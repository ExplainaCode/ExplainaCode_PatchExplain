record_number,buggy_code,fixed_code,code_similarity
181001,"public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_USE_STATIC_IP)) {
    boolean value=((Boolean)newValue).booleanValue();
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_USE_STATIC_IP,value ? 1 : 0);
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
    for (int i=0; i < mSettingNames.length; i++) {
      if (key.equals(mPreferenceKeys[i])) {
        Settings.System.putString(getContentResolver(),mSettingNames[i],value);
        break;
      }
    }
  }
  return true;
}",0.8282760920306769
181002,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  mUseStaticIpCheckBox.setOnPreferenceChangeListener(this);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}",0.9360341151385928
181003,"public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_USE_STATIC_IP)) {
    boolean value=((Boolean)newValue).booleanValue();
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_USE_STATIC_IP,value ? 1 : 0);
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
    for (int i=0; i < mSettingNames.length; i++) {
      if (key.equals(mPreferenceKeys[i])) {
        Settings.System.putString(getContentResolver(),mSettingNames[i],value);
        break;
      }
    }
  }
  return true;
}",0.8282760920306769
181004,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  mUseStaticIpCheckBox.setOnPreferenceChangeListener(this);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}",0.9360341151385928
181005,"public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object newValue){
  String key=preference.getKey();
  if (key == null)   return true;
  if (key.equals(KEY_NUM_CHANNELS)) {
    try {
      int numChannels=Integer.parseInt((String)newValue);
      WifiManager wifiManager=(WifiManager)getSystemService(WIFI_SERVICE);
      if (!wifiManager.setNumAllowedChannels(numChannels,true)) {
        Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      }
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_num_channels_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_SLEEP_POLICY)) {
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_SLEEP_POLICY,Integer.parseInt(((String)newValue)));
    }
 catch (    NumberFormatException e) {
      Toast.makeText(this,R.string.wifi_setting_sleep_policy_error,Toast.LENGTH_SHORT).show();
      return false;
    }
  }
 else   if (key.equals(KEY_USE_STATIC_IP)) {
    boolean value=((Boolean)newValue).booleanValue();
    try {
      Settings.System.putInt(getContentResolver(),Settings.System.WIFI_USE_STATIC_IP,value ? 1 : 0);
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
 else {
    String value=(String)newValue;
    if (!isIpAddress(value)) {
      Toast.makeText(this,R.string.wifi_ip_settings_invalid_ip,Toast.LENGTH_LONG).show();
      return false;
    }
    preference.setSummary(value);
    for (int i=0; i < mSettingNames.length; i++) {
      if (key.equals(mPreferenceKeys[i])) {
        Settings.System.putString(getContentResolver(),mSettingNames[i],value);
        break;
      }
    }
  }
  return true;
}",0.8282760920306769
181006,"public void updatePackage(String pkgName,long size,String formattedSize){
  ApplicationInfo info=null;
  try {
    info=mPm.getApplicationInfo(pkgName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    return;
  }
  AppInfo aInfo=mCache.getEntry(pkgName);
  if (aInfo != null) {
    aInfo.refreshLabel(info.loadLabel(mPm));
    aInfo.refreshIcon(info.loadIcon(mPm));
    aInfo.setSize(size,formattedSize);
    notifyDataSetChanged();
  }
}","public void updatePackage(String pkgName,long size,String formattedSize){
  ApplicationInfo info=null;
  try {
    info=mPm.getApplicationInfo(pkgName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    return;
  }
  AppInfo aInfo=mCache.getEntry(pkgName);
  if (aInfo != null) {
    CharSequence label=info.loadLabel(mPm);
    aInfo.refreshLabel(label);
    aInfo.refreshIcon(info.loadIcon(mPm));
    aInfo.setSize(size,formattedSize);
    addLocalEntry(info,label);
    notifyDataSetChanged();
  }
}",0.9099901088031652
181007,"private boolean updateAppList(List<ApplicationInfo> newList){
  if ((newList == null) || mCache.isEmpty()) {
    return false;
  }
  Set<String> existingList=new HashSet<String>();
  boolean ret=false;
  for (  ApplicationInfo info : newList) {
    String pkgName=info.packageName;
    AppInfo aInfo=mCache.getEntry(pkgName);
    if (aInfo != null) {
      existingList.add(pkgName);
    }
 else {
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      updatePackageList(Intent.ACTION_PACKAGE_ADDED,pkgName);
      ret=true;
    }
  }
  List<String> deletedList=null;
  Set<String> staleList=mCache.getPkgList();
  for (  String pkgName : staleList) {
    if (!existingList.contains(pkgName)) {
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      if (deletedList == null) {
        deletedList=new ArrayList<String>();
        deletedList.add(pkgName);
      }
      ret=true;
    }
  }
  if (deletedList != null) {
    mAppInfoAdapter.removeFromList(deletedList);
  }
  return ret;
}","private boolean updateAppList(List<ApplicationInfo> newList){
  if ((newList == null) || mCache.isEmpty()) {
    return false;
  }
  Set<String> existingList=new HashSet<String>();
  boolean ret=false;
  int N=newList.size();
  for (int i=(N - 1); i >= 0; i--) {
    ApplicationInfo info=newList.get(i);
    String pkgName=info.packageName;
    AppInfo aInfo=mCache.getEntry(pkgName);
    if (aInfo != null) {
      existingList.add(pkgName);
    }
 else {
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      updatePackageList(Intent.ACTION_PACKAGE_ADDED,pkgName);
      newList.remove(i);
      ret=true;
    }
  }
  List<String> deletedList=null;
  Set<String> staleList=mCache.getPkgList();
  for (  String pkgName : staleList) {
    if (!existingList.contains(pkgName)) {
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      if (deletedList == null) {
        deletedList=new ArrayList<String>();
        deletedList.add(pkgName);
      }
      ret=true;
    }
  }
  if (deletedList != null) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mAppInfoAdapter.removeFromList(deletedList);
  }
  return ret;
}",0.9297392841361024
181008,"public void addToList(String pkgName,long size,String formattedSize){
  if (pkgName == null) {
    return;
  }
  boolean notInList=true;
  ApplicationInfo info=null;
  try {
    info=mPm.getApplicationInfo(pkgName,0);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + pkgName);
    return;
  }
  if (info == null) {
    Log.i(TAG,""String_Node_Str"" + pkgName);
    return;
  }
  mAppList.add(info);
  CharSequence label=info.loadLabel(mPm);
  mCache.addEntry(new AppInfo(pkgName,-1,label,info.loadIcon(mPm),size,formattedSize));
  if (notInList && (shouldBeInList(mFilterApps,info))) {
    int newIdx=Collections.binarySearch(mAppLocalList,info,getAppComparator(mSortOrder));
    if (newIdx >= 0) {
      Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      return;
    }
    newIdx=-newIdx - 1;
    addFilterListLocked(newIdx,info,label);
    adjustIndex();
    notifyDataSetChanged();
  }
}","public void addToList(String pkgName,long size,String formattedSize){
  if (pkgName == null) {
    return;
  }
  ApplicationInfo info=null;
  try {
    info=mPm.getApplicationInfo(pkgName,0);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + pkgName);
    return;
  }
  if (info == null) {
    Log.i(TAG,""String_Node_Str"" + pkgName);
    return;
  }
  mAppList.add(info);
  CharSequence label=info.loadLabel(mPm);
  mCache.addEntry(new AppInfo(pkgName,-1,label,info.loadIcon(mPm),size,formattedSize));
  if (addLocalEntry(info,label)) {
    notifyDataSetChanged();
  }
}",0.7506561679790026
181009,"public void handleMessage(Message msg){
  boolean status;
  long size;
  String formattedSize;
  ApplicationInfo info;
  Bundle data;
  String pkgName=null;
  AppInfo appInfo;
  data=msg.getData();
  if (data != null) {
    pkgName=data.getString(ATTR_PKG_NAME);
  }
switch (msg.what) {
case INIT_PKG_INFO:
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + mJustCreated);
  List<ApplicationInfo> newList=null;
if (!mJustCreated) {
  newList=getInstalledApps(FILTER_APPS_ALL);
  updateAppList(newList);
}
initAppList(newList,mFilterApps);
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case COMPUTE_BULK_SIZE:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
String[] pkgs=data.getStringArray(ATTR_PKGS);
long[] sizes=data.getLongArray(ATTR_STATS);
String[] formatted=data.getStringArray(ATTR_SIZE_STRS);
if (pkgs == null || sizes == null || formatted == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
mAppInfoAdapter.bulkUpdateSizes(pkgs,sizes,formatted);
break;
case COMPUTE_END:
mComputeSizes=true;
mFirst=true;
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case REMOVE_PKG:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
if (!mComputeSizes) {
Boolean currB=mAddRemoveMap.get(pkgName);
if (currB == null || (currB.equals(Boolean.TRUE))) {
mAddRemoveMap.put(pkgName,Boolean.FALSE);
}
break;
}
List<String> pkgList=new ArrayList<String>();
pkgList.add(pkgName);
mAppInfoAdapter.removeFromList(pkgList);
break;
case REORDER_LIST:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
int menuOption=msg.arg1;
if ((menuOption == SORT_ORDER_ALPHA) || (menuOption == SORT_ORDER_SIZE)) {
if (menuOption != mSortOrder) {
mSortOrder=menuOption;
if (localLOGV) Log.i(TAG,""String_Node_Str"" + mSortOrder);
mAppInfoAdapter.sortList(mSortOrder);
}
}
 else if (menuOption != mFilterApps) {
mFilterApps=menuOption;
boolean ret=mAppInfoAdapter.resetAppList(mFilterApps);
if (!ret) {
mFilterApps=FILTER_APPS_ALL;
mHandler.sendEmptyMessage(INIT_PKG_INFO);
sendMessageToHandler(REORDER_LIST,menuOption);
}
}
break;
case ADD_PKG_START:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
if (!mComputeSizes || !mLoadLabels) {
Boolean currB=mAddRemoveMap.get(pkgName);
if (currB == null || (currB.equals(Boolean.FALSE))) {
mAddRemoveMap.put(pkgName,Boolean.TRUE);
}
break;
}
try {
info=mPm.getApplicationInfo(pkgName,0);
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"" + pkgName);
break;
}
mObserver.invokeGetSizeInfo(pkgName);
break;
case ADD_PKG_DONE:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
status=data.getBoolean(ATTR_GET_SIZE_STATUS);
if (status) {
size=data.getLong(ATTR_PKG_STATS);
formattedSize=data.getString(ATTR_PKG_SIZE_STR);
int idx=mAppInfoAdapter.getIndex(pkgName);
if (idx == -1) {
mAppInfoAdapter.addToList(pkgName,size,formattedSize);
}
 else {
mAppInfoAdapter.updatePackage(pkgName,size,formattedSize);
}
}
break;
case REFRESH_LABELS:
Map<String,CharSequence> labelMap=(Map<String,CharSequence>)msg.obj;
if (labelMap != null) {
mAppInfoAdapter.bulkUpdateLabels(labelMap);
}
break;
case REFRESH_ICONS:
Map<String,Drawable> iconMap=(Map<String,Drawable>)msg.obj;
if (iconMap != null) {
mAppInfoAdapter.bulkUpdateIcons(iconMap);
}
break;
case REFRESH_DONE:
mLoadLabels=true;
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case NEXT_LOAD_STEP:
if (!mCache.isEmpty() && mSetListViewLater) {
if (localLOGV) Log.i(TAG,""String_Node_Str"");
initListView();
mSetListViewLater=false;
mFirst=true;
}
if (mComputeSizes && mLoadLabels) {
doneLoadingData();
Set<String> keys=mAddRemoveMap.keySet();
for (String key : keys) {
if (mAddRemoveMap.get(key) == Boolean.TRUE) {
updatePackageList(Intent.ACTION_PACKAGE_ADDED,key);
}
 else {
updatePackageList(Intent.ACTION_PACKAGE_REMOVED,key);
}
}
mAddRemoveMap.clear();
}
 else if (!mComputeSizes && !mLoadLabels) {
if (mSizesFirst) {
initComputeSizes();
}
 else {
initResourceThread();
}
}
 else {
if (mSetListViewLater) {
if (localLOGV) Log.i(TAG,""String_Node_Str"");
initListView();
mSetListViewLater=false;
}
if (!mComputeSizes) {
initComputeSizes();
}
 else if (!mLoadLabels) {
initResourceThread();
}
}
break;
default :
break;
}
}","public void handleMessage(Message msg){
  boolean status;
  long size;
  String formattedSize;
  ApplicationInfo info;
  Bundle data;
  String pkgName=null;
  AppInfo appInfo;
  data=msg.getData();
  if (data != null) {
    pkgName=data.getString(ATTR_PKG_NAME);
  }
switch (msg.what) {
case INIT_PKG_INFO:
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + mJustCreated);
  List<ApplicationInfo> newList=null;
if (!mJustCreated) {
  if (localLOGV)   Log.i(TAG,""String_Node_Str"");
  newList=getInstalledApps(FILTER_APPS_ALL);
  updateAppList(newList);
}
initAppList(newList,mFilterApps);
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case COMPUTE_BULK_SIZE:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
String[] pkgs=data.getStringArray(ATTR_PKGS);
long[] sizes=data.getLongArray(ATTR_STATS);
String[] formatted=data.getStringArray(ATTR_SIZE_STRS);
if (pkgs == null || sizes == null || formatted == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
mAppInfoAdapter.bulkUpdateSizes(pkgs,sizes,formatted);
break;
case COMPUTE_END:
mComputeSizes=true;
mFirst=true;
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case REMOVE_PKG:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
if (!mComputeSizes) {
Boolean currB=mAddRemoveMap.get(pkgName);
if (currB == null || (currB.equals(Boolean.TRUE))) {
mAddRemoveMap.put(pkgName,Boolean.FALSE);
}
break;
}
List<String> pkgList=new ArrayList<String>();
pkgList.add(pkgName);
mAppInfoAdapter.removeFromList(pkgList);
break;
case REORDER_LIST:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
int menuOption=msg.arg1;
if ((menuOption == SORT_ORDER_ALPHA) || (menuOption == SORT_ORDER_SIZE)) {
if (menuOption != mSortOrder) {
mSortOrder=menuOption;
if (localLOGV) Log.i(TAG,""String_Node_Str"" + mSortOrder);
mAppInfoAdapter.sortList(mSortOrder);
}
}
 else if (menuOption != mFilterApps) {
mFilterApps=menuOption;
boolean ret=mAppInfoAdapter.resetAppList(mFilterApps);
if (!ret) {
mFilterApps=FILTER_APPS_ALL;
mHandler.sendEmptyMessage(INIT_PKG_INFO);
sendMessageToHandler(REORDER_LIST,menuOption);
}
}
break;
case ADD_PKG_START:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
if (!mComputeSizes || !mLoadLabels) {
Boolean currB=mAddRemoveMap.get(pkgName);
if (currB == null || (currB.equals(Boolean.FALSE))) {
mAddRemoveMap.put(pkgName,Boolean.TRUE);
}
break;
}
try {
info=mPm.getApplicationInfo(pkgName,0);
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"" + pkgName);
break;
}
mObserver.invokeGetSizeInfo(pkgName);
break;
case ADD_PKG_DONE:
if (localLOGV) Log.i(TAG,""String_Node_Str"");
if (pkgName == null) {
Log.w(TAG,""String_Node_Str"");
break;
}
status=data.getBoolean(ATTR_GET_SIZE_STATUS);
if (status) {
size=data.getLong(ATTR_PKG_STATS);
formattedSize=data.getString(ATTR_PKG_SIZE_STR);
if (!mAppInfoAdapter.isInstalled(pkgName)) {
mAppInfoAdapter.addToList(pkgName,size,formattedSize);
}
 else {
mAppInfoAdapter.updatePackage(pkgName,size,formattedSize);
}
}
break;
case REFRESH_LABELS:
Map<String,CharSequence> labelMap=(Map<String,CharSequence>)msg.obj;
if (labelMap != null) {
mAppInfoAdapter.bulkUpdateLabels(labelMap);
}
break;
case REFRESH_ICONS:
Map<String,Drawable> iconMap=(Map<String,Drawable>)msg.obj;
if (iconMap != null) {
mAppInfoAdapter.bulkUpdateIcons(iconMap);
}
break;
case REFRESH_DONE:
mLoadLabels=true;
mHandler.sendEmptyMessage(NEXT_LOAD_STEP);
break;
case NEXT_LOAD_STEP:
if (!mCache.isEmpty() && mSetListViewLater) {
if (localLOGV) Log.i(TAG,""String_Node_Str"");
initListView();
mSetListViewLater=false;
mFirst=true;
}
if (mComputeSizes && mLoadLabels) {
doneLoadingData();
Set<String> keys=mAddRemoveMap.keySet();
for (String key : keys) {
if (mAddRemoveMap.get(key) == Boolean.TRUE) {
updatePackageList(Intent.ACTION_PACKAGE_ADDED,key);
}
 else {
updatePackageList(Intent.ACTION_PACKAGE_REMOVED,key);
}
}
mAddRemoveMap.clear();
}
 else if (!mComputeSizes && !mLoadLabels) {
if (mSizesFirst) {
initComputeSizes();
}
 else {
initResourceThread();
}
}
 else {
if (mSetListViewLater) {
if (localLOGV) Log.i(TAG,""String_Node_Str"");
initListView();
mSetListViewLater=false;
}
if (!mComputeSizes) {
initComputeSizes();
}
 else if (!mLoadLabels) {
initResourceThread();
}
}
break;
default :
break;
}
}",0.9873772791023844
181010,"/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INSTALLATION);
    }
  }
}","/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivity(intent);
    }
  }
}",0.9320252277505257
181011,"@Override protected void onResume(){
  super.onResume();
  mWifiEnabler.resume();
  mAirplaneModeEnabler.resume();
  mBtEnabler.resume();
}","@Override protected void onResume(){
  super.onResume();
  mWifiEnabler.resume();
  mBtEnabler.resume();
  mAirplaneModeEnabler.resume();
}",0.8345323741007195
181012,"/** 
 * Sets the state of the preferences for enabling/disabling AccessibilityServices.
 * @param isEnabled If to enable or disable the preferences.
 */
private void setAccessibilityServicePreferencesState(boolean isEnabled){
  if (mAccessibilityServicesCategory == null) {
    return;
  }
  int count=mAccessibilityServicesCategory.getPreferenceCount();
  for (int i=0; i < count; i++) {
    mAccessibilityServicesCategory.getPreference(i).setEnabled(isEnabled);
  }
}","/** 
 * Sets the state of the preferences for enabling/disabling AccessibilityServices.
 * @param isEnabled If to enable or disable the preferences.
 */
private void setAccessibilityServicePreferencesState(boolean isEnabled){
  if (mAccessibilityServicesCategory == null) {
    return;
  }
  int count=mAccessibilityServicesCategory.getPreferenceCount();
  for (int i=0; i < count; i++) {
    Preference pref=mAccessibilityServicesCategory.getPreference(i);
    pref.setEnabled(isEnabled);
    if (!isEnabled) {
      ((CheckBoxPreference)pref).setChecked(false);
    }
  }
}",0.8984674329501916
181013,"@Override protected void onResume(){
  super.onResume();
  mDevicePreferenceMap.clear();
  mDeviceList.removeAll();
  addDevices();
  mEnabler.resume();
  mDiscoverableEnabler.resume();
  mNamePreference.resume();
  mLocalManager.registerCallback(this);
  mLocalManager.startScanning(false);
  registerReceiver(mReceiver,new IntentFilter(BluetoothIntent.BLUETOOTH_STATE_CHANGED_ACTION));
  mLocalManager.setForegroundActivity(this);
}","@Override protected void onResume(){
  super.onResume();
  mDevicePreferenceMap.clear();
  mDeviceList.removeAll();
  addDevices();
  mEnabler.resume();
  mDiscoverableEnabler.resume();
  mNamePreference.resume();
  mLocalManager.registerCallback(this);
  mDeviceList.setProgress(mLocalManager.getBluetoothManager().isDiscovering());
  mLocalManager.startScanning(false);
  registerReceiver(mReceiver,new IntentFilter(BluetoothIntent.BLUETOOTH_STATE_CHANGED_ACTION));
  mLocalManager.setForegroundActivity(this);
}",0.9156118143459916
181014,"@Override public boolean isEnabled(){
  return super.isEnabled() && !mIsBusy;
}","@Override public boolean isEnabled(){
  setEnabled(true);
  return super.isEnabled() && !mIsBusy;
}",0.8876404494382022
181015,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}",0.8739837398373984
181016,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}",0.8739837398373984
181017,"@Override public boolean isEnabled(){
  return super.isEnabled() && !mIsBusy;
}","@Override public boolean isEnabled(){
  setEnabled(true);
  return super.isEnabled() && !mIsBusy;
}",0.8876404494382022
181018,"/** 
 * Called when we need to set our member variables to point to the views. 
 */
private void onReferenceViews(View view){
  mPasswordText=(TextView)view.findViewById(R.id.password_text);
  mPasswordEdit=(EditText)view.findViewById(R.id.password_edit);
  mSsidText=(TextView)view.findViewById(R.id.ssid_text);
  mSsidEdit=(EditText)view.findViewById(R.id.ssid_edit);
  mSecurityText=(TextView)view.findViewById(R.id.security_text);
  mSecuritySpinner=(Spinner)view.findViewById(R.id.security_spinner);
  mWepTypeSpinner=(Spinner)view.findViewById(R.id.wep_type_spinner);
  mEnterpriseView=mView.findViewById(R.id.enterprise_wrapper);
  mShowPasswordCheckBox=(CheckBox)view.findViewById(R.id.show_password_checkbox);
  if (mShowPasswordCheckBox != null) {
    mShowPasswordCheckBox.setOnClickListener(this);
  }
  if (mMode == MODE_CONFIGURE) {
    mSecuritySpinner.setOnItemSelectedListener(this);
    mSecuritySpinner.setPromptId(R.string.security);
    setSpinnerAdapter(mSecuritySpinner,mAutoSecurityAllowed ? R.array.wifi_security_entries : R.array.wifi_security_without_auto_entries);
  }
 else   if (mMode == MODE_INFO) {
    mTable=(ViewGroup)view.findViewById(R.id.table);
  }
  if (mMode == MODE_CONFIGURE || (mState.isEnterprise() && !mState.configured)) {
    setEnterpriseFields(view);
    mPhase2Spinner.setSelection(getSelectionIndex(R.array.wifi_phase2_entries,mState.getPhase2()));
    mEapSpinner.setSelection(getSelectionIndex(R.array.wifi_eap_entries,mState.getEap()));
    mClientCertSpinner.setSelection(getSelectionIndex(getAllUserCertificateKeys(),mState.getEnterpriseField(AccessPointState.CLIENT_CERT)));
    mCaCertSpinner.setSelection(getSelectionIndex(getAllCaCertificateKeys(),mState.getEnterpriseField(AccessPointState.CA_CERT)));
  }
}","/** 
 * Called when we need to set our member variables to point to the views. 
 */
private void onReferenceViews(View view){
  mPasswordText=(TextView)view.findViewById(R.id.password_text);
  mPasswordEdit=(EditText)view.findViewById(R.id.password_edit);
  mSsidText=(TextView)view.findViewById(R.id.ssid_text);
  mSsidEdit=(EditText)view.findViewById(R.id.ssid_edit);
  mSecurityText=(TextView)view.findViewById(R.id.security_text);
  mSecuritySpinner=(Spinner)view.findViewById(R.id.security_spinner);
  mWepTypeSpinner=(Spinner)view.findViewById(R.id.wep_type_spinner);
  mEnterpriseView=mView.findViewById(R.id.enterprise_wrapper);
  mShowPasswordCheckBox=(CheckBox)view.findViewById(R.id.show_password_checkbox);
  if (mShowPasswordCheckBox != null) {
    mShowPasswordCheckBox.setOnClickListener(this);
  }
  if (mMode == MODE_CONFIGURE) {
    mSecuritySpinner.setOnItemSelectedListener(this);
    mSecuritySpinner.setPromptId(R.string.security);
    setSpinnerAdapter(mSecuritySpinner,mAutoSecurityAllowed ? R.array.wifi_security_entries : R.array.wifi_security_without_auto_entries);
  }
 else   if (mMode == MODE_INFO) {
    mTable=(ViewGroup)view.findViewById(R.id.table);
  }
  if (mMode == MODE_CONFIGURE || (mState.isEnterprise() && !mState.configured)) {
    setEnterpriseFields(view);
    updateCertificateSelection();
  }
}",0.8510775168864587
181019,"private void handleSecurityChange(int security){
  setEnterpriseFieldsVisible(false);
switch (security) {
case SECURITY_NONE:
{
      setWepVisible(false);
      setGenericPasswordVisible(false);
      break;
    }
case SECURITY_WEP:
{
    setGenericPasswordVisible(false);
    setWepVisible(true);
    updatePasswordCaption(AccessPointState.WEP);
    break;
  }
case SECURITY_AUTO:
{
  setWepVisible(false);
  setGenericPasswordVisible(mState.hasSecurity());
  updatePasswordCaption(AccessPointState.WPA);
  break;
}
case SECURITY_WPA_PERSONAL:
case SECURITY_WPA2_PERSONAL:
{
setWepVisible(false);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
case SECURITY_WPA_EAP:
case SECURITY_IEEE8021X:
{
if (Keystore.getInstance().getState() != Keystore.UNLOCKED) {
getContext().startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
mSecuritySpinner.setSelection(0);
return;
}
setEnterpriseFieldsVisible(true);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
}
}","private void handleSecurityChange(int security){
  setEnterpriseFieldsVisible(false);
switch (security) {
case SECURITY_NONE:
{
      setWepVisible(false);
      setGenericPasswordVisible(false);
      break;
    }
case SECURITY_WEP:
{
    setGenericPasswordVisible(false);
    setWepVisible(true);
    updatePasswordCaption(AccessPointState.WEP);
    break;
  }
case SECURITY_AUTO:
{
  setWepVisible(false);
  setGenericPasswordVisible(mState.hasSecurity());
  updatePasswordCaption(AccessPointState.WPA);
  break;
}
case SECURITY_WPA_PERSONAL:
case SECURITY_WPA2_PERSONAL:
{
setWepVisible(false);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
case SECURITY_WPA_EAP:
case SECURITY_IEEE8021X:
{
if (Keystore.getInstance().getState() != Keystore.UNLOCKED) {
getContext().startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
return;
}
enableEnterpriseFields();
break;
}
}
}",0.9327983951855566
181020,"private void showAddOtherNetworkDialog(){
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setState(new AccessPointState(this));
  dialog.setMode(AccessPointDialog.MODE_CONFIGURE);
  dialog.setTitle(R.string.wifi_add_other_network);
  dialog.setAutoSecurityAllowed(false);
  showDialog(dialog);
}","private void showAddOtherNetworkDialog(){
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setState(new AccessPointState(this));
  dialog.setMode(AccessPointDialog.MODE_CONFIGURE);
  dialog.setTitle(R.string.wifi_add_other_network);
  dialog.setAutoSecurityAllowed(false);
  mResumeMode=AccessPointDialog.MODE_CONFIGURE;
  showDialog(dialog);
}",0.930835734870317
181021,"public void showAccessPointDialog(AccessPointState state,int mode){
  if (state.isEnterprise() && Keystore.getInstance().getState() != Keystore.UNLOCKED) {
    startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
    return;
  }
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setMode(mode);
  dialog.setState(state);
  showDialog(dialog);
}","public void showAccessPointDialog(AccessPointState state,int mode){
  if (state.isEnterprise() && Keystore.getInstance().getState() != Keystore.UNLOCKED) {
    startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
    mResumeState=state;
    mResumeMode=mode;
    return;
  }
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setMode(mode);
  dialog.setState(state);
  showDialog(dialog);
}",0.9376498800959232
181022,"/** 
 * {@inheritDoc}
 */
public void onDismiss(DialogInterface dialog){
  if (dialog == mDialog) {
    mDialog=null;
  }
}","/** 
 * {@inheritDoc}
 */
public void onDismiss(DialogInterface dialog){
  if (dialog == mDialog) {
    mDialog=null;
    mResumeMode=-1;
  }
}",0.924812030075188
181023,"@Override protected void onResume(){
  super.onResume();
  mWifiLayer.onResume();
  mWifiEnabler.resume();
}","@Override protected void onResume(){
  super.onResume();
  mWifiLayer.onResume();
  mWifiEnabler.resume();
  if (mResumeState != null) {
    if (Keystore.getInstance().getState() == Keystore.UNLOCKED) {
      showAccessPointDialog(mResumeState,mResumeMode);
    }
    mResumeMode=-1;
    mResumeState=null;
  }
 else {
    if (mResumeMode == AccessPointDialog.MODE_CONFIGURE) {
      if (Keystore.getInstance().getState() == Keystore.UNLOCKED) {
        ((AccessPointDialog)mDialog).enableEnterpriseFields();
      }
    }
  }
}",0.3396226415094339
181024,"/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(""String_Node_Str"");
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INSTALLATION);
    }
  }
}","/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INSTALLATION);
    }
  }
}",0.963872832369942
181025,"/** 
 * Ask the current default engine to launch the matching CHECK_TTS_DATA activity to check the required TTS files are properly installed.
 */
private void checkVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(""String_Node_Str"");
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INTEGRITY_CHECK);
    }
  }
}","/** 
 * Ask the current default engine to launch the matching CHECK_TTS_DATA activity to check the required TTS files are properly installed.
 */
private void checkVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INTEGRITY_CHECK);
    }
  }
}",0.9640804597701148
181026,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.TTS_SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.9929078014184396
181027,"/** 
 * Called when mPlayExample or mInstallData is clicked
 */
public boolean onPreferenceClick(Preference preference){
  if (preference == mPlayExample) {
    if (mTts != null) {
      mTts.speak(getResources().getString(R.string.tts_demo),TextToSpeech.TTS_QUEUE_FLUSH,null);
    }
    return true;
  }
  if (preference == mInstallData) {
    installVoiceData();
    finish();
    return true;
  }
  return false;
}","/** 
 * Called when mPlayExample or mInstallData is clicked
 */
public boolean onPreferenceClick(Preference preference){
  if (preference == mPlayExample) {
    if (mTts != null) {
      mTts.speak(getResources().getString(R.string.tts_demo),TextToSpeech.QUEUE_FLUSH,null);
    }
    return true;
  }
  if (preference == mInstallData) {
    installVoiceData();
    finish();
    return true;
  }
  return false;
}",0.9951807228915662
181028,"private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language == null) {
    Locale currentLocale=Locale.getDefault();
    language=currentLocale.getISO3Language();
    country=currentLocale.getISO3Country();
    variant=currentLocale.getVariant();
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  mDefaultLanguage=language;
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country == null) {
      Locale currentLocale=Locale.getDefault();
      country=currentLocale.getISO3Country();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultCountry=country;
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant == null) {
      Locale currentLocale=Locale.getDefault();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultLocVariant=variant;
  setDefaultLocalePref(language,country,variant);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}","private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language == null) {
    Locale currentLocale=Locale.getDefault();
    language=currentLocale.getISO3Language();
    country=currentLocale.getISO3Country();
    variant=currentLocale.getVariant();
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  mDefaultLanguage=language;
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country == null) {
      Locale currentLocale=Locale.getDefault();
      country=currentLocale.getISO3Country();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultCountry=country;
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant == null) {
      Locale currentLocale=Locale.getDefault();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultLocVariant=variant;
  setDefaultLocalePref(language,country,variant);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}",0.8731231231231231
181029,"/** 
 * Called when we need to set our member variables to point to the views. 
 */
private void onReferenceViews(View view){
  mPasswordText=(TextView)view.findViewById(R.id.password_text);
  mPasswordEdit=(EditText)view.findViewById(R.id.password_edit);
  mSsidText=(TextView)view.findViewById(R.id.ssid_text);
  mSsidEdit=(EditText)view.findViewById(R.id.ssid_edit);
  mSecurityText=(TextView)view.findViewById(R.id.security_text);
  mSecuritySpinner=(Spinner)view.findViewById(R.id.security_spinner);
  mWepTypeSpinner=(Spinner)view.findViewById(R.id.wep_type_spinner);
  mEnterpriseView=mView.findViewById(R.id.enterprise_wrapper);
  mShowPasswordCheckBox=(CheckBox)view.findViewById(R.id.show_password_checkbox);
  if (mShowPasswordCheckBox != null) {
    mShowPasswordCheckBox.setOnClickListener(this);
  }
  if (mMode == MODE_CONFIGURE) {
    mSecuritySpinner.setOnItemSelectedListener(this);
    mSecuritySpinner.setPromptId(R.string.security);
    setSpinnerAdapter(mSecuritySpinner,mAutoSecurityAllowed ? R.array.wifi_security_entries : R.array.wifi_security_without_auto_entries);
  }
 else   if (mMode == MODE_INFO) {
    mTable=(ViewGroup)view.findViewById(R.id.table);
  }
  if (mMode == MODE_CONFIGURE || (mState.isEnterprise() && !mState.configured)) {
    setEnterpriseFields(view);
    mPhase2Spinner.setSelection(getSelectionIndex(R.array.wifi_phase2_entries,mState.getPhase2()));
    mEapSpinner.setSelection(getSelectionIndex(R.array.wifi_eap_entries,mState.getEap()));
    mClientCertSpinner.setSelection(getSelectionIndex(getAllUserCertificateKeys(),mState.getEnterpriseField(AccessPointState.CLIENT_CERT)));
    mCaCertSpinner.setSelection(getSelectionIndex(getAllCaCertificateKeys(),mState.getEnterpriseField(AccessPointState.CA_CERT)));
  }
}","/** 
 * Called when we need to set our member variables to point to the views. 
 */
private void onReferenceViews(View view){
  mPasswordText=(TextView)view.findViewById(R.id.password_text);
  mPasswordEdit=(EditText)view.findViewById(R.id.password_edit);
  mSsidText=(TextView)view.findViewById(R.id.ssid_text);
  mSsidEdit=(EditText)view.findViewById(R.id.ssid_edit);
  mSecurityText=(TextView)view.findViewById(R.id.security_text);
  mSecuritySpinner=(Spinner)view.findViewById(R.id.security_spinner);
  mWepTypeSpinner=(Spinner)view.findViewById(R.id.wep_type_spinner);
  mEnterpriseView=mView.findViewById(R.id.enterprise_wrapper);
  mShowPasswordCheckBox=(CheckBox)view.findViewById(R.id.show_password_checkbox);
  if (mShowPasswordCheckBox != null) {
    mShowPasswordCheckBox.setOnClickListener(this);
  }
  if (mMode == MODE_CONFIGURE) {
    mSecuritySpinner.setOnItemSelectedListener(this);
    mSecuritySpinner.setPromptId(R.string.security);
    setSpinnerAdapter(mSecuritySpinner,mAutoSecurityAllowed ? R.array.wifi_security_entries : R.array.wifi_security_without_auto_entries);
  }
 else   if (mMode == MODE_INFO) {
    mTable=(ViewGroup)view.findViewById(R.id.table);
  }
  if (mMode == MODE_CONFIGURE || (mState.isEnterprise() && !mState.configured)) {
    setEnterpriseFields(view);
    updateCertificateSelection();
  }
}",0.8510775168864587
181030,"private void handleSecurityChange(int security){
  setEnterpriseFieldsVisible(false);
switch (security) {
case SECURITY_NONE:
{
      setWepVisible(false);
      setGenericPasswordVisible(false);
      break;
    }
case SECURITY_WEP:
{
    setGenericPasswordVisible(false);
    setWepVisible(true);
    updatePasswordCaption(AccessPointState.WEP);
    break;
  }
case SECURITY_AUTO:
{
  setWepVisible(false);
  setGenericPasswordVisible(mState.hasSecurity());
  updatePasswordCaption(AccessPointState.WPA);
  break;
}
case SECURITY_WPA_PERSONAL:
case SECURITY_WPA2_PERSONAL:
{
setWepVisible(false);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
case SECURITY_WPA_EAP:
case SECURITY_IEEE8021X:
{
if (Keystore.getInstance().getState() != Keystore.UNLOCKED) {
getContext().startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
mSecuritySpinner.setSelection(0);
return;
}
setEnterpriseFieldsVisible(true);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
}
}","private void handleSecurityChange(int security){
  setEnterpriseFieldsVisible(false);
switch (security) {
case SECURITY_NONE:
{
      setWepVisible(false);
      setGenericPasswordVisible(false);
      break;
    }
case SECURITY_WEP:
{
    setGenericPasswordVisible(false);
    setWepVisible(true);
    updatePasswordCaption(AccessPointState.WEP);
    break;
  }
case SECURITY_AUTO:
{
  setWepVisible(false);
  setGenericPasswordVisible(mState.hasSecurity());
  updatePasswordCaption(AccessPointState.WPA);
  break;
}
case SECURITY_WPA_PERSONAL:
case SECURITY_WPA2_PERSONAL:
{
setWepVisible(false);
setGenericPasswordVisible(true);
updatePasswordCaption(AccessPointState.WPA);
break;
}
case SECURITY_WPA_EAP:
case SECURITY_IEEE8021X:
{
if (Keystore.getInstance().getState() != Keystore.UNLOCKED) {
getContext().startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
return;
}
enableEnterpriseFields();
break;
}
}
}",0.9327983951855566
181031,"private void showAddOtherNetworkDialog(){
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setState(new AccessPointState(this));
  dialog.setMode(AccessPointDialog.MODE_CONFIGURE);
  dialog.setTitle(R.string.wifi_add_other_network);
  dialog.setAutoSecurityAllowed(false);
  showDialog(dialog);
}","private void showAddOtherNetworkDialog(){
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setState(new AccessPointState(this));
  dialog.setMode(AccessPointDialog.MODE_CONFIGURE);
  dialog.setTitle(R.string.wifi_add_other_network);
  dialog.setAutoSecurityAllowed(false);
  mResumeMode=AccessPointDialog.MODE_CONFIGURE;
  showDialog(dialog);
}",0.930835734870317
181032,"public void showAccessPointDialog(AccessPointState state,int mode){
  if (state.isEnterprise() && Keystore.getInstance().getState() != Keystore.UNLOCKED) {
    startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
    return;
  }
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setMode(mode);
  dialog.setState(state);
  showDialog(dialog);
}","public void showAccessPointDialog(AccessPointState state,int mode){
  if (state.isEnterprise() && Keystore.getInstance().getState() != Keystore.UNLOCKED) {
    startActivity(new Intent(SecuritySettings.ACTION_UNLOCK_CREDENTIAL_STORAGE));
    mResumeState=state;
    mResumeMode=mode;
    return;
  }
  AccessPointDialog dialog=new AccessPointDialog(this,mWifiLayer);
  dialog.setMode(mode);
  dialog.setState(state);
  showDialog(dialog);
}",0.9376498800959232
181033,"/** 
 * {@inheritDoc}
 */
public void onDismiss(DialogInterface dialog){
  if (dialog == mDialog) {
    mDialog=null;
  }
}","/** 
 * {@inheritDoc}
 */
public void onDismiss(DialogInterface dialog){
  if (dialog == mDialog) {
    mDialog=null;
    mResumeMode=-1;
  }
}",0.924812030075188
181034,"@Override protected void onResume(){
  super.onResume();
  mWifiLayer.onResume();
  mWifiEnabler.resume();
}","@Override protected void onResume(){
  super.onResume();
  mWifiLayer.onResume();
  mWifiEnabler.resume();
  if (mResumeState != null) {
    if (Keystore.getInstance().getState() == Keystore.UNLOCKED) {
      showAccessPointDialog(mResumeState,mResumeMode);
    }
    mResumeMode=-1;
    mResumeState=null;
  }
 else {
    if (mResumeMode == AccessPointDialog.MODE_CONFIGURE) {
      if (Keystore.getInstance().getState() == Keystore.UNLOCKED) {
        ((AccessPointDialog)mDialog).enableEnterpriseFields();
      }
    }
  }
}",0.3396226415094339
181035,"/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(""String_Node_Str"");
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INSTALLATION);
    }
  }
}","/** 
 * Ask the current default engine to launch the matching INSTALL_TTS_DATA activity so the required TTS files are properly installed.
 */
private void installVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INSTALLATION);
    }
  }
}",0.963872832369942
181036,"/** 
 * Ask the current default engine to launch the matching CHECK_TTS_DATA activity to check the required TTS files are properly installed.
 */
private void checkVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(""String_Node_Str"");
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INTEGRITY_CHECK);
    }
  }
}","/** 
 * Ask the current default engine to launch the matching CHECK_TTS_DATA activity to check the required TTS files are properly installed.
 */
private void checkVoiceData(){
  PackageManager pm=getPackageManager();
  Intent intent=new Intent();
  intent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA);
  List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
  for (int i=0; i < resolveInfos.size(); i++) {
    ActivityInfo currentActivityInfo=resolveInfos.get(i).activityInfo;
    if (mDefaultEng.equals(currentActivityInfo.packageName)) {
      intent.setClassName(mDefaultEng,currentActivityInfo.name);
      this.startActivityForResult(intent,VOICE_DATA_INTEGRITY_CHECK);
    }
  }
}",0.9640804597701148
181037,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.TTS_SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.9929078014184396
181038,"/** 
 * Called when mPlayExample or mInstallData is clicked
 */
public boolean onPreferenceClick(Preference preference){
  if (preference == mPlayExample) {
    if (mTts != null) {
      mTts.speak(getResources().getString(R.string.tts_demo),TextToSpeech.TTS_QUEUE_FLUSH,null);
    }
    return true;
  }
  if (preference == mInstallData) {
    installVoiceData();
    finish();
    return true;
  }
  return false;
}","/** 
 * Called when mPlayExample or mInstallData is clicked
 */
public boolean onPreferenceClick(Preference preference){
  if (preference == mPlayExample) {
    if (mTts != null) {
      mTts.speak(getResources().getString(R.string.tts_demo),TextToSpeech.QUEUE_FLUSH,null);
    }
    return true;
  }
  if (preference == mInstallData) {
    installVoiceData();
    finish();
    return true;
  }
  return false;
}",0.9951807228915662
181039,"private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language == null) {
    Locale currentLocale=Locale.getDefault();
    language=currentLocale.getISO3Language();
    country=currentLocale.getISO3Country();
    variant=currentLocale.getVariant();
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  mDefaultLanguage=language;
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country == null) {
      Locale currentLocale=Locale.getDefault();
      country=currentLocale.getISO3Country();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultCountry=country;
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant == null) {
      Locale currentLocale=Locale.getDefault();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultLocVariant=variant;
  setDefaultLocalePref(language,country,variant);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}","private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language == null) {
    Locale currentLocale=Locale.getDefault();
    language=currentLocale.getISO3Language();
    country=currentLocale.getISO3Country();
    variant=currentLocale.getVariant();
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  mDefaultLanguage=language;
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country == null) {
      Locale currentLocale=Locale.getDefault();
      country=currentLocale.getISO3Country();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultCountry=country;
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant == null) {
      Locale currentLocale=Locale.getDefault();
      variant=currentLocale.getVariant();
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  mDefaultLocVariant=variant;
  setDefaultLocalePref(language,country,variant);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}",0.8731231231231231
181040,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
      Log.v(TAG,""String_Node_Str"");
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
    }
 else {
      Log.v(TAG,""String_Node_Str"");
      mEnableDemo=false;
      updateWidgetState();
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
      Log.v(TAG,""String_Node_Str"");
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
        mTts.setLanguage(Locale.getDefault());
      }
    }
 else {
      Log.v(TAG,""String_Node_Str"");
      mEnableDemo=false;
      updateWidgetState();
    }
  }
}",0.9532338308457712
181041,"public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    int value=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,value);
      if (mTts != null) {
        mTts.setSpeechRate((float)(value / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + value);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    int value=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,value);
      if (mTts != null) {
        mTts.setSpeechRate((float)(value / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + value);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    }
  }
  return true;
}",0.952018278750952
181042,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
      Log.v(TAG,""String_Node_Str"");
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
    }
 else {
      Log.v(TAG,""String_Node_Str"");
      mEnableDemo=false;
      updateWidgetState();
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
      Log.v(TAG,""String_Node_Str"");
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
        mTts.setLanguage(Locale.getDefault());
      }
    }
 else {
      Log.v(TAG,""String_Node_Str"");
      mEnableDemo=false;
      updateWidgetState();
    }
  }
}",0.9532338308457712
181043,"public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    int value=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,value);
      if (mTts != null) {
        mTts.setSpeechRate((float)(value / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + value);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    int value=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,value);
      if (mTts != null) {
        mTts.setSpeechRate((float)(value / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + value);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    }
  }
  return true;
}",0.952018278750952
181044,"private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language != null) {
    mDefaultLanguage=language;
  }
 else {
    language=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_LANG;
    country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
    variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country.compareTo(""String_Node_Str"") != 0) {
      mDefaultCountry=country;
    }
 else {
      country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant.compareTo(""String_Node_Str"") != 0) {
      mDefaultLocVariant=variant;
    }
 else {
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  String localeString=new String(language);
  if (country.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + country;
  }
 else {
    localeString+=LOCALE_DELIMITER + ""String_Node_Str"";
  }
  if (variant.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + variant;
  }
  Log.v(TAG,""String_Node_Str"" + localeString);
  mDefaultLocPref.setValue(localeString);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}","private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language != null) {
    mDefaultLanguage=language;
  }
 else {
    language=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_LANG;
    country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
    variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country != null) {
      mDefaultCountry=country;
    }
 else {
      country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant != null) {
      mDefaultLocVariant=variant;
    }
 else {
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  String localeString=new String(language);
  if (country.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + country;
  }
 else {
    localeString+=LOCALE_DELIMITER + ""String_Node_Str"";
  }
  if (variant.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + variant;
  }
  Log.v(TAG,""String_Node_Str"" + localeString);
  mDefaultLocPref.setValue(localeString);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}",0.9889610389610388
181045,"private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language != null) {
    mDefaultLanguage=language;
  }
 else {
    language=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_LANG;
    country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
    variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country.compareTo(""String_Node_Str"") != 0) {
      mDefaultCountry=country;
    }
 else {
      country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant.compareTo(""String_Node_Str"") != 0) {
      mDefaultLocVariant=variant;
    }
 else {
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  String localeString=new String(language);
  if (country.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + country;
  }
 else {
    localeString+=LOCALE_DELIMITER + ""String_Node_Str"";
  }
  if (variant.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + variant;
  }
  Log.v(TAG,""String_Node_Str"" + localeString);
  mDefaultLocPref.setValue(localeString);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}","private void initDefaultSettings(){
  ContentResolver resolver=getContentResolver();
  int intVal=0;
  mUseDefaultPref=(CheckBoxPreference)findPreference(KEY_TTS_USE_DEFAULT);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_USE_DEFAULTS);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_USE_DEFAULTS;
    Settings.Secure.putInt(resolver,TTS_USE_DEFAULTS,intVal);
  }
  mUseDefaultPref.setChecked(intVal == 1);
  mUseDefaultPref.setOnPreferenceChangeListener(this);
  String engine=Settings.Secure.getString(resolver,TTS_DEFAULT_SYNTH);
  if (engine == null) {
    engine=FALLBACK_TTS_DEFAULT_SYNTH;
    Settings.Secure.putString(resolver,TTS_DEFAULT_SYNTH,engine);
  }
  mDefaultEng=engine;
  mDefaultRatePref=(ListPreference)findPreference(KEY_TTS_DEFAULT_RATE);
  try {
    intVal=Settings.Secure.getInt(resolver,TTS_DEFAULT_RATE);
  }
 catch (  SettingNotFoundException e) {
    intVal=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_RATE;
    Settings.Secure.putInt(resolver,TTS_DEFAULT_RATE,intVal);
  }
  mDefaultRatePref.setValue(String.valueOf(intVal));
  mDefaultRatePref.setOnPreferenceChangeListener(this);
  String language=null;
  String country=null;
  String variant=null;
  mDefaultLocPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_LANG);
  language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if (language != null) {
    mDefaultLanguage=language;
  }
 else {
    language=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_LANG;
    country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
    variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,language);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
  }
  if (country == null) {
    country=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
    if (country != null) {
      mDefaultCountry=country;
    }
 else {
      country=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_COUNTRY;
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,country);
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  if (variant == null) {
    variant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
    if (variant != null) {
      mDefaultLocVariant=variant;
    }
 else {
      variant=TextToSpeech.Engine.FALLBACK_TTS_DEFAULT_VARIANT;
      Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,variant);
    }
  }
  String localeString=new String(language);
  if (country.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + country;
  }
 else {
    localeString+=LOCALE_DELIMITER + ""String_Node_Str"";
  }
  if (variant.compareTo(""String_Node_Str"") != 0) {
    localeString+=LOCALE_DELIMITER + variant;
  }
  Log.v(TAG,""String_Node_Str"" + localeString);
  mDefaultLocPref.setValue(localeString);
  mDefaultLocPref.setOnPreferenceChangeListener(this);
}",0.9889610389610388
181046,"private void handleSave(){
  replaceStateWithWifiLayerInstance();
  String ssid=mSsidEdit.getText().toString();
  String password=mPasswordEdit.getText().toString();
  mState.setSsid(ssid);
  int securityType=getSecurityTypeFromSpinner();
  if (!TextUtils.isEmpty(password)) {
switch (securityType) {
case SECURITY_WPA_PERSONAL:
{
        mState.setSecurity(AccessPointState.WPA);
        mState.setPassword(password);
        break;
      }
case SECURITY_WPA2_PERSONAL:
{
      mState.setSecurity(AccessPointState.WPA2);
      mState.setPassword(password);
      break;
    }
case SECURITY_AUTO:
{
    mState.setPassword(password);
    break;
  }
case SECURITY_WEP:
{
  mState.setSecurity(AccessPointState.WEP);
  mState.setPassword(password,WEP_TYPE_VALUES[mWepTypeSpinner.getSelectedItemPosition()]);
  break;
}
}
}
 else {
mState.setSecurity(AccessPointState.OPEN);
}
if (securityType == SECURITY_NONE) {
mState.setSecurity(AccessPointState.OPEN);
}
if (!mWifiLayer.saveNetwork(mState)) {
return;
}
if (!mWifiLayer.connectToNetwork(mState)) {
return;
}
}","private void handleSave(){
  replaceStateWithWifiLayerInstance();
  String ssid=mSsidEdit.getText().toString();
  String password=mPasswordEdit.getText().toString();
  mState.setSsid(ssid);
  int securityType=getSecurityTypeFromSpinner();
  if (!TextUtils.isEmpty(password)) {
switch (securityType) {
case SECURITY_WPA_PERSONAL:
{
        mState.setSecurity(AccessPointState.WPA);
        mState.setPassword(password);
        break;
      }
case SECURITY_WPA2_PERSONAL:
{
      mState.setSecurity(AccessPointState.WPA2);
      mState.setPassword(password);
      break;
    }
case SECURITY_AUTO:
{
    mState.setPassword(password);
    break;
  }
case SECURITY_WEP:
{
  mState.setSecurity(AccessPointState.WEP);
  mState.setPassword(password,WEP_TYPE_VALUES[mWepTypeSpinner.getSelectedItemPosition()]);
  break;
}
}
}
 else {
switch (securityType) {
case SECURITY_WPA_EAP:
mState.setSecurity(AccessPointState.WPA_EAP);
break;
case SECURITY_IEEE8021X:
mState.setSecurity(AccessPointState.IEEE8021X);
break;
default :
mState.setSecurity(AccessPointState.OPEN);
break;
}
if (isEnterprise() && !mState.configured) {
updateEnterpriseFields(AccessPointState.WPA_EAP.equals(mState.security) ? SECURITY_WPA_EAP : SECURITY_IEEE8021X);
}
}
if (securityType == SECURITY_NONE) {
mState.setSecurity(AccessPointState.OPEN);
}
if (!mWifiLayer.saveNetwork(mState)) {
return;
}
if (!mWifiLayer.connectToNetwork(mState)) {
return;
}
}",0.8032323232323232
181047,"private void handleSave(){
  replaceStateWithWifiLayerInstance();
  String ssid=mSsidEdit.getText().toString();
  String password=mPasswordEdit.getText().toString();
  mState.setSsid(ssid);
  int securityType=getSecurityTypeFromSpinner();
  if (!TextUtils.isEmpty(password)) {
switch (securityType) {
case SECURITY_WPA_PERSONAL:
{
        mState.setSecurity(AccessPointState.WPA);
        mState.setPassword(password);
        break;
      }
case SECURITY_WPA2_PERSONAL:
{
      mState.setSecurity(AccessPointState.WPA2);
      mState.setPassword(password);
      break;
    }
case SECURITY_AUTO:
{
    mState.setPassword(password);
    break;
  }
case SECURITY_WEP:
{
  mState.setSecurity(AccessPointState.WEP);
  mState.setPassword(password,WEP_TYPE_VALUES[mWepTypeSpinner.getSelectedItemPosition()]);
  break;
}
}
}
 else {
mState.setSecurity(AccessPointState.OPEN);
}
if (securityType == SECURITY_NONE) {
mState.setSecurity(AccessPointState.OPEN);
}
if (!mWifiLayer.saveNetwork(mState)) {
return;
}
if (!mWifiLayer.connectToNetwork(mState)) {
return;
}
}","private void handleSave(){
  replaceStateWithWifiLayerInstance();
  String ssid=mSsidEdit.getText().toString();
  String password=mPasswordEdit.getText().toString();
  mState.setSsid(ssid);
  int securityType=getSecurityTypeFromSpinner();
  if (!TextUtils.isEmpty(password)) {
switch (securityType) {
case SECURITY_WPA_PERSONAL:
{
        mState.setSecurity(AccessPointState.WPA);
        mState.setPassword(password);
        break;
      }
case SECURITY_WPA2_PERSONAL:
{
      mState.setSecurity(AccessPointState.WPA2);
      mState.setPassword(password);
      break;
    }
case SECURITY_AUTO:
{
    mState.setPassword(password);
    break;
  }
case SECURITY_WEP:
{
  mState.setSecurity(AccessPointState.WEP);
  mState.setPassword(password,WEP_TYPE_VALUES[mWepTypeSpinner.getSelectedItemPosition()]);
  break;
}
}
}
 else {
switch (securityType) {
case SECURITY_WPA_EAP:
mState.setSecurity(AccessPointState.WPA_EAP);
break;
case SECURITY_IEEE8021X:
mState.setSecurity(AccessPointState.IEEE8021X);
break;
default :
mState.setSecurity(AccessPointState.OPEN);
break;
}
if (isEnterprise() && !mState.configured) {
updateEnterpriseFields(AccessPointState.WPA_EAP.equals(mState.security) ? SECURITY_WPA_EAP : SECURITY_IEEE8021X);
}
}
if (securityType == SECURITY_NONE) {
mState.setSecurity(AccessPointState.OPEN);
}
if (!mWifiLayer.saveNetwork(mState)) {
return;
}
if (!mWifiLayer.connectToNetwork(mState)) {
return;
}
}",0.8032323232323232
181048,"public void setChecked(boolean checked){
  mSelectedKey=getKey();
}","public void setChecked(){
  mSelectedKey=getKey();
}",0.8739495798319328
181049,"private void fillList(){
  String where=""String_Node_Str"" + android.os.SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,""String_Node_Str"") + ""String_Node_Str"";
  Cursor cursor=managedQuery(Telephony.Carriers.CONTENT_URI,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},where,Telephony.Carriers.DEFAULT_SORT_ORDER);
  PreferenceGroup apnList=(PreferenceGroup)findPreference(""String_Node_Str"");
  apnList.removeAll();
  ArrayList<Preference> mmsApnList=new ArrayList<Preference>();
  mSelectedKey=getSelectedApnKey();
  cursor.moveToFirst();
  while (!cursor.isAfterLast()) {
    String name=cursor.getString(NAME_INDEX);
    String apn=cursor.getString(APN_INDEX);
    String key=cursor.getString(ID_INDEX);
    String type=cursor.getString(TYPES_INDEX);
    ApnPreference pref=new ApnPreference(this);
    pref.setKey(key);
    pref.setTitle(name);
    pref.setSummary(apn);
    pref.setPersistent(false);
    pref.setOnPreferenceChangeListener(this);
    boolean selectable=((type == null) || !type.equals(""String_Node_Str""));
    pref.setSelectable(selectable);
    if (selectable) {
      if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
        pref.setChecked(true);
      }
      apnList.addPreference(pref);
    }
 else {
      mmsApnList.add(pref);
    }
    cursor.moveToNext();
  }
  cursor.close();
  for (  Preference preference : mmsApnList) {
    apnList.addPreference(preference);
  }
}","private void fillList(){
  String where=""String_Node_Str"" + android.os.SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,""String_Node_Str"") + ""String_Node_Str"";
  Cursor cursor=managedQuery(Telephony.Carriers.CONTENT_URI,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},where,Telephony.Carriers.DEFAULT_SORT_ORDER);
  PreferenceGroup apnList=(PreferenceGroup)findPreference(""String_Node_Str"");
  apnList.removeAll();
  ArrayList<Preference> mmsApnList=new ArrayList<Preference>();
  mSelectedKey=getSelectedApnKey();
  cursor.moveToFirst();
  while (!cursor.isAfterLast()) {
    String name=cursor.getString(NAME_INDEX);
    String apn=cursor.getString(APN_INDEX);
    String key=cursor.getString(ID_INDEX);
    String type=cursor.getString(TYPES_INDEX);
    ApnPreference pref=new ApnPreference(this);
    pref.setKey(key);
    pref.setTitle(name);
    pref.setSummary(apn);
    pref.setPersistent(false);
    pref.setOnPreferenceChangeListener(this);
    boolean selectable=((type == null) || !type.equals(""String_Node_Str""));
    pref.setSelectable(selectable);
    if (selectable) {
      if ((mSelectedKey != null) && mSelectedKey.equals(key)) {
        pref.setChecked();
      }
      apnList.addPreference(pref);
    }
 else {
      mmsApnList.add(pref);
    }
    cursor.moveToNext();
  }
  cursor.close();
  for (  Preference preference : mmsApnList) {
    apnList.addPreference(preference);
  }
}",0.9986366734832992
181050,"/** 
 * Format a number of tenths-units as a decimal string without using a conversion to float.  E.g. 347 -> ""34.7""
 */
private final String tenthsToFixedString(int x){
  int tens=x / 10;
  return new String(""String_Node_Str"" + tens + ""String_Node_Str""+ (x - 10 * tens));
}","/** 
 * Format a number of tenths-units as a decimal string without using a conversion to float.  E.g. 347 -> ""34.7""
 */
private final String tenthsToFixedString(int x){
  int tens=x / 10;
  return Integer.toString(tens) + ""String_Node_Str"" + (x - 10 * tens);
}",0.908411214953271
181051,"private void displayQxdmEnableResult(){
  String status=mQxdmLogEnabled ? ""String_Node_Str"" : ""String_Node_Str"";
  DialogInterface mProgressPanel=new AlertDialog.Builder(this).setMessage(status).show();
  mHandler.postDelayed(new Runnable(){
    public void run(){
      finish();
    }
  }
,2000);
}","private void displayQxdmEnableResult(){
  String status=mQxdmLogEnabled ? ""String_Node_Str"" : ""String_Node_Str"";
  new AlertDialog.Builder(this).setMessage(status).show();
  mHandler.postDelayed(new Runnable(){
    public void run(){
      finish();
    }
  }
,2000);
}",0.945518453427065
181052,"private void update(){
  try {
    mMassStorage.setChecked(mMountService.getMassStorageEnabled());
  }
 catch (  RemoteException ex) {
  }
  String scanVolume=null;
  boolean scanning=""String_Node_Str"".equals(scanVolume);
  if (scanning) {
    setLayout(mScanningLayout);
  }
 else {
    String status=Environment.getExternalStorageState();
    boolean readOnly=false;
    if (status.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {
      status=Environment.MEDIA_MOUNTED;
      readOnly=true;
    }
    if (status.equals(Environment.MEDIA_MOUNTED)) {
      try {
        File path=Environment.getExternalStorageDirectory();
        StatFs stat=new StatFs(path.getPath());
        long blockSize=stat.getBlockSize();
        long totalBlocks=stat.getBlockCount();
        long availableBlocks=stat.getAvailableBlocks();
        mTotalSize.setText(formatSize(totalBlocks * blockSize));
        mUsedSize.setText(formatSize((totalBlocks - availableBlocks) * blockSize));
        mAvailableSize.setText(formatSize(availableBlocks * blockSize));
      }
 catch (      IllegalArgumentException e) {
        status=Environment.MEDIA_REMOVED;
      }
      mReadOnlyStatus.setVisibility(readOnly ? View.VISIBLE : View.GONE);
      setLayout(mMountedLayout);
    }
 else     if (status.equals(Environment.MEDIA_UNMOUNTED)) {
      setLayout(mUnmountedLayout);
    }
 else     if (status.equals(Environment.MEDIA_REMOVED)) {
      setLayout(mRemovedLayout);
    }
 else     if (status.equals(Environment.MEDIA_SHARED)) {
      setLayout(mSharedLayout);
    }
 else     if (status.equals(Environment.MEDIA_BAD_REMOVAL)) {
      setLayout(mBadRemovalLayout);
    }
  }
}","private void update(){
  try {
    mMassStorage.setChecked(mMountService.getMassStorageEnabled());
  }
 catch (  RemoteException ex) {
  }
  String status=Environment.getExternalStorageState();
  boolean readOnly=false;
  if (status.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {
    status=Environment.MEDIA_MOUNTED;
    readOnly=true;
  }
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    try {
      File path=Environment.getExternalStorageDirectory();
      StatFs stat=new StatFs(path.getPath());
      long blockSize=stat.getBlockSize();
      long totalBlocks=stat.getBlockCount();
      long availableBlocks=stat.getAvailableBlocks();
      mTotalSize.setText(formatSize(totalBlocks * blockSize));
      mUsedSize.setText(formatSize((totalBlocks - availableBlocks) * blockSize));
      mAvailableSize.setText(formatSize(availableBlocks * blockSize));
    }
 catch (    IllegalArgumentException e) {
      status=Environment.MEDIA_REMOVED;
    }
    mReadOnlyStatus.setVisibility(readOnly ? View.VISIBLE : View.GONE);
    setLayout(mMountedLayout);
  }
 else   if (status.equals(Environment.MEDIA_UNMOUNTED)) {
    setLayout(mUnmountedLayout);
  }
 else   if (status.equals(Environment.MEDIA_REMOVED)) {
    setLayout(mRemovedLayout);
  }
 else   if (status.equals(Environment.MEDIA_SHARED)) {
    setLayout(mSharedLayout);
  }
 else   if (status.equals(Environment.MEDIA_BAD_REMOVAL)) {
    setLayout(mBadRemovalLayout);
  }
}",0.9260096930533118
181053,"public View getView(int position,View convertView,ViewGroup parent){
  AppViewHolder holder;
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.usage_stats_item,null);
    holder=new AppViewHolder();
    holder.pkgName=(TextView)convertView.findViewById(R.id.package_name);
    holder.launchCount=(TextView)convertView.findViewById(R.id.launch_count);
    holder.usageTime=(TextView)convertView.findViewById(R.id.usage_time);
    convertView.setTag(holder);
  }
 else {
    holder=(AppViewHolder)convertView.getTag();
  }
  PkgUsageStats pkgStats=mUsageStats.get(position);
  if (pkgStats != null) {
    CharSequence label=mAppLabelMap.get(pkgStats.packageName);
    holder.pkgName.setText(label);
    holder.launchCount.setText(String.valueOf(pkgStats.launchCount));
    holder.usageTime.setText(String.valueOf(pkgStats.usageTime) + ""String_Node_Str"");
  }
 else {
    Log.w(TAG,""String_Node_Str"" + pkgStats.packageName);
  }
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  AppViewHolder holder;
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.usage_stats_item,null);
    holder=new AppViewHolder();
    holder.pkgName=(TextView)convertView.findViewById(R.id.package_name);
    holder.launchCount=(TextView)convertView.findViewById(R.id.launch_count);
    holder.usageTime=(TextView)convertView.findViewById(R.id.usage_time);
    convertView.setTag(holder);
  }
 else {
    holder=(AppViewHolder)convertView.getTag();
  }
  PkgUsageStats pkgStats=mUsageStats.get(position);
  if (pkgStats != null) {
    CharSequence label=mAppLabelMap.get(pkgStats.packageName);
    holder.pkgName.setText(label);
    holder.launchCount.setText(String.valueOf(pkgStats.launchCount));
    holder.usageTime.setText(String.valueOf(pkgStats.usageTime) + ""String_Node_Str"");
  }
 else {
    Log.w(TAG,""String_Node_Str"" + position);
  }
  return convertView;
}",0.9865284974093264
181054,"private List<HashMap> getZones(){
  List<HashMap> myData=new ArrayList<HashMap>();
  long date=Calendar.getInstance().getTimeInMillis();
  try {
    XmlResourceParser xrp=getResources().getXml(R.xml.timezones);
    while (xrp.next() != XmlResourceParser.START_TAG)     ;
    xrp.next();
    while (xrp.getEventType() != XmlResourceParser.END_TAG) {
      while (xrp.getEventType() != XmlResourceParser.START_TAG) {
        if (xrp.getEventType() == XmlResourceParser.END_DOCUMENT) {
          return myData;
        }
        xrp.next();
      }
      if (xrp.getName().equals(XMLTAG_TIMEZONE)) {
        String id=xrp.getAttributeValue(0);
        String displayName=xrp.nextText();
        addItem(myData,id,displayName,date);
      }
      while (xrp.getEventType() != XmlResourceParser.END_TAG) {
        xrp.next();
      }
      xrp.next();
    }
    xrp.close();
  }
 catch (  XmlPullParserException xppe) {
    Log.e(TAG,""String_Node_Str"");
  }
catch (  java.io.IOException ioe) {
    Log.e(TAG,""String_Node_Str"");
  }
  return myData;
}","private List<HashMap> getZones(){
  List<HashMap> myData=new ArrayList<HashMap>();
  long date=Calendar.getInstance().getTimeInMillis();
  try {
    XmlResourceParser xrp=getResources().getXml(R.xml.timezones);
    while (xrp.next() != XmlResourceParser.START_TAG)     continue;
    xrp.next();
    while (xrp.getEventType() != XmlResourceParser.END_TAG) {
      while (xrp.getEventType() != XmlResourceParser.START_TAG) {
        if (xrp.getEventType() == XmlResourceParser.END_DOCUMENT) {
          return myData;
        }
        xrp.next();
      }
      if (xrp.getName().equals(XMLTAG_TIMEZONE)) {
        String id=xrp.getAttributeValue(0);
        String displayName=xrp.nextText();
        addItem(myData,id,displayName,date);
      }
      while (xrp.getEventType() != XmlResourceParser.END_TAG) {
        xrp.next();
      }
      xrp.next();
    }
    xrp.close();
  }
 catch (  XmlPullParserException xppe) {
    Log.e(TAG,""String_Node_Str"");
  }
catch (  java.io.IOException ioe) {
    Log.e(TAG,""String_Node_Str"");
  }
  return myData;
}",0.996186844613918
181055,"public void askDisconnect(){
  Context context=mLocalManager.getForegroundActivity();
  if (context == null) {
    disconnect();
    return;
  }
  Resources res=context.getResources();
  String name=getName();
  if (TextUtils.isEmpty(name)) {
    name=res.getString(R.string.bluetooth_device);
  }
  String message=res.getString(R.string.bluetooth_disconnect_blank,name);
  DialogInterface.OnClickListener disconnectListener=new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      disconnect();
    }
  }
;
  AlertDialog ad=new AlertDialog.Builder(context).setTitle(getName()).setMessage(message).setPositiveButton(android.R.string.ok,disconnectListener).setNegativeButton(android.R.string.cancel,null).show();
}","public void askDisconnect(){
  Context context=mLocalManager.getForegroundActivity();
  if (context == null) {
    disconnect();
    return;
  }
  Resources res=context.getResources();
  String name=getName();
  if (TextUtils.isEmpty(name)) {
    name=res.getString(R.string.bluetooth_device);
  }
  String message=res.getString(R.string.bluetooth_disconnect_blank,name);
  DialogInterface.OnClickListener disconnectListener=new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      disconnect();
    }
  }
;
  new AlertDialog.Builder(context).setTitle(getName()).setMessage(message).setPositiveButton(android.R.string.ok,disconnectListener).setNegativeButton(android.R.string.cancel,null).show();
}",0.990138067061144
181056,"private void fillData(){
  BluetoothDevice manager=mLocalManager.getBluetoothManager();
  fetchName();
  fetchBtClass();
  mVisible=false;
  dispatchAttributesChanged();
}","private void fillData(){
  fetchName();
  fetchBtClass();
  mVisible=false;
  dispatchAttributesChanged();
}",0.7741935483870968
181057,"private void connectAndPreferAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  Context context=mLocalManager.getContext();
  for (  Profile profile : mProfiles) {
    LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
    profileManager.setPreferred(mAddress,true);
    queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
  }
}","private void connectAndPreferAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
    profileManager.setPreferred(mAddress,true);
    queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
  }
}",0.9454976303317536
181058,"void updateTimes(){
  long at=SystemClock.uptimeMillis() / 1000;
  long ut=SystemClock.elapsedRealtime() / 1000;
  long st=ut - at;
  if (ut == 0) {
    ut=1;
  }
  mUptime.setSummary(convert(ut));
}","void updateTimes(){
  long at=SystemClock.uptimeMillis() / 1000;
  long ut=SystemClock.elapsedRealtime() / 1000;
  if (ut == 0) {
    ut=1;
  }
  mUptime.setSummary(convert(ut));
}",0.949868073878628
181059,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (resultCode != RESULT_OK) {
    return;
  }
  if (requestCode == REQUEST_PICK_BOOKMARK) {
    if (data == null) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    String title=data.getStringExtra(BookmarkPicker.EXTRA_TITLE);
    char shortcut=data.getCharExtra(BookmarkPicker.EXTRA_SHORTCUT,(char)0);
    updateShortcut(shortcut,data);
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (resultCode != RESULT_OK) {
    return;
  }
  if (requestCode == REQUEST_PICK_BOOKMARK) {
    if (data == null) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    char shortcut=data.getCharExtra(BookmarkPicker.EXTRA_SHORTCUT,(char)0);
    updateShortcut(shortcut,data);
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
  }
}",0.8958333333333334
181060,"private void updatePasswordCaption(String security){
  if (mPasswordText != null && security != null && security.equals(AccessPointState.WEP)) {
    mPasswordText.setText(R.string.please_type_hex_key);
  }
 else {
    mPasswordText.setText(R.string.please_type_passphrase);
  }
}","private void updatePasswordCaption(String security){
  if (mPasswordText != null) {
    if (security != null && security.equals(AccessPointState.WEP)) {
      mPasswordText.setText(R.string.please_type_hex_key);
    }
 else {
      mPasswordText.setText(R.string.please_type_passphrase);
    }
  }
}",0.8512110726643599
181061,"public AccessPointPreference(WifiSettings wifiSettings,AccessPointState state){
  super(wifiSettings,null);
  mWifiSettings=wifiSettings;
  mState=state;
  setWidgetLayoutResource(R.layout.preference_widget_wifi_signal);
  state.setCallback(this);
  refresh();
}","public AccessPointPreference(WifiSettings wifiSettings,AccessPointState state){
  super(wifiSettings,null);
  mState=state;
  setWidgetLayoutResource(R.layout.preference_widget_wifi_signal);
  state.setCallback(this);
  refresh();
}",0.9392712550607288
181062,"private void refreshStatus(AccessPointState ap,NetworkInfo.DetailedState detailedState){
  final WifiInfo wifiInfo=mWifiManager.getConnectionInfo();
  if (detailedState == null) {
    detailedState=WifiInfo.getDetailedStateOf(wifiInfo.getSupplicantState());
  }
  if (ap == null && WifiStatus.isLiveConnection(detailedState)) {
    ap=findApLocked(wifiInfo.getNetworkId(),wifiInfo.getBSSID(),wifiInfo.getSSID(),null);
  }
  if (ap != null) {
    ap.blockRefresh();
    ap.updateFromWifiInfo(wifiInfo,detailedState);
    ap.setStatus(detailedState);
    ap.unblockRefresh();
  }
}","private void refreshStatus(AccessPointState ap,NetworkInfo.DetailedState detailedState){
  final WifiInfo wifiInfo=mWifiManager.getConnectionInfo();
  if (detailedState == null) {
    detailedState=WifiInfo.getDetailedStateOf(wifiInfo.getSupplicantState());
  }
  if (ap == null && WifiStatus.isLiveConnection(detailedState)) {
synchronized (this) {
      ap=findApLocked(wifiInfo.getNetworkId(),wifiInfo.getBSSID(),wifiInfo.getSSID(),null);
    }
  }
  if (ap != null) {
    ap.blockRefresh();
    ap.updateFromWifiInfo(wifiInfo,detailedState);
    ap.setStatus(detailedState);
    ap.unblockRefresh();
  }
}",0.9747474747474748
181063,"private AccessPointState getCurrentAp(){
  final WifiInfo wifiInfo=mWifiManager.getConnectionInfo();
  String ssid=wifiInfo.getSSID();
  if (ssid != null) {
    return findApLocked(wifiInfo.getNetworkId(),wifiInfo.getBSSID(),ssid,null);
  }
 else {
    return null;
  }
}","private AccessPointState getCurrentAp(){
  final WifiInfo wifiInfo=mWifiManager.getConnectionInfo();
  String ssid=wifiInfo.getSSID();
  if (ssid != null) {
synchronized (this) {
      return findApLocked(wifiInfo.getNetworkId(),wifiInfo.getBSSID(),ssid,null);
    }
  }
 else {
    return null;
  }
}",0.9475524475524476
181064,"private void showDialog(Dialog dialog){
  if (mDialog != null) {
    mDialog.dismiss();
  }
  mDialog=dialog;
  dialog.setOnDismissListener(this);
  if (dialog != null) {
    dialog.show();
  }
}","private void showDialog(Dialog dialog){
  if (mDialog != null) {
    mDialog.dismiss();
  }
  mDialog=dialog;
  if (dialog != null) {
    dialog.setOnDismissListener(this);
    dialog.show();
  }
}",0.8724489795918368
181065,"private void syncBluetoothState(){
  setBluetoothStateInt(mManager.isEnabled() ? BluetoothDevice.BLUETOOTH_STATE_ON : BluetoothDevice.BLUETOOTH_STATE_OFF);
}","private void syncBluetoothState(){
  int bluetoothState;
  if (mManager != null) {
    bluetoothState=mManager.isEnabled() ? BluetoothDevice.BLUETOOTH_STATE_ON : BluetoothDevice.BLUETOOTH_STATE_OFF;
  }
 else {
    bluetoothState=BluetoothError.ERROR;
  }
  setBluetoothStateInt(bluetoothState);
}",0.5903083700440529
181066,"private void syncBluetoothState(){
  setBluetoothStateInt(mManager.isEnabled() ? BluetoothDevice.BLUETOOTH_STATE_ON : BluetoothDevice.BLUETOOTH_STATE_OFF);
}","private void syncBluetoothState(){
  int bluetoothState;
  if (mManager != null) {
    bluetoothState=mManager.isEnabled() ? BluetoothDevice.BLUETOOTH_STATE_ON : BluetoothDevice.BLUETOOTH_STATE_OFF;
  }
 else {
    bluetoothState=BluetoothError.ERROR;
  }
  setBluetoothStateInt(bluetoothState);
}",0.5903083700440529
181067,"/** 
 * Return the AudioFileFormat from the given InputStream. Implementation.
 * @param bitStream
 * @param baos
 * @param mediaLength
 * @return an AudioInputStream object based on the audio file data containedin the input stream.
 * @exception UnsupportedAudioFileException if the File does not point to a valid audio file data recognized by the system.
 * @exception IOException if an I/O exception occurs.
 */
protected AudioFileFormat getAudioFileFormat(InputStream bitStream,int mediaLength) throws UnsupportedAudioFileException, IOException {
  AudioFormat format;
  try {
    decoder=new FLACDecoder(bitStream);
    streamInfo=decoder.readStreamInfo();
    if (streamInfo == null) {
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
      }
      throw new UnsupportedAudioFileException(""String_Node_Str"");
    }
    format=new FlacAudioFormat(streamInfo);
  }
 catch (  IOException ioe) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    throw new UnsupportedAudioFileException(ioe.getMessage());
  }
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + format);
  }
  return new AudioFileFormat(FlacFileFormatType.FLAC,format,AudioSystem.NOT_SPECIFIED);
}","/** 
 * Return the AudioFileFormat from the given InputStream. Implementation.
 * @param bitStream
 * @param mediaLength
 * @return an AudioInputStream object based on the audio file data containedin the input stream.
 * @exception UnsupportedAudioFileException if the File does not point to a valid audio file data recognized by the system.
 * @exception IOException if an I/O exception occurs.
 */
protected AudioFileFormat getAudioFileFormat(InputStream bitStream,int mediaLength) throws UnsupportedAudioFileException, IOException {
  AudioFormat format;
  try {
    decoder=new FLACDecoder(bitStream);
    streamInfo=decoder.readStreamInfo();
    if (streamInfo == null) {
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
      }
      throw new UnsupportedAudioFileException(""String_Node_Str"");
    }
    format=new FlacAudioFormat(streamInfo);
  }
 catch (  IOException ioe) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    final UnsupportedAudioFileException unsupportedAudioFileException=new UnsupportedAudioFileException(ioe.getMessage());
    unsupportedAudioFileException.initCause(ioe);
    throw unsupportedAudioFileException;
  }
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + format);
  }
  return new AudioFileFormat(FlacFileFormatType.FLAC,format,AudioSystem.NOT_SPECIFIED);
}",0.917057902973396
181068,"/** 
 * Constructor.
 */
public AbstractTestCase(String testName){
  super(testName);
}","protected AbstractTestCase(){
}",0.4406779661016949
181069,"/** 
 * Get test input file.
 * @param path Path to test input file.
 */
public String getTestFile(String path){
  return new File(basedir,path).getAbsolutePath();
}","/** 
 * Get test input file.
 * @param path Path to test input file.
 * @return file relative to basedir
 */
public String getTestFile(String path){
  return new File(basedir,path).getAbsolutePath();
}",0.9016393442622952
181070,"/** 
 * Read a block of bytes (aligned) without updating the CRC value.
 * @param val   The array to receive the bytes. If null, no bytes are returned
 * @param nvals The number of bytes to read
 * @throws IOException  Thrown if error reading input stream
 */
public void readByteBlockAlignedNoCRC(byte[] val,int nvals) throws IOException {
  while (nvals > 0) {
    int chunk=Math.min(nvals,putByte - getByte);
    if (chunk == 0) {
      readFromStream();
    }
 else {
      if (val != null)       System.arraycopy(buffer,getByte,val,0,chunk);
      nvals-=chunk;
      getByte+=chunk;
      availBits-=(chunk << BITS_PER_BLURB_LOG2);
      totalBitsRead+=(chunk << BITS_PER_BLURB_LOG2);
    }
  }
}","/** 
 * Read a block of bytes (aligned) without updating the CRC value.
 * @param val   The array to receive the bytes. If null, no bytes are returned
 * @param nvals The number of bytes to read
 * @throws IOException  Thrown if error reading input stream
 */
public void readByteBlockAlignedNoCRC(byte[] val,int nvals) throws IOException {
  int destlength=nvals;
  while (nvals > 0) {
    int chunk=Math.min(nvals,putByte - getByte);
    if (chunk == 0) {
      readFromStream();
    }
 else {
      if (val != null)       System.arraycopy(buffer,getByte,val,destlength - nvals,chunk);
      nvals-=chunk;
      getByte+=chunk;
      availBits-=(chunk << BITS_PER_BLURB_LOG2);
      totalBitsRead+=(chunk << BITS_PER_BLURB_LOG2);
    }
  }
}",0.970242214532872
181071,"/** 
 * Process the StreamInfo block.
 * @param info the StreamInfo block
 * @see org.kc7bfi.jflac.PCMProcessor#processStreamInfo(org.kc7bfi.jflac.metadata.StreamInfo)
 */
public void processStreamInfo(StreamInfo streamInfo){
  try {
    fmt=new AudioFormat(streamInfo.sampleRate,streamInfo.bitsPerSample,streamInfo.channels,true,false);
    info=new DataLine.Info(SourceDataLine.class,fmt,AudioSystem.NOT_SPECIFIED);
    line=(SourceDataLine)AudioSystem.getLine(info);
    line.open(fmt,AudioSystem.NOT_SPECIFIED);
  }
 catch (  LineUnavailableException e) {
    e.printStackTrace();
  }
}","/** 
 * Process the StreamInfo block.
 * @param info the StreamInfo block
 * @see org.kc7bfi.jflac.PCMProcessor#processStreamInfo(org.kc7bfi.jflac.metadata.StreamInfo)
 */
public void processStreamInfo(StreamInfo streamInfo){
  try {
    fmt=new AudioFormat(streamInfo.sampleRate,streamInfo.bitsPerSample,streamInfo.channels,true,false);
    info=new DataLine.Info(SourceDataLine.class,fmt,AudioSystem.NOT_SPECIFIED);
    line=(SourceDataLine)AudioSystem.getLine(info);
    line.open(fmt,AudioSystem.NOT_SPECIFIED);
    line.start();
  }
 catch (  LineUnavailableException e) {
    e.printStackTrace();
  }
}",0.9849749582637728
181072,"/** 
 * Process the decoded PCM bytes.
 * @param pcm The decoded PCM data
 * @see org.kc7bfi.jflac.PCMProcessor#processPCM(org.kc7bfi.jflac.util.ByteSpace)
 */
public void processPCM(ByteSpace pcm){
  line.write(pcm.space,0,pcm.pos);
  if (prefill) {
    line.start();
    prefill=false;
  }
}","/** 
 * Process the decoded PCM bytes.
 * @param pcm The decoded PCM data
 * @see org.kc7bfi.jflac.PCMProcessor#processPCM(org.kc7bfi.jflac.util.ByteSpace)
 */
public void processPCM(ByteSpace pcm){
  line.write(pcm.space,0,pcm.pos);
}",0.8901515151515151
181073,"/** 
 * The main routine. <p>args[0] is the input file name
 * @param args  Command line arguments
 */
public static void main(String[] args){
  try {
    Player decoder=new Player();
    decoder.decode(args[0]);
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  LineUnavailableException e) {
    e.printStackTrace();
  }
  System.exit(0);
}","/** 
 * The main routine. <p>args[0] is the input file name
 * @param args  Command line arguments
 */
public static void main(String[] args){
  try {
    Player decoder=new Player();
    for (int i=0; i < args.length; i++)     decoder.decode(args[i]);
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  LineUnavailableException e) {
    e.printStackTrace();
  }
  System.exit(0);
}",0.952808988764045
181074,"/** 
 * Constructor that takes in a board, player and genericMove
 * @param setting the current board
 * @param currentTurn the current Player
 * @param nextMove the next genericMove
 */
@Override public Iterator<StateImpl> iterator(){
  return null;
}","@Override public Iterator<StateImpl> iterator(){
  return null;
}",0.4100946372239747
181075,"/** 
 * Randomly choose which move to make
 */
public void randomMove(){
  Random generator=new Random();
  float f=generator.nextFloat() * 100;
  if ((int)f < 50 && currentTurn.wallCount() > 0) {
    wall();
    int wall=(int)generator.nextFloat() * wallBackerList.size() - 1;
    PlaceWall tmp=wallBackerList.get(wall);
    nextMove=tmp;
  }
 else {
    pawn();
    int move=(int)generator.nextFloat() * pawnBackerList.size() - 1;
    MovePawn tmp=pawnBackerList.get(move);
    nextMove=tmp;
  }
}","/** 
 * Randomly choose which move to make
 */
public void randomMove(){
  Random generator=new Random();
  float f=generator.nextFloat() * 100;
  if ((int)f < 50 && currentTurn.wallCount() > 0) {
    wall();
    float wall=generator.nextFloat() * (wallBackerList.size() - 1);
    PlaceWall tmp=wallBackerList.get((int)wall);
    nextMove=tmp;
  }
 else {
    pawn();
    float move=generator.nextFloat() * (pawnBackerList.size() - 1);
    MovePawn tmp=pawnBackerList.get((int)move);
    nextMove=tmp;
  }
}",0.9363817097415508
181076,"/** 
 * Constructor that takes in a board and player
 * @param setting the current board state
 * @param currentTurn the current player
 */
public RandomAI(Board setting,Player currentTurn){
  this.setting=setting;
  this.currentTurn=currentTurn;
  nextMove=null;
}","/** 
 * Constructor that takes in a board, player and genericMove
 * @param setting the current board
 * @param currentTurn the current Player
 * @param nextMove the next genericMove
 */
public RandomAI(Board setting,Player currentTurn,GenericMove nextMove){
  this.setting=setting;
  this.currentTurn=currentTurn;
  this.nextMove=nextMove;
}",0.8270181219110379
181077,"/** 
 * Undo a move of the current player (two if you are playing against the AI)
 */
public void undoMove();","/** 
 * Undo a move of the current player (two if you are playing against the AI)
 */
public boolean undoMove();",0.9592760180995475
181078,"/** 
 * Redo the move of the current player (two if you are playing against the AI)
 */
public void redoMove();","/** 
 * Redo the move of the current player (two if you are playing against the AI)
 */
public boolean redoMove();",0.96
181079,"@Override public void play(){
  String[] commands={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  short[] tokens={TOKEN_SAVE,TOKEN_UNDO,TOKEN_REDO,TOKEN_QUIT};
  short[] argCount={0,0,0,0};
  short invalid=-1;
  inputParser=new ParserImpl(commands,tokens,argCount,invalid);
  MoveParser parser=new MoveParserImpl();
  Scanner s=new Scanner(System.in);
  short token;
  GenericMove nextMove;
  printBoard();
  while (!isOver()) {
    if (current.equals(players._1())) {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
    String command;
    if (current.isHuman()) {
      command=s.next();
    }
 else {
      State thinker=new StateImpl(gameBoard,current);
      command=thinker.nextBestMove().toString();
      System.out.println(command);
    }
    token=inputParser.ensureString(command);
    if (token == TOKEN_SAVE) {
      try {
        Manager.saveGame();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else     if (token == TOKEN_UNDO) {
      undoMove();
      printBoard();
      current=current.getOpponent();
    }
 else     if (token == TOKEN_REDO) {
      redoMove();
      printBoard();
      current=current.getOpponent();
    }
 else {
      nextMove=parser.loadMove(current,gameBoard,command);
      if (nextMove == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        if (nextMove.isValid()) {
          nextMove.makeMove();
          printBoard();
          undoMoves.add(nextMove);
          redoMoves=new LinkedList<GenericMove>();
          current=current.getOpponent();
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + current.getOpponent().getName() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}","@Override public void play(){
  String[] commands={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  short[] tokens={TOKEN_SAVE,TOKEN_UNDO,TOKEN_REDO,TOKEN_QUIT};
  short[] argCount={0,0,0,0};
  short invalid=-1;
  inputParser=new ParserImpl(commands,tokens,argCount,invalid);
  MoveParser parser=new MoveParserImpl();
  Scanner s=new Scanner(System.in);
  short token;
  GenericMove nextMove;
  printBoard();
  while (!isOver()) {
    if (current.equals(players._1())) {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
    String command;
    if (current.isHuman()) {
      command=s.next();
    }
 else {
      State thinker=new StateImpl(gameBoard,current);
      command=thinker.nextBestMove().toString();
      System.out.println(command);
    }
    token=inputParser.ensureString(command);
    if (token == TOKEN_SAVE) {
      try {
        Manager.saveGame();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else     if (token == TOKEN_UNDO) {
      if (undoMove() == true) {
        printBoard();
        current=current.getOpponent();
      }
    }
 else     if (token == TOKEN_REDO) {
      if (redoMove()) {
        printBoard();
        current=current.getOpponent();
      }
    }
 else {
      nextMove=parser.loadMove(current,gameBoard,command);
      if (nextMove == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        if (nextMove.isValid()) {
          nextMove.makeMove();
          printBoard();
          undoMoves.add(nextMove);
          redoMoves=new LinkedList<GenericMove>();
          current=current.getOpponent();
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + current.getOpponent().getName() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}",0.9868885526979324
181080,"@Override public void undoMove(){
  if (undoMoves.size() >= 1) {
    if (current.getOpponent().isHuman() == false) {
      undoOnce();
      current=current.getOpponent();
      undoOnce();
    }
 else {
      undoOnce();
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","@Override public boolean undoMove(){
  boolean retVal=false;
  if (undoMoves.size() - 1 > 1) {
    if (current.getOpponent().isHuman() == false) {
      undoOnce();
      current=current.getOpponent();
      undoOnce();
    }
 else {
      undoOnce();
    }
    retVal=true;
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  return retVal;
}",0.35625
181081,"@Override public void redoMove(){
  if (redoMoves.size() >= 0) {
    if (current.getOpponent().isHuman() == false) {
      redoOnce();
      current=current.getOpponent();
      redoOnce();
    }
 else {
      redoOnce();
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","@Override public boolean redoMove(){
  boolean retVal=false;
  System.out.println(""String_Node_Str"" + redoMoves);
  if (redoMoves.size() - 1 > 0) {
    if (current.getOpponent().isHuman() == false) {
      redoOnce();
      current=current.getOpponent();
      redoOnce();
    }
 else {
      redoOnce();
    }
    retVal=true;
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  return retVal;
}",0.1991341991341991
181082,"public boolean pathToGoal(Pawn pawn){
  assert(pawns.contains(pawn));
  HashSet<Square> seen=new HashSet<Square>();
  int goalRow;
  if (pawn.getOwner().goalEnd() == Player.BOTTOM) {
    goalRow=0;
  }
 else {
    goalRow=Board.ROWS - 1;
  }
  return localPathToGoal(pawn.getSquare(),seen,goalRow);
}","public boolean pathToGoal(Pawn pawn){
  assert(pawns.contains(pawn));
  HashSet<Square> seen=new HashSet<Square>();
  int goalRow;
  if (pawn.getOwner().goalEnd() == Player.TOP) {
    goalRow=0;
  }
 else {
    goalRow=Board.ROWS - 1;
  }
  return localPathToGoal(pawn.getSquare(),seen,goalRow);
}",0.9916247906197656
181083,"public GenericMove parseMove(String move,Player current,Board board){
  int len=move.length();
  boolean validInput=len == 2 || len == 3;
  int col=-1;
  int row=-1;
  boolean type=GenericMove.PAWN;
  boolean dir=false;
  GenericMove result=null;
  ;
  col=charNum(move.charAt(0));
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput) {
    row=parseInt(move.charAt(1)) - 1;
  }
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput && len == 3) {
    type=GenericMove.WALL;
    char dirChar=move.charAt(2);
    if (dirChar == 'h') {
      dir=Wall.HORIZONTAL;
    }
 else     if (dirChar == 'v') {
      dir=Wall.VERTICAL;
    }
 else {
      validInput=false;
    }
  }
  if (validInput) {
    if (type == GenericMove.PAWN) {
      result=new MovePawnImpl(col,row,current,board);
      System.out.println(len);
    }
 else     if (type == GenericMove.WALL) {
      result=new PlaceWallImpl(col,row,dir,current,board);
    }
  }
  return result;
}","public GenericMove parseMove(String move,Player current,Board board){
  int len=move.length();
  boolean validInput=len == 2 || len == 3;
  int col=-1;
  int row=-1;
  boolean type=GenericMove.PAWN;
  boolean dir=false;
  GenericMove result=null;
  ;
  col=charNum(move.charAt(0));
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput) {
    row=parseInt(move.charAt(1)) - 1;
  }
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput && len == 3) {
    type=GenericMove.WALL;
    char dirChar=move.charAt(2);
    if (dirChar == 'h') {
      dir=Wall.HORIZONTAL;
    }
 else     if (dirChar == 'v') {
      dir=Wall.VERTICAL;
    }
 else {
      validInput=false;
    }
  }
  if (validInput) {
    if (type == GenericMove.PAWN) {
      result=new MovePawnImpl(col,row,current,board);
    }
 else     if (type == GenericMove.WALL) {
      result=new PlaceWallImpl(col,row,dir,current,board);
    }
  }
  return result;
}",0.984351337708228
181084,"@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  boolean direction=tentative.getDirection();
  if (direction == Wall.HORIZONTAL) {
    direction=Wall.VERTICAL;
  }
 else {
    direction=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),direction);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    System.out.println(""String_Node_Str"" + setting);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
      System.out.println(""String_Node_Str"");
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
      System.out.println(""String_Node_Str"");
    }
    setting.removeWall(tentative);
  }
  if (owner.hasWon(setting) || owner.getOpponent().hasWon(setting)) {
    valid=false;
  }
  return valid;
}","@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  boolean direction=tentative.getDirection();
  if (direction == Wall.HORIZONTAL) {
    direction=Wall.VERTICAL;
  }
 else {
    direction=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),direction);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
    }
    setting.removeWall(tentative);
  }
  if (owner.hasWon(setting) || owner.getOpponent().hasWon(setting)) {
    valid=false;
  }
  return valid;
}",0.9501568490763332
181085,"@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  boolean direction=tentative.getDirection();
  if (direction == Wall.HORIZONTAL) {
    direction=Wall.VERTICAL;
  }
 else {
    direction=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),direction);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
    }
    setting.removeWall(tentative);
  }
  if (owner.hasWon(setting) || owner.getOpponent().hasWon(setting)) {
    valid=false;
  }
  return valid;
}","@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  Wall left=new WallImpl(new SquareImpl(tentative.topLeft().getCol() - 1,tentative.topLeft().getRow()),tentative.getDirection());
  Wall right=new WallImpl(new SquareImpl(tentative.topLeft().getCol() + 1,tentative.topLeft().getRow()),tentative.getDirection());
  boolean opDirection=tentative.getDirection();
  if (opDirection == Wall.HORIZONTAL) {
    opDirection=Wall.VERTICAL;
  }
 else {
    opDirection=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),opDirection);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else   if (setting.containsWall(right) == true) {
    valid=false;
  }
 else   if (setting.containsWall(left) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
    }
    setting.removeWall(tentative);
  }
  if (owner.hasWon(setting) || owner.getOpponent().hasWon(setting)) {
    valid=false;
  }
  return valid;
}",0.6369426751592356
181086,"public void logicalPlay(){
  Node pathP1=pathLength(currentTurn);
  int costP1=pathP1.getCost();
  Node pathP2=pathLength(currentTurn.getOpponent());
  int costP2=pathP2.getCost();
  if (costP1 < costP2) {
    nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
  }
 else {
    if (setting.getPawn(currentTurn,setting).getOwner().wallCount() <= 0) {
      nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
    }
 else {
      if (wallMove() == false) {
        nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
      }
    }
  }
  findPathTaken(pathP1);
}","public void logicalPlay(){
  Node pathP1=pathLength(currentTurn);
  int costP1=pathP1.getCost();
  System.out.println(""String_Node_Str"" + costP1);
  Node pathP2=pathLength(currentTurn.getOpponent());
  int costP2=pathP2.getCost();
  System.out.println(""String_Node_Str"" + costP2);
  if (costP1 < costP2) {
    System.out.println(""String_Node_Str"");
    nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
  }
 else {
    System.out.println(""String_Node_Str"");
    if (setting.getPawn(currentTurn,setting).getOwner().wallCount() <= 0) {
      nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
    }
 else {
      System.out.println(""String_Node_Str"");
      if (wallMove() == false) {
        nextMove=new MovePawnImpl(pathP1.getSquare().getCol(),pathP1.getSquare().getRow(),currentTurn,setting);
      }
    }
  }
  findPathTaken(pathP1);
}",0.8609271523178808
181087,"private boolean wallMove(){
  Player p2=currentTurn.getOpponent();
  Square tmp=setting.getPawn(p2,setting).getSquare();
  Square rightS=new SquareImpl(tmp.getCol() - 1,tmp.getRow());
  PlaceWallImpl next=null;
  boolean exit=false;
  boolean retVal=true;
  if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.HORIZONTAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else   if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.VERTICAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else   if ((next=new PlaceWallImpl(rightS.getCol(),rightS.getRow(),Wall.HORIZONTAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else {
    for (int i=tmp.getCol() - 3; i < tmp.getCol() + 3 && exit == false; i++) {
      for (int j=tmp.getRow() - 3; j < tmp.getRow() + 3 && exit == false; j++) {
        tmp=new SquareImpl(i,j);
        if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.HORIZONTAL,currentTurn,setting)).isValid()) {
          nextMove=next;
          exit=true;
        }
 else         if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.VERTICAL,currentTurn,setting)).isValid()) {
          nextMove=next;
          exit=true;
        }
      }
    }
  }
  if (nextMove == null) {
    retVal=false;
  }
  return retVal;
}","private boolean wallMove(){
  Player p2=currentTurn.getOpponent();
  Square tmp=setting.getPawn(p2,setting).getSquare();
  Square rightS=new SquareImpl(tmp.getCol() - 1,tmp.getRow());
  PlaceWallImpl next=null;
  boolean exit=false;
  boolean retVal=true;
  if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow() - 1,Wall.HORIZONTAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else   if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.VERTICAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else   if ((next=new PlaceWallImpl(rightS.getCol() - 1,rightS.getRow(),Wall.VERTICAL,currentTurn,setting)).isValid()) {
    nextMove=next;
  }
 else {
    for (int i=tmp.getCol() - 3; i < tmp.getCol() + 3 && exit == false; i++) {
      for (int j=tmp.getRow() - 3; j < tmp.getRow() + 3 && exit == false; j++) {
        tmp=new SquareImpl(i,j);
        if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.HORIZONTAL,currentTurn,setting)).isValid()) {
          nextMove=next;
          exit=true;
        }
 else         if ((next=new PlaceWallImpl(tmp.getCol(),tmp.getRow(),Wall.VERTICAL,currentTurn,setting)).isValid()) {
          nextMove=next;
          exit=true;
        }
      }
    }
  }
  if (nextMove == null) {
    retVal=false;
  }
  return retVal;
}",0.7368421052631579
181088,"@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  boolean direction=tentative.getDirection();
  if (direction == Wall.HORIZONTAL) {
    direction=Wall.VERTICAL;
  }
 else {
    direction=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),direction);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 8) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 8) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
    }
    setting.removeWall(tentative);
  }
  return valid;
}","@Override public boolean isValid(){
  boolean valid=true;
  Wall test=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),tentative.getDirection());
  boolean direction=tentative.getDirection();
  if (direction == Wall.HORIZONTAL) {
    direction=Wall.VERTICAL;
  }
 else {
    direction=Wall.HORIZONTAL;
  }
  Wall opposite=new WallImpl(new SquareImpl(tentative.topLeft().getCol(),tentative.topLeft().getRow()),direction);
  if (setting.getPawn(owner,setting).getOwner().wallCount() <= 0) {
    valid=false;
  }
  if (tentative.topLeft().getCol() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() < 0) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getCol() > 7) {
    valid=false;
  }
 else   if (tentative.topLeft().getRow() > 7) {
    valid=false;
  }
 else   if (setting.containsWall(test) == true) {
    valid=false;
  }
 else   if (setting.containsWall(opposite) == true) {
    valid=false;
  }
 else {
    setting.addWall(tentative);
    if (setting.pathToGoal(setting.getPawn(owner,setting)) == false) {
      valid=false;
    }
 else     if (setting.pathToGoal(setting.getPawn(owner.getOpponent(),setting)) == false) {
      valid=false;
    }
    setting.removeWall(tentative);
  }
  return valid;
}",0.9720627631075393
181089,"/** 
 * Searches for a path from a pawn to said pawn's goal.
 * @param pawn the pawn from which to search for a path to a goal
 * @return True iff there is a path from the pawn to its goal
 */
public boolean pathToGoal(Pawn pawn){
  assert(pawns.contains(pawn));
  HashSet<Square> seen=new HashSet<Square>(ROWS * COLS);
  int goalRow;
  if (pawn.getOwner().goalEnd() == Player.BOTTOM) {
    goalRow=0;
  }
 else {
    goalRow=Board.ROWS - 1;
  }
  return localPathToGoal(pawn.getSquare(),seen,goalRow);
}","/** 
 * Searches for a path from a pawn to said pawn's goal.
 * @param pawn the pawn from which to search for a path to a goal
 * @return True iff there is a path from the pawn to its goal
 */
public boolean pathToGoal(Pawn pawn){
  assert(pawns.contains(pawn));
  HashSet<Square> seen=new HashSet<Square>();
  int goalRow;
  if (pawn.getOwner().goalEnd() == Player.BOTTOM) {
    goalRow=0;
  }
 else {
    goalRow=Board.ROWS - 1;
  }
  return localPathToGoal(pawn.getSquare(),seen,goalRow);
}",0.9889669007021064
181090,"/** 
 * This is a helper function used by pathToGoal. It recursively checks neighbors until it finds a goal or all connected squares are searched.
 * @param current The square currently being visited
 * @param seen A hash set of squares that have been visited
 * @param goalRow The number of the row that we are trying to get to
 * @return True iff there is a path from current to the goal row
 */
private boolean localPathToGoal(Square current,HashSet<Square> seen,int goalRow){
  int row=current.getRow();
  int col=current.getCol();
  boolean found=(row == goalRow);
  if (!found) {
    seen.add(current);
    Square left=possibleSquare(col - 1,row);
    Square right=possibleSquare(col + 1,row);
    Square up=possibleSquare(col,row + 1);
    Square down=possibleSquare(col,row - 1);
    if (left != null && !seen.contains(left) && !wallBetween(current,left)) {
      found=localPathToGoal(left,seen,goalRow);
    }
    if (!found && right != null && !seen.contains(right) && !wallBetween(current,right)) {
      found=localPathToGoal(right,seen,goalRow);
    }
    if (!found && up != null && !seen.contains(up) && !wallBetween(current,up)) {
      found=localPathToGoal(up,seen,goalRow);
    }
    if (!found && down != null && !seen.contains(down) && !wallBetween(current,down)) {
      found=localPathToGoal(down,seen,goalRow);
    }
  }
  return found;
}","/** 
 * This is a helper function used by pathToGoal. It recursively checks neighbors until it finds a goal or all connected squares are searched.
 * @param current The square currently being visited
 * @param seen A hash set of squares that have been visited
 * @param goalRow The number of the row that we are trying to get to
 * @return True iff there is a path from current to the goal row
 */
private boolean localPathToGoal(Square current,HashSet<Square> seen,int goalRow){
  int row=current.getRow();
  int col=current.getCol();
  boolean found=(row == goalRow);
  if (!found) {
    seen.add(current);
    Square left=possibleSquare(col - 1,row);
    Square right=possibleSquare(col + 1,row);
    Square up=possibleSquare(col,row + 1);
    Square down=possibleSquare(col,row - 1);
    for (    Square s : seen) {
      System.out.print(s + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    if (left != null && !seen.contains(left) && !wallBetween(current,left)) {
      found=localPathToGoal(left,seen,goalRow);
    }
    boolean test=seen.contains(right);
    if (!found && right != null && !seen.contains(right) && !wallBetween(current,right)) {
      found=localPathToGoal(right,seen,goalRow);
    }
    if (!found && up != null && !seen.contains(up) && !wallBetween(current,up)) {
      found=localPathToGoal(up,seen,goalRow);
    }
    if (!found && down != null && !seen.contains(down) && !wallBetween(current,down)) {
      found=localPathToGoal(down,seen,goalRow);
    }
  }
  return found;
}",0.9422744555824404
181091,"/** 
 * Two squares are equal if they have the same row and column
 * @param s the Square being compared with this square
 * @return True iff the two squares are equal
 */
public boolean equals(Square s){
  return this.getRow() == s.getRow() && this.getCol() == s.getCol();
}","/** 
 * Two squares are equal if they have the same row and column
 * @param s the Square being compared with this square
 * @return True iff the two squares are equal
 */
@Override public boolean equals(Object o){
  Square s=(Square)o;
  return this.getRow() == s.getRow() && this.getCol() == s.getCol();
}",0.9381443298969072
181092,"@Override public boolean isValid(){
  Square temp;
  Square temp2;
  boolean valid=true;
  int destination_col=destination.getCol();
  int destination_row=destination.getRow();
  int start_col=start.getCol();
  int start_row=start.getRow();
  Square between=isTwoAway(start,destination);
  if (destination_col > 8 || destination_col < 0 || destination_row > 8 || destination_row < 0) {
    valid=false;
  }
 else   if (start == destination) {
    valid=false;
  }
 else   if (isAdjacent(start,destination)) {
    if (setting.wallBetween(start,destination) || destination.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      valid=false;
    }
  }
 else   if (between != null) {
    if (!between.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      valid=false;
    }
 else     if (setting.wallBetween(start,between) || setting.wallBetween(between,destination)) {
      valid=false;
    }
  }
 else   if (start_col - destination_col == 1 && start_row - destination_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col - 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row - 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
  }
 else   if (destination_col - start_col == 1 && start_row - destination_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col + 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row - 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
  }
 else   if (destination_col - start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col + 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row + 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
  }
 else   if (start_col - destination_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col - 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row + 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
  }
 else {
    valid=false;
  }
  return valid;
}","@Override public boolean isValid(){
  Square temp;
  Square temp2;
  boolean valid=true;
  int destination_col=destination.getCol();
  int destination_row=destination.getRow();
  int start_col=start.getCol();
  int start_row=start.getRow();
  Square between=isTwoAway(start,destination);
  if (destination_col > 8 || destination_col < 0 || destination_row > 8 || destination_row < 0) {
    valid=false;
  }
 else   if (start == destination) {
    valid=false;
  }
 else   if (isAdjacent(start,destination)) {
    if (setting.wallBetween(start,destination) || destination.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      valid=false;
    }
  }
 else   if (between != null) {
    if (!between.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      valid=false;
    }
 else     if (setting.wallBetween(start,between) || setting.wallBetween(between,destination)) {
      valid=false;
    }
  }
 else   if (start_col - destination_col == 1 && start_row - destination_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col - 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row - 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
 else {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && start_row - destination_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col + 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row - 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
 else {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col + 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row + 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
 else {
      valid=false;
    }
  }
 else   if (start_col - destination_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,start_row);
    temp2=new SquareImpl(start_col,destination_row);
    if (temp.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp2=new SquareImpl(destination_col - 1,start_row);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp,destination)) {
        valid=false;
      }
    }
 else     if (temp2.hasPawn(setting.getPawn(owner.getOpponent(),setting))) {
      temp=new SquareImpl(start_col,destination_row + 1);
      if (!setting.wallBetween(temp,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(start,temp2)) {
        valid=false;
      }
 else       if (setting.wallBetween(temp2,destination)) {
        valid=false;
      }
    }
 else {
      valid=false;
    }
  }
 else {
    valid=false;
  }
  return valid;
}",0.9863523573200992
181093,"@Override public void play(){
}","@Override public void play(){
  Player current=players._1();
  Pair<Pawn> pawns=new PairImpl<Pawn>(new PawnImpl(new SquareImpl(4,8),players._1()),new PawnImpl(new SquareImpl(4,0),players._2()));
  Board gameBoard=new BoardImpl(pawns);
  MoveParser parser=new MoveParserImpl();
  GenericMove nextMove;
  while (!isOver()) {
    System.out.println(gameBoard.toString());
    if (current.equals(players._1())) {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
    nextMove=parser.scanMove(current,gameBoard);
    if (nextMove == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      moves.add(nextMove);
      if (nextMove.isValid()) {
        nextMove.makeMove();
        current=current.getOpponent();
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}",0.0635897435897435
181094,"/** 
 * Checks if there is a wall between two given adjacent squares
 * @param a one of the squares
 * @param b the other square
 * @return True if there is a wall between the two squares
 */
private boolean wallBetween(Square a,Square b){
  assert(a.getRow() == b.getRow() || a.getCol() == b.getCol());
  Square topLeftMost;
  Square other;
  Pair<Square> topLeftCandidate;
  boolean wallDirection;
  Pair<Wall> candidateWalls;
  if (a.getRow() == b.getRow()) {
    assert(Math.abs(a.getCol() - b.getCol()) == 1);
    if (a.getCol() < b.getCol()) {
      topLeftMost=a;
    }
 else {
      topLeftMost=b;
    }
    wallDirection=Wall.VERTICAL;
    other=new SquareImpl(topLeftMost.getCol(),topLeftMost.getRow() + 1);
  }
 else {
    assert(Math.abs(a.getRow() - b.getRow()) == 1);
    if (a.getRow() > b.getRow()) {
      topLeftMost=a;
    }
 else {
      topLeftMost=b;
    }
    wallDirection=Wall.HORIZONTAL;
    other=new SquareImpl(topLeftMost.getCol() - 1,topLeftMost.getRow());
  }
  topLeftCandidate=new PairImpl<Square>(topLeftMost,other);
  candidateWalls=new PairImpl<Wall>(new WallImpl(topLeftCandidate._1(),wallDirection),new WallImpl(topLeftCandidate._2(),wallDirection));
  return walls.contains(candidateWalls._1()) || walls.contains(candidateWalls._2());
}","/** 
 * Checks if there is a wall between two given adjacent squares
 * @param a one of the squares
 * @param b the other square
 * @return True if there is a wall between the two squares
 */
public boolean wallBetween(Square a,Square b){
  assert(a.getRow() == b.getRow() || a.getCol() == b.getCol());
  Square topLeftMost;
  Square other;
  Pair<Square> topLeftCandidate;
  boolean wallDirection;
  Pair<Wall> candidateWalls;
  if (a.getRow() == b.getRow()) {
    assert(Math.abs(a.getCol() - b.getCol()) == 1);
    if (a.getCol() < b.getCol()) {
      topLeftMost=a;
    }
 else {
      topLeftMost=b;
    }
    wallDirection=Wall.VERTICAL;
    other=new SquareImpl(topLeftMost.getCol(),topLeftMost.getRow() - 1);
  }
 else {
    assert(Math.abs(a.getRow() - b.getRow()) == 1);
    if (a.getRow() < b.getRow()) {
      topLeftMost=a;
    }
 else {
      topLeftMost=b;
    }
    wallDirection=Wall.HORIZONTAL;
    other=new SquareImpl(topLeftMost.getCol() - 1,topLeftMost.getRow());
  }
  topLeftCandidate=new PairImpl<Square>(topLeftMost,other);
  candidateWalls=new PairImpl<Wall>(new WallImpl(topLeftCandidate._1(),wallDirection),new WallImpl(topLeftCandidate._2(),wallDirection));
  return walls.contains(candidateWalls._1()) || walls.contains(candidateWalls._2());
}",0.9941153393487642
181095,"@Override public String toString(){
  String board=""String_Node_Str"";
  int pawn1Row=pawns._1().getSquare().getRow();
  int pawn1Col=pawns._1().getSquare().getCol();
  int pawn2Row=pawns._2().getSquare().getRow();
  int pawn2Col=pawns._2().getSquare().getCol();
  for (int i=0; i < 9; i++) {
    board+=""String_Node_Str"" + i + ""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  for (  Wall w : walls) {
    System.out.println(w.topLeft().getRow());
    System.out.println(w.topLeft().getCol());
    System.out.println(w.getDirection());
  }
  if (wallBetween(new SquareImpl(3,4),new SquareImpl(4,4))) {
    System.out.println(""String_Node_Str"");
  }
  for (int i=0; i < 9 * 2 - 1; i++) {
    if (i % 2 == 0) {
      board+=i / 2 + ""String_Node_Str"";
    }
 else {
      board+=""String_Node_Str"";
    }
    for (int j=0; j < 9; j++) {
      if (wallBetween(new SquareImpl(j,i % 2),new SquareImpl(j + 1,i % 2)) == true) {
        System.out.println(""String_Node_Str"");
        board+=""String_Node_Str"";
      }
 else {
        board+=""String_Node_Str"";
      }
      if (i % 2 == 0) {
        if (pawn1Col == j && pawn1Row * 2 == i) {
          board+=""String_Node_Str"";
        }
 else         if (pawn2Col == j && pawn2Row * 2 == i) {
          board+=""String_Node_Str"";
        }
 else {
          board+=""String_Node_Str"";
        }
      }
 else {
        if (wallBetween(new SquareImpl(j,i % 2),new SquareImpl(j,i % 2 + 1)) == true) {
          board+=""String_Node_Str"";
        }
 else {
          board+=""String_Node_Str"";
        }
      }
    }
    board+=""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  for (int i=0; i < 9; i++) {
    board+=""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  return board;
}","@Override public String toString(){
  String board=""String_Node_Str"";
  int pawn1Row=pawns._1().getSquare().getRow();
  int pawn1Col=pawns._1().getSquare().getCol();
  int pawn2Row=pawns._2().getSquare().getRow();
  int pawn2Col=pawns._2().getSquare().getCol();
  for (int i=0; i < 9; i++) {
    board+=""String_Node_Str"" + i + ""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  for (  Wall w : walls) {
    System.out.println(w.topLeft().getRow());
    System.out.println(w.topLeft().getCol());
    System.out.println(w.getDirection());
  }
  for (int i=0; i < 9 * 2 - 1; i++) {
    if (i % 2 == 0) {
      board+=i / 2 + ""String_Node_Str"";
    }
 else {
      board+=""String_Node_Str"";
    }
    for (int j=0; j < 9; j++) {
      if (wallBetween(new SquareImpl(j,i % 2),new SquareImpl(j + 1,i % 2)) == true) {
        System.out.println(""String_Node_Str"");
        board+=""String_Node_Str"";
      }
 else {
        board+=""String_Node_Str"";
      }
      if (i % 2 == 0) {
        if (pawn1Col == j && pawn1Row * 2 == i) {
          board+=""String_Node_Str"";
        }
 else         if (pawn2Col == j && pawn2Row * 2 == i) {
          board+=""String_Node_Str"";
        }
 else {
          board+=""String_Node_Str"";
        }
      }
 else {
        if (wallBetween(new SquareImpl(j,i % 2),new SquareImpl(j,i % 2 + 1)) == true) {
          board+=""String_Node_Str"";
        }
 else {
          board+=""String_Node_Str"";
        }
      }
    }
    board+=""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  for (int i=0; i < 9; i++) {
    board+=""String_Node_Str"";
  }
  board+=""String_Node_Str"";
  return board;
}",0.4792102901585402
181096,"/** 
 * Constructor for a SquareImpl from a row and column
 * @param row the row of the square
 * @param col the column of the square
 */
public SquareImpl(int row,int col){
  this.row=row;
  this.col=col;
}","/** 
 * Constructor for a SquareImpl from a row and column
 * @param row the row of the square
 * @param col the column of the square
 */
public SquareImpl(int col,int row){
  this.row=row;
  this.col=col;
}",0.9710144927536232
181097,"@Override public void play(){
  Player current=players._1();
  Pair<Pawn> pawns=new PairImpl<Pawn>(new PawnImpl(new SquareImpl(4,8),players._1()),new PawnImpl(new SquareImpl(4,0),players._2()));
  Board gameBoard=new BoardImpl(pawns);
  MoveParser parser=new MoveParserImpl();
  GenericMove nextMove;
  System.out.println(gameBoard.toString());
  while (!isOver()) {
    if (current.equals(players._1())) {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
    nextMove=parser.scanMove(current,gameBoard);
    if (nextMove == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      moves.add(nextMove);
      if (nextMove.isValid()) {
        nextMove.makeMove();
        current=current.getOpponent();
        System.out.println(gameBoard.toString());
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","@Override public void play(){
  Player current=players._1();
  Pair<Pawn> pawns=new PairImpl<Pawn>(new PawnImpl(new SquareImpl(4,8),players._1()),new PawnImpl(new SquareImpl(4,0),players._2()));
  Board gameBoard=new BoardImpl(pawns);
  MoveParser parser=new MoveParserImpl();
  GenericMove nextMove;
  while (!isOver()) {
    System.out.println(gameBoard.toString());
    if (current == null) {
      System.out.println(""String_Node_Str"");
    }
    if (current.equals(players._1())) {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + current.getName() + ""String_Node_Str"");
    }
    nextMove=parser.scanMove(current,gameBoard);
    if (nextMove == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      moves.add(nextMove);
      if (nextMove.isValid()) {
        nextMove.makeMove();
        current=current.getOpponent();
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}",0.6355511420059583
181098,"/** 
 * Loops parsing input until the user invokes the exit command.
 * @param inputParser the input parser that parses users' input
 */
public static void inputLoop(Parser inputParser){
  boolean exit=false;
  short token;
  while (!exit) {
    System.out.print(PROMPT);
    token=inputParser.ensureCommand();
    if (token == EXIT) {
      exit=true;
    }
 else     if (token == NEW_GAME) {
      Pair<Player> players;
      if (inputParser.hasRequiredArgs()) {
        Player _1=new PlayerImpl(inputParser.nextArg());
        Player _2=new PlayerImpl(inputParser.nextArg());
        players=new PairImpl<Player>(_1,_2);
        _1.setOpponent(_2);
        _2.setOpponent(_2);
      }
 else {
        if (inputParser.hasErroneousArgs()) {
          System.out.println(""String_Node_Str"");
        }
        players=enterPlayers();
      }
      currentGame=new GameImpl(players);
      System.out.println(""String_Node_Str"".concat(players._1().getName()).concat(""String_Node_Str"").concat(players._2().getName()));
      currentGame.play();
    }
 else     if (token == HELP) {
      System.out.print(inputParser);
    }
 else     if (token == INVALID) {
      System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Loops parsing input until the user invokes the exit command.
 * @param inputParser the input parser that parses users' input
 */
public static void inputLoop(Parser inputParser){
  boolean exit=false;
  short token;
  while (!exit) {
    System.out.print(PROMPT);
    token=inputParser.ensureCommand();
    if (token == EXIT) {
      exit=true;
    }
 else     if (token == NEW_GAME) {
      Pair<Player> players;
      if (inputParser.hasRequiredArgs()) {
        Player _1=new PlayerImpl(inputParser.nextArg());
        Player _2=new PlayerImpl(inputParser.nextArg());
        players=new PairImpl<Player>(_1,_2);
        _1.setOpponent(_2);
        _2.setOpponent(_1);
      }
 else {
        if (inputParser.hasErroneousArgs()) {
          System.out.println(""String_Node_Str"");
        }
        players=enterPlayers();
      }
      currentGame=new GameImpl(players);
      System.out.println(""String_Node_Str"".concat(players._1().getName()).concat(""String_Node_Str"").concat(players._2().getName()));
      currentGame.play();
    }
 else     if (token == HELP) {
      System.out.print(inputParser);
    }
 else     if (token == INVALID) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.9991742361684558
181099,"/** 
 * Prompts the user to enter player names, then creates and returns a pair of players with those names.
 * @return A pair of players with names specified by the user
 */
public static Pair<Player> enterPlayers(){
  Player p1;
  Player p2;
  Scanner s=new Scanner(System.in);
  System.out.print(""String_Node_Str"");
  p1=new PlayerImpl(s.nextLine());
  System.out.print(""String_Node_Str"");
  p2=new PlayerImpl(s.nextLine());
  return new PairImpl<Player>(p1,p2);
}","/** 
 * Prompts the user to enter player names, then creates and returns a pair of players with those names.
 * @return A pair of players with names specified by the user
 */
public static Pair<Player> enterPlayers(){
  Player _1;
  Player _2;
  Scanner s=new Scanner(System.in);
  System.out.print(""String_Node_Str"");
  _1=new PlayerImpl(s.nextLine());
  System.out.print(""String_Node_Str"");
  _2=new PlayerImpl(s.nextLine());
  _1.setOpponent(_2);
  _2.setOpponent(_1);
  return new PairImpl<Player>(_1,_2);
}",0.9427402862985684
181100,"public GenericMove parseMove(String move,Player current,Board board){
  int len=move.length();
  boolean validInput=len == 2 || len == 3;
  int col=charNum(move.charAt(0));
  int row=-1;
  boolean type=GenericMove.PAWN;
  boolean dir=false;
  GenericMove result=null;
  ;
  if (validInput && row == -1) {
    validInput=false;
  }
 else   if (validInput) {
    row=parseInt(move.charAt(1)) - 1;
  }
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput && len == 3) {
    type=GenericMove.WALL;
    char dirChar=move.charAt(2);
    if (dirChar == 'h') {
      dir=Wall.HORIZONTAL;
    }
 else     if (dirChar == 'v') {
      dir=Wall.VERTICAL;
    }
 else {
      validInput=false;
    }
  }
  if (validInput) {
    if (type == GenericMove.PAWN) {
      result=new MovePawnImpl(col,row,current,board);
      System.out.println(len);
    }
 else     if (type == GenericMove.WALL) {
      result=new PlaceWallImpl(col,row,dir,current,board);
    }
  }
  return result;
}","public GenericMove parseMove(String move,Player current,Board board){
  int len=move.length();
  boolean validInput=len == 2 || len == 3;
  int col=-1;
  int row=-1;
  boolean type=GenericMove.PAWN;
  boolean dir=false;
  GenericMove result=null;
  ;
  col=charNum(move.charAt(0));
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput) {
    row=parseInt(move.charAt(1)) - 1;
  }
  if (validInput && col == -1) {
    validInput=false;
  }
 else   if (validInput && len == 3) {
    type=GenericMove.WALL;
    char dirChar=move.charAt(2);
    if (dirChar == 'h') {
      dir=Wall.HORIZONTAL;
    }
 else     if (dirChar == 'v') {
      dir=Wall.VERTICAL;
    }
 else {
      validInput=false;
    }
  }
  if (validInput) {
    if (type == GenericMove.PAWN) {
      result=new MovePawnImpl(col,row,current,board);
      System.out.println(len);
    }
 else     if (type == GenericMove.WALL) {
      result=new PlaceWallImpl(col,row,dir,current,board);
    }
  }
  return result;
}",0.9690309690309692
181101,"@Override public boolean isValid(){
  Square temp;
  Square temp2;
  boolean valid=true;
  int destination_col=destination.getCol();
  int destination_row=destination.getRow();
  int start_col=start.getCol();
  int start_row=start.getRow();
  Square between=isTwoAway(start,destination);
  if (destination_col > 8 || destination_col < 0 || destination_row > 8 || destination_row < 0) {
    valid=false;
  }
 else   if (start == destination) {
    valid=false;
  }
 else   if (isAdjacent(start,destination)) {
    if (setting.wallBetween(start,destination) || destination.hasPawn()) {
      valid=false;
    }
  }
 else   if (between != null) {
    if (!between.hasPawn()) {
      valid=false;
    }
 else     if (setting.wallBetween(start,between) || setting.wallBetween(between,destination)) {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row - start_row);
    temp2=new SquareImpl(destination_col - start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col + start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row - start_row);
    temp2=new SquareImpl(destination_col + start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && destination_row + start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row + start_row);
    temp2=new SquareImpl(destination_col - start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col + start_col == 1 && destination_row + start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row + start_row);
    temp2=new SquareImpl(destination_col + start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
  return valid;
}","@Override public boolean isValid(){
  Square temp;
  Square temp2;
  boolean valid=true;
  int destination_col=destination.getCol();
  int destination_row=destination.getRow();
  int start_col=start.getCol();
  int start_row=start.getRow();
  Square between=isTwoAway(start,destination);
  if (destination_col > 8 || destination_col < 0 || destination_row > 8 || destination_row < 0) {
    valid=false;
  }
 else   if (start == destination) {
    valid=false;
  }
 else   if (isAdjacent(start,destination)) {
    if (setting.wallBetween(start,destination) || destination.hasPawn()) {
      valid=false;
    }
  }
 else   if (between != null) {
    if (!between.hasPawn()) {
      valid=false;
    }
 else     if (setting.wallBetween(start,between) || setting.wallBetween(between,destination)) {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row - start_row);
    temp2=new SquareImpl(destination_col - start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col + start_col == 1 && destination_row - start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row - start_row);
    temp2=new SquareImpl(destination_col + start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col - start_col == 1 && destination_row + start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row + start_row);
    temp2=new SquareImpl(destination_col - start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else   if (destination_col + start_col == 1 && destination_row + start_row == 1) {
    temp=new SquareImpl(destination_col,destination_row + start_row);
    temp2=new SquareImpl(destination_col + start_col,destination_col);
    if (!temp.hasPawn() && !temp2.hasPawn()) {
      valid=false;
    }
  }
 else {
    valid=false;
  }
  return valid;
}",0.9929594561786842
181102,"@Override public void makeMove(){
  Pawn player=setting.getPawn(owner,setting);
  player.setSquare(destination);
  System.out.println(""String_Node_Str"" + setting);
}","@Override public void makeMove(){
  System.out.println(""String_Node_Str"" + setting);
  System.out.println(""String_Node_Str"" + owner.getName());
}",0.5548387096774193
181103,"@overide public String toString(){
  return null;
}","@Override public String toString(){
  return null;
}",0.970873786407767
181104,"public boolean contains(X item){
  return null;
}","public boolean contains(X item){
  return false;
}",0.9292929292929292
181105,"/** 
 * Sorting                                                                     
 */
private void inPlaceSort(int beginIndex,int endIndex,PSTPoint s){
  Sort.heapSort(tree,baseZeroIndex(beginIndex),baseZeroIndex(endIndex));
}","/** 
 * Sorting                                                                     
 */
private void inPlaceSort(int beginIndex,int endIndex,PSTPoint s){
  Sort.insertionSort(tree,baseZeroIndex(beginIndex),baseZeroIndex(endIndex));
}",0.9719222462203024
181106,"/** 
 * Testing                                                                     
 */
public static void main(String[] args){
  PSTPoint[] testPoints;
  if (args.length < 1) {
    testPoints=new PSTPoint[9];
    testPoints[0]=new PSTPoint(0,8);
    testPoints[1]=new PSTPoint(1,7);
    testPoints[2]=new PSTPoint(2,6);
    testPoints[3]=new PSTPoint(3,5);
    testPoints[4]=new PSTPoint(4,4);
    testPoints[5]=new PSTPoint(5,3);
    testPoints[6]=new PSTPoint(6,2);
    testPoints[7]=new PSTPoint(7,1);
    testPoints[8]=new PSTPoint(8,0);
    System.out.print(""String_Node_Str"");
    printArray(testPoints);
    InPlacePST ippst=new InPlacePST(testPoints);
    System.out.print(""String_Node_Str"");
    ippst.printArray();
  }
 else {
    System.out.println(""String_Node_Str"");
    int n=Integer.parseInt(args[0]);
    testPoints=new PSTPoint[2 * n];
    int count=0;
    for (int i=-n; i < n; i++) {
      if ((i % 2) == 0)       testPoints[count++]=new PSTPoint(i,i + n);
 else       testPoints[count++]=new PSTPoint(-i,-(i + n));
    }
    System.out.println(""String_Node_Str"" + (2 * n) + ""String_Node_Str"");
    if (n < 10) {
      System.out.print(""String_Node_Str"");
      printArray(testPoints);
    }
    InPlacePST ippst=new InPlacePST(testPoints);
    if (n < 10) {
      System.out.print(""String_Node_Str"");
      ippst.printArray();
    }
    System.out.println(""String_Node_Str"" + ippst.leftMostNE(-10,-10));
    System.out.println(""String_Node_Str"" + ippst.highestNE(1,-10));
    System.out.println(""String_Node_Str"" + ippst.highest3Sided(4,5,0));
    System.out.print(""String_Node_Str"");
    printArray(ippst.enumerate3Sided(1,7,-8).toArray(new PSTPoint[0]));
  }
}","/** 
 * Testing                                                                     
 */
public static void main(String[] args){
  PSTPoint[] testPoints;
  if (args.length < 1) {
    testPoints=new PSTPoint[7];
    testPoints[0]=new PSTPoint(0,8);
    testPoints[1]=new PSTPoint(1,7);
    testPoints[2]=new PSTPoint(2,6);
    testPoints[3]=new PSTPoint(3,5);
    testPoints[4]=new PSTPoint(4,4);
    testPoints[5]=new PSTPoint(5,3);
    testPoints[6]=new PSTPoint(6,2);
    System.out.print(""String_Node_Str"");
    printArray(testPoints);
    InPlacePST ippst=new InPlacePST(testPoints);
    System.out.print(""String_Node_Str"");
    ippst.printArray();
  }
 else {
    System.out.println(""String_Node_Str"");
    int n=Integer.parseInt(args[0]);
    testPoints=new PSTPoint[2 * n];
    int count=0;
    for (int i=-n; i < n; i++) {
      if ((i % 2) == 0)       testPoints[count++]=new PSTPoint(i,i + n);
 else       testPoints[count++]=new PSTPoint(-i,-(i + n));
    }
    System.out.println(""String_Node_Str"" + (2 * n) + ""String_Node_Str"");
    if (n < 10) {
      System.out.print(""String_Node_Str"");
      printArray(testPoints);
    }
    InPlacePST ippst=new InPlacePST(testPoints);
    if (n < 10) {
      System.out.print(""String_Node_Str"");
      ippst.printArray();
    }
    System.out.println(""String_Node_Str"" + ippst.leftMostNE(-10,-10));
    System.out.println(""String_Node_Str"" + ippst.highestNE(1,-10));
    System.out.println(""String_Node_Str"" + ippst.highest3Sided(4,5,0));
    System.out.print(""String_Node_Str"");
    printArray(ippst.enumerate3Sided(1,7,-8).toArray(new PSTPoint[0]));
  }
}",0.9769277474195508
181107,"private void buildLevel(int i){
  int n=tree.length;
  int h=(int)Math.floor(log2(n));
  int A=n - (powerOf2(h) - 1);
  int k=(int)Math.floor(A / powerOf2(h - i));
  PSTPoint s=getPoint(powerOf2(i + 1));
  int k1=powerOf2(h + 1 - i) - 1;
  int k2=powerOf2(h - i) - 1 + A - k * powerOf2(h - i);
  int k3=powerOf2(h - i) - 1;
  int indexOfMaxY;
  for (int j=1; j <= k; j++) {
    indexOfMaxY=powerOf2(i) + (j - 1) * k1;
    for (int index=indexOfMaxY; index <= powerOf2(i) + j * k1 - 1; index++)     if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))     indexOfMaxY=index;
    swap(indexOfMaxY,powerOf2(i) + j - 1);
  }
  indexOfMaxY=powerOf2(i) + k * k1;
  for (int index=indexOfMaxY; index <= powerOf2(i) + k * k1 + k2 - 1; index++) {
    if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))     indexOfMaxY=index;
  }
  swap(indexOfMaxY,powerOf2(i) + k);
  int m=powerOf2(i) + k * k1 + k2;
  for (int j=1; j <= powerOf2(i) - k - 1; j++) {
    indexOfMaxY=m + (j - 1) * k3;
    for (int index=indexOfMaxY; index <= m + j * k3 - 1; index++)     if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))     indexOfMaxY=index;
    swap(indexOfMaxY,powerOf2(i) + k + j);
  }
  inPlaceSort(powerOf2(i + 1),n,s);
}","private void buildLevel(int i){
  int n=tree.length;
  int h=(int)Math.floor(log2(n));
  int A=n - (powerOf2(h) - 1);
  int k=(int)Math.floor(A / powerOf2(h - i));
  PSTPoint s=getPoint(powerOf2(i + 1));
  int k1=powerOf2(h + 1 - i) - 1;
  int k2=powerOf2(h - i) - 1 + A - k * powerOf2(h - i);
  int k3=powerOf2(h - i) - 1;
  int indexOfMaxY;
  for (int j=1; j <= k; j++) {
    indexOfMaxY=powerOf2(i) + (j - 1) * k1;
    for (int index=indexOfMaxY; index <= powerOf2(i) + j * k1 - 1; index++)     if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))     indexOfMaxY=index;
    swap(indexOfMaxY,powerOf2(i) + j - 1);
  }
  if (k < powerOf2(i)) {
    indexOfMaxY=powerOf2(i) + k * k1;
    for (int index=indexOfMaxY; index <= powerOf2(i) + k * k1 + k2 - 1; index++) {
      if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))       indexOfMaxY=index;
    }
    swap(indexOfMaxY,powerOf2(i) + k);
    int m=powerOf2(i) + k * k1 + k2;
    for (int j=1; j <= powerOf2(i) - k - 1; j++) {
      indexOfMaxY=m + (j - 1) * k3;
      for (int index=indexOfMaxY; index <= m + j * k3 - 1; index++)       if (getPoint(index).yGreaterThan(getPoint(indexOfMaxY)))       indexOfMaxY=index;
      swap(indexOfMaxY,powerOf2(i) + k + j);
    }
  }
  inPlaceSort(powerOf2(i + 1),n,s);
}",0.9466933867735472
181108,"public InPlacePST(PSTPoint[] points){
  tree=points;
  Sort.heapSort(tree,0,tree.length - 1);
  int h=(int)Math.floor(log2(tree.length));
  for (int i=0; i <= h - 1; i++)   buildLevel(i);
}","public InPlacePST(PSTPoint[] points){
  tree=points;
  Sort.insertionSort(tree,0,tree.length - 1);
  int h=(int)Math.floor(log2(tree.length));
  for (int i=0; i <= h - 1; i++)   buildLevel(i);
}",0.9712793733681462
181109,"/** 
 * * FUNCTION NAME: leftMostNE                                                    * PURPOSE:       Determine the point with minimum x-coordinate among           all points {p  P | xmin  p.x  ymin  p.y}                  * PARAMETERS                                                                   Type/Name:   double/xmin                                                   Description: The minimum x coordinate to consider                          * Type/Name:   double/ymin                                                   Description: The minimum y coordinate to consider                          * RETURN:        The PSTPoint with minimum x-coordinate within given           boundaries.                                                   
 */
public PSTPoint leftMostNE(double xmin,double ymin){
  PSTPoint best=new PSTPoint(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);
  int indexP=1;
  int indexQ=1;
  while (!isLeaf(indexP)) {
    PSTPoint p=getPoint(indexP);
    if (xmin <= p.getX() && p.getY() >= ymin)     best=p;
    PSTPoint q=getPoint(indexQ);
    if (xmin <= q.getX() && q.getY() >= ymin)     best=q;
    if (indexP == indexQ) {
      if (numberOfChildren(indexP) == 1) {
        indexQ=indexOfLeftChild(indexP);
        indexP=indexOfLeftChild(indexP);
      }
 else {
        indexQ=indexOfRightChild(indexP);
        indexP=indexOfLeftChild(indexP);
      }
    }
 else {
      if (isLeaf(indexQ))       indexQ=indexP;
 else       if (numberOfChildren(indexQ) == 1) {
        PSTPoint ql=getPoint(indexOfLeftChild(indexQ));
        PSTPoint pr=getPoint(indexOfRightChild(indexP));
        if (ql.getY() < ymin) {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
 else         if (pr.getY() < ymin) {
          indexP=indexOfLeftChild(indexP);
          indexQ=indexOfLeftChild(indexQ);
        }
 else         if (ql.getX() < xmin) {
          indexP=indexOfLeftChild(indexQ);
          indexQ=indexOfLeftChild(indexQ);
        }
 else         if (pr.getX() < xmin) {
          indexP=indexOfRightChild(indexP);
          indexQ=indexOfLeftChild(indexQ);
        }
 else {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
      }
 else {
        PSTPoint ql=getPoint(indexOfLeftChild(indexQ));
        PSTPoint pr=getPoint(indexOfRightChild(indexP));
        PSTPoint pl=getPoint(indexOfLeftChild(indexP));
        if (pr.getX() >= xmin && pr.getY() >= ymin) {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
 else         if (pr.getX() < xmin) {
          if (ql.getX() < xmin) {
            indexP=indexOfLeftChild(indexQ);
            indexQ=indexOfRightChild(indexQ);
          }
 else           if (ql.getY() < ymin) {
            indexP=indexOfRightChild(indexP);
            indexQ=indexOfRightChild(indexQ);
          }
 else {
            indexP=indexOfRightChild(indexP);
            indexQ=indexOfLeftChild(indexQ);
          }
        }
 else {
          if (pl.getY() < ymin) {
            indexP=indexOfLeftChild(indexQ);
            indexQ=indexOfRightChild(indexQ);
          }
 else {
            indexP=indexOfLeftChild(indexP);
            if (ql.getY() >= ymin)             indexQ=indexOfLeftChild(indexQ);
 else             indexQ=indexOfRightChild(indexQ);
          }
        }
      }
    }
  }
  PSTPoint p=getPoint(indexP);
  if (xmin <= p.getX() && p.getY() >= ymin)   best=p;
  PSTPoint q=getPoint(indexQ);
  if (xmin <= q.getX() && q.getY() >= ymin)   best=q;
  return best;
}","/** 
 * * FUNCTION NAME: leftMostNE                                                    * PURPOSE:       Determine the point with minimum x-coordinate among           all points {p  P | xmin  p.x  ymin  p.y}                  * PARAMETERS                                                                   Type/Name:   double/xmin                                                   Description: The minimum x coordinate to consider                          * Type/Name:   double/ymin                                                   Description: The minimum y coordinate to consider                          * RETURN:        The PSTPoint with minimum x-coordinate within given           boundaries.                                                   
 */
public PSTPoint leftMostNE(double xmin,double ymin){
  PSTPoint best=new PSTPoint(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);
  int indexP=1;
  int indexQ=1;
  while (!isLeaf(indexP)) {
    PSTPoint p=getPoint(indexP);
    if (xmin <= p.getX() && p.getY() >= ymin && p.getX() < best.getX())     best=p;
    PSTPoint q=getPoint(indexQ);
    if (xmin <= q.getX() && q.getY() >= ymin && q.getX() < best.getX())     best=q;
    if (indexP == indexQ) {
      if (numberOfChildren(indexP) == 1) {
        indexQ=indexOfLeftChild(indexP);
        indexP=indexOfLeftChild(indexP);
      }
 else {
        indexQ=indexOfRightChild(indexP);
        indexP=indexOfLeftChild(indexP);
      }
    }
 else {
      if (isLeaf(indexQ))       indexQ=indexP;
 else       if (numberOfChildren(indexQ) == 1) {
        PSTPoint ql=getPoint(indexOfLeftChild(indexQ));
        PSTPoint pr=getPoint(indexOfRightChild(indexP));
        if (ql.getY() < ymin) {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
 else         if (pr.getY() < ymin) {
          indexP=indexOfLeftChild(indexP);
          indexQ=indexOfLeftChild(indexQ);
        }
 else         if (ql.getX() < xmin) {
          indexP=indexOfLeftChild(indexQ);
          indexQ=indexOfLeftChild(indexQ);
        }
 else         if (pr.getX() < xmin) {
          indexP=indexOfRightChild(indexP);
          indexQ=indexOfLeftChild(indexQ);
        }
 else {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
      }
 else {
        PSTPoint ql=getPoint(indexOfLeftChild(indexQ));
        PSTPoint pr=getPoint(indexOfRightChild(indexP));
        PSTPoint pl=getPoint(indexOfLeftChild(indexP));
        if (pr.getX() >= xmin && pr.getY() >= ymin) {
          indexQ=indexOfRightChild(indexP);
          indexP=indexOfLeftChild(indexP);
        }
 else         if (pr.getX() < xmin) {
          if (ql.getX() < xmin) {
            indexP=indexOfLeftChild(indexQ);
            indexQ=indexOfRightChild(indexQ);
          }
 else           if (ql.getY() < ymin) {
            indexP=indexOfRightChild(indexP);
            indexQ=indexOfRightChild(indexQ);
          }
 else {
            indexP=indexOfRightChild(indexP);
            indexQ=indexOfLeftChild(indexQ);
          }
        }
 else {
          if (pl.getY() < ymin) {
            indexP=indexOfLeftChild(indexQ);
            indexQ=indexOfRightChild(indexQ);
          }
 else {
            indexP=indexOfLeftChild(indexP);
            if (ql.getY() >= ymin)             indexQ=indexOfLeftChild(indexQ);
 else             indexQ=indexOfRightChild(indexQ);
          }
        }
      }
    }
  }
  PSTPoint p=getPoint(indexP);
  if (xmin <= p.getX() && p.getY() >= ymin && p.getX() < best.getX())   best=p;
  PSTPoint q=getPoint(indexQ);
  if (xmin <= q.getX() && q.getY() >= ymin && q.getX() < best.getX())   best=q;
  return best;
}",0.9856946354883082
181110,"private CharSequence getDecodingSourceCode(String affectationFormat,String indentation,String targetVariableName,String inputStreamVarName,Type parameterType,int recursionDepth){
  StringBuilder buffer=new StringBuilder();
  if (parameterType.getTypeKind() == TypeKind.Primitive) {
    PrimitiveType primitiveType=(PrimitiveType)parameterType;
    String primitiveName=primitiveType.getPrimitiveClass().getName();
    String valueName=inputStreamVarName + ""String_Node_Str"" + primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str"";
    buffer.append(indentation + String.format(affectationFormat,targetVariableName,valueName) + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.PrimitiveWrapper) {
    PrimitiveWrapperType primitiveWrapperType=(PrimitiveWrapperType)parameterType;
    String primitiveName=primitiveWrapperType.getPrimitiveClass().getName();
    String valueName=inputStreamVarName + ""String_Node_Str"" + primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str"";
    buffer.append(indentation + String.format(affectationFormat,targetVariableName,valueName) + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Array) {
    ArrayType arrayType=(ArrayType)parameterType;
    CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str""+ recursionDepth+ ""String_Node_Str"",inputStreamVarName,arrayType.getComponentType(),recursionDepth + 1);
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,arrayType.getComponentType(),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth),arrayType.getTypeWithNoArray(),arrayType.bracketToString().substring(2)));
  }
 else   if (parameterType.getTypeKind() == TypeKind.Enum) {
    EnumType enumType=(EnumType)parameterType;
    int nbEnumItems=enumType.getNbEnumItems();
    String enumOrdinalAsInt=inputStreamVarName + (nbEnumItems + 1 <= 256 ? ""String_Node_Str"" : (nbEnumItems + 1 <= 65536 ? ""String_Node_Str"" : ""String_Node_Str""));
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",indentation,recursionDepth,enumOrdinalAsInt,String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth + ""String_Node_Str""+ nbEnumItems+ ""String_Node_Str""+ enumType.getQualifiedClassName()+ ""String_Node_Str""+ recursionDepth+ ""String_Node_Str"") + ""String_Node_Str"") + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Declared) {
    DeclaredType declaredType=(DeclaredType)parameterType;
    if (declaredType.getTypeClass() == String.class) {
      buffer.append(indentation + String.format(affectationFormat,targetVariableName,inputStreamVarName + ""String_Node_Str"") + ""String_Node_Str"");
    }
 else     if (declaredType.getTypeClass() == List.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Set.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Collection.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Map.class) {
      CharSequence initKeyBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(1),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),toString(declaredType.getGenericArgumentTypeList().get(1)),inputStreamVarName,recursionDepth,initKeyBlock,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (modelData.getClassNameToVoClass().containsKey(parameterType.toString())) {
      VoClass voClass=modelData.getClassNameToVoClass().get(parameterType.toString());
      buffer.append(indentation + ""String_Node_Str"" + inputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(affectationFormat,targetVariableName,""String_Node_Str"" + getValueObjectName(voClass).getQualifiedName() + ""String_Node_Str""+ inputStreamVarName+ ""String_Node_Str"")+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(affectationFormat,targetVariableName,""String_Node_Str"")+ ""String_Node_Str"");
    }
 else {
      config.getProcessingEnv().getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + parameterType + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + parameterType+ ""String_Node_Str"");
    }
  }
  return buffer;
}","private CharSequence getDecodingSourceCode(String affectationFormat,String indentation,String targetVariableName,String inputStreamVarName,Type parameterType,int recursionDepth){
  StringBuilder buffer=new StringBuilder();
  if (parameterType.getTypeKind() == TypeKind.Primitive) {
    PrimitiveType primitiveType=(PrimitiveType)parameterType;
    String primitiveName=primitiveType.getPrimitiveClass().getName();
    String valueName=inputStreamVarName + ""String_Node_Str"" + primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str"";
    buffer.append(indentation + String.format(affectationFormat,targetVariableName,valueName) + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.PrimitiveWrapper) {
    PrimitiveWrapperType primitiveWrapperType=(PrimitiveWrapperType)parameterType;
    String primitiveName=primitiveWrapperType.getPrimitiveClass().getName();
    String valueName=inputStreamVarName + ""String_Node_Str"" + primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str"";
    buffer.append(indentation + String.format(affectationFormat,targetVariableName,valueName) + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Array) {
    ArrayType arrayType=(ArrayType)parameterType;
    CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str""+ recursionDepth+ ""String_Node_Str"",inputStreamVarName,arrayType.getComponentType(),recursionDepth + 1);
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(arrayType.getComponentType()),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth),toString(arrayType.getTypeWithNoArray()),arrayType.bracketToString().substring(2)));
  }
 else   if (parameterType.getTypeKind() == TypeKind.Enum) {
    EnumType enumType=(EnumType)parameterType;
    int nbEnumItems=enumType.getNbEnumItems();
    String enumOrdinalAsInt=inputStreamVarName + (nbEnumItems + 1 <= 256 ? ""String_Node_Str"" : (nbEnumItems + 1 <= 65536 ? ""String_Node_Str"" : ""String_Node_Str""));
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",indentation,recursionDepth,enumOrdinalAsInt,String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth + ""String_Node_Str""+ nbEnumItems+ ""String_Node_Str""+ enumType.getQualifiedClassName()+ ""String_Node_Str""+ recursionDepth+ ""String_Node_Str"") + ""String_Node_Str"") + ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Declared) {
    DeclaredType declaredType=(DeclaredType)parameterType;
    if (declaredType.getTypeClass() == String.class) {
      buffer.append(indentation + String.format(affectationFormat,targetVariableName,inputStreamVarName + ""String_Node_Str"") + ""String_Node_Str"");
    }
 else     if (declaredType.getTypeClass() == List.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Set.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Collection.class) {
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),inputStreamVarName,recursionDepth,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (declaredType.getTypeClass() == Map.class) {
      CharSequence initKeyBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      CharSequence initValueBlock=getDecodingSourceCode(""String_Node_Str"",indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,inputStreamVarName,declaredType.getGenericArgumentTypeList().get(1),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,toString(declaredType.getGenericArgumentTypeList().get(0)),toString(declaredType.getGenericArgumentTypeList().get(1)),inputStreamVarName,recursionDepth,initKeyBlock,initValueBlock,String.format(affectationFormat,targetVariableName,""String_Node_Str""),String.format(affectationFormat,targetVariableName,""String_Node_Str"" + recursionDepth)));
    }
 else     if (modelData.getClassNameToVoClass().containsKey(parameterType.toString())) {
      VoClass voClass=modelData.getClassNameToVoClass().get(parameterType.toString());
      buffer.append(indentation + ""String_Node_Str"" + inputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(affectationFormat,targetVariableName,""String_Node_Str"" + getValueObjectName(voClass).getQualifiedName() + ""String_Node_Str""+ inputStreamVarName+ ""String_Node_Str"")+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(affectationFormat,targetVariableName,""String_Node_Str"")+ ""String_Node_Str"");
    }
 else {
      config.getProcessingEnv().getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + parameterType + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + parameterType+ ""String_Node_Str"");
    }
  }
  return buffer;
}",0.9958378689889223
181111,"private CharSequence getEncodingSourceCode(String indentation,String valueName,String outputStreamVarName,Type parameterType,int recursionDepth){
  StringBuilder buffer=new StringBuilder();
  if (parameterType.getTypeKind() == TypeKind.Primitive) {
    PrimitiveType primitiveType=(PrimitiveType)parameterType;
    String primitiveName=primitiveType.getPrimitiveClass().getName();
    buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.PrimitiveWrapper) {
    PrimitiveWrapperType primitiveWrapperType=(PrimitiveWrapperType)parameterType;
    String primitiveName=primitiveWrapperType.getPrimitiveClass().getName();
    buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Array) {
    ArrayType arrayType=(ArrayType)parameterType;
    CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,outputStreamVarName,arrayType.getComponentType(),recursionDepth + 1);
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,arrayType.getComponentType(),recursionDepth,writeValueBlock));
  }
 else   if (parameterType.getTypeKind() == TypeKind.Enum) {
    EnumType enumType=(EnumType)parameterType;
    int nbEnumItems=enumType.getNbEnumItems();
    String enumWriteCommand=(nbEnumItems + 1 <= 256 ? ""String_Node_Str"" : (nbEnumItems + 1 <= 65536 ? ""String_Node_Str"" : ""String_Node_Str""));
    buffer.append(indentation + ""String_Node_Str"" + valueName+ ""String_Node_Str""+ outputStreamVarName+ enumWriteCommand+ ""String_Node_Str""+ nbEnumItems+ ""String_Node_Str"");
    buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ enumWriteCommand+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Declared) {
    DeclaredType declaredType=(DeclaredType)parameterType;
    if (declaredType.getTypeClass() == String.class) {
      buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ valueName+ ""String_Node_Str"");
    }
 else     if (declaredType.getTypeClass() == List.class || declaredType.getTypeClass() == Set.class || declaredType.getTypeClass() == Collection.class) {
      CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,outputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,toString(declaredType.getGenericArgumentTypeList().get(0)),recursionDepth,writeValueBlock));
    }
 else     if (declaredType.getTypeClass() == Map.class) {
      CharSequence writeKeyBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str"",outputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str"",outputStreamVarName,declaredType.getGenericArgumentTypeList().get(1),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,toString(declaredType.getGenericArgumentTypeList().get(0)),toString(declaredType.getGenericArgumentTypeList().get(1)),recursionDepth,writeKeyBlock,writeValueBlock));
    }
 else     if (modelData.getClassNameToVoClass().containsKey(parameterType.toString())) {
      buffer.append(indentation + ""String_Node_Str"" + valueName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(""String_Node_Str"",outputStreamVarName,valueName));
      buffer.append(indentation + ""String_Node_Str"");
    }
 else {
      config.getProcessingEnv().getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + parameterType + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + parameterType+ ""String_Node_Str"");
    }
  }
  return buffer;
}","private CharSequence getEncodingSourceCode(String indentation,String valueName,String outputStreamVarName,Type parameterType,int recursionDepth){
  StringBuilder buffer=new StringBuilder();
  if (parameterType.getTypeKind() == TypeKind.Primitive) {
    PrimitiveType primitiveType=(PrimitiveType)parameterType;
    String primitiveName=primitiveType.getPrimitiveClass().getName();
    buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.PrimitiveWrapper) {
    PrimitiveWrapperType primitiveWrapperType=(PrimitiveWrapperType)parameterType;
    String primitiveName=primitiveWrapperType.getPrimitiveClass().getName();
    buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ primitiveName.substring(0,1).toUpperCase()+ primitiveName.substring(1).toLowerCase()+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Array) {
    ArrayType arrayType=(ArrayType)parameterType;
    CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,outputStreamVarName,arrayType.getComponentType(),recursionDepth + 1);
    buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,toString(arrayType.getComponentType()),recursionDepth,writeValueBlock));
  }
 else   if (parameterType.getTypeKind() == TypeKind.Enum) {
    EnumType enumType=(EnumType)parameterType;
    int nbEnumItems=enumType.getNbEnumItems();
    String enumWriteCommand=(nbEnumItems + 1 <= 256 ? ""String_Node_Str"" : (nbEnumItems + 1 <= 65536 ? ""String_Node_Str"" : ""String_Node_Str""));
    buffer.append(indentation + ""String_Node_Str"" + valueName+ ""String_Node_Str""+ outputStreamVarName+ enumWriteCommand+ ""String_Node_Str""+ nbEnumItems+ ""String_Node_Str"");
    buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ enumWriteCommand+ ""String_Node_Str""+ valueName+ ""String_Node_Str"");
  }
 else   if (parameterType.getTypeKind() == TypeKind.Declared) {
    DeclaredType declaredType=(DeclaredType)parameterType;
    if (declaredType.getTypeClass() == String.class) {
      buffer.append(indentation + outputStreamVarName + ""String_Node_Str""+ valueName+ ""String_Node_Str"");
    }
 else     if (declaredType.getTypeClass() == List.class || declaredType.getTypeClass() == Set.class || declaredType.getTypeClass() == Collection.class) {
      CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth,outputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,toString(declaredType.getGenericArgumentTypeList().get(0)),recursionDepth,writeValueBlock));
    }
 else     if (declaredType.getTypeClass() == Map.class) {
      CharSequence writeKeyBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str"",outputStreamVarName,declaredType.getGenericArgumentTypeList().get(0),recursionDepth + 1);
      CharSequence writeValueBlock=getEncodingSourceCode(indentation + ""String_Node_Str"",""String_Node_Str"" + recursionDepth + ""String_Node_Str"",outputStreamVarName,declaredType.getGenericArgumentTypeList().get(1),recursionDepth + 1);
      buffer.append(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",indentation,outputStreamVarName,valueName,toString(declaredType.getGenericArgumentTypeList().get(0)),toString(declaredType.getGenericArgumentTypeList().get(1)),recursionDepth,writeKeyBlock,writeValueBlock));
    }
 else     if (modelData.getClassNameToVoClass().containsKey(parameterType.toString())) {
      buffer.append(indentation + ""String_Node_Str"" + valueName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + outputStreamVarName+ ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + String.format(""String_Node_Str"",outputStreamVarName,valueName));
      buffer.append(indentation + ""String_Node_Str"");
    }
 else {
      config.getProcessingEnv().getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + parameterType + ""String_Node_Str"");
      buffer.append(indentation + ""String_Node_Str"" + parameterType+ ""String_Node_Str"");
    }
  }
  return buffer;
}",0.9989975942261428
181112,"protected void generateValueObject(VoClass voClass){
  StringBuilder buffer=new StringBuilder();
  ClassName objectValueName=getValueObjectName(voClass);
  List<ModelField> fieldList=voClass.getFieldList();
  buffer.append(""String_Node_Str"" + objectValueName.getPackageName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(getGeneratedTag() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  for (  ModelField field : fieldList) {
    buffer.append(""String_Node_Str"" + field.getType() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  List<String> fieldDeclarationList=new ArrayList<String>();
  for (  ModelField field : fieldList)   fieldDeclarationList.add(field.getType() + ""String_Node_Str"" + field.getName());
  buffer.append(getCommaSeparatedSequence(fieldDeclarationList) + ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str""+ SmallDataInputStream.class.getName()+ ""String_Node_Str""+ IOException.class.getName()+ ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(getDecodingSourceCode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + field.getName(),""String_Node_Str"",field.getType(),0));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + SmallDataOutputStream.class.getName() + ""String_Node_Str""+ IOException.class.getName()+ ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(getEncodingSourceCode(""String_Node_Str"",""String_Node_Str"" + field.getName(),""String_Node_Str"",field.getType(),0));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  List<String> fieldLogList=new ArrayList<String>();
  for (  ModelField field : fieldList)   fieldLogList.add(field.getName() + ""String_Node_Str"");
  buffer.append(getCommaSeparatedSequence(fieldLogList,""String_Node_Str""));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  writeFileContent(objectValueName.getQualifiedName(),buffer);
}","protected void generateValueObject(VoClass voClass){
  StringBuilder buffer=new StringBuilder();
  ClassName objectValueName=getValueObjectName(voClass);
  List<ModelField> fieldList=voClass.getFieldList();
  buffer.append(""String_Node_Str"" + objectValueName.getPackageName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(getGeneratedTag() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  for (  ModelField field : fieldList) {
    buffer.append(""String_Node_Str"" + toString(field.getType()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str"");
  List<String> fieldDeclarationList=new ArrayList<String>();
  for (  ModelField field : fieldList)   fieldDeclarationList.add(toString(field.getType()) + ""String_Node_Str"" + field.getName());
  buffer.append(getCommaSeparatedSequence(fieldDeclarationList) + ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + objectValueName.getSimpleName() + ""String_Node_Str""+ SmallDataInputStream.class.getName()+ ""String_Node_Str""+ IOException.class.getName()+ ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(getDecodingSourceCode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + field.getName(),""String_Node_Str"",field.getType(),0));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + SmallDataOutputStream.class.getName() + ""String_Node_Str""+ IOException.class.getName()+ ""String_Node_Str"");
  for (  ModelField field : fieldList)   buffer.append(getEncodingSourceCode(""String_Node_Str"",""String_Node_Str"" + field.getName(),""String_Node_Str"",field.getType(),0));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  List<String> fieldLogList=new ArrayList<String>();
  for (  ModelField field : fieldList)   fieldLogList.add(field.getName() + ""String_Node_Str"");
  buffer.append(getCommaSeparatedSequence(fieldLogList,""String_Node_Str""));
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  writeFileContent(objectValueName.getQualifiedName(),buffer);
}",0.9964825888146324
181113,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  String name=((Player)sender).getDisplayName();
  User user=(userManager.userExists(name)) ? userManager.getUser((Player)sender) : null;
  if (user != null) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion(user,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation(user,args[2]);
        }
      }
    }
    return true;
  }
  ((Player)sender).sendMessage(""String_Node_Str"");
  return false;
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  String name=((Player)sender).getDisplayName();
  User user=(userManager.exists(name)) ? userManager.getUser((Player)sender) : null;
  if (user != null) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion(user,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation(user,args[2]);
        }
      }
    }
    return true;
  }
  ((Player)sender).sendMessage(""String_Node_Str"");
  return false;
}",0.9972627737226276
181114,"@Override public void onBlockBreak(BlockBreakEvent event){
  Player player=event.getPlayer();
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(player.getDisplayName())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}","@Override public void onBlockBreak(BlockBreakEvent event){
  User user=plugin.userManager.getUser(event.getPlayer());
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(user.getNation())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}",0.8460388639760837
181115,"@Override public void onBlockDamage(BlockDamageEvent event){
  Player player=event.getPlayer();
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(player.getDisplayName())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}","@Override public void onBlockDamage(BlockDamageEvent event){
  User user=plugin.userManager.getUser(event.getPlayer());
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(user.getNation())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}",0.8469539375928677
181116,"@Override public void onBlockPlace(BlockPlaceEvent event){
  Player player=event.getPlayer();
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(player.getDisplayName())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}","@Override public void onBlockPlace(BlockPlaceEvent event){
  User user=plugin.userManager.getUser(event.getPlayer());
  Plot plot=plugin.plotManager.getPlotAtLocation(event.getBlock().getLocation());
  if (plot != null && !plot.getOwner().equals(user.getNation())) {
    event.setCancelled(true);
    plugin.sendToLog(""String_Node_Str"");
  }
}",0.8460388639760837
181117,"@Override public void onPlayerKick(PlayerKickEvent event){
  String name=event.getPlayer().getDisplayName();
  plugin.userManager.saveObject(name);
  plugin.userManager.collection.remove(name);
}","@Override public void onPlayerKick(PlayerKickEvent event){
  String name=event.getPlayer().getDisplayName();
  plugin.userManager.saveObject(name);
}",0.8662790697674418
181118,"@Override public void onPlayerQuit(PlayerQuitEvent event){
  String name=event.getPlayer().getDisplayName();
  plugin.userManager.saveObject(name);
  plugin.userManager.collection.remove(name);
}","@Override public void onPlayerQuit(PlayerQuitEvent event){
  String name=event.getPlayer().getDisplayName();
  plugin.userManager.saveObject(name);
}",0.8662790697674418
181119,"@Override public void onPlayerMove(PlayerMoveEvent event){
  plugin.userManager.updateLocation(event.getPlayer());
}","@Override public void onPlayerMove(PlayerMoveEvent event){
  Player player=event.getPlayer();
  if (plugin.userManager.exists(player.getDisplayName())) {
    User user=plugin.userManager.getUser(player);
    plugin.userManager.updateLocation(user);
  }
}",0.5351351351351351
181120,"@Override public void onPlayerJoin(PlayerJoinEvent event){
  Player player=event.getPlayer();
  String name=player.getDisplayName();
  if (plugin.userManager.userExists(name)) {
    plugin.userManager.setupUser(player);
  }
 else {
    if (REGISTER_ON_JOIN) {
      plugin.userManager.registerUser(player);
      plugin.userManager.setupUser(player);
    }
 else {
      player.sendMessage(""String_Node_Str"");
      player.sendMessage(""String_Node_Str"");
    }
  }
}","@Override public void onPlayerJoin(PlayerJoinEvent event){
  Player player=event.getPlayer();
  String name=player.getDisplayName();
  if (plugin.userManager.exists(name)) {
    plugin.userManager.setupUser(player);
  }
 else {
    if (REGISTER_ON_JOIN) {
      plugin.userManager.registerUser(player);
      plugin.userManager.setupUser(player);
    }
 else {
      player.sendMessage(""String_Node_Str"");
      player.sendMessage(""String_Node_Str"");
    }
  }
}",0.9935344827586208
181121,"/** 
 * Fetches the Group for the provided group name, if it exists.
 * @param key The group name of the Group to get
 * @return the Group with a matching name
 */
public Group getGroup(String key){
  return (groupExists(key)) ? (Group)collection.get(key) : null;
}","/** 
 * Fetches the Group for the provided group name, if it exists.
 * @param key The group name of the Group to get
 * @return the Group with a matching name
 */
public Group getGroup(String key){
  return (exists(key)) ? (Group)collection.get(key) : null;
}",0.9866666666666668
181122,"/** 
 * Creates a nation Group for the commanding User and sets them in a position of leadership for that Group.
 * @param user The User creating the nation Group
 * @param name The name of the new nation Group
 */
public void foundNation(User user,String name){
  if (!groupExists(name)) {
    if (user.getNation().equals(""String_Node_Str"")) {
      Group group=new Group(name);
      group.addMember(user.getKey());
      group.addLeader(user.getKey());
      user.setNation(name);
      collection.put(name,group);
      saveObject(name);
      user.message(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"");
    }
  }
 else {
    user.message(""String_Node_Str"");
  }
}","/** 
 * Creates a nation Group for the commanding User and sets them in a position of leadership for that Group.
 * @param user The User creating the nation Group
 * @param name The name of the new nation Group
 */
public void foundNation(User user,String name){
  if (!exists(name)) {
    if (user.getNation().equals(""String_Node_Str"")) {
      Group group=new Group(name);
      group.addMember(user.getName());
      group.addLeader(user.getName());
      user.setNation(name);
      collection.put(name,group);
      saveObject(name);
      user.message(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"");
    }
  }
 else {
    user.message(""String_Node_Str"");
  }
}",0.985406532314107
181123,"/** 
 * Flags a Plot as being available for resale by the commanding User/Nation.
 * @param user The User reselling the Plot
 * @return true if the Plot resale status was toggled, falseotherwise
 */
public Boolean resellPlot(User user){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!plotExists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner().equals(user.getNation())) {
    plot.setSaleStatus(!plot.getSaleStatus());
    showBoundaries(plot);
    if (plot.getSaleStatus()) {
      user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    }
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}","/** 
 * Flags a Plot as being available for resale by the commanding User/Nation.
 * @param user The User reselling the Plot
 * @return true if the Plot resale status was toggled, falseotherwise
 */
public Boolean resellPlot(User user){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!exists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner().equals(user.getNation())) {
    plot.setSaleStatus(!plot.getSaleStatus());
    showBoundaries(plot);
    if (plot.getSaleStatus()) {
      user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    }
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}",0.9963942307692308
181124,"/** 
 * Renames the regional description of the Plot for the commanding User/Nation.
 * @param user The user renaming the Plot's region
 * @param region The new region description
 * @return true if the Plot's region was renamed, false otherwise
 */
public Boolean setRegion(User user,String region){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!plotExists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner() == user.getNation()) {
    plot.setRegion(region);
    saveObject(locKey);
    user.setCurrentLocationName(plot.getLoctionName());
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str""+ region);
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}","/** 
 * Renames the regional description of the Plot for the commanding User/Nation.
 * @param user The user renaming the Plot's region
 * @param region The new region description
 * @return true if the Plot's region was renamed, false otherwise
 */
public Boolean setRegion(User user,String region){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!exists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner().equals(user.getNation())) {
    plot.setRegion(region);
    saveObject(locKey);
    user.setCurrentLocationDescription(plot.getLoctionDescription());
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str""+ region);
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}",0.9701765063907486
181125,"/** 
 * Fetches the Plot for the provided location key, if it exists.
 * @param key The location key of the Plot to get
 * @return the Plot at the provided location key, null if no matching instance exists
 */
public Plot getPlot(String key){
  return (plotExists(key)) ? (Plot)collection.get(key) : null;
}","/** 
 * Fetches the Plot for the provided location key, if it exists.
 * @param key The location key of the Plot to get
 * @return the Plot at the provided location key, null if no matching instance exists
 */
public Plot getPlot(String key){
  return (exists(key)) ? (Plot)collection.get(key) : null;
}",0.9901639344262296
181126,"/** 
 * Creates a Plot (if none exists), gives ownership to the  commanding User/Nation, then loads the Plot into 'collection' and saves it to the data source.
 * @param user The User claiming the Plot
 * @return true if the Plot was created, false otherwise
 */
public Boolean claimPlot(User user){
  String locKey=user.getLocationKey();
  if (plotExists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user)) {
    Location loc=user.getLocation();
    Plot plot=new Plot(plugin.getWorld(),(int)loc.getX(),(int)loc.getZ());
    plot.setOwner(user.getNation());
    collection.put(locKey,plot);
    saveObject(locKey);
    plugin.groupManager.getGroup(user.getNation()).addPlot(locKey);
    showBoundaries(plot);
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}","/** 
 * Creates a Plot (if none exists), gives ownership to the  commanding User/Nation, then loads the Plot into 'collection' and saves it to the data source.
 * @param user The User claiming the Plot
 * @return true if the Plot was created, false otherwise
 */
public Boolean claimPlot(User user){
  String locKey=user.getLocationKey();
  if (exists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user)) {
    Location loc=user.getLocation();
    Plot plot=new Plot(plugin.getWorld(),(int)loc.getX(),(int)loc.getZ());
    plot.setOwner(user.getNation());
    collection.put(locKey,plot);
    user.setCurrentLocationDescription(plot.getLoctionDescription());
    saveObject(locKey);
    plugin.groupManager.getGroup(user.getNation()).addPlot(locKey);
    showBoundaries(plot);
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}",0.960292580982236
181127,"/** 
 * Fetches the Plot from a User's location
 * @param user The User at the Plot
 * @return the Plot at the User's location, nullif no Plot was found
 */
public Plot getPlotAtUser(User user){
  Plot plot=getPlot(user.getLocationKey());
  if (plot == null) {
    plugin.sendToLog(""String_Node_Str"" + user.getKey() + ""String_Node_Str"");
  }
  return plot;
}","/** 
 * Fetches the Plot from a User's location
 * @param user The User at the Plot
 * @return the Plot at the User's location, nullif no Plot was found
 */
public Plot getPlotAtUser(User user){
  Plot plot=getPlot(user.getLocationKey());
  if (plot == null) {
    plugin.sendToLog(""String_Node_Str"" + user.getName() + ""String_Node_Str"");
  }
  return plot;
}",0.99023709902371
181128,"/** 
 * Destroys the Plot and ownership settings for the commanding  User/Nation.
 * @param user The User destroying the Plot
 * @return true if the Plot was destroyed, false otherwise
 */
public Boolean razePlot(User user){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!plotExists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner().equals(user.getNation())) {
    collection.remove(locKey);
    deleteObject(locKey);
    plugin.groupManager.getGroup(user.getNation()).removePlot(locKey);
    user.setCurrentLocationName(""String_Node_Str"");
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}","/** 
 * Destroys the Plot and ownership settings for the commanding  User/Nation.
 * @param user The User destroying the Plot
 * @return true if the Plot was destroyed, false otherwise
 */
public Boolean razePlot(User user){
  String locKey=user.getLocationKey();
  Plot plot=getPlotAtUser(user);
  if (!exists(locKey)) {
    user.message(""String_Node_Str"");
    return false;
  }
  if (plugin.userManager.isLeader(user) && plot.getOwner().equals(user.getNation())) {
    collection.remove(locKey);
    deleteObject(locKey);
    plugin.groupManager.getGroup(user.getNation()).removePlot(locKey);
    user.setCurrentLocationDescription(""String_Node_Str"");
    user.message(""String_Node_Str"" + locKey + ""String_Node_Str"");
    return true;
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}",0.8484848484848485
181129,"private void check(){
  File file=new File(""String_Node_Str"");
  try {
    if (!file.exists()) {
      file.createNewFile();
      BufferedWriter out=new BufferedWriter(new FileWriter(file));
      for (      Object key : properties.keySet()) {
        out.write(key + ""String_Node_Str"" + properties.getProperty((String)key));
        out.newLine();
      }
      out.close();
    }
 else {
      properties.load(new FileInputStream(file));
      plugin.sendToLog(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
  }
}","private void check(){
  File folder=new File(""String_Node_Str"");
  File file=new File(""String_Node_Str"");
  try {
    if (!folder.exists()) {
      folder.mkdirs();
    }
    if (!file.exists()) {
      file.createNewFile();
      BufferedWriter out=new BufferedWriter(new FileWriter(file));
      for (      Object key : properties.keySet()) {
        out.write(key + ""String_Node_Str"" + properties.getProperty((String)key));
        out.newLine();
      }
      out.close();
      plugin.sendToLog(""String_Node_Str"");
    }
 else {
      properties.load(new FileInputStream(file));
      plugin.sendToLog(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
  }
}",0.8827694728560189
181130,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  String name=((Player)sender).getDisplayName();
  User user=(userManager.exists(name)) ? userManager.getUser((Player)sender) : null;
  ChatColor yellow=ChatColor.getByCode(14);
  ChatColor white=ChatColor.getByCode(15);
  if (user != null) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        user.message(yellow + ""String_Node_Str"");
        user.message(yellow + ""String_Node_Str"");
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.viewInvites();
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          userManager.acceptInvite(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.clearInvites();
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.rentPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.buyPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion(user,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.inviteUserToNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.kickUserFromNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.promoteUser(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.demoteUser(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.leaveNation(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(white + ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          ArrayList<String> allies=groupManager.getGroup(user.getNation()).getAllies();
          ArrayList<String> enemies=groupManager.getGroup(user.getNation()).getEnemies();
          String allyList=""String_Node_Str"";
          String enemyList=""String_Node_Str"";
          user.message(ChatColor.getByCode(5) + ""String_Node_Str"" + (groupManager.exists(user.getNation()) ? user.getNation() : ""String_Node_Str""));
          if (allies.size() > 0) {
            for (int i=0; i < allies.size(); i++) {
              allyList=allyList + allies.get(i) + ""String_Node_Str"";
            }
            user.message(ChatColor.getByCode(2) + ""String_Node_Str"" + allyList.substring(0,allyList.length() - 2)+ ""String_Node_Str"");
          }
 else {
            user.message(ChatColor.getByCode(2) + ""String_Node_Str"");
          }
          if (enemies.size() > 0) {
            for (int i=0; i < enemies.size(); i++) {
              enemyList=enemyList + enemies.get(i) + ""String_Node_Str"";
            }
            user.message(ChatColor.getByCode(12) + ""String_Node_Str"" + enemyList.substring(0,enemyList.length() - 2)+ ""String_Node_Str"");
          }
 else {
            user.message(ChatColor.getByCode(12) + ""String_Node_Str"");
          }
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"") && userManager.isLeader(user) == true) {
          groupManager.changeStatus(user,args[2],args[3]);
        }
      }
    }
    return true;
  }
  ((Player)sender).sendMessage(""String_Node_Str"");
  return false;
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  String name=((Player)sender).getDisplayName();
  User user=(userManager.exists(name)) ? userManager.getUser((Player)sender) : null;
  ChatColor yellow=ChatColor.getByCode(14);
  ChatColor white=ChatColor.getByCode(15);
  if (user != null) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        user.message(yellow + ""String_Node_Str"");
        user.message(yellow + ""String_Node_Str"");
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.viewInvites();
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          userManager.acceptInvite(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.clearInvites();
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.rentPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.buyPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion(user,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.inviteUserToNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.kickUserFromNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.promoteUser(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.demoteUser(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.leaveNation(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.renameNation(user,args[2]);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.setTaxRate(user,Integer.valueOf(args[2]));
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          user.message(yellow + ""String_Node_Str"");
          user.message(yellow + ""String_Node_Str"" + white+ ""String_Node_Str"");
          user.message(white + ""String_Node_Str"");
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          ArrayList<String> allies=groupManager.getGroup(user.getNation()).getAllies();
          ArrayList<String> enemies=groupManager.getGroup(user.getNation()).getEnemies();
          String allyList=""String_Node_Str"";
          String enemyList=""String_Node_Str"";
          user.message(ChatColor.getByCode(5) + ""String_Node_Str"" + (groupManager.exists(user.getNation()) ? user.getNation() : ""String_Node_Str""));
          if (allies.size() > 0) {
            for (int i=0; i < allies.size(); i++) {
              allyList=allyList + allies.get(i) + ""String_Node_Str"";
            }
            user.message(ChatColor.getByCode(2) + ""String_Node_Str"" + allyList.substring(0,allyList.length() - 2)+ ""String_Node_Str"");
          }
 else {
            user.message(ChatColor.getByCode(2) + ""String_Node_Str"");
          }
          if (enemies.size() > 0) {
            for (int i=0; i < enemies.size(); i++) {
              enemyList=enemyList + enemies.get(i) + ""String_Node_Str"";
            }
            user.message(ChatColor.getByCode(12) + ""String_Node_Str"" + enemyList.substring(0,enemyList.length() - 2)+ ""String_Node_Str"");
          }
 else {
            user.message(ChatColor.getByCode(12) + ""String_Node_Str"");
          }
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"") && userManager.isLeader(user) == true) {
          groupManager.changeStatus(user,args[2],args[3]);
        }
      }
    }
    return true;
  }
  ((Player)sender).sendMessage(""String_Node_Str"");
  return false;
}",0.990798269760126
181131,"/** 
 * Creates a nation Group for the commanding User and sets them in a position of leadership for that Group.
 * @param user The User creating the nation Group
 * @param name The name of the new nation Group
 */
public void foundNation(User user,String name){
  if (!exists(name)) {
    if (user.getNation().equals(""String_Node_Str"")) {
      Group group=new Group(name);
      group.addMember(user.getName());
      group.addLeader(user.getName());
      user.setNation(name);
      collection.put(name,group);
      saveObject(name);
      plugin.messageAll(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"");
    }
  }
 else {
    user.message(""String_Node_Str"");
  }
}","/** 
 * Creates a nation Group for the commanding User and sets them in a position of leadership for that Group.
 * @param user The User creating the nation Group
 * @param name The name of the new nation Group
 * @return true if the nation was founded, false otherwise
 */
public Boolean foundNation(User user,String name){
  if (!exists(name)) {
    if (user.getNation().equals(""String_Node_Str"")) {
      Group group=new Group(name);
      group.addMember(user.getName());
      group.addLeader(user.getName());
      user.setNation(name);
      collection.put(name,group);
      saveObject(name);
      plugin.messageAll(""String_Node_Str"" + name + ""String_Node_Str"");
      return true;
    }
 else {
      user.message(""String_Node_Str"");
      return false;
    }
  }
 else {
    user.message(""String_Node_Str"");
    return false;
  }
}",0.918849840255591
181132,"public Group(String n){
  name=n;
  members=new ArrayList<String>();
  leaders=new ArrayList<String>();
  plots=new ArrayList<String>();
  allies=new ArrayList<String>();
  enemies=new ArrayList<String>();
}","public Group(String n){
  name=n;
  tax=0;
  members=new ArrayList<String>();
  leaders=new ArrayList<String>();
  plots=new ArrayList<String>();
  allies=new ArrayList<String>();
  enemies=new ArrayList<String>();
}",0.9787234042553192
181133,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (userManager.collection.containsKey(((Player)sender).getDisplayName())) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot((Player)sender);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot((Player)sender);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot((Player)sender);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion((Player)sender,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation((Player)sender,args[2]);
        }
      }
    }
    return true;
  }
  return false;
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  String name=((Player)sender).getDisplayName();
  User user=(userManager.userExists(name)) ? userManager.getUser((Player)sender) : null;
  if (user != null) {
    if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.claimPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.razePlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.resellPlot(user);
        }
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          plotManager.setRegion(user,args[2]);
        }
      }
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          groupManager.foundNation(user,args[2]);
        }
      }
    }
    return true;
  }
  ((Player)sender).sendMessage(""String_Node_Str"");
  return false;
}",0.8666035950804163
181134,"public void onEnable(){
  setupPermissions();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_DAMAGE,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.BLOCK_PLACE,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_JOIN,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_QUIT,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_KICK,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_MOVE,userListener,Event.Priority.High,this);
  plotManager.loadAll();
  groupManager.loadAll();
  this.sendToLog(""String_Node_Str"");
}","public void onEnable(){
  setupPermissions();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_DAMAGE,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.BLOCK_PLACE,blockListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_JOIN,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_QUIT,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_KICK,userListener,Event.Priority.Normal,this);
  pm.registerEvent(Event.Type.PLAYER_MOVE,userListener,Event.Priority.High,this);
  plotManager.loadAll();
  groupManager.loadAll();
  userManager.loadAll();
  sendToLog(""String_Node_Str"");
}",0.9809160305343512
181135,"/** 
 * Deserializes and sends data to the server.
 * @param type The type of data being loaded. Determines theload path.
 * @param key The identification key of the data being loaded.Determines the file name.
 * @return the deserialized object
 */
@Override public NAWObject load(String type,String key){
  File file=new File(paths.get(type) + key);
  NAWObject obj=null;
  try {
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(file));
    obj=(NAWObject)in.readObject();
    in.close();
    plugin.sendToLog(key + ""String_Node_Str"");
    return obj;
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
    return null;
  }
catch (  ClassNotFoundException e) {
    plugin.sendToLog(e.getMessage());
    return null;
  }
}","/** 
 * Deserializes and sends data to the server.
 * @param type The type of data being loaded. Determines theload path.
 * @param key The identification key of the data being loaded.Determines the file name.
 * @return the deserialized object
 */
@Override public NAWObject load(String type,String key){
  File file=new File(paths.get(type) + key);
  NAWObject obj=null;
  try {
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(file));
    obj=(NAWObject)in.readObject();
    in.close();
    return obj;
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
  }
catch (  ClassNotFoundException e) {
    plugin.sendToLog(e.getMessage());
  }
  return null;
}",0.9337931034482758
181136,"/** 
 * Serializes and stores the data to a file.
 * @param type The type of data being saved. Determines thesave path.
 * @param key The identification key of the data being saved. Determines the file name.
 * @param obj The data to save
 */
public void save(String type,String key,NAWObject obj){
  File file=new File(paths.get(type) + key);
  try {
    if (!file.exists()) {
      file.createNewFile();
    }
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(file));
    out.writeObject(obj);
    out.close();
    plugin.sendToLog(key + ""String_Node_Str"");
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
  }
}","/** 
 * Serializes and stores the data to a file.
 * @param type The type of data being saved. Determines thesave path.
 * @param key The identification key of the data being saved. Determines the file name.
 * @param obj The data to save
 */
public void save(String type,String key,NAWObject obj){
  File file=new File(paths.get(type) + key);
  try {
    if (!file.exists()) {
      file.createNewFile();
    }
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(file));
    out.writeObject(obj);
    out.close();
  }
 catch (  IOException e) {
    plugin.sendToLog(e.getMessage());
  }
}",0.9627870150435472
181137,"@Override public void onPlayerJoin(PlayerJoinEvent event){
  Player player=event.getPlayer();
  player.sendMessage(""String_Node_Str"");
  if (plugin.userManager.loadUser(player)) {
    plugin.userManager.updateLocation(player);
  }
 else {
    if (registerOnJoin) {
      plugin.userManager.registerUser(player);
    }
 else {
      player.sendMessage(""String_Node_Str"");
      player.sendMessage(""String_Node_Str"");
    }
  }
}","@Override public void onPlayerJoin(PlayerJoinEvent event){
  Player player=event.getPlayer();
  String name=player.getDisplayName();
  if (plugin.userManager.userExists(name)) {
    plugin.userManager.loadUser(player);
  }
 else {
    if (REGISTER_ON_JOIN) {
      plugin.userManager.registerUser(player);
      plugin.userManager.loadUser(player);
    }
 else {
      player.sendMessage(""String_Node_Str"");
      player.sendMessage(""String_Node_Str"");
    }
  }
}",0.3277216610549944
181138,"public void foundNation(Player player,String name){
  if (!collection.containsKey(name)) {
    Group group=new Group(name);
    group.addMember(player.getDisplayName());
    group.setFounder(player.getDisplayName());
    collection.put(name,group);
    this.saveObject(name);
    player.sendMessage(""String_Node_Str"" + name + ""String_Node_Str"");
  }
 else {
    player.sendMessage(""String_Node_Str"");
  }
}","public void foundNation(User user,String name){
  if (!groupExists(name)) {
    if (user.getNation().equals(""String_Node_Str"")) {
      Group group=new Group(name);
      group.addMember(user.getKey());
      group.addLeader(user.getKey());
      user.setNation(name);
      collection.put(name,group);
      saveObject(name);
      user.message(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      user.message(""String_Node_Str"");
    }
  }
 else {
    user.message(""String_Node_Str"");
  }
}",0.2850877192982456
181139,"/** 
 * Stores all objects on the server to the data source
 */
public void saveAll(){
  for (  String key : collection.keySet()) {
    saveObject(key.toString());
  }
}","/** 
 * Stores all objects on the server to the data source
 */
public void saveAll(){
  for (  String key : collection.keySet()) {
    saveObject(key.toString());
  }
  plugin.sendToLog(String.valueOf(collection.size()) + ""String_Node_Str"" + type+ ""String_Node_Str"");
}",0.7699316628701595
181140,"/** 
 * Loads all objects from the data source to the server
 */
public void loadAll(){
  ArrayList<String> keys=database.gatherDataset(type);
  for (  String key : keys) {
    loadObject(key);
  }
}","/** 
 * Loads all objects from the data source to the server
 */
public void loadAll(){
  ArrayList<String> keys=database.gatherDataset(type);
  for (  String key : keys) {
    loadObject(key);
  }
  plugin.sendToLog(String.valueOf(collection.size()) + ""String_Node_Str"" + type+ ""String_Node_Str"");
}",0.7975951903807615
181141,"public static void main(String[] args){
  List<List<Double>> tuple1=simulate(new EconCost());
  List<List<Double>> tuple2=simulate(new ShortestPathCost());
  for (int i=0; i < tuple1.get(0).size(); i++) {
    System.out.println(tuple1.get(0).get(i) + ""String_Node_Str"" + tuple2.get(0).get(i));
  }
  for (int i=0; i < tuple1.get(1).size(); i++) {
    System.err.println(tuple1.get(1).get(i) + ""String_Node_Str"" + tuple2.get(1).get(i));
  }
}","public static void main(String[] args) throws IOException {
  List<List<Double>> tuple1=simulate(new EconCost());
  List<List<Double>> tuple2=simulate(new ShortestPathCost());
  BufferedWriter costOutput=new BufferedWriter(new FileWriter(new File(""String_Node_Str"")));
  BufferedWriter milesOutput=new BufferedWriter(new FileWriter(new File(""String_Node_Str"")));
  for (int i=0; i < tuple1.get(0).size(); i++) {
    costOutput.write(tuple1.get(0).get(i) + ""String_Node_Str"" + tuple2.get(0).get(i));
    costOutput.newLine();
  }
  for (int i=0; i < tuple1.get(1).size(); i++) {
    milesOutput.write(tuple1.get(1).get(i) + ""String_Node_Str"" + tuple2.get(1).get(i));
    milesOutput.newLine();
  }
  costOutput.close();
  milesOutput.close();
}",0.6858108108108109
181142,"private static List<List<Double>> simulate(Comparator<Route> routeMetric){
  List<List<Double>> tuple=new ArrayList<List<Double>>();
  tuple.add(new ArrayList<Double>());
  tuple.add(new ArrayList<Double>());
  Internet myInternet=new Internet(routeMetric);
  boolean stop=false;
  while (!stop) {
    stop=true;
    for (    POP pop : myInternet.getAllPOPs()) {
      stop=pop.propogate() && stop;
    }
  }
  for (  POP pop : myInternet.getAllPOPs()) {
    List<Route> routes=pop.getRoutes();
    for (    Route r : routes) {
      tuple.get(0).add(r.getCost());
      tuple.get(1).add(r.getMiles());
    }
  }
  return tuple;
}","private static List<List<Double>> simulate(Comparator<Route> routeMetric){
  List<List<Double>> tuple=new ArrayList<List<Double>>();
  tuple.add(new ArrayList<Double>());
  tuple.add(new ArrayList<Double>());
  Internet myInternet=new Internet(routeMetric);
  int iterations=0;
  for (; ; ) {
    iterations++;
    boolean someoneChanged=false;
    for (    POP pop : myInternet.getAllPOPs()) {
      boolean changed=pop.propogate();
      if (changed)       someoneChanged=true;
    }
    if (!someoneChanged)     break;
  }
  System.err.println(""String_Node_Str"" + iterations);
  for (  POP pop : myInternet.getAllPOPs()) {
    List<Route> routes=pop.getRoutes();
    for (    Route r : routes) {
      tuple.get(0).add(r.getCost());
      tuple.get(1).add(r.getMiles());
    }
  }
  return tuple;
}",0.8134171907756813
181143,"public void setJSONObject(JSONObject jsonObject){
  Iterator itr=jsonObject.keys();
  while (itr.hasNext()) {
    try {
      String key=(String)itr.next();
      Object value=jsonObject.opt(key);
      Field field=this.getClass().getField(key);
      Class type=field.getType();
      int fieldModifiers=field.getModifiers();
      if (type.isPrimitive()) {
        if (type.equals(Integer.class)) {
          field.setInt(this,jsonObject.getInt(key));
        }
 else         if (type.equals(Double.class)) {
          field.setDouble(this,jsonObject.getDouble(key));
        }
      }
 else       if (type.isArray() && value instanceof JSONArray) {
        JSONArray jsonArray=(JSONArray)value;
        Object[] values=(Object[])Array.newInstance(type,jsonArray.length());
        for (int j=0; j < jsonArray.length(); j++) {
          Resource resource=(Resource)type.newInstance();
          resource.setJSONObject(jsonArray.getJSONObject(j));
          values[j]=resource;
        }
        field.set(this,values);
      }
 else       if (Resource.class.isAssignableFrom(type) && value instanceof JSONObject) {
        Resource resource=(Resource)type.newInstance();
        resource.setJSONObject((JSONObject)value);
        field.set(this,resource);
      }
 else       if (type.equals(String.class) && value instanceof String) {
        field.set(this,(String)value);
      }
    }
 catch (    Exception nsfe) {
      System.err.println(""String_Node_Str"" + nsfe.getMessage());
    }
  }
}","public void setJSONObject(JSONObject jsonObject){
  Iterator itr=jsonObject.keys();
  while (itr.hasNext()) {
    String key=(String)itr.next();
    Object value=jsonObject.opt(key);
    try {
      Field field=this.getClass().getField(key);
      Class type=field.getType();
      int fieldModifiers=field.getModifiers();
      if (type.isPrimitive()) {
        if (type.equals(Integer.class)) {
          field.setInt(this,jsonObject.getInt(key));
        }
 else         if (type.equals(Double.class)) {
          field.setDouble(this,jsonObject.getDouble(key));
        }
      }
 else       if (type.isArray() && value instanceof JSONArray) {
        JSONArray jsonArray=(JSONArray)value;
        Object[] values=(Object[])Array.newInstance(type,jsonArray.length());
        for (int j=0; j < jsonArray.length(); j++) {
          Resource resource=(Resource)type.newInstance();
          resource.setJSONObject(jsonArray.getJSONObject(j));
          values[j]=resource;
        }
        field.set(this,values);
      }
 else       if (Resource.class.isAssignableFrom(type) && value instanceof JSONObject) {
        Resource resource=(Resource)type.newInstance();
        resource.setJSONObject((JSONObject)value);
        field.set(this,resource);
      }
 else       if (type.equals(String.class) && value instanceof String) {
        field.set(this,(String)value);
      }
    }
 catch (    Exception nsfe) {
      System.err.println(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str""+ nsfe.getMessage());
    }
  }
}",0.933903321275896
181144,"public static void main(String[] args) throws IOException, TrafficspacesAPIException {
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  if (args == null || args.length != 2) {
    System.out.println(""String_Node_Str"" + APITest.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ConnectorFactory factory=new ConnectorFactory(args[0],args[1]);
  Properties props=null;
  props=new java.util.Properties();
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",""String_Node_Str"");
  List zones=factory.getZoneConnector().find(props);
  System.out.println(""String_Node_Str"" + zones.size() + ""String_Node_Str"");
  List ads=factory.getAdConnector().find(props);
  System.out.println(""String_Node_Str"" + ads.size() + ""String_Node_Str"");
}","public static void main(String[] args) throws IOException, TrafficspacesAPIException {
  if (args == null || args.length != 2) {
    System.out.println(""String_Node_Str"" + APITest.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ConnectorFactory factory=new ConnectorFactory(args[0],args[1]);
  Properties props=null;
  props=new java.util.Properties();
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",""String_Node_Str"");
  List zones=factory.getZoneConnector().find(props);
  System.out.println(""String_Node_Str"" + zones.size() + ""String_Node_Str"");
  List ads=factory.getAdConnector().find(props);
  System.out.println(""String_Node_Str"" + ads.size() + ""String_Node_Str"");
}",0.961436170212766
181145,"/** 
 * UTILITY FUNCTIONS       
 */
protected String sendRequest(String path,String format,String method,String data) throws IOException, TrafficspacesAPIException {
}","/** 
 * UTILITY FUNCTIONS       
 */
protected String sendRequest(String path,String format,String method,String data) throws IOException, TrafficspacesAPIException {
  URL url=new URL(endPoint.baseURI + path);
  HttpURLConnection httpCon=(HttpURLConnection)url.openConnection();
  httpCon.setDoOutput(true);
  httpCon.setRequestMethod(method.toUpperCase());
  String basicAuth=""String_Node_Str"" + Base64.encode((endPoint.username + ""String_Node_Str"" + endPoint.password).getBytes());
  httpCon.setRequestProperty(""String_Node_Str"",basicAuth);
  String contentType=format.equalsIgnoreCase(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  httpCon.setRequestProperty(""String_Node_Str"",contentType + ""String_Node_Str"");
  httpCon.setRequestProperty(""String_Node_Str"",contentType);
  if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
    httpCon.setRequestProperty(""String_Node_Str"",data.length());
    OutputStreamWriter out=new OutputStreamWriter(httpCon.getOutputStream());
    out.write(data);
    out.close();
  }
 else {
    httpCon.connect();
  }
  String responseData=readResponseData(httpCon.getInputStream());
  int responseCode=httpCon.getResponseCode();
  if (responseCode != HttpURLConnection.HTTP_OK && responseCode != HttpURLConnection.HTTP_CREATED) {
    throw new TrafficspacesAPIException(responseCode,responseData);
  }
  return responseData;
}",0.2118537200504413
181146,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 * @param confirm true if user confirmation is needed before shutting down.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog;
    if (mReboot) {
      dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.reboot_system).setSingleChoiceItems(com.android.internal.R.array.shutdown_reboot_options,0,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          if (which < 0)           return;
          String actions[]=context.getResources().getStringArray(com.android.internal.R.array.shutdown_reboot_actions);
          if (actions != null && which < actions.length)           mRebootReason=actions[which];
        }
      }
).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          mReboot=true;
          beginShutdownSequence(context);
        }
      }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    }
 else {
      dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          beginShutdownSequence(context);
        }
      }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    }
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 * @param confirm true if user confirmation is needed before shutting down.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog;
    if (mReboot) {
      dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.reboot_system).setSingleChoiceItems(com.android.internal.R.array.shutdown_reboot_options,0,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          if (which < 0)           return;
          String actions[]=context.getResources().getStringArray(com.android.internal.R.array.shutdown_reboot_actions);
          if (actions != null && which < actions.length)           mRebootReason=actions[which];
        }
      }
).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          mReboot=true;
          beginShutdownSequence(context);
        }
      }
).setNegativeButton(com.android.internal.R.string.no,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          mReboot=false;
          dialog.cancel();
        }
      }
).setOnCancelListener(new DialogInterface.OnCancelListener(){
        public void onCancel(        DialogInterface dialog){
          mReboot=false;
        }
      }
).create();
    }
 else {
      dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          beginShutdownSequence(context);
        }
      }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    }
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}",0.9299862718180036
181147,"private boolean isBatteryUpdateInteresting(int batteryStatus,int batteryLevel){
  final boolean isPluggedIn=isPluggedIn(batteryStatus);
  final boolean wasPluggedIn=isPluggedIn(mBatteryStatus);
  final boolean stateChangedWhilePluggedIn=wasPluggedIn == true && isPluggedIn == true && (mBatteryStatus != batteryStatus);
  if (wasPluggedIn != isPluggedIn || stateChangedWhilePluggedIn) {
    return true;
  }
  if (isPluggedIn && mBatteryLevel != batteryLevel) {
    return true;
  }
  if (!isPluggedIn) {
    if (isBatteryLow(batteryLevel) && batteryLevel != mBatteryLevel) {
      return true;
    }
  }
  return false;
}","private boolean isBatteryUpdateInteresting(int batteryStatus,int batteryLevel){
  final boolean isPluggedIn=isPluggedIn(batteryStatus);
  final boolean wasPluggedIn=isPluggedIn(mBatteryStatus);
  final boolean stateChangedWhilePluggedIn=wasPluggedIn == true && isPluggedIn == true && (mBatteryStatus != batteryStatus);
  if (wasPluggedIn != isPluggedIn || stateChangedWhilePluggedIn) {
    return true;
  }
  if (mBatteryLevel != batteryLevel) {
    return true;
  }
  return false;
}",0.8506787330316742
181148,"/** 
 * After a change in the connectivity state of any network, We're mainly concerned with making sure that the list of DNS servers is setupup according to which networks are connected, and ensuring that the right routing table entries exist.
 */
private void handleConnectivityChange(int netType){
  handleDnsConfigurationChange(netType);
  if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].addDefaultRoute();
    }
 else {
      mNetTrackers[netType].addPrivateDnsRoutes();
    }
  }
 else {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].removeDefaultRoute();
    }
 else {
      mNetTrackers[netType].removePrivateDnsRoutes();
    }
  }
}","/** 
 * After a change in the connectivity state of any network, We're mainly concerned with making sure that the list of DNS servers is setupup according to which networks are connected, and ensuring that the right routing table entries exist.
 */
private void handleConnectivityChange(int netType){
  handleDnsConfigurationChange(netType);
  if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].addDefaultRoute();
    }
 else {
      if (mActiveDefaultNetwork != -1) {
        String defaultIface=mNetTrackers[mActiveDefaultNetwork].getInterfaceName();
        if (defaultIface != null && !defaultIface.equals(mNetTrackers[netType].getInterfaceName())) {
          mNetTrackers[netType].removeDefaultRoute();
        }
      }
      mNetTrackers[netType].addPrivateDnsRoutes();
    }
  }
 else {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].removeDefaultRoute();
    }
 else {
      mNetTrackers[netType].removePrivateDnsRoutes();
    }
  }
}",0.827357970215113
181149,"/** 
 * Return NetworkInfo for the active (i.e., connected) network interface. It is assumed that at most one network is active at a time. If more than one is active, it is indeterminate which will be returned.
 * @return the info for the active network, or {@code null} if none isactive
 */
public NetworkInfo getActiveNetworkInfo(){
  enforceAccessPermission();
  for (int type=0; type <= ConnectivityManager.MAX_NETWORK_TYPE; type++) {
    if (mNetAttributes[type] == null || !mNetAttributes[type].isDefault()) {
      continue;
    }
    NetworkStateTracker t=mNetTrackers[type];
    NetworkInfo info=t.getNetworkInfo();
    if (info.isConnected()) {
      if (DBG && type != mActiveDefaultNetwork)       Slog.e(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return info;
    }
  }
  return null;
}","/** 
 * Return NetworkInfo for the active (i.e., connected) network interface. It is assumed that at most one network is active at a time. If more than one is active, it is indeterminate which will be returned.
 * @return the info for the active network, or {@code null} if none isactive
 */
public NetworkInfo getActiveNetworkInfo(){
  enforceAccessPermission();
  if (mActiveDefaultNetwork != -1) {
    return mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
  }
  return null;
}",0.6119287374128582
181150,"/** 
 * After a change in the connectivity state of any network, We're mainly concerned with making sure that the list of DNS servers is setupup according to which networks are connected, and ensuring that the right routing table entries exist.
 */
private void handleConnectivityChange(int netType){
  handleDnsConfigurationChange(netType);
  if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].addDefaultRoute();
    }
 else {
      mNetTrackers[netType].addPrivateDnsRoutes();
    }
  }
 else {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].removeDefaultRoute();
    }
 else {
      mNetTrackers[netType].removePrivateDnsRoutes();
    }
  }
}","/** 
 * After a change in the connectivity state of any network, We're mainly concerned with making sure that the list of DNS servers is setupup according to which networks are connected, and ensuring that the right routing table entries exist.
 */
private void handleConnectivityChange(int netType){
  handleDnsConfigurationChange(netType);
  if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].addDefaultRoute();
    }
 else {
      if (mActiveDefaultNetwork != -1) {
        String defaultIface=mNetTrackers[mActiveDefaultNetwork].getInterfaceName();
        if (defaultIface != null && !defaultIface.equals(mNetTrackers[netType].getInterfaceName())) {
          mNetTrackers[netType].removeDefaultRoute();
        }
      }
      mNetTrackers[netType].addPrivateDnsRoutes();
    }
  }
 else {
    if (mNetAttributes[netType].isDefault()) {
      mNetTrackers[netType].removeDefaultRoute();
    }
 else {
      mNetTrackers[netType].removePrivateDnsRoutes();
    }
  }
}",0.827357970215113
181151,"/** 
 * Return NetworkInfo for the active (i.e., connected) network interface. It is assumed that at most one network is active at a time. If more than one is active, it is indeterminate which will be returned.
 * @return the info for the active network, or {@code null} if none isactive
 */
public NetworkInfo getActiveNetworkInfo(){
  enforceAccessPermission();
  for (int type=0; type <= ConnectivityManager.MAX_NETWORK_TYPE; type++) {
    if (mNetAttributes[type] == null || !mNetAttributes[type].isDefault()) {
      continue;
    }
    NetworkStateTracker t=mNetTrackers[type];
    NetworkInfo info=t.getNetworkInfo();
    if (info.isConnected()) {
      if (DBG && type != mActiveDefaultNetwork)       Slog.e(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return info;
    }
  }
  return null;
}","/** 
 * Return NetworkInfo for the active (i.e., connected) network interface. It is assumed that at most one network is active at a time. If more than one is active, it is indeterminate which will be returned.
 * @return the info for the active network, or {@code null} if none isactive
 */
public NetworkInfo getActiveNetworkInfo(){
  enforceAccessPermission();
  if (mActiveDefaultNetwork != -1) {
    return mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
  }
  return null;
}",0.6119287374128582
181152,"/** 
 * Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16. If R.length == 9, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> If R.length == 16, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   0  \ |  R[ 4]   R[ 5]   R[ 6]   0  | |  R[ 8]   R[ 9]   R[10]   0  | \  0       0       0       1  / </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */
public static void getRotationMatrixFromVector(float[] R,float[] rotationVector){
  float q0;
  float q1=rotationVector[0];
  float q2=rotationVector[1];
  float q3=rotationVector[2];
  if (rotationVector.length == 4) {
    q0=rotationVector[3];
  }
 else {
    q0=(float)Math.sqrt(1 - q1 * q1 - q2 * q2 - q3 * q3);
  }
  float sq_q1=2 * q1 * q1;
  float sq_q2=2 * q2 * q2;
  float sq_q3=2 * q3 * q3;
  float q1_q2=2 * q1 * q2;
  float q3_q0=2 * q3 * q0;
  float q1_q3=2 * q1 * q3;
  float q2_q0=2 * q2 * q0;
  float q2_q3=2 * q2 * q3;
  float q1_q0=2 * q1 * q0;
  if (R.length == 9) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=q1_q2 + q3_q0;
    R[4]=1 - sq_q1 - sq_q3;
    R[5]=q2_q3 - q1_q0;
    R[6]=q1_q3 - q2_q0;
    R[7]=q2_q3 + q1_q0;
    R[8]=1 - sq_q1 - sq_q2;
  }
 else   if (R.length == 16) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=0.0f;
    R[4]=q1_q2 + q3_q0;
    R[5]=1 - sq_q1 - sq_q3;
    R[6]=q2_q3 - q1_q0;
    R[7]=0.0f;
    R[8]=q1_q3 - q2_q0;
    R[9]=q2_q3 + q1_q0;
    R[10]=1 - sq_q1 - sq_q2;
    R[11]=0.0f;
    R[12]=R[13]=R[14]=0.0f;
    R[15]=1.0f;
  }
}","/** 
 * Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16. If R.length == 9, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> If R.length == 16, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   0  \ |  R[ 4]   R[ 5]   R[ 6]   0  | |  R[ 8]   R[ 9]   R[10]   0  | \  0       0       0       1  / </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */
public static void getRotationMatrixFromVector(float[] R,float[] rotationVector){
  float q0;
  float q1=rotationVector[0];
  float q2=rotationVector[1];
  float q3=rotationVector[2];
  if (rotationVector.length == 4) {
    q0=rotationVector[3];
  }
 else {
    q0=1 - q1 * q1 - q2 * q2 - q3 * q3;
    q0=(q0 > 0) ? (float)Math.sqrt(q0) : 0;
  }
  float sq_q1=2 * q1 * q1;
  float sq_q2=2 * q2 * q2;
  float sq_q3=2 * q3 * q3;
  float q1_q2=2 * q1 * q2;
  float q3_q0=2 * q3 * q0;
  float q1_q3=2 * q1 * q3;
  float q2_q0=2 * q2 * q0;
  float q2_q3=2 * q2 * q3;
  float q1_q0=2 * q1 * q0;
  if (R.length == 9) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=q1_q2 + q3_q0;
    R[4]=1 - sq_q1 - sq_q3;
    R[5]=q2_q3 - q1_q0;
    R[6]=q1_q3 - q2_q0;
    R[7]=q2_q3 + q1_q0;
    R[8]=1 - sq_q1 - sq_q2;
  }
 else   if (R.length == 16) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=0.0f;
    R[4]=q1_q2 + q3_q0;
    R[5]=1 - sq_q1 - sq_q3;
    R[6]=q2_q3 - q1_q0;
    R[7]=0.0f;
    R[8]=q1_q3 - q2_q0;
    R[9]=q2_q3 + q1_q0;
    R[10]=1 - sq_q1 - sq_q2;
    R[11]=0.0f;
    R[12]=R[13]=R[14]=0.0f;
    R[15]=1.0f;
  }
}",0.9767318878900052
181153,"/** 
 * Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16. If R.length == 9, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> If R.length == 16, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   0  \ |  R[ 4]   R[ 5]   R[ 6]   0  | |  R[ 8]   R[ 9]   R[10]   0  | \  0       0       0       1  / </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */
public static void getRotationMatrixFromVector(float[] R,float[] rotationVector){
  float q0;
  float q1=rotationVector[0];
  float q2=rotationVector[1];
  float q3=rotationVector[2];
  if (rotationVector.length == 4) {
    q0=rotationVector[3];
  }
 else {
    q0=(float)Math.sqrt(1 - q1 * q1 - q2 * q2 - q3 * q3);
  }
  float sq_q1=2 * q1 * q1;
  float sq_q2=2 * q2 * q2;
  float sq_q3=2 * q3 * q3;
  float q1_q2=2 * q1 * q2;
  float q3_q0=2 * q3 * q0;
  float q1_q3=2 * q1 * q3;
  float q2_q0=2 * q2 * q0;
  float q2_q3=2 * q2 * q3;
  float q1_q0=2 * q1 * q0;
  if (R.length == 9) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=q1_q2 + q3_q0;
    R[4]=1 - sq_q1 - sq_q3;
    R[5]=q2_q3 - q1_q0;
    R[6]=q1_q3 - q2_q0;
    R[7]=q2_q3 + q1_q0;
    R[8]=1 - sq_q1 - sq_q2;
  }
 else   if (R.length == 16) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=0.0f;
    R[4]=q1_q2 + q3_q0;
    R[5]=1 - sq_q1 - sq_q3;
    R[6]=q2_q3 - q1_q0;
    R[7]=0.0f;
    R[8]=q1_q3 - q2_q0;
    R[9]=q2_q3 + q1_q0;
    R[10]=1 - sq_q1 - sq_q2;
    R[11]=0.0f;
    R[12]=R[13]=R[14]=0.0f;
    R[15]=1.0f;
  }
}","/** 
 * Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16. If R.length == 9, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> If R.length == 16, the following matrix is returned: <pre> /  R[ 0]   R[ 1]   R[ 2]   0  \ |  R[ 4]   R[ 5]   R[ 6]   0  | |  R[ 8]   R[ 9]   R[10]   0  | \  0       0       0       1  / </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */
public static void getRotationMatrixFromVector(float[] R,float[] rotationVector){
  float q0;
  float q1=rotationVector[0];
  float q2=rotationVector[1];
  float q3=rotationVector[2];
  if (rotationVector.length == 4) {
    q0=rotationVector[3];
  }
 else {
    q0=1 - q1 * q1 - q2 * q2 - q3 * q3;
    q0=(q0 > 0) ? (float)Math.sqrt(q0) : 0;
  }
  float sq_q1=2 * q1 * q1;
  float sq_q2=2 * q2 * q2;
  float sq_q3=2 * q3 * q3;
  float q1_q2=2 * q1 * q2;
  float q3_q0=2 * q3 * q0;
  float q1_q3=2 * q1 * q3;
  float q2_q0=2 * q2 * q0;
  float q2_q3=2 * q2 * q3;
  float q1_q0=2 * q1 * q0;
  if (R.length == 9) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=q1_q2 + q3_q0;
    R[4]=1 - sq_q1 - sq_q3;
    R[5]=q2_q3 - q1_q0;
    R[6]=q1_q3 - q2_q0;
    R[7]=q2_q3 + q1_q0;
    R[8]=1 - sq_q1 - sq_q2;
  }
 else   if (R.length == 16) {
    R[0]=1 - sq_q2 - sq_q3;
    R[1]=q1_q2 - q3_q0;
    R[2]=q1_q3 + q2_q0;
    R[3]=0.0f;
    R[4]=q1_q2 + q3_q0;
    R[5]=1 - sq_q1 - sq_q3;
    R[6]=q2_q3 - q1_q0;
    R[7]=0.0f;
    R[8]=q1_q3 - q2_q0;
    R[9]=q2_q3 + q1_q0;
    R[10]=1 - sq_q1 - sq_q2;
    R[11]=0.0f;
    R[12]=R[13]=R[14]=0.0f;
    R[15]=1.0f;
  }
}",0.9767318878900052
181154,"/** 
 * Called when SMS send completes. Broadcasts a sentIntent on success. On failure, either sets up retries or broadcasts a sentIntent with the failure in the result code.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldan SmsResponse instance if send was successful.  ar.userObj should be an SmsTracker instance.
 */
protected void handleSendComplete(AsyncResult ar){
  SmsTracker tracker=(SmsTracker)ar.userObj;
  PendingIntent sentIntent=tracker.mSentIntent;
  if (ar.exception == null) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + sentIntent);
    }
    if (tracker.mDeliveryIntent != null) {
      int messageRef=((SmsResponse)ar.result).messageRef;
      tracker.mMessageRef=messageRef;
      deliveryPendingList.add(tracker);
    }
    if (sentIntent != null) {
      try {
        sentIntent.send(Activity.RESULT_OK);
      }
 catch (      CanceledException ex) {
      }
    }
  }
 else {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    int ss=mPhone.getServiceState().getState();
    if (ss != ServiceState.STATE_IN_SERVICE) {
      handleNotInService(ss,tracker);
    }
 else     if ((((CommandException)(ar.exception)).getCommandError() == CommandException.Error.SMS_FAIL_RETRY) && tracker.mRetryCount < MAX_SEND_RETRIES) {
      tracker.mRetryCount++;
      Message retryMsg=obtainMessage(EVENT_SEND_RETRY,tracker);
      sendMessageDelayed(retryMsg,SEND_RETRY_DELAY);
    }
 else     if (tracker.mSentIntent != null) {
      int error=RESULT_ERROR_GENERIC_FAILURE;
      if (((CommandException)(ar.exception)).getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
        error=RESULT_ERROR_FDN_CHECK_FAILURE;
      }
      try {
        Intent fillIn=new Intent();
        if (ar.result != null) {
          fillIn.putExtra(""String_Node_Str"",((SmsResponse)ar.result).errorCode);
        }
        tracker.mSentIntent.send(mContext,error,fillIn);
      }
 catch (      CanceledException ex) {
      }
    }
  }
}","/** 
 * Called when SMS send completes. Broadcasts a sentIntent on success. On failure, either sets up retries or broadcasts a sentIntent with the failure in the result code.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldan SmsResponse instance if send was successful.  ar.userObj should be an SmsTracker instance.
 */
protected void handleSendComplete(AsyncResult ar){
  SmsTracker tracker=(SmsTracker)ar.userObj;
  PendingIntent sentIntent=tracker.mSentIntent;
  if (ar.exception == null) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + sentIntent);
    }
    if (tracker.mDeliveryIntent != null) {
      int messageRef=((SmsResponse)ar.result).messageRef;
      tracker.mMessageRef=messageRef;
      deliveryPendingList.add(tracker);
    }
    if (sentIntent != null) {
      try {
        if (mRemainingMessages > -1) {
          mRemainingMessages--;
        }
        if (mRemainingMessages == 0) {
          Intent sendNext=new Intent();
          sendNext.putExtra(SEND_NEXT_MSG_EXTRA,true);
          sentIntent.send(mContext,Activity.RESULT_OK,sendNext);
        }
 else {
          sentIntent.send(Activity.RESULT_OK);
        }
      }
 catch (      CanceledException ex) {
      }
    }
  }
 else {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    int ss=mPhone.getServiceState().getState();
    if (ss != ServiceState.STATE_IN_SERVICE) {
      handleNotInService(ss,tracker);
    }
 else     if ((((CommandException)(ar.exception)).getCommandError() == CommandException.Error.SMS_FAIL_RETRY) && tracker.mRetryCount < MAX_SEND_RETRIES) {
      tracker.mRetryCount++;
      Message retryMsg=obtainMessage(EVENT_SEND_RETRY,tracker);
      sendMessageDelayed(retryMsg,SEND_RETRY_DELAY);
    }
 else     if (tracker.mSentIntent != null) {
      int error=RESULT_ERROR_GENERIC_FAILURE;
      if (((CommandException)(ar.exception)).getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
        error=RESULT_ERROR_FDN_CHECK_FAILURE;
      }
      try {
        Intent fillIn=new Intent();
        if (ar.result != null) {
          fillIn.putExtra(""String_Node_Str"",((SmsResponse)ar.result).errorCode);
        }
        if (mRemainingMessages > -1) {
          mRemainingMessages--;
        }
        if (mRemainingMessages == 0) {
          fillIn.putExtra(SEND_NEXT_MSG_EXTRA,true);
        }
        tracker.mSentIntent.send(mContext,error,fillIn);
      }
 catch (      CanceledException ex) {
      }
    }
  }
}",0.8843866989649857
181155,"/** 
 * Send a multi-part text based SMS which already passed SMS control check. It is the working function for sendMultipartText().
 * @param destinationAddress the address to send the message to
 * @param scAddress is the service center address or null to usethe current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been sent. The result code will be <code>Activity.RESULT_OK<code> for success, or one of these errors: <code>RESULT_ERROR_GENERIC_FAILURE</code> <code>RESULT_ERROR_RADIO_OFF</code> <code>RESULT_ERROR_NULL_PDU</code>.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been delivered to the recipient.  The raw pdu of the status report is in the extended data (""pdu"").
 */
private void sendMultipartTextWithPermit(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int ss=mPhone.getServiceState().getState();
  if (ss != ServiceState.STATE_IN_SERVICE) {
    for (int i=0, count=parts.size(); i < count; i++) {
      PendingIntent sentIntent=null;
      if (sentIntents != null && sentIntents.size() > i) {
        sentIntent=sentIntents.get(i);
      }
      SmsTracker tracker=SmsTrackerFactory(null,sentIntent,null);
      handleNotInService(ss,tracker);
    }
    return;
  }
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=false;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    HashMap<String,Object> map=new HashMap<String,Object>();
    map.put(""String_Node_Str"",pdus.encodedScAddress);
    map.put(""String_Node_Str"",pdus.encodedMessage);
    SmsTracker tracker=SmsTrackerFactory(map,sentIntent,deliveryIntent);
    sendSms(tracker);
  }
}","/** 
 * Send a multi-part text based SMS which already passed SMS control check. It is the working function for sendMultipartText().
 * @param destinationAddress the address to send the message to
 * @param scAddress is the service center address or null to usethe current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been sent. The result code will be <code>Activity.RESULT_OK<code> for success, or one of these errors: <code>RESULT_ERROR_GENERIC_FAILURE</code> <code>RESULT_ERROR_RADIO_OFF</code> <code>RESULT_ERROR_NULL_PDU</code>.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been delivered to the recipient.  The raw pdu of the status report is in the extended data (""pdu"").
 */
private void sendMultipartTextWithPermit(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int ss=mPhone.getServiceState().getState();
  if (ss != ServiceState.STATE_IN_SERVICE) {
    for (int i=0, count=parts.size(); i < count; i++) {
      PendingIntent sentIntent=null;
      if (sentIntents != null && sentIntents.size() > i) {
        sentIntent=sentIntents.get(i);
      }
      SmsTracker tracker=SmsTrackerFactory(null,sentIntent,null);
      handleNotInService(ss,tracker);
    }
    return;
  }
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  mRemainingMessages=msgCount;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=false;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    HashMap<String,Object> map=new HashMap<String,Object>();
    map.put(""String_Node_Str"",pdus.encodedScAddress);
    map.put(""String_Node_Str"",pdus.encodedMessage);
    SmsTracker tracker=SmsTrackerFactory(map,sentIntent,deliveryIntent);
    sendSms(tracker);
  }
}",0.9951250196571788
181156,"/** 
 * {@inheritDoc} 
 */
protected void sendMultipartText(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=true;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    sendRawPdu(pdus.encodedScAddress,pdus.encodedMessage,sentIntent,deliveryIntent);
  }
}","/** 
 * {@inheritDoc} 
 */
protected void sendMultipartText(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  mRemainingMessages=msgCount;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=true;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    sendRawPdu(pdus.encodedScAddress,pdus.encodedMessage,sentIntent,deliveryIntent);
  }
}",0.9899448589036652
181157,"/** 
 * Called when SMS send completes. Broadcasts a sentIntent on success. On failure, either sets up retries or broadcasts a sentIntent with the failure in the result code.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldan SmsResponse instance if send was successful.  ar.userObj should be an SmsTracker instance.
 */
protected void handleSendComplete(AsyncResult ar){
  SmsTracker tracker=(SmsTracker)ar.userObj;
  PendingIntent sentIntent=tracker.mSentIntent;
  if (ar.exception == null) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + sentIntent);
    }
    if (tracker.mDeliveryIntent != null) {
      int messageRef=((SmsResponse)ar.result).messageRef;
      tracker.mMessageRef=messageRef;
      deliveryPendingList.add(tracker);
    }
    if (sentIntent != null) {
      try {
        sentIntent.send(Activity.RESULT_OK);
      }
 catch (      CanceledException ex) {
      }
    }
  }
 else {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    int ss=mPhone.getServiceState().getState();
    if (ss != ServiceState.STATE_IN_SERVICE) {
      handleNotInService(ss,tracker);
    }
 else     if ((((CommandException)(ar.exception)).getCommandError() == CommandException.Error.SMS_FAIL_RETRY) && tracker.mRetryCount < MAX_SEND_RETRIES) {
      tracker.mRetryCount++;
      Message retryMsg=obtainMessage(EVENT_SEND_RETRY,tracker);
      sendMessageDelayed(retryMsg,SEND_RETRY_DELAY);
    }
 else     if (tracker.mSentIntent != null) {
      int error=RESULT_ERROR_GENERIC_FAILURE;
      if (((CommandException)(ar.exception)).getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
        error=RESULT_ERROR_FDN_CHECK_FAILURE;
      }
      try {
        Intent fillIn=new Intent();
        if (ar.result != null) {
          fillIn.putExtra(""String_Node_Str"",((SmsResponse)ar.result).errorCode);
        }
        tracker.mSentIntent.send(mContext,error,fillIn);
      }
 catch (      CanceledException ex) {
      }
    }
  }
}","/** 
 * Called when SMS send completes. Broadcasts a sentIntent on success. On failure, either sets up retries or broadcasts a sentIntent with the failure in the result code.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldan SmsResponse instance if send was successful.  ar.userObj should be an SmsTracker instance.
 */
protected void handleSendComplete(AsyncResult ar){
  SmsTracker tracker=(SmsTracker)ar.userObj;
  PendingIntent sentIntent=tracker.mSentIntent;
  if (ar.exception == null) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + sentIntent);
    }
    if (tracker.mDeliveryIntent != null) {
      int messageRef=((SmsResponse)ar.result).messageRef;
      tracker.mMessageRef=messageRef;
      deliveryPendingList.add(tracker);
    }
    if (sentIntent != null) {
      try {
        if (mRemainingMessages > -1) {
          mRemainingMessages--;
        }
        if (mRemainingMessages == 0) {
          Intent sendNext=new Intent();
          sendNext.putExtra(SEND_NEXT_MSG_EXTRA,true);
          sentIntent.send(mContext,Activity.RESULT_OK,sendNext);
        }
 else {
          sentIntent.send(Activity.RESULT_OK);
        }
      }
 catch (      CanceledException ex) {
      }
    }
  }
 else {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    int ss=mPhone.getServiceState().getState();
    if (ss != ServiceState.STATE_IN_SERVICE) {
      handleNotInService(ss,tracker);
    }
 else     if ((((CommandException)(ar.exception)).getCommandError() == CommandException.Error.SMS_FAIL_RETRY) && tracker.mRetryCount < MAX_SEND_RETRIES) {
      tracker.mRetryCount++;
      Message retryMsg=obtainMessage(EVENT_SEND_RETRY,tracker);
      sendMessageDelayed(retryMsg,SEND_RETRY_DELAY);
    }
 else     if (tracker.mSentIntent != null) {
      int error=RESULT_ERROR_GENERIC_FAILURE;
      if (((CommandException)(ar.exception)).getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
        error=RESULT_ERROR_FDN_CHECK_FAILURE;
      }
      try {
        Intent fillIn=new Intent();
        if (ar.result != null) {
          fillIn.putExtra(""String_Node_Str"",((SmsResponse)ar.result).errorCode);
        }
        if (mRemainingMessages > -1) {
          mRemainingMessages--;
        }
        if (mRemainingMessages == 0) {
          fillIn.putExtra(SEND_NEXT_MSG_EXTRA,true);
        }
        tracker.mSentIntent.send(mContext,error,fillIn);
      }
 catch (      CanceledException ex) {
      }
    }
  }
}",0.8843866989649857
181158,"/** 
 * Send a multi-part text based SMS which already passed SMS control check. It is the working function for sendMultipartText().
 * @param destinationAddress the address to send the message to
 * @param scAddress is the service center address or null to usethe current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been sent. The result code will be <code>Activity.RESULT_OK<code> for success, or one of these errors: <code>RESULT_ERROR_GENERIC_FAILURE</code> <code>RESULT_ERROR_RADIO_OFF</code> <code>RESULT_ERROR_NULL_PDU</code>.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been delivered to the recipient.  The raw pdu of the status report is in the extended data (""pdu"").
 */
private void sendMultipartTextWithPermit(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int ss=mPhone.getServiceState().getState();
  if (ss != ServiceState.STATE_IN_SERVICE) {
    for (int i=0, count=parts.size(); i < count; i++) {
      PendingIntent sentIntent=null;
      if (sentIntents != null && sentIntents.size() > i) {
        sentIntent=sentIntents.get(i);
      }
      SmsTracker tracker=SmsTrackerFactory(null,sentIntent,null);
      handleNotInService(ss,tracker);
    }
    return;
  }
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=false;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    HashMap<String,Object> map=new HashMap<String,Object>();
    map.put(""String_Node_Str"",pdus.encodedScAddress);
    map.put(""String_Node_Str"",pdus.encodedMessage);
    SmsTracker tracker=SmsTrackerFactory(map,sentIntent,deliveryIntent);
    sendSms(tracker);
  }
}","/** 
 * Send a multi-part text based SMS which already passed SMS control check. It is the working function for sendMultipartText().
 * @param destinationAddress the address to send the message to
 * @param scAddress is the service center address or null to usethe current default SMSC
 * @param parts an <code>ArrayList</code> of strings that, in order,comprise the original message
 * @param sentIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been sent. The result code will be <code>Activity.RESULT_OK<code> for success, or one of these errors: <code>RESULT_ERROR_GENERIC_FAILURE</code> <code>RESULT_ERROR_RADIO_OFF</code> <code>RESULT_ERROR_NULL_PDU</code>.
 * @param deliveryIntents if not null, an <code>ArrayList</code> of<code>PendingIntent</code>s (one for each message part) that is broadcast when the corresponding message part has been delivered to the recipient.  The raw pdu of the status report is in the extended data (""pdu"").
 */
private void sendMultipartTextWithPermit(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int ss=mPhone.getServiceState().getState();
  if (ss != ServiceState.STATE_IN_SERVICE) {
    for (int i=0, count=parts.size(); i < count; i++) {
      PendingIntent sentIntent=null;
      if (sentIntents != null && sentIntents.size() > i) {
        sentIntent=sentIntents.get(i);
      }
      SmsTracker tracker=SmsTrackerFactory(null,sentIntent,null);
      handleNotInService(ss,tracker);
    }
    return;
  }
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  mRemainingMessages=msgCount;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=false;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    HashMap<String,Object> map=new HashMap<String,Object>();
    map.put(""String_Node_Str"",pdus.encodedScAddress);
    map.put(""String_Node_Str"",pdus.encodedMessage);
    SmsTracker tracker=SmsTrackerFactory(map,sentIntent,deliveryIntent);
    sendSms(tracker);
  }
}",0.9951250196571788
181159,"/** 
 * {@inheritDoc} 
 */
protected void sendMultipartText(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=true;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    sendRawPdu(pdus.encodedScAddress,pdus.encodedMessage,sentIntent,deliveryIntent);
  }
}","/** 
 * {@inheritDoc} 
 */
protected void sendMultipartText(String destinationAddress,String scAddress,ArrayList<String> parts,ArrayList<PendingIntent> sentIntents,ArrayList<PendingIntent> deliveryIntents){
  int refNumber=getNextConcatenatedRef() & 0x00FF;
  int msgCount=parts.size();
  int encoding=android.telephony.SmsMessage.ENCODING_UNKNOWN;
  mRemainingMessages=msgCount;
  for (int i=0; i < msgCount; i++) {
    TextEncodingDetails details=SmsMessage.calculateLength(parts.get(i),false);
    if (encoding != details.codeUnitSize && (encoding == android.telephony.SmsMessage.ENCODING_UNKNOWN || encoding == android.telephony.SmsMessage.ENCODING_7BIT)) {
      encoding=details.codeUnitSize;
    }
  }
  for (int i=0; i < msgCount; i++) {
    SmsHeader.ConcatRef concatRef=new SmsHeader.ConcatRef();
    concatRef.refNumber=refNumber;
    concatRef.seqNumber=i + 1;
    concatRef.msgCount=msgCount;
    concatRef.isEightBits=true;
    SmsHeader smsHeader=new SmsHeader();
    smsHeader.concatRef=concatRef;
    PendingIntent sentIntent=null;
    if (sentIntents != null && sentIntents.size() > i) {
      sentIntent=sentIntents.get(i);
    }
    PendingIntent deliveryIntent=null;
    if (deliveryIntents != null && deliveryIntents.size() > i) {
      deliveryIntent=deliveryIntents.get(i);
    }
    SmsMessage.SubmitPdu pdus=SmsMessage.getSubmitPdu(scAddress,destinationAddress,parts.get(i),deliveryIntent != null,SmsHeader.toByteArray(smsHeader),encoding);
    sendRawPdu(pdus.encodedScAddress,pdus.encodedMessage,sentIntent,deliveryIntent);
  }
}",0.9899448589036652
181160,"/** 
 * Called when a status report is received.  This should correspond to a previously successful SEND.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldbe a String representing the status report PDU, as ASCII hex.
 */
protected void handleStatusReport(AsyncResult ar){
  String pduString=(String)ar.result;
  SmsMessage sms=SmsMessage.newFromCDS(pduString);
  if (sms != null) {
    int messageRef=sms.messageRef;
    for (int i=0, count=deliveryPendingList.size(); i < count; i++) {
      SmsTracker tracker=deliveryPendingList.get(i);
      if (tracker.mMessageRef == messageRef) {
        deliveryPendingList.remove(i);
        PendingIntent intent=tracker.mDeliveryIntent;
        Intent fillIn=new Intent();
        fillIn.putExtra(""String_Node_Str"",IccUtils.hexStringToBytes(pduString));
        try {
          intent.send(mContext,Activity.RESULT_OK,fillIn);
        }
 catch (        CanceledException ex) {
        }
        break;
      }
    }
  }
  acknowledgeLastIncomingSms(true,Intents.RESULT_SMS_HANDLED,null);
}","/** 
 * Called when a status report is received.  This should correspond to a previously successful SEND.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldbe a String representing the status report PDU, as ASCII hex.
 */
protected void handleStatusReport(AsyncResult ar){
  String pduString=(String)ar.result;
  SmsMessage sms=SmsMessage.newFromCDS(pduString);
  int tpStatus=sms.getStatus();
  if (sms != null) {
    int messageRef=sms.messageRef;
    for (int i=0, count=deliveryPendingList.size(); i < count; i++) {
      SmsTracker tracker=deliveryPendingList.get(i);
      if (tracker.mMessageRef == messageRef) {
        if (tpStatus >= Sms.STATUS_FAILED || tpStatus < Sms.STATUS_PENDING) {
          deliveryPendingList.remove(i);
        }
        PendingIntent intent=tracker.mDeliveryIntent;
        Intent fillIn=new Intent();
        fillIn.putExtra(""String_Node_Str"",IccUtils.hexStringToBytes(pduString));
        try {
          intent.send(mContext,Activity.RESULT_OK,fillIn);
        }
 catch (        CanceledException ex) {
        }
        break;
      }
    }
  }
  acknowledgeLastIncomingSms(true,Intents.RESULT_SMS_HANDLED,null);
}",0.9454870420017872
181161,"@Override public void onDetached(){
  removeCallbacks(mHider);
}","@Override public void onDetached(){
}",0.7326732673267327
181162,"/** 
 * Called when a status report is received.  This should correspond to a previously successful SEND.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldbe a String representing the status report PDU, as ASCII hex.
 */
protected void handleStatusReport(AsyncResult ar){
  String pduString=(String)ar.result;
  SmsMessage sms=SmsMessage.newFromCDS(pduString);
  if (sms != null) {
    int messageRef=sms.messageRef;
    for (int i=0, count=deliveryPendingList.size(); i < count; i++) {
      SmsTracker tracker=deliveryPendingList.get(i);
      if (tracker.mMessageRef == messageRef) {
        deliveryPendingList.remove(i);
        PendingIntent intent=tracker.mDeliveryIntent;
        Intent fillIn=new Intent();
        fillIn.putExtra(""String_Node_Str"",IccUtils.hexStringToBytes(pduString));
        try {
          intent.send(mContext,Activity.RESULT_OK,fillIn);
        }
 catch (        CanceledException ex) {
        }
        break;
      }
    }
  }
  acknowledgeLastIncomingSms(true,Intents.RESULT_SMS_HANDLED,null);
}","/** 
 * Called when a status report is received.  This should correspond to a previously successful SEND.
 * @param ar AsyncResult passed into the message handler.  ar.result shouldbe a String representing the status report PDU, as ASCII hex.
 */
protected void handleStatusReport(AsyncResult ar){
  String pduString=(String)ar.result;
  SmsMessage sms=SmsMessage.newFromCDS(pduString);
  int tpStatus=sms.getStatus();
  if (sms != null) {
    int messageRef=sms.messageRef;
    for (int i=0, count=deliveryPendingList.size(); i < count; i++) {
      SmsTracker tracker=deliveryPendingList.get(i);
      if (tracker.mMessageRef == messageRef) {
        if (tpStatus >= Sms.STATUS_FAILED || tpStatus < Sms.STATUS_PENDING) {
          deliveryPendingList.remove(i);
        }
        PendingIntent intent=tracker.mDeliveryIntent;
        Intent fillIn=new Intent();
        fillIn.putExtra(""String_Node_Str"",IccUtils.hexStringToBytes(pduString));
        try {
          intent.send(mContext,Activity.RESULT_OK,fillIn);
        }
 catch (        CanceledException ex) {
        }
        break;
      }
    }
  }
  acknowledgeLastIncomingSms(true,Intents.RESULT_SMS_HANDLED,null);
}",0.9454870420017872
181163,"public static ApplicationInfo generateApplicationInfo(Package p,int flags){
  if (p == null)   return null;
  if (!copyNeeded(flags,p,null)) {
    if (!sCompatibilityModeEnabled) {
      p.applicationInfo.disableCompatibilityMode();
    }
    return p.applicationInfo;
  }
  ApplicationInfo ai=new ApplicationInfo(p.applicationInfo);
  if ((flags & PackageManager.GET_META_DATA) != 0) {
    ai.metaData=p.mAppMetaData;
  }
  if ((flags & PackageManager.GET_SHARED_LIBRARY_FILES) != 0) {
    ai.sharedLibraryFiles=p.usesLibraryFiles;
  }
  if (!sCompatibilityModeEnabled) {
    ai.disableCompatibilityMode();
  }
  ai.enabled=p.mSetEnabled == PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
  return ai;
}","public static ApplicationInfo generateApplicationInfo(Package p,int flags){
  if (p == null)   return null;
  if (!copyNeeded(flags,p,null)) {
    if (!sCompatibilityModeEnabled) {
      p.applicationInfo.disableCompatibilityMode();
    }
    return p.applicationInfo;
  }
  ApplicationInfo ai=new ApplicationInfo(p.applicationInfo);
  if ((flags & PackageManager.GET_META_DATA) != 0) {
    ai.metaData=p.mAppMetaData;
  }
  if ((flags & PackageManager.GET_SHARED_LIBRARY_FILES) != 0) {
    ai.sharedLibraryFiles=p.usesLibraryFiles;
  }
  if (!sCompatibilityModeEnabled) {
    ai.disableCompatibilityMode();
  }
  if (p.mSetEnabled == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
    ai.enabled=true;
  }
 else   if (p.mSetEnabled == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
    ai.enabled=false;
  }
  return ai;
}",0.8852672750977836
181164,"public void run(String[] args){
  boolean validCommand=false;
  if (args.length < 1) {
    showUsage();
    return;
  }
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return;
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runList();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runPath();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runInstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runUninstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetInstallLocation();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runGetInstallLocation();
    return;
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        displayPackageFilePath(args[1]);
      }
    }
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public void run(String[] args){
  boolean validCommand=false;
  if (args.length < 1) {
    showUsage();
    return;
  }
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return;
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runList();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runPath();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runInstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runUninstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runClear();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetInstallLocation();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runGetInstallLocation();
    return;
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        displayPackageFilePath(args[1]);
      }
    }
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.979757085020243
181165,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}",0.9773855488141202
181166,"PackageSetting(String name,String realName,File codePath,File resourcePath,String nativeLibraryPathString,int pVersionCode,int pkgFlags){
  super(name,realName,codePath,resourcePath,nativeLibraryPathString,pVersionCode,pkgFlags);
}","PackageSetting(PackageSetting orig){
  super(orig.name,orig.realName,orig.codePath,orig.resourcePath,orig.nativeLibraryPathString,orig.versionCode,orig.pkgFlags);
  copyFrom(orig);
}",0.5665859564164649
181167,"private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    mSettings.disableSystemPackageLP(packageName);
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}","private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  killApplication(packageName,oldPkg.applicationInfo.uid);
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    if (!mSettings.disableSystemPackageLP(packageName) && deletedPackage != null) {
      res.removedInfo.args=createInstallArgs(isExternal(pkg) ? PackageManager.INSTALL_EXTERNAL : PackageManager.INSTALL_INTERNAL,deletedPackage.applicationInfo.sourceDir,deletedPackage.applicationInfo.publicSourceDir,deletedPackage.applicationInfo.nativeLibraryDir);
    }
 else {
      res.removedInfo.args=null;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
}",0.8540639269406393
181168,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo,boolean writeSettings){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  final boolean deleteCodeAndResources;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    flags&=~PackageManager.DONT_DELETE_DATA;
  }
 else {
    deleteCodeAndResources=false;
    flags|=PackageManager.DONT_DELETE_DATA;
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo,writeSettings);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    NativeLibraryHelper.removeNativeBinariesLI(p.applicationInfo.nativeLibraryDir);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS,0);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    if (writeSettings) {
      mSettings.writeLP();
    }
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo,boolean writeSettings){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  if (ps.versionCode < p.mVersionCode) {
    flags&=~PackageManager.DONT_DELETE_DATA;
  }
 else {
    flags|=PackageManager.DONT_DELETE_DATA;
  }
  boolean ret=deleteInstalledPackageLI(p,true,flags,outInfo,writeSettings);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    NativeLibraryHelper.removeNativeBinariesLI(p.applicationInfo.nativeLibraryDir);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS,0);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    if (writeSettings) {
      mSettings.writeLP();
    }
  }
  return true;
}",0.9433473616056977
181169,"int disableSystemPackageLP(String name){
  PackageSetting p=mPackages.get(name);
  if (p == null) {
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return -1;
  }
  PackageSetting dp=mDisabledSysPackages.get(name);
  if (dp == null) {
    if ((p.pkg != null) && (p.pkg.applicationInfo != null)) {
      p.pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    mDisabledSysPackages.put(name,p);
  }
  return removePackageLP(name);
}","boolean disableSystemPackageLP(String name){
  PackageSetting p=mPackages.get(name);
  if (p == null) {
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return false;
  }
  PackageSetting dp=mDisabledSysPackages.get(name);
  if (dp == null) {
    if ((p.pkg != null) && (p.pkg.applicationInfo != null)) {
      p.pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    mDisabledSysPackages.put(name,p);
    PackageSetting newp=new PackageSetting(p);
    replacePackageLP(name,newp);
    return true;
  }
  return false;
}",0.8640776699029126
181170,"void removePackageLI(PackageParser.Package pkg,boolean chatty){
  if (chatty && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.applicationInfo.packageName);
synchronized (mPackages) {
    clearPackagePreferredActivitiesLP(pkg.packageName);
    mPackages.remove(pkg.applicationInfo.packageName);
    if (pkg.mPath != null) {
      mAppDirs.remove(pkg.mPath);
    }
    PackageSetting ps=(PackageSetting)pkg.mExtras;
    if (ps != null && ps.sharedUser != null) {
      if (false) {
        ps.sharedUser.packages.remove(ps);
        if (ps.sharedUser.packages.size() == 0) {
        }
      }
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      mProvidersByComponent.remove(new ComponentName(p.info.packageName,p.info.name));
      if (p.info.authority == null) {
        continue;
      }
      String names[]=p.info.authority.split(""String_Node_Str"");
      for (int j=0; j < names.length; j++) {
        if (mProviders.get(names[j]) == p) {
          mProviders.remove(names[j]);
          if (chatty && Config.LOGD)           Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
        }
      }
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      mServices.removeService(s);
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      mReceivers.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      mActivities.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      boolean tree=false;
      BasePermission bp=mSettings.mPermissions.get(p.info.name);
      if (bp == null) {
        tree=true;
        bp=mSettings.mPermissionTrees.get(p.info.name);
      }
      if (bp != null && bp.perm == p) {
        bp.perm=null;
        if (chatty) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(p.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      mInstrumentation.remove(a.getComponentName());
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
  }
}","void removePackageLI(PackageParser.Package pkg,boolean chatty){
  if (chatty && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.applicationInfo.packageName);
synchronized (mPackages) {
    clearPackagePreferredActivitiesLP(pkg.packageName);
    mPackages.remove(pkg.applicationInfo.packageName);
    if (pkg.mPath != null) {
      mAppDirs.remove(pkg.mPath);
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      mProvidersByComponent.remove(new ComponentName(p.info.packageName,p.info.name));
      if (p.info.authority == null) {
        continue;
      }
      String names[]=p.info.authority.split(""String_Node_Str"");
      for (int j=0; j < names.length; j++) {
        if (mProviders.get(names[j]) == p) {
          mProviders.remove(names[j]);
          if (chatty && Config.LOGD)           Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
        }
      }
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      mServices.removeService(s);
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      mReceivers.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      mActivities.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      boolean tree=false;
      BasePermission bp=mSettings.mPermissions.get(p.info.name);
      if (bp == null) {
        tree=true;
        bp=mSettings.mPermissionTrees.get(p.info.name);
      }
      if (bp != null && bp.perm == p) {
        bp.perm=null;
        if (chatty) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(p.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      mInstrumentation.remove(a.getComponentName());
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
  }
}",0.9698608964451314
181171,"@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren && mFirstPosition > 0) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}",0.990036231884058
181172,"private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}","private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    mSettings.disableSystemPackageLP(packageName);
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}",0.9847185985836748
181173,"static private int printField(char[] formatStr,int amt,char suffix,int pos,boolean always,int zeropad){
  if (always || amt > 0) {
    if ((always && zeropad >= 3) || amt > 99) {
      int dig=amt / 100;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      always=true;
      amt-=(dig * 100);
    }
    if ((always && zeropad >= 2) || amt > 9) {
      int dig=amt / 10;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      always=true;
      amt-=(dig * 10);
    }
    formatStr[pos]=(char)(amt + '0');
    pos++;
    formatStr[pos]=suffix;
    pos++;
  }
  return pos;
}","static private int printField(char[] formatStr,int amt,char suffix,int pos,boolean always,int zeropad){
  if (always || amt > 0) {
    final int startPos=pos;
    if ((always && zeropad >= 3) || amt > 99) {
      int dig=amt / 100;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      amt-=(dig * 100);
    }
    if ((always && zeropad >= 2) || amt > 9 || startPos != pos) {
      int dig=amt / 10;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      amt-=(dig * 10);
    }
    formatStr[pos]=(char)(amt + '0');
    pos++;
    formatStr[pos]=suffix;
    pos++;
  }
  return pos;
}",0.9277824978759558
181174,"static private int printField(char[] formatStr,int amt,char suffix,int pos,boolean always,int zeropad){
  if (always || amt > 0) {
    if ((always && zeropad >= 3) || amt > 99) {
      int dig=amt / 100;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      always=true;
      amt-=(dig * 100);
    }
    if ((always && zeropad >= 2) || amt > 9) {
      int dig=amt / 10;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      always=true;
      amt-=(dig * 10);
    }
    formatStr[pos]=(char)(amt + '0');
    pos++;
    formatStr[pos]=suffix;
    pos++;
  }
  return pos;
}","static private int printField(char[] formatStr,int amt,char suffix,int pos,boolean always,int zeropad){
  if (always || amt > 0) {
    final int startPos=pos;
    if ((always && zeropad >= 3) || amt > 99) {
      int dig=amt / 100;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      amt-=(dig * 100);
    }
    if ((always && zeropad >= 2) || amt > 9 || startPos != pos) {
      int dig=amt / 10;
      formatStr[pos]=(char)(dig + '0');
      pos++;
      amt-=(dig * 10);
    }
    formatStr[pos]=(char)(amt + '0');
    pos++;
    formatStr[pos]=suffix;
    pos++;
  }
  return pos;
}",0.9277824978759558
181175,"public void run(String[] args){
  boolean validCommand=false;
  if (args.length < 1) {
    showUsage();
    return;
  }
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return;
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runList();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runPath();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runInstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runUninstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetInstallLocation();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runGetInstallLocation();
    return;
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        displayPackageFilePath(args[1]);
      }
    }
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}","public void run(String[] args){
  boolean validCommand=false;
  if (args.length < 1) {
    showUsage();
    return;
  }
  mPm=IPackageManager.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
  if (mPm == null) {
    System.err.println(PM_NOT_RUNNING_ERR);
    return;
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (""String_Node_Str"".equals(op)) {
    runList();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runPath();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runInstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runUninstall();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runClear();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runSetInstallLocation();
    return;
  }
  if (""String_Node_Str"".equals(op)) {
    runGetInstallLocation();
    return;
  }
  try {
    if (args.length == 1) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(false);
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        runListPackages(true);
      }
    }
 else     if (args.length == 2) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        validCommand=true;
        displayPackageFilePath(args[1]);
      }
    }
  }
  finally {
    if (validCommand == false) {
      if (op != null) {
        System.err.println(""String_Node_Str"" + op + ""String_Node_Str"");
      }
      showUsage();
    }
  }
}",0.979757085020243
181176,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}",0.9773855488141202
181177,"PackageSetting(String name,String realName,File codePath,File resourcePath,String nativeLibraryPathString,int pVersionCode,int pkgFlags){
  super(name,realName,codePath,resourcePath,nativeLibraryPathString,pVersionCode,pkgFlags);
}","PackageSetting(PackageSetting orig){
  super(orig.name,orig.realName,orig.codePath,orig.resourcePath,orig.nativeLibraryPathString,orig.versionCode,orig.pkgFlags);
  copyFrom(orig);
}",0.5665859564164649
181178,"private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    mSettings.disableSystemPackageLP(packageName);
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}","private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  killApplication(packageName,oldPkg.applicationInfo.uid);
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    if (!mSettings.disableSystemPackageLP(packageName) && deletedPackage != null) {
      res.removedInfo.args=createInstallArgs(isExternal(pkg) ? PackageManager.INSTALL_EXTERNAL : PackageManager.INSTALL_INTERNAL,deletedPackage.applicationInfo.sourceDir,deletedPackage.applicationInfo.publicSourceDir,deletedPackage.applicationInfo.nativeLibraryDir);
    }
 else {
      res.removedInfo.args=null;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
}",0.8540639269406393
181179,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo,boolean writeSettings){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  final boolean deleteCodeAndResources;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    flags&=~PackageManager.DONT_DELETE_DATA;
  }
 else {
    deleteCodeAndResources=false;
    flags|=PackageManager.DONT_DELETE_DATA;
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo,writeSettings);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    NativeLibraryHelper.removeNativeBinariesLI(p.applicationInfo.nativeLibraryDir);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS,0);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    if (writeSettings) {
      mSettings.writeLP();
    }
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo,boolean writeSettings){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  if (ps.versionCode < p.mVersionCode) {
    flags&=~PackageManager.DONT_DELETE_DATA;
  }
 else {
    flags|=PackageManager.DONT_DELETE_DATA;
  }
  boolean ret=deleteInstalledPackageLI(p,true,flags,outInfo,writeSettings);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    NativeLibraryHelper.removeNativeBinariesLI(p.applicationInfo.nativeLibraryDir);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS,0);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    if (writeSettings) {
      mSettings.writeLP();
    }
  }
  return true;
}",0.9433473616056977
181180,"int disableSystemPackageLP(String name){
  PackageSetting p=mPackages.get(name);
  if (p == null) {
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return -1;
  }
  PackageSetting dp=mDisabledSysPackages.get(name);
  if (dp == null) {
    if ((p.pkg != null) && (p.pkg.applicationInfo != null)) {
      p.pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    mDisabledSysPackages.put(name,p);
  }
  return removePackageLP(name);
}","boolean disableSystemPackageLP(String name){
  PackageSetting p=mPackages.get(name);
  if (p == null) {
    Log.w(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
    return false;
  }
  PackageSetting dp=mDisabledSysPackages.get(name);
  if (dp == null) {
    if ((p.pkg != null) && (p.pkg.applicationInfo != null)) {
      p.pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    mDisabledSysPackages.put(name,p);
    PackageSetting newp=new PackageSetting(p);
    replacePackageLP(name,newp);
    return true;
  }
  return false;
}",0.8640776699029126
181181,"void removePackageLI(PackageParser.Package pkg,boolean chatty){
  if (chatty && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.applicationInfo.packageName);
synchronized (mPackages) {
    clearPackagePreferredActivitiesLP(pkg.packageName);
    mPackages.remove(pkg.applicationInfo.packageName);
    if (pkg.mPath != null) {
      mAppDirs.remove(pkg.mPath);
    }
    PackageSetting ps=(PackageSetting)pkg.mExtras;
    if (ps != null && ps.sharedUser != null) {
      if (false) {
        ps.sharedUser.packages.remove(ps);
        if (ps.sharedUser.packages.size() == 0) {
        }
      }
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      mProvidersByComponent.remove(new ComponentName(p.info.packageName,p.info.name));
      if (p.info.authority == null) {
        continue;
      }
      String names[]=p.info.authority.split(""String_Node_Str"");
      for (int j=0; j < names.length; j++) {
        if (mProviders.get(names[j]) == p) {
          mProviders.remove(names[j]);
          if (chatty && Config.LOGD)           Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
        }
      }
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      mServices.removeService(s);
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      mReceivers.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      mActivities.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      boolean tree=false;
      BasePermission bp=mSettings.mPermissions.get(p.info.name);
      if (bp == null) {
        tree=true;
        bp=mSettings.mPermissionTrees.get(p.info.name);
      }
      if (bp != null && bp.perm == p) {
        bp.perm=null;
        if (chatty) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(p.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      mInstrumentation.remove(a.getComponentName());
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
  }
}","void removePackageLI(PackageParser.Package pkg,boolean chatty){
  if (chatty && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.applicationInfo.packageName);
synchronized (mPackages) {
    clearPackagePreferredActivitiesLP(pkg.packageName);
    mPackages.remove(pkg.applicationInfo.packageName);
    if (pkg.mPath != null) {
      mAppDirs.remove(pkg.mPath);
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      mProvidersByComponent.remove(new ComponentName(p.info.packageName,p.info.name));
      if (p.info.authority == null) {
        continue;
      }
      String names[]=p.info.authority.split(""String_Node_Str"");
      for (int j=0; j < names.length; j++) {
        if (mProviders.get(names[j]) == p) {
          mProviders.remove(names[j]);
          if (chatty && Config.LOGD)           Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
        }
      }
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      mServices.removeService(s);
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      mReceivers.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      mActivities.removeActivity(a,""String_Node_Str"");
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      boolean tree=false;
      BasePermission bp=mSettings.mPermissions.get(p.info.name);
      if (bp == null) {
        tree=true;
        bp=mSettings.mPermissionTrees.get(p.info.name);
      }
      if (bp != null && bp.perm == p) {
        bp.perm=null;
        if (chatty) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(p.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      mInstrumentation.remove(a.getComponentName());
      if (chatty) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
  }
}",0.9698608964451314
181182,"private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}","private void replaceSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  boolean updatedSettings=false;
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING | PackageParser.PARSE_IS_SYSTEM;
  String packageName=deletedPackage.packageName;
  res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
  if (packageName == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  PackageParser.Package oldPkg;
  PackageSetting oldPkgSetting;
synchronized (mPackages) {
    oldPkg=mPackages.get(packageName);
    oldPkgSetting=mSettings.mPackages.get(packageName);
    if ((oldPkg == null) || (oldPkg.applicationInfo == null) || (oldPkgSetting == null)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return;
    }
  }
  res.removedInfo.uid=oldPkg.applicationInfo.uid;
  res.removedInfo.removedPackage=packageName;
  removePackageLI(oldPkg,true);
synchronized (mPackages) {
    mSettings.disableSystemPackageLP(packageName);
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
  newPackage=scanPackageLI(pkg,parseFlags,scanMode,0);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    if (newPackage.mExtras != null) {
      final PackageSetting newPkgSetting=(PackageSetting)newPackage.mExtras;
      newPkgSetting.firstInstallTime=oldPkgSetting.firstInstallTime;
      newPkgSetting.lastUpdateTime=System.currentTimeMillis();
    }
    updateSettingsLI(newPackage,installerPackageName,res);
    updatedSettings=true;
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (newPackage != null) {
      removePackageLI(newPackage,true);
    }
    scanPackageLI(oldPkg,parseFlags,SCAN_MONITOR | SCAN_UPDATE_SIGNATURE,0);
synchronized (mPackages) {
      if (updatedSettings) {
        mSettings.enableSystemPackageLP(packageName);
        mSettings.setInstallerPackageName(packageName,oldPkgSetting.installerPackageName);
      }
      mSettings.writeLP();
    }
  }
 else {
synchronized (mPackages) {
      PackageSetting ps=mSettings.getDisabledSystemPkg(packageName);
      if (ps != null && ps.codePathString != null && !ps.codePathString.equals(oldPkgSetting.codePathString)) {
        res.removedInfo.args=createInstallArgs(0,oldPkgSetting.codePathString,oldPkgSetting.resourcePathString,oldPkgSetting.nativeLibraryPathString);
      }
    }
  }
}",0.9847185985836748
181183,"@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren && mFirstPosition > 0) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}",0.990036231884058
181184,"/** 
 * Called from the input dispatcher thread before a key is dispatched to a window. <p>Allows you to define behavior for keys that can not be overridden by applications or redirect key events to a different window.  This method is called from the input thread, with no locks held. <p>Note that if you change the window a key is dispatched to, the new target window will receive the key event without having input focus.
 * @param win The window that currently has focus.  This is where the keyevent will normally go.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param metaState bit mask of meta keys that are held.
 * @param repeatCount Number of times a key down has repeated.
 * @param policyFlags The policy flags associated with the key.
 * @return Returns true if the policy consumed the event and it shouldnot be further dispatched.
 */
public boolean interceptKeyBeforeDispatching(WindowState win,int action,int flags,int keyCode,int metaState,int repeatCount,int policyFlags);","/** 
 * Called from the input dispatcher thread before a key is dispatched to a window. <p>Allows you to define behavior for keys that can not be overridden by applications or redirect key events to a different window.  This method is called from the input thread, with no locks held. <p>Note that if you change the window a key is dispatched to, the new target window will receive the key event without having input focus.
 * @param win The window that currently has focus.  This is where the keyevent will normally go.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param scanCode The key's scan code.
 * @param metaState bit mask of meta keys that are held.
 * @param repeatCount Number of times a key down has repeated.
 * @param policyFlags The policy flags associated with the key.
 * @return Returns true if the policy consumed the event and it shouldnot be further dispatched.
 */
public boolean interceptKeyBeforeDispatching(WindowState win,int action,int flags,int keyCode,int scanCode,int metaState,int repeatCount,int policyFlags);",0.9754969949144706
181185,"/** 
 * Called from the input reader thread before a key is enqueued. <p>There are some actions that need to be handled here because they affect the power state of the device, for example, the power keys. Generally, it's best to keep as little as possible in the queue thread because it's the most fragile.
 * @param whenNanos The event time in uptime nanoseconds.
 * @param keyCode The key code.
 * @param down True if the key is down.
 * @param policyFlags The policy flags associated with the key.
 * @param isScreenOn True if the screen is already on
 * @return The bitwise or of the {@link #ACTION_PASS_TO_USER},  {@link #ACTION_POKE_USER_ACTIVITY} and {@link #ACTION_GO_TO_SLEEP} flags.
 */
public int interceptKeyBeforeQueueing(long whenNanos,int keyCode,boolean down,int policyFlags,boolean isScreenOn);","/** 
 * Called from the input reader thread before a key is enqueued. <p>There are some actions that need to be handled here because they affect the power state of the device, for example, the power keys. Generally, it's best to keep as little as possible in the queue thread because it's the most fragile.
 * @param whenNanos The event time in uptime nanoseconds.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param scanCode The key's scan code.
 * @param policyFlags The policy flags associated with the key.
 * @param isScreenOn True if the screen is already on
 * @return The bitwise or of the {@link #ACTION_PASS_TO_USER},  {@link #ACTION_POKE_USER_ACTIVITY} and {@link #ACTION_GO_TO_SLEEP} flags.
 */
public int interceptKeyBeforeQueueing(long whenNanos,int action,int flags,int keyCode,int scanCode,int policyFlags,boolean isScreenOn);",0.8772542175683536
181186,"/** 
 * Called from the input dispatcher thread before a key is dispatched to a window. <p>Allows you to define behavior for keys that can not be overridden by applications or redirect key events to a different window.  This method is called from the input thread, with no locks held. <p>Note that if you change the window a key is dispatched to, the new target window will receive the key event without having input focus.
 * @param win The window that currently has focus.  This is where the keyevent will normally go.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param metaState bit mask of meta keys that are held.
 * @param repeatCount Number of times a key down has repeated.
 * @param policyFlags The policy flags associated with the key.
 * @return Returns true if the policy consumed the event and it shouldnot be further dispatched.
 */
public boolean interceptKeyBeforeDispatching(WindowState win,int action,int flags,int keyCode,int metaState,int repeatCount,int policyFlags);","/** 
 * Called from the input dispatcher thread before a key is dispatched to a window. <p>Allows you to define behavior for keys that can not be overridden by applications or redirect key events to a different window.  This method is called from the input thread, with no locks held. <p>Note that if you change the window a key is dispatched to, the new target window will receive the key event without having input focus.
 * @param win The window that currently has focus.  This is where the keyevent will normally go.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param scanCode The key's scan code.
 * @param metaState bit mask of meta keys that are held.
 * @param repeatCount Number of times a key down has repeated.
 * @param policyFlags The policy flags associated with the key.
 * @return Returns true if the policy consumed the event and it shouldnot be further dispatched.
 */
public boolean interceptKeyBeforeDispatching(WindowState win,int action,int flags,int keyCode,int scanCode,int metaState,int repeatCount,int policyFlags);",0.9754969949144706
181187,"/** 
 * Called from the input reader thread before a key is enqueued. <p>There are some actions that need to be handled here because they affect the power state of the device, for example, the power keys. Generally, it's best to keep as little as possible in the queue thread because it's the most fragile.
 * @param whenNanos The event time in uptime nanoseconds.
 * @param keyCode The key code.
 * @param down True if the key is down.
 * @param policyFlags The policy flags associated with the key.
 * @param isScreenOn True if the screen is already on
 * @return The bitwise or of the {@link #ACTION_PASS_TO_USER},  {@link #ACTION_POKE_USER_ACTIVITY} and {@link #ACTION_GO_TO_SLEEP} flags.
 */
public int interceptKeyBeforeQueueing(long whenNanos,int keyCode,boolean down,int policyFlags,boolean isScreenOn);","/** 
 * Called from the input reader thread before a key is enqueued. <p>There are some actions that need to be handled here because they affect the power state of the device, for example, the power keys. Generally, it's best to keep as little as possible in the queue thread because it's the most fragile.
 * @param whenNanos The event time in uptime nanoseconds.
 * @param action The key event action.
 * @param flags The key event flags.
 * @param keyCode The key code.
 * @param scanCode The key's scan code.
 * @param policyFlags The policy flags associated with the key.
 * @param isScreenOn True if the screen is already on
 * @return The bitwise or of the {@link #ACTION_PASS_TO_USER},  {@link #ACTION_POKE_USER_ACTIVITY} and {@link #ACTION_GO_TO_SLEEP} flags.
 */
public int interceptKeyBeforeQueueing(long whenNanos,int action,int flags,int keyCode,int scanCode,int policyFlags,boolean isScreenOn);",0.8772542175683536
181188,"@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      ss.position=mFirstPosition;
      ss.firstId=mAdapter.getItemId(mFirstPosition);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}",0.9187620889748548
181189,"@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      ss.position=mFirstPosition;
      ss.firstId=mAdapter.getItemId(mFirstPosition);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}","@Override public Parcelable onSaveInstanceState(){
  dismissPopup();
  Parcelable superState=super.onSaveInstanceState();
  SavedState ss=new SavedState(superState);
  boolean haveChildren=getChildCount() > 0 && mItemCount > 0;
  long selectedId=getSelectedItemId();
  ss.selectedId=selectedId;
  ss.height=getHeight();
  if (selectedId >= 0) {
    ss.viewTop=mSelectedTop;
    ss.position=getSelectedItemPosition();
    ss.firstId=INVALID_POSITION;
  }
 else {
    if (haveChildren) {
      View v=getChildAt(0);
      ss.viewTop=v.getTop();
      int firstPos=mFirstPosition;
      if (firstPos >= mItemCount) {
        firstPos=mItemCount - 1;
      }
      ss.position=firstPos;
      ss.firstId=mAdapter.getItemId(firstPos);
    }
 else {
      ss.viewTop=0;
      ss.firstId=INVALID_POSITION;
      ss.position=0;
    }
  }
  ss.filter=null;
  if (mFiltered) {
    final EditText textFilter=mTextFilter;
    if (textFilter != null) {
      Editable filterText=textFilter.getText();
      if (filterText != null) {
        ss.filter=filterText.toString();
      }
    }
  }
  return ss;
}",0.9187620889748548
181190,"private Intent newGrantCredentialsPermissionIntent(Account account,int uid,AccountAuthenticatorResponse response,String authTokenType,String authTokenLabel){
  RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo=mAuthenticatorCache.getServiceInfo(AuthenticatorDescription.newKey(account.type));
  if (serviceInfo == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + account.type);
  }
  final Context authContext;
  try {
    authContext=mContext.createPackageContext(serviceInfo.type.packageName,0);
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + account.type);
  }
  Intent intent=new Intent(mContext,GrantCredentialsPermissionActivity.class);
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.addCategory(String.valueOf(getCredentialPermissionNotificationId(account,authTokenType,uid)));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT,account);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_LABEL,authTokenLabel);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE,authTokenType);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE,response);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT_TYPE_LABEL,authContext.getString(serviceInfo.type.labelId));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_PACKAGES,mContext.getPackageManager().getPackagesForUid(uid));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID,uid);
  return intent;
}","private Intent newGrantCredentialsPermissionIntent(Account account,int uid,AccountAuthenticatorResponse response,String authTokenType,String authTokenLabel){
  Intent intent=new Intent(mContext,GrantCredentialsPermissionActivity.class);
  intent.addCategory(String.valueOf(getCredentialPermissionNotificationId(account,authTokenType,uid)));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT,account);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE,authTokenType);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE,response);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID,uid);
  return intent;
}",0.5392670157068062
181191,"protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.grant_credentials_permission);
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final Bundle extras=getIntent().getExtras();
  mAccount=extras.getParcelable(EXTRAS_ACCOUNT);
  mAuthTokenType=extras.getString(EXTRAS_AUTH_TOKEN_TYPE);
  if (mAccount == null || mAuthTokenType == null) {
    setResult(Activity.RESULT_CANCELED);
    finish();
    return;
  }
  mUid=extras.getInt(EXTRAS_REQUESTING_UID);
  final String accountTypeLabel=extras.getString(EXTRAS_ACCOUNT_TYPE_LABEL);
  final String[] packages=extras.getStringArray(EXTRAS_PACKAGES);
  final String authTokenLabel=extras.getString(EXTRAS_AUTH_TOKEN_LABEL);
  findViewById(R.id.allow_button).setOnClickListener(this);
  findViewById(R.id.deny_button).setOnClickListener(this);
  LinearLayout packagesListView=(LinearLayout)findViewById(R.id.packages_list);
  final PackageManager pm=getPackageManager();
  for (  String pkg : packages) {
    String packageLabel;
    try {
      packageLabel=pm.getApplicationLabel(pm.getApplicationInfo(pkg,0)).toString();
    }
 catch (    PackageManager.NameNotFoundException e) {
      packageLabel=pkg;
    }
    packagesListView.addView(newPackageView(packageLabel));
  }
  ((TextView)findViewById(R.id.account_name)).setText(mAccount.name);
  ((TextView)findViewById(R.id.account_type)).setText(accountTypeLabel);
  TextView authTokenTypeView=(TextView)findViewById(R.id.authtoken_type);
  if (TextUtils.isEmpty(authTokenLabel)) {
    authTokenTypeView.setVisibility(View.GONE);
  }
 else {
    authTokenTypeView.setText(authTokenLabel);
  }
}","protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.grant_credentials_permission);
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final Bundle extras=getIntent().getExtras();
  mAccount=extras.getParcelable(EXTRAS_ACCOUNT);
  mAuthTokenType=extras.getString(EXTRAS_AUTH_TOKEN_TYPE);
  mUid=extras.getInt(EXTRAS_REQUESTING_UID);
  final PackageManager pm=getPackageManager();
  final String[] packages=pm.getPackagesForUid(mUid);
  if (mAccount == null || mAuthTokenType == null || packages == null) {
    setResult(Activity.RESULT_CANCELED);
    finish();
    return;
  }
  final String accountTypeLabel=accountManagerService.getAccountLabel(mAccount.type);
  final TextView authTokenTypeView=(TextView)findViewById(R.id.authtoken_type);
  authTokenTypeView.setVisibility(View.GONE);
  IAccountManagerResponse response=new IAccountManagerResponse.Stub(){
    public void onResult(    Bundle bundle){
      final String authTokenLabel=bundle.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);
      if (!TextUtils.isEmpty(authTokenLabel)) {
        runOnUiThread(new Runnable(){
          public void run(){
            if (!isFinishing()) {
              authTokenTypeView.setText(authTokenLabel);
              authTokenTypeView.setVisibility(View.VISIBLE);
            }
          }
        }
);
      }
    }
    public void onError(    int code,    String message){
    }
  }
;
  accountManagerService.getAuthTokenLabel(response,mAccount,mAuthTokenType);
  findViewById(R.id.allow_button).setOnClickListener(this);
  findViewById(R.id.deny_button).setOnClickListener(this);
  LinearLayout packagesListView=(LinearLayout)findViewById(R.id.packages_list);
  for (  String pkg : packages) {
    String packageLabel;
    try {
      packageLabel=pm.getApplicationLabel(pm.getApplicationInfo(pkg,0)).toString();
    }
 catch (    PackageManager.NameNotFoundException e) {
      packageLabel=pkg;
    }
    packagesListView.addView(newPackageView(packageLabel));
  }
  ((TextView)findViewById(R.id.account_name)).setText(mAccount.name);
  ((TextView)findViewById(R.id.account_type)).setText(accountTypeLabel);
}",0.2955911823647295
181192,"public void onClick(View v){
  final AccountManagerService accountManagerService=AccountManagerService.getSingleton();
switch (v.getId()) {
case R.id.allow_button:
    accountManagerService.grantAppPermission(mAccount,mAuthTokenType,mUid);
  Intent result=new Intent();
result.putExtra(""String_Node_Str"",true);
setResult(RESULT_OK,result);
setAccountAuthenticatorResult(result.getExtras());
break;
case R.id.deny_button:
accountManagerService.revokeAppPermission(mAccount,mAuthTokenType,mUid);
setResult(RESULT_CANCELED);
break;
}
finish();
}","public void onClick(View v){
switch (v.getId()) {
case R.id.allow_button:
    accountManagerService.grantAppPermission(mAccount,mAuthTokenType,mUid);
  Intent result=new Intent();
result.putExtra(""String_Node_Str"",true);
setResult(RESULT_OK,result);
setAccountAuthenticatorResult(result.getExtras());
break;
case R.id.deny_button:
accountManagerService.revokeAppPermission(mAccount,mAuthTokenType,mUid);
setResult(RESULT_CANCELED);
break;
}
finish();
}",0.909456740442656
181193,"/** 
 * Lists all the installed packages.
 */
private void runListPackages(boolean showApplicationPackage){
  try {
    String opt;
    while ((opt=nextOption()) != null) {
      if (opt.equals(""String_Node_Str"")) {
      }
 else       if (opt.equals(""String_Node_Str"")) {
        showApplicationPackage=true;
      }
 else       if (opt.equals(""String_Node_Str"")) {
        showApplicationPackage=true;
      }
 else {
        System.err.println(""String_Node_Str"" + opt);
        showUsage();
        return;
      }
    }
  }
 catch (  RuntimeException ex) {
    System.err.println(""String_Node_Str"" + ex.toString());
    showUsage();
    return;
  }
  try {
    List<PackageInfo> packages=mPm.getInstalledPackages(0);
    int count=packages.size();
    for (int p=0; p < count; p++) {
      PackageInfo info=packages.get(p);
      System.out.print(""String_Node_Str"");
      if (showApplicationPackage) {
        System.out.print(info.applicationInfo.sourceDir);
        System.out.print(""String_Node_Str"");
      }
      System.out.println(info.packageName);
    }
  }
 catch (  RemoteException e) {
    System.err.println(e.toString());
    System.err.println(PM_NOT_RUNNING_ERR);
  }
}","/** 
 * Lists all the installed packages.
 */
private void runListPackages(boolean showApplicationPackage){
  int getFlags=0;
  boolean listDisabled=false, listEnabled=false;
  try {
    String opt;
    while ((opt=nextOption()) != null) {
      if (opt.equals(""String_Node_Str"")) {
      }
 else       if (opt.equals(""String_Node_Str"")) {
        showApplicationPackage=true;
      }
 else       if (opt.equals(""String_Node_Str"")) {
        showApplicationPackage=true;
      }
 else       if (opt.equals(""String_Node_Str"")) {
        listDisabled=true;
      }
 else       if (opt.equals(""String_Node_Str"")) {
        listEnabled=true;
      }
 else       if (opt.equals(""String_Node_Str"")) {
        getFlags|=PackageManager.GET_UNINSTALLED_PACKAGES;
      }
 else {
        System.err.println(""String_Node_Str"" + opt);
        showUsage();
        return;
      }
    }
  }
 catch (  RuntimeException ex) {
    System.err.println(""String_Node_Str"" + ex.toString());
    showUsage();
    return;
  }
  String filter=nextArg();
  try {
    List<PackageInfo> packages=mPm.getInstalledPackages(getFlags);
    int count=packages.size();
    for (int p=0; p < count; p++) {
      PackageInfo info=packages.get(p);
      if (filter != null && !info.packageName.contains(filter)) {
        continue;
      }
      if ((!listDisabled || !info.applicationInfo.enabled) && (!listEnabled || info.applicationInfo.enabled)) {
        System.out.print(""String_Node_Str"");
        if (showApplicationPackage) {
          System.out.print(info.applicationInfo.sourceDir);
          System.out.print(""String_Node_Str"");
        }
        System.out.println(info.packageName);
      }
    }
  }
 catch (  RemoteException e) {
    System.err.println(e.toString());
    System.err.println(PM_NOT_RUNNING_ERR);
  }
}",0.7958500669344043
181194,"/** 
 * Execute the list sub-command. pm list [package | packages] pm list permission-groups pm list permissions pm list features pm list instrumentation
 */
private void runList(){
  String type=nextArg();
  if (type == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    runListPackages(false);
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListPermissionGroups();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListPermissions();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListFeatures();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListInstrumentation();
  }
 else {
    System.err.println(""String_Node_Str"" + type + ""String_Node_Str"");
    showUsage();
  }
}","/** 
 * Execute the list sub-command. pm list [package | packages] pm list permission-groups pm list permissions pm list features pm list libraries pm list instrumentation
 */
private void runList(){
  String type=nextArg();
  if (type == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    runListPackages(false);
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListPermissionGroups();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListPermissions();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListFeatures();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListLibraries();
  }
 else   if (""String_Node_Str"".equals(type)) {
    runListInstrumentation();
  }
 else {
    System.err.println(""String_Node_Str"" + type + ""String_Node_Str"");
    showUsage();
  }
}",0.9469434832756632
181195,"private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
}",0.9598904324007044
181196,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags,long firstInstallTime,long lastUpdateTime){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  pi.installLocation=p.installLocation;
  pi.firstInstallTime=firstInstallTime;
  pi.lastUpdateTime=lastUpdateTime;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[j++]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[j++]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[j++]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[j++]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    int N=(p.mSignatures != null) ? p.mSignatures.length : 0;
    if (N > 0) {
      pi.signatures=new Signature[N];
      System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags,long firstInstallTime,long lastUpdateTime){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=generateApplicationInfo(p,flags);
  pi.installLocation=p.installLocation;
  pi.firstInstallTime=firstInstallTime;
  pi.lastUpdateTime=lastUpdateTime;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[j++]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[j++]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[j++]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0, j=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[j++]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    int N=(p.mSignatures != null) ? p.mSignatures.length : 0;
    if (N > 0) {
      pi.signatures=new Signature[N];
      System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
    }
  }
  return pi;
}",0.9950827897641746
181197,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,String[] args){
  boolean isUnpluggedOnly=false;
  for (  String arg : args) {
    if (""String_Node_Str"".equals(arg)) {
      if (LOCAL_LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"");
      isUnpluggedOnly=true;
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(PrintWriter pw,String[] args,List<ApplicationInfo> apps){
  boolean isUnpluggedOnly=false;
  for (  String arg : args) {
    if (""String_Node_Str"".equals(arg)) {
      if (LOCAL_LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"");
      isUnpluggedOnly=true;
    }
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (isUnpluggedOnly) {
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
 else {
    dumpCheckinLocked(pw,STATS_SINCE_CHARGED,-1);
    dumpCheckinLocked(pw,STATS_SINCE_UNPLUGGED,-1);
  }
}",0.5350184307530279
181198,"/** 
 * Gets the SIP URI string of this profile.
 * @return the SIP URI string of this profile
 */
public String getUriString(){
  return mAddress.getURI().toString();
}","/** 
 * Gets the SIP URI string of this profile.
 * @return the SIP URI string of this profile
 */
public String getUriString(){
  if (!TextUtils.isEmpty(mProxyAddress)) {
    return ""String_Node_Str"" + getUserName() + ""String_Node_Str""+ mDomain;
  }
  return getUri().toString();
}",0.6740576496674058
181199,"/** 
 * Sets the protocol used to connect to the SIP server. Currently, only ""UDP"" and ""TCP"" are supported.
 * @param protocol the protocol string
 * @return this builder object
 * @throws IllegalArgumentException if the protocol is not recognized
 */
public Builder setProtocol(String protocol) throws IllegalArgumentException {
  if (protocol == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  protocol=protocol.toUpperCase();
  if (!protocol.equals(""String_Node_Str"") && !protocol.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + protocol);
  }
  mProfile.mProtocol=protocol;
  return this;
}","/** 
 * Sets the protocol used to connect to the SIP server. Currently, only ""UDP"" and ""TCP"" are supported.
 * @param protocol the protocol string
 * @return this builder object
 * @throws IllegalArgumentException if the protocol is not recognized
 */
public Builder setProtocol(String protocol) throws IllegalArgumentException {
  if (protocol == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  protocol=protocol.toUpperCase();
  if (!protocol.equals(UDP) && !protocol.equals(TCP)) {
    throw new IllegalArgumentException(""String_Node_Str"" + protocol);
  }
  mProfile.mProtocol=protocol;
  return this;
}",0.8658346333853354
181200,"/** 
 * Sets the port number of the server. By default, it is 5060.
 * @param port port number of the server
 * @return this builder object
 * @throws IllegalArgumentException if the port number is out of range
 */
public Builder setPort(int port) throws IllegalArgumentException {
  try {
    mUri.setPort(port);
    return this;
  }
 catch (  InvalidArgumentException e) {
    throw new IllegalArgumentException(e);
  }
}","/** 
 * Sets the port number of the server. By default, it is 5060.
 * @param port port number of the server
 * @return this builder object
 * @throws IllegalArgumentException if the port number is out of range
 */
public Builder setPort(int port) throws IllegalArgumentException {
  if ((port > 65535) || (port < 1000)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mProfile.mPort=port;
  return this;
}",0.7523584905660378
181201,"private SipProfile(Parcel in){
  mAddress=(Address)in.readSerializable();
  mProxyAddress=in.readString();
  mPassword=in.readString();
  mDomain=in.readString();
  mProtocol=in.readString();
  mProfileName=in.readString();
  mSendKeepAlive=(in.readInt() == 0) ? false : true;
  mAutoRegistration=(in.readInt() == 0) ? false : true;
  mCallingUid=in.readInt();
}","private SipProfile(Parcel in){
  mAddress=(Address)in.readSerializable();
  mProxyAddress=in.readString();
  mPassword=in.readString();
  mDomain=in.readString();
  mProtocol=in.readString();
  mProfileName=in.readString();
  mSendKeepAlive=(in.readInt() == 0) ? false : true;
  mAutoRegistration=(in.readInt() == 0) ? false : true;
  mCallingUid=in.readInt();
  mPort=in.readInt();
}",0.970509383378016
181202,"/** 
 * Gets the port number of the SIP server.
 * @return the port number of the SIP server
 */
public int getPort(){
  int port=getUri().getPort();
  return (port == -1) ? DEFAULT_PORT : port;
}","/** 
 * Gets the port number of the SIP server.
 * @return the port number of the SIP server
 */
public int getPort(){
  return mPort;
}",0.8132530120481928
181203,"/** 
 * Builds and returns the SIP profile object.
 * @return the profile object created
 */
public SipProfile build(){
  mProfile.mPassword=mUri.getUserPassword();
  mUri.setUserPassword(null);
  try {
    mProfile.mAddress=mAddressFactory.createAddress(mDisplayName,mUri);
    if (!TextUtils.isEmpty(mProxyAddress)) {
      SipURI uri=(SipURI)mAddressFactory.createURI(fix(mProxyAddress));
      mProfile.mProxyAddress=uri.getHost();
    }
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
  return mProfile;
}","/** 
 * Builds and returns the SIP profile object.
 * @return the profile object created
 */
public SipProfile build(){
  mProfile.mPassword=mUri.getUserPassword();
  mUri.setUserPassword(null);
  try {
    if (!TextUtils.isEmpty(mProxyAddress)) {
      SipURI uri=(SipURI)mAddressFactory.createURI(fix(mProxyAddress));
      mProfile.mProxyAddress=uri.getHost();
    }
 else {
      if (!mProfile.mProtocol.equals(UDP)) {
        mUri.setTransportParam(mProfile.mProtocol);
      }
      if (mProfile.mPort != DEFAULT_PORT) {
        mUri.setPort(mProfile.mPort);
      }
    }
    mProfile.mAddress=mAddressFactory.createAddress(mDisplayName,mUri);
  }
 catch (  InvalidArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  ParseException e) {
    throw new RuntimeException(e);
  }
  return mProfile;
}",0.6470154753131908
181204,"@Override public void writeToParcel(Parcel out,int flags){
  out.writeSerializable(mAddress);
  out.writeString(mProxyAddress);
  out.writeString(mPassword);
  out.writeString(mDomain);
  out.writeString(mProtocol);
  out.writeString(mProfileName);
  out.writeInt(mSendKeepAlive ? 1 : 0);
  out.writeInt(mAutoRegistration ? 1 : 0);
  out.writeInt(mCallingUid);
}","@Override public void writeToParcel(Parcel out,int flags){
  out.writeSerializable(mAddress);
  out.writeString(mProxyAddress);
  out.writeString(mPassword);
  out.writeString(mDomain);
  out.writeString(mProtocol);
  out.writeString(mProfileName);
  out.writeInt(mSendKeepAlive ? 1 : 0);
  out.writeInt(mAutoRegistration ? 1 : 0);
  out.writeInt(mCallingUid);
  out.writeInt(mPort);
}",0.9692101740294512
181205,"private Request createRequest(String requestType,SipProfile userProfile,String tag) throws ParseException, SipException {
  FromHeader fromHeader=createFromHeader(userProfile,tag);
  ToHeader toHeader=createToHeader(userProfile);
  SipURI requestURI=mAddressFactory.createSipURI(""String_Node_Str"" + userProfile.getSipDomain());
  List<ViaHeader> viaHeaders=createViaHeaders();
  CallIdHeader callIdHeader=createCallIdHeader();
  CSeqHeader cSeqHeader=createCSeqHeader(requestType);
  MaxForwardsHeader maxForwards=createMaxForwardsHeader();
  Request request=mMessageFactory.createRequest(requestURI,requestType,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards);
  Header userAgentHeader=mHeaderFactory.createHeader(""String_Node_Str"",""String_Node_Str"");
  request.addHeader(userAgentHeader);
  return request;
}","private Request createRequest(String requestType,SipProfile userProfile,String tag) throws ParseException, SipException {
  FromHeader fromHeader=createFromHeader(userProfile,tag);
  ToHeader toHeader=createToHeader(userProfile);
  SipURI requestURI=mAddressFactory.createSipURI(userProfile.getUriString().replaceFirst(userProfile.getUserName() + ""String_Node_Str"",""String_Node_Str""));
  List<ViaHeader> viaHeaders=createViaHeaders();
  CallIdHeader callIdHeader=createCallIdHeader();
  CSeqHeader cSeqHeader=createCSeqHeader(requestType);
  MaxForwardsHeader maxForwards=createMaxForwardsHeader();
  Request request=mMessageFactory.createRequest(requestURI,requestType,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards);
  Header userAgentHeader=mHeaderFactory.createHeader(""String_Node_Str"",""String_Node_Str"");
  request.addHeader(userAgentHeader);
  return request;
}",0.9335664335664337
181206,"private Intent newGrantCredentialsPermissionIntent(Account account,int uid,AccountAuthenticatorResponse response,String authTokenType,String authTokenLabel){
  RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo=mAuthenticatorCache.getServiceInfo(AuthenticatorDescription.newKey(account.type));
  if (serviceInfo == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + account.type);
  }
  final Context authContext;
  try {
    authContext=mContext.createPackageContext(serviceInfo.type.packageName,0);
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + account.type);
  }
  Intent intent=new Intent(mContext,GrantCredentialsPermissionActivity.class);
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.addCategory(String.valueOf(getCredentialPermissionNotificationId(account,authTokenType,uid)));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT,account);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_LABEL,authTokenLabel);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE,authTokenType);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE,response);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT_TYPE_LABEL,authContext.getString(serviceInfo.type.labelId));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_PACKAGES,mContext.getPackageManager().getPackagesForUid(uid));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID,uid);
  return intent;
}","private Intent newGrantCredentialsPermissionIntent(Account account,int uid,AccountAuthenticatorResponse response,String authTokenType,String authTokenLabel){
  Intent intent=new Intent(mContext,GrantCredentialsPermissionActivity.class);
  intent.addCategory(String.valueOf(getCredentialPermissionNotificationId(account,authTokenType,uid)));
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT,account);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE,authTokenType);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE,response);
  intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID,uid);
  return intent;
}",0.5392670157068062
181207,"protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.grant_credentials_permission);
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final Bundle extras=getIntent().getExtras();
  mAccount=extras.getParcelable(EXTRAS_ACCOUNT);
  mAuthTokenType=extras.getString(EXTRAS_AUTH_TOKEN_TYPE);
  if (mAccount == null || mAuthTokenType == null) {
    setResult(Activity.RESULT_CANCELED);
    finish();
    return;
  }
  mUid=extras.getInt(EXTRAS_REQUESTING_UID);
  final String accountTypeLabel=extras.getString(EXTRAS_ACCOUNT_TYPE_LABEL);
  final String[] packages=extras.getStringArray(EXTRAS_PACKAGES);
  final String authTokenLabel=extras.getString(EXTRAS_AUTH_TOKEN_LABEL);
  findViewById(R.id.allow_button).setOnClickListener(this);
  findViewById(R.id.deny_button).setOnClickListener(this);
  LinearLayout packagesListView=(LinearLayout)findViewById(R.id.packages_list);
  final PackageManager pm=getPackageManager();
  for (  String pkg : packages) {
    String packageLabel;
    try {
      packageLabel=pm.getApplicationLabel(pm.getApplicationInfo(pkg,0)).toString();
    }
 catch (    PackageManager.NameNotFoundException e) {
      packageLabel=pkg;
    }
    packagesListView.addView(newPackageView(packageLabel));
  }
  ((TextView)findViewById(R.id.account_name)).setText(mAccount.name);
  ((TextView)findViewById(R.id.account_type)).setText(accountTypeLabel);
  TextView authTokenTypeView=(TextView)findViewById(R.id.authtoken_type);
  if (TextUtils.isEmpty(authTokenLabel)) {
    authTokenTypeView.setVisibility(View.GONE);
  }
 else {
    authTokenTypeView.setText(authTokenLabel);
  }
}","protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.grant_credentials_permission);
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final Bundle extras=getIntent().getExtras();
  mAccount=extras.getParcelable(EXTRAS_ACCOUNT);
  mAuthTokenType=extras.getString(EXTRAS_AUTH_TOKEN_TYPE);
  mUid=extras.getInt(EXTRAS_REQUESTING_UID);
  final PackageManager pm=getPackageManager();
  final String[] packages=pm.getPackagesForUid(mUid);
  if (mAccount == null || mAuthTokenType == null || packages == null) {
    setResult(Activity.RESULT_CANCELED);
    finish();
    return;
  }
  final String accountTypeLabel=accountManagerService.getAccountLabel(mAccount.type);
  final TextView authTokenTypeView=(TextView)findViewById(R.id.authtoken_type);
  authTokenTypeView.setVisibility(View.GONE);
  IAccountManagerResponse response=new IAccountManagerResponse.Stub(){
    public void onResult(    Bundle bundle){
      final String authTokenLabel=bundle.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);
      if (!TextUtils.isEmpty(authTokenLabel)) {
        runOnUiThread(new Runnable(){
          public void run(){
            if (!isFinishing()) {
              authTokenTypeView.setText(authTokenLabel);
              authTokenTypeView.setVisibility(View.VISIBLE);
            }
          }
        }
);
      }
    }
    public void onError(    int code,    String message){
    }
  }
;
  accountManagerService.getAuthTokenLabel(response,mAccount,mAuthTokenType);
  findViewById(R.id.allow_button).setOnClickListener(this);
  findViewById(R.id.deny_button).setOnClickListener(this);
  LinearLayout packagesListView=(LinearLayout)findViewById(R.id.packages_list);
  for (  String pkg : packages) {
    String packageLabel;
    try {
      packageLabel=pm.getApplicationLabel(pm.getApplicationInfo(pkg,0)).toString();
    }
 catch (    PackageManager.NameNotFoundException e) {
      packageLabel=pkg;
    }
    packagesListView.addView(newPackageView(packageLabel));
  }
  ((TextView)findViewById(R.id.account_name)).setText(mAccount.name);
  ((TextView)findViewById(R.id.account_type)).setText(accountTypeLabel);
}",0.2955911823647295
181208,"public void onClick(View v){
  final AccountManagerService accountManagerService=AccountManagerService.getSingleton();
switch (v.getId()) {
case R.id.allow_button:
    accountManagerService.grantAppPermission(mAccount,mAuthTokenType,mUid);
  Intent result=new Intent();
result.putExtra(""String_Node_Str"",true);
setResult(RESULT_OK,result);
setAccountAuthenticatorResult(result.getExtras());
break;
case R.id.deny_button:
accountManagerService.revokeAppPermission(mAccount,mAuthTokenType,mUid);
setResult(RESULT_CANCELED);
break;
}
finish();
}","public void onClick(View v){
switch (v.getId()) {
case R.id.allow_button:
    accountManagerService.grantAppPermission(mAccount,mAuthTokenType,mUid);
  Intent result=new Intent();
result.putExtra(""String_Node_Str"",true);
setResult(RESULT_OK,result);
setAccountAuthenticatorResult(result.getExtras());
break;
case R.id.deny_button:
accountManagerService.revokeAppPermission(mAccount,mAuthTokenType,mUid);
setResult(RESULT_CANCELED);
break;
}
finish();
}",0.909456740442656
181209,"/** 
 * Gets the SIP URI string of this profile.
 * @return the SIP URI string of this profile
 */
public String getUriString(){
  return mAddress.getURI().toString();
}","/** 
 * Gets the SIP URI string of this profile.
 * @return the SIP URI string of this profile
 */
public String getUriString(){
  if (!TextUtils.isEmpty(mProxyAddress)) {
    return ""String_Node_Str"" + getUserName() + ""String_Node_Str""+ mDomain;
  }
  return getUri().toString();
}",0.6740576496674058
181210,"/** 
 * Sets the protocol used to connect to the SIP server. Currently, only ""UDP"" and ""TCP"" are supported.
 * @param protocol the protocol string
 * @return this builder object
 * @throws IllegalArgumentException if the protocol is not recognized
 */
public Builder setProtocol(String protocol) throws IllegalArgumentException {
  if (protocol == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  protocol=protocol.toUpperCase();
  if (!protocol.equals(""String_Node_Str"") && !protocol.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + protocol);
  }
  mProfile.mProtocol=protocol;
  return this;
}","/** 
 * Sets the protocol used to connect to the SIP server. Currently, only ""UDP"" and ""TCP"" are supported.
 * @param protocol the protocol string
 * @return this builder object
 * @throws IllegalArgumentException if the protocol is not recognized
 */
public Builder setProtocol(String protocol) throws IllegalArgumentException {
  if (protocol == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  protocol=protocol.toUpperCase();
  if (!protocol.equals(UDP) && !protocol.equals(TCP)) {
    throw new IllegalArgumentException(""String_Node_Str"" + protocol);
  }
  mProfile.mProtocol=protocol;
  return this;
}",0.8658346333853354
181211,"/** 
 * Sets the port number of the server. By default, it is 5060.
 * @param port port number of the server
 * @return this builder object
 * @throws IllegalArgumentException if the port number is out of range
 */
public Builder setPort(int port) throws IllegalArgumentException {
  try {
    mUri.setPort(port);
    return this;
  }
 catch (  InvalidArgumentException e) {
    throw new IllegalArgumentException(e);
  }
}","/** 
 * Sets the port number of the server. By default, it is 5060.
 * @param port port number of the server
 * @return this builder object
 * @throws IllegalArgumentException if the port number is out of range
 */
public Builder setPort(int port) throws IllegalArgumentException {
  if ((port > 65535) || (port < 1000)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mProfile.mPort=port;
  return this;
}",0.7523584905660378
181212,"private SipProfile(Parcel in){
  mAddress=(Address)in.readSerializable();
  mProxyAddress=in.readString();
  mPassword=in.readString();
  mDomain=in.readString();
  mProtocol=in.readString();
  mProfileName=in.readString();
  mSendKeepAlive=(in.readInt() == 0) ? false : true;
  mAutoRegistration=(in.readInt() == 0) ? false : true;
  mCallingUid=in.readInt();
}","private SipProfile(Parcel in){
  mAddress=(Address)in.readSerializable();
  mProxyAddress=in.readString();
  mPassword=in.readString();
  mDomain=in.readString();
  mProtocol=in.readString();
  mProfileName=in.readString();
  mSendKeepAlive=(in.readInt() == 0) ? false : true;
  mAutoRegistration=(in.readInt() == 0) ? false : true;
  mCallingUid=in.readInt();
  mPort=in.readInt();
}",0.970509383378016
181213,"/** 
 * Gets the port number of the SIP server.
 * @return the port number of the SIP server
 */
public int getPort(){
  int port=getUri().getPort();
  return (port == -1) ? DEFAULT_PORT : port;
}","/** 
 * Gets the port number of the SIP server.
 * @return the port number of the SIP server
 */
public int getPort(){
  return mPort;
}",0.8132530120481928
181214,"/** 
 * Builds and returns the SIP profile object.
 * @return the profile object created
 */
public SipProfile build(){
  mProfile.mPassword=mUri.getUserPassword();
  mUri.setUserPassword(null);
  try {
    mProfile.mAddress=mAddressFactory.createAddress(mDisplayName,mUri);
    if (!TextUtils.isEmpty(mProxyAddress)) {
      SipURI uri=(SipURI)mAddressFactory.createURI(fix(mProxyAddress));
      mProfile.mProxyAddress=uri.getHost();
    }
  }
 catch (  ParseException e) {
    throw new RuntimeException(e);
  }
  return mProfile;
}","/** 
 * Builds and returns the SIP profile object.
 * @return the profile object created
 */
public SipProfile build(){
  mProfile.mPassword=mUri.getUserPassword();
  mUri.setUserPassword(null);
  try {
    if (!TextUtils.isEmpty(mProxyAddress)) {
      SipURI uri=(SipURI)mAddressFactory.createURI(fix(mProxyAddress));
      mProfile.mProxyAddress=uri.getHost();
    }
 else {
      if (!mProfile.mProtocol.equals(UDP)) {
        mUri.setTransportParam(mProfile.mProtocol);
      }
      if (mProfile.mPort != DEFAULT_PORT) {
        mUri.setPort(mProfile.mPort);
      }
    }
    mProfile.mAddress=mAddressFactory.createAddress(mDisplayName,mUri);
  }
 catch (  InvalidArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  ParseException e) {
    throw new RuntimeException(e);
  }
  return mProfile;
}",0.6470154753131908
181215,"@Override public void writeToParcel(Parcel out,int flags){
  out.writeSerializable(mAddress);
  out.writeString(mProxyAddress);
  out.writeString(mPassword);
  out.writeString(mDomain);
  out.writeString(mProtocol);
  out.writeString(mProfileName);
  out.writeInt(mSendKeepAlive ? 1 : 0);
  out.writeInt(mAutoRegistration ? 1 : 0);
  out.writeInt(mCallingUid);
}","@Override public void writeToParcel(Parcel out,int flags){
  out.writeSerializable(mAddress);
  out.writeString(mProxyAddress);
  out.writeString(mPassword);
  out.writeString(mDomain);
  out.writeString(mProtocol);
  out.writeString(mProfileName);
  out.writeInt(mSendKeepAlive ? 1 : 0);
  out.writeInt(mAutoRegistration ? 1 : 0);
  out.writeInt(mCallingUid);
  out.writeInt(mPort);
}",0.9692101740294512
181216,"private Request createRequest(String requestType,SipProfile userProfile,String tag) throws ParseException, SipException {
  FromHeader fromHeader=createFromHeader(userProfile,tag);
  ToHeader toHeader=createToHeader(userProfile);
  SipURI requestURI=mAddressFactory.createSipURI(""String_Node_Str"" + userProfile.getSipDomain());
  List<ViaHeader> viaHeaders=createViaHeaders();
  CallIdHeader callIdHeader=createCallIdHeader();
  CSeqHeader cSeqHeader=createCSeqHeader(requestType);
  MaxForwardsHeader maxForwards=createMaxForwardsHeader();
  Request request=mMessageFactory.createRequest(requestURI,requestType,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards);
  Header userAgentHeader=mHeaderFactory.createHeader(""String_Node_Str"",""String_Node_Str"");
  request.addHeader(userAgentHeader);
  return request;
}","private Request createRequest(String requestType,SipProfile userProfile,String tag) throws ParseException, SipException {
  FromHeader fromHeader=createFromHeader(userProfile,tag);
  ToHeader toHeader=createToHeader(userProfile);
  SipURI requestURI=mAddressFactory.createSipURI(userProfile.getUriString().replaceFirst(userProfile.getUserName() + ""String_Node_Str"",""String_Node_Str""));
  List<ViaHeader> viaHeaders=createViaHeaders();
  CallIdHeader callIdHeader=createCallIdHeader();
  CSeqHeader cSeqHeader=createCSeqHeader(requestType);
  MaxForwardsHeader maxForwards=createMaxForwardsHeader();
  Request request=mMessageFactory.createRequest(requestURI,requestType,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards);
  Header userAgentHeader=mHeaderFactory.createHeader(""String_Node_Str"",""String_Node_Str"");
  request.addHeader(userAgentHeader);
  return request;
}",0.9335664335664337
181217,"private void startTextSelectionMode(){
  if (!mIsInTextSelectionMode) {
    if (mSelectionModifierCursorController == null) {
      Log.w(LOG_TAG,""String_Node_Str"");
      return;
    }
    if (!requestFocus()) {
      return;
    }
    selectCurrentWord();
    mSelectionModifierCursorController.show();
    mIsInTextSelectionMode=true;
  }
}","private void startTextSelectionMode(){
  if (!mIsInTextSelectionMode) {
    if (!hasSelectionController()) {
      Log.w(LOG_TAG,""String_Node_Str"");
      return;
    }
    if (!requestFocus()) {
      return;
    }
    selectCurrentWord();
    mIsInTextSelectionMode=true;
  }
}",0.7942122186495176
181218,"public void beginBatchEdit(){
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=++ims.mBatchEditNesting;
    if (nesting == 1) {
      ims.mCursorChanged=false;
      ims.mChangedDelta=0;
      if (ims.mContentChanged) {
        ims.mChangedStart=0;
        ims.mChangedEnd=mText.length();
      }
 else {
        ims.mChangedStart=EXTRACT_UNKNOWN;
        ims.mChangedEnd=EXTRACT_UNKNOWN;
        ims.mContentChanged=false;
      }
      onBeginBatchEdit();
    }
  }
}","public void beginBatchEdit(){
  mInBatchEditControllers=true;
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=++ims.mBatchEditNesting;
    if (nesting == 1) {
      ims.mCursorChanged=false;
      ims.mChangedDelta=0;
      if (ims.mContentChanged) {
        ims.mChangedStart=0;
        ims.mChangedEnd=mText.length();
      }
 else {
        ims.mChangedStart=EXTRACT_UNKNOWN;
        ims.mChangedEnd=EXTRACT_UNKNOWN;
        ims.mContentChanged=false;
      }
      onBeginBatchEdit();
    }
  }
}",0.9692898272552783
181219,"/** 
 * Called when a context menu option for the text view is selected.  Currently this will be one of:   {@link android.R.id#selectAll},  {@link android.R.id#startSelectingText},  {@link android.R.id#cut},   {@link android.R.id#copy},  {@link android.R.id#paste},   {@link android.R.id#copyUrl}, or   {@link android.R.id#switchInputMethod}.
 */
public boolean onTextContextMenuItem(int id){
  int min=0;
  int max=mText.length();
  if (isFocused()) {
    final int selStart=getSelectionStart();
    final int selEnd=getSelectionEnd();
    min=Math.max(0,Math.min(selStart,selEnd));
    max=Math.max(0,Math.max(selStart,selEnd));
  }
  ClipboardManager clip=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
switch (id) {
case ID_SELECT_ALL:
    Selection.setSelection((Spannable)mText,0,mText.length());
  startTextSelectionMode();
return true;
case ID_START_SELECTING_TEXT:
startTextSelectionMode();
return true;
case ID_CUT:
clip.setText(mTransformed.subSequence(min,max));
((Editable)mText).delete(min,max);
stopTextSelectionMode();
return true;
case ID_COPY:
clip.setText(mTransformed.subSequence(min,max));
stopTextSelectionMode();
return true;
case ID_PASTE:
CharSequence paste=clip.getText();
if (paste != null && paste.length() > 0) {
long minMax=prepareSpacesAroundPaste(min,max,paste);
min=extractRangeStartFromLong(minMax);
max=extractRangeEndFromLong(minMax);
Selection.setSelection((Spannable)mText,max);
((Editable)mText).replace(min,max,paste);
stopTextSelectionMode();
}
return true;
case ID_COPY_URL:
URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
if (urls.length == 1) {
clip.setText(urls[0].getURL());
}
return true;
case ID_SWITCH_INPUT_METHOD:
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.showInputMethodPicker();
}
return true;
case ID_ADD_TO_DICTIONARY:
String word=getWordForDictionary();
if (word != null) {
Intent i=new Intent(""String_Node_Str"");
i.putExtra(""String_Node_Str"",word);
i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
getContext().startActivity(i);
}
return true;
}
return false;
}","/** 
 * Called when a context menu option for the text view is selected.  Currently this will be one of:   {@link android.R.id#selectAll},  {@link android.R.id#startSelectingText},  {@link android.R.id#cut},   {@link android.R.id#copy},  {@link android.R.id#paste},   {@link android.R.id#copyUrl}, or   {@link android.R.id#switchInputMethod}.
 */
public boolean onTextContextMenuItem(int id){
  int min=0;
  int max=mText.length();
  if (isFocused()) {
    final int selStart=getSelectionStart();
    final int selEnd=getSelectionEnd();
    min=Math.max(0,Math.min(selStart,selEnd));
    max=Math.max(0,Math.max(selStart,selEnd));
  }
  ClipboardManager clip=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
switch (id) {
case ID_SELECT_ALL:
    Selection.setSelection((Spannable)mText,0,mText.length());
  startTextSelectionMode();
getSelectionController().show();
return true;
case ID_START_SELECTING_TEXT:
startTextSelectionMode();
getSelectionController().show();
return true;
case ID_CUT:
clip.setText(mTransformed.subSequence(min,max));
((Editable)mText).delete(min,max);
stopTextSelectionMode();
return true;
case ID_COPY:
clip.setText(mTransformed.subSequence(min,max));
stopTextSelectionMode();
return true;
case ID_PASTE:
CharSequence paste=clip.getText();
if (paste != null && paste.length() > 0) {
long minMax=prepareSpacesAroundPaste(min,max,paste);
min=extractRangeStartFromLong(minMax);
max=extractRangeEndFromLong(minMax);
Selection.setSelection((Spannable)mText,max);
((Editable)mText).replace(min,max,paste);
stopTextSelectionMode();
}
return true;
case ID_COPY_URL:
URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
if (urls.length == 1) {
clip.setText(urls[0].getURL());
}
return true;
case ID_SWITCH_INPUT_METHOD:
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.showInputMethodPicker();
}
return true;
case ID_ADD_TO_DICTIONARY:
String word=getWordForDictionary();
if (word != null) {
Intent i=new Intent(""String_Node_Str"");
i.putExtra(""String_Node_Str"",word);
i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
getContext().startActivity(i);
}
return true;
}
return false;
}",0.9846153846153848
181220,"private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      if (mSelectionModifierCursorController != null && !mSelectionModifierCursorController.isShowing()) {
        mSelectionModifierCursorController.show();
      }
 else {
        showContextMenu();
      }
      return;
    }
 else {
      stopTextSelectionMode();
      if (mInsertionPointCursorController != null && mText.length() > 0) {
        mInsertionPointCursorController.show();
      }
    }
  }
 else   if (hasSelection() && mSelectionModifierCursorController != null) {
    mSelectionModifierCursorController.show();
  }
}","private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      if (hasSelectionController() && !getSelectionController().isShowing()) {
        getSelectionController().show();
      }
 else {
        showContextMenu();
      }
      return;
    }
 else {
      stopTextSelectionMode();
      if (hasInsertionController() && mText.length() > 0) {
        getInsertionController().show();
      }
    }
  }
 else   if (hasSelection() && hasSelectionController()) {
    getSelectionController().show();
  }
}",0.7348284960422163
181221,"public void show(){
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}","public void show(){
  if (isInBatchEditMode()) {
    return;
  }
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.8899755501222494
181222,"public void endBatchEdit(){
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=--ims.mBatchEditNesting;
    if (nesting == 0) {
      finishBatchEdit(ims);
    }
  }
}","public void endBatchEdit(){
  mInBatchEditControllers=false;
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=--ims.mBatchEditNesting;
    if (nesting == 0) {
      finishBatchEdit(ims);
    }
  }
}",0.9241379310344828
181223,"private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  if (windowSupportsHandles && mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (windowSupportsHandles && textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  mInsertionControllerEnabled=windowSupportsHandles && mCursorVisible && mLayout != null;
  mSelectionControllerEnabled=windowSupportsHandles && textCanBeSelected() && mLayout != null;
  if (!mInsertionControllerEnabled) {
    mInsertionPointCursorController=null;
  }
  if (!mSelectionControllerEnabled) {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.5800109229929
181224,"/** 
 * {@inheritDoc}
 */
public boolean onPreDraw(){
  if (mPreDrawState != PREDRAW_PENDING) {
    return true;
  }
  if (mLayout == null) {
    assumeLayout();
  }
  boolean changed=false;
  SelectionModifierCursorController selectionController=null;
  if (mSelectionModifierCursorController != null) {
    selectionController=(SelectionModifierCursorController)mSelectionModifierCursorController;
  }
  if (mMovement != null) {
    int curs=getSelectionEnd();
    if (selectionController != null && selectionController.isSelectionStartDragged()) {
      curs=getSelectionStart();
    }
    if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
      curs=mText.length();
    }
    if (curs >= 0) {
      changed=bringPointIntoView(curs);
    }
  }
 else {
    changed=bringTextIntoView();
  }
  if (selectionController != null && hasSelection()) {
    startTextSelectionMode();
  }
  mPreDrawState=PREDRAW_DONE;
  return !changed;
}","/** 
 * {@inheritDoc}
 */
public boolean onPreDraw(){
  if (mPreDrawState != PREDRAW_PENDING) {
    return true;
  }
  if (mLayout == null) {
    assumeLayout();
  }
  boolean changed=false;
  SelectionModifierCursorController selectionController=null;
  if (mSelectionModifierCursorController != null) {
    selectionController=(SelectionModifierCursorController)mSelectionModifierCursorController;
  }
  if (mMovement != null) {
    int curs=getSelectionEnd();
    if (selectionController != null && selectionController.isSelectionStartDragged()) {
      curs=getSelectionStart();
    }
    if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
      curs=mText.length();
    }
    if (curs >= 0) {
      changed=bringPointIntoView(curs);
    }
  }
 else {
    changed=bringTextIntoView();
  }
  if (this instanceof ExtractEditText && selectionController != null && hasSelection()) {
    startTextSelectionMode();
  }
  mPreDrawState=PREDRAW_DONE;
  return !changed;
}",0.9821154828819622
181225,"public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  mStartHandle.positionAtCursor(selectionStart,true);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}","public void updatePosition(){
  if (!isShowing()) {
    return;
  }
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  mStartHandle.positionAtCursor(selectionStart,true);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.9527363184079602
181226,"private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY + (int)mHotspotY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY <= clip.bottom;
}","private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  if (isInBatchEditMode()) {
    return false;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY + (int)mHotspotY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY <= clip.bottom;
}",0.9784172661870504
181227,"private void startTextSelectionMode(){
  if (!mIsInTextSelectionMode) {
    if (mSelectionModifierCursorController == null) {
      Log.w(LOG_TAG,""String_Node_Str"");
      return;
    }
    if (!requestFocus()) {
      return;
    }
    selectCurrentWord();
    mSelectionModifierCursorController.show();
    mIsInTextSelectionMode=true;
  }
}","private void startTextSelectionMode(){
  if (!mIsInTextSelectionMode) {
    if (!hasSelectionController()) {
      Log.w(LOG_TAG,""String_Node_Str"");
      return;
    }
    if (!requestFocus()) {
      return;
    }
    selectCurrentWord();
    mIsInTextSelectionMode=true;
  }
}",0.7942122186495176
181228,"public void beginBatchEdit(){
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=++ims.mBatchEditNesting;
    if (nesting == 1) {
      ims.mCursorChanged=false;
      ims.mChangedDelta=0;
      if (ims.mContentChanged) {
        ims.mChangedStart=0;
        ims.mChangedEnd=mText.length();
      }
 else {
        ims.mChangedStart=EXTRACT_UNKNOWN;
        ims.mChangedEnd=EXTRACT_UNKNOWN;
        ims.mContentChanged=false;
      }
      onBeginBatchEdit();
    }
  }
}","public void beginBatchEdit(){
  mInBatchEditControllers=true;
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=++ims.mBatchEditNesting;
    if (nesting == 1) {
      ims.mCursorChanged=false;
      ims.mChangedDelta=0;
      if (ims.mContentChanged) {
        ims.mChangedStart=0;
        ims.mChangedEnd=mText.length();
      }
 else {
        ims.mChangedStart=EXTRACT_UNKNOWN;
        ims.mChangedEnd=EXTRACT_UNKNOWN;
        ims.mContentChanged=false;
      }
      onBeginBatchEdit();
    }
  }
}",0.9692898272552783
181229,"/** 
 * Called when a context menu option for the text view is selected.  Currently this will be one of:   {@link android.R.id#selectAll},  {@link android.R.id#startSelectingText},  {@link android.R.id#cut},   {@link android.R.id#copy},  {@link android.R.id#paste},   {@link android.R.id#copyUrl}, or   {@link android.R.id#switchInputMethod}.
 */
public boolean onTextContextMenuItem(int id){
  int min=0;
  int max=mText.length();
  if (isFocused()) {
    final int selStart=getSelectionStart();
    final int selEnd=getSelectionEnd();
    min=Math.max(0,Math.min(selStart,selEnd));
    max=Math.max(0,Math.max(selStart,selEnd));
  }
  ClipboardManager clip=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
switch (id) {
case ID_SELECT_ALL:
    Selection.setSelection((Spannable)mText,0,mText.length());
  startTextSelectionMode();
return true;
case ID_START_SELECTING_TEXT:
startTextSelectionMode();
return true;
case ID_CUT:
clip.setText(mTransformed.subSequence(min,max));
((Editable)mText).delete(min,max);
stopTextSelectionMode();
return true;
case ID_COPY:
clip.setText(mTransformed.subSequence(min,max));
stopTextSelectionMode();
return true;
case ID_PASTE:
CharSequence paste=clip.getText();
if (paste != null && paste.length() > 0) {
long minMax=prepareSpacesAroundPaste(min,max,paste);
min=extractRangeStartFromLong(minMax);
max=extractRangeEndFromLong(minMax);
Selection.setSelection((Spannable)mText,max);
((Editable)mText).replace(min,max,paste);
stopTextSelectionMode();
}
return true;
case ID_COPY_URL:
URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
if (urls.length == 1) {
clip.setText(urls[0].getURL());
}
return true;
case ID_SWITCH_INPUT_METHOD:
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.showInputMethodPicker();
}
return true;
case ID_ADD_TO_DICTIONARY:
String word=getWordForDictionary();
if (word != null) {
Intent i=new Intent(""String_Node_Str"");
i.putExtra(""String_Node_Str"",word);
i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
getContext().startActivity(i);
}
return true;
}
return false;
}","/** 
 * Called when a context menu option for the text view is selected.  Currently this will be one of:   {@link android.R.id#selectAll},  {@link android.R.id#startSelectingText},  {@link android.R.id#cut},   {@link android.R.id#copy},  {@link android.R.id#paste},   {@link android.R.id#copyUrl}, or   {@link android.R.id#switchInputMethod}.
 */
public boolean onTextContextMenuItem(int id){
  int min=0;
  int max=mText.length();
  if (isFocused()) {
    final int selStart=getSelectionStart();
    final int selEnd=getSelectionEnd();
    min=Math.max(0,Math.min(selStart,selEnd));
    max=Math.max(0,Math.max(selStart,selEnd));
  }
  ClipboardManager clip=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
switch (id) {
case ID_SELECT_ALL:
    Selection.setSelection((Spannable)mText,0,mText.length());
  startTextSelectionMode();
getSelectionController().show();
return true;
case ID_START_SELECTING_TEXT:
startTextSelectionMode();
getSelectionController().show();
return true;
case ID_CUT:
clip.setText(mTransformed.subSequence(min,max));
((Editable)mText).delete(min,max);
stopTextSelectionMode();
return true;
case ID_COPY:
clip.setText(mTransformed.subSequence(min,max));
stopTextSelectionMode();
return true;
case ID_PASTE:
CharSequence paste=clip.getText();
if (paste != null && paste.length() > 0) {
long minMax=prepareSpacesAroundPaste(min,max,paste);
min=extractRangeStartFromLong(minMax);
max=extractRangeEndFromLong(minMax);
Selection.setSelection((Spannable)mText,max);
((Editable)mText).replace(min,max,paste);
stopTextSelectionMode();
}
return true;
case ID_COPY_URL:
URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
if (urls.length == 1) {
clip.setText(urls[0].getURL());
}
return true;
case ID_SWITCH_INPUT_METHOD:
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.showInputMethodPicker();
}
return true;
case ID_ADD_TO_DICTIONARY:
String word=getWordForDictionary();
if (word != null) {
Intent i=new Intent(""String_Node_Str"");
i.putExtra(""String_Node_Str"",word);
i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
getContext().startActivity(i);
}
return true;
}
return false;
}",0.9846153846153848
181230,"private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      if (mSelectionModifierCursorController != null && !mSelectionModifierCursorController.isShowing()) {
        mSelectionModifierCursorController.show();
      }
 else {
        showContextMenu();
      }
      return;
    }
 else {
      stopTextSelectionMode();
      if (mInsertionPointCursorController != null && mText.length() > 0) {
        mInsertionPointCursorController.show();
      }
    }
  }
 else   if (hasSelection() && mSelectionModifierCursorController != null) {
    mSelectionModifierCursorController.show();
  }
}","private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      if (hasSelectionController() && !getSelectionController().isShowing()) {
        getSelectionController().show();
      }
 else {
        showContextMenu();
      }
      return;
    }
 else {
      stopTextSelectionMode();
      if (hasInsertionController() && mText.length() > 0) {
        getInsertionController().show();
      }
    }
  }
 else   if (hasSelection() && hasSelectionController()) {
    getSelectionController().show();
  }
}",0.7348284960422163
181231,"public void show(){
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}","public void show(){
  if (isInBatchEditMode()) {
    return;
  }
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.8899755501222494
181232,"public void endBatchEdit(){
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=--ims.mBatchEditNesting;
    if (nesting == 0) {
      finishBatchEdit(ims);
    }
  }
}","public void endBatchEdit(){
  mInBatchEditControllers=false;
  final InputMethodState ims=mInputMethodState;
  if (ims != null) {
    int nesting=--ims.mBatchEditNesting;
    if (nesting == 0) {
      finishBatchEdit(ims);
    }
  }
}",0.9241379310344828
181233,"private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  if (windowSupportsHandles && mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (windowSupportsHandles && textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  mInsertionControllerEnabled=windowSupportsHandles && mCursorVisible && mLayout != null;
  mSelectionControllerEnabled=windowSupportsHandles && textCanBeSelected() && mLayout != null;
  if (!mInsertionControllerEnabled) {
    mInsertionPointCursorController=null;
  }
  if (!mSelectionControllerEnabled) {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.5800109229929
181234,"/** 
 * {@inheritDoc}
 */
public boolean onPreDraw(){
  if (mPreDrawState != PREDRAW_PENDING) {
    return true;
  }
  if (mLayout == null) {
    assumeLayout();
  }
  boolean changed=false;
  SelectionModifierCursorController selectionController=null;
  if (mSelectionModifierCursorController != null) {
    selectionController=(SelectionModifierCursorController)mSelectionModifierCursorController;
  }
  if (mMovement != null) {
    int curs=getSelectionEnd();
    if (selectionController != null && selectionController.isSelectionStartDragged()) {
      curs=getSelectionStart();
    }
    if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
      curs=mText.length();
    }
    if (curs >= 0) {
      changed=bringPointIntoView(curs);
    }
  }
 else {
    changed=bringTextIntoView();
  }
  if (selectionController != null && hasSelection()) {
    startTextSelectionMode();
  }
  mPreDrawState=PREDRAW_DONE;
  return !changed;
}","/** 
 * {@inheritDoc}
 */
public boolean onPreDraw(){
  if (mPreDrawState != PREDRAW_PENDING) {
    return true;
  }
  if (mLayout == null) {
    assumeLayout();
  }
  boolean changed=false;
  SelectionModifierCursorController selectionController=null;
  if (mSelectionModifierCursorController != null) {
    selectionController=(SelectionModifierCursorController)mSelectionModifierCursorController;
  }
  if (mMovement != null) {
    int curs=getSelectionEnd();
    if (selectionController != null && selectionController.isSelectionStartDragged()) {
      curs=getSelectionStart();
    }
    if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
      curs=mText.length();
    }
    if (curs >= 0) {
      changed=bringPointIntoView(curs);
    }
  }
 else {
    changed=bringTextIntoView();
  }
  if (this instanceof ExtractEditText && selectionController != null && hasSelection()) {
    startTextSelectionMode();
  }
  mPreDrawState=PREDRAW_DONE;
  return !changed;
}",0.9821154828819622
181235,"public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  mStartHandle.positionAtCursor(selectionStart,true);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}","public void updatePosition(){
  if (!isShowing()) {
    return;
  }
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  mStartHandle.positionAtCursor(selectionStart,true);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.9527363184079602
181236,"private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY + (int)mHotspotY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY <= clip.bottom;
}","private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  if (isInBatchEditMode()) {
    return false;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY + (int)mHotspotY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY <= clip.bottom;
}",0.9784172661870504
181237,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p><p>Note about auto scaling in compatibility mode: When auto scaling is not enabled, this method will create a bitmap of the same size as this view. Because this bitmap will be drawn scaled by the parent ViewGroup, the result on screen might show scaling artifacts. To avoid such artifacts, you should call this method by setting the auto scaling to true. Doing so, however, will generate a bitmap of a different size than the view. This implies that your application must be able to handle this size.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(boolean autoScale){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (Config.DEBUG && ViewDebug.profileDrawing) {
      EventLog.writeEvent(60002,hashCode());
    }
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    final AttachInfo attachInfo=mAttachInfo;
    final boolean scalingRequired=attachInfo != null && attachInfo.mScalingRequired;
    if (autoScale && scalingRequired) {
      width=(int)((width * attachInfo.mApplicationScale) + 0.5f);
      height=(int)((height * attachInfo.mApplicationScale) + 0.5f);
    }
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || isOpaque();
    final boolean translucentWindow=attachInfo != null && attachInfo.mTranslucentWindow;
    if (width <= 0 || height <= 0 || (width * height * (opaque && !translucentWindow ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=translucentWindow ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
if (autoScale) {
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 else {
mUnscaledDrawingCache=new SoftReference<Bitmap>(bitmap);
}
if (opaque && translucentWindow) bitmap.setHasAlpha(false);
}
 catch (OutOfMemoryError e) {
if (autoScale) {
mDrawingCache=null;
}
 else {
mUnscaledDrawingCache=null;
}
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
if (autoScale && scalingRequired) {
final float scale=attachInfo.mApplicationScale;
canvas.scale(scale,scale);
}
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
mPrivateFlags|=DRAWING_CACHE_VALID;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
mPrivateFlags&=~DIRTY_MASK;
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p><p>Note about auto scaling in compatibility mode: When auto scaling is not enabled, this method will create a bitmap of the same size as this view. Because this bitmap will be drawn scaled by the parent ViewGroup, the result on screen might show scaling artifacts. To avoid such artifacts, you should call this method by setting the auto scaling to true. Doing so, however, will generate a bitmap of a different size than the view. This implies that your application must be able to handle this size.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(boolean autoScale){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (Config.DEBUG && ViewDebug.profileDrawing) {
      EventLog.writeEvent(60002,hashCode());
    }
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    final AttachInfo attachInfo=mAttachInfo;
    final boolean scalingRequired=attachInfo != null && attachInfo.mScalingRequired;
    if (autoScale && scalingRequired) {
      width=(int)((width * attachInfo.mApplicationScale) + 0.5f);
      height=(int)((height * attachInfo.mApplicationScale) + 0.5f);
    }
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || isOpaque();
    final boolean use32BitCache=attachInfo != null && attachInfo.mUse32BitDrawingCache;
    if (width <= 0 || height <= 0 || (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
if (autoScale) {
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 else {
mUnscaledDrawingCache=new SoftReference<Bitmap>(bitmap);
}
if (opaque && use32BitCache) bitmap.setHasAlpha(false);
}
 catch (OutOfMemoryError e) {
if (autoScale) {
mDrawingCache=null;
}
 else {
mUnscaledDrawingCache=null;
}
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
if (autoScale && scalingRequired) {
final float scale=attachInfo.mApplicationScale;
canvas.scale(scale,scale);
}
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
mPrivateFlags|=DRAWING_CACHE_VALID;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
mPrivateFlags&=~DIRTY_MASK;
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
}
}",0.9816309816309816
181238,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=PixelFormat.formatHasAlpha(lp.format);
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    boolean hadSurface=mSurface.isValid();
    try {
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        mSurfaceHolder.mSurface=new Surface();
        mSurfaceHolder.mSurfaceLock.unlock();
      }
    }
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      if (mSurfaceHolder != null && mSurface.isValid()) {
        mSurfaceHolderCallback.surfaceRedrawNeeded(mSurfaceHolder);
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            if (c instanceof SurfaceHolder.Callback2) {
              ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
            }
          }
        }
      }
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=PixelFormat.formatHasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    boolean hadSurface=mSurface.isValid();
    try {
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        mSurfaceHolder.mSurface=new Surface();
        mSurfaceHolder.mSurfaceLock.unlock();
      }
    }
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      if (mSurfaceHolder != null && mSurface.isValid()) {
        mSurfaceHolderCallback.surfaceRedrawNeeded(mSurfaceHolder);
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            if (c instanceof SurfaceHolder.Callback2) {
              ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);
            }
          }
        }
      }
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}",0.9978798586572438
181239,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the x,y, and z axes which transforms prevR to R. outputs a 3 element vector containing the x,y, and z angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an array of floats in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  int i, j, k;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=R[0];
    pri1=R[1];
    pri2=R[2];
    pri3=R[3];
    pri4=R[4];
    pri5=R[5];
    pri6=R[6];
    pri7=R[7];
    pri8=R[8];
  }
 else   if (prevR.length == 16) {
    pri0=R[0];
    pri1=R[1];
    pri2=R[2];
    pri3=R[4];
    pri4=R[5];
    pri5=R[6];
    pri6=R[8];
    pri7=R[9];
    pri8=R[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the x,y, and z axes which transforms prevR to R. outputs a 3 element vector containing the x,y, and z angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an array of floats in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  int i, j, k;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.971878994461014
181240,"/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the x,y, and z axes which transforms prevR to R. outputs a 3 element vector containing the x,y, and z angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an array of floats in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  int i, j, k;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=R[0];
    pri1=R[1];
    pri2=R[2];
    pri3=R[3];
    pri4=R[4];
    pri5=R[5];
    pri6=R[6];
    pri7=R[7];
    pri8=R[8];
  }
 else   if (prevR.length == 16) {
    pri0=R[0];
    pri1=R[1];
    pri2=R[2];
    pri3=R[4];
    pri4=R[5];
    pri5=R[6];
    pri6=R[8];
    pri7=R[9];
    pri8=R[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}","/** 
 * Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the rotation around the x,y, and z axes which transforms prevR to R. outputs a 3 element vector containing the x,y, and z angle change at indexes 0, 1, and 2 respectively. <p> Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: <p>If the array length is 9, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   \ |  R[ 3]   R[ 4]   R[ 5]   | \  R[ 6]   R[ 7]   R[ 8]   / </pre> <p>If the array length is 16, then the array elements represent this matrix <pre> /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \ |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  | |  R[ 8]   R[ 9]   R[10]   R[11]  | \  R[12]   R[13]   R[14]   R[15]  / </pre>
 * @param R current rotation matrix
 * @param prevR previous rotation matrix
 * @param angleChange an array of floats in which the angle change is stored
 */
public static void getAngleChange(float[] angleChange,float[] R,float[] prevR){
  float rd1=0, rd4=0, rd6=0, rd7=0, rd8=0;
  float ri0=0, ri1=0, ri2=0, ri3=0, ri4=0, ri5=0, ri6=0, ri7=0, ri8=0;
  float pri0=0, pri1=0, pri2=0, pri3=0, pri4=0, pri5=0, pri6=0, pri7=0, pri8=0;
  int i, j, k;
  if (R.length == 9) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[3];
    ri4=R[4];
    ri5=R[5];
    ri6=R[6];
    ri7=R[7];
    ri8=R[8];
  }
 else   if (R.length == 16) {
    ri0=R[0];
    ri1=R[1];
    ri2=R[2];
    ri3=R[4];
    ri4=R[5];
    ri5=R[6];
    ri6=R[8];
    ri7=R[9];
    ri8=R[10];
  }
  if (prevR.length == 9) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[3];
    pri4=prevR[4];
    pri5=prevR[5];
    pri6=prevR[6];
    pri7=prevR[7];
    pri8=prevR[8];
  }
 else   if (prevR.length == 16) {
    pri0=prevR[0];
    pri1=prevR[1];
    pri2=prevR[2];
    pri3=prevR[4];
    pri4=prevR[5];
    pri5=prevR[6];
    pri6=prevR[8];
    pri7=prevR[9];
    pri8=prevR[10];
  }
  rd1=pri0 * ri1 + pri3 * ri4 + pri6 * ri7;
  rd4=pri1 * ri1 + pri4 * ri4 + pri7 * ri7;
  rd6=pri2 * ri0 + pri5 * ri3 + pri8 * ri6;
  rd7=pri2 * ri1 + pri5 * ri4 + pri8 * ri7;
  rd8=pri2 * ri2 + pri5 * ri5 + pri8 * ri8;
  angleChange[0]=(float)Math.atan2(rd1,rd4);
  angleChange[1]=(float)Math.asin(-rd7);
  angleChange[2]=(float)Math.atan2(-rd6,rd8);
}",0.971878994461014
181241,"/** 
 * Called when the application is stopping.  There are no more application objects running and the process will exit.  <em>Note: never depend on this method being called; in many cases an unneeded application process will simply be killed by the kernel without executing any application code.</em> If you override this method, be sure to call super.onTerminate().
 */
public void onTerminate(){
}","/** 
 * This method is for use in emulated process environments.  It will never be called on a production Android device, where processes are removed by simply killing them; no user code (including this callback) is executed when doing so.
 */
public void onTerminate(){
}",0.1693907875185735
181242,"/** 
 * Called when the application is stopping.  There are no more application objects running and the process will exit.  <em>Note: never depend on this method being called; in many cases an unneeded application process will simply be killed by the kernel without executing any application code.</em> If you override this method, be sure to call super.onTerminate().
 */
public void onTerminate(){
}","/** 
 * This method is for use in emulated process environments.  It will never be called on a production Android device, where processes are removed by simply killing them; no user code (including this callback) is executed when doing so.
 */
public void onTerminate(){
}",0.1693907875185735
181243,"/** 
 * Resolves the value of a resource, if the value references a theme or resource value. <p/> This method ensures that it returns a   {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return a new instance of IResourceValue that contains the input value.
 * @param type the type of the resource
 * @param name the name of the attribute containing this value.
 * @param value the resource value, or reference to resolve
 * @return the resolved resource value or <code>null</code> if it failed to resolve it.
 */
private IResourceValue resolveValue(String type,String name,String value){
  if (value == null) {
    return null;
  }
  IResourceValue resValue=findResValue(value);
  if (resValue == null) {
    return new ResourceValue(type,name,value);
  }
  return resolveResValue(resValue);
}","/** 
 * Resolves the value of a resource, if the value references a theme or resource value. <p/> This method ensures that it returns a   {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return a new instance of IResourceValue that contains the input value.
 * @param type the type of the resource
 * @param name the name of the attribute containing this value.
 * @param value the resource value, or reference to resolve
 * @return the resolved resource value or <code>null</code> if it failed to resolve it.
 */
private IResourceValue resolveValue(String type,String name,String value){
  if (value == null) {
    return null;
  }
  IResourceValue resValue=findResValue(value,false);
  if (resValue == null) {
    return new ResourceValue(type,name,value);
  }
  return resolveResValue(resValue);
}",0.9968782518210196
181244,"@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  BridgeXmlBlockParser parser=null;
  if (set instanceof BridgeXmlBlockParser) {
    parser=(BridgeXmlBlockParser)set;
  }
 else   if (set != null) {
    mLogger.error(""String_Node_Str"");
    return null;
  }
  boolean[] frameworkAttributes=new boolean[1];
  TreeMap<Integer,String> styleNameMap=searchAttrs(attrs,frameworkAttributes);
  BridgeTypedArray ta=((BridgeResources)mResources).newTypeArray(attrs.length,parser != null ? parser.isPlatformFile() : true);
  IStyleResourceValue defStyleValues=null;
  String customStyle=null;
  if (parser != null) {
    customStyle=parser.getAttributeValue(null,""String_Node_Str"");
  }
  if (customStyle != null) {
    IResourceValue item=findResValue(customStyle);
    if (item instanceof IStyleResourceValue) {
      defStyleValues=(IStyleResourceValue)item;
    }
  }
  if (defStyleValues == null && defStyleAttr != 0) {
    String defStyleName=searchAttr(defStyleAttr);
    if (mThemeValues != null) {
      IResourceValue item=findItemInStyle(mThemeValues,defStyleName);
      if (item != null) {
        item=findResValue(item.getValue());
        if (item instanceof IStyleResourceValue) {
          defStyleValues=(IStyleResourceValue)item;
        }
      }
 else {
        System.out.println(""String_Node_Str"" + defStyleName);
      }
    }
  }
  if (defStyleRes != 0) {
    throw new UnsupportedOperationException();
  }
  String namespace=BridgeConstants.NS_RESOURCES;
  if (frameworkAttributes[0] == false) {
    namespace=mProjectCallback.getNamespace();
  }
  if (styleNameMap != null) {
    for (    Entry<Integer,String> styleAttribute : styleNameMap.entrySet()) {
      int index=styleAttribute.getKey().intValue();
      String name=styleAttribute.getValue();
      String value=null;
      if (parser != null) {
        value=parser.getAttributeValue(namespace,name);
      }
      if (value == null) {
        IResourceValue resValue=null;
        if (defStyleValues != null) {
          resValue=findItemInStyle(defStyleValues,name);
        }
        if (resValue == null && mThemeValues != null) {
          resValue=findItemInStyle(mThemeValues,name);
        }
        if (resValue != null) {
          resValue=resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,name,resValue);
      }
 else {
        ta.bridgeSetValue(index,name,resolveValue(null,name,value));
      }
    }
  }
  ta.sealArray();
  return ta;
}","@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  BridgeXmlBlockParser parser=null;
  if (set instanceof BridgeXmlBlockParser) {
    parser=(BridgeXmlBlockParser)set;
  }
 else   if (set != null) {
    mLogger.error(""String_Node_Str"");
    return null;
  }
  boolean[] frameworkAttributes=new boolean[1];
  TreeMap<Integer,String> styleNameMap=searchAttrs(attrs,frameworkAttributes);
  BridgeTypedArray ta=((BridgeResources)mResources).newTypeArray(attrs.length,parser != null ? parser.isPlatformFile() : true);
  IStyleResourceValue defStyleValues=null;
  String customStyle=null;
  if (parser != null) {
    customStyle=parser.getAttributeValue(null,""String_Node_Str"");
  }
  if (customStyle != null) {
    IResourceValue item=findResValue(customStyle,false);
    if (item instanceof IStyleResourceValue) {
      defStyleValues=(IStyleResourceValue)item;
    }
  }
  if (defStyleValues == null && defStyleAttr != 0) {
    String defStyleName=searchAttr(defStyleAttr);
    if (mThemeValues != null) {
      IResourceValue item=findItemInStyle(mThemeValues,defStyleName);
      if (item != null) {
        item=findResValue(item.getValue(),false);
        if (item instanceof IStyleResourceValue) {
          defStyleValues=(IStyleResourceValue)item;
        }
      }
 else {
        System.out.println(""String_Node_Str"" + defStyleName);
      }
    }
  }
  if (defStyleRes != 0) {
    throw new UnsupportedOperationException();
  }
  String namespace=BridgeConstants.NS_RESOURCES;
  if (frameworkAttributes[0] == false) {
    namespace=mProjectCallback.getNamespace();
  }
  if (styleNameMap != null) {
    for (    Entry<Integer,String> styleAttribute : styleNameMap.entrySet()) {
      int index=styleAttribute.getKey().intValue();
      String name=styleAttribute.getValue();
      String value=null;
      if (parser != null) {
        value=parser.getAttributeValue(namespace,name);
      }
      if (value == null) {
        IResourceValue resValue=null;
        if (defStyleValues != null) {
          resValue=findItemInStyle(defStyleValues,name);
        }
        if (resValue == null && mThemeValues != null) {
          resValue=findItemInStyle(mThemeValues,name);
        }
        if (resValue != null) {
          resValue=resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,name,resValue);
      }
 else {
        ta.bridgeSetValue(index,name,resolveValue(null,name,value));
      }
    }
  }
  ta.sealArray();
  return ta;
}",0.9976199920666402
181245,"/** 
 * Returns the   {@link IResourceValue} referenced by the value of <var>value</var>.<p/> This method ensures that it returns a  {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return the input value.
 * @param value the value containing the reference to resolve.
 * @return a {@link IResourceValue} object or <code>null</code>
 */
IResourceValue resolveResValue(IResourceValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof IStyleResourceValue) {
    return value;
  }
  IResourceValue resolvedValue=findResValue(value.getValue());
  if (resolvedValue == null) {
    return value;
  }
  return resolveResValue(resolvedValue);
}","/** 
 * Returns the   {@link IResourceValue} referenced by the value of <var>value</var>.<p/> This method ensures that it returns a  {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return the input value.
 * @param value the value containing the reference to resolve.
 * @return a {@link IResourceValue} object or <code>null</code>
 */
IResourceValue resolveResValue(IResourceValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof IStyleResourceValue) {
    return value;
  }
  IResourceValue resolvedValue=findResValue(value.getValue(),value.isFramework());
  if (resolvedValue == null) {
    return value;
  }
  return resolveResValue(resolvedValue);
}",0.9880239520958084
181246,"private int resolveResourceValue(String value,int defaultValue){
  IResourceValue resource=mContext.resolveResValue(mContext.findResValue(value));
  if (resource != null) {
    Integer id=null;
    if (mPlatformFile || resource.isFramework()) {
      id=Bridge.getResourceValue(resource.getType(),resource.getName());
    }
 else {
      id=mContext.getProjectCallback().getResourceValue(resource.getType(),resource.getName());
    }
    if (id != null) {
      return id;
    }
  }
  return defaultValue;
}","private int resolveResourceValue(String value,int defaultValue){
  IResourceValue resource=mContext.resolveResValue(mContext.findResValue(value,mPlatformFile));
  if (resource != null) {
    Integer id=null;
    if (mPlatformFile || resource.isFramework()) {
      id=Bridge.getResourceValue(resource.getType(),resource.getName());
    }
 else {
      id=mContext.getProjectCallback().getResourceValue(resource.getType(),resource.getName());
    }
    if (id != null) {
      return id;
    }
  }
  return defaultValue;
}",0.9863813229571984
181247,"/** 
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,or an hexadecimal color
 * @param context
 * @param isFramework indicates whether the resource is a framework resources.Framework resources are cached, and loaded only once.
 */
public static Drawable getDrawable(IResourceValue value,BridgeContext context,boolean isFramework){
  Drawable d=null;
  String stringValue=value.getValue();
  String lowerCaseValue=stringValue.toLowerCase();
  if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
    File file=new File(stringValue);
    if (file.isFile()) {
      NinePatch ninePatch=Bridge.getCached9Patch(stringValue,isFramework ? null : context.getProjectKey());
      if (ninePatch == null) {
        try {
          ninePatch=NinePatch.load(file.toURL(),false);
          Bridge.setCached9Patch(stringValue,ninePatch,isFramework ? null : context.getProjectKey());
        }
 catch (        MalformedURLException e) {
        }
catch (        IOException e) {
        }
      }
      if (ninePatch != null) {
        return new NinePatchDrawable(ninePatch);
      }
    }
    return null;
  }
 else   if (lowerCaseValue.endsWith(""String_Node_Str"")) {
    File f=new File(stringValue);
    if (f.isFile()) {
      try {
        KXmlParser parser=new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,true);
        parser.setInput(new FileReader(f));
        d=Drawable.createFromXml(context.getResources(),new BridgeXmlBlockParser(parser,context,false));
        return d;
      }
 catch (      XmlPullParserException e) {
        context.getLogger().error(e);
      }
catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
        context.getLogger().error(e);
      }
    }
    return null;
  }
 else {
    File bmpFile=new File(stringValue);
    if (bmpFile.isFile()) {
      try {
        Bitmap bitmap=Bridge.getCachedBitmap(stringValue,isFramework ? null : context.getProjectKey());
        if (bitmap == null) {
          bitmap=new Bitmap(bmpFile);
          try {
            bitmap.setDensity(Density.MEDIUM.getValue());
          }
 catch (          NoClassDefFoundError error) {
          }
          Bridge.setCachedBitmap(stringValue,bitmap,isFramework ? null : context.getProjectKey());
        }
        try {
          if (value instanceof IDensityBasedResourceValue) {
            Density density=((IDensityBasedResourceValue)value).getDensity();
            if (density != Density.MEDIUM) {
              bitmap=Bitmap.createBitmap(bitmap);
              bitmap.setDensity(density.getValue());
            }
          }
        }
 catch (        NoClassDefFoundError error) {
        }
        return new BitmapDrawable(context.getResources(),bitmap);
      }
 catch (      IOException e) {
      }
    }
 else {
      try {
        int color=getColor(stringValue);
        return new ColorDrawable(color);
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return null;
}","/** 
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,or an hexadecimal color
 * @param context
 * @param isFramework indicates whether the resource is a framework resources.Framework resources are cached, and loaded only once.
 */
public static Drawable getDrawable(IResourceValue value,BridgeContext context,boolean isFramework){
  Drawable d=null;
  String stringValue=value.getValue();
  String lowerCaseValue=stringValue.toLowerCase();
  if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
    File file=new File(stringValue);
    if (file.isFile()) {
      NinePatch ninePatch=Bridge.getCached9Patch(stringValue,isFramework ? null : context.getProjectKey());
      if (ninePatch == null) {
        try {
          ninePatch=NinePatch.load(file.toURL(),false);
          Bridge.setCached9Patch(stringValue,ninePatch,isFramework ? null : context.getProjectKey());
        }
 catch (        MalformedURLException e) {
        }
catch (        IOException e) {
        }
      }
      if (ninePatch != null) {
        return new NinePatchDrawable(ninePatch);
      }
    }
    return null;
  }
 else   if (lowerCaseValue.endsWith(""String_Node_Str"")) {
    File f=new File(stringValue);
    if (f.isFile()) {
      try {
        KXmlParser parser=new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,true);
        parser.setInput(new FileReader(f));
        d=Drawable.createFromXml(context.getResources(),new BridgeXmlBlockParser(parser,context,isFramework));
        return d;
      }
 catch (      XmlPullParserException e) {
        context.getLogger().error(e);
      }
catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
        context.getLogger().error(e);
      }
    }
    return null;
  }
 else {
    File bmpFile=new File(stringValue);
    if (bmpFile.isFile()) {
      try {
        Bitmap bitmap=Bridge.getCachedBitmap(stringValue,isFramework ? null : context.getProjectKey());
        if (bitmap == null) {
          bitmap=new Bitmap(bmpFile);
          try {
            bitmap.setDensity(Density.MEDIUM.getValue());
          }
 catch (          NoClassDefFoundError error) {
          }
          Bridge.setCachedBitmap(stringValue,bitmap,isFramework ? null : context.getProjectKey());
        }
        try {
          if (value instanceof IDensityBasedResourceValue) {
            Density density=((IDensityBasedResourceValue)value).getDensity();
            if (density != Density.MEDIUM) {
              bitmap=Bitmap.createBitmap(bitmap);
              bitmap.setDensity(density.getValue());
            }
          }
        }
 catch (        NoClassDefFoundError error) {
        }
        return new BitmapDrawable(context.getResources(),bitmap);
      }
 catch (      IOException e) {
      }
    }
 else {
      try {
        int color=getColor(stringValue);
        return new ColorDrawable(color);
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return null;
}",0.997389885807504
181248,"/** 
 * Resolves the value of a resource, if the value references a theme or resource value. <p/> This method ensures that it returns a   {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return a new instance of IResourceValue that contains the input value.
 * @param type the type of the resource
 * @param name the name of the attribute containing this value.
 * @param value the resource value, or reference to resolve
 * @return the resolved resource value or <code>null</code> if it failed to resolve it.
 */
private IResourceValue resolveValue(String type,String name,String value){
  if (value == null) {
    return null;
  }
  IResourceValue resValue=findResValue(value);
  if (resValue == null) {
    return new ResourceValue(type,name,value);
  }
  return resolveResValue(resValue);
}","/** 
 * Resolves the value of a resource, if the value references a theme or resource value. <p/> This method ensures that it returns a   {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return a new instance of IResourceValue that contains the input value.
 * @param type the type of the resource
 * @param name the name of the attribute containing this value.
 * @param value the resource value, or reference to resolve
 * @return the resolved resource value or <code>null</code> if it failed to resolve it.
 */
private IResourceValue resolveValue(String type,String name,String value){
  if (value == null) {
    return null;
  }
  IResourceValue resValue=findResValue(value,false);
  if (resValue == null) {
    return new ResourceValue(type,name,value);
  }
  return resolveResValue(resValue);
}",0.9968782518210196
181249,"@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  BridgeXmlBlockParser parser=null;
  if (set instanceof BridgeXmlBlockParser) {
    parser=(BridgeXmlBlockParser)set;
  }
 else   if (set != null) {
    mLogger.error(""String_Node_Str"");
    return null;
  }
  boolean[] frameworkAttributes=new boolean[1];
  TreeMap<Integer,String> styleNameMap=searchAttrs(attrs,frameworkAttributes);
  BridgeTypedArray ta=((BridgeResources)mResources).newTypeArray(attrs.length,parser != null ? parser.isPlatformFile() : true);
  IStyleResourceValue defStyleValues=null;
  String customStyle=null;
  if (parser != null) {
    customStyle=parser.getAttributeValue(null,""String_Node_Str"");
  }
  if (customStyle != null) {
    IResourceValue item=findResValue(customStyle);
    if (item instanceof IStyleResourceValue) {
      defStyleValues=(IStyleResourceValue)item;
    }
  }
  if (defStyleValues == null && defStyleAttr != 0) {
    String defStyleName=searchAttr(defStyleAttr);
    if (mThemeValues != null) {
      IResourceValue item=findItemInStyle(mThemeValues,defStyleName);
      if (item != null) {
        item=findResValue(item.getValue());
        if (item instanceof IStyleResourceValue) {
          defStyleValues=(IStyleResourceValue)item;
        }
      }
 else {
        System.out.println(""String_Node_Str"" + defStyleName);
      }
    }
  }
  if (defStyleRes != 0) {
    throw new UnsupportedOperationException();
  }
  String namespace=BridgeConstants.NS_RESOURCES;
  if (frameworkAttributes[0] == false) {
    namespace=mProjectCallback.getNamespace();
  }
  if (styleNameMap != null) {
    for (    Entry<Integer,String> styleAttribute : styleNameMap.entrySet()) {
      int index=styleAttribute.getKey().intValue();
      String name=styleAttribute.getValue();
      String value=null;
      if (parser != null) {
        value=parser.getAttributeValue(namespace,name);
      }
      if (value == null) {
        IResourceValue resValue=null;
        if (defStyleValues != null) {
          resValue=findItemInStyle(defStyleValues,name);
        }
        if (resValue == null && mThemeValues != null) {
          resValue=findItemInStyle(mThemeValues,name);
        }
        if (resValue != null) {
          resValue=resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,name,resValue);
      }
 else {
        ta.bridgeSetValue(index,name,resolveValue(null,name,value));
      }
    }
  }
  ta.sealArray();
  return ta;
}","@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  BridgeXmlBlockParser parser=null;
  if (set instanceof BridgeXmlBlockParser) {
    parser=(BridgeXmlBlockParser)set;
  }
 else   if (set != null) {
    mLogger.error(""String_Node_Str"");
    return null;
  }
  boolean[] frameworkAttributes=new boolean[1];
  TreeMap<Integer,String> styleNameMap=searchAttrs(attrs,frameworkAttributes);
  BridgeTypedArray ta=((BridgeResources)mResources).newTypeArray(attrs.length,parser != null ? parser.isPlatformFile() : true);
  IStyleResourceValue defStyleValues=null;
  String customStyle=null;
  if (parser != null) {
    customStyle=parser.getAttributeValue(null,""String_Node_Str"");
  }
  if (customStyle != null) {
    IResourceValue item=findResValue(customStyle,false);
    if (item instanceof IStyleResourceValue) {
      defStyleValues=(IStyleResourceValue)item;
    }
  }
  if (defStyleValues == null && defStyleAttr != 0) {
    String defStyleName=searchAttr(defStyleAttr);
    if (mThemeValues != null) {
      IResourceValue item=findItemInStyle(mThemeValues,defStyleName);
      if (item != null) {
        item=findResValue(item.getValue(),false);
        if (item instanceof IStyleResourceValue) {
          defStyleValues=(IStyleResourceValue)item;
        }
      }
 else {
        System.out.println(""String_Node_Str"" + defStyleName);
      }
    }
  }
  if (defStyleRes != 0) {
    throw new UnsupportedOperationException();
  }
  String namespace=BridgeConstants.NS_RESOURCES;
  if (frameworkAttributes[0] == false) {
    namespace=mProjectCallback.getNamespace();
  }
  if (styleNameMap != null) {
    for (    Entry<Integer,String> styleAttribute : styleNameMap.entrySet()) {
      int index=styleAttribute.getKey().intValue();
      String name=styleAttribute.getValue();
      String value=null;
      if (parser != null) {
        value=parser.getAttributeValue(namespace,name);
      }
      if (value == null) {
        IResourceValue resValue=null;
        if (defStyleValues != null) {
          resValue=findItemInStyle(defStyleValues,name);
        }
        if (resValue == null && mThemeValues != null) {
          resValue=findItemInStyle(mThemeValues,name);
        }
        if (resValue != null) {
          resValue=resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,name,resValue);
      }
 else {
        ta.bridgeSetValue(index,name,resolveValue(null,name,value));
      }
    }
  }
  ta.sealArray();
  return ta;
}",0.9976199920666402
181250,"/** 
 * Returns the   {@link IResourceValue} referenced by the value of <var>value</var>.<p/> This method ensures that it returns a  {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return the input value.
 * @param value the value containing the reference to resolve.
 * @return a {@link IResourceValue} object or <code>null</code>
 */
IResourceValue resolveResValue(IResourceValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof IStyleResourceValue) {
    return value;
  }
  IResourceValue resolvedValue=findResValue(value.getValue());
  if (resolvedValue == null) {
    return value;
  }
  return resolveResValue(resolvedValue);
}","/** 
 * Returns the   {@link IResourceValue} referenced by the value of <var>value</var>.<p/> This method ensures that it returns a  {@link IResourceValue} object that does notreference another resource. If the resource cannot be resolved, it returns <code>null</code>. <p/> If a value that does not need to be resolved is given, the method will return the input value.
 * @param value the value containing the reference to resolve.
 * @return a {@link IResourceValue} object or <code>null</code>
 */
IResourceValue resolveResValue(IResourceValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof IStyleResourceValue) {
    return value;
  }
  IResourceValue resolvedValue=findResValue(value.getValue(),value.isFramework());
  if (resolvedValue == null) {
    return value;
  }
  return resolveResValue(resolvedValue);
}",0.9880239520958084
181251,"private int resolveResourceValue(String value,int defaultValue){
  IResourceValue resource=mContext.resolveResValue(mContext.findResValue(value));
  if (resource != null) {
    Integer id=null;
    if (mPlatformFile || resource.isFramework()) {
      id=Bridge.getResourceValue(resource.getType(),resource.getName());
    }
 else {
      id=mContext.getProjectCallback().getResourceValue(resource.getType(),resource.getName());
    }
    if (id != null) {
      return id;
    }
  }
  return defaultValue;
}","private int resolveResourceValue(String value,int defaultValue){
  IResourceValue resource=mContext.resolveResValue(mContext.findResValue(value,mPlatformFile));
  if (resource != null) {
    Integer id=null;
    if (mPlatformFile || resource.isFramework()) {
      id=Bridge.getResourceValue(resource.getType(),resource.getName());
    }
 else {
      id=mContext.getProjectCallback().getResourceValue(resource.getType(),resource.getName());
    }
    if (id != null) {
      return id;
    }
  }
  return defaultValue;
}",0.9863813229571984
181252,"/** 
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,or an hexadecimal color
 * @param context
 * @param isFramework indicates whether the resource is a framework resources.Framework resources are cached, and loaded only once.
 */
public static Drawable getDrawable(IResourceValue value,BridgeContext context,boolean isFramework){
  Drawable d=null;
  String stringValue=value.getValue();
  String lowerCaseValue=stringValue.toLowerCase();
  if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
    File file=new File(stringValue);
    if (file.isFile()) {
      NinePatch ninePatch=Bridge.getCached9Patch(stringValue,isFramework ? null : context.getProjectKey());
      if (ninePatch == null) {
        try {
          ninePatch=NinePatch.load(file.toURL(),false);
          Bridge.setCached9Patch(stringValue,ninePatch,isFramework ? null : context.getProjectKey());
        }
 catch (        MalformedURLException e) {
        }
catch (        IOException e) {
        }
      }
      if (ninePatch != null) {
        return new NinePatchDrawable(ninePatch);
      }
    }
    return null;
  }
 else   if (lowerCaseValue.endsWith(""String_Node_Str"")) {
    File f=new File(stringValue);
    if (f.isFile()) {
      try {
        KXmlParser parser=new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,true);
        parser.setInput(new FileReader(f));
        d=Drawable.createFromXml(context.getResources(),new BridgeXmlBlockParser(parser,context,false));
        return d;
      }
 catch (      XmlPullParserException e) {
        context.getLogger().error(e);
      }
catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
        context.getLogger().error(e);
      }
    }
    return null;
  }
 else {
    File bmpFile=new File(stringValue);
    if (bmpFile.isFile()) {
      try {
        Bitmap bitmap=Bridge.getCachedBitmap(stringValue,isFramework ? null : context.getProjectKey());
        if (bitmap == null) {
          bitmap=new Bitmap(bmpFile);
          try {
            bitmap.setDensity(Density.MEDIUM.getValue());
          }
 catch (          NoClassDefFoundError error) {
          }
          Bridge.setCachedBitmap(stringValue,bitmap,isFramework ? null : context.getProjectKey());
        }
        try {
          if (value instanceof IDensityBasedResourceValue) {
            Density density=((IDensityBasedResourceValue)value).getDensity();
            if (density != Density.MEDIUM) {
              bitmap=Bitmap.createBitmap(bitmap);
              bitmap.setDensity(density.getValue());
            }
          }
        }
 catch (        NoClassDefFoundError error) {
        }
        return new BitmapDrawable(context.getResources(),bitmap);
      }
 catch (      IOException e) {
      }
    }
 else {
      try {
        int color=getColor(stringValue);
        return new ColorDrawable(color);
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return null;
}","/** 
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,or an hexadecimal color
 * @param context
 * @param isFramework indicates whether the resource is a framework resources.Framework resources are cached, and loaded only once.
 */
public static Drawable getDrawable(IResourceValue value,BridgeContext context,boolean isFramework){
  Drawable d=null;
  String stringValue=value.getValue();
  String lowerCaseValue=stringValue.toLowerCase();
  if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
    File file=new File(stringValue);
    if (file.isFile()) {
      NinePatch ninePatch=Bridge.getCached9Patch(stringValue,isFramework ? null : context.getProjectKey());
      if (ninePatch == null) {
        try {
          ninePatch=NinePatch.load(file.toURL(),false);
          Bridge.setCached9Patch(stringValue,ninePatch,isFramework ? null : context.getProjectKey());
        }
 catch (        MalformedURLException e) {
        }
catch (        IOException e) {
        }
      }
      if (ninePatch != null) {
        return new NinePatchDrawable(ninePatch);
      }
    }
    return null;
  }
 else   if (lowerCaseValue.endsWith(""String_Node_Str"")) {
    File f=new File(stringValue);
    if (f.isFile()) {
      try {
        KXmlParser parser=new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,true);
        parser.setInput(new FileReader(f));
        d=Drawable.createFromXml(context.getResources(),new BridgeXmlBlockParser(parser,context,isFramework));
        return d;
      }
 catch (      XmlPullParserException e) {
        context.getLogger().error(e);
      }
catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
        context.getLogger().error(e);
      }
    }
    return null;
  }
 else {
    File bmpFile=new File(stringValue);
    if (bmpFile.isFile()) {
      try {
        Bitmap bitmap=Bridge.getCachedBitmap(stringValue,isFramework ? null : context.getProjectKey());
        if (bitmap == null) {
          bitmap=new Bitmap(bmpFile);
          try {
            bitmap.setDensity(Density.MEDIUM.getValue());
          }
 catch (          NoClassDefFoundError error) {
          }
          Bridge.setCachedBitmap(stringValue,bitmap,isFramework ? null : context.getProjectKey());
        }
        try {
          if (value instanceof IDensityBasedResourceValue) {
            Density density=((IDensityBasedResourceValue)value).getDensity();
            if (density != Density.MEDIUM) {
              bitmap=Bitmap.createBitmap(bitmap);
              bitmap.setDensity(density.getValue());
            }
          }
        }
 catch (        NoClassDefFoundError error) {
        }
        return new BitmapDrawable(context.getResources(),bitmap);
      }
 catch (      IOException e) {
      }
    }
 else {
      try {
        int color=getColor(stringValue);
        return new ColorDrawable(color);
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return null;
}",0.997389885807504
181253,"/** 
 * Called as part of the activity lifecycle when an activity is going into the background, but has not (yet) been killed.  The counterpart to  {@link #onResume}. <p>When activity B is launched in front of activity A, this callback will be invoked on A.  B will not be created until A's   {@link #onPause} returns,so be sure to not do anything lengthy here. <p>This callback is mostly used for saving any persistent state the activity is editing, to present a ""edit in place"" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one.  This is also a good place to do things like stop animations and other things that consume a noticeable mount of CPU in order to make the switch to the next activity as fast as possible, or to close resources that are exclusive access such as the camera. <p>In situations where the system needs more memory it may kill paused processes to reclaim resources.  Because of this, you should be sure that all of your state is saved by the time you return from this function.  In general  {@link #onSaveInstanceState} is used to saveper-instance state in the activity and this method is used to store global persistent data (in content providers, files, etc.) <p>After receiving this call you will usually receive a following call to  {@link #onStop} (after the next activity has been resumed anddisplayed), however in some cases there will be a direct call back to {@link #onResume} without going through the stopped state.<p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onResume
 * @see #onSaveInstanceState
 * @see #onStop
 */
protected void onPause(){
  mCalled=true;
  QueuedWork.waitToFinish();
}","/** 
 * Called as part of the activity lifecycle when an activity is going into the background, but has not (yet) been killed.  The counterpart to  {@link #onResume}. <p>When activity B is launched in front of activity A, this callback will be invoked on A.  B will not be created until A's   {@link #onPause} returns,so be sure to not do anything lengthy here. <p>This callback is mostly used for saving any persistent state the activity is editing, to present a ""edit in place"" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one.  This is also a good place to do things like stop animations and other things that consume a noticeable mount of CPU in order to make the switch to the next activity as fast as possible, or to close resources that are exclusive access such as the camera. <p>In situations where the system needs more memory it may kill paused processes to reclaim resources.  Because of this, you should be sure that all of your state is saved by the time you return from this function.  In general  {@link #onSaveInstanceState} is used to saveper-instance state in the activity and this method is used to store global persistent data (in content providers, files, etc.) <p>After receiving this call you will usually receive a following call to  {@link #onStop} (after the next activity has been resumed anddisplayed), however in some cases there will be a direct call back to {@link #onResume} without going through the stopped state.<p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onResume
 * @see #onSaveInstanceState
 * @see #onStop
 */
protected void onPause(){
  mCalled=true;
}",0.992
181254,"private final void handlePauseActivity(IBinder token,boolean finished,boolean userLeaving,int configChanges){
  ActivityClientRecord r=mActivities.get(token);
  if (r != null) {
    if (userLeaving) {
      performUserLeavingActivity(r);
    }
    r.activity.mConfigChangeFlags|=configChanges;
    Bundle state=performPauseActivity(token,finished,true);
    try {
      ActivityManagerNative.getDefault().activityPaused(token,state);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handlePauseActivity(IBinder token,boolean finished,boolean userLeaving,int configChanges){
  ActivityClientRecord r=mActivities.get(token);
  if (r != null) {
    if (userLeaving) {
      performUserLeavingActivity(r);
    }
    r.activity.mConfigChangeFlags|=configChanges;
    Bundle state=performPauseActivity(token,finished,true);
    QueuedWork.waitToFinish();
    try {
      ActivityManagerNative.getDefault().activityPaused(token,state);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.9690309690309692
181255,"public void setAudioMode(){
  Context context=getContext();
  if (context == null)   return;
  AudioManager audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  int mode=AudioManager.MODE_NORMAL;
switch (getState()) {
case RINGING:
    mode=AudioManager.MODE_RINGTONE;
  break;
case OFFHOOK:
Phone fgPhone=getFgPhone();
if (!(fgPhone instanceof SipPhone)) {
mode=AudioManager.MODE_IN_CALL;
}
break;
}
if (audioManager.getMode() != mode) audioManager.setMode(mode);
}","public void setAudioMode(){
  Context context=getContext();
  if (context == null)   return;
  AudioManager audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  int mode=AudioManager.MODE_NORMAL;
switch (getState()) {
case RINGING:
    mode=AudioManager.MODE_RINGTONE;
  break;
case OFFHOOK:
Phone fgPhone=getFgPhone();
if (hasActiveFgCall() && !(fgPhone instanceof SipPhone)) {
mode=AudioManager.MODE_IN_CALL;
}
break;
}
if (audioManager.getMode() != mode) audioManager.setMode(mode);
}",0.979062811565304
181256,"public void setAudioMode(){
  Context context=getContext();
  if (context == null)   return;
  AudioManager audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  int mode=AudioManager.MODE_NORMAL;
switch (getState()) {
case RINGING:
    mode=AudioManager.MODE_RINGTONE;
  break;
case OFFHOOK:
Phone fgPhone=getFgPhone();
if (!(fgPhone instanceof SipPhone)) {
mode=AudioManager.MODE_IN_CALL;
}
break;
}
if (audioManager.getMode() != mode) audioManager.setMode(mode);
}","public void setAudioMode(){
  Context context=getContext();
  if (context == null)   return;
  AudioManager audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  int mode=AudioManager.MODE_NORMAL;
switch (getState()) {
case RINGING:
    mode=AudioManager.MODE_RINGTONE;
  break;
case OFFHOOK:
Phone fgPhone=getFgPhone();
if (hasActiveFgCall() && !(fgPhone instanceof SipPhone)) {
mode=AudioManager.MODE_IN_CALL;
}
break;
}
if (audioManager.getMode() != mode) audioManager.setMode(mode);
}",0.979062811565304
181257,"/** 
 * {@inheritDoc}
 */
public void onClick(DialogInterface dialog,int which){
  if (which == POSITIVE_BUTTON) {
    IMountService mountService=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (mountService != null) {
      try {
        mountService.formatVolume(Environment.getExternalStorageDirectory().toString());
      }
 catch (      RemoteException e) {
      }
    }
  }
  finish();
}","/** 
 * {@inheritDoc}
 */
public void onClick(DialogInterface dialog,int which){
  if (which == POSITIVE_BUTTON) {
    Intent intent=new Intent(ExternalStorageFormatter.FORMAT_ONLY);
    intent.setComponent(ExternalStorageFormatter.COMPONENT_NAME);
    startService(intent);
  }
  finish();
}",0.3623789764868603
181258,"/** 
 * {@inheritDoc}
 */
public void onClick(DialogInterface dialog,int which){
  if (which == POSITIVE_BUTTON) {
    IMountService mountService=IMountService.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (mountService != null) {
      try {
        mountService.formatVolume(Environment.getExternalStorageDirectory().toString());
      }
 catch (      RemoteException e) {
      }
    }
  }
  finish();
}","/** 
 * {@inheritDoc}
 */
public void onClick(DialogInterface dialog,int which){
  if (which == POSITIVE_BUTTON) {
    Intent intent=new Intent(ExternalStorageFormatter.FORMAT_ONLY);
    intent.setComponent(ExternalStorageFormatter.COMPONENT_NAME);
    startService(intent);
  }
  finish();
}",0.3623789764868603
181259,"@Override protected void onCreate(Bundle savedInstanceState){
  String libname=""String_Node_Str"";
  ActivityInfo ai;
  mIMM=(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
  mInputMethodCallback=new InputMethodCallback(this);
  getWindow().takeSurface(this);
  getWindow().takeInputQueue(this);
  getWindow().setFormat(PixelFormat.RGB_565);
  getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
  mNativeContentView=new NativeContentView(this);
  mNativeContentView.mActivity=this;
  setContentView(mNativeContentView);
  mNativeContentView.requestFocus();
  mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
  try {
    ai=getPackageManager().getActivityInfo(getIntent().getComponent(),PackageManager.GET_META_DATA);
    if (ai.metaData != null) {
      String ln=ai.metaData.getString(META_DATA_LIB_NAME);
      if (ln != null)       libname=ln;
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  String path=null;
  if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_HAS_CODE) == 0) {
    File libraryFile=new File(ai.applicationInfo.nativeLibraryDir,System.mapLibraryName(libname));
    if (libraryFile.exists()) {
      path=libraryFile.getPath();
    }
  }
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + libname);
  }
  byte[] nativeSavedState=savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
  mNativeHandle=loadNativeCode(path,Looper.myQueue(),getFilesDir().toString(),Environment.getExternalStorageAppFilesDirectory(ai.packageName).toString(),Build.VERSION.SDK_INT,getAssets(),nativeSavedState);
  if (mNativeHandle == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + path);
  }
  super.onCreate(savedInstanceState);
}","@Override protected void onCreate(Bundle savedInstanceState){
  String libname=""String_Node_Str"";
  ActivityInfo ai;
  mIMM=(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
  mInputMethodCallback=new InputMethodCallback(this);
  getWindow().takeSurface(this);
  getWindow().takeInputQueue(this);
  getWindow().setFormat(PixelFormat.RGB_565);
  getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
  mNativeContentView=new NativeContentView(this);
  mNativeContentView.mActivity=this;
  setContentView(mNativeContentView);
  mNativeContentView.requestFocus();
  mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
  try {
    ai=getPackageManager().getActivityInfo(getIntent().getComponent(),PackageManager.GET_META_DATA);
    if (ai.metaData != null) {
      String ln=ai.metaData.getString(META_DATA_LIB_NAME);
      if (ln != null)       libname=ln;
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  String path=null;
  File libraryFile=new File(ai.applicationInfo.nativeLibraryDir,System.mapLibraryName(libname));
  if (libraryFile.exists()) {
    path=libraryFile.getPath();
  }
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + libname);
  }
  byte[] nativeSavedState=savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
  mNativeHandle=loadNativeCode(path,Looper.myQueue(),getFilesDir().toString(),Environment.getExternalStorageAppFilesDirectory(ai.packageName).toString(),Build.VERSION.SDK_INT,getAssets(),nativeSavedState);
  if (mNativeHandle == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + path);
  }
  super.onCreate(savedInstanceState);
}",0.9774236387782204
181260,"void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    Message m=mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
    m.arg1=onBattery ? 1 : 0;
    mHandler.sendMessage(m);
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeAsyncLocked();
      }
    }
  }
}","void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    Message m=mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
    m.arg1=onBattery ? 1 : 0;
    mHandler.sendMessage(m);
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 95 || (mDischargeCurrentLevel < 30 && level >= 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeAsyncLocked();
      }
    }
  }
}",0.9982631350412504
181261,"void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    Message m=mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
    m.arg1=onBattery ? 1 : 0;
    mHandler.sendMessage(m);
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeAsyncLocked();
      }
    }
  }
}","void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    Message m=mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
    m.arg1=onBattery ? 1 : 0;
    mHandler.sendMessage(m);
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 95 || (mDischargeCurrentLevel < 30 && level >= 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeAsyncLocked();
      }
    }
  }
}",0.9982631350412504
181262,"private void doDrag(int deltaX,int deltaY){
  if ((deltaX | deltaY) != 0) {
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int rangeX=computeMaxScrollX();
    final int rangeY=computeMaxScrollY();
    if (mEdgeGlowTop != null) {
      mOverscrollDeltaX=deltaX;
      mOverscrollDeltaY=deltaY;
    }
    overScrollBy(deltaX,deltaY,oldX,oldY,rangeX,rangeY,mOverscrollDistance,mOverscrollDistance,true);
  }
  if (!getSettings().getBuiltInZoomControls()) {
    boolean showPlusMinus=mMinZoomScale < mMaxZoomScale;
    if (mZoomControls != null && showPlusMinus) {
      if (mZoomControls.getVisibility() == View.VISIBLE) {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
      }
 else {
        mZoomControls.show(showPlusMinus,false);
      }
      mPrivateHandler.postDelayed(mZoomControlRunnable,ZOOM_CONTROLS_TIMEOUT);
    }
  }
}","private void doDrag(int deltaX,int deltaY){
  if ((deltaX | deltaY) != 0) {
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int rangeX=computeMaxScrollX();
    final int rangeY=computeMaxScrollY();
    if (mEdgeGlowTop != null) {
      mOverscrollDeltaX=deltaX;
      mOverscrollDeltaY=deltaY;
    }
    overScrollBy(deltaX,deltaY,oldX,oldY,rangeX,rangeY,mOverscrollDistance,mOverscrollDistance,true);
    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished() || !mEdgeGlowLeft.isFinished()|| !mEdgeGlowRight.isFinished())) {
      invalidate();
    }
  }
  if (!getSettings().getBuiltInZoomControls()) {
    boolean showPlusMinus=mMinZoomScale < mMaxZoomScale;
    if (mZoomControls != null && showPlusMinus) {
      if (mZoomControls.getVisibility() == View.VISIBLE) {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
      }
 else {
        mZoomControls.show(showPlusMinus,false);
      }
      mPrivateHandler.postDelayed(mZoomControlRunnable,ZOOM_CONTROLS_TIMEOUT);
    }
  }
}",0.9035956227201668
181263,"/** 
 * Sets the rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If appplications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.mOrientation is the angle between camera orientation and natural device orientation. The sum of the two is the angle for rotation. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose the camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). The reference code is as follows. public void public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; mParameters.setRotation((orientation + info.mOrientation) % 360); }
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}","/** 
 * Sets the rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If applications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum or of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). The reference code is as follows. public void public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); }
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}",0.8914285714285715
181264,"/** 
 * Set the display orientation. This affects the preview frames and the picture displayed after snapshot. This method is useful for portrait mode applications. This does not affect the order of byte array passed in  {@link PreviewCallback#onPreviewFrame}. This method is not allowed to be called during preview. If you want to make the camera image show in the same orientation as the display, you can use the following code.<p> <pre> public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) { android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result = (info.orientation - degrees + 360) % 360; camera.setDisplayOrientation(result); } </pre>
 * @param degrees the angle that the picture will be rotated clockwise.Valid values are 0, 90, 180, and 270. The starting position is 0 (landscape).
 */
public native final void setDisplayOrientation(int degrees);","/** 
 * Set the clockwise rotation of preview display in degrees. This affects the preview frames and the picture displayed after snapshot. This method is useful for portrait mode applications. Note that preview display of front-facing cameras is flipped horizontally, that is, the image is reflected along the central vertical axis of the camera sensor. So the users can see themselves as looking into a mirror. This does not affect the order of byte array passed in   {@link PreviewCallback#onPreviewFrame}, JPEG pictures, or recorded videos. This method is not allowed to be called during preview. If you want to make the camera image show in the same orientation as the display, you can use the following code.<p> <pre> public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) { android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360;  // compensate the mirror } else {  // back-facing result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result); } </pre>
 * @param degrees the angle that the picture will be rotated clockwise.Valid values are 0, 90, 180, and 270. The starting position is 0 (landscape).
 * @see #setPreviewDisplay(SurfaceHolder)
 */
public native final void setDisplayOrientation(int degrees);",0.8272583201267829
181265,"private void doDrag(int deltaX,int deltaY){
  if ((deltaX | deltaY) != 0) {
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int rangeX=computeMaxScrollX();
    final int rangeY=computeMaxScrollY();
    if (mEdgeGlowTop != null) {
      mOverscrollDeltaX=deltaX;
      mOverscrollDeltaY=deltaY;
    }
    overScrollBy(deltaX,deltaY,oldX,oldY,rangeX,rangeY,mOverscrollDistance,mOverscrollDistance,true);
  }
  if (!getSettings().getBuiltInZoomControls()) {
    boolean showPlusMinus=mMinZoomScale < mMaxZoomScale;
    if (mZoomControls != null && showPlusMinus) {
      if (mZoomControls.getVisibility() == View.VISIBLE) {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
      }
 else {
        mZoomControls.show(showPlusMinus,false);
      }
      mPrivateHandler.postDelayed(mZoomControlRunnable,ZOOM_CONTROLS_TIMEOUT);
    }
  }
}","private void doDrag(int deltaX,int deltaY){
  if ((deltaX | deltaY) != 0) {
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int rangeX=computeMaxScrollX();
    final int rangeY=computeMaxScrollY();
    if (mEdgeGlowTop != null) {
      mOverscrollDeltaX=deltaX;
      mOverscrollDeltaY=deltaY;
    }
    overScrollBy(deltaX,deltaY,oldX,oldY,rangeX,rangeY,mOverscrollDistance,mOverscrollDistance,true);
    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished() || !mEdgeGlowLeft.isFinished()|| !mEdgeGlowRight.isFinished())) {
      invalidate();
    }
  }
  if (!getSettings().getBuiltInZoomControls()) {
    boolean showPlusMinus=mMinZoomScale < mMaxZoomScale;
    if (mZoomControls != null && showPlusMinus) {
      if (mZoomControls.getVisibility() == View.VISIBLE) {
        mPrivateHandler.removeCallbacks(mZoomControlRunnable);
      }
 else {
        mZoomControls.show(showPlusMinus,false);
      }
      mPrivateHandler.postDelayed(mZoomControlRunnable,ZOOM_CONTROLS_TIMEOUT);
    }
  }
}",0.9035956227201668
181266,"/** 
 * Sets the rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If appplications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.mOrientation is the angle between camera orientation and natural device orientation. The sum of the two is the angle for rotation. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose the camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). The reference code is as follows. public void public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; mParameters.setRotation((orientation + info.mOrientation) % 360); }
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}","/** 
 * Sets the rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG   {@link PictureCallback}. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If applications want to rotate the picture to match the orientation of what users see, apps should use   {@link android.view.OrientationEventListener} and {@link CameraInfo}. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum or of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). The reference code is as follows. public void public void onOrientationChanged(int orientation) { if (orientation == ORIENTATION_UNKNOWN) return; android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); orientation = (orientation + 45) / 90 * 90; int rotation = 0; if (info.facing == CameraInfo.CAMERA_FACING_FRONT) { rotation = (info.orientation - orientation + 360) % 360; } else {  // back-facing camera rotation = (info.orientation + orientation) % 360; } mParameters.setRotation(rotation); }
 * @param rotation The rotation angle in degrees relative to theorientation of the camera. Rotation can only be 0, 90, 180 or 270.
 * @throws IllegalArgumentException if rotation value is invalid.
 * @see android.view.OrientationEventListener
 * @see #getCameraInfo(int,CameraInfo)
 */
public void setRotation(int rotation){
  if (rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270) {
    set(KEY_ROTATION,Integer.toString(rotation));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + rotation);
  }
}",0.8914285714285715
181267,"/** 
 * Set the display orientation. This affects the preview frames and the picture displayed after snapshot. This method is useful for portrait mode applications. This does not affect the order of byte array passed in  {@link PreviewCallback#onPreviewFrame}. This method is not allowed to be called during preview. If you want to make the camera image show in the same orientation as the display, you can use the following code.<p> <pre> public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) { android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result = (info.orientation - degrees + 360) % 360; camera.setDisplayOrientation(result); } </pre>
 * @param degrees the angle that the picture will be rotated clockwise.Valid values are 0, 90, 180, and 270. The starting position is 0 (landscape).
 */
public native final void setDisplayOrientation(int degrees);","/** 
 * Set the clockwise rotation of preview display in degrees. This affects the preview frames and the picture displayed after snapshot. This method is useful for portrait mode applications. Note that preview display of front-facing cameras is flipped horizontally, that is, the image is reflected along the central vertical axis of the camera sensor. So the users can see themselves as looking into a mirror. This does not affect the order of byte array passed in   {@link PreviewCallback#onPreviewFrame}, JPEG pictures, or recorded videos. This method is not allowed to be called during preview. If you want to make the camera image show in the same orientation as the display, you can use the following code.<p> <pre> public static void setCameraDisplayOrientation(Activity activity, int cameraId, android.hardware.Camera camera) { android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360;  // compensate the mirror } else {  // back-facing result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result); } </pre>
 * @param degrees the angle that the picture will be rotated clockwise.Valid values are 0, 90, 180, and 270. The starting position is 0 (landscape).
 * @see #setPreviewDisplay(SurfaceHolder)
 */
public native final void setDisplayOrientation(int degrees);",0.8272583201267829
181268,"final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        mService.setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (mService) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mService.mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    if (mMainStack && aInfo != null && (aInfo.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
        if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
          int realCallingPid=callingPid;
          int realCallingUid=callingUid;
          if (caller != null) {
            ProcessRecord callerApp=mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
              realCallingPid=callerApp.pid;
              realCallingUid=callerApp.info.uid;
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ realCallingPid+ ""String_Node_Str""+ intent.toString());
              return START_PERMISSION_DENIED;
            }
          }
          IIntentSender target=mService.getIntentSenderLocked(IActivityManager.INTENT_SENDER_ACTIVITY,""String_Node_Str"",realCallingUid,null,null,0,intent,resolvedType,PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
          Intent newIntent=new Intent();
          if (requestCode >= 0) {
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT,true);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,new IntentSender(target));
          if (mService.mHeavyWeightProcess.activities.size() > 0) {
            ActivityRecord hist=mService.mHeavyWeightProcess.activities.get(0);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,hist.packageName);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,hist.task.taskId);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,aInfo.packageName);
          newIntent.setFlags(intent.getFlags());
          newIntent.setClassName(""String_Node_Str"",HeavyWeightSwitcherActivity.class.getName());
          intent=newIntent;
          resolvedType=null;
          caller=null;
          callingUid=Binder.getCallingUid();
          callingPid=Binder.getCallingPid();
          componentSpecified=true;
          try {
            ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,null,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
            aInfo=rInfo != null ? rInfo.activityInfo : null;
          }
 catch (          RemoteException e) {
            aInfo=null;
          }
        }
      }
    }
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange && mMainStack) {
      mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      mService.updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        ActivityRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        mService.setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (mService) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mService.mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    if (mMainStack && aInfo != null && (aInfo.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
        if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
          int realCallingPid=callingPid;
          int realCallingUid=callingUid;
          if (caller != null) {
            ProcessRecord callerApp=mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
              realCallingPid=callerApp.pid;
              realCallingUid=callerApp.info.uid;
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ realCallingPid+ ""String_Node_Str""+ intent.toString());
              return START_PERMISSION_DENIED;
            }
          }
          IIntentSender target=mService.getIntentSenderLocked(IActivityManager.INTENT_SENDER_ACTIVITY,""String_Node_Str"",realCallingUid,null,null,0,intent,resolvedType,PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
          Intent newIntent=new Intent();
          if (requestCode >= 0) {
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT,true);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,new IntentSender(target));
          if (mService.mHeavyWeightProcess.activities.size() > 0) {
            ActivityRecord hist=mService.mHeavyWeightProcess.activities.get(0);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,hist.packageName);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,hist.task.taskId);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,aInfo.packageName);
          newIntent.setFlags(intent.getFlags());
          newIntent.setClassName(""String_Node_Str"",HeavyWeightSwitcherActivity.class.getName());
          intent=newIntent;
          resolvedType=null;
          caller=null;
          callingUid=Binder.getCallingUid();
          callingPid=Binder.getCallingPid();
          componentSpecified=true;
          try {
            ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,null,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
            aInfo=rInfo != null ? rInfo.activityInfo : null;
          }
 catch (          RemoteException e) {
            aInfo=null;
          }
        }
      }
    }
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange && mMainStack) {
      mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      mService.updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            mService.wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        ActivityRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              mService.wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}",0.9984005686866892
181269,"final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        mService.setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (mService) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mService.mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    if (mMainStack && aInfo != null && (aInfo.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
        if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
          int realCallingPid=callingPid;
          int realCallingUid=callingUid;
          if (caller != null) {
            ProcessRecord callerApp=mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
              realCallingPid=callerApp.pid;
              realCallingUid=callerApp.info.uid;
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ realCallingPid+ ""String_Node_Str""+ intent.toString());
              return START_PERMISSION_DENIED;
            }
          }
          IIntentSender target=mService.getIntentSenderLocked(IActivityManager.INTENT_SENDER_ACTIVITY,""String_Node_Str"",realCallingUid,null,null,0,intent,resolvedType,PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
          Intent newIntent=new Intent();
          if (requestCode >= 0) {
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT,true);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,new IntentSender(target));
          if (mService.mHeavyWeightProcess.activities.size() > 0) {
            ActivityRecord hist=mService.mHeavyWeightProcess.activities.get(0);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,hist.packageName);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,hist.task.taskId);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,aInfo.packageName);
          newIntent.setFlags(intent.getFlags());
          newIntent.setClassName(""String_Node_Str"",HeavyWeightSwitcherActivity.class.getName());
          intent=newIntent;
          resolvedType=null;
          caller=null;
          callingUid=Binder.getCallingUid();
          callingPid=Binder.getCallingPid();
          componentSpecified=true;
          try {
            ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,null,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
            aInfo=rInfo != null ? rInfo.activityInfo : null;
          }
 catch (          RemoteException e) {
            aInfo=null;
          }
        }
      }
    }
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange && mMainStack) {
      mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      mService.updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        ActivityRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        mService.setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (mService) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mService.mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    if (mMainStack && aInfo != null && (aInfo.applicationInfo.flags & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
      if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
        if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
          int realCallingPid=callingPid;
          int realCallingUid=callingUid;
          if (caller != null) {
            ProcessRecord callerApp=mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
              realCallingPid=callerApp.pid;
              realCallingUid=callerApp.info.uid;
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ realCallingPid+ ""String_Node_Str""+ intent.toString());
              return START_PERMISSION_DENIED;
            }
          }
          IIntentSender target=mService.getIntentSenderLocked(IActivityManager.INTENT_SENDER_ACTIVITY,""String_Node_Str"",realCallingUid,null,null,0,intent,resolvedType,PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT);
          Intent newIntent=new Intent();
          if (requestCode >= 0) {
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT,true);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,new IntentSender(target));
          if (mService.mHeavyWeightProcess.activities.size() > 0) {
            ActivityRecord hist=mService.mHeavyWeightProcess.activities.get(0);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,hist.packageName);
            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,hist.task.taskId);
          }
          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,aInfo.packageName);
          newIntent.setFlags(intent.getFlags());
          newIntent.setClassName(""String_Node_Str"",HeavyWeightSwitcherActivity.class.getName());
          intent=newIntent;
          resolvedType=null;
          caller=null;
          callingUid=Binder.getCallingUid();
          callingPid=Binder.getCallingPid();
          componentSpecified=true;
          try {
            ResolveInfo rInfo=AppGlobals.getPackageManager().resolveIntent(intent,null,PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS);
            aInfo=rInfo != null ? rInfo.activityInfo : null;
          }
 catch (          RemoteException e) {
            aInfo=null;
          }
        }
      }
    }
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange && mMainStack) {
      mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      mService.updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            mService.wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        ActivityRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              mService.wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}",0.9984005686866892
181270,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mAllowPanAndScale || mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        if (!mAllowPanAndScale) {
          return true;
        }
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
        if (mSelectingText) {
          mDrawSelectionPointer=false;
          mSelectionStarted=nativeStartSelection(contentX,contentY);
          if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
          }
          invalidate();
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mSelectingText && mSelectionStarted) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
      }
      nativeExtendSelection(contentX,contentY);
      invalidate();
      break;
    }
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      if (mScaleDetector != null && !mScaleDetector.isInProgress()) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
          mSnapScrollMode=SNAP_X;
          mSnapPositive=deltaX > 0;
        }
 else         if (ay > MAX_SLOPE_FOR_DIAG * ax) {
          mSnapScrollMode=SNAP_Y;
          mSnapPositive=deltaY > 0;
        }
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (nativeHitSelection(contentX,contentY)) {
copySelection();
}
selectionDone();
break;
}
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
 else {
if (mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY())) {
invalidate();
}
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mAllowPanAndScale || mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        if (!mAllowPanAndScale) {
          return true;
        }
        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
        if (mSelectingText) {
          mDrawSelectionPointer=false;
          mSelectionStarted=nativeStartSelection(contentX,contentY);
          if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
          }
          invalidate();
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mSelectingText && mSelectionStarted) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
      }
      nativeExtendSelection(contentX,contentY);
      invalidate();
      break;
    }
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      if (mScaleDetector != null && !mScaleDetector.isInProgress()) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
          mSnapScrollMode=SNAP_X;
          mSnapPositive=deltaX > 0;
        }
 else         if (ay > MAX_SLOPE_FOR_DIAG * ax) {
          mSnapScrollMode=SNAP_Y;
          mSnapPositive=deltaY > 0;
        }
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (nativeHitSelection(contentX,contentY)) {
copySelection();
}
selectionDone();
break;
}
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
 else {
if (mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY())) {
invalidate();
}
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}",0.9949036668738348
181271,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mAllowPanAndScale || mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        if (!mAllowPanAndScale) {
          return true;
        }
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
        if (mSelectingText) {
          mDrawSelectionPointer=false;
          mSelectionStarted=nativeStartSelection(contentX,contentY);
          if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
          }
          invalidate();
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mSelectingText && mSelectionStarted) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
      }
      nativeExtendSelection(contentX,contentY);
      invalidate();
      break;
    }
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      if (mScaleDetector != null && !mScaleDetector.isInProgress()) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
          mSnapScrollMode=SNAP_X;
          mSnapPositive=deltaX > 0;
        }
 else         if (ay > MAX_SLOPE_FOR_DIAG * ax) {
          mSnapScrollMode=SNAP_Y;
          mSnapPositive=deltaY > 0;
        }
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (nativeHitSelection(contentX,contentY)) {
copySelection();
}
selectionDone();
break;
}
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
 else {
if (mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY())) {
invalidate();
}
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mAllowPanAndScale || mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        if (!mAllowPanAndScale) {
          return true;
        }
        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
        if (mSelectingText) {
          mDrawSelectionPointer=false;
          mSelectionStarted=nativeStartSelection(contentX,contentY);
          if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
          }
          invalidate();
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mSelectingText && mSelectionStarted) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,""String_Node_Str"" + contentX + ""String_Node_Str""+ contentY);
      }
      nativeExtendSelection(contentX,contentY);
      invalidate();
      break;
    }
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      if (mScaleDetector != null && !mScaleDetector.isInProgress()) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
          mSnapScrollMode=SNAP_X;
          mSnapPositive=deltaX > 0;
        }
 else         if (ay > MAX_SLOPE_FOR_DIAG * ax) {
          mSnapScrollMode=SNAP_Y;
          mSnapPositive=deltaY > 0;
        }
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (nativeHitSelection(contentX,contentY)) {
copySelection();
}
selectionDone();
break;
}
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
 else {
if (mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY())) {
invalidate();
}
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
mScroller.springBack(mScrollX,mScrollY,0,computeMaxScrollX(),0,computeMaxScrollY());
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}",0.9949036668738348
181272,"private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  if (windowSupportsHandles && mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (windowSupportsHandles && textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.3933376040999359
181273,"private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  boolean windowSupportsHandles=false;
  ViewGroup.LayoutParams params=getRootView().getLayoutParams();
  if (params instanceof WindowManager.LayoutParams) {
    WindowManager.LayoutParams windowParams=(WindowManager.LayoutParams)params;
    windowSupportsHandles=windowParams.type < WindowManager.LayoutParams.FIRST_SUB_WINDOW || windowParams.type > WindowManager.LayoutParams.LAST_SUB_WINDOW;
  }
  if (windowSupportsHandles && mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (windowSupportsHandles && textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.3933376040999359
181274,"public void commitPendingDataToDisk(){
  Parcel next;
synchronized (this) {
    next=mPendingWrite;
    mPendingWrite=null;
    mWriteLock.lock();
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    stream.write(next.marshall());
    stream.flush();
    stream.close();
    mFile.commit();
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    mFile.rollback();
  }
 finally {
    next.recycle();
    mWriteLock.unlock();
  }
}","public void commitPendingDataToDisk(){
  final Parcel next;
synchronized (this) {
    next=mPendingWrite;
    mPendingWrite=null;
    if (next == null) {
      return;
    }
    mWriteLock.lock();
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    stream.write(next.marshall());
    stream.flush();
    stream.close();
    mFile.commit();
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    mFile.rollback();
  }
 finally {
    next.recycle();
    mWriteLock.unlock();
  }
}",0.9521072796934866
181275,"public void commitPendingDataToDisk(){
  Parcel next;
synchronized (this) {
    next=mPendingWrite;
    mPendingWrite=null;
    mWriteLock.lock();
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    stream.write(next.marshall());
    stream.flush();
    stream.close();
    mFile.commit();
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    mFile.rollback();
  }
 finally {
    next.recycle();
    mWriteLock.unlock();
  }
}","public void commitPendingDataToDisk(){
  final Parcel next;
synchronized (this) {
    next=mPendingWrite;
    mPendingWrite=null;
    if (next == null) {
      return;
    }
    mWriteLock.lock();
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    stream.write(next.marshall());
    stream.flush();
    stream.close();
    mFile.commit();
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
    mFile.rollback();
  }
 finally {
    next.recycle();
    mWriteLock.unlock();
  }
}",0.9521072796934866
181276,"/** 
 * <p>Generate the layout parameters for the popup window.</p>
 * @param token the window token used to bind the popup's window
 * @return the layout parameters to pass to the window manager
 */
private WindowManager.LayoutParams createPopupLayout(IBinder token){
  WindowManager.LayoutParams p=new WindowManager.LayoutParams();
  p.gravity=Gravity.LEFT | Gravity.TOP;
  p.width=mLastWidth=mWidth;
  p.height=mLastHeight=mHeight;
  if (mBackground != null) {
    p.format=mBackground.getOpacity();
  }
 else {
    p.format=PixelFormat.TRANSLUCENT;
  }
  p.flags=computeFlags(p.flags);
  p.type=WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
  p.token=token;
  p.softInputMode=mSoftInputMode;
  p.setTitle(""String_Node_Str"" + Integer.toHexString(hashCode()));
  return p;
}","/** 
 * <p>Generate the layout parameters for the popup window.</p>
 * @param token the window token used to bind the popup's window
 * @return the layout parameters to pass to the window manager
 */
private WindowManager.LayoutParams createPopupLayout(IBinder token){
  WindowManager.LayoutParams p=new WindowManager.LayoutParams();
  p.gravity=Gravity.LEFT | Gravity.TOP;
  p.width=mLastWidth=mWidth;
  p.height=mLastHeight=mHeight;
  if (mBackground != null) {
    p.format=mBackground.getOpacity();
  }
 else {
    p.format=PixelFormat.TRANSLUCENT;
  }
  p.flags=computeFlags(p.flags);
  p.type=mWindowLayoutType;
  p.token=token;
  p.softInputMode=mSoftInputMode;
  p.setTitle(""String_Node_Str"" + Integer.toHexString(hashCode()));
  return p;
}",0.9660130718954248
181277,"public HandleView(CursorController controller,int pos){
  super(TextView.this.mContext);
  mController=controller;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  setOrientation(pos);
}","public HandleView(CursorController controller,int pos){
  super(TextView.this.mContext);
  mController=controller;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  mContainer.setWindowLayoutType(WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL);
  setOrientation(pos);
}",0.8748353096179183
181278,"public HandleView(CursorController controller,Drawable handle){
  super(TextView.this.mContext);
  mController=controller;
  mDrawable=handle;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  final int handleWidth=mDrawable.getIntrinsicWidth();
  final int handleHeight=mDrawable.getIntrinsicHeight();
  mHotspotX=handleWidth * 0.5f;
  mHotspotY=-handleHeight * 0.2f;
}","public HandleView(CursorController controller,int pos){
  super(TextView.this.mContext);
  mController=controller;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  setOrientation(pos);
}",0.675263774912075
181279,"private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionVisible()) {
    int[] coords=null;
    if (mContainer.isShowing()) {
      coords=mTempCoords;
      TextView.this.getLocationInWindow(coords);
      mContainer.update(coords[0] + mPositionX,coords[1] + mPositionY,mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
    if (mIsDragging) {
      if (coords == null) {
        coords=mTempCoords;
        TextView.this.getLocationInWindow(coords);
      }
      if (coords[0] != mLastParentX || coords[1] != mLastParentY) {
        mOffsetX+=coords[0] - mLastParentX;
        mOffsetY+=coords[1] - mLastParentY;
        mLastParentX=coords[0];
        mLastParentY=coords[1];
      }
    }
  }
 else {
    hide();
  }
}","private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionVisible()) {
    int[] coords=null;
    if (mContainer.isShowing()) {
      coords=mTempCoords;
      TextView.this.getLocationInWindow(coords);
      mContainer.update(coords[0] + mPositionX,coords[1] + mPositionY,mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
    if (mIsDragging) {
      if (coords == null) {
        coords=mTempCoords;
        TextView.this.getLocationInWindow(coords);
      }
      if (coords[0] != mLastParentX || coords[1] != mLastParentY) {
        mTouchToWindowOffsetX+=coords[0] - mLastParentX;
        mTouchToWindowOffsetY+=coords[1] - mLastParentY;
        mLastParentX=coords[0];
        mLastParentY=coords[1];
      }
    }
  }
 else {
    hide();
  }
}",0.9842805320435308
181280,"void positionAtCursor(final int offset,boolean bottom){
  final int width=mDrawable.getIntrinsicWidth();
  final int height=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - width / 2.0) + TextView.this.mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop) + TextView.this.mScrollY;
  bounds.right=bounds.left + width;
  bounds.bottom=bounds.top + height;
  convertFromViewportToContentCoordinates(bounds);
  moveTo(bounds.left,bounds.top);
}","void positionAtCursor(final int offset,boolean bottom){
  final int width=mDrawable.getIntrinsicWidth();
  final int height=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - mHotspotX) + TextView.this.mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop - mHeight) + TextView.this.mScrollY;
  bounds.right=bounds.left + width;
  bounds.bottom=bounds.top + height;
  convertFromViewportToContentCoordinates(bounds);
  moveTo(bounds.left,bounds.top);
}",0.9780701754385964
181281,"int getHysteresisOffset(int x,int y,int previousOffset){
  final Layout layout=getLayout();
  if (layout == null)   return -1;
  y-=getTotalPaddingTop();
  y=Math.max(0,y);
  y=Math.min(getHeight() - getTotalPaddingBottom() - 1,y);
  y+=getScrollY();
  int line=getLayout().getLineForVertical(y);
  final int previousLine=layout.getLineForOffset(previousOffset);
  final int previousLineTop=layout.getLineTop(previousLine);
  final int previousLineBottom=layout.getLineBottom(previousLine);
  final int hysteresisThreshold=(previousLineBottom - previousLineTop) / 6;
  if (((line == previousLine + 1) && ((y - previousLineBottom) < hysteresisThreshold)) || ((line == previousLine - 1) && ((previousLineTop - y) < hysteresisThreshold))) {
    line=previousLine;
  }
  return getOffsetForHorizontal(line,x);
}","int getHysteresisOffset(int x,int y,int previousOffset){
  final Layout layout=getLayout();
  if (layout == null)   return -1;
  y-=getTotalPaddingTop();
  y=Math.max(0,y);
  y=Math.min(getHeight() - getTotalPaddingBottom() - 1,y);
  y+=getScrollY();
  int line=getLayout().getLineForVertical(y);
  final int previousLine=layout.getLineForOffset(previousOffset);
  final int previousLineTop=layout.getLineTop(previousLine);
  final int previousLineBottom=layout.getLineBottom(previousLine);
  final int hysteresisThreshold=(previousLineBottom - previousLineTop) / 8;
  if (((line == previousLine + 1) && ((y - previousLineBottom) < hysteresisThreshold)) || ((line == previousLine - 1) && ((previousLineTop - y) < hysteresisThreshold))) {
    line=previousLine;
  }
  return getOffsetForHorizontal(line,x);
}",0.9987608426270136
181282,"InsertionPointCursorController(){
  Resources res=mContext.getResources();
  mHandle=new HandleView(this,res.getDrawable(mTextSelectHandleRes));
}","InsertionPointCursorController(){
  mHandle=new HandleView(this,HandleView.CENTER);
}",0.6493506493506493
181283,"public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  boolean oneLineSelection=mLayout.getLineForOffset(selectionStart) == mLayout.getLineForOffset(selectionEnd);
  mStartHandle.positionAtCursor(selectionStart,oneLineSelection);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}","public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  mStartHandle.positionAtCursor(selectionStart,true);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.8526434195725534
181284,"SelectionModifierCursorController(){
  Resources res=mContext.getResources();
  mStartHandle=new HandleView(this,res.getDrawable(mTextSelectHandleLeftRes));
  mEndHandle=new HandleView(this,res.getDrawable(mTextSelectHandleRightRes));
}","SelectionModifierCursorController(){
  mStartHandle=new HandleView(this,HandleView.LEFT);
  mEndHandle=new HandleView(this,HandleView.RIGHT);
}",0.6649076517150396
181285,"private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY + mHotspotY <= clip.bottom;
}","private boolean isPositionVisible(){
  if (mIsDragging) {
    return true;
  }
  final int extendedPaddingTop=getExtendedPaddingTop();
  final int extendedPaddingBottom=getExtendedPaddingBottom();
  final int compoundPaddingLeft=getCompoundPaddingLeft();
  final int compoundPaddingRight=getCompoundPaddingRight();
  final TextView hostView=TextView.this;
  final int left=0;
  final int right=hostView.getWidth();
  final int top=0;
  final int bottom=hostView.getHeight();
  if (mTempRect == null) {
    mTempRect=new Rect();
  }
  final Rect clip=mTempRect;
  clip.left=left + compoundPaddingLeft;
  clip.top=top + extendedPaddingTop;
  clip.right=right - compoundPaddingRight;
  clip.bottom=bottom - extendedPaddingBottom;
  final ViewParent parent=hostView.getParent();
  if (parent == null || !parent.getChildVisibleRect(hostView,clip,null)) {
    return false;
  }
  final int[] coords=mTempCoords;
  hostView.getLocationInWindow(coords);
  final int posX=coords[0] + mPositionX + (int)mHotspotX;
  final int posY=coords[1] + mPositionY + (int)mHotspotY;
  return posX >= clip.left && posX <= clip.right && posY >= clip.top && posY <= clip.bottom;
}",0.987429562201994
181286,void onInputQueueCreated(InputQueue queue);,"/** 
 * Called when the given InputQueue is now associated with the thread making this call, so it can start receiving events from it.
 */
void onInputQueueCreated(InputQueue queue);",0.3822222222222222
181287,void onInputQueueDestroyed(InputQueue queue);,"/** 
 * Called when the given InputQueue is no longer associated with the thread and thus not dispatching events.
 */
void onInputQueueDestroyed(InputQueue queue);",0.4326923076923077
181288,"/** 
 * <p>Generate the layout parameters for the popup window.</p>
 * @param token the window token used to bind the popup's window
 * @return the layout parameters to pass to the window manager
 */
private WindowManager.LayoutParams createPopupLayout(IBinder token){
  WindowManager.LayoutParams p=new WindowManager.LayoutParams();
  p.gravity=Gravity.LEFT | Gravity.TOP;
  p.width=mLastWidth=mWidth;
  p.height=mLastHeight=mHeight;
  if (mBackground != null) {
    p.format=mBackground.getOpacity();
  }
 else {
    p.format=PixelFormat.TRANSLUCENT;
  }
  p.flags=computeFlags(p.flags);
  p.type=WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
  p.token=token;
  p.softInputMode=mSoftInputMode;
  p.setTitle(""String_Node_Str"" + Integer.toHexString(hashCode()));
  return p;
}","/** 
 * <p>Generate the layout parameters for the popup window.</p>
 * @param token the window token used to bind the popup's window
 * @return the layout parameters to pass to the window manager
 */
private WindowManager.LayoutParams createPopupLayout(IBinder token){
  WindowManager.LayoutParams p=new WindowManager.LayoutParams();
  p.gravity=Gravity.LEFT | Gravity.TOP;
  p.width=mLastWidth=mWidth;
  p.height=mLastHeight=mHeight;
  if (mBackground != null) {
    p.format=mBackground.getOpacity();
  }
 else {
    p.format=PixelFormat.TRANSLUCENT;
  }
  p.flags=computeFlags(p.flags);
  p.type=mWindowLayoutType;
  p.token=token;
  p.softInputMode=mSoftInputMode;
  p.setTitle(""String_Node_Str"" + Integer.toHexString(hashCode()));
  return p;
}",0.9660130718954248
181289,"public HandleView(CursorController controller,int pos){
  super(TextView.this.mContext);
  mController=controller;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  setOrientation(pos);
}","public HandleView(CursorController controller,int pos){
  super(TextView.this.mContext);
  mController=controller;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  mContainer.setWindowLayoutType(WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL);
  setOrientation(pos);
}",0.8748353096179183
181290,"/** 
 * @deprecated This functionality will be removed in the future; please donot use. Control whether this activity is required to be persistent.  By default activities are not persistent; setting this to true will prevent the system from stopping this activity or its process when running low on resources. <p><em>You should avoid using this method</em>, it has severe negative consequences on how well the system can manage its resources.  A better approach is to implement an application service that you control with {@link Context#startService} and {@link Context#stopService}.
 * @param isPersistent Control whether the current activity must bepersistent, true if so, false for the normal behavior.
 */
@Deprecated public void setPersistent(boolean isPersistent){
  if (mParent == null) {
    try {
      ActivityManagerNative.getDefault().setPersistent(mToken,isPersistent);
    }
 catch (    RemoteException e) {
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * @deprecated As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}this is a no-op.
 */
@Deprecated public void setPersistent(boolean isPersistent){
}",0.1972318339100346
181291,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
  int grantedMode=data.readInt();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  boolean onlyIfNeeded=data.readInt() != 0;
  boolean debug=data.readInt() != 0;
  Configuration config=Configuration.CREATOR.createFromParcel(data);
  int result=startActivityWithConfig(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug,config);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
  fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean res=killPids(pids,reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
String type=getProviderMimeType(uri);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
  int grantedMode=data.readInt();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  boolean onlyIfNeeded=data.readInt() != 0;
  boolean debug=data.readInt() != 0;
  Configuration config=Configuration.CREATOR.createFromParcel(data);
  int result=startActivityWithConfig(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug,config);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
  fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean res=killPids(pids,reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
String type=getProviderMimeType(uri);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9961292567303092
181292,"private final int computeOomAdjLocked(ProcessRecord app,int hiddenAdj,ProcessRecord TOP_APP,boolean recursed){
  if (mAdjSeq == app.adjSeq) {
    if (!recursed && app.hidden) {
      app.curAdj=hiddenAdj;
    }
    return app.curAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    return (app.curAdj=EMPTY_APP_ADJ);
  }
  if (app.maxAdj <= FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    return (app.curAdj=app.maxAdj);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.keeping=false;
  app.empty=false;
  app.hidden=false;
  int adj;
  int schedGroup;
  int N;
  if (app == TOP_APP) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.instrumentationClass != null) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.persistentActivities > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.curReceiver != null || (mPendingBroadcast != null && mPendingBroadcast.curApp == app)) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.executingServices.size() > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.foregroundServices) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.forcingToForeground != null) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    app.adjSource=app.forcingToForeground;
  }
 else   if (app == mHeavyWeightProcess) {
    adj=HEAVY_WEIGHT_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app == mHomeProcess) {
    adj=HOME_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
  }
 else   if ((N=app.activities.size()) != 0) {
    app.hidden=true;
    adj=hiddenAdj;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    N=app.activities.size();
    for (int j=0; j < N; j++) {
      if (app.activities.get(j).visible) {
        app.hidden=false;
        adj=VISIBLE_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.adjType=""String_Node_Str"";
        break;
      }
    }
  }
 else {
    app.hidden=true;
    app.empty=true;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=hiddenAdj;
    app.adjType=""String_Node_Str"";
  }
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=BACKUP_APP_ADJ;
      app.adjType=""String_Node_Str"";
      app.hidden=false;
    }
  }
  if (app.services.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    final long now=SystemClock.uptimeMillis();
    Iterator<ServiceRecord> jt=app.services.iterator();
    while (jt.hasNext() && adj > FOREGROUND_APP_ADJ) {
      ServiceRecord s=jt.next();
      if (s.startRequested) {
        if (now < (s.lastActivity + MAX_SERVICE_INACTIVITY)) {
          if (adj > SECONDARY_SERVER_ADJ) {
            adj=SECONDARY_SERVER_ADJ;
            app.adjType=""String_Node_Str"";
            app.hidden=false;
          }
        }
        if (adj > SECONDARY_SERVER_ADJ) {
          app.adjType=""String_Node_Str"";
        }
        app.keeping=true;
      }
      if (s.connections.size() > 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
        Iterator<ArrayList<ConnectionRecord>> kt=s.connections.values().iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ArrayList<ConnectionRecord> clist=kt.next();
          for (int i=0; i < clist.size() && adj > FOREGROUND_APP_ADJ; i++) {
            ConnectionRecord cr=clist.get(i);
            if (cr.binding.client == app) {
              continue;
            }
            if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
              ProcessRecord client=cr.binding.client;
              int myHiddenAdj=hiddenAdj;
              if (myHiddenAdj > client.hiddenAdj) {
                if (client.hiddenAdj >= VISIBLE_APP_ADJ) {
                  myHiddenAdj=client.hiddenAdj;
                }
 else {
                  myHiddenAdj=VISIBLE_APP_ADJ;
                }
              }
              int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
              if (adj > clientAdj) {
                adj=clientAdj >= VISIBLE_APP_ADJ ? clientAdj : VISIBLE_APP_ADJ;
                if (!client.hidden) {
                  app.hidden=false;
                }
                if (client.keeping) {
                  app.keeping=true;
                }
                app.adjType=""String_Node_Str"";
                app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                app.adjSource=cr.binding.client;
                app.adjTarget=s.name;
              }
              if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                  schedGroup=Process.THREAD_GROUP_DEFAULT;
                }
              }
            }
            ActivityRecord a=cr.activity;
            if (a != null && adj > FOREGROUND_APP_ADJ && (a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
              adj=FOREGROUND_APP_ADJ;
              schedGroup=Process.THREAD_GROUP_DEFAULT;
              app.hidden=false;
              app.adjType=""String_Node_Str"";
              app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
              app.adjSource=a;
              app.adjTarget=s.name;
            }
          }
        }
      }
    }
    if (adj > hiddenAdj) {
      adj=hiddenAdj;
      app.hidden=false;
      app.adjType=""String_Node_Str"";
    }
  }
  if (app.pubProviders.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    Iterator<ContentProviderRecord> jt=app.pubProviders.values().iterator();
    while (jt.hasNext() && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
      ContentProviderRecord cpr=jt.next();
      if (cpr.clients.size() != 0) {
        Iterator<ProcessRecord> kt=cpr.clients.iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ProcessRecord client=kt.next();
          if (client == app) {
            continue;
          }
          int myHiddenAdj=hiddenAdj;
          if (myHiddenAdj > client.hiddenAdj) {
            if (client.hiddenAdj > FOREGROUND_APP_ADJ) {
              myHiddenAdj=client.hiddenAdj;
            }
 else {
              myHiddenAdj=FOREGROUND_APP_ADJ;
            }
          }
          int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
          if (adj > clientAdj) {
            adj=clientAdj > FOREGROUND_APP_ADJ ? clientAdj : FOREGROUND_APP_ADJ;
            if (!client.hidden) {
              app.hidden=false;
            }
            if (client.keeping) {
              app.keeping=true;
            }
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
            app.adjSource=client;
            app.adjTarget=cpr.name;
          }
          if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
            schedGroup=Process.THREAD_GROUP_DEFAULT;
          }
        }
      }
      if (cpr.externals != 0) {
        if (adj > FOREGROUND_APP_ADJ) {
          adj=FOREGROUND_APP_ADJ;
          schedGroup=Process.THREAD_GROUP_DEFAULT;
          app.hidden=false;
          app.keeping=true;
          app.adjType=""String_Node_Str"";
          app.adjTarget=cpr.name;
        }
      }
    }
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < HIDDEN_APP_MIN_ADJ) {
    app.keeping=true;
  }
  app.curAdj=adj;
  app.curSchedGroup=schedGroup;
  return adj;
}","private final int computeOomAdjLocked(ProcessRecord app,int hiddenAdj,ProcessRecord TOP_APP,boolean recursed){
  if (mAdjSeq == app.adjSeq) {
    if (!recursed && app.hidden) {
      app.curAdj=hiddenAdj;
    }
    return app.curAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    return (app.curAdj=EMPTY_APP_ADJ);
  }
  if (app.maxAdj <= FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    return (app.curAdj=app.maxAdj);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.keeping=false;
  app.empty=false;
  app.hidden=false;
  int adj;
  int schedGroup;
  int N;
  if (app == TOP_APP) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.instrumentationClass != null) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.curReceiver != null || (mPendingBroadcast != null && mPendingBroadcast.curApp == app)) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.executingServices.size() > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.foregroundServices) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.forcingToForeground != null) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    app.adjSource=app.forcingToForeground;
  }
 else   if (app == mHeavyWeightProcess) {
    adj=HEAVY_WEIGHT_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app == mHomeProcess) {
    adj=HOME_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
  }
 else   if ((N=app.activities.size()) != 0) {
    app.hidden=true;
    adj=hiddenAdj;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    N=app.activities.size();
    for (int j=0; j < N; j++) {
      if (app.activities.get(j).visible) {
        app.hidden=false;
        adj=VISIBLE_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.adjType=""String_Node_Str"";
        break;
      }
    }
  }
 else {
    app.hidden=true;
    app.empty=true;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=hiddenAdj;
    app.adjType=""String_Node_Str"";
  }
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=BACKUP_APP_ADJ;
      app.adjType=""String_Node_Str"";
      app.hidden=false;
    }
  }
  if (app.services.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    final long now=SystemClock.uptimeMillis();
    Iterator<ServiceRecord> jt=app.services.iterator();
    while (jt.hasNext() && adj > FOREGROUND_APP_ADJ) {
      ServiceRecord s=jt.next();
      if (s.startRequested) {
        if (now < (s.lastActivity + MAX_SERVICE_INACTIVITY)) {
          if (adj > SECONDARY_SERVER_ADJ) {
            adj=SECONDARY_SERVER_ADJ;
            app.adjType=""String_Node_Str"";
            app.hidden=false;
          }
        }
        if (adj > SECONDARY_SERVER_ADJ) {
          app.adjType=""String_Node_Str"";
        }
        app.keeping=true;
      }
      if (s.connections.size() > 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
        Iterator<ArrayList<ConnectionRecord>> kt=s.connections.values().iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ArrayList<ConnectionRecord> clist=kt.next();
          for (int i=0; i < clist.size() && adj > FOREGROUND_APP_ADJ; i++) {
            ConnectionRecord cr=clist.get(i);
            if (cr.binding.client == app) {
              continue;
            }
            if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
              ProcessRecord client=cr.binding.client;
              int myHiddenAdj=hiddenAdj;
              if (myHiddenAdj > client.hiddenAdj) {
                if (client.hiddenAdj >= VISIBLE_APP_ADJ) {
                  myHiddenAdj=client.hiddenAdj;
                }
 else {
                  myHiddenAdj=VISIBLE_APP_ADJ;
                }
              }
              int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
              if (adj > clientAdj) {
                adj=clientAdj >= VISIBLE_APP_ADJ ? clientAdj : VISIBLE_APP_ADJ;
                if (!client.hidden) {
                  app.hidden=false;
                }
                if (client.keeping) {
                  app.keeping=true;
                }
                app.adjType=""String_Node_Str"";
                app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                app.adjSource=cr.binding.client;
                app.adjTarget=s.name;
              }
              if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                  schedGroup=Process.THREAD_GROUP_DEFAULT;
                }
              }
            }
            ActivityRecord a=cr.activity;
            if (a != null && adj > FOREGROUND_APP_ADJ && (a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
              adj=FOREGROUND_APP_ADJ;
              schedGroup=Process.THREAD_GROUP_DEFAULT;
              app.hidden=false;
              app.adjType=""String_Node_Str"";
              app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
              app.adjSource=a;
              app.adjTarget=s.name;
            }
          }
        }
      }
    }
    if (adj > hiddenAdj) {
      adj=hiddenAdj;
      app.hidden=false;
      app.adjType=""String_Node_Str"";
    }
  }
  if (app.pubProviders.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    Iterator<ContentProviderRecord> jt=app.pubProviders.values().iterator();
    while (jt.hasNext() && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
      ContentProviderRecord cpr=jt.next();
      if (cpr.clients.size() != 0) {
        Iterator<ProcessRecord> kt=cpr.clients.iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ProcessRecord client=kt.next();
          if (client == app) {
            continue;
          }
          int myHiddenAdj=hiddenAdj;
          if (myHiddenAdj > client.hiddenAdj) {
            if (client.hiddenAdj > FOREGROUND_APP_ADJ) {
              myHiddenAdj=client.hiddenAdj;
            }
 else {
              myHiddenAdj=FOREGROUND_APP_ADJ;
            }
          }
          int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
          if (adj > clientAdj) {
            adj=clientAdj > FOREGROUND_APP_ADJ ? clientAdj : FOREGROUND_APP_ADJ;
            if (!client.hidden) {
              app.hidden=false;
            }
            if (client.keeping) {
              app.keeping=true;
            }
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
            app.adjSource=client;
            app.adjTarget=cpr.name;
          }
          if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
            schedGroup=Process.THREAD_GROUP_DEFAULT;
          }
        }
      }
      if (cpr.externals != 0) {
        if (adj > FOREGROUND_APP_ADJ) {
          adj=FOREGROUND_APP_ADJ;
          schedGroup=Process.THREAD_GROUP_DEFAULT;
          app.hidden=false;
          app.keeping=true;
          app.adjType=""String_Node_Str"";
          app.adjTarget=cpr.name;
        }
      }
    }
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < HIDDEN_APP_MIN_ADJ) {
    app.keeping=true;
  }
  app.curAdj=adj;
  app.curSchedGroup=schedGroup;
  return adj;
}",0.9909460243760884
181293,"final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          Process.killProcess(app.pid);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          if (app.persistent) {
            addAppLocked(app.info);
          }
        }
      }
    }
    if (!updateOomAdjLocked()) {
      int numServiceProcs=0;
      for (i=mLruProcesses.size() - 1; i >= 0; i--) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (app.persistent || app.services.size() != 0 || app.curReceiver != null || app.persistentActivities > 0) {
          if (localLOGV)           Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.services);
          numServiceProcs++;
        }
      }
      int curMaxProcs=mProcessLimit;
      if (curMaxProcs <= 0)       curMaxProcs=MAX_PROCESSES;
      if (mAlwaysFinishActivities) {
        curMaxProcs=1;
      }
      curMaxProcs+=numServiceProcs;
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (!app.persistent && app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
      if (Config.LOGV)       Slog.v(TAG,""String_Node_Str"" + mLruProcesses.size() + ""String_Node_Str""+ curMaxProcs+ ""String_Node_Str"");
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        boolean canQuit=!app.persistent && app.curReceiver == null && app.services.size() == 0 && app.persistentActivities == 0;
        int NUMA=app.activities.size();
        int j;
        if (Config.LOGV)         Slog.v(TAG,""String_Node_Str"" + app.processName);
        for (j=0; j < NUMA && canQuit; j++) {
          ActivityRecord r=app.activities.get(j);
          if (Config.LOGV)           Slog.v(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.visible);
          canQuit=(r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped;
        }
        if (canQuit) {
          for (j=0; j < NUMA; j++) {
            ActivityRecord r=app.activities.get(j);
            if (!r.finishing) {
              r.stack.destroyActivityLocked(r,false);
            }
            r.resultTo=null;
          }
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
    }
    int curMaxActivities=MAX_ACTIVITIES;
    if (mAlwaysFinishActivities) {
      curMaxActivities=1;
    }
    for (i=0; i < mMainStack.mLRUActivities.size() && mMainStack.mLRUActivities.size() > curMaxActivities; i++) {
      final ActivityRecord r=(ActivityRecord)mMainStack.mLRUActivities.get(i);
      if ((r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped&& !r.persistent&& !r.finishing) {
        final int origSize=mMainStack.mLRUActivities.size();
        r.stack.destroyActivityLocked(r,true);
        if (origSize > mMainStack.mLRUActivities.size()) {
          i--;
        }
      }
    }
  }
}","final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          Process.killProcess(app.pid);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          if (app.persistent) {
            addAppLocked(app.info);
          }
        }
      }
    }
    if (!updateOomAdjLocked()) {
      int numServiceProcs=0;
      for (i=mLruProcesses.size() - 1; i >= 0; i--) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (app.persistent || app.services.size() != 0 || app.curReceiver != null) {
          if (localLOGV)           Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.services);
          numServiceProcs++;
        }
      }
      int curMaxProcs=mProcessLimit;
      if (curMaxProcs <= 0)       curMaxProcs=MAX_PROCESSES;
      if (mAlwaysFinishActivities) {
        curMaxProcs=1;
      }
      curMaxProcs+=numServiceProcs;
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (!app.persistent && app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
      if (Config.LOGV)       Slog.v(TAG,""String_Node_Str"" + mLruProcesses.size() + ""String_Node_Str""+ curMaxProcs+ ""String_Node_Str"");
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        boolean canQuit=!app.persistent && app.curReceiver == null && app.services.size() == 0;
        int NUMA=app.activities.size();
        int j;
        if (Config.LOGV)         Slog.v(TAG,""String_Node_Str"" + app.processName);
        for (j=0; j < NUMA && canQuit; j++) {
          ActivityRecord r=app.activities.get(j);
          if (Config.LOGV)           Slog.v(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.visible);
          canQuit=(r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped;
        }
        if (canQuit) {
          for (j=0; j < NUMA; j++) {
            ActivityRecord r=app.activities.get(j);
            if (!r.finishing) {
              r.stack.destroyActivityLocked(r,false);
            }
            r.resultTo=null;
          }
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
    }
    int curMaxActivities=MAX_ACTIVITIES;
    if (mAlwaysFinishActivities) {
      curMaxActivities=1;
    }
    for (i=0; i < mMainStack.mLRUActivities.size() && mMainStack.mLRUActivities.size() > curMaxActivities; i++) {
      final ActivityRecord r=(ActivityRecord)mMainStack.mLRUActivities.get(i);
      if ((r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped&& !r.finishing) {
        final int origSize=mMainStack.mLRUActivities.size();
        r.stack.destroyActivityLocked(r,true);
        if (origSize > mMainStack.mLRUActivities.size()) {
          i--;
        }
      }
    }
  }
}",0.990974930362117
181294,"ActivityRecord(ActivityManagerService _service,ActivityStack _stack,ProcessRecord _caller,int _launchedFromUid,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified){
  service=_service;
  stack=_stack;
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  haveState=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  persistent=false;
  visible=true;
  waitingVisible=false;
  nowVisible=false;
  thumbnailNeeded=false;
  idle=false;
  hasBeenLaunched=false;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    baseDir=aInfo.applicationInfo.sourceDir;
    resDir=aInfo.applicationInfo.publicSourceDir;
    dataDir=aInfo.applicationInfo.dataDir;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    theme=aInfo.getThemeResource();
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,theme != 0 ? theme : android.R.style.Theme,com.android.internal.R.styleable.Window);
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false);
    if (!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) {
      if (Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME) && _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !""String_Node_Str"".equals(realActivity.getClassName())) {
        isHomeActivity=true;
      }
 else {
        isHomeActivity=false;
      }
    }
 else {
      isHomeActivity=false;
    }
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    baseDir=null;
    resDir=null;
    dataDir=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    isHomeActivity=false;
  }
}","ActivityRecord(ActivityManagerService _service,ActivityStack _stack,ProcessRecord _caller,int _launchedFromUid,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified){
  service=_service;
  stack=_stack;
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  haveState=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  waitingVisible=false;
  nowVisible=false;
  thumbnailNeeded=false;
  idle=false;
  hasBeenLaunched=false;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    baseDir=aInfo.applicationInfo.sourceDir;
    resDir=aInfo.applicationInfo.publicSourceDir;
    dataDir=aInfo.applicationInfo.dataDir;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    theme=aInfo.getThemeResource();
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,theme != 0 ? theme : android.R.style.Theme,com.android.internal.R.styleable.Window);
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false);
    if (!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) {
      if (Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME) && _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !""String_Node_Str"".equals(realActivity.getClassName())) {
        isHomeActivity=true;
      }
 else {
        isHomeActivity=false;
      }
    }
 else {
      isHomeActivity=false;
    }
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    baseDir=null;
    resDir=null;
    dataDir=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    isHomeActivity=false;
  }
}",0.9971767363071712
181295,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(baseDir);
  if (!resDir.equals(baseDir))   pw.print(""String_Node_Str"");
  pw.print(resDir);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingResults);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(launchTime,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(startTime,pw);
    pw.println(""String_Node_Str"");
  }
  if (waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.println(nowVisible);
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(baseDir);
  if (!resDir.equals(baseDir))   pw.print(""String_Node_Str"");
  pw.print(resDir);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingResults);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(launchTime,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(startTime,pw);
    pw.println(""String_Node_Str"");
  }
  if (waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.println(nowVisible);
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}",0.9930756641067606
181296,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mService.mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mService.mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  int changes=oldConfig.diff(newConfig);
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
  }
  if ((changes & (~r.info.configChanges)) != 0) {
    r.configChangeFlags|=changes;
    r.startFreezingScreenLocked(r.app,globalChanges);
    if (r.app == null || r.app.thread == null) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      destroyActivityLocked(r,true);
    }
 else     if (r.state == ActivityState.PAUSING) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.configDestroy=true;
      return true;
    }
 else     if (r.state == ActivityState.RESUMED) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,true);
      r.configChangeFlags=0;
    }
 else {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,false);
      r.configChangeFlags=0;
    }
    return false;
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9751191106405506
181297,"/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.persistent) {
        mService.decPersistentCountLocked(r.app);
      }
      if (r.app.activities.size() == 0) {
        mService.updateLruProcessLocked(r.app,true,false);
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.app=null;
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}","/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateLruProcessLocked(r.app,true,false);
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.app=null;
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}",0.9815627743634768
181298,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.println(lruSeq);
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.println(removed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.println(lruSeq);
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.993503436587892
181299,"ProcessRecord(BatteryStatsImpl.Uid.Proc _batteryStats,IApplicationThread _thread,ApplicationInfo _info,String _processName){
  batteryStats=_batteryStats;
  info=_info;
  processName=_processName;
  pkgList.add(_info.packageName);
  thread=_thread;
  maxAdj=ActivityManagerService.EMPTY_APP_ADJ;
  hiddenAdj=ActivityManagerService.HIDDEN_APP_MIN_ADJ;
  curRawAdj=setRawAdj=-100;
  curAdj=setAdj=-100;
  persistent=false;
  removed=false;
  persistentActivities=0;
}","ProcessRecord(BatteryStatsImpl.Uid.Proc _batteryStats,IApplicationThread _thread,ApplicationInfo _info,String _processName){
  batteryStats=_batteryStats;
  info=_info;
  processName=_processName;
  pkgList.add(_info.packageName);
  thread=_thread;
  maxAdj=ActivityManagerService.EMPTY_APP_ADJ;
  hiddenAdj=ActivityManagerService.HIDDEN_APP_MIN_ADJ;
  curRawAdj=setRawAdj=-100;
  curAdj=setAdj=-100;
  persistent=false;
  removed=false;
}",0.9712389380530974
181300,"/** 
 * @deprecated This functionality will be removed in the future; please donot use. Control whether this activity is required to be persistent.  By default activities are not persistent; setting this to true will prevent the system from stopping this activity or its process when running low on resources. <p><em>You should avoid using this method</em>, it has severe negative consequences on how well the system can manage its resources.  A better approach is to implement an application service that you control with {@link Context#startService} and {@link Context#stopService}.
 * @param isPersistent Control whether the current activity must bepersistent, true if so, false for the normal behavior.
 */
@Deprecated public void setPersistent(boolean isPersistent){
  if (mParent == null) {
    try {
      ActivityManagerNative.getDefault().setPersistent(mToken,isPersistent);
    }
 catch (    RemoteException e) {
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * @deprecated As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}this is a no-op.
 */
@Deprecated public void setPersistent(boolean isPersistent){
}",0.1972318339100346
181301,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
  int grantedMode=data.readInt();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  boolean onlyIfNeeded=data.readInt() != 0;
  boolean debug=data.readInt() != 0;
  Configuration config=Configuration.CREATOR.createFromParcel(data);
  int result=startActivityWithConfig(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug,config);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
  fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean res=killPids(pids,reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
String type=getProviderMimeType(uri);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
  int grantedMode=data.readInt();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  boolean onlyIfNeeded=data.readInt() != 0;
  boolean debug=data.readInt() != 0;
  Configuration config=Configuration.CREATOR.createFromParcel(data);
  int result=startActivityWithConfig(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug,config);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
  fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean res=killPids(pids,reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
String type=getProviderMimeType(uri);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9961292567303092
181302,"private final int computeOomAdjLocked(ProcessRecord app,int hiddenAdj,ProcessRecord TOP_APP,boolean recursed){
  if (mAdjSeq == app.adjSeq) {
    if (!recursed && app.hidden) {
      app.curAdj=hiddenAdj;
    }
    return app.curAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    return (app.curAdj=EMPTY_APP_ADJ);
  }
  if (app.maxAdj <= FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    return (app.curAdj=app.maxAdj);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.keeping=false;
  app.empty=false;
  app.hidden=false;
  int adj;
  int schedGroup;
  int N;
  if (app == TOP_APP) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.instrumentationClass != null) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.persistentActivities > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.curReceiver != null || (mPendingBroadcast != null && mPendingBroadcast.curApp == app)) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.executingServices.size() > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.foregroundServices) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.forcingToForeground != null) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    app.adjSource=app.forcingToForeground;
  }
 else   if (app == mHeavyWeightProcess) {
    adj=HEAVY_WEIGHT_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app == mHomeProcess) {
    adj=HOME_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
  }
 else   if ((N=app.activities.size()) != 0) {
    app.hidden=true;
    adj=hiddenAdj;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    N=app.activities.size();
    for (int j=0; j < N; j++) {
      if (app.activities.get(j).visible) {
        app.hidden=false;
        adj=VISIBLE_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.adjType=""String_Node_Str"";
        break;
      }
    }
  }
 else {
    app.hidden=true;
    app.empty=true;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=hiddenAdj;
    app.adjType=""String_Node_Str"";
  }
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=BACKUP_APP_ADJ;
      app.adjType=""String_Node_Str"";
      app.hidden=false;
    }
  }
  if (app.services.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    final long now=SystemClock.uptimeMillis();
    Iterator<ServiceRecord> jt=app.services.iterator();
    while (jt.hasNext() && adj > FOREGROUND_APP_ADJ) {
      ServiceRecord s=jt.next();
      if (s.startRequested) {
        if (now < (s.lastActivity + MAX_SERVICE_INACTIVITY)) {
          if (adj > SECONDARY_SERVER_ADJ) {
            adj=SECONDARY_SERVER_ADJ;
            app.adjType=""String_Node_Str"";
            app.hidden=false;
          }
        }
        if (adj > SECONDARY_SERVER_ADJ) {
          app.adjType=""String_Node_Str"";
        }
        app.keeping=true;
      }
      if (s.connections.size() > 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
        Iterator<ArrayList<ConnectionRecord>> kt=s.connections.values().iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ArrayList<ConnectionRecord> clist=kt.next();
          for (int i=0; i < clist.size() && adj > FOREGROUND_APP_ADJ; i++) {
            ConnectionRecord cr=clist.get(i);
            if (cr.binding.client == app) {
              continue;
            }
            if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
              ProcessRecord client=cr.binding.client;
              int myHiddenAdj=hiddenAdj;
              if (myHiddenAdj > client.hiddenAdj) {
                if (client.hiddenAdj >= VISIBLE_APP_ADJ) {
                  myHiddenAdj=client.hiddenAdj;
                }
 else {
                  myHiddenAdj=VISIBLE_APP_ADJ;
                }
              }
              int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
              if (adj > clientAdj) {
                adj=clientAdj >= VISIBLE_APP_ADJ ? clientAdj : VISIBLE_APP_ADJ;
                if (!client.hidden) {
                  app.hidden=false;
                }
                if (client.keeping) {
                  app.keeping=true;
                }
                app.adjType=""String_Node_Str"";
                app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                app.adjSource=cr.binding.client;
                app.adjTarget=s.name;
              }
              if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                  schedGroup=Process.THREAD_GROUP_DEFAULT;
                }
              }
            }
            ActivityRecord a=cr.activity;
            if (a != null && adj > FOREGROUND_APP_ADJ && (a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
              adj=FOREGROUND_APP_ADJ;
              schedGroup=Process.THREAD_GROUP_DEFAULT;
              app.hidden=false;
              app.adjType=""String_Node_Str"";
              app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
              app.adjSource=a;
              app.adjTarget=s.name;
            }
          }
        }
      }
    }
    if (adj > hiddenAdj) {
      adj=hiddenAdj;
      app.hidden=false;
      app.adjType=""String_Node_Str"";
    }
  }
  if (app.pubProviders.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    Iterator<ContentProviderRecord> jt=app.pubProviders.values().iterator();
    while (jt.hasNext() && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
      ContentProviderRecord cpr=jt.next();
      if (cpr.clients.size() != 0) {
        Iterator<ProcessRecord> kt=cpr.clients.iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ProcessRecord client=kt.next();
          if (client == app) {
            continue;
          }
          int myHiddenAdj=hiddenAdj;
          if (myHiddenAdj > client.hiddenAdj) {
            if (client.hiddenAdj > FOREGROUND_APP_ADJ) {
              myHiddenAdj=client.hiddenAdj;
            }
 else {
              myHiddenAdj=FOREGROUND_APP_ADJ;
            }
          }
          int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
          if (adj > clientAdj) {
            adj=clientAdj > FOREGROUND_APP_ADJ ? clientAdj : FOREGROUND_APP_ADJ;
            if (!client.hidden) {
              app.hidden=false;
            }
            if (client.keeping) {
              app.keeping=true;
            }
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
            app.adjSource=client;
            app.adjTarget=cpr.name;
          }
          if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
            schedGroup=Process.THREAD_GROUP_DEFAULT;
          }
        }
      }
      if (cpr.externals != 0) {
        if (adj > FOREGROUND_APP_ADJ) {
          adj=FOREGROUND_APP_ADJ;
          schedGroup=Process.THREAD_GROUP_DEFAULT;
          app.hidden=false;
          app.keeping=true;
          app.adjType=""String_Node_Str"";
          app.adjTarget=cpr.name;
        }
      }
    }
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < HIDDEN_APP_MIN_ADJ) {
    app.keeping=true;
  }
  app.curAdj=adj;
  app.curSchedGroup=schedGroup;
  return adj;
}","private final int computeOomAdjLocked(ProcessRecord app,int hiddenAdj,ProcessRecord TOP_APP,boolean recursed){
  if (mAdjSeq == app.adjSeq) {
    if (!recursed && app.hidden) {
      app.curAdj=hiddenAdj;
    }
    return app.curAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    return (app.curAdj=EMPTY_APP_ADJ);
  }
  if (app.maxAdj <= FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    return (app.curAdj=app.maxAdj);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.keeping=false;
  app.empty=false;
  app.hidden=false;
  int adj;
  int schedGroup;
  int N;
  if (app == TOP_APP) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.instrumentationClass != null) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.curReceiver != null || (mPendingBroadcast != null && mPendingBroadcast.curApp == app)) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.executingServices.size() > 0) {
    adj=FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.foregroundServices) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app.forcingToForeground != null) {
    adj=PERCEPTIBLE_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    app.adjSource=app.forcingToForeground;
  }
 else   if (app == mHeavyWeightProcess) {
    adj=HEAVY_WEIGHT_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
  }
 else   if (app == mHomeProcess) {
    adj=HOME_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
  }
 else   if ((N=app.activities.size()) != 0) {
    app.hidden=true;
    adj=hiddenAdj;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    N=app.activities.size();
    for (int j=0; j < N; j++) {
      if (app.activities.get(j).visible) {
        app.hidden=false;
        adj=VISIBLE_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.adjType=""String_Node_Str"";
        break;
      }
    }
  }
 else {
    app.hidden=true;
    app.empty=true;
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=hiddenAdj;
    app.adjType=""String_Node_Str"";
  }
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=BACKUP_APP_ADJ;
      app.adjType=""String_Node_Str"";
      app.hidden=false;
    }
  }
  if (app.services.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    final long now=SystemClock.uptimeMillis();
    Iterator<ServiceRecord> jt=app.services.iterator();
    while (jt.hasNext() && adj > FOREGROUND_APP_ADJ) {
      ServiceRecord s=jt.next();
      if (s.startRequested) {
        if (now < (s.lastActivity + MAX_SERVICE_INACTIVITY)) {
          if (adj > SECONDARY_SERVER_ADJ) {
            adj=SECONDARY_SERVER_ADJ;
            app.adjType=""String_Node_Str"";
            app.hidden=false;
          }
        }
        if (adj > SECONDARY_SERVER_ADJ) {
          app.adjType=""String_Node_Str"";
        }
        app.keeping=true;
      }
      if (s.connections.size() > 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
        Iterator<ArrayList<ConnectionRecord>> kt=s.connections.values().iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ArrayList<ConnectionRecord> clist=kt.next();
          for (int i=0; i < clist.size() && adj > FOREGROUND_APP_ADJ; i++) {
            ConnectionRecord cr=clist.get(i);
            if (cr.binding.client == app) {
              continue;
            }
            if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
              ProcessRecord client=cr.binding.client;
              int myHiddenAdj=hiddenAdj;
              if (myHiddenAdj > client.hiddenAdj) {
                if (client.hiddenAdj >= VISIBLE_APP_ADJ) {
                  myHiddenAdj=client.hiddenAdj;
                }
 else {
                  myHiddenAdj=VISIBLE_APP_ADJ;
                }
              }
              int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
              if (adj > clientAdj) {
                adj=clientAdj >= VISIBLE_APP_ADJ ? clientAdj : VISIBLE_APP_ADJ;
                if (!client.hidden) {
                  app.hidden=false;
                }
                if (client.keeping) {
                  app.keeping=true;
                }
                app.adjType=""String_Node_Str"";
                app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                app.adjSource=cr.binding.client;
                app.adjTarget=s.name;
              }
              if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                  schedGroup=Process.THREAD_GROUP_DEFAULT;
                }
              }
            }
            ActivityRecord a=cr.activity;
            if (a != null && adj > FOREGROUND_APP_ADJ && (a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
              adj=FOREGROUND_APP_ADJ;
              schedGroup=Process.THREAD_GROUP_DEFAULT;
              app.hidden=false;
              app.adjType=""String_Node_Str"";
              app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
              app.adjSource=a;
              app.adjTarget=s.name;
            }
          }
        }
      }
    }
    if (adj > hiddenAdj) {
      adj=hiddenAdj;
      app.hidden=false;
      app.adjType=""String_Node_Str"";
    }
  }
  if (app.pubProviders.size() != 0 && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
    Iterator<ContentProviderRecord> jt=app.pubProviders.values().iterator();
    while (jt.hasNext() && (adj > FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE)) {
      ContentProviderRecord cpr=jt.next();
      if (cpr.clients.size() != 0) {
        Iterator<ProcessRecord> kt=cpr.clients.iterator();
        while (kt.hasNext() && adj > FOREGROUND_APP_ADJ) {
          ProcessRecord client=kt.next();
          if (client == app) {
            continue;
          }
          int myHiddenAdj=hiddenAdj;
          if (myHiddenAdj > client.hiddenAdj) {
            if (client.hiddenAdj > FOREGROUND_APP_ADJ) {
              myHiddenAdj=client.hiddenAdj;
            }
 else {
              myHiddenAdj=FOREGROUND_APP_ADJ;
            }
          }
          int clientAdj=computeOomAdjLocked(client,myHiddenAdj,TOP_APP,true);
          if (adj > clientAdj) {
            adj=clientAdj > FOREGROUND_APP_ADJ ? clientAdj : FOREGROUND_APP_ADJ;
            if (!client.hidden) {
              app.hidden=false;
            }
            if (client.keeping) {
              app.keeping=true;
            }
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
            app.adjSource=client;
            app.adjTarget=cpr.name;
          }
          if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
            schedGroup=Process.THREAD_GROUP_DEFAULT;
          }
        }
      }
      if (cpr.externals != 0) {
        if (adj > FOREGROUND_APP_ADJ) {
          adj=FOREGROUND_APP_ADJ;
          schedGroup=Process.THREAD_GROUP_DEFAULT;
          app.hidden=false;
          app.keeping=true;
          app.adjType=""String_Node_Str"";
          app.adjTarget=cpr.name;
        }
      }
    }
  }
  app.curRawAdj=adj;
  if (adj > app.maxAdj) {
    adj=app.maxAdj;
    if (app.maxAdj <= PERCEPTIBLE_APP_ADJ) {
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (adj < HIDDEN_APP_MIN_ADJ) {
    app.keeping=true;
  }
  app.curAdj=adj;
  app.curSchedGroup=schedGroup;
  return adj;
}",0.9909460243760884
181303,"final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          Process.killProcess(app.pid);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          if (app.persistent) {
            addAppLocked(app.info);
          }
        }
      }
    }
    if (!updateOomAdjLocked()) {
      int numServiceProcs=0;
      for (i=mLruProcesses.size() - 1; i >= 0; i--) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (app.persistent || app.services.size() != 0 || app.curReceiver != null || app.persistentActivities > 0) {
          if (localLOGV)           Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.services);
          numServiceProcs++;
        }
      }
      int curMaxProcs=mProcessLimit;
      if (curMaxProcs <= 0)       curMaxProcs=MAX_PROCESSES;
      if (mAlwaysFinishActivities) {
        curMaxProcs=1;
      }
      curMaxProcs+=numServiceProcs;
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (!app.persistent && app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
      if (Config.LOGV)       Slog.v(TAG,""String_Node_Str"" + mLruProcesses.size() + ""String_Node_Str""+ curMaxProcs+ ""String_Node_Str"");
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        boolean canQuit=!app.persistent && app.curReceiver == null && app.services.size() == 0 && app.persistentActivities == 0;
        int NUMA=app.activities.size();
        int j;
        if (Config.LOGV)         Slog.v(TAG,""String_Node_Str"" + app.processName);
        for (j=0; j < NUMA && canQuit; j++) {
          ActivityRecord r=app.activities.get(j);
          if (Config.LOGV)           Slog.v(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.visible);
          canQuit=(r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped;
        }
        if (canQuit) {
          for (j=0; j < NUMA; j++) {
            ActivityRecord r=app.activities.get(j);
            if (!r.finishing) {
              r.stack.destroyActivityLocked(r,false);
            }
            r.resultTo=null;
          }
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
    }
    int curMaxActivities=MAX_ACTIVITIES;
    if (mAlwaysFinishActivities) {
      curMaxActivities=1;
    }
    for (i=0; i < mMainStack.mLRUActivities.size() && mMainStack.mLRUActivities.size() > curMaxActivities; i++) {
      final ActivityRecord r=(ActivityRecord)mMainStack.mLRUActivities.get(i);
      if ((r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped&& !r.persistent&& !r.finishing) {
        final int origSize=mMainStack.mLRUActivities.size();
        r.stack.destroyActivityLocked(r,true);
        if (origSize > mMainStack.mLRUActivities.size()) {
          i--;
        }
      }
    }
  }
}","final void trimApplications(){
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
        if (app.pid > 0 && app.pid != MY_PID) {
          Process.killProcess(app.pid);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          if (app.persistent) {
            addAppLocked(app.info);
          }
        }
      }
    }
    if (!updateOomAdjLocked()) {
      int numServiceProcs=0;
      for (i=mLruProcesses.size() - 1; i >= 0; i--) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (app.persistent || app.services.size() != 0 || app.curReceiver != null) {
          if (localLOGV)           Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ app.services);
          numServiceProcs++;
        }
      }
      int curMaxProcs=mProcessLimit;
      if (curMaxProcs <= 0)       curMaxProcs=MAX_PROCESSES;
      if (mAlwaysFinishActivities) {
        curMaxProcs=1;
      }
      curMaxProcs+=numServiceProcs;
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (!app.persistent && app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
      if (Config.LOGV)       Slog.v(TAG,""String_Node_Str"" + mLruProcesses.size() + ""String_Node_Str""+ curMaxProcs+ ""String_Node_Str"");
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        boolean canQuit=!app.persistent && app.curReceiver == null && app.services.size() == 0;
        int NUMA=app.activities.size();
        int j;
        if (Config.LOGV)         Slog.v(TAG,""String_Node_Str"" + app.processName);
        for (j=0; j < NUMA && canQuit; j++) {
          ActivityRecord r=app.activities.get(j);
          if (Config.LOGV)           Slog.v(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString() + ""String_Node_Str""+ r.haveState+ ""String_Node_Str""+ r.visible);
          canQuit=(r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped;
        }
        if (canQuit) {
          for (j=0; j < NUMA; j++) {
            ActivityRecord r=app.activities.get(j);
            if (!r.finishing) {
              r.stack.destroyActivityLocked(r,false);
            }
            r.resultTo=null;
          }
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ (app.thread != null ? app.thread.asBinder() : null)+ ""String_Node_Str"");
          if (app.pid > 0 && app.pid != MY_PID) {
            Process.killProcess(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
    }
    int curMaxActivities=MAX_ACTIVITIES;
    if (mAlwaysFinishActivities) {
      curMaxActivities=1;
    }
    for (i=0; i < mMainStack.mLRUActivities.size() && mMainStack.mLRUActivities.size() > curMaxActivities; i++) {
      final ActivityRecord r=(ActivityRecord)mMainStack.mLRUActivities.get(i);
      if ((r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped&& !r.finishing) {
        final int origSize=mMainStack.mLRUActivities.size();
        r.stack.destroyActivityLocked(r,true);
        if (origSize > mMainStack.mLRUActivities.size()) {
          i--;
        }
      }
    }
  }
}",0.990974930362117
181304,"ActivityRecord(ActivityManagerService _service,ActivityStack _stack,ProcessRecord _caller,int _launchedFromUid,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified){
  service=_service;
  stack=_stack;
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  haveState=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  persistent=false;
  visible=true;
  waitingVisible=false;
  nowVisible=false;
  thumbnailNeeded=false;
  idle=false;
  hasBeenLaunched=false;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    baseDir=aInfo.applicationInfo.sourceDir;
    resDir=aInfo.applicationInfo.publicSourceDir;
    dataDir=aInfo.applicationInfo.dataDir;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    theme=aInfo.getThemeResource();
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,theme != 0 ? theme : android.R.style.Theme,com.android.internal.R.styleable.Window);
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false);
    if (!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) {
      if (Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME) && _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !""String_Node_Str"".equals(realActivity.getClassName())) {
        isHomeActivity=true;
      }
 else {
        isHomeActivity=false;
      }
    }
 else {
      isHomeActivity=false;
    }
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    baseDir=null;
    resDir=null;
    dataDir=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    isHomeActivity=false;
  }
}","ActivityRecord(ActivityManagerService _service,ActivityStack _stack,ProcessRecord _caller,int _launchedFromUid,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified){
  service=_service;
  stack=_stack;
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  configuration=_configuration;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  haveState=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=true;
  waitingVisible=false;
  nowVisible=false;
  thumbnailNeeded=false;
  idle=false;
  hasBeenLaunched=false;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    baseDir=aInfo.applicationInfo.sourceDir;
    resDir=aInfo.applicationInfo.publicSourceDir;
    dataDir=aInfo.applicationInfo.dataDir;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    theme=aInfo.getThemeResource();
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,theme != 0 ? theme : android.R.style.Theme,com.android.internal.R.styleable.Window);
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false);
    if (!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) {
      if (Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME) && _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !""String_Node_Str"".equals(realActivity.getClassName())) {
        isHomeActivity=true;
      }
 else {
        isHomeActivity=false;
      }
    }
 else {
      isHomeActivity=false;
    }
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    baseDir=null;
    resDir=null;
    dataDir=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    isHomeActivity=false;
  }
}",0.9971767363071712
181305,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(baseDir);
  if (!resDir.equals(baseDir))   pw.print(""String_Node_Str"");
  pw.print(resDir);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingResults);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(launchTime,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(startTime,pw);
    pw.println(""String_Node_Str"");
  }
  if (waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.println(nowVisible);
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(baseDir);
  if (!resDir.equals(baseDir))   pw.print(""String_Node_Str"");
  pw.print(resDir);
  pw.print(""String_Node_Str"");
  pw.println(dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(isHomeActivity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingResults);
  }
  if (uriPermissions != null) {
    if (uriPermissions.readUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.readUriPermissions);
    }
    if (uriPermissions.writeUriPermissions != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(uriPermissions.writeUriPermissions);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.print(thumbnailNeeded);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  if (launchTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(launchTime,pw);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(startTime,pw);
    pw.println(""String_Node_Str"");
  }
  if (waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.println(nowVisible);
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}",0.9930756641067606
181306,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mService.mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mService.mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  int changes=oldConfig.diff(newConfig);
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
  }
  if ((changes & (~r.info.configChanges)) != 0) {
    r.configChangeFlags|=changes;
    r.startFreezingScreenLocked(r.app,globalChanges);
    if (r.app == null || r.app.thread == null) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      destroyActivityLocked(r,true);
    }
 else     if (r.state == ActivityState.PAUSING) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.configDestroy=true;
      return true;
    }
 else     if (r.state == ActivityState.RESUMED) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,true);
      r.configChangeFlags=0;
    }
 else {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,false);
      r.configChangeFlags=0;
    }
    return false;
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9751191106405506
181307,"/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.persistent) {
        mService.decPersistentCountLocked(r.app);
      }
      if (r.app.activities.size() == 0) {
        mService.updateLruProcessLocked(r.app,true,false);
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.app=null;
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}","/** 
 * Destroy the current CLIENT SIDE instance of an activity.  This may be called both when actually finishing an activity, or when performing a configuration switch where we destroy the current client-side object but then create a new client-side object for this same HistoryRecord.
 */
final boolean destroyActivityLocked(ActivityRecord r,boolean removeFromApp){
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ (r.app != null ? r.app.processName : ""String_Node_Str""));
  EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  boolean removedFromHistory=false;
  cleanUpActivityLocked(r,false);
  final boolean hadApp=r.app != null;
  if (hadApp) {
    if (removeFromApp) {
      int idx=r.app.activities.indexOf(r);
      if (idx >= 0) {
        r.app.activities.remove(idx);
      }
      if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
        mService.mHeavyWeightProcess=null;
        mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
      }
      if (r.app.activities.size() == 0) {
        mService.updateLruProcessLocked(r.app,true,false);
      }
    }
    boolean skipDestroy=false;
    try {
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleDestroyActivity(r,r.finishing,r.configChangeFlags);
    }
 catch (    Exception e) {
      if (r.finishing) {
        removeActivityFromHistoryLocked(r);
        removedFromHistory=true;
        skipDestroy=true;
      }
    }
    r.app=null;
    r.nowVisible=false;
    if (r.finishing && !skipDestroy) {
      r.state=ActivityState.DESTROYING;
      Message msg=mHandler.obtainMessage(DESTROY_TIMEOUT_MSG);
      msg.obj=r;
      mHandler.sendMessageDelayed(msg,DESTROY_TIMEOUT);
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
 else {
    if (r.finishing) {
      removeActivityFromHistoryLocked(r);
      removedFromHistory=true;
    }
 else {
      r.state=ActivityState.DESTROYED;
    }
  }
  r.configChangeFlags=0;
  if (!mLRUActivities.remove(r) && hadApp) {
    Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
  }
  return removedFromHistory;
}",0.9815627743634768
181308,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.println(lruSeq);
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastActivityTime,now,pw);
  pw.print(""String_Node_Str"");
  pw.print(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(keeping);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.println(removed);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(adjSeq);
  pw.print(""String_Node_Str"");
  pw.println(lruSeq);
  if (!keeping) {
    long wtime;
synchronized (batteryStats.getBatteryStats()) {
      wtime=batteryStats.getBatteryStats().getProcessWakeTime(info.uid,pid,SystemClock.elapsedRealtime());
    }
    long timeUsed=wtime - lastWakeTime;
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastWakeTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(timeUsed,pw);
    pw.println(""String_Node_Str"");
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(lastCpuTime);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(curCpuTime - lastCpuTime,pw);
    pw.println(""String_Node_Str"");
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastRequestedGc,now,pw);
  pw.print(""String_Node_Str"");
  TimeUtils.formatDuration(lastLowMemory,now,pw);
  pw.print(""String_Node_Str"");
  pw.println(reportLowMemory);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.993503436587892
181309,"ProcessRecord(BatteryStatsImpl.Uid.Proc _batteryStats,IApplicationThread _thread,ApplicationInfo _info,String _processName){
  batteryStats=_batteryStats;
  info=_info;
  processName=_processName;
  pkgList.add(_info.packageName);
  thread=_thread;
  maxAdj=ActivityManagerService.EMPTY_APP_ADJ;
  hiddenAdj=ActivityManagerService.HIDDEN_APP_MIN_ADJ;
  curRawAdj=setRawAdj=-100;
  curAdj=setAdj=-100;
  persistent=false;
  removed=false;
  persistentActivities=0;
}","ProcessRecord(BatteryStatsImpl.Uid.Proc _batteryStats,IApplicationThread _thread,ApplicationInfo _info,String _processName){
  batteryStats=_batteryStats;
  info=_info;
  processName=_processName;
  pkgList.add(_info.packageName);
  thread=_thread;
  maxAdj=ActivityManagerService.EMPTY_APP_ADJ;
  hiddenAdj=ActivityManagerService.HIDDEN_APP_MIN_ADJ;
  curRawAdj=setRawAdj=-100;
  curAdj=setAdj=-100;
  persistent=false;
  removed=false;
}",0.9712389380530974
181310,"public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + processName);
  pw.println(prefix + ""String_Node_Str"" + taskAffinity);
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ Integer.toHexString(theme));
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  if (!sourceDir.equals(publicSourceDir)) {
    pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  }
  if (resourceDirs != null) {
    pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  }
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}","public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + processName);
  pw.println(prefix + ""String_Node_Str"" + taskAffinity);
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ Integer.toHexString(theme));
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  if (sourceDir == null) {
    if (publicSourceDir != null) {
      pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
    }
  }
 else   if (!sourceDir.equals(publicSourceDir)) {
    pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  }
  if (resourceDirs != null) {
    pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  }
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}",0.8745332337565347
181311,"public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + processName);
  pw.println(prefix + ""String_Node_Str"" + taskAffinity);
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ Integer.toHexString(theme));
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  if (!sourceDir.equals(publicSourceDir)) {
    pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  }
  if (resourceDirs != null) {
    pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  }
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}","public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + processName);
  pw.println(prefix + ""String_Node_Str"" + taskAffinity);
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ Integer.toHexString(theme));
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  if (sourceDir == null) {
    if (publicSourceDir != null) {
      pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
    }
  }
 else   if (!sourceDir.equals(publicSourceDir)) {
    pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  }
  if (resourceDirs != null) {
    pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  }
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}",0.8745332337565347
181312,"public HandleView(CursorController controller,Drawable handle){
  super(TextView.this.mContext);
  mController=controller;
  mDrawable=handle;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  mHotspotX=mDrawable.getIntrinsicWidth() * 0.5f;
  mHotspotY=-mDrawable.getIntrinsicHeight() * 0.2f;
}","public HandleView(CursorController controller,Drawable handle){
  super(TextView.this.mContext);
  mController=controller;
  mDrawable=handle;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  final int handleWidth=mDrawable.getIntrinsicWidth();
  final int handleHeight=mDrawable.getIntrinsicHeight();
  mHotspotX=handleWidth * 0.5f;
  mHotspotY=-handleHeight * 0.2f;
}",0.8104166666666667
181313,"private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionInBounds()) {
    if (mContainer.isShowing()) {
      final int[] coords=mTempCoords;
      TextView.this.getLocationInWindow(coords);
      coords[0]+=mPositionX;
      coords[1]+=mPositionY;
      mContainer.update(coords[0],coords[1],mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
  }
 else {
    hide();
  }
}","private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionVisible()) {
    int[] coords=null;
    if (mContainer.isShowing()) {
      coords=mTempCoords;
      TextView.this.getLocationInWindow(coords);
      mContainer.update(coords[0] + mPositionX,coords[1] + mPositionY,mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
    if (mIsDragging) {
      if (coords == null) {
        coords=mTempCoords;
        TextView.this.getLocationInWindow(coords);
      }
      if (coords[0] != mLastParentX || coords[1] != mLastParentY) {
        mOffsetX+=coords[0] - mLastParentX;
        mOffsetY+=coords[1] - mLastParentY;
        mLastParentX=coords[0];
        mLastParentY=coords[1];
      }
    }
  }
 else {
    hide();
  }
}",0.4945226917057903
181314,"private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getWidth() - getWidth() - mPaddingLeft- mPaddingRight);
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getWidth() - (getWidth() - mPaddingLeft - mPaddingRight));
  }
  return scrollRange;
}",0.9934065934065934
181315,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      mIsBeingDragged=true;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9869433017349312
181316,"private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getHeight() - getHeight() - mPaddingBottom- mPaddingTop);
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getHeight() - (getHeight() - mPaddingBottom - mPaddingTop));
  }
  return scrollRange;
}",0.9934640522875816
181317,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      mIsBeingDragged=true;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.986952636282395
181318,"private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getWidth() - getWidth() - mPaddingLeft- mPaddingRight);
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getWidth() - (getWidth() - mPaddingLeft - mPaddingRight));
  }
  return scrollRange;
}",0.9934065934065934
181319,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      mIsBeingDragged=true;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9869433017349312
181320,"private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getHeight() - getHeight() - mPaddingBottom- mPaddingTop);
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  if (getChildCount() > 0) {
    View child=getChildAt(0);
    scrollRange=Math.max(0,child.getHeight() - (getHeight() - mPaddingBottom - mPaddingTop));
  }
  return scrollRange;
}",0.9934640522875816
181321,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      mIsBeingDragged=true;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.986952636282395
181322,"@Override protected void onFocusChanged(boolean focused,int direction,Rect previouslyFocusedRect){
  if (mTemporaryDetach) {
    super.onFocusChanged(focused,direction,previouslyFocusedRect);
    return;
  }
  mShowCursor=SystemClock.uptimeMillis();
  ensureEndedBatchEdit();
  if (focused) {
    int selStart=getSelectionStart();
    int selEnd=getSelectionEnd();
    if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
      if (mLastTouchOffset >= 0) {
        mLastTouchOffset=Math.min(mLastTouchOffset,mText.length());
        Selection.setSelection((Spannable)mText,mLastTouchOffset);
      }
      if (mMovement != null) {
        mMovement.onTakeFocus(this,(Spannable)mText,direction);
      }
      if (mSelectAllOnFocus) {
        Selection.setSelection((Spannable)mText,0,mText.length());
      }
      if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
        Selection.setSelection((Spannable)mText,selStart,selEnd);
      }
      mTouchFocusSelected=true;
    }
    mFrozenWithFocus=false;
    mSelectionMoved=false;
    if (mText instanceof Spannable) {
      Spannable sp=(Spannable)mText;
      MetaKeyKeyListener.resetMetaState(sp);
    }
    makeBlink();
    if (mError != null) {
      showError();
    }
  }
 else {
    if (mError != null) {
      hideError();
    }
    onEndBatchEdit();
    hideInsertionPointCursorController();
    if (this instanceof ExtractEditText) {
      mIsInTextSelectionMode=false;
    }
 else {
      terminateTextSelectionMode();
    }
  }
  startStopMarquee(focused);
  if (mTransformation != null) {
    mTransformation.onFocusChanged(this,mText,focused,direction,previouslyFocusedRect);
  }
  super.onFocusChanged(focused,direction,previouslyFocusedRect);
}","@Override protected void onFocusChanged(boolean focused,int direction,Rect previouslyFocusedRect){
  if (mTemporaryDetach) {
    super.onFocusChanged(focused,direction,previouslyFocusedRect);
    return;
  }
  mShowCursor=SystemClock.uptimeMillis();
  ensureEndedBatchEdit();
  if (focused) {
    int selStart=getSelectionStart();
    int selEnd=getSelectionEnd();
    if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
      if (mLastTouchOffset >= 0) {
        mLastTouchOffset=Math.min(mLastTouchOffset,mText.length());
        Selection.setSelection((Spannable)mText,mLastTouchOffset);
      }
      if (mMovement != null) {
        mMovement.onTakeFocus(this,(Spannable)mText,direction);
      }
      if (mSelectAllOnFocus) {
        Selection.setSelection((Spannable)mText,0,mText.length());
      }
      if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
        Selection.setSelection((Spannable)mText,selStart,selEnd);
      }
      mTouchFocusSelected=true;
    }
    mFrozenWithFocus=false;
    mSelectionMoved=false;
    if (mText instanceof Spannable) {
      Spannable sp=(Spannable)mText;
      MetaKeyKeyListener.resetMetaState(sp);
    }
    makeBlink();
    if (mError != null) {
      showError();
    }
  }
 else {
    if (mError != null) {
      hideError();
    }
    onEndBatchEdit();
    hideInsertionPointCursorController();
    if (this instanceof ExtractEditText) {
      mIsInTextSelectionMode=false;
    }
 else {
      terminateTextSelectionMode();
    }
    mLastTouchOffset=-1;
  }
  startStopMarquee(focused);
  if (mTransformation != null) {
    mTransformation.onFocusChanged(this,mText,focused,direction,previouslyFocusedRect);
  }
  super.onFocusChanged(focused,direction,previouslyFocusedRect);
}",0.9929478138222848
181323,"@Override public boolean onKeyShortcut(int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_A:
    if (canSelectAll()) {
      return onTextContextMenuItem(ID_SELECT_ALL);
    }
  break;
case KeyEvent.KEYCODE_X:
if (canCut()) {
  return onTextContextMenuItem(ID_CUT);
}
break;
case KeyEvent.KEYCODE_C:
if (canCopy()) {
return onTextContextMenuItem(ID_COPY);
}
break;
case KeyEvent.KEYCODE_V:
if (canPaste()) {
return onTextContextMenuItem(ID_PASTE);
}
break;
}
return super.onKeyShortcut(keyCode,event);
}","@Override public boolean onKeyShortcut(int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_A:
    if (canSelectText()) {
      return onTextContextMenuItem(ID_SELECT_ALL);
    }
  break;
case KeyEvent.KEYCODE_X:
if (canCut()) {
  return onTextContextMenuItem(ID_CUT);
}
break;
case KeyEvent.KEYCODE_C:
if (canCopy()) {
return onTextContextMenuItem(ID_COPY);
}
break;
case KeyEvent.KEYCODE_V:
if (canPaste()) {
return onTextContextMenuItem(ID_PASTE);
}
break;
}
return super.onKeyShortcut(keyCode,event);
}",0.9933014354066986
181324,"private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (canSelectText() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.9747292418772564
181325,"private boolean canSelectText(){
  return (mText instanceof Spannable && mMovement != null && mMovement.canSelectArbitrarily());
}","private boolean canSelectText(){
  return textCanBeSelected() && mText.length() != 0;
}",0.5529953917050692
181326,"@Override protected void onCreateContextMenu(ContextMenu menu){
  super.onCreateContextMenu(menu);
  boolean added=false;
  if (mIsInTextSelectionMode) {
    MenuHandler handler=new MenuHandler();
    if (canCut()) {
      menu.add(0,ID_CUT,0,com.android.internal.R.string.cut).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
      added=true;
    }
    if (canCopy()) {
      menu.add(0,ID_COPY,0,com.android.internal.R.string.copy).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
      added=true;
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
  }
 else {
    MenuHandler handler=new MenuHandler();
    if (canSelectText()) {
      menu.add(0,ID_START_SELECTING_TEXT,0,com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
      added=true;
    }
    if (canSelectAll()) {
      menu.add(0,ID_SELECT_ALL,0,com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
      added=true;
    }
    if (mText instanceof Spanned) {
      int selStart=getSelectionStart();
      int selEnd=getSelectionEnd();
      int min=Math.min(selStart,selEnd);
      int max=Math.max(selStart,selEnd);
      URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
      if (urls.length == 1) {
        menu.add(0,ID_COPY_URL,0,com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
        added=true;
      }
    }
    if (canPaste() && textIsOnlySpaces()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
    if (isInputMethodTarget()) {
      menu.add(1,ID_SWITCH_INPUT_METHOD,0,com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
      added=true;
    }
    String word=getWordForDictionary();
    if (word != null) {
      menu.add(1,ID_ADD_TO_DICTIONARY,0,getContext().getString(com.android.internal.R.string.addToDictionary,word)).setOnMenuItemClickListener(handler);
      added=true;
    }
  }
  if (added) {
    menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
  }
}","@Override protected void onCreateContextMenu(ContextMenu menu){
  super.onCreateContextMenu(menu);
  boolean added=false;
  if (mIsInTextSelectionMode) {
    MenuHandler handler=new MenuHandler();
    if (canCut()) {
      menu.add(0,ID_CUT,0,com.android.internal.R.string.cut).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
      added=true;
    }
    if (canCopy()) {
      menu.add(0,ID_COPY,0,com.android.internal.R.string.copy).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
      added=true;
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
  }
 else {
    MenuHandler handler=new MenuHandler();
    if (canSelectText()) {
      menu.add(0,ID_START_SELECTING_TEXT,0,com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
      menu.add(0,ID_SELECT_ALL,0,com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
      added=true;
    }
    if (mText instanceof Spanned) {
      int selStart=getSelectionStart();
      int selEnd=getSelectionEnd();
      int min=Math.min(selStart,selEnd);
      int max=Math.max(selStart,selEnd);
      URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
      if (urls.length == 1) {
        menu.add(0,ID_COPY_URL,0,com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
        added=true;
      }
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
    if (isInputMethodTarget()) {
      menu.add(1,ID_SWITCH_INPUT_METHOD,0,com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
      added=true;
    }
    String word=getWordForDictionary();
    if (word != null) {
      menu.add(1,ID_ADD_TO_DICTIONARY,0,getContext().getString(com.android.internal.R.string.addToDictionary,word)).setOnMenuItemClickListener(handler);
      added=true;
    }
  }
  if (added) {
    menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
  }
}",0.9839715048975958
181327,"public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      notifyDateChanged();
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  String[] months=dfs.getShortMonths();
  if (months[0].startsWith(""String_Node_Str"")) {
    for (int i=0; i < months.length; i++) {
      months[i]=String.valueOf(i + 1);
    }
  }
  mMonthPicker.setRange(1,12,months);
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      adjustMaxDay();
      notifyDateChanged();
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      adjustMaxDay();
      notifyDateChanged();
      updateDaySpinner();
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers(months);
  if (!isEnabled()) {
    setEnabled(false);
  }
}","public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      notifyDateChanged();
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  String[] months=dfs.getShortMonths();
  if (months[0].startsWith(""String_Node_Str"")) {
    for (int i=0; i < months.length; i++) {
      months[i]=String.valueOf(i + 1);
    }
    mMonthPicker.setRange(1,12);
  }
 else {
    mMonthPicker.setRange(1,12,months);
  }
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      adjustMaxDay();
      notifyDateChanged();
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      adjustMaxDay();
      notifyDateChanged();
      updateDaySpinner();
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers(months);
  if (!isEnabled()) {
    setEnabled(false);
  }
}",0.9889020070838253
181328,"/** 
 * Set the range of numbers allowed for the number picker. The current value will be automatically set to the start. Also provide a mapping for values used to display to the user.
 * @param start the start of the range (inclusive)
 * @param end the end of the range (inclusive)
 * @param displayedValues the values displayed to the user.
 */
public void setRange(int start,int end,String[] displayedValues){
  mDisplayedValues=displayedValues;
  mStart=start;
  mEnd=end;
  mCurrent=start;
  updateView();
}","/** 
 * Set the range of numbers allowed for the number picker. The current value will be automatically set to the start. Also provide a mapping for values used to display to the user.
 * @param start the start of the range (inclusive)
 * @param end the end of the range (inclusive)
 * @param displayedValues the values displayed to the user.
 */
public void setRange(int start,int end,String[] displayedValues){
  mDisplayedValues=displayedValues;
  mStart=start;
  mEnd=end;
  mCurrent=start;
  updateView();
  if (displayedValues != null) {
    mText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
  }
}",0.88504753673293
181329,"@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  mTemporaryDetach=false;
  if (mShowErrorAfterAttach) {
    showError();
    mShowErrorAfterAttach=false;
  }
}","@Override protected void onAttachedToWindow(){
  super.onAttachedToWindow();
  mTemporaryDetach=false;
  if (mShowErrorAfterAttach) {
    showError();
    mShowErrorAfterAttach=false;
  }
  final ViewTreeObserver observer=getViewTreeObserver();
  if (observer != null) {
    if (mInsertionPointCursorController != null) {
      observer.addOnTouchModeChangeListener(mInsertionPointCursorController);
    }
    if (mSelectionModifierCursorController != null) {
      observer.addOnTouchModeChangeListener(mSelectionModifierCursorController);
    }
  }
}",0.5101214574898786
181330,"@Override protected void onVisibilityChanged(View changedView,int visibility){
  super.onVisibilityChanged(changedView,visibility);
  if (visibility != VISIBLE) {
    hideControllers();
  }
}","@Override protected void onVisibilityChanged(View changedView,int visibility){
  super.onVisibilityChanged(changedView,visibility);
  if (visibility != VISIBLE) {
    hideInsertionPointCursorController();
    if (mSelectionModifierCursorController != null) {
      mSelectionModifierCursorController.hide();
    }
  }
}",0.7058823529411765
181331,"private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      showContextMenu();
      return;
    }
 else {
      stopTextSelectionMode();
      if (mInsertionPointCursorController != null) {
        mInsertionPointCursorController.show();
      }
    }
  }
}","private void onTapUpEvent(int prevStart,int prevEnd){
  final int start=getSelectionStart();
  final int end=getSelectionEnd();
  if (start == end) {
    if (start >= prevStart && start < prevEnd) {
      Selection.setSelection((Spannable)mText,prevStart,prevEnd);
      if (mSelectionModifierCursorController != null && !mSelectionModifierCursorController.isShowing()) {
        mSelectionModifierCursorController.show();
      }
 else {
        showContextMenu();
      }
      return;
    }
 else {
      stopTextSelectionMode();
      if (mInsertionPointCursorController != null) {
        mInsertionPointCursorController.show();
      }
    }
  }
 else   if (hasSelection() && mSelectionModifierCursorController != null) {
    mSelectionModifierCursorController.show();
  }
}",0.7493995196156925
181332,"public void show(){
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
}","public void show(){
  mIsShowing=true;
  updatePosition();
  mStartHandle.show();
  mEndHandle.show();
  hideInsertionPointCursorController();
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.8834355828220859
181333,"private void hideDelayed(int msec){
  TextView.this.removeCallbacks(mHider);
  TextView.this.postDelayed(mHider,msec);
}","private void hideDelayed(int delay){
  removeCallbacks(mHider);
  postDelayed(mHider,delay);
}",0.8037383177570093
181334,"public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  boolean oneLineSelection=mLayout.getLineForOffset(selectionStart) == mLayout.getLineForOffset(selectionEnd);
  mStartHandle.positionAtCursor(selectionStart,oneLineSelection);
  mEndHandle.positionAtCursor(selectionEnd,true);
}","public void updatePosition(){
  final int selectionStart=getSelectionStart();
  final int selectionEnd=getSelectionEnd();
  if ((selectionStart < 0) || (selectionEnd < 0)) {
    Log.w(LOG_TAG,""String_Node_Str"");
    hide();
    return;
  }
  boolean oneLineSelection=mLayout.getLineForOffset(selectionStart) == mLayout.getLineForOffset(selectionEnd);
  mStartHandle.positionAtCursor(selectionStart,oneLineSelection);
  mEndHandle.positionAtCursor(selectionEnd,true);
  hideDelayed(DELAY_BEFORE_FADE_OUT);
}",0.9609856262833676
181335,"public void hide(){
  mStartHandle.hide();
  mEndHandle.hide();
  mIsShowing=false;
}","public void hide(){
  mStartHandle.hide();
  mEndHandle.hide();
  mIsShowing=false;
  removeCallbacks(mHider);
}",0.8629441624365483
181336,"@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  if (hasWindowFocus) {
    if (mBlink != null) {
      mBlink.uncancel();
      if (isFocused()) {
        mShowCursor=SystemClock.uptimeMillis();
        makeBlink();
      }
    }
  }
 else {
    if (mBlink != null) {
      mBlink.cancel();
    }
    onEndBatchEdit();
    if (mInputContentType != null) {
      mInputContentType.enterDown=false;
    }
    hideControllers();
  }
  startStopMarquee(hasWindowFocus);
}","@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  if (hasWindowFocus) {
    if (mBlink != null) {
      mBlink.uncancel();
      if (isFocused()) {
        mShowCursor=SystemClock.uptimeMillis();
        makeBlink();
      }
    }
  }
 else {
    if (mBlink != null) {
      mBlink.cancel();
    }
    onEndBatchEdit();
    if (mInputContentType != null) {
      mInputContentType.enterDown=false;
    }
    hideInsertionPointCursorController();
    if (mSelectionModifierCursorController != null) {
      mSelectionModifierCursorController.hide();
    }
  }
  startStopMarquee(hasWindowFocus);
}",0.8444816053511706
181337,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  if (mPreDrawState != PREDRAW_NOT_REGISTERED) {
    final ViewTreeObserver observer=getViewTreeObserver();
    if (observer != null) {
      observer.removeOnPreDrawListener(this);
      mPreDrawState=PREDRAW_NOT_REGISTERED;
    }
  }
  if (mError != null) {
    hideError();
  }
  hideControllers();
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  final ViewTreeObserver observer=getViewTreeObserver();
  if (observer != null) {
    if (mPreDrawState != PREDRAW_NOT_REGISTERED) {
      observer.removeOnPreDrawListener(this);
      mPreDrawState=PREDRAW_NOT_REGISTERED;
    }
    if (mInsertionPointCursorController != null) {
      observer.removeOnTouchModeChangeListener(mInsertionPointCursorController);
    }
    if (mSelectionModifierCursorController != null) {
      observer.removeOnTouchModeChangeListener(mSelectionModifierCursorController);
    }
  }
  if (mError != null) {
    hideError();
  }
  hideControllers();
}",0.4809160305343511
181338,"public HandleView(CursorController controller,Drawable handle){
  super(TextView.this.mContext);
  mController=controller;
  mDrawable=handle;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  mContainer.setLayoutInScreenEnabled(true);
}","public HandleView(CursorController controller,Drawable handle){
  super(TextView.this.mContext);
  mController=controller;
  mDrawable=handle;
  mContainer=new PopupWindow(TextView.this.mContext,null,com.android.internal.R.attr.textSelectHandleWindowStyle);
  mContainer.setSplitTouchEnabled(true);
  mContainer.setClippingEnabled(false);
  mHotspotX=mDrawable.getIntrinsicWidth() * 0.5f;
  mHotspotY=-mDrawable.getIntrinsicHeight() * 0.2f;
}",0.841596130592503
181339,"private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionInBounds()) {
    if (mContainer.isShowing()) {
      final int[] coords=mTempCoords;
      TextView.this.getLocationOnScreen(coords);
      coords[0]+=mPositionX;
      coords[1]+=mPositionY;
      mContainer.update(coords[0],coords[1],mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
  }
 else {
    hide();
  }
}","private void moveTo(int x,int y){
  mPositionX=x - TextView.this.mScrollX;
  mPositionY=y - TextView.this.mScrollY;
  if (isPositionInBounds()) {
    if (mContainer.isShowing()) {
      final int[] coords=mTempCoords;
      TextView.this.getLocationInWindow(coords);
      coords[0]+=mPositionX;
      coords[1]+=mPositionY;
      mContainer.update(coords[0],coords[1],mRight - mLeft,mBottom - mTop);
    }
 else {
      show();
    }
  }
 else {
    hide();
  }
}",0.9827586206896552
181340,"@Override protected void onFocusChanged(boolean focused,int direction,Rect previouslyFocusedRect){
  if (mTemporaryDetach) {
    super.onFocusChanged(focused,direction,previouslyFocusedRect);
    return;
  }
  mShowCursor=SystemClock.uptimeMillis();
  ensureEndedBatchEdit();
  if (focused) {
    int selStart=getSelectionStart();
    int selEnd=getSelectionEnd();
    if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
      if (mLastTouchOffset >= 0) {
        mLastTouchOffset=Math.min(mLastTouchOffset,mText.length());
        Selection.setSelection((Spannable)mText,mLastTouchOffset);
      }
      if (mMovement != null) {
        mMovement.onTakeFocus(this,(Spannable)mText,direction);
      }
      if (mSelectAllOnFocus) {
        Selection.setSelection((Spannable)mText,0,mText.length());
      }
      if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
        Selection.setSelection((Spannable)mText,selStart,selEnd);
      }
      mTouchFocusSelected=true;
    }
    mFrozenWithFocus=false;
    mSelectionMoved=false;
    if (mText instanceof Spannable) {
      Spannable sp=(Spannable)mText;
      MetaKeyKeyListener.resetMetaState(sp);
    }
    makeBlink();
    if (mError != null) {
      showError();
    }
  }
 else {
    if (mError != null) {
      hideError();
    }
    onEndBatchEdit();
    hideInsertionPointCursorController();
    if (this instanceof ExtractEditText) {
      mIsInTextSelectionMode=false;
    }
 else {
      terminateTextSelectionMode();
    }
  }
  startStopMarquee(focused);
  if (mTransformation != null) {
    mTransformation.onFocusChanged(this,mText,focused,direction,previouslyFocusedRect);
  }
  super.onFocusChanged(focused,direction,previouslyFocusedRect);
}","@Override protected void onFocusChanged(boolean focused,int direction,Rect previouslyFocusedRect){
  if (mTemporaryDetach) {
    super.onFocusChanged(focused,direction,previouslyFocusedRect);
    return;
  }
  mShowCursor=SystemClock.uptimeMillis();
  ensureEndedBatchEdit();
  if (focused) {
    int selStart=getSelectionStart();
    int selEnd=getSelectionEnd();
    if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
      if (mLastTouchOffset >= 0) {
        mLastTouchOffset=Math.min(mLastTouchOffset,mText.length());
        Selection.setSelection((Spannable)mText,mLastTouchOffset);
      }
      if (mMovement != null) {
        mMovement.onTakeFocus(this,(Spannable)mText,direction);
      }
      if (mSelectAllOnFocus) {
        Selection.setSelection((Spannable)mText,0,mText.length());
      }
      if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
        Selection.setSelection((Spannable)mText,selStart,selEnd);
      }
      mTouchFocusSelected=true;
    }
    mFrozenWithFocus=false;
    mSelectionMoved=false;
    if (mText instanceof Spannable) {
      Spannable sp=(Spannable)mText;
      MetaKeyKeyListener.resetMetaState(sp);
    }
    makeBlink();
    if (mError != null) {
      showError();
    }
  }
 else {
    if (mError != null) {
      hideError();
    }
    onEndBatchEdit();
    hideInsertionPointCursorController();
    if (this instanceof ExtractEditText) {
      mIsInTextSelectionMode=false;
    }
 else {
      terminateTextSelectionMode();
    }
    mLastTouchOffset=-1;
  }
  startStopMarquee(focused);
  if (mTransformation != null) {
    mTransformation.onFocusChanged(this,mText,focused,direction,previouslyFocusedRect);
  }
  super.onFocusChanged(focused,direction,previouslyFocusedRect);
}",0.9929478138222848
181341,"@Override public boolean onKeyShortcut(int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_A:
    if (canSelectAll()) {
      return onTextContextMenuItem(ID_SELECT_ALL);
    }
  break;
case KeyEvent.KEYCODE_X:
if (canCut()) {
  return onTextContextMenuItem(ID_CUT);
}
break;
case KeyEvent.KEYCODE_C:
if (canCopy()) {
return onTextContextMenuItem(ID_COPY);
}
break;
case KeyEvent.KEYCODE_V:
if (canPaste()) {
return onTextContextMenuItem(ID_PASTE);
}
break;
}
return super.onKeyShortcut(keyCode,event);
}","@Override public boolean onKeyShortcut(int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_A:
    if (canSelectText()) {
      return onTextContextMenuItem(ID_SELECT_ALL);
    }
  break;
case KeyEvent.KEYCODE_X:
if (canCut()) {
  return onTextContextMenuItem(ID_CUT);
}
break;
case KeyEvent.KEYCODE_C:
if (canCopy()) {
return onTextContextMenuItem(ID_COPY);
}
break;
case KeyEvent.KEYCODE_V:
if (canPaste()) {
return onTextContextMenuItem(ID_PASTE);
}
break;
}
return super.onKeyShortcut(keyCode,event);
}",0.9933014354066986
181342,"private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (canSelectText() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}","private void prepareCursorControllers(){
  if (mCursorVisible && mLayout != null) {
    if (mInsertionPointCursorController == null) {
      mInsertionPointCursorController=new InsertionPointCursorController();
    }
  }
 else {
    mInsertionPointCursorController=null;
  }
  if (textCanBeSelected() && mLayout != null) {
    if (mSelectionModifierCursorController == null) {
      mSelectionModifierCursorController=new SelectionModifierCursorController();
    }
  }
 else {
    stopTextSelectionMode();
    mSelectionModifierCursorController=null;
  }
}",0.9747292418772564
181343,"private boolean canSelectText(){
  return (mText instanceof Spannable && mMovement != null && mMovement.canSelectArbitrarily());
}","private boolean canSelectText(){
  return textCanBeSelected() && mText.length() != 0;
}",0.5529953917050692
181344,"@Override protected void onCreateContextMenu(ContextMenu menu){
  super.onCreateContextMenu(menu);
  boolean added=false;
  if (mIsInTextSelectionMode) {
    MenuHandler handler=new MenuHandler();
    if (canCut()) {
      menu.add(0,ID_CUT,0,com.android.internal.R.string.cut).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
      added=true;
    }
    if (canCopy()) {
      menu.add(0,ID_COPY,0,com.android.internal.R.string.copy).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
      added=true;
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
  }
 else {
    MenuHandler handler=new MenuHandler();
    if (canSelectText()) {
      menu.add(0,ID_START_SELECTING_TEXT,0,com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
      added=true;
    }
    if (canSelectAll()) {
      menu.add(0,ID_SELECT_ALL,0,com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
      added=true;
    }
    if (mText instanceof Spanned) {
      int selStart=getSelectionStart();
      int selEnd=getSelectionEnd();
      int min=Math.min(selStart,selEnd);
      int max=Math.max(selStart,selEnd);
      URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
      if (urls.length == 1) {
        menu.add(0,ID_COPY_URL,0,com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
        added=true;
      }
    }
    if (canPaste() && textIsOnlySpaces()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
    if (isInputMethodTarget()) {
      menu.add(1,ID_SWITCH_INPUT_METHOD,0,com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
      added=true;
    }
    String word=getWordForDictionary();
    if (word != null) {
      menu.add(1,ID_ADD_TO_DICTIONARY,0,getContext().getString(com.android.internal.R.string.addToDictionary,word)).setOnMenuItemClickListener(handler);
      added=true;
    }
  }
  if (added) {
    menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
  }
}","@Override protected void onCreateContextMenu(ContextMenu menu){
  super.onCreateContextMenu(menu);
  boolean added=false;
  if (mIsInTextSelectionMode) {
    MenuHandler handler=new MenuHandler();
    if (canCut()) {
      menu.add(0,ID_CUT,0,com.android.internal.R.string.cut).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
      added=true;
    }
    if (canCopy()) {
      menu.add(0,ID_COPY,0,com.android.internal.R.string.copy).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
      added=true;
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
  }
 else {
    MenuHandler handler=new MenuHandler();
    if (canSelectText()) {
      menu.add(0,ID_START_SELECTING_TEXT,0,com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
      menu.add(0,ID_SELECT_ALL,0,com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
      added=true;
    }
    if (mText instanceof Spanned) {
      int selStart=getSelectionStart();
      int selEnd=getSelectionEnd();
      int min=Math.min(selStart,selEnd);
      int max=Math.max(selStart,selEnd);
      URLSpan[] urls=((Spanned)mText).getSpans(min,max,URLSpan.class);
      if (urls.length == 1) {
        menu.add(0,ID_COPY_URL,0,com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
        added=true;
      }
    }
    if (canPaste()) {
      menu.add(0,ID_PASTE,0,com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
      added=true;
    }
    if (isInputMethodTarget()) {
      menu.add(1,ID_SWITCH_INPUT_METHOD,0,com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
      added=true;
    }
    String word=getWordForDictionary();
    if (word != null) {
      menu.add(1,ID_ADD_TO_DICTIONARY,0,getContext().getString(com.android.internal.R.string.addToDictionary,word)).setOnMenuItemClickListener(handler);
      added=true;
    }
  }
  if (added) {
    menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
  }
}",0.9839715048975958
181345,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
    if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=true;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
    if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=true;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}",0.9146757679180888
181346,"private void printRestoreSets(RestoreSet[] sets){
  for (  RestoreSet s : sets) {
    System.out.println(""String_Node_Str"" + Long.toHexString(s.token) + ""String_Node_Str""+ s.name);
  }
}","private void printRestoreSets(RestoreSet[] sets){
  if (sets == null || sets.length == 0) {
    System.out.println(""String_Node_Str"");
    return;
  }
  for (  RestoreSet s : sets) {
    System.out.println(""String_Node_Str"" + Long.toHexString(s.token) + ""String_Node_Str""+ s.name);
  }
}",0.7864693446088795
181347,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
    if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=true;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
    if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
      if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mHideLockScreen=true;
      }
      if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + win);
        mDismissKeyguard=true;
      }
      if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
        mAllowLockscreenWhenOn=true;
      }
    }
  }
}",0.9146757679180888
181348,"private void printRestoreSets(RestoreSet[] sets){
  for (  RestoreSet s : sets) {
    System.out.println(""String_Node_Str"" + Long.toHexString(s.token) + ""String_Node_Str""+ s.name);
  }
}","private void printRestoreSets(RestoreSet[] sets){
  if (sets == null || sets.length == 0) {
    System.out.println(""String_Node_Str"");
    return;
  }
  for (  RestoreSet s : sets) {
    System.out.println(""String_Node_Str"" + Long.toHexString(s.token) + ""String_Node_Str""+ s.name);
  }
}",0.7864693446088795
181349,"@Override public void onChanged(SipAudioCall call){
synchronized (SipPhone.class) {
    Call.State newState=getCallStateFrom(call);
    if (mState == newState)     return;
    if (newState == Call.State.INCOMING) {
      setState(mOwner.getState());
    }
 else {
      if (mOwner == ringingCall) {
        if (ringingCall.getState() == Call.State.WAITING) {
          try {
            switchHoldingAndActive();
          }
 catch (          CallStateException e) {
            onCallEnded(DisconnectCause.LOCAL);
            return;
          }
        }
        foregroundCall.switchWith(ringingCall);
      }
      if (newState == Call.State.ACTIVE)       call.startAudio();
      setState(newState);
    }
    mOwner.onConnectionStateChanged(SipConnection.this);
    Log.v(LOG_TAG,""String_Node_Str"" + mPeer.getUriString() + ""String_Node_Str""+ mState+ ""String_Node_Str""+ getPhone());
  }
}","@Override public void onChanged(SipAudioCall call){
synchronized (SipPhone.class) {
    Call.State newState=getCallStateFrom(call);
    if (mState == newState)     return;
    if (newState == Call.State.INCOMING) {
      setState(mOwner.getState());
    }
 else {
      if (mOwner == ringingCall) {
        if (ringingCall.getState() == Call.State.WAITING) {
          try {
            switchHoldingAndActive();
          }
 catch (          CallStateException e) {
            onCallEnded(DisconnectCause.LOCAL);
            return;
          }
        }
        foregroundCall.switchWith(ringingCall);
      }
      setState(newState);
    }
    mOwner.onConnectionStateChanged(SipConnection.this);
    Log.v(LOG_TAG,""String_Node_Str"" + mPeer.getUriString() + ""String_Node_Str""+ mState+ ""String_Node_Str""+ getPhone());
  }
}",0.9616279069767442
181350,"private final void processNextBroadcast(boolean fromMsg){
synchronized (this) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + mParallelBroadcasts.size() + ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"" + target + ""String_Node_Str""+ r);
        deliverToRegisteredReceiver(r,(BroadcastFilter)target,false);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT) {
        Slog.v(TAG,""String_Node_Str"" + mPendingBroadcast.curApp);
      }
      boolean isDead;
synchronized (mPidsSelfLocked) {
        isDead=(mPidsSelfLocked.get(mPendingBroadcast.curApp.pid) == null);
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mPendingBroadcast.curApp + ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        scheduleAppGcsLocked();
        if (looped) {
          updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * BROADCAST_TIMEOUT * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + now + ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeout();
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG,""String_Node_Str"" + r.state + ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST) {
              int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
              Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ r.callerApp);
            }
            performReceive(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false);
          }
 catch (          RemoteException e) {
            Slog.w(TAG,""String_Node_Str"" + r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"");
        mHandler.removeMessages(BROADCAST_TIMEOUT_MSG);
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ (r.receiverTime + BROADCAST_TIMEOUT));
      Message msg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
      mHandler.sendMessageAtTime(msg,r.receiverTime + BROADCAST_TIMEOUT);
    }
    Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
      deliverToRegisteredReceiver(r,filter,r.ordered);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"" + r.ordered + ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    boolean skip=false;
    int perm=checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.exported ? -1 : info.activityInfo.applicationInfo.uid);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ info.activityInfo.packageName+ ""String_Node_Str""+ info.activityInfo.name);
      skip=true;
    }
    if (r.callingUid != Process.SYSTEM_UID && r.requiredPermission != null) {
      try {
        perm=AppGlobals.getPackageManager().checkPermission(r.requiredPermission,info.activityInfo.applicationInfo.packageName);
      }
 catch (      RemoteException e) {
        perm=PackageManager.PERMISSION_DENIED;
      }
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ info.activityInfo.applicationInfo.packageName+ ""String_Node_Str""+ r.requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.state=BroadcastRecord.APP_RECEIVE;
    String targetProcess=info.activityInfo.processName;
    r.curComponent=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    r.curReceiver=info.activityInfo;
    ProcessRecord app=getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid);
    if (app != null && app.thread != null) {
      try {
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + targetProcess + ""String_Node_Str""+ r);
    if ((r.curApp=startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscard(r);
      finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}","private final void processNextBroadcast(boolean fromMsg){
synchronized (this) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + mParallelBroadcasts.size() + ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"" + target + ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT) {
        Slog.v(TAG,""String_Node_Str"" + mPendingBroadcast.curApp);
      }
      boolean isDead;
synchronized (mPidsSelfLocked) {
        isDead=(mPidsSelfLocked.get(mPendingBroadcast.curApp.pid) == null);
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mPendingBroadcast.curApp + ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        scheduleAppGcsLocked();
        if (looped) {
          updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * BROADCAST_TIMEOUT * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + now + ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG,""String_Node_Str"" + r.state + ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST) {
              int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
              Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq+ ""String_Node_Str""+ r.callerApp);
            }
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false);
          }
 catch (          RemoteException e) {
            Slog.w(TAG,""String_Node_Str"" + r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,""String_Node_Str"" + r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + BROADCAST_TIMEOUT;
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG,""String_Node_Str"" + r.ordered + ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    boolean skip=false;
    int perm=checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.exported ? -1 : info.activityInfo.applicationInfo.uid);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ info.activityInfo.packageName+ ""String_Node_Str""+ info.activityInfo.name);
      skip=true;
    }
    if (r.callingUid != Process.SYSTEM_UID && r.requiredPermission != null) {
      try {
        perm=AppGlobals.getPackageManager().checkPermission(r.requiredPermission,info.activityInfo.applicationInfo.packageName);
      }
 catch (      RemoteException e) {
        perm=PackageManager.PERMISSION_DENIED;
      }
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ info.activityInfo.applicationInfo.packageName+ ""String_Node_Str""+ r.requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.state=BroadcastRecord.APP_RECEIVE;
    String targetProcess=info.activityInfo.processName;
    r.curComponent=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    r.curReceiver=info.activityInfo;
    ProcessRecord app=getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid);
    if (app != null && app.thread != null) {
      try {
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + targetProcess + ""String_Node_Str""+ r);
    if ((r.curApp=startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}",0.8862359550561798
181351,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Slog.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(EventLogTags.AM_PROC_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.setSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mProcessesReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Slog.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLruProcessLocked(app,false,true);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))   Slog.v(TAG,""String_Node_Str"" + app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  ActivityRecord hr=mMainStack.topRunningActivityLocked(null);
  if (hr != null && normalMode) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (mMainStack.realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      mMainStack.ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
      br.state=BroadcastRecord.IDLE;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Slog.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Slog.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(EventLogTags.AM_PROC_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.setSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mProcessesReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Slog.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLruProcessLocked(app,false,true);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))   Slog.v(TAG,""String_Node_Str"" + app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  ActivityRecord hr=mMainStack.topRunningActivityLocked(null);
  if (hr != null && normalMode) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (mMainStack.realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      mMainStack.ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscardLocked(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
      br.state=BroadcastRecord.IDLE;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Slog.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9994896223205172
181352,"void skipCurrentReceiverLocked(ProcessRecord app){
  boolean reschedule=false;
  BroadcastRecord r=app.curReceiver;
  if (r != null) {
    logBroadcastReceiverDiscard(r);
    finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
    reschedule=true;
  }
  r=mPendingBroadcast;
  if (r != null && r.curApp == app) {
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    logBroadcastReceiverDiscard(r);
    finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
    reschedule=true;
  }
  if (reschedule) {
    scheduleBroadcastsLocked();
  }
}","void skipCurrentReceiverLocked(ProcessRecord app){
  boolean reschedule=false;
  BroadcastRecord r=app.curReceiver;
  if (r != null) {
    logBroadcastReceiverDiscardLocked(r);
    finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
    reschedule=true;
  }
  r=mPendingBroadcast;
  if (r != null && r.curApp == app) {
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    logBroadcastReceiverDiscardLocked(r);
    finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
    reschedule=true;
  }
  if (reschedule) {
    scheduleBroadcastsLocked();
  }
}",0.9906396255850234
181353,"static void performReceive(ProcessRecord app,IIntentReceiver receiver,Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky) throws RemoteException {
  if (app != null && app.thread != null) {
    app.thread.scheduleRegisteredReceiver(receiver,intent,resultCode,data,extras,ordered,sticky);
  }
 else {
    receiver.performReceive(intent,resultCode,data,extras,ordered,sticky);
  }
}","public void performReceive(Intent intent,int resultCode,String data,Bundle extras,boolean ordered,boolean sticky){
  mHandler.post(new Runnable(){
    public void run(){
synchronized (ActivityManagerService.this) {
        mDidUpdate=true;
      }
      systemReady(goingCallback);
    }
  }
);
}",0.1040787623066104
181354,"public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    Intent intent=new Intent(""String_Node_Str"");
    if (!mProcessesReady) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mProcessesReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessivePowerUsageLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
}
}
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    Intent intent=new Intent(""String_Node_Str"");
    if (!mProcessesReady) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
synchronized (ActivityManagerService.this) {
broadcastTimeoutLocked(true);
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessivePowerUsageLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
}
}
break;
}
}",0.98126582278481
181355,"/** 
 * Populates the database map of values with the appropriate RRULE, RDATE, EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desiredrecurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary informationto specify a recurrence.  The required fields are DTSTART, one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if there was an error, including if the date is out of range.
 */
public static boolean populateContentValues(ICalendar.Component component,ContentValues values){
  ICalendar.Property dtstartProperty=component.getFirstProperty(""String_Node_Str"");
  String dtstart=dtstartProperty.getValue();
  ICalendar.Parameter tzidParam=dtstartProperty.getFirstParameter(""String_Node_Str"");
  String tzid=tzidParam == null ? null : tzidParam.value;
  Time start=new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
  boolean inUtc=start.parse(dtstart);
  boolean allDay=start.allDay;
  if (inUtc) {
    tzid=Time.TIMEZONE_UTC;
  }
  String duration=computeDuration(start,component);
  String rrule=flattenProperties(component,""String_Node_Str"");
  String rdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  String exrule=flattenProperties(component,""String_Node_Str"");
  String exdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + component.toString());
    }
    return false;
  }
  if (allDay) {
    start.timezone=Time.TIMEZONE_UTC;
  }
  long millis=start.toMillis(false);
  values.put(Calendar.Events.DTSTART,millis);
  if (millis == -1) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + component.toString());
    }
    return false;
  }
  values.put(Calendar.Events.RRULE,rrule);
  values.put(Calendar.Events.RDATE,rdate);
  values.put(Calendar.Events.EXRULE,exrule);
  values.put(Calendar.Events.EXDATE,exdate);
  values.put(Calendar.Events.EVENT_TIMEZONE,tzid);
  values.put(Calendar.Events.DURATION,duration);
  values.put(Calendar.Events.ALL_DAY,allDay ? 1 : 0);
  return true;
}","/** 
 * Populates the database map of values with the appropriate RRULE, RDATE, EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desiredrecurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary informationto specify a recurrence.  The required fields are DTSTART, one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if there was an error, including if the date is out of range.
 */
public static boolean populateContentValues(ICalendar.Component component,ContentValues values){
  ICalendar.Property dtstartProperty=component.getFirstProperty(""String_Node_Str"");
  String dtstart=dtstartProperty.getValue();
  ICalendar.Parameter tzidParam=dtstartProperty.getFirstParameter(""String_Node_Str"");
  String tzid=tzidParam == null ? null : tzidParam.value;
  Time start=new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
  boolean inUtc=start.parse(dtstart);
  boolean allDay=start.allDay;
  if (inUtc || allDay) {
    tzid=Time.TIMEZONE_UTC;
  }
  String duration=computeDuration(start,component);
  String rrule=flattenProperties(component,""String_Node_Str"");
  String rdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  String exrule=flattenProperties(component,""String_Node_Str"");
  String exdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + component.toString());
    }
    return false;
  }
  if (allDay) {
    start.timezone=Time.TIMEZONE_UTC;
  }
  long millis=start.toMillis(false);
  values.put(Calendar.Events.DTSTART,millis);
  if (millis == -1) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + component.toString());
    }
    return false;
  }
  values.put(Calendar.Events.RRULE,rrule);
  values.put(Calendar.Events.RDATE,rdate);
  values.put(Calendar.Events.EXRULE,exrule);
  values.put(Calendar.Events.EXDATE,exdate);
  values.put(Calendar.Events.EVENT_TIMEZONE,tzid);
  values.put(Calendar.Events.DURATION,duration);
  values.put(Calendar.Events.ALL_DAY,allDay ? 1 : 0);
  return true;
}",0.9978531558608844
181356,"@SmallTest public void testRecurrenceSet2() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,null,""String_Node_Str"",1);
}","@SmallTest public void testRecurrenceSet2() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,""String_Node_Str"",""String_Node_Str"",1);
}",0.9572301425661914
181357,"@SmallTest public void testRecurrenceSet1() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,null,""String_Node_Str"",1);
}","@SmallTest public void testRecurrenceSet1() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,""String_Node_Str"",""String_Node_Str"",1);
}",0.9572301425661914
181358,"/** 
 * Populates the database map of values with the appropriate RRULE, RDATE, EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desiredrecurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary informationto specify a recurrence.  The required fields are DTSTART, one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if there was an error, including if the date is out of range.
 */
public static boolean populateContentValues(ICalendar.Component component,ContentValues values){
  ICalendar.Property dtstartProperty=component.getFirstProperty(""String_Node_Str"");
  String dtstart=dtstartProperty.getValue();
  ICalendar.Parameter tzidParam=dtstartProperty.getFirstParameter(""String_Node_Str"");
  String tzid=tzidParam == null ? null : tzidParam.value;
  Time start=new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
  boolean inUtc=start.parse(dtstart);
  boolean allDay=start.allDay;
  if (inUtc) {
    tzid=Time.TIMEZONE_UTC;
  }
  String duration=computeDuration(start,component);
  String rrule=flattenProperties(component,""String_Node_Str"");
  String rdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  String exrule=flattenProperties(component,""String_Node_Str"");
  String exdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + component.toString());
    }
    return false;
  }
  if (allDay) {
    start.timezone=Time.TIMEZONE_UTC;
  }
  long millis=start.toMillis(false);
  values.put(Calendar.Events.DTSTART,millis);
  if (millis == -1) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + component.toString());
    }
    return false;
  }
  values.put(Calendar.Events.RRULE,rrule);
  values.put(Calendar.Events.RDATE,rdate);
  values.put(Calendar.Events.EXRULE,exrule);
  values.put(Calendar.Events.EXDATE,exdate);
  values.put(Calendar.Events.EVENT_TIMEZONE,tzid);
  values.put(Calendar.Events.DURATION,duration);
  values.put(Calendar.Events.ALL_DAY,allDay ? 1 : 0);
  return true;
}","/** 
 * Populates the database map of values with the appropriate RRULE, RDATE, EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desiredrecurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary informationto specify a recurrence.  The required fields are DTSTART, one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if there was an error, including if the date is out of range.
 */
public static boolean populateContentValues(ICalendar.Component component,ContentValues values){
  ICalendar.Property dtstartProperty=component.getFirstProperty(""String_Node_Str"");
  String dtstart=dtstartProperty.getValue();
  ICalendar.Parameter tzidParam=dtstartProperty.getFirstParameter(""String_Node_Str"");
  String tzid=tzidParam == null ? null : tzidParam.value;
  Time start=new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
  boolean inUtc=start.parse(dtstart);
  boolean allDay=start.allDay;
  if (inUtc || allDay) {
    tzid=Time.TIMEZONE_UTC;
  }
  String duration=computeDuration(start,component);
  String rrule=flattenProperties(component,""String_Node_Str"");
  String rdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  String exrule=flattenProperties(component,""String_Node_Str"");
  String exdate=extractDates(component.getFirstProperty(""String_Node_Str""));
  if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + component.toString());
    }
    return false;
  }
  if (allDay) {
    start.timezone=Time.TIMEZONE_UTC;
  }
  long millis=start.toMillis(false);
  values.put(Calendar.Events.DTSTART,millis);
  if (millis == -1) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"" + component.toString());
    }
    return false;
  }
  values.put(Calendar.Events.RRULE,rrule);
  values.put(Calendar.Events.RDATE,rdate);
  values.put(Calendar.Events.EXRULE,exrule);
  values.put(Calendar.Events.EXDATE,exdate);
  values.put(Calendar.Events.EVENT_TIMEZONE,tzid);
  values.put(Calendar.Events.DURATION,duration);
  values.put(Calendar.Events.ALL_DAY,allDay ? 1 : 0);
  return true;
}",0.9978531558608844
181359,"@SmallTest public void testRecurrenceSet2() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,null,""String_Node_Str"",1);
}","@SmallTest public void testRecurrenceSet2() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,""String_Node_Str"",""String_Node_Str"",1);
}",0.9572301425661914
181360,"@SmallTest public void testRecurrenceSet1() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,null,""String_Node_Str"",1);
}","@SmallTest public void testRecurrenceSet1() throws Exception {
  String recurrence=""String_Node_Str"" + ""String_Node_Str"";
  verifyPopulateContentValues(recurrence,""String_Node_Str"",null,null,null,1250812800000L,""String_Node_Str"",""String_Node_Str"",1);
}",0.9572301425661914
181361,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9762202753441802
181362,"private void run(String[] args) throws Exception {
  if (args.length < 1) {
    showUsage();
    return;
  }
  mAm=ActivityManagerNative.getDefault();
  if (mAm == null) {
    System.err.println(NO_SYSTEM_ERROR_CODE);
    throw new AndroidException(""String_Node_Str"");
  }
  mArgs=args;
  String op=args[0];
  mNextArg=1;
  if (op.equals(""String_Node_Str"")) {
    runStart();
  }
 else   if (op.equals(""String_Node_Str"")) {
    runStartService();
  }
 else   if (op.equals(""String_Node_Str"")) {
    runInstrument();
  }
 else   if (op.equals(""String_Node_Str"")) {
    sendBroadcast();
  }
 else   if (op.equals(""String_Node_Str"")) {
    runProfile();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + op);
  }
}","void run() throws RemoteException {
  try {
    printMessageForState();
    mAm.setActivityController(this);
    mState=STATE_NORMAL;
    InputStreamReader converter=new InputStreamReader(System.in);
    BufferedReader in=new BufferedReader(converter);
    String line;
    while ((line=in.readLine()) != null) {
      boolean addNewline=true;
      if (line.length() <= 0) {
        addNewline=false;
      }
 else       if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
        resumeController(RESULT_DEFAULT);
        break;
      }
 else       if (mState == STATE_CRASHED) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_KILL);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_WAIT);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_EARLY_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_CONTINUE);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
synchronized (this) {
        if (addNewline) {
          System.out.println(""String_Node_Str"");
        }
        printMessageForState();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    mAm.setActivityController(null);
  }
}",0.0674908118944203
181363,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
case SCHEDULE_CRASH:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (DEBUG_MESSAGES) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
case SCHEDULE_CRASH:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}",0.9941520467836256
181364,"private final void queueOrSendMessage(int what,Object obj,int arg1,int arg2){
synchronized (this) {
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ mH.codeToString(what)+ ""String_Node_Str""+ arg1+ ""String_Node_Str""+ obj);
    Message msg=Message.obtain();
    msg.what=what;
    msg.obj=obj;
    msg.arg1=arg1;
    msg.arg2=arg2;
    mH.sendMessage(msg);
  }
}","private final void queueOrSendMessage(int what,Object obj,int arg1,int arg2){
synchronized (this) {
    if (DEBUG_MESSAGES)     Slog.v(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ mH.codeToString(what)+ ""String_Node_Str""+ arg1+ ""String_Node_Str""+ obj);
    Message msg=Message.obtain();
    msg.what=what;
    msg.obj=obj;
    msg.arg1=arg1;
    msg.arg2=arg2;
    mH.sendMessage(msg);
  }
}",0.9733163913595934
181365,"public static final void main(String[] args){
  SamplingProfilerIntegration.start();
  Process.setArgV0(""String_Node_Str"");
  Looper.prepareMainLooper();
  if (sMainThreadHandler == null) {
    sMainThreadHandler=new Handler();
  }
  ActivityThread thread=new ActivityThread();
  thread.attach(false);
  Looper.loop();
  if (Process.supportsProcesses()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  thread.detach();
  String name=(thread.mInitialApplication != null) ? thread.mInitialApplication.getPackageName() : ""String_Node_Str"";
  Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
}","public static final void main(String[] args){
  SamplingProfilerIntegration.start();
  Process.setArgV0(""String_Node_Str"");
  Looper.prepareMainLooper();
  if (sMainThreadHandler == null) {
    sMainThreadHandler=new Handler();
  }
  ActivityThread thread=new ActivityThread();
  thread.attach(false);
  if (false) {
    Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG,""String_Node_Str""));
  }
  Looper.loop();
  if (Process.supportsProcesses()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  thread.detach();
  String name=(thread.mInitialApplication != null) ? thread.mInitialApplication.getPackageName() : ""String_Node_Str"";
  Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str"");
}",0.9206349206349206
181366,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityClientRecord r=(ActivityClientRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityClientRecord r=(ActivityClientRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
case SCHEDULE_CRASH:
throw new RemoteServiceException((String)msg.obj);
}
}","public void handleMessage(Message msg){
  if (DEBUG_MESSAGES)   Slog.v(TAG,""String_Node_Str"" + msg.what);
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityClientRecord r=(ActivityClientRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityClientRecord r=(ActivityClientRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
case SCHEDULE_CRASH:
throw new RemoteServiceException((String)msg.obj);
}
if (DEBUG_MESSAGES) Slog.v(TAG,""String_Node_Str"" + msg.what);
}",0.9798552093169656
181367,"/** 
 * Enable or disable the visualization engine.
 * @param enabled requested enable state
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} in case of failure.
 * @throws IllegalStateException
 */
public int setEnabled(boolean enabled) throws IllegalStateException {
synchronized (mStateLock) {
    if ((enabled && mState != STATE_INITIALIZED) || (!enabled && mState != STATE_ENABLED)) {
      throw (new IllegalStateException(""String_Node_Str"" + mState));
    }
    int status=native_setEnabled(enabled);
    if (status == SUCCESS) {
      mState=enabled ? STATE_ENABLED : STATE_INITIALIZED;
    }
    return status;
  }
}","/** 
 * Enable or disable the visualization engine.
 * @param enabled requested enable state
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} in case of failure.
 * @throws IllegalStateException
 */
public int setEnabled(boolean enabled) throws IllegalStateException {
synchronized (mStateLock) {
    if (mState == STATE_UNINITIALIZED) {
      throw (new IllegalStateException(""String_Node_Str"" + mState));
    }
    int status=SUCCESS;
    if ((enabled && (mState == STATE_INITIALIZED)) || (!enabled && (mState == STATE_ENABLED))) {
      status=native_setEnabled(enabled);
      if (status == SUCCESS) {
        mState=enabled ? STATE_ENABLED : STATE_INITIALIZED;
      }
    }
    return status;
  }
}",0.6850447966919366
181368,"/** 
 * It's difficult to discern from the spec when impl.create() should be called, but it seems like a reasonable rule is ""as soon as possible, but not in a context where IOException cannot be thrown""
 * @throws IOException from SocketImpl.create()
 */
private void implCreateIfNeeded() throws IOException {
  if (!implCreated) {
synchronized (this) {
      if (!implCreated) {
        implCreated=true;
        impl.create(true);
      }
    }
  }
}","/** 
 * It's difficult to discern from the spec when impl.create() should be called, but it seems like a reasonable rule is ""as soon as possible, but not in a context where IOException cannot be thrown""
 * @throws IOException from SocketImpl.create()
 */
private void implCreateIfNeeded() throws IOException {
  if (!implCreated) {
synchronized (this) {
      if (!implCreated) {
        try {
          impl.create(true);
        }
  finally {
          implCreated=true;
        }
      }
    }
  }
}",0.8951781970649895
181369,"/** 
 * Enable or disable the visualization engine.
 * @param enabled requested enable state
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} in case of failure.
 * @throws IllegalStateException
 */
public int setEnabled(boolean enabled) throws IllegalStateException {
synchronized (mStateLock) {
    if ((enabled && mState != STATE_INITIALIZED) || (!enabled && mState != STATE_ENABLED)) {
      throw (new IllegalStateException(""String_Node_Str"" + mState));
    }
    int status=native_setEnabled(enabled);
    if (status == SUCCESS) {
      mState=enabled ? STATE_ENABLED : STATE_INITIALIZED;
    }
    return status;
  }
}","/** 
 * Enable or disable the visualization engine.
 * @param enabled requested enable state
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} in case of failure.
 * @throws IllegalStateException
 */
public int setEnabled(boolean enabled) throws IllegalStateException {
synchronized (mStateLock) {
    if (mState == STATE_UNINITIALIZED) {
      throw (new IllegalStateException(""String_Node_Str"" + mState));
    }
    int status=SUCCESS;
    if ((enabled && (mState == STATE_INITIALIZED)) || (!enabled && (mState == STATE_ENABLED))) {
      status=native_setEnabled(enabled);
      if (status == SUCCESS) {
        mState=enabled ? STATE_ENABLED : STATE_INITIALIZED;
      }
    }
    return status;
  }
}",0.6850447966919366
181370,"/** 
 * It's difficult to discern from the spec when impl.create() should be called, but it seems like a reasonable rule is ""as soon as possible, but not in a context where IOException cannot be thrown""
 * @throws IOException from SocketImpl.create()
 */
private void implCreateIfNeeded() throws IOException {
  if (!implCreated) {
synchronized (this) {
      if (!implCreated) {
        implCreated=true;
        impl.create(true);
      }
    }
  }
}","/** 
 * It's difficult to discern from the spec when impl.create() should be called, but it seems like a reasonable rule is ""as soon as possible, but not in a context where IOException cannot be thrown""
 * @throws IOException from SocketImpl.create()
 */
private void implCreateIfNeeded() throws IOException {
  if (!implCreated) {
synchronized (this) {
      if (!implCreated) {
        try {
          impl.create(true);
        }
  finally {
          implCreated=true;
        }
      }
    }
  }
}",0.8951781970649895
181371,"private void updateConnectivity(Intent intent){
  NetworkInfo info=(NetworkInfo)(intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO));
  int connectionStatus=intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION,0);
  Slog.d(TAG,""String_Node_Str"" + info + ""String_Node_Str""+ connectionStatus);
  if (info.isConnected() == false)   return;
switch (info.getType()) {
case ConnectivityManager.TYPE_MOBILE:
    if (info.isConnected()) {
      updateDataNetType(info.getSubtype(),connectionStatus);
      updateDataIcon();
      updateSignalStrength();
    }
  break;
case ConnectivityManager.TYPE_WIFI:
if (info.isConnected()) {
  mIsWifiConnected=true;
  mInetCondition=(connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
  int iconId;
  if (mLastWifiSignalLevel == -1) {
    iconId=sWifiSignalImages[mInetCondition][0];
  }
 else {
    iconId=sWifiSignalImages[mInetCondition][mLastWifiSignalLevel];
  }
  mService.setIcon(""String_Node_Str"",iconId,0);
  mService.setIconVisibility(""String_Node_Str"",true);
}
 else {
  mLastWifiSignalLevel=-1;
  mIsWifiConnected=false;
  mInetCondition=0;
  int iconId=sWifiSignalImages[0][0];
  mService.setIcon(""String_Node_Str"",iconId,0);
  mService.setIconVisibility(""String_Node_Str"",false);
}
updateSignalStrength();
break;
}
}","private void updateConnectivity(Intent intent){
  NetworkInfo info=(NetworkInfo)(intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO));
  int connectionStatus=intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION,0);
  Slog.d(TAG,""String_Node_Str"" + info + ""String_Node_Str""+ connectionStatus);
  int inetCondition=(connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
switch (info.getType()) {
case ConnectivityManager.TYPE_MOBILE:
    mInetCondition=inetCondition;
  updateDataNetType(info.getSubtype());
updateDataIcon();
updateSignalStrength();
break;
case ConnectivityManager.TYPE_WIFI:
mInetCondition=inetCondition;
if (info.isConnected()) {
mIsWifiConnected=true;
int iconId;
if (mLastWifiSignalLevel == -1) {
iconId=sWifiSignalImages[mInetCondition][0];
}
 else {
iconId=sWifiSignalImages[mInetCondition][mLastWifiSignalLevel];
}
mService.setIcon(""String_Node_Str"",iconId,0);
mService.setIconVisibility(""String_Node_Str"",true);
}
 else {
mLastWifiSignalLevel=-1;
mIsWifiConnected=false;
int iconId=sWifiSignalImages[0][0];
mService.setIcon(""String_Node_Str"",iconId,0);
mService.setIconVisibility(""String_Node_Str"",false);
}
updateSignalStrength();
break;
}
}",0.7019813991103923
181372,"@Override public void onDataConnectionStateChanged(int state,int networkType){
  mDataState=state;
  updateDataNetType(networkType,0);
  updateDataIcon();
  updateSignalStrength();
}","@Override public void onDataConnectionStateChanged(int state,int networkType){
  mDataState=state;
  updateDataNetType(networkType);
  updateDataIcon();
}",0.9166666666666666
181373,"private final void updateDataNetType(int net,int inetCondition){
  mInetCondition=(inetCondition > INET_CONDITION_THRESHOLD ? 1 : 0);
switch (net) {
case TelephonyManager.NETWORK_TYPE_EDGE:
    mDataIconList=sDataNetType_e[mInetCondition];
  break;
case TelephonyManager.NETWORK_TYPE_UMTS:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_HSDPA:
case TelephonyManager.NETWORK_TYPE_HSUPA:
case TelephonyManager.NETWORK_TYPE_HSPA:
if (mHspaDataDistinguishable) {
mDataIconList=sDataNetType_h[mInetCondition];
}
 else {
mDataIconList=sDataNetType_3g[mInetCondition];
}
break;
case TelephonyManager.NETWORK_TYPE_CDMA:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_1xRTT:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_EVDO_0:
case TelephonyManager.NETWORK_TYPE_EVDO_A:
case TelephonyManager.NETWORK_TYPE_EVDO_B:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
default :
mDataIconList=sDataNetType_g[mInetCondition];
break;
}
}","private final void updateDataNetType(int net){
switch (net) {
case TelephonyManager.NETWORK_TYPE_EDGE:
    mDataIconList=sDataNetType_e[mInetCondition];
  break;
case TelephonyManager.NETWORK_TYPE_UMTS:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_HSDPA:
case TelephonyManager.NETWORK_TYPE_HSUPA:
case TelephonyManager.NETWORK_TYPE_HSPA:
if (mHspaDataDistinguishable) {
mDataIconList=sDataNetType_h[mInetCondition];
}
 else {
mDataIconList=sDataNetType_3g[mInetCondition];
}
break;
case TelephonyManager.NETWORK_TYPE_CDMA:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_1xRTT:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_EVDO_0:
case TelephonyManager.NETWORK_TYPE_EVDO_A:
case TelephonyManager.NETWORK_TYPE_EVDO_B:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
default :
mDataIconList=sDataNetType_g[mInetCondition];
break;
}
}",0.9569093610698366
181374,"/** 
 * Called when an attempt to fail over to another network has failed.
 * @param info the {@link NetworkInfo} for the failed network
 */
private void handleConnectionFailure(NetworkInfo info){
  mNetTrackers[info.getType()].setTeardownRequested(false);
  String reason=info.getReason();
  String extraInfo=info.getExtraInfo();
  if (DBG) {
    String reasonText;
    if (reason == null) {
      reasonText=""String_Node_Str"";
    }
 else {
      reasonText=""String_Node_Str"" + reason + ""String_Node_Str"";
    }
    Slog.v(TAG,""String_Node_Str"" + info.getTypeName() + ""String_Node_Str""+ reasonText);
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (getActiveNetworkInfo() == null) {
    intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
  }
  if (reason != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,reason);
  }
  if (extraInfo != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,extraInfo);
  }
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[info.getType()].isDefault()) {
    newNet=tryFailover(info.getType());
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}","/** 
 * Called when an attempt to fail over to another network has failed.
 * @param info the {@link NetworkInfo} for the failed network
 */
private void handleConnectionFailure(NetworkInfo info){
  mNetTrackers[info.getType()].setTeardownRequested(false);
  String reason=info.getReason();
  String extraInfo=info.getExtraInfo();
  if (DBG) {
    String reasonText;
    if (reason == null) {
      reasonText=""String_Node_Str"";
    }
 else {
      reasonText=""String_Node_Str"" + reason + ""String_Node_Str"";
    }
    Slog.v(TAG,""String_Node_Str"" + info.getTypeName() + ""String_Node_Str""+ reasonText);
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (getActiveNetworkInfo() == null) {
    intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
  }
  if (reason != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,reason);
  }
  if (extraInfo != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,extraInfo);
  }
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[info.getType()].isDefault()) {
    newNet=tryFailover(info.getType());
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      if (!switchTo.isConnected()) {
        mDefaultInetConditionPublished=0;
      }
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}",0.939452585015206
181375,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    newNet=tryFailover(prevNetType);
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange(prevNetType);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    newNet=tryFailover(prevNetType);
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      if (!switchTo.isConnected()) {
        mDefaultInetConditionPublished=0;
      }
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  handleConnectivityChange(prevNetType);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}",0.9405698778833108
181376,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
final boolean resumeTopActivityLocked(ActivityRecord prev){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mMainStack) {
      return mService.startHomeActivityLocked();
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
    long now=SystemClock.uptimeMillis();
    final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
    final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
    final int nextUid=next.info.applicationInfo.uid;
    if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
      mService.showLaunchWarningLocked(mLastStartedActivity,next);
    }
 else {
      next.startTime=now;
      mLastStartedActivity=next;
    }
  }
 else {
    next.startTime=SystemClock.uptimeMillis();
    mLastStartedActivity=next;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      }
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
    }
 else {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
    }
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mService.mWindowManager.setAppVisibility(next,true);
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.updateLruProcessLocked(next.app,true,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mMainStack) {
synchronized (mService) {
        Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
        if (config != null) {
          next.frozenBeforeDestroy=true;
        }
        updated=mService.updateConfigurationLocked(config,next);
      }
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mMainStack) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.app.thread.scheduleResumeActivity(next,mService.isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
          mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
final boolean resumeTopActivityLocked(ActivityRecord prev){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mMainStack) {
      return mService.startHomeActivityLocked();
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      }
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
    }
 else {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
    }
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mService.mWindowManager.setAppVisibility(next,true);
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.updateLruProcessLocked(next.app,true,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mMainStack) {
synchronized (mService) {
        Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
        if (config != null) {
          next.frozenBeforeDestroy=true;
        }
        updated=mService.updateConfigurationLocked(config,next);
      }
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mMainStack) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.app.thread.scheduleResumeActivity(next,mService.isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
          mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9968571611827336
181377,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
final boolean resumeTopActivityLocked(ActivityRecord prev){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mMainStack) {
      return mService.startHomeActivityLocked();
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
    long now=SystemClock.uptimeMillis();
    final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
    final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
    final int nextUid=next.info.applicationInfo.uid;
    if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
      mService.showLaunchWarningLocked(mLastStartedActivity,next);
    }
 else {
      next.startTime=now;
      mLastStartedActivity=next;
    }
  }
 else {
    next.startTime=SystemClock.uptimeMillis();
    mLastStartedActivity=next;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      }
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
    }
 else {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
    }
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mService.mWindowManager.setAppVisibility(next,true);
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.updateLruProcessLocked(next.app,true,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mMainStack) {
synchronized (mService) {
        Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
        if (config != null) {
          next.frozenBeforeDestroy=true;
        }
        updated=mService.updateConfigurationLocked(config,next);
      }
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mMainStack) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.app.thread.scheduleResumeActivity(next,mService.isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
          mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
final boolean resumeTopActivityLocked(ActivityRecord prev){
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mMainStack) {
      return mService.startHomeActivityLocked();
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Slog.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      }
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,""String_Node_Str"" + prev);
      if (mNoAnimActivities.contains(next)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"");
    if (mNoAnimActivities.contains(next)) {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
    }
 else {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
    }
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,""String_Node_Str"" + next);
    mService.mWindowManager.setAppVisibility(next,true);
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.updateLruProcessLocked(next.app,true,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mMainStack) {
synchronized (mService) {
        Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
        if (config != null) {
          next.frozenBeforeDestroy=true;
        }
        updated=mService.updateConfigurationLocked(config,next);
      }
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mMainStack) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.app.thread.scheduleResumeActivity(next,mService.isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
          mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9968571611827336
181378,"private void updateConnectivity(Intent intent){
  NetworkInfo info=(NetworkInfo)(intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO));
  int connectionStatus=intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION,0);
  Slog.d(TAG,""String_Node_Str"" + info + ""String_Node_Str""+ connectionStatus);
  if (info.isConnected() == false)   return;
switch (info.getType()) {
case ConnectivityManager.TYPE_MOBILE:
    if (info.isConnected()) {
      updateDataNetType(info.getSubtype(),connectionStatus);
      updateDataIcon();
      updateSignalStrength();
    }
  break;
case ConnectivityManager.TYPE_WIFI:
if (info.isConnected()) {
  mIsWifiConnected=true;
  mInetCondition=(connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
  int iconId;
  if (mLastWifiSignalLevel == -1) {
    iconId=sWifiSignalImages[mInetCondition][0];
  }
 else {
    iconId=sWifiSignalImages[mInetCondition][mLastWifiSignalLevel];
  }
  mService.setIcon(""String_Node_Str"",iconId,0);
  mService.setIconVisibility(""String_Node_Str"",true);
}
 else {
  mLastWifiSignalLevel=-1;
  mIsWifiConnected=false;
  mInetCondition=0;
  int iconId=sWifiSignalImages[0][0];
  mService.setIcon(""String_Node_Str"",iconId,0);
  mService.setIconVisibility(""String_Node_Str"",false);
}
updateSignalStrength();
break;
}
}","private void updateConnectivity(Intent intent){
  NetworkInfo info=(NetworkInfo)(intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO));
  int connectionStatus=intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION,0);
  Slog.d(TAG,""String_Node_Str"" + info + ""String_Node_Str""+ connectionStatus);
  int inetCondition=(connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
switch (info.getType()) {
case ConnectivityManager.TYPE_MOBILE:
    mInetCondition=inetCondition;
  updateDataNetType(info.getSubtype());
updateDataIcon();
updateSignalStrength();
break;
case ConnectivityManager.TYPE_WIFI:
mInetCondition=inetCondition;
if (info.isConnected()) {
mIsWifiConnected=true;
int iconId;
if (mLastWifiSignalLevel == -1) {
iconId=sWifiSignalImages[mInetCondition][0];
}
 else {
iconId=sWifiSignalImages[mInetCondition][mLastWifiSignalLevel];
}
mService.setIcon(""String_Node_Str"",iconId,0);
mService.setIconVisibility(""String_Node_Str"",true);
}
 else {
mLastWifiSignalLevel=-1;
mIsWifiConnected=false;
int iconId=sWifiSignalImages[0][0];
mService.setIcon(""String_Node_Str"",iconId,0);
mService.setIconVisibility(""String_Node_Str"",false);
}
updateSignalStrength();
break;
}
}",0.7019813991103923
181379,"@Override public void onDataConnectionStateChanged(int state,int networkType){
  mDataState=state;
  updateDataNetType(networkType,0);
  updateDataIcon();
  updateSignalStrength();
}","@Override public void onDataConnectionStateChanged(int state,int networkType){
  mDataState=state;
  updateDataNetType(networkType);
  updateDataIcon();
}",0.9166666666666666
181380,"private final void updateDataNetType(int net,int inetCondition){
  mInetCondition=(inetCondition > INET_CONDITION_THRESHOLD ? 1 : 0);
switch (net) {
case TelephonyManager.NETWORK_TYPE_EDGE:
    mDataIconList=sDataNetType_e[mInetCondition];
  break;
case TelephonyManager.NETWORK_TYPE_UMTS:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_HSDPA:
case TelephonyManager.NETWORK_TYPE_HSUPA:
case TelephonyManager.NETWORK_TYPE_HSPA:
if (mHspaDataDistinguishable) {
mDataIconList=sDataNetType_h[mInetCondition];
}
 else {
mDataIconList=sDataNetType_3g[mInetCondition];
}
break;
case TelephonyManager.NETWORK_TYPE_CDMA:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_1xRTT:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_EVDO_0:
case TelephonyManager.NETWORK_TYPE_EVDO_A:
case TelephonyManager.NETWORK_TYPE_EVDO_B:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
default :
mDataIconList=sDataNetType_g[mInetCondition];
break;
}
}","private final void updateDataNetType(int net){
switch (net) {
case TelephonyManager.NETWORK_TYPE_EDGE:
    mDataIconList=sDataNetType_e[mInetCondition];
  break;
case TelephonyManager.NETWORK_TYPE_UMTS:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_HSDPA:
case TelephonyManager.NETWORK_TYPE_HSUPA:
case TelephonyManager.NETWORK_TYPE_HSPA:
if (mHspaDataDistinguishable) {
mDataIconList=sDataNetType_h[mInetCondition];
}
 else {
mDataIconList=sDataNetType_3g[mInetCondition];
}
break;
case TelephonyManager.NETWORK_TYPE_CDMA:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_1xRTT:
mDataIconList=sDataNetType_1x[mInetCondition];
break;
case TelephonyManager.NETWORK_TYPE_EVDO_0:
case TelephonyManager.NETWORK_TYPE_EVDO_A:
case TelephonyManager.NETWORK_TYPE_EVDO_B:
mDataIconList=sDataNetType_3g[mInetCondition];
break;
default :
mDataIconList=sDataNetType_g[mInetCondition];
break;
}
}",0.9569093610698366
181381,"/** 
 * Called when an attempt to fail over to another network has failed.
 * @param info the {@link NetworkInfo} for the failed network
 */
private void handleConnectionFailure(NetworkInfo info){
  mNetTrackers[info.getType()].setTeardownRequested(false);
  String reason=info.getReason();
  String extraInfo=info.getExtraInfo();
  if (DBG) {
    String reasonText;
    if (reason == null) {
      reasonText=""String_Node_Str"";
    }
 else {
      reasonText=""String_Node_Str"" + reason + ""String_Node_Str"";
    }
    Slog.v(TAG,""String_Node_Str"" + info.getTypeName() + ""String_Node_Str""+ reasonText);
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (getActiveNetworkInfo() == null) {
    intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
  }
  if (reason != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,reason);
  }
  if (extraInfo != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,extraInfo);
  }
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[info.getType()].isDefault()) {
    newNet=tryFailover(info.getType());
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}","/** 
 * Called when an attempt to fail over to another network has failed.
 * @param info the {@link NetworkInfo} for the failed network
 */
private void handleConnectionFailure(NetworkInfo info){
  mNetTrackers[info.getType()].setTeardownRequested(false);
  String reason=info.getReason();
  String extraInfo=info.getExtraInfo();
  if (DBG) {
    String reasonText;
    if (reason == null) {
      reasonText=""String_Node_Str"";
    }
 else {
      reasonText=""String_Node_Str"" + reason + ""String_Node_Str"";
    }
    Slog.v(TAG,""String_Node_Str"" + info.getTypeName() + ""String_Node_Str""+ reasonText);
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (getActiveNetworkInfo() == null) {
    intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
  }
  if (reason != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,reason);
  }
  if (extraInfo != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,extraInfo);
  }
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[info.getType()].isDefault()) {
    newNet=tryFailover(info.getType());
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      if (!switchTo.isConnected()) {
        mDefaultInetConditionPublished=0;
      }
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}",0.939452585015206
181382,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    newNet=tryFailover(prevNetType);
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange(prevNetType);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    newNet=tryFailover(prevNetType);
    if (newNet != null) {
      NetworkInfo switchTo=newNet.getNetworkInfo();
      if (!switchTo.isConnected()) {
        mDefaultInetConditionPublished=0;
      }
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  handleConnectivityChange(prevNetType);
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected()) {
    sendConnectedBroadcast(newNet.getNetworkInfo());
  }
}",0.9405698778833108
181383,"/** 
 * @hide
 */
@Override public void onDrawOverlay(Canvas canvas){
  if ((mGroupFlags & FLAG_CHILD_HAS_OVERLAY) == FLAG_CHILD_HAS_OVERLAY) {
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.isOverlayEnabled()) {
        canvas.translate(child.mLeft + child.mScrollX,child.mTop + child.mScrollY);
        child.onDrawOverlay(canvas);
        canvas.translate(-(child.mLeft + child.mScrollX),-(child.mTop + child.mScrollY));
      }
    }
  }
}","/** 
 * @hide
 */
@Override public void onDrawOverlay(Canvas canvas){
  if ((mGroupFlags & FLAG_CHILD_HAS_OVERLAY) == FLAG_CHILD_HAS_OVERLAY) {
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.isOverlayEnabled()) {
        canvas.translate(child.mLeft - child.mScrollX,child.mTop - child.mScrollY);
        child.onDrawOverlay(canvas);
        canvas.translate(-(child.mLeft - child.mScrollX),-(child.mTop - child.mScrollY));
      }
    }
  }
}",0.9924953095684804
181384,"void positionAtCursor(final int offset,boolean bottom){
  final int drawableWidth=mDrawable.getIntrinsicWidth();
  final int drawableHeight=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  mHotSpotVerticalPosition=lineTop;
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - drawableWidth / 2.0) + mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop) + mScrollY;
  mTopExtension=bottom ? 0 : drawableHeight / 2;
  mBottomExtension=0;
  if (line == mLayout.getLineCount() - 1) {
    mTopExtension=(lineBottom - lineTop) - drawableHeight / 2;
  }
  bounds.right=bounds.left + drawableWidth;
  bounds.bottom=bounds.top + drawableHeight;
  convertFromViewportToContentCoordinates(bounds);
  mDrawable.setBounds(bounds);
  postInvalidate();
}","void positionAtCursor(final int offset,boolean bottom){
  final int drawableWidth=mDrawable.getIntrinsicWidth();
  final int drawableHeight=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  mHotSpotVerticalPosition=lineTop;
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - drawableWidth / 2.0) + mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop) + mScrollY;
  mTopExtension=bottom ? 0 : drawableHeight / 2;
  mBottomExtension=0;
  if (line == mLayout.getLineCount() - 1) {
    mTopExtension=(lineBottom - lineTop) - drawableHeight / 2;
  }
  bounds.right=bounds.left + drawableWidth;
  bounds.bottom=bounds.top + drawableHeight;
  convertFromViewportToContentCoordinates(bounds);
  invalidate();
  mDrawable.setBounds(bounds);
  invalidate();
}",0.9882100750267953
181385,"/** 
 * @hide
 */
@Override public void onDrawOverlay(Canvas canvas){
  if ((mGroupFlags & FLAG_CHILD_HAS_OVERLAY) == FLAG_CHILD_HAS_OVERLAY) {
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.isOverlayEnabled()) {
        canvas.translate(child.mLeft + child.mScrollX,child.mTop + child.mScrollY);
        child.onDrawOverlay(canvas);
        canvas.translate(-(child.mLeft + child.mScrollX),-(child.mTop + child.mScrollY));
      }
    }
  }
}","/** 
 * @hide
 */
@Override public void onDrawOverlay(Canvas canvas){
  if ((mGroupFlags & FLAG_CHILD_HAS_OVERLAY) == FLAG_CHILD_HAS_OVERLAY) {
    final int childCount=getChildCount();
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.isOverlayEnabled()) {
        canvas.translate(child.mLeft - child.mScrollX,child.mTop - child.mScrollY);
        child.onDrawOverlay(canvas);
        canvas.translate(-(child.mLeft - child.mScrollX),-(child.mTop - child.mScrollY));
      }
    }
  }
}",0.9924953095684804
181386,"void positionAtCursor(final int offset,boolean bottom){
  final int drawableWidth=mDrawable.getIntrinsicWidth();
  final int drawableHeight=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  mHotSpotVerticalPosition=lineTop;
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - drawableWidth / 2.0) + mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop) + mScrollY;
  mTopExtension=bottom ? 0 : drawableHeight / 2;
  mBottomExtension=0;
  if (line == mLayout.getLineCount() - 1) {
    mTopExtension=(lineBottom - lineTop) - drawableHeight / 2;
  }
  bounds.right=bounds.left + drawableWidth;
  bounds.bottom=bounds.top + drawableHeight;
  convertFromViewportToContentCoordinates(bounds);
  mDrawable.setBounds(bounds);
  postInvalidate();
}","void positionAtCursor(final int offset,boolean bottom){
  final int drawableWidth=mDrawable.getIntrinsicWidth();
  final int drawableHeight=mDrawable.getIntrinsicHeight();
  final int line=mLayout.getLineForOffset(offset);
  final int lineTop=mLayout.getLineTop(line);
  final int lineBottom=mLayout.getLineBottom(line);
  mHotSpotVerticalPosition=lineTop;
  final Rect bounds=sCursorControllerTempRect;
  bounds.left=(int)(mLayout.getPrimaryHorizontal(offset) - drawableWidth / 2.0) + mScrollX;
  bounds.top=(bottom ? lineBottom : lineTop) + mScrollY;
  mTopExtension=bottom ? 0 : drawableHeight / 2;
  mBottomExtension=0;
  if (line == mLayout.getLineCount() - 1) {
    mTopExtension=(lineBottom - lineTop) - drawableHeight / 2;
  }
  bounds.right=bounds.left + drawableWidth;
  bounds.bottom=bounds.top + drawableHeight;
  convertFromViewportToContentCoordinates(bounds);
  invalidate();
  mDrawable.setBounds(bounds);
  invalidate();
}",0.9882100750267953
181387,"@Override public void hangup() throws CallStateException {
synchronized (SipPhone.class) {
    Log.v(LOG_TAG,""String_Node_Str"" + mPeer.getUriString() + ""String_Node_Str""+ ""String_Node_Str""+ getPhone().getPhoneName());
    try {
      mSipAudioCall.endCall();
      setState(Call.State.DISCONNECTING);
      setDisconnectCause(DisconnectCause.LOCAL);
    }
 catch (    SipException e) {
      throw new CallStateException(""String_Node_Str"" + e);
    }
  }
}","@Override public void hangup() throws CallStateException {
synchronized (SipPhone.class) {
    Log.v(LOG_TAG,""String_Node_Str"" + mPeer.getUriString() + ""String_Node_Str""+ ""String_Node_Str""+ getPhone().getPhoneName());
    try {
      if (mSipAudioCall != null)       mSipAudioCall.endCall();
      setState(Call.State.DISCONNECTING);
      setDisconnectCause(DisconnectCause.LOCAL);
    }
 catch (    SipException e) {
      throw new CallStateException(""String_Node_Str"" + e);
    }
  }
}",0.9650793650793652
181388,"void noteStopWakeLocked(WakeLock wl,WorkSource ws){
  try {
    if (ws != null) {
      mBatteryStats.noteStopWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
    }
 else {
      mBatteryStats.noteStopWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
    }
  }
 catch (  RemoteException e) {
  }
}","void noteStopWakeLocked(WakeLock wl,WorkSource ws){
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      if (ws != null) {
        mBatteryStats.noteStopWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
      }
 else {
        mBatteryStats.noteStopWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
      }
    }
 catch (    RemoteException e) {
    }
 finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.7328042328042328
181389,"public void updateWakeLockWorkSource(IBinder lock,WorkSource ws){
  int uid=Binder.getCallingUid();
  int pid=Binder.getCallingPid();
  if (ws != null && ws.size() == 0) {
    ws=null;
  }
  if (ws != null) {
    enforceWakeSourcePermission(uid,pid);
  }
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (mLocks) {
      int index=mLocks.getIndex(lock);
      if (index < 0) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      WakeLock wl=mLocks.get(index);
      WorkSource oldsource=wl.ws;
      wl.ws=ws != null ? new WorkSource(ws) : null;
      noteStopWakeLocked(wl,oldsource);
      noteStartWakeLocked(wl,ws);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void updateWakeLockWorkSource(IBinder lock,WorkSource ws){
  int uid=Binder.getCallingUid();
  int pid=Binder.getCallingPid();
  if (ws != null && ws.size() == 0) {
    ws=null;
  }
  if (ws != null) {
    enforceWakeSourcePermission(uid,pid);
  }
synchronized (mLocks) {
    int index=mLocks.getIndex(lock);
    if (index < 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    WakeLock wl=mLocks.get(index);
    WorkSource oldsource=wl.ws;
    wl.ws=ws != null ? new WorkSource(ws) : null;
    noteStopWakeLocked(wl,oldsource);
    noteStartWakeLocked(wl,ws);
  }
}",0.7390648567119156
181390,"void noteStartWakeLocked(WakeLock wl,WorkSource ws){
  try {
    if (ws != null) {
      mBatteryStats.noteStartWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
    }
 else {
      mBatteryStats.noteStartWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
    }
  }
 catch (  RemoteException e) {
  }
}","void noteStartWakeLocked(WakeLock wl,WorkSource ws){
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      if (ws != null) {
        mBatteryStats.noteStartWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
      }
 else {
        mBatteryStats.noteStartWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
      }
    }
 catch (    RemoteException e) {
    }
 finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.7349081364829396
181391,"private void releaseWakeLockLocked(IBinder lock,int flags,boolean death){
  WakeLock wl=mLocks.removeLock(lock);
  if (wl == null) {
    return;
  }
  if (mSpew) {
    Slog.d(TAG,""String_Node_Str"" + Integer.toHexString(wl.flags) + ""String_Node_Str""+ wl.tag);
  }
  if (isScreenLock(wl.flags)) {
    mWakeLockState=mLocks.gatherState();
    if ((wl.flags & PowerManager.ON_AFTER_RELEASE) != 0) {
      userActivity(SystemClock.uptimeMillis(),false);
    }
    setPowerState(mWakeLockState | mUserState);
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PARTIAL_WAKE_LOCK) {
    mPartialCount--;
    if (mPartialCount == 0) {
      if (LOG_PARTIAL_WL)       EventLog.writeEvent(EventLogTags.POWER_PARTIAL_WAKE_STATE,0,wl.tag);
      Power.releaseWakeLock(PARTIAL_NAME);
    }
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK) {
    mProximityWakeLockCount--;
    if (mProximityWakeLockCount == 0) {
      if (mProximitySensorActive && ((flags & PowerManager.WAIT_FOR_PROXIMITY_NEGATIVE) != 0)) {
        if (mDebugProximitySensor) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
 else {
        disableProximityLockLocked();
      }
    }
  }
  wl.binder.unlinkToDeath(wl,0);
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      noteStopWakeLocked(wl,wl.ws);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}","private void releaseWakeLockLocked(IBinder lock,int flags,boolean death){
  WakeLock wl=mLocks.removeLock(lock);
  if (wl == null) {
    return;
  }
  if (mSpew) {
    Slog.d(TAG,""String_Node_Str"" + Integer.toHexString(wl.flags) + ""String_Node_Str""+ wl.tag);
  }
  if (isScreenLock(wl.flags)) {
    mWakeLockState=mLocks.gatherState();
    if ((wl.flags & PowerManager.ON_AFTER_RELEASE) != 0) {
      userActivity(SystemClock.uptimeMillis(),false);
    }
    setPowerState(mWakeLockState | mUserState);
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PARTIAL_WAKE_LOCK) {
    mPartialCount--;
    if (mPartialCount == 0) {
      if (LOG_PARTIAL_WL)       EventLog.writeEvent(EventLogTags.POWER_PARTIAL_WAKE_STATE,0,wl.tag);
      Power.releaseWakeLock(PARTIAL_NAME);
    }
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK) {
    mProximityWakeLockCount--;
    if (mProximityWakeLockCount == 0) {
      if (mProximitySensorActive && ((flags & PowerManager.WAIT_FOR_PROXIMITY_NEGATIVE) != 0)) {
        if (mDebugProximitySensor) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
 else {
        disableProximityLockLocked();
      }
    }
  }
  wl.binder.unlinkToDeath(wl,0);
  noteStopWakeLocked(wl,wl.ws);
}",0.9274823354406844
181392,"void clearModes(int modeFlags){
  if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : readOwners) {
        r.removeReadPermission(this);
      }
      readOwners.clear();
    }
  }
  if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : writeOwners) {
        r.removeWritePermission(this);
      }
      readOwners.clear();
    }
  }
}","void clearModes(int modeFlagsToClear){
  if ((modeFlagsToClear & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : readOwners) {
        r.removeReadPermission(this);
      }
      readOwners.clear();
    }
  }
  if ((modeFlagsToClear & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : writeOwners) {
        r.removeWritePermission(this);
      }
      readOwners.clear();
    }
  }
}",0.9860093271152564
181393,"/** 
 * Writes a new home time zone to the db. Updates the home time zone in the db asynchronously and updates the local cache. Sending a time zone of  {@link CalendarCache#TIMEZONE_TYPE_AUTO} will cause it to be setto the device's time zone. null or empty tz will be ignored.
 * @param context The calling activity
 * @param timeZone The time zone to set Calendar to, or{@link CalendarCache#TIMEZONE_TYPE_AUTO}
 */
public void setTimeZone(Context context,String timeZone){
  if (TextUtils.isEmpty(timeZone)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
    return;
  }
  boolean updatePrefs=false;
synchronized (mTZCallbacks) {
    if (CalendarCache.TIMEZONE_TYPE_AUTO.equals(timeZone)) {
      if (mUseHomeTZ) {
        updatePrefs=true;
      }
      mUseHomeTZ=false;
    }
 else {
      if (!mUseHomeTZ || !TextUtils.equals(mHomeTZ,timeZone)) {
        updatePrefs=true;
      }
      mUseHomeTZ=true;
      mHomeTZ=timeZone;
    }
  }
  if (updatePrefs) {
    SharedPreferences prefs=getSharedPreferences(context,mPrefsName);
    setSharedPreference(prefs,KEY_HOME_TZ_ENABLED,mUseHomeTZ);
    setSharedPreference(prefs,KEY_HOME_TZ,mHomeTZ);
    ContentValues values=new ContentValues();
    if (mHandler == null) {
      mHandler=new AsyncTZHandler(context.getContentResolver());
    }
    mHandler.cancelOperation(mToken);
    if (++mToken == 0) {
      mToken=1;
    }
    String[] selArgs=new String[]{CalendarCache.TIMEZONE_KEY_TYPE};
    values.put(CalendarCache.VALUE,mUseHomeTZ ? CalendarCache.TIMEZONE_TYPE_HOME : CalendarCache.TIMEZONE_TYPE_AUTO);
    mHandler.startUpdate(mToken,null,CalendarCache.URI,values,CalendarCache.WHERE,selArgs);
    if (mUseHomeTZ) {
      selArgs[0]=CalendarCache.TIMEZONE_KEY_INSTANCES;
      values.clear();
      values.put(CalendarCache.VALUE,mHomeTZ);
      mHandler.startUpdate(mToken,null,CalendarCache.URI,values,CalendarCache.WHERE,selArgs);
    }
  }
}","/** 
 * Writes a new home time zone to the db. Updates the home time zone in the db asynchronously and updates the local cache. Sending a time zone of  {@link CalendarCache#TIMEZONE_TYPE_AUTO} will cause it to be setto the device's time zone. null or empty tz will be ignored.
 * @param context The calling activity
 * @param timeZone The time zone to set Calendar to, or{@link CalendarCache#TIMEZONE_TYPE_AUTO}
 */
public void setTimeZone(Context context,String timeZone){
  if (TextUtils.isEmpty(timeZone)) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
    return;
  }
  boolean updatePrefs=false;
synchronized (mTZCallbacks) {
    if (CalendarCache.TIMEZONE_TYPE_AUTO.equals(timeZone)) {
      if (mUseHomeTZ) {
        updatePrefs=true;
      }
      mUseHomeTZ=false;
    }
 else {
      if (!mUseHomeTZ || !TextUtils.equals(mHomeTZ,timeZone)) {
        updatePrefs=true;
      }
      mUseHomeTZ=true;
      mHomeTZ=timeZone;
    }
  }
  if (updatePrefs) {
    SharedPreferences prefs=getSharedPreferences(context,mPrefsName);
    setSharedPreference(prefs,KEY_HOME_TZ_ENABLED,mUseHomeTZ);
    setSharedPreference(prefs,KEY_HOME_TZ,mHomeTZ);
    ContentValues values=new ContentValues();
    if (mHandler == null) {
      mHandler=new AsyncTZHandler(context.getContentResolver());
    }
    mHandler.cancelOperation(mToken);
    if (++mToken == 0) {
      mToken=1;
    }
    values.put(CalendarCache.VALUE,mUseHomeTZ ? CalendarCache.TIMEZONE_TYPE_HOME : CalendarCache.TIMEZONE_TYPE_AUTO);
    mHandler.startUpdate(mToken,null,CalendarCache.URI,values,CalendarCache.WHERE,TIMEZONE_TYPE_ARGS);
    if (mUseHomeTZ) {
      ContentValues values2=new ContentValues();
      values2.put(CalendarCache.VALUE,mHomeTZ);
      mHandler.startUpdate(mToken,null,CalendarCache.URI,values2,CalendarCache.WHERE,TIMEZONE_INSTANCES_ARGS);
    }
  }
}",0.8625893566322478
181394,"void clearModes(int modeFlags){
  if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : readOwners) {
        r.removeReadPermission(this);
      }
      readOwners.clear();
    }
  }
  if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : writeOwners) {
        r.removeWritePermission(this);
      }
      readOwners.clear();
    }
  }
}","void clearModes(int modeFlagsToClear){
  if ((modeFlagsToClear & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_READ_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : readOwners) {
        r.removeReadPermission(this);
      }
      readOwners.clear();
    }
  }
  if ((modeFlagsToClear & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    globalModeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    modeFlags&=~Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
    if (readOwners.size() > 0) {
      for (      UriPermissionOwner r : writeOwners) {
        r.removeWritePermission(this);
      }
      readOwners.clear();
    }
  }
}",0.9860093271152564
181395,"public boolean remove(WorkSource other){
  int N1=mNum;
  final int[] uids1=mUids;
  final int N2=other.mNum;
  final int[] uids2=other.mUids;
  boolean changed=false;
  int i1=0;
  for (int i2=0; i2 < N2 && i1 < N1; i2++) {
    if (uids2[i2] == uids1[i1]) {
      N1--;
      if (i1 < N1)       System.arraycopy(uids1,i1,uids1,i1 - 1,N1 - i1);
    }
    while (i1 < N1 && uids2[i2] > uids1[i1]) {
      i1++;
    }
  }
  mNum=N1;
  return changed;
}","public boolean remove(WorkSource other){
  int N1=mNum;
  final int[] uids1=mUids;
  final int N2=other.mNum;
  final int[] uids2=other.mUids;
  boolean changed=false;
  int i1=0;
  for (int i2=0; i2 < N2 && i1 < N1; i2++) {
    if (uids2[i2] == uids1[i1]) {
      N1--;
      if (i1 < N1)       System.arraycopy(uids1,i1 + 1,uids1,i1,N1 - i1);
    }
    while (i1 < N1 && uids2[i2] > uids1[i1]) {
      i1++;
    }
  }
  mNum=N1;
  return changed;
}",0.9911111111111112
181396,"public boolean remove(WorkSource other){
  int N1=mNum;
  final int[] uids1=mUids;
  final int N2=other.mNum;
  final int[] uids2=other.mUids;
  boolean changed=false;
  int i1=0;
  for (int i2=0; i2 < N2 && i1 < N1; i2++) {
    if (uids2[i2] == uids1[i1]) {
      N1--;
      if (i1 < N1)       System.arraycopy(uids1,i1,uids1,i1 - 1,N1 - i1);
    }
    while (i1 < N1 && uids2[i2] > uids1[i1]) {
      i1++;
    }
  }
  mNum=N1;
  return changed;
}","public boolean remove(WorkSource other){
  int N1=mNum;
  final int[] uids1=mUids;
  final int N2=other.mNum;
  final int[] uids2=other.mUids;
  boolean changed=false;
  int i1=0;
  for (int i2=0; i2 < N2 && i1 < N1; i2++) {
    if (uids2[i2] == uids1[i1]) {
      N1--;
      if (i1 < N1)       System.arraycopy(uids1,i1 + 1,uids1,i1,N1 - i1);
    }
    while (i1 < N1 && uids2[i2] > uids1[i1]) {
      i1++;
    }
  }
  mNum=N1;
  return changed;
}",0.9911111111111112
181397,"void noteStopWakeLocked(WakeLock wl,WorkSource ws){
  try {
    if (ws != null) {
      mBatteryStats.noteStopWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
    }
 else {
      mBatteryStats.noteStopWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
    }
  }
 catch (  RemoteException e) {
  }
}","void noteStopWakeLocked(WakeLock wl,WorkSource ws){
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      if (ws != null) {
        mBatteryStats.noteStopWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
      }
 else {
        mBatteryStats.noteStopWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
      }
    }
 catch (    RemoteException e) {
    }
 finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.7328042328042328
181398,"public void updateWakeLockWorkSource(IBinder lock,WorkSource ws){
  int uid=Binder.getCallingUid();
  int pid=Binder.getCallingPid();
  if (ws != null && ws.size() == 0) {
    ws=null;
  }
  if (ws != null) {
    enforceWakeSourcePermission(uid,pid);
  }
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (mLocks) {
      int index=mLocks.getIndex(lock);
      if (index < 0) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      WakeLock wl=mLocks.get(index);
      WorkSource oldsource=wl.ws;
      wl.ws=ws != null ? new WorkSource(ws) : null;
      noteStopWakeLocked(wl,oldsource);
      noteStartWakeLocked(wl,ws);
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void updateWakeLockWorkSource(IBinder lock,WorkSource ws){
  int uid=Binder.getCallingUid();
  int pid=Binder.getCallingPid();
  if (ws != null && ws.size() == 0) {
    ws=null;
  }
  if (ws != null) {
    enforceWakeSourcePermission(uid,pid);
  }
synchronized (mLocks) {
    int index=mLocks.getIndex(lock);
    if (index < 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    WakeLock wl=mLocks.get(index);
    WorkSource oldsource=wl.ws;
    wl.ws=ws != null ? new WorkSource(ws) : null;
    noteStopWakeLocked(wl,oldsource);
    noteStartWakeLocked(wl,ws);
  }
}",0.7390648567119156
181399,"void noteStartWakeLocked(WakeLock wl,WorkSource ws){
  try {
    if (ws != null) {
      mBatteryStats.noteStartWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
    }
 else {
      mBatteryStats.noteStartWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
    }
  }
 catch (  RemoteException e) {
  }
}","void noteStartWakeLocked(WakeLock wl,WorkSource ws){
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      if (ws != null) {
        mBatteryStats.noteStartWakelockFromSource(ws,wl.pid,wl.tag,wl.monitorType);
      }
 else {
        mBatteryStats.noteStartWakelock(wl.uid,wl.pid,wl.tag,wl.monitorType);
      }
    }
 catch (    RemoteException e) {
    }
 finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.7349081364829396
181400,"private void releaseWakeLockLocked(IBinder lock,int flags,boolean death){
  WakeLock wl=mLocks.removeLock(lock);
  if (wl == null) {
    return;
  }
  if (mSpew) {
    Slog.d(TAG,""String_Node_Str"" + Integer.toHexString(wl.flags) + ""String_Node_Str""+ wl.tag);
  }
  if (isScreenLock(wl.flags)) {
    mWakeLockState=mLocks.gatherState();
    if ((wl.flags & PowerManager.ON_AFTER_RELEASE) != 0) {
      userActivity(SystemClock.uptimeMillis(),false);
    }
    setPowerState(mWakeLockState | mUserState);
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PARTIAL_WAKE_LOCK) {
    mPartialCount--;
    if (mPartialCount == 0) {
      if (LOG_PARTIAL_WL)       EventLog.writeEvent(EventLogTags.POWER_PARTIAL_WAKE_STATE,0,wl.tag);
      Power.releaseWakeLock(PARTIAL_NAME);
    }
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK) {
    mProximityWakeLockCount--;
    if (mProximityWakeLockCount == 0) {
      if (mProximitySensorActive && ((flags & PowerManager.WAIT_FOR_PROXIMITY_NEGATIVE) != 0)) {
        if (mDebugProximitySensor) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
 else {
        disableProximityLockLocked();
      }
    }
  }
  wl.binder.unlinkToDeath(wl,0);
  if (wl.monitorType >= 0) {
    long origId=Binder.clearCallingIdentity();
    try {
      noteStopWakeLocked(wl,wl.ws);
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}","private void releaseWakeLockLocked(IBinder lock,int flags,boolean death){
  WakeLock wl=mLocks.removeLock(lock);
  if (wl == null) {
    return;
  }
  if (mSpew) {
    Slog.d(TAG,""String_Node_Str"" + Integer.toHexString(wl.flags) + ""String_Node_Str""+ wl.tag);
  }
  if (isScreenLock(wl.flags)) {
    mWakeLockState=mLocks.gatherState();
    if ((wl.flags & PowerManager.ON_AFTER_RELEASE) != 0) {
      userActivity(SystemClock.uptimeMillis(),false);
    }
    setPowerState(mWakeLockState | mUserState);
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PARTIAL_WAKE_LOCK) {
    mPartialCount--;
    if (mPartialCount == 0) {
      if (LOG_PARTIAL_WL)       EventLog.writeEvent(EventLogTags.POWER_PARTIAL_WAKE_STATE,0,wl.tag);
      Power.releaseWakeLock(PARTIAL_NAME);
    }
  }
 else   if ((wl.flags & LOCK_MASK) == PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK) {
    mProximityWakeLockCount--;
    if (mProximityWakeLockCount == 0) {
      if (mProximitySensorActive && ((flags & PowerManager.WAIT_FOR_PROXIMITY_NEGATIVE) != 0)) {
        if (mDebugProximitySensor) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
 else {
        disableProximityLockLocked();
      }
    }
  }
  wl.binder.unlinkToDeath(wl,0);
  noteStopWakeLocked(wl,wl.ws);
}",0.9274823354406844
181401,"private boolean handleAuthentication(ResponseEvent event) throws SipException {
  Response response=event.getResponse();
  String nonce=getNonceFromResponse(response);
  if (((nonce != null) && nonce.equals(mLastNonce)) || (nonce == mLastNonce)) {
    return false;
  }
 else {
    mClientTransaction=mSipHelper.handleChallenge(event,getAccountManager());
    mDialog=mClientTransaction.getDialog();
    mLastNonce=nonce;
    return true;
  }
}","private boolean handleAuthentication(ResponseEvent event) throws SipException {
  Response response=event.getResponse();
  String nonce=getNonceFromResponse(response);
  if (((nonce != null) && nonce.equals(mLastNonce)) || (nonce == null)) {
    mLastNonce=nonce;
    return false;
  }
 else {
    mClientTransaction=mSipHelper.handleChallenge(event,getAccountManager());
    mDialog=mClientTransaction.getDialog();
    mLastNonce=nonce;
    return true;
  }
}",0.9734513274336284
181402,"private String getNonceFromResponse(Response response){
  WWWAuthenticate authHeader=(WWWAuthenticate)(response.getHeader(SIPHeaderNames.WWW_AUTHENTICATE));
  return (authHeader == null) ? null : authHeader.getNonce();
}","private String getNonceFromResponse(Response response){
  WWWAuthenticate wwwAuth=(WWWAuthenticate)response.getHeader(SIPHeaderNames.WWW_AUTHENTICATE);
  if (wwwAuth != null)   return wwwAuth.getNonce();
  ProxyAuthenticate proxyAuth=(ProxyAuthenticate)response.getHeader(SIPHeaderNames.PROXY_AUTHENTICATE);
  return (proxyAuth == null) ? null : proxyAuth.getNonce();
}",0.5704584040747029
181403,"private boolean handleAuthentication(ResponseEvent event) throws SipException {
  Response response=event.getResponse();
  String nonce=getNonceFromResponse(response);
  if (((nonce != null) && nonce.equals(mLastNonce)) || (nonce == mLastNonce)) {
    return false;
  }
 else {
    mClientTransaction=mSipHelper.handleChallenge(event,getAccountManager());
    mDialog=mClientTransaction.getDialog();
    mLastNonce=nonce;
    return true;
  }
}","private boolean handleAuthentication(ResponseEvent event) throws SipException {
  Response response=event.getResponse();
  String nonce=getNonceFromResponse(response);
  if (((nonce != null) && nonce.equals(mLastNonce)) || (nonce == null)) {
    mLastNonce=nonce;
    return false;
  }
 else {
    mClientTransaction=mSipHelper.handleChallenge(event,getAccountManager());
    mDialog=mClientTransaction.getDialog();
    mLastNonce=nonce;
    return true;
  }
}",0.9734513274336284
181404,"private String getNonceFromResponse(Response response){
  WWWAuthenticate authHeader=(WWWAuthenticate)(response.getHeader(SIPHeaderNames.WWW_AUTHENTICATE));
  return (authHeader == null) ? null : authHeader.getNonce();
}","private String getNonceFromResponse(Response response){
  WWWAuthenticate wwwAuth=(WWWAuthenticate)response.getHeader(SIPHeaderNames.WWW_AUTHENTICATE);
  if (wwwAuth != null)   return wwwAuth.getNonce();
  ProxyAuthenticate proxyAuth=(ProxyAuthenticate)response.getHeader(SIPHeaderNames.PROXY_AUTHENTICATE);
  return (proxyAuth == null) ? null : proxyAuth.getNonce();
}",0.5704584040747029
181405,"protected void onDataSetupComplete(AsyncResult ar){
  String reason=null;
  if (ar.userObj instanceof String) {
    reason=(String)ar.userObj;
  }
  if (ar.exception == null) {
    if (isApnTypeActive(Phone.APN_TYPE_DEFAULT)) {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      if (canSetPreferApn && preferredApn == null) {
        Log.d(LOG_TAG,""String_Node_Str"");
        preferredApn=mActiveApn;
        setPreferredApn(preferredApn.id);
      }
    }
 else {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
    notifyDefaultData(reason);
  }
 else {
    GsmDataConnection.FailCause cause;
    cause=(GsmDataConnection.FailCause)(ar.result);
    if (DBG)     log(""String_Node_Str"" + cause);
    if (cause.isEventLoggable()) {
      GsmCellLocation loc=((GsmCellLocation)phone.getCellLocation());
      EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,cause.ordinal(),loc != null ? loc.getCid() : -1,TelephonyManager.getDefault().getNetworkType());
    }
    if (cause.isPermanentFail()) {
      notifyNoData(cause);
      if (!mRequestedApnType.equals(Phone.APN_TYPE_DEFAULT)) {
        phone.notifyDataConnection(Phone.REASON_APN_FAILED);
        onEnableApn(apnTypeToId(mRequestedApnType),DISABLED);
      }
      return;
    }
    waitingApns.remove(0);
    if (waitingApns.isEmpty()) {
      startDelayedRetry(cause,reason);
    }
 else {
      setState(State.SCANNING);
      sendMessageDelayed(obtainMessage(EVENT_TRY_SETUP_DATA,reason),APN_DELAY_MILLIS);
    }
  }
}","protected void onDataSetupComplete(AsyncResult ar){
  String reason=null;
  if (ar.userObj instanceof String) {
    reason=(String)ar.userObj;
  }
  if (ar.exception == null) {
    if (isApnTypeActive(Phone.APN_TYPE_DEFAULT)) {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      if (canSetPreferApn && preferredApn == null) {
        Log.d(LOG_TAG,""String_Node_Str"");
        preferredApn=mActiveApn;
        setPreferredApn(preferredApn.id);
      }
    }
 else {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
    notifyDefaultData(reason);
  }
 else {
    GsmDataConnection.FailCause cause;
    cause=(GsmDataConnection.FailCause)(ar.result);
    if (DBG)     log(""String_Node_Str"" + cause);
    if (cause.isEventLoggable()) {
      GsmCellLocation loc=((GsmCellLocation)phone.getCellLocation());
      EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,cause.ordinal(),loc != null ? loc.getCid() : -1,TelephonyManager.getDefault().getNetworkType());
    }
    if (cause.isPermanentFail()) {
      notifyNoData(cause);
      phone.notifyDataConnection(Phone.REASON_APN_FAILED);
      onEnableApn(apnTypeToId(mRequestedApnType),DISABLED);
      return;
    }
    waitingApns.remove(0);
    if (waitingApns.isEmpty()) {
      startDelayedRetry(cause,reason);
    }
 else {
      setState(State.SCANNING);
      sendMessageDelayed(obtainMessage(EVENT_TRY_SETUP_DATA,reason),APN_DELAY_MILLIS);
    }
  }
}",0.9187183811129848
181406,"protected void onDataSetupComplete(AsyncResult ar){
  String reason=null;
  if (ar.userObj instanceof String) {
    reason=(String)ar.userObj;
  }
  if (ar.exception == null) {
    if (isApnTypeActive(Phone.APN_TYPE_DEFAULT)) {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      if (canSetPreferApn && preferredApn == null) {
        Log.d(LOG_TAG,""String_Node_Str"");
        preferredApn=mActiveApn;
        setPreferredApn(preferredApn.id);
      }
    }
 else {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
    notifyDefaultData(reason);
  }
 else {
    GsmDataConnection.FailCause cause;
    cause=(GsmDataConnection.FailCause)(ar.result);
    if (DBG)     log(""String_Node_Str"" + cause);
    if (cause.isEventLoggable()) {
      GsmCellLocation loc=((GsmCellLocation)phone.getCellLocation());
      EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,cause.ordinal(),loc != null ? loc.getCid() : -1,TelephonyManager.getDefault().getNetworkType());
    }
    if (cause.isPermanentFail()) {
      notifyNoData(cause);
      if (!mRequestedApnType.equals(Phone.APN_TYPE_DEFAULT)) {
        phone.notifyDataConnection(Phone.REASON_APN_FAILED);
        onEnableApn(apnTypeToId(mRequestedApnType),DISABLED);
      }
      return;
    }
    waitingApns.remove(0);
    if (waitingApns.isEmpty()) {
      startDelayedRetry(cause,reason);
    }
 else {
      setState(State.SCANNING);
      sendMessageDelayed(obtainMessage(EVENT_TRY_SETUP_DATA,reason),APN_DELAY_MILLIS);
    }
  }
}","protected void onDataSetupComplete(AsyncResult ar){
  String reason=null;
  if (ar.userObj instanceof String) {
    reason=(String)ar.userObj;
  }
  if (ar.exception == null) {
    if (isApnTypeActive(Phone.APN_TYPE_DEFAULT)) {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      if (canSetPreferApn && preferredApn == null) {
        Log.d(LOG_TAG,""String_Node_Str"");
        preferredApn=mActiveApn;
        setPreferredApn(preferredApn.id);
      }
    }
 else {
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
    notifyDefaultData(reason);
  }
 else {
    GsmDataConnection.FailCause cause;
    cause=(GsmDataConnection.FailCause)(ar.result);
    if (DBG)     log(""String_Node_Str"" + cause);
    if (cause.isEventLoggable()) {
      GsmCellLocation loc=((GsmCellLocation)phone.getCellLocation());
      EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL,cause.ordinal(),loc != null ? loc.getCid() : -1,TelephonyManager.getDefault().getNetworkType());
    }
    if (cause.isPermanentFail()) {
      notifyNoData(cause);
      phone.notifyDataConnection(Phone.REASON_APN_FAILED);
      onEnableApn(apnTypeToId(mRequestedApnType),DISABLED);
      return;
    }
    waitingApns.remove(0);
    if (waitingApns.isEmpty()) {
      startDelayedRetry(cause,reason);
    }
 else {
      setState(State.SCANNING);
      sendMessageDelayed(obtainMessage(EVENT_TRY_SETUP_DATA,reason),APN_DELAY_MILLIS);
    }
  }
}",0.9187183811129848
181407,"/** 
 * Dumps a human-readable summary of the battery statistics to the given PrintWriter.
 * @param pw a Printer to receive the dump output.
 */
@SuppressWarnings(""String_Node_Str"") public void dumpLocked(PrintWriter pw){
  HistoryItem rec=getHistory();
  if (rec != null) {
    pw.println(""String_Node_Str"");
    int oldState=0;
    int oldStatus=-1;
    int oldHealth=-1;
    int oldPlug=-1;
    int oldTemp=-1;
    int oldVolt=-1;
    while (rec != null) {
      pw.print(""String_Node_Str"");
      pw.print(rec.time);
      pw.print(""String_Node_Str"");
      if (rec.cmd == HistoryItem.CMD_START) {
        pw.println(""String_Node_Str"");
      }
 else {
        if (rec.batteryLevel < 10)         pw.print(""String_Node_Str"");
 else         if (rec.batteryLevel < 100)         pw.print(""String_Node_Str"");
        pw.print(rec.batteryLevel);
        pw.print(""String_Node_Str"");
        if (rec.states < 0x10)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000000)         pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(rec.states));
        if (oldStatus != rec.batteryStatus) {
          oldStatus=rec.batteryStatus;
          pw.print(""String_Node_Str"");
switch (oldStatus) {
case BatteryManager.BATTERY_STATUS_UNKNOWN:
            pw.print(""String_Node_Str"");
          break;
case BatteryManager.BATTERY_STATUS_CHARGING:
        pw.print(""String_Node_Str"");
      break;
case BatteryManager.BATTERY_STATUS_DISCHARGING:
    pw.print(""String_Node_Str"");
  break;
case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_STATUS_FULL:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldStatus);
break;
}
}
if (oldHealth != rec.batteryHealth) {
oldHealth=rec.batteryHealth;
pw.print(""String_Node_Str"");
switch (oldHealth) {
case BatteryManager.BATTERY_HEALTH_UNKNOWN:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_GOOD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVERHEAT:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_DEAD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldHealth);
break;
}
}
if (oldPlug != rec.batteryPlugType) {
oldPlug=rec.batteryPlugType;
pw.print(""String_Node_Str"");
switch (oldPlug) {
case 0:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_AC:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_USB:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldPlug);
break;
}
}
if (oldTemp != rec.batteryTemperature) {
oldTemp=rec.batteryTemperature;
pw.print(""String_Node_Str"");
pw.print(oldTemp);
}
if (oldVolt != rec.batteryVoltage) {
oldVolt=rec.batteryVoltage;
pw.print(""String_Node_Str"");
pw.print(oldVolt);
}
printBitDescriptions(pw,oldState,rec.states,HISTORY_STATE_DESCRIPTIONS);
pw.println();
}
oldState=rec.states;
rec=rec.next;
}
}
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"" + getStartCount() + ""String_Node_Str""+ getIsOnBattery());
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_CHARGED,-1);
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"");
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_UNPLUGGED,-1);
}","/** 
 * Dumps a human-readable summary of the battery statistics to the given PrintWriter.
 * @param pw a Printer to receive the dump output.
 */
@SuppressWarnings(""String_Node_Str"") public void dumpLocked(PrintWriter pw){
  HistoryItem rec=getHistory();
  if (rec != null) {
    pw.println(""String_Node_Str"");
    long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
    int oldState=0;
    int oldStatus=-1;
    int oldHealth=-1;
    int oldPlug=-1;
    int oldTemp=-1;
    int oldVolt=-1;
    while (rec != null) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(rec.time - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
      pw.print(""String_Node_Str"");
      if (rec.cmd == HistoryItem.CMD_START) {
        pw.println(""String_Node_Str"");
      }
 else {
        if (rec.batteryLevel < 10)         pw.print(""String_Node_Str"");
 else         if (rec.batteryLevel < 100)         pw.print(""String_Node_Str"");
        pw.print(rec.batteryLevel);
        pw.print(""String_Node_Str"");
        if (rec.states < 0x10)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000000)         pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(rec.states));
        if (oldStatus != rec.batteryStatus) {
          oldStatus=rec.batteryStatus;
          pw.print(""String_Node_Str"");
switch (oldStatus) {
case BatteryManager.BATTERY_STATUS_UNKNOWN:
            pw.print(""String_Node_Str"");
          break;
case BatteryManager.BATTERY_STATUS_CHARGING:
        pw.print(""String_Node_Str"");
      break;
case BatteryManager.BATTERY_STATUS_DISCHARGING:
    pw.print(""String_Node_Str"");
  break;
case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_STATUS_FULL:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldStatus);
break;
}
}
if (oldHealth != rec.batteryHealth) {
oldHealth=rec.batteryHealth;
pw.print(""String_Node_Str"");
switch (oldHealth) {
case BatteryManager.BATTERY_HEALTH_UNKNOWN:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_GOOD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVERHEAT:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_DEAD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldHealth);
break;
}
}
if (oldPlug != rec.batteryPlugType) {
oldPlug=rec.batteryPlugType;
pw.print(""String_Node_Str"");
switch (oldPlug) {
case 0:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_AC:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_USB:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldPlug);
break;
}
}
if (oldTemp != rec.batteryTemperature) {
oldTemp=rec.batteryTemperature;
pw.print(""String_Node_Str"");
pw.print(oldTemp);
}
if (oldVolt != rec.batteryVoltage) {
oldVolt=rec.batteryVoltage;
pw.print(""String_Node_Str"");
pw.print(oldVolt);
}
printBitDescriptions(pw,oldState,rec.states,HISTORY_STATE_DESCRIPTIONS);
pw.println();
}
oldState=rec.states;
rec=rec.next;
}
pw.println(""String_Node_Str"");
}
SparseArray<? extends Uid> uidStats=getUidStats();
final int NU=uidStats.size();
boolean didPid=false;
long nowRealtime=SystemClock.elapsedRealtime();
StringBuilder sb=new StringBuilder(64);
for (int i=0; i < NU; i++) {
Uid uid=uidStats.valueAt(i);
SparseArray<? extends Uid.Pid> pids=uid.getPidStats();
if (pids != null) {
for (int j=0; j < pids.size(); j++) {
Uid.Pid pid=pids.valueAt(j);
if (!didPid) {
pw.println(""String_Node_Str"");
didPid=true;
}
long time=pid.mWakeSum + (pid.mWakeStart != 0 ? (nowRealtime - pid.mWakeStart) : 0);
pw.print(""String_Node_Str"");
pw.print(pids.keyAt(j));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(time,pw);
pw.println(""String_Node_Str"");
}
}
}
if (didPid) {
pw.println(""String_Node_Str"");
}
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"" + getStartCount() + ""String_Node_Str""+ getIsOnBattery());
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_CHARGED,-1);
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"");
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_UNPLUGGED,-1);
}",0.8906287069988138
181408,"/** 
 * @hide Just for debugging; not internationalized. 
 */
public static void formatDuration(long time,long now,PrintWriter pw){
  if (time == 0) {
    pw.print(""String_Node_Str"");
    return;
  }
  formatDuration(time - now,pw);
}","/** 
 * @hide Just for debugging; not internationalized. 
 */
public static void formatDuration(long time,long now,PrintWriter pw){
  if (time == 0) {
    pw.print(""String_Node_Str"");
    return;
  }
  formatDuration(time - now,pw,0);
}",0.9957446808510638
181409,"/** 
 * Dumps a human-readable summary of the battery statistics to the given PrintWriter.
 * @param pw a Printer to receive the dump output.
 */
@SuppressWarnings(""String_Node_Str"") public void dumpLocked(PrintWriter pw){
  HistoryItem rec=getHistory();
  if (rec != null) {
    pw.println(""String_Node_Str"");
    int oldState=0;
    int oldStatus=-1;
    int oldHealth=-1;
    int oldPlug=-1;
    int oldTemp=-1;
    int oldVolt=-1;
    while (rec != null) {
      pw.print(""String_Node_Str"");
      pw.print(rec.time);
      pw.print(""String_Node_Str"");
      if (rec.cmd == HistoryItem.CMD_START) {
        pw.println(""String_Node_Str"");
      }
 else {
        if (rec.batteryLevel < 10)         pw.print(""String_Node_Str"");
 else         if (rec.batteryLevel < 100)         pw.print(""String_Node_Str"");
        pw.print(rec.batteryLevel);
        pw.print(""String_Node_Str"");
        if (rec.states < 0x10)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000000)         pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(rec.states));
        if (oldStatus != rec.batteryStatus) {
          oldStatus=rec.batteryStatus;
          pw.print(""String_Node_Str"");
switch (oldStatus) {
case BatteryManager.BATTERY_STATUS_UNKNOWN:
            pw.print(""String_Node_Str"");
          break;
case BatteryManager.BATTERY_STATUS_CHARGING:
        pw.print(""String_Node_Str"");
      break;
case BatteryManager.BATTERY_STATUS_DISCHARGING:
    pw.print(""String_Node_Str"");
  break;
case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_STATUS_FULL:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldStatus);
break;
}
}
if (oldHealth != rec.batteryHealth) {
oldHealth=rec.batteryHealth;
pw.print(""String_Node_Str"");
switch (oldHealth) {
case BatteryManager.BATTERY_HEALTH_UNKNOWN:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_GOOD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVERHEAT:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_DEAD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldHealth);
break;
}
}
if (oldPlug != rec.batteryPlugType) {
oldPlug=rec.batteryPlugType;
pw.print(""String_Node_Str"");
switch (oldPlug) {
case 0:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_AC:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_USB:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldPlug);
break;
}
}
if (oldTemp != rec.batteryTemperature) {
oldTemp=rec.batteryTemperature;
pw.print(""String_Node_Str"");
pw.print(oldTemp);
}
if (oldVolt != rec.batteryVoltage) {
oldVolt=rec.batteryVoltage;
pw.print(""String_Node_Str"");
pw.print(oldVolt);
}
printBitDescriptions(pw,oldState,rec.states,HISTORY_STATE_DESCRIPTIONS);
pw.println();
}
oldState=rec.states;
rec=rec.next;
}
}
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"" + getStartCount() + ""String_Node_Str""+ getIsOnBattery());
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_CHARGED,-1);
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"");
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_UNPLUGGED,-1);
}","/** 
 * Dumps a human-readable summary of the battery statistics to the given PrintWriter.
 * @param pw a Printer to receive the dump output.
 */
@SuppressWarnings(""String_Node_Str"") public void dumpLocked(PrintWriter pw){
  HistoryItem rec=getHistory();
  if (rec != null) {
    pw.println(""String_Node_Str"");
    long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
    int oldState=0;
    int oldStatus=-1;
    int oldHealth=-1;
    int oldPlug=-1;
    int oldTemp=-1;
    int oldVolt=-1;
    while (rec != null) {
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(rec.time - now,pw,TimeUtils.HUNDRED_DAY_FIELD_LEN);
      pw.print(""String_Node_Str"");
      if (rec.cmd == HistoryItem.CMD_START) {
        pw.println(""String_Node_Str"");
      }
 else {
        if (rec.batteryLevel < 10)         pw.print(""String_Node_Str"");
 else         if (rec.batteryLevel < 100)         pw.print(""String_Node_Str"");
        pw.print(rec.batteryLevel);
        pw.print(""String_Node_Str"");
        if (rec.states < 0x10)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x100000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x1000000)         pw.print(""String_Node_Str"");
 else         if (rec.states < 0x10000000)         pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(rec.states));
        if (oldStatus != rec.batteryStatus) {
          oldStatus=rec.batteryStatus;
          pw.print(""String_Node_Str"");
switch (oldStatus) {
case BatteryManager.BATTERY_STATUS_UNKNOWN:
            pw.print(""String_Node_Str"");
          break;
case BatteryManager.BATTERY_STATUS_CHARGING:
        pw.print(""String_Node_Str"");
      break;
case BatteryManager.BATTERY_STATUS_DISCHARGING:
    pw.print(""String_Node_Str"");
  break;
case BatteryManager.BATTERY_STATUS_NOT_CHARGING:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_STATUS_FULL:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldStatus);
break;
}
}
if (oldHealth != rec.batteryHealth) {
oldHealth=rec.batteryHealth;
pw.print(""String_Node_Str"");
switch (oldHealth) {
case BatteryManager.BATTERY_HEALTH_UNKNOWN:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_GOOD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVERHEAT:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_DEAD:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldHealth);
break;
}
}
if (oldPlug != rec.batteryPlugType) {
oldPlug=rec.batteryPlugType;
pw.print(""String_Node_Str"");
switch (oldPlug) {
case 0:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_AC:
pw.print(""String_Node_Str"");
break;
case BatteryManager.BATTERY_PLUGGED_USB:
pw.print(""String_Node_Str"");
break;
default :
pw.print(oldPlug);
break;
}
}
if (oldTemp != rec.batteryTemperature) {
oldTemp=rec.batteryTemperature;
pw.print(""String_Node_Str"");
pw.print(oldTemp);
}
if (oldVolt != rec.batteryVoltage) {
oldVolt=rec.batteryVoltage;
pw.print(""String_Node_Str"");
pw.print(oldVolt);
}
printBitDescriptions(pw,oldState,rec.states,HISTORY_STATE_DESCRIPTIONS);
pw.println();
}
oldState=rec.states;
rec=rec.next;
}
pw.println(""String_Node_Str"");
}
SparseArray<? extends Uid> uidStats=getUidStats();
final int NU=uidStats.size();
boolean didPid=false;
long nowRealtime=SystemClock.elapsedRealtime();
StringBuilder sb=new StringBuilder(64);
for (int i=0; i < NU; i++) {
Uid uid=uidStats.valueAt(i);
SparseArray<? extends Uid.Pid> pids=uid.getPidStats();
if (pids != null) {
for (int j=0; j < pids.size(); j++) {
Uid.Pid pid=pids.valueAt(j);
if (!didPid) {
pw.println(""String_Node_Str"");
didPid=true;
}
long time=pid.mWakeSum + (pid.mWakeStart != 0 ? (nowRealtime - pid.mWakeStart) : 0);
pw.print(""String_Node_Str"");
pw.print(pids.keyAt(j));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(time,pw);
pw.println(""String_Node_Str"");
}
}
}
if (didPid) {
pw.println(""String_Node_Str"");
}
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"" + getStartCount() + ""String_Node_Str""+ getIsOnBattery());
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_CHARGED,-1);
pw.println(""String_Node_Str"");
pw.println(""String_Node_Str"");
dumpLocked(pw,""String_Node_Str"",STATS_SINCE_UNPLUGGED,-1);
}",0.8906287069988138
181410,"/** 
 * @hide Just for debugging; not internationalized. 
 */
public static void formatDuration(long time,long now,PrintWriter pw){
  if (time == 0) {
    pw.print(""String_Node_Str"");
    return;
  }
  formatDuration(time - now,pw);
}","/** 
 * @hide Just for debugging; not internationalized. 
 */
public static void formatDuration(long time,long now,PrintWriter pw){
  if (time == 0) {
    pw.print(""String_Node_Str"");
    return;
  }
  formatDuration(time - now,pw,0);
}",0.9957446808510638
181411,"void edgeReached(int delta){
  mScroller.notifyVerticalEdgeReached(mScrollY,0,mOverflingDistance);
  mTouchMode=TOUCH_MODE_OVERFLING;
  if (mEdgeGlowTop != null) {
    final int vel=(int)mScroller.getCurrVelocity();
    if (delta > 0) {
      mEdgeGlowTop.onAbsorb(vel);
    }
 else {
      mEdgeGlowBottom.onAbsorb(vel);
    }
  }
  invalidate();
  post(this);
}","void edgeReached(int delta){
  mScroller.notifyVerticalEdgeReached(mScrollY,0,mOverflingDistance);
  final int overscrollMode=getOverscrollMode();
  if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    final int vel=(int)mScroller.getCurrVelocity();
    if (delta > 0) {
      mEdgeGlowTop.onAbsorb(vel);
    }
 else {
      mEdgeGlowBottom.onAbsorb(vel);
    }
  }
  invalidate();
  post(this);
}",0.5939675174013921
181412,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mMotionY=mLastY=(int)ev.getY();
          mMotionCorrection=0;
          mActivePointerId=ev.getPointerId(0);
          break;
        }
default :
{
        mActivePointerId=ev.getPointerId(0);
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            if (mTouchMode == TOUCH_MODE_FLING) {
              createScrollingCache();
              mTouchMode=TOUCH_MODE_SCROLL;
              mMotionCorrection=0;
              motionPosition=findMotionRow(y);
              reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
        }
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final int y=(int)ev.getY(pointerIndex);
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
requestDisallowInterceptTouchEvent(true);
}
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int motionIndex;
if (mMotionPosition >= 0) {
motionIndex=mMotionPosition - mFirstPosition;
}
 else {
motionIndex=getChildCount() / 2;
}
int motionViewPrevTop=0;
View motionView=this.getChildAt(motionIndex);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
boolean atEdge=false;
if (incrementalDeltaY != 0) {
atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(motionIndex);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
if (atEdge) {
  int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  overscrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
  if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
    mVelocityTracker.clear();
  }
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  if (mEdgeGlowTop != null) {
    if (rawDeltaY > 0) {
      mEdgeGlowTop.onPull((float)overscroll / getHeight());
    }
 else     if (rawDeltaY < 0) {
      mEdgeGlowBottom.onPull((float)overscroll / getHeight());
    }
  }
}
mMotionY=y;
invalidate();
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findClosestMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
overscrollBy(0,-incrementalDeltaY,0,mScrollY,0,0,0,mOverscrollDistance,true);
if (mEdgeGlowTop != null) {
if (rawDeltaY > 0) {
mEdgeGlowTop.onPull((float)-incrementalDeltaY / getHeight());
}
 else if (rawDeltaY < 0) {
mEdgeGlowBottom.onPull((float)-incrementalDeltaY / getHeight());
}
invalidate();
}
if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
mVelocityTracker.clear();
}
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mMotionY=mLastY=(int)ev.getY();
          mMotionCorrection=0;
          mActivePointerId=ev.getPointerId(0);
          break;
        }
default :
{
        mActivePointerId=ev.getPointerId(0);
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            if (mTouchMode == TOUCH_MODE_FLING) {
              createScrollingCache();
              mTouchMode=TOUCH_MODE_SCROLL;
              mMotionCorrection=0;
              motionPosition=findMotionRow(y);
              reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
        }
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final int y=(int)ev.getY(pointerIndex);
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
requestDisallowInterceptTouchEvent(true);
}
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int motionIndex;
if (mMotionPosition >= 0) {
motionIndex=mMotionPosition - mFirstPosition;
}
 else {
motionIndex=getChildCount() / 2;
}
int motionViewPrevTop=0;
View motionView=this.getChildAt(motionIndex);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
boolean atEdge=false;
if (incrementalDeltaY != 0) {
atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(motionIndex);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
if (atEdge) {
  int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  overscrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
  if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
    mVelocityTracker.clear();
  }
  final int overscrollMode=getOverscrollMode();
  if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
    mTouchMode=TOUCH_MODE_OVERSCROLL;
    if (rawDeltaY > 0) {
      mEdgeGlowTop.onPull((float)overscroll / getHeight());
    }
 else     if (rawDeltaY < 0) {
      mEdgeGlowBottom.onPull((float)overscroll / getHeight());
    }
  }
}
mMotionY=y;
invalidate();
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findClosestMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
overscrollBy(0,-incrementalDeltaY,0,mScrollY,0,0,0,mOverscrollDistance,true);
final int overscrollMode=getOverscrollMode();
if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
if (rawDeltaY > 0) {
mEdgeGlowTop.onPull((float)-incrementalDeltaY / getHeight());
}
 else if (rawDeltaY < 0) {
mEdgeGlowBottom.onPull((float)-incrementalDeltaY / getHeight());
}
invalidate();
}
if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
mVelocityTracker.clear();
}
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.9805413736634236
181413,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int pulledToX=oldX + deltaX;
    if (pulledToX < 0) {
      mEdgeGlowLeft.onPull((float)deltaX / getWidth());
    }
 else     if (pulledToX > range) {
      mEdgeGlowRight.onPull((float)deltaX / getWidth());
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.966563128083318
181414,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,getScrollRange(),0,mOverflingDistance,0,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      if (x < 0 && oldX >= 0) {
        mEdgeGlowLeft.onAbsorb((int)mScroller.getCurrVelocity());
      }
 else       if (x > range && oldX <= range) {
        mEdgeGlowRight.onAbsorb((int)mScroller.getCurrVelocity());
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,getScrollRange(),0,mOverflingDistance,0,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      final int overscrollMode=getOverscrollMode();
      if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
        if (x < 0 && oldX >= 0) {
          mEdgeGlowLeft.onAbsorb((int)mScroller.getCurrVelocity());
        }
 else         if (x > range && oldX <= range) {
          mEdgeGlowRight.onAbsorb((int)mScroller.getCurrVelocity());
        }
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.8636651870640456
181415,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int pulledToY=oldY + deltaY;
    if (pulledToY < 0) {
      mEdgeGlowTop.onPull((float)deltaY / getHeight());
    }
 else     if (pulledToY > range) {
      mEdgeGlowBottom.onPull((float)deltaY / getHeight());
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9665875479276976
181416,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,0,getScrollRange(),0,mOverflingDistance,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      if (y < 0 && oldY >= 0) {
        mEdgeGlowTop.onAbsorb((int)mScroller.getCurrVelocity());
      }
 else       if (y > range && oldY <= range) {
        mEdgeGlowBottom.onAbsorb((int)mScroller.getCurrVelocity());
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,0,getScrollRange(),0,mOverflingDistance,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      final int overscrollMode=getOverscrollMode();
      if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
        if (y < 0 && oldY >= 0) {
          mEdgeGlowTop.onAbsorb((int)mScroller.getCurrVelocity());
        }
 else         if (y > range && oldY <= range) {
          mEdgeGlowBottom.onAbsorb((int)mScroller.getCurrVelocity());
        }
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.8636651870640456
181417,"void edgeReached(int delta){
  mScroller.notifyVerticalEdgeReached(mScrollY,0,mOverflingDistance);
  mTouchMode=TOUCH_MODE_OVERFLING;
  if (mEdgeGlowTop != null) {
    final int vel=(int)mScroller.getCurrVelocity();
    if (delta > 0) {
      mEdgeGlowTop.onAbsorb(vel);
    }
 else {
      mEdgeGlowBottom.onAbsorb(vel);
    }
  }
  invalidate();
  post(this);
}","void edgeReached(int delta){
  mScroller.notifyVerticalEdgeReached(mScrollY,0,mOverflingDistance);
  final int overscrollMode=getOverscrollMode();
  if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    final int vel=(int)mScroller.getCurrVelocity();
    if (delta > 0) {
      mEdgeGlowTop.onAbsorb(vel);
    }
 else {
      mEdgeGlowBottom.onAbsorb(vel);
    }
  }
  invalidate();
  post(this);
}",0.5939675174013921
181418,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mMotionY=mLastY=(int)ev.getY();
          mMotionCorrection=0;
          mActivePointerId=ev.getPointerId(0);
          break;
        }
default :
{
        mActivePointerId=ev.getPointerId(0);
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            if (mTouchMode == TOUCH_MODE_FLING) {
              createScrollingCache();
              mTouchMode=TOUCH_MODE_SCROLL;
              mMotionCorrection=0;
              motionPosition=findMotionRow(y);
              reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
        }
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final int y=(int)ev.getY(pointerIndex);
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
requestDisallowInterceptTouchEvent(true);
}
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int motionIndex;
if (mMotionPosition >= 0) {
motionIndex=mMotionPosition - mFirstPosition;
}
 else {
motionIndex=getChildCount() / 2;
}
int motionViewPrevTop=0;
View motionView=this.getChildAt(motionIndex);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
boolean atEdge=false;
if (incrementalDeltaY != 0) {
atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(motionIndex);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
if (atEdge) {
  int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  overscrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
  if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
    mVelocityTracker.clear();
  }
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  if (mEdgeGlowTop != null) {
    if (rawDeltaY > 0) {
      mEdgeGlowTop.onPull((float)overscroll / getHeight());
    }
 else     if (rawDeltaY < 0) {
      mEdgeGlowBottom.onPull((float)overscroll / getHeight());
    }
  }
}
mMotionY=y;
invalidate();
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findClosestMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
overscrollBy(0,-incrementalDeltaY,0,mScrollY,0,0,0,mOverscrollDistance,true);
if (mEdgeGlowTop != null) {
if (rawDeltaY > 0) {
mEdgeGlowTop.onPull((float)-incrementalDeltaY / getHeight());
}
 else if (rawDeltaY < 0) {
mEdgeGlowBottom.onPull((float)-incrementalDeltaY / getHeight());
}
invalidate();
}
if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
mVelocityTracker.clear();
}
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mMotionY=mLastY=(int)ev.getY();
          mMotionCorrection=0;
          mActivePointerId=ev.getPointerId(0);
          break;
        }
default :
{
        mActivePointerId=ev.getPointerId(0);
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            if (mTouchMode == TOUCH_MODE_FLING) {
              createScrollingCache();
              mTouchMode=TOUCH_MODE_SCROLL;
              mMotionCorrection=0;
              motionPosition=findMotionRow(y);
              reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
        }
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final int y=(int)ev.getY(pointerIndex);
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
requestDisallowInterceptTouchEvent(true);
}
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int motionIndex;
if (mMotionPosition >= 0) {
motionIndex=mMotionPosition - mFirstPosition;
}
 else {
motionIndex=getChildCount() / 2;
}
int motionViewPrevTop=0;
View motionView=this.getChildAt(motionIndex);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
boolean atEdge=false;
if (incrementalDeltaY != 0) {
atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(motionIndex);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
if (atEdge) {
  int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  overscrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
  if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
    mVelocityTracker.clear();
  }
  final int overscrollMode=getOverscrollMode();
  if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
    mTouchMode=TOUCH_MODE_OVERSCROLL;
    if (rawDeltaY > 0) {
      mEdgeGlowTop.onPull((float)overscroll / getHeight());
    }
 else     if (rawDeltaY < 0) {
      mEdgeGlowBottom.onPull((float)overscroll / getHeight());
    }
  }
}
mMotionY=y;
invalidate();
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findClosestMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
overscrollBy(0,-incrementalDeltaY,0,mScrollY,0,0,0,mOverscrollDistance,true);
final int overscrollMode=getOverscrollMode();
if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
if (rawDeltaY > 0) {
mEdgeGlowTop.onPull((float)-incrementalDeltaY / getHeight());
}
 else if (rawDeltaY < 0) {
mEdgeGlowBottom.onPull((float)-incrementalDeltaY / getHeight());
}
invalidate();
}
if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
mVelocityTracker.clear();
}
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.9805413736634236
181419,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int pulledToX=oldX + deltaX;
    if (pulledToX < 0) {
      mEdgeGlowLeft.onPull((float)deltaX / getWidth());
    }
 else     if (pulledToX > range) {
      mEdgeGlowRight.onPull((float)deltaX / getWidth());
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(deltaX,0,mScrollX,0,range,0,mOverscrollDistance,0,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToX=oldX + deltaX;
      if (pulledToX < 0) {
        mEdgeGlowLeft.onPull((float)deltaX / getWidth());
      }
 else       if (pulledToX > range) {
        mEdgeGlowRight.onPull((float)deltaX / getWidth());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
  mEdgeGlowLeft.onRelease();
  mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowLeft != null) {
mEdgeGlowLeft.onRelease();
mEdgeGlowRight.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.966563128083318
181420,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,getScrollRange(),0,mOverflingDistance,0,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      if (x < 0 && oldX >= 0) {
        mEdgeGlowLeft.onAbsorb((int)mScroller.getCurrVelocity());
      }
 else       if (x > range && oldX <= range) {
        mEdgeGlowRight.onAbsorb((int)mScroller.getCurrVelocity());
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,getScrollRange(),0,mOverflingDistance,0,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      final int overscrollMode=getOverscrollMode();
      if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
        if (x < 0 && oldX >= 0) {
          mEdgeGlowLeft.onAbsorb((int)mScroller.getCurrVelocity());
        }
 else         if (x > range && oldX <= range) {
          mEdgeGlowRight.onAbsorb((int)mScroller.getCurrVelocity());
        }
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.8636651870640456
181421,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int pulledToY=oldY + deltaY;
    if (pulledToY < 0) {
      mEdgeGlowTop.onPull((float)deltaY / getHeight());
    }
 else     if (pulledToY > range) {
      mEdgeGlowBottom.onPull((float)deltaY / getHeight());
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    final int range=getScrollRange();
    if (overscrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true)) {
      mVelocityTracker.clear();
    }
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
    final int overscrollMode=getOverscrollMode();
    if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
      final int pulledToY=oldY + deltaY;
      if (pulledToY < 0) {
        mEdgeGlowTop.onPull((float)deltaY / getHeight());
      }
 else       if (pulledToY > range) {
        mEdgeGlowBottom.onPull((float)deltaY / getHeight());
      }
    }
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
  mEdgeGlowTop.onRelease();
  mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9665875479276976
181422,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,0,getScrollRange(),0,mOverflingDistance,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      if (y < 0 && oldY >= 0) {
        mEdgeGlowTop.onAbsorb((int)mScroller.getCurrVelocity());
      }
 else       if (y > range && oldY <= range) {
        mEdgeGlowBottom.onAbsorb((int)mScroller.getCurrVelocity());
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (oldX != x || oldY != y) {
      overscrollBy(x - oldX,y - oldY,oldX,oldY,0,getScrollRange(),0,mOverflingDistance,false);
      onScrollChanged(mScrollX,mScrollY,oldX,oldY);
      final int range=getScrollRange();
      final int overscrollMode=getOverscrollMode();
      if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && range > 0)) {
        if (y < 0 && oldY >= 0) {
          mEdgeGlowTop.onAbsorb((int)mScroller.getCurrVelocity());
        }
 else         if (y > range && oldY <= range) {
          mEdgeGlowBottom.onAbsorb((int)mScroller.getCurrVelocity());
        }
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.8636651870640456
181423,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  final boolean deleteCodeAndResources;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    flags&=~PackageManager.DONT_DELETE_DATA;
  }
 else {
    deleteCodeAndResources=false;
    flags|=PackageManager.DONT_DELETE_DATA;
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}",0.9255874673629244
181424,"public void run(){
  if (mDataChanged) {
    post(this);
  }
 else {
    fireOnSelected();
  }
}","public void run(){
  if (mDataChanged) {
    if (getAdapter() != null) {
      post(this);
    }
  }
 else {
    fireOnSelected();
  }
}",0.8275862068965517
181425,"@Override public void onInvalidated(){
  mDataChanged=true;
  if (AdapterView.this.getAdapter().hasStableIds()) {
    mInstanceState=AdapterView.this.onSaveInstanceState();
  }
  mOldItemCount=mItemCount;
  mItemCount=0;
  mSelectedPosition=INVALID_POSITION;
  mSelectedRowId=INVALID_ROW_ID;
  mNextSelectedPosition=INVALID_POSITION;
  mNextSelectedRowId=INVALID_ROW_ID;
  mNeedSync=false;
  checkSelectionChanged();
  checkFocus();
  requestLayout();
}","@Override public void onInvalidated(){
  mDataChanged=true;
  if (AdapterView.this.getAdapter().hasStableIds()) {
    mInstanceState=AdapterView.this.onSaveInstanceState();
  }
  mOldItemCount=mItemCount;
  mItemCount=0;
  mSelectedPosition=INVALID_POSITION;
  mSelectedRowId=INVALID_ROW_ID;
  mNextSelectedPosition=INVALID_POSITION;
  mNextSelectedRowId=INVALID_ROW_ID;
  mNeedSync=false;
  checkFocus();
  requestLayout();
}",0.969283276450512
181426,"void selectionChanged(){
  if (mOnItemSelectedListener != null) {
    if (mInLayout || mBlockLayoutRequests) {
      if (mSelectionNotifier == null) {
        mSelectionNotifier=new SelectionNotifier();
      }
      mSelectionNotifier.post(mSelectionNotifier);
    }
 else {
      fireOnSelected();
    }
  }
  if (mSelectedPosition != ListView.INVALID_POSITION && isShown() && !isInTouchMode()) {
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
  }
}","void selectionChanged(){
  if (mOnItemSelectedListener != null) {
    if (mInLayout || mBlockLayoutRequests) {
      if (mSelectionNotifier == null) {
        mSelectionNotifier=new SelectionNotifier();
      }
      post(mSelectionNotifier);
    }
 else {
      fireOnSelected();
    }
  }
  if (mSelectedPosition != ListView.INVALID_POSITION && isShown() && !isInTouchMode()) {
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
  }
}",0.9794149512459372
181427,"public void run(){
  if (mDataChanged) {
    post(this);
  }
 else {
    fireOnSelected();
  }
}","public void run(){
  if (mDataChanged) {
    if (getAdapter() != null) {
      post(this);
    }
  }
 else {
    fireOnSelected();
  }
}",0.8275862068965517
181428,"@Override public void onInvalidated(){
  mDataChanged=true;
  if (AdapterView.this.getAdapter().hasStableIds()) {
    mInstanceState=AdapterView.this.onSaveInstanceState();
  }
  mOldItemCount=mItemCount;
  mItemCount=0;
  mSelectedPosition=INVALID_POSITION;
  mSelectedRowId=INVALID_ROW_ID;
  mNextSelectedPosition=INVALID_POSITION;
  mNextSelectedRowId=INVALID_ROW_ID;
  mNeedSync=false;
  checkSelectionChanged();
  checkFocus();
  requestLayout();
}","@Override public void onInvalidated(){
  mDataChanged=true;
  if (AdapterView.this.getAdapter().hasStableIds()) {
    mInstanceState=AdapterView.this.onSaveInstanceState();
  }
  mOldItemCount=mItemCount;
  mItemCount=0;
  mSelectedPosition=INVALID_POSITION;
  mSelectedRowId=INVALID_ROW_ID;
  mNextSelectedPosition=INVALID_POSITION;
  mNextSelectedRowId=INVALID_ROW_ID;
  mNeedSync=false;
  checkFocus();
  requestLayout();
}",0.969283276450512
181429,"void selectionChanged(){
  if (mOnItemSelectedListener != null) {
    if (mInLayout || mBlockLayoutRequests) {
      if (mSelectionNotifier == null) {
        mSelectionNotifier=new SelectionNotifier();
      }
      mSelectionNotifier.post(mSelectionNotifier);
    }
 else {
      fireOnSelected();
    }
  }
  if (mSelectedPosition != ListView.INVALID_POSITION && isShown() && !isInTouchMode()) {
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
  }
}","void selectionChanged(){
  if (mOnItemSelectedListener != null) {
    if (mInLayout || mBlockLayoutRequests) {
      if (mSelectionNotifier == null) {
        mSelectionNotifier=new SelectionNotifier();
      }
      post(mSelectionNotifier);
    }
 else {
      fireOnSelected();
    }
  }
  if (mSelectedPosition != ListView.INVALID_POSITION && isShown() && !isInTouchMode()) {
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
  }
}",0.9794149512459372
181430,"/** 
 * Sets the maximum and maximum preview fps. This controls the rate of preview frames received in   {@link #PreviewCallback}. The minimum and maximum preview fps must be one of the elements from   {@link #getSupportedPreviewFpsRange}.
 * @param min the minimum preview fps (scaled by 1000).
 * @param max the maximum preview fps (scaled by 1000).
 * @throws RuntimeException if fps range is invalid.
 * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
 * @see #getSupportedPreviewFpsRange()
 */
public void setPreviewFpsRange(int min,int max){
  set(KEY_PREVIEW_FPS_RANGE,""String_Node_Str"" + min + ""String_Node_Str""+ max);
}","/** 
 * Sets the maximum and maximum preview fps. This controls the rate of preview frames received in   {@link PreviewCallback}. The minimum and maximum preview fps must be one of the elements from   {@link #getSupportedPreviewFpsRange}.
 * @param min the minimum preview fps (scaled by 1000).
 * @param max the maximum preview fps (scaled by 1000).
 * @throws RuntimeException if fps range is invalid.
 * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
 * @see #getSupportedPreviewFpsRange()
 */
public void setPreviewFpsRange(int min,int max){
  set(KEY_PREVIEW_FPS_RANGE,""String_Node_Str"" + min + ""String_Node_Str""+ max);
}",0.999216914643696
181431,"@Override public int update(Uri url,ContentValues initialValues,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  sKnownMutationsInFlight.decrementAndGet();
  int count=db.update(args.table,initialValues,args.where,args.args);
  if (count > 0) {
    SettingsCache.wipe(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str""+ initialValues);
  return count;
}","@Override public int update(Uri url,ContentValues initialValues,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.update(args.table,initialValues,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.invalidate(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str""+ initialValues);
  return count;
}",0.891583452211127
181432,"private void fullyPopulateCache(String table,SettingsCache cache){
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  Cursor c=db.query(table,new String[]{Settings.NameValueTable.NAME,Settings.NameValueTable.VALUE},null,null,null,null,null,""String_Node_Str"" + (MAX_CACHE_ENTRIES + 1));
  try {
synchronized (cache) {
      cache.clear();
      cache.setFullyMatchesDisk(true);
      int rows=0;
      while (c.moveToNext()) {
        rows++;
        String name=c.getString(0);
        String value=c.getString(1);
        cache.populate(name,value);
      }
      if (rows > MAX_CACHE_ENTRIES) {
        cache.setFullyMatchesDisk(false);
        Log.d(TAG,""String_Node_Str"" + table);
      }
      Log.d(TAG,""String_Node_Str"" + table + ""String_Node_Str""+ cache.fullyMatchesDisk());
    }
  }
  finally {
    c.close();
  }
}","private void fullyPopulateCache(String table,SettingsCache cache){
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  Cursor c=db.query(table,new String[]{Settings.NameValueTable.NAME,Settings.NameValueTable.VALUE},null,null,null,null,null,""String_Node_Str"" + (MAX_CACHE_ENTRIES + 1));
  try {
synchronized (cache) {
      cache.clear();
      cache.setFullyMatchesDisk(true);
      int rows=0;
      while (c.moveToNext()) {
        rows++;
        String name=c.getString(0);
        String value=c.getString(1);
        cache.populate(name,value);
      }
      if (rows > MAX_CACHE_ENTRIES) {
        cache.setFullyMatchesDisk(false);
        Log.d(TAG,""String_Node_Str"" + table);
      }
      Log.d(TAG,""String_Node_Str"" + table + ""String_Node_Str""+ rows+ ""String_Node_Str""+ cache.fullyMatchesDisk());
    }
  }
  finally {
    c.close();
  }
}",0.9851807943094252
181433,"@Override public int delete(Uri url,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
 else   if (TABLE_OLD_FAVORITES.equals(args.table)) {
    args.table=TABLE_FAVORITES;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.delete(args.table,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.wipe(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str"");
  return count;
}","@Override public int delete(Uri url,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
 else   if (TABLE_OLD_FAVORITES.equals(args.table)) {
    args.table=TABLE_FAVORITES;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.delete(args.table,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.invalidate(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str"");
  return count;
}",0.9918256130790192
181434,"@Override public int update(Uri url,ContentValues initialValues,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  sKnownMutationsInFlight.decrementAndGet();
  int count=db.update(args.table,initialValues,args.where,args.args);
  if (count > 0) {
    SettingsCache.wipe(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str""+ initialValues);
  return count;
}","@Override public int update(Uri url,ContentValues initialValues,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.update(args.table,initialValues,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.invalidate(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str""+ initialValues);
  return count;
}",0.891583452211127
181435,"private void fullyPopulateCache(String table,SettingsCache cache){
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  Cursor c=db.query(table,new String[]{Settings.NameValueTable.NAME,Settings.NameValueTable.VALUE},null,null,null,null,null,""String_Node_Str"" + (MAX_CACHE_ENTRIES + 1));
  try {
synchronized (cache) {
      cache.clear();
      cache.setFullyMatchesDisk(true);
      int rows=0;
      while (c.moveToNext()) {
        rows++;
        String name=c.getString(0);
        String value=c.getString(1);
        cache.populate(name,value);
      }
      if (rows > MAX_CACHE_ENTRIES) {
        cache.setFullyMatchesDisk(false);
        Log.d(TAG,""String_Node_Str"" + table);
      }
      Log.d(TAG,""String_Node_Str"" + table + ""String_Node_Str""+ cache.fullyMatchesDisk());
    }
  }
  finally {
    c.close();
  }
}","private void fullyPopulateCache(String table,SettingsCache cache){
  SQLiteDatabase db=mOpenHelper.getReadableDatabase();
  Cursor c=db.query(table,new String[]{Settings.NameValueTable.NAME,Settings.NameValueTable.VALUE},null,null,null,null,null,""String_Node_Str"" + (MAX_CACHE_ENTRIES + 1));
  try {
synchronized (cache) {
      cache.clear();
      cache.setFullyMatchesDisk(true);
      int rows=0;
      while (c.moveToNext()) {
        rows++;
        String name=c.getString(0);
        String value=c.getString(1);
        cache.populate(name,value);
      }
      if (rows > MAX_CACHE_ENTRIES) {
        cache.setFullyMatchesDisk(false);
        Log.d(TAG,""String_Node_Str"" + table);
      }
      Log.d(TAG,""String_Node_Str"" + table + ""String_Node_Str""+ rows+ ""String_Node_Str""+ cache.fullyMatchesDisk());
    }
  }
  finally {
    c.close();
  }
}",0.9851807943094252
181436,"@Override public int delete(Uri url,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
 else   if (TABLE_OLD_FAVORITES.equals(args.table)) {
    args.table=TABLE_FAVORITES;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.delete(args.table,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.wipe(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str"");
  return count;
}","@Override public int delete(Uri url,String where,String[] whereArgs){
  SqlArguments args=new SqlArguments(url,where,whereArgs);
  if (TABLE_FAVORITES.equals(args.table)) {
    return 0;
  }
 else   if (TABLE_OLD_FAVORITES.equals(args.table)) {
    args.table=TABLE_FAVORITES;
  }
  checkWritePermissions(args);
  sKnownMutationsInFlight.incrementAndGet();
  SQLiteDatabase db=mOpenHelper.getWritableDatabase();
  int count=db.delete(args.table,args.where,args.args);
  sKnownMutationsInFlight.decrementAndGet();
  if (count > 0) {
    SettingsCache.invalidate(args.table);
    sendNotify(url);
  }
  startAsyncCachePopulation();
  if (LOCAL_LOGV)   Log.v(TAG,args.table + ""String_Node_Str"" + count+ ""String_Node_Str"");
  return count;
}",0.9918256130790192
181437,"/** 
 * Inflate a new view hierarchy from the specified XML node. Throws  {@link InflateException} if there is an error.<p> <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 * @param parser XML dom node containing the description of the viewhierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if<em>attachToRoot</em> is true), or else simply an object that provides a set of LayoutParams values for root of the returned hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached tothe root parameter? If false, root is only used to create the correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied andattachToRoot is true, this is root; otherwise it is the root of the inflated XML file.
 */
public View inflate(XmlPullParser parser,ViewGroup root,boolean attachToRoot){
synchronized (mConstructorArgs) {
    final AttributeSet attrs=Xml.asAttributeSet(parser);
    mConstructorArgs[0]=mContext;
    View result=root;
    try {
      int type;
      while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      }
      if (type != XmlPullParser.START_TAG) {
        throw new InflateException(parser.getPositionDescription() + ""String_Node_Str"");
      }
      final String name=parser.getName();
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + name);
        System.out.println(""String_Node_Str"");
      }
      if (TAG_MERGE.equals(name)) {
        if (root == null || !attachToRoot) {
          throw new InflateException(""String_Node_Str"" + ""String_Node_Str"");
        }
        rInflate(parser,root,attrs);
      }
 else {
        View temp=createViewFromTag(name,attrs);
        ViewGroup.LayoutParams params=null;
        if (root != null) {
          if (DEBUG) {
            System.out.println(""String_Node_Str"" + root);
          }
          params=root.generateLayoutParams(attrs);
          if (!attachToRoot) {
            temp.setLayoutParams(params);
          }
        }
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        rInflate(parser,temp,attrs);
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        if (root != null && attachToRoot) {
          root.addView(temp,params);
        }
        if (root == null || !attachToRoot) {
          result=temp;
        }
      }
    }
 catch (    XmlPullParserException e) {
      InflateException ex=new InflateException(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
catch (    IOException e) {
      InflateException ex=new InflateException(parser.getPositionDescription() + ""String_Node_Str"" + e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    mConstructorArgs[0]=null;
    mConstructorArgs[1]=null;
    return result;
  }
}","/** 
 * Inflate a new view hierarchy from the specified XML node. Throws  {@link InflateException} if there is an error.<p> <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 * @param parser XML dom node containing the description of the viewhierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if<em>attachToRoot</em> is true), or else simply an object that provides a set of LayoutParams values for root of the returned hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached tothe root parameter? If false, root is only used to create the correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied andattachToRoot is true, this is root; otherwise it is the root of the inflated XML file.
 */
public View inflate(XmlPullParser parser,ViewGroup root,boolean attachToRoot){
synchronized (mConstructorArgs) {
    final AttributeSet attrs=Xml.asAttributeSet(parser);
    Context lastContext=(Context)mConstructorArgs[0];
    mConstructorArgs[0]=mContext;
    View result=root;
    try {
      int type;
      while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      }
      if (type != XmlPullParser.START_TAG) {
        throw new InflateException(parser.getPositionDescription() + ""String_Node_Str"");
      }
      final String name=parser.getName();
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + name);
        System.out.println(""String_Node_Str"");
      }
      if (TAG_MERGE.equals(name)) {
        if (root == null || !attachToRoot) {
          throw new InflateException(""String_Node_Str"" + ""String_Node_Str"");
        }
        rInflate(parser,root,attrs);
      }
 else {
        View temp=createViewFromTag(name,attrs);
        ViewGroup.LayoutParams params=null;
        if (root != null) {
          if (DEBUG) {
            System.out.println(""String_Node_Str"" + root);
          }
          params=root.generateLayoutParams(attrs);
          if (!attachToRoot) {
            temp.setLayoutParams(params);
          }
        }
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        rInflate(parser,temp,attrs);
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        if (root != null && attachToRoot) {
          root.addView(temp,params);
        }
        if (root == null || !attachToRoot) {
          result=temp;
        }
      }
    }
 catch (    XmlPullParserException e) {
      InflateException ex=new InflateException(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
catch (    IOException e) {
      InflateException ex=new InflateException(parser.getPositionDescription() + ""String_Node_Str"" + e.getMessage());
      ex.initCause(e);
      throw ex;
    }
 finally {
      mConstructorArgs[0]=lastContext;
      mConstructorArgs[1]=null;
    }
    return result;
  }
}",0.9803076923076924
181438,"/** 
 * Inflate a new view hierarchy from the specified XML node. Throws  {@link InflateException} if there is an error.<p> <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 * @param parser XML dom node containing the description of the viewhierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if<em>attachToRoot</em> is true), or else simply an object that provides a set of LayoutParams values for root of the returned hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached tothe root parameter? If false, root is only used to create the correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied andattachToRoot is true, this is root; otherwise it is the root of the inflated XML file.
 */
public View inflate(XmlPullParser parser,ViewGroup root,boolean attachToRoot){
synchronized (mConstructorArgs) {
    final AttributeSet attrs=Xml.asAttributeSet(parser);
    mConstructorArgs[0]=mContext;
    View result=root;
    try {
      int type;
      while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      }
      if (type != XmlPullParser.START_TAG) {
        throw new InflateException(parser.getPositionDescription() + ""String_Node_Str"");
      }
      final String name=parser.getName();
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + name);
        System.out.println(""String_Node_Str"");
      }
      if (TAG_MERGE.equals(name)) {
        if (root == null || !attachToRoot) {
          throw new InflateException(""String_Node_Str"" + ""String_Node_Str"");
        }
        rInflate(parser,root,attrs);
      }
 else {
        View temp=createViewFromTag(name,attrs);
        ViewGroup.LayoutParams params=null;
        if (root != null) {
          if (DEBUG) {
            System.out.println(""String_Node_Str"" + root);
          }
          params=root.generateLayoutParams(attrs);
          if (!attachToRoot) {
            temp.setLayoutParams(params);
          }
        }
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        rInflate(parser,temp,attrs);
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        if (root != null && attachToRoot) {
          root.addView(temp,params);
        }
        if (root == null || !attachToRoot) {
          result=temp;
        }
      }
    }
 catch (    XmlPullParserException e) {
      InflateException ex=new InflateException(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
catch (    IOException e) {
      InflateException ex=new InflateException(parser.getPositionDescription() + ""String_Node_Str"" + e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    mConstructorArgs[0]=null;
    mConstructorArgs[1]=null;
    return result;
  }
}","/** 
 * Inflate a new view hierarchy from the specified XML node. Throws  {@link InflateException} if there is an error.<p> <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 * @param parser XML dom node containing the description of the viewhierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if<em>attachToRoot</em> is true), or else simply an object that provides a set of LayoutParams values for root of the returned hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached tothe root parameter? If false, root is only used to create the correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied andattachToRoot is true, this is root; otherwise it is the root of the inflated XML file.
 */
public View inflate(XmlPullParser parser,ViewGroup root,boolean attachToRoot){
synchronized (mConstructorArgs) {
    final AttributeSet attrs=Xml.asAttributeSet(parser);
    Context lastContext=(Context)mConstructorArgs[0];
    mConstructorArgs[0]=mContext;
    View result=root;
    try {
      int type;
      while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      }
      if (type != XmlPullParser.START_TAG) {
        throw new InflateException(parser.getPositionDescription() + ""String_Node_Str"");
      }
      final String name=parser.getName();
      if (DEBUG) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + name);
        System.out.println(""String_Node_Str"");
      }
      if (TAG_MERGE.equals(name)) {
        if (root == null || !attachToRoot) {
          throw new InflateException(""String_Node_Str"" + ""String_Node_Str"");
        }
        rInflate(parser,root,attrs);
      }
 else {
        View temp=createViewFromTag(name,attrs);
        ViewGroup.LayoutParams params=null;
        if (root != null) {
          if (DEBUG) {
            System.out.println(""String_Node_Str"" + root);
          }
          params=root.generateLayoutParams(attrs);
          if (!attachToRoot) {
            temp.setLayoutParams(params);
          }
        }
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        rInflate(parser,temp,attrs);
        if (DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        if (root != null && attachToRoot) {
          root.addView(temp,params);
        }
        if (root == null || !attachToRoot) {
          result=temp;
        }
      }
    }
 catch (    XmlPullParserException e) {
      InflateException ex=new InflateException(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
catch (    IOException e) {
      InflateException ex=new InflateException(parser.getPositionDescription() + ""String_Node_Str"" + e.getMessage());
      ex.initCause(e);
      throw ex;
    }
 finally {
      mConstructorArgs[0]=lastContext;
      mConstructorArgs[1]=null;
    }
    return result;
  }
}",0.9803076923076924
181439,"public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ taskAffinity);
  if (theme != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(theme));
  }
  pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(flags)+ ""String_Node_Str""+ processName);
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}","public void dump(Printer pw,String prefix){
  super.dumpFront(pw,prefix);
  if (className != null) {
    pw.println(prefix + ""String_Node_Str"" + className);
  }
  if (permission != null) {
    pw.println(prefix + ""String_Node_Str"" + permission);
  }
  pw.println(prefix + ""String_Node_Str"" + processName);
  pw.println(prefix + ""String_Node_Str"" + taskAffinity);
  pw.println(prefix + ""String_Node_Str"" + uid+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ Integer.toHexString(theme));
  pw.println(prefix + ""String_Node_Str"" + sourceDir);
  if (!sourceDir.equals(publicSourceDir)) {
    pw.println(prefix + ""String_Node_Str"" + publicSourceDir);
  }
  if (resourceDirs != null) {
    pw.println(prefix + ""String_Node_Str"" + resourceDirs);
  }
  pw.println(prefix + ""String_Node_Str"" + dataDir);
  if (sharedLibraryFiles != null) {
    pw.println(prefix + ""String_Node_Str"" + sharedLibraryFiles);
  }
  pw.println(prefix + ""String_Node_Str"" + enabled+ ""String_Node_Str""+ targetSdkVersion);
  if (manageSpaceActivityName != null) {
    pw.println(prefix + ""String_Node_Str"" + manageSpaceActivityName);
  }
  if (descriptionRes != 0) {
    pw.println(prefix + ""String_Node_Str"" + Integer.toHexString(descriptionRes));
  }
  super.dumpBack(pw,prefix);
}",0.7124394184168013
181440,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r);
  updateLruProcessLocked(app,true,true);
  boolean created=false;
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
    mStringBuilder.setLength(0);
    r.intent.getIntent().toShortString(mStringBuilder,false,true);
    EventLog.writeEvent(EventLogTags.AM_CREATE_SERVICE,System.identityHashCode(r),r.shortName,mStringBuilder.toString(),r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    ensurePackageDexOpt(r.serviceInfo.packageName);
    app.thread.scheduleCreateService(r,r.serviceInfo);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.lastStartId++;
    if (r.lastStartId < 1) {
      r.lastStartId=1;
    }
    r.pendingStarts.add(new ServiceRecord.StartItem(r.lastStartId,null));
  }
  sendServiceArgsLocked(r,true);
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r);
  updateLruProcessLocked(app,true,true);
  boolean created=false;
  try {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
    mStringBuilder.setLength(0);
    r.intent.getIntent().toShortString(mStringBuilder,false,true);
    EventLog.writeEvent(EventLogTags.AM_CREATE_SERVICE,System.identityHashCode(r),r.shortName,mStringBuilder.toString(),r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    ensurePackageDexOpt(r.serviceInfo.packageName);
    app.thread.scheduleCreateService(r,r.serviceInfo);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.lastStartId++;
    if (r.lastStartId < 1) {
      r.lastStartId=1;
    }
    r.pendingStarts.add(new ServiceRecord.StartItem(r,r.lastStartId,null,-1));
  }
  sendServiceArgsLocked(r,true);
}",0.9981570217471434
181441,"void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + (intent != null ? intent.getData() : null) + ""String_Node_Str""+ intent+ ""String_Node_Str""+ Integer.toHexString(intent != null ? intent.getFlags() : 0));
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}","void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,UriPermissionOwner owner){
  int targetUid=checkGrantUriPermissionFromIntentLocked(callingUid,targetPkg,intent);
  if (targetUid < 0) {
    return;
  }
  grantUriPermissionUncheckedFromIntentLocked(targetUid,targetPkg,intent,owner);
}",0.2464114832535885
181442,"public boolean stopServiceToken(ComponentName className,IBinder token,int startId){
synchronized (this) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + className + ""String_Node_Str""+ token+ ""String_Node_Str""+ startId);
    ServiceRecord r=findServiceLocked(className,token);
    if (r != null) {
      if (startId >= 0) {
        ServiceRecord.StartItem si=r.findDeliveredStart(startId,false);
        if (si != null) {
          while (r.deliveredStarts.size() > 0) {
            if (r.deliveredStarts.remove(0) == si) {
              break;
            }
          }
        }
        if (r.lastStartId != startId) {
          return false;
        }
        if (r.deliveredStarts.size() > 0) {
          Slog.w(TAG,""String_Node_Str"" + startId + ""String_Node_Str""+ r.deliveredStarts.size()+ ""String_Node_Str"");
        }
      }
synchronized (r.stats.getBatteryStats()) {
        r.stats.stopRunningLocked();
        r.startRequested=false;
        r.callStart=false;
      }
      final long origId=Binder.clearCallingIdentity();
      bringDownServiceLocked(r,false);
      Binder.restoreCallingIdentity(origId);
      return true;
    }
  }
  return false;
}","public boolean stopServiceToken(ComponentName className,IBinder token,int startId){
synchronized (this) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + className + ""String_Node_Str""+ token+ ""String_Node_Str""+ startId);
    ServiceRecord r=findServiceLocked(className,token);
    if (r != null) {
      if (startId >= 0) {
        ServiceRecord.StartItem si=r.findDeliveredStart(startId,false);
        if (si != null) {
          while (r.deliveredStarts.size() > 0) {
            ServiceRecord.StartItem cur=r.deliveredStarts.remove(0);
            cur.removeUriPermissionsLocked();
            if (cur == si) {
              break;
            }
          }
        }
        if (r.lastStartId != startId) {
          return false;
        }
        if (r.deliveredStarts.size() > 0) {
          Slog.w(TAG,""String_Node_Str"" + startId + ""String_Node_Str""+ r.deliveredStarts.size()+ ""String_Node_Str"");
        }
      }
synchronized (r.stats.getBatteryStats()) {
        r.stats.stopRunningLocked();
        r.startRequested=false;
        r.callStart=false;
      }
      final long origId=Binder.clearCallingIdentity();
      bringDownServiceLocked(r,false);
      Binder.restoreCallingIdentity(origId);
      return true;
    }
  }
  return false;
}",0.9438754608766898
181443,"void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,ActivityRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  final IPackageManager pm=AppGlobals.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (DEBUG_URI_PERMISSION)     Slog.v(TAG,""String_Node_Str"" + uri);
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Slog.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      if (DEBUG_URI_PERMISSION)       Slog.v(TAG,""String_Node_Str"" + targetPkg);
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    if (DEBUG_URI_PERMISSION)     Slog.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}","void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,UriPermissionOwner owner){
  int targetUid=checkGrantUriPermissionLocked(callingUid,targetPkg,uri,modeFlags);
  if (targetUid < 0) {
    return;
  }
  grantUriPermissionUncheckedLocked(targetUid,targetPkg,uri,modeFlags,owner);
}",0.0760601915184678
181444,"private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  final long now=SystemClock.uptimeMillis();
  long minDuration=SERVICE_RESTART_DURATION;
  long resetTime=SERVICE_RESET_RUN_DURATION;
  final int N=r.deliveredStarts.size();
  if (N > 0) {
    for (int i=N - 1; i >= 0; i--) {
      ServiceRecord.StartItem si=r.deliveredStarts.get(i);
      if (si.intent == null) {
      }
 else       if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
        r.pendingStarts.add(0,si);
        long dur=SystemClock.uptimeMillis() - si.deliveredTime;
        dur*=2;
        if (minDuration < dur)         minDuration=dur;
        if (resetTime < dur)         resetTime=dur;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
        canceled=true;
      }
    }
    r.deliveredStarts.clear();
  }
  r.totalRestartCount++;
  if (r.restartDelay == 0) {
    r.restartCount++;
    r.restartDelay=minDuration;
  }
 else {
    if (now > (r.restartTime + resetTime)) {
      r.restartCount=1;
      r.restartDelay=minDuration;
    }
 else {
      r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
      if (r.restartDelay < minDuration) {
        r.restartDelay=minDuration;
      }
    }
  }
  r.nextRestartTime=now + r.restartDelay;
  boolean repeat;
  do {
    repeat=false;
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r2=mRestartingServices.get(i);
      if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
        r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
        r.restartDelay=r.nextRestartTime - now;
        repeat=true;
        break;
      }
    }
  }
 while (repeat);
  if (!mRestartingServices.contains(r)) {
    mRestartingServices.add(r);
  }
  r.cancelNotification();
  mHandler.removeCallbacks(r.restarter);
  mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.shortName,r.restartDelay);
  return canceled;
}","private final boolean scheduleServiceRestartLocked(ServiceRecord r,boolean allowCancel){
  boolean canceled=false;
  final long now=SystemClock.uptimeMillis();
  long minDuration=SERVICE_RESTART_DURATION;
  long resetTime=SERVICE_RESET_RUN_DURATION;
  final int N=r.deliveredStarts.size();
  if (N > 0) {
    for (int i=N - 1; i >= 0; i--) {
      ServiceRecord.StartItem si=r.deliveredStarts.get(i);
      si.removeUriPermissionsLocked();
      if (si.intent == null) {
      }
 else       if (!allowCancel || (si.deliveryCount < ServiceRecord.MAX_DELIVERY_COUNT && si.doneExecutingCount < ServiceRecord.MAX_DONE_EXECUTING_COUNT)) {
        r.pendingStarts.add(0,si);
        long dur=SystemClock.uptimeMillis() - si.deliveredTime;
        dur*=2;
        if (minDuration < dur)         minDuration=dur;
        if (resetTime < dur)         resetTime=dur;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + si.intent + ""String_Node_Str""+ r.name);
        canceled=true;
      }
    }
    r.deliveredStarts.clear();
  }
  r.totalRestartCount++;
  if (r.restartDelay == 0) {
    r.restartCount++;
    r.restartDelay=minDuration;
  }
 else {
    if (now > (r.restartTime + resetTime)) {
      r.restartCount=1;
      r.restartDelay=minDuration;
    }
 else {
      r.restartDelay*=SERVICE_RESTART_DURATION_FACTOR;
      if (r.restartDelay < minDuration) {
        r.restartDelay=minDuration;
      }
    }
  }
  r.nextRestartTime=now + r.restartDelay;
  boolean repeat;
  do {
    repeat=false;
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r2=mRestartingServices.get(i);
      if (r2 != r && r.nextRestartTime >= (r2.nextRestartTime - SERVICE_MIN_RESTART_TIME_BETWEEN) && r.nextRestartTime < (r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN)) {
        r.nextRestartTime=r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;
        r.restartDelay=r.nextRestartTime - now;
        repeat=true;
        break;
      }
    }
  }
 while (repeat);
  if (!mRestartingServices.contains(r)) {
    mRestartingServices.add(r);
  }
  r.cancelNotification();
  mHandler.removeCallbacks(r.restarter);
  mHandler.postAtTime(r.restarter,r.nextRestartTime);
  r.nextRestartTime=SystemClock.uptimeMillis() + r.restartDelay;
  Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ r.restartDelay+ ""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,r.shortName,r.restartDelay);
  return canceled;
}",0.992035940371656
181445,"private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 1) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}","private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  while (r.pendingStarts.size() > 0) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.remove(0);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null) {
        continue;
      }
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      if (si.targetPermissionUid >= 0) {
        grantUriPermissionUncheckedFromIntentLocked(si.targetPermissionUid,r.packageName,si.intent,si);
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
}",0.764234161988773
181446,"private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(EventLogTags.AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r.shortName);
  }
}","private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(EventLogTags.AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.clearDeliveredStartsLocked();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        if (DEBUG_SERVICE)         Slog.v(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r.shortName);
  }
}",0.9925526857867216
181447,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid){
synchronized (this) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
    if (caller != null) {
      final ProcessRecord callerApp=getRecordForAppLocked(caller);
      if (callerApp == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
      }
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid);
    if (res == null) {
      return null;
    }
    if (res.record == null) {
      return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
    }
    ServiceRecord r=res.record;
    if (unscheduleServiceRestartLocked(r)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
    }
    r.startRequested=true;
    r.callStart=false;
    r.lastStartId++;
    if (r.lastStartId < 1) {
      r.lastStartId=1;
    }
    r.pendingStarts.add(new ServiceRecord.StartItem(r.lastStartId,service));
    r.lastActivity=SystemClock.uptimeMillis();
synchronized (r.stats.getBatteryStats()) {
      r.stats.startRunningLocked();
    }
    if (!bringUpServiceLocked(r,service.getFlags(),false)) {
      return new ComponentName(""String_Node_Str"",""String_Node_Str"");
    }
    return r.name;
  }
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid){
synchronized (this) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
    if (caller != null) {
      final ProcessRecord callerApp=getRecordForAppLocked(caller);
      if (callerApp == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
      }
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid);
    if (res == null) {
      return null;
    }
    if (res.record == null) {
      return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
    }
    ServiceRecord r=res.record;
    int targetPermissionUid=checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service);
    if (unscheduleServiceRestartLocked(r)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r.shortName);
    }
    r.startRequested=true;
    r.callStart=false;
    r.lastStartId++;
    if (r.lastStartId < 1) {
      r.lastStartId=1;
    }
    r.pendingStarts.add(new ServiceRecord.StartItem(r,r.lastStartId,service,targetPermissionUid));
    r.lastActivity=SystemClock.uptimeMillis();
synchronized (r.stats.getBatteryStats()) {
      r.stats.startRunningLocked();
    }
    if (!bringUpServiceLocked(r,service.getFlags(),false)) {
      return new ComponentName(""String_Node_Str"",""String_Node_Str"");
    }
    return r.name;
  }
}",0.9603048586852968
181448,"void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeLocked();
      }
    }
  }
}","void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeLocked();
      }
    }
  }
}",0.9995402298850574
181449,"void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeLocked();
      }
    }
  }
}","void setOnBattery(boolean onBattery,int oldStatus,int level){
synchronized (this) {
    boolean doWrite=false;
    mOnBattery=mOnBatteryInternal=onBattery;
    long uptime=SystemClock.uptimeMillis() * 1000;
    long mSecRealtime=SystemClock.elapsedRealtime();
    long realtime=mSecRealtime * 1000;
    if (onBattery) {
      if (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 100 || (mDischargeCurrentLevel < 20 && level > 90)) {
        doWrite=true;
        resetAllStatsLocked();
        mDischargeStartLevel=level;
        mLowDischargeAmountSinceCharge=0;
        mHighDischargeAmountSinceCharge=0;
      }
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryUptimeStart=uptime;
      mTrackBatteryRealtimeStart=realtime;
      mUnpluggedBatteryUptime=getBatteryUptimeLocked(uptime);
      mUnpluggedBatteryRealtime=getBatteryRealtimeLocked(realtime);
      mDischargeCurrentLevel=mDischargeUnplugLevel=level;
      doUnplugLocked(mUnpluggedBatteryUptime,mUnpluggedBatteryRealtime);
    }
 else {
      updateKernelWakelocksLocked();
      mHistoryCur.batteryLevel=(byte)level;
      mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
      if (DEBUG_HISTORY)       Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
      addHistoryRecordLocked(mSecRealtime);
      mTrackBatteryPastUptime+=uptime - mTrackBatteryUptimeStart;
      mTrackBatteryPastRealtime+=realtime - mTrackBatteryRealtimeStart;
      mDischargeCurrentLevel=level;
      if (level < mDischargeUnplugLevel) {
        mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
        mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
      }
      doPlugLocked(getBatteryUptimeLocked(uptime),getBatteryRealtimeLocked(realtime));
    }
    if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
      if (mFile != null) {
        writeLocked();
      }
    }
  }
}",0.9995402298850574
181450,"private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  if (type == TypedValue.TYPE_STRING) {
    outValue.string=loadStringValueAt(index);
  }
  return true;
}","private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  outValue.string=(type == TypedValue.TYPE_STRING) ? loadStringValueAt(index) : null;
  return true;
}",0.9346210995542348
181451,"private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  if (type == TypedValue.TYPE_STRING) {
    outValue.string=loadStringValueAt(index);
  }
  return true;
}","private boolean getValueAt(int index,TypedValue outValue){
  final int[] data=mData;
  final int type=data[index + AssetManager.STYLE_TYPE];
  if (type == TypedValue.TYPE_NULL) {
    return false;
  }
  outValue.type=type;
  outValue.data=data[index + AssetManager.STYLE_DATA];
  outValue.assetCookie=data[index + AssetManager.STYLE_ASSET_COOKIE];
  outValue.resourceId=data[index + AssetManager.STYLE_RESOURCE_ID];
  outValue.changingConfigurations=data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
  outValue.density=data[index + AssetManager.STYLE_DENSITY];
  outValue.string=(type == TypedValue.TYPE_STRING) ? loadStringValueAt(index) : null;
  return true;
}",0.9346210995542348
181452,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}",0.9116442363955528
181453,"private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  permissionFailure=source.readString();
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}","private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}",0.9129511677282378
181454,"/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
    }
    ContentProvider.this.onCreate();
  }
}","/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
      mExported=info.exported;
    }
    ContentProvider.this.onCreate();
  }
}",0.9734816082121472
181455,"private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}","private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}",0.99370012599748
181456,"private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}","private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}",0.9923508414074452
181457,"void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}","void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + (intent != null ? intent.getData() : null) + ""String_Node_Str""+ intent+ ""String_Node_Str""+ Integer.toHexString(intent != null ? intent.getFlags() : 0));
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}",0.7383863080684596
181458,"public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Log.w(TAG,""String_Node_Str"" + res);
  }
}","public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Slog.w(TAG,""String_Node_Str"" + res);
  }
}",0.9989373007438896
181459,"private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}","private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if (!pi.exported && pi.applicationInfo.uid != uid) {
      return false;
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}",0.9266903914590748
181460,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9657731958762886
181461,"public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}",0.999781770568124
181462,"private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r,int mode){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}","private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(callingUid);
  if (perms != null) {
    for (    Map.Entry<Uri,UriPermission> uri : perms.entrySet()) {
      if (uri.getKey().getAuthority().equals(cpi.authority)) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}",0.8765852149706155
181463,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderClientRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}",0.9116442363955528
181464,"private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  permissionFailure=source.readString();
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}","private ContentProviderHolder(Parcel source){
  info=ProviderInfo.CREATOR.createFromParcel(source);
  provider=ContentProviderNative.asInterface(source.readStrongBinder());
  noReleaseNeeded=source.readInt() != 0;
}",0.9129511677282378
181465,"/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
    }
    ContentProvider.this.onCreate();
  }
}","/** 
 * After being instantiated, this is called to tell the content provider about itself.
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */
public void attachInfo(Context context,ProviderInfo info){
  if (mContext == null) {
    mContext=context;
    mMyUid=Process.myUid();
    if (info != null) {
      setReadPermission(info.readPermission);
      setWritePermission(info.writePermission);
      setPathPermissions(info.pathPermissions);
      mExported=info.exported;
    }
    ContentProvider.this.onCreate();
  }
}",0.9734816082121472
181466,"private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}","private void enforceReadPermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return;
  }
  final Context context=getContext();
  final String rperm=getReadPermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (rperm == null || context.checkPermission(rperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String pprperm=pp.getReadPermission();
      if (pprperm != null && pp.match(path)) {
        if (context.checkPermission(pprperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return;
  }
  String msg=""String_Node_Str"" + ContentProvider.this.getClass().getName() + ""String_Node_Str""+ uri+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ rperm;
  throw new SecurityException(msg);
}",0.99370012599748
181467,"private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}","private boolean hasWritePermission(Uri uri){
  final int uid=Binder.getCallingUid();
  if (uid == mMyUid) {
    return true;
  }
  final Context context=getContext();
  final String wperm=getWritePermission();
  final int pid=Binder.getCallingPid();
  if (mExported && (wperm == null || context.checkPermission(wperm,pid,uid) == PackageManager.PERMISSION_GRANTED)) {
    return true;
  }
  PathPermission[] pps=getPathPermissions();
  if (pps != null) {
    final String path=uri.getPath();
    int i=pps.length;
    while (i > 0) {
      i--;
      final PathPermission pp=pps[i];
      final String ppwperm=pp.getWritePermission();
      if (ppwperm != null && pp.match(path)) {
        if (context.checkPermission(ppwperm,pid,uid) == PackageManager.PERMISSION_GRANTED) {
          return true;
        }
      }
    }
  }
  if (context.checkUriPermission(uri,pid,uid,Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED) {
    return true;
  }
  return false;
}",0.9923508414074452
181468,"void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}","void grantUriPermissionFromIntentLocked(int callingUid,String targetPkg,Intent intent,ActivityRecord activity){
  if (DEBUG_URI_PERMISSION)   Slog.v(TAG,""String_Node_Str"" + (intent != null ? intent.getData() : null) + ""String_Node_Str""+ intent+ ""String_Node_Str""+ Integer.toHexString(intent != null ? intent.getFlags() : 0));
  if (intent == null) {
    return;
  }
  Uri data=intent.getData();
  if (data == null) {
    return;
  }
  grantUriPermissionLocked(callingUid,targetPkg,data,intent.getFlags(),activity);
}",0.7383863080684596
181469,"public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Log.w(TAG,""String_Node_Str"" + res);
  }
}","public void handleApplicationStrictModeViolation(IBinder app,int violationMask,StrictMode.ViolationInfo info){
  ProcessRecord r=findAppProcess(app);
  if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
    Integer stackFingerprint=info.crashInfo.stackTrace.hashCode();
    boolean logIt=true;
synchronized (mAlreadyLoggedViolatedStacks) {
      if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
        logIt=false;
      }
 else {
        if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
          mAlreadyLoggedViolatedStacks.clear();
        }
        mAlreadyLoggedViolatedStacks.add(stackFingerprint);
      }
    }
    if (logIt) {
      logStrictModeViolationToDropBox(r,info);
    }
  }
  if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
    AppErrorResult result=new AppErrorResult();
synchronized (this) {
      final long origId=Binder.clearCallingIdentity();
      Message msg=Message.obtain();
      msg.what=SHOW_STRICT_MODE_VIOLATION_MSG;
      HashMap<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",result);
      data.put(""String_Node_Str"",r);
      data.put(""String_Node_Str"",violationMask);
      data.put(""String_Node_Str"",info);
      msg.obj=data;
      mHandler.sendMessage(msg);
      Binder.restoreCallingIdentity(origId);
    }
    int res=result.get();
    Slog.w(TAG,""String_Node_Str"" + res);
  }
}",0.9989373007438896
181470,"private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}","private final boolean checkHoldingPermissionsLocked(IPackageManager pm,ProviderInfo pi,int uid,int modeFlags){
  try {
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
      if ((pi.readPermission != null) && (pm.checkUidPermission(pi.readPermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
      if ((pi.writePermission != null) && (pm.checkUidPermission(pi.writePermission,uid) != PackageManager.PERMISSION_GRANTED)) {
        return false;
      }
    }
    if (!pi.exported && pi.applicationInfo.uid != uid) {
      return false;
    }
    return true;
  }
 catch (  RemoteException e) {
    return false;
  }
}",0.9266903914590748
181471,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj <= PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9657731958762886
181472,"public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Log.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap data=(HashMap)msg.obj;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,""String_Node_Str"" + proc);
          return;
        }
        AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
        if (!mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          res.set(0);
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap data=(HashMap)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,""String_Node_Str"" + proc);
      return;
    }
    broadcastIntentLocked(null,null,new Intent(""String_Node_Str""),null,null,0,null,null,null,false,false,MY_PID,Process.SYSTEM_UID);
    Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get(""String_Node_Str""));
    d.show();
    proc.anrDialog=d;
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get(""String_Node_Str"");
if (proc == null) {
  Slog.e(TAG,""String_Node_Str"");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,""String_Node_Str"" + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get(""String_Node_Str"");
if (!mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence(""String_Node_Str""));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case BROADCAST_INTENT_MSG:
{
if (DEBUG_BROADCAST) Slog.v(TAG,""String_Node_Str"");
processNextBroadcast(true);
}
break;
case BROADCAST_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
mHandler.sendMessageDelayed(nmsg,BROADCAST_TIMEOUT);
return;
}
if (mSystemReady) {
broadcastTimeout();
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,SERVICE_TIMEOUT);
return;
}
serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,""String_Node_Str"" + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(""String_Node_Str"");
d.setMessage(""String_Node_Str"");
d.setButton(""String_Node_Str"",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int uid=msg.arg1;
boolean restart=(msg.arg2 == 1);
String pkg=(String)msg.obj;
forceStopPackageLocked(pkg,uid,restart,false,true);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivity(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT));
try {
int[] outId=new int[1];
inm.enqueueNotification(""String_Node_Str"",R.string.heavy_weight_notification,notification,outId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,""String_Node_Str"",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotification(""String_Node_Str"",R.string.heavy_weight_notification);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,""String_Node_Str"",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessiveWakeLocksLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
if (mSleeping) {
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,WAKE_LOCK_CHECK_DELAY);
}
}
}
break;
}
}",0.999781770568124
181473,"private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r,int mode){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED && mode == ParcelFileDescriptor.MODE_READ_ONLY || mode == -1) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}","private final String checkContentProviderPermissionLocked(ProviderInfo cpi,ProcessRecord r){
  final int callingPid=(r != null) ? r.pid : Binder.getCallingPid();
  final int callingUid=(r != null) ? r.info.uid : Binder.getCallingUid();
  if (checkComponentPermission(cpi.readPermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  if (checkComponentPermission(cpi.writePermission,callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
    return null;
  }
  PathPermission[] pps=cpi.pathPermissions;
  if (pps != null) {
    int i=pps.length;
    while (i > 0) {
      i--;
      PathPermission pp=pps[i];
      if (checkComponentPermission(pp.getReadPermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
      if (checkComponentPermission(pp.getWritePermission(),callingPid,callingUid,cpi.exported ? -1 : cpi.applicationInfo.uid) == PackageManager.PERMISSION_GRANTED) {
        return null;
      }
    }
  }
  HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(callingUid);
  if (perms != null) {
    for (    Map.Entry<Uri,UriPermission> uri : perms.entrySet()) {
      if (uri.getKey().getAuthority().equals(cpi.authority)) {
        return null;
      }
    }
  }
  String msg=""String_Node_Str"" + cpi.name + ""String_Node_Str""+ (r != null ? r : ""String_Node_Str"")+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ cpi.readPermission+ ""String_Node_Str""+ cpi.writePermission;
  Slog.w(TAG,msg);
  return msg;
}",0.8765852149706155
181474,"/** 
 * Puts the device to speaker mode. 
 */
void setSpeakerMode();","/** 
 * Puts the device to speaker mode. 
 */
void setSpeakerMode(boolean speakerMode);",0.8774193548387097
181475,"private void stopCall(boolean releaseSocket){
  Log.d(TAG,""String_Node_Str"");
  if (mRtpSession != null) {
    mRtpSession.join(null);
    if (releaseSocket) {
      mRtpSession.release();
      mRtpSession=null;
    }
  }
  setInCallMode();
}","private void stopCall(boolean releaseSocket){
  Log.d(TAG,""String_Node_Str"");
  if (mRtpSession != null) {
    mRtpSession.join(null);
    if (releaseSocket) {
      mRtpSession.release();
      mRtpSession=null;
    }
  }
}",0.9593147751605996
181476,"public synchronized void setSpeakerMode(){
  ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setSpeakerphoneOn(true);
}","public synchronized void setSpeakerMode(boolean speakerMode){
  ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setSpeakerphoneOn(speakerMode);
}",0.8993288590604027
181477,"private void startCall(SdpSessionDescription peerSd){
  stopCall(DONT_RELEASE_SOCKET);
  mPeerSd=peerSd;
  String peerMediaAddress=peerSd.getPeerMediaAddress(AUDIO);
  int peerMediaPort=peerSd.getPeerMediaPort(AUDIO);
  Log.i(TAG,""String_Node_Str"" + peerMediaAddress + ""String_Node_Str""+ peerMediaPort);
  int localPort=getLocalMediaPort();
  int sampleRate=8000;
  int frameSize=sampleRate / 50;
  try {
    mCodec=getCodec(peerSd);
    AudioStream audioStream=mRtpSession;
    audioStream.associate(InetAddress.getByName(peerMediaAddress),peerMediaPort);
    audioStream.setCodec(convert(mCodec),mCodec.payloadType);
    audioStream.setDtmfType(DTMF);
    Log.d(TAG,""String_Node_Str"" + localPort + ""String_Node_Str""+ peerMediaAddress+ ""String_Node_Str""+ peerMediaPort);
    audioStream.setMode(RtpStream.MODE_NORMAL);
    if (!mHold) {
      if (!peerSd.isSending(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_SEND_ONLY);
      }
      if (!peerSd.isReceiving(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_RECEIVE_ONLY);
      }
    }
    setInCallMode();
    AudioGroup audioGroup=new AudioGroup();
    audioStream.join(audioGroup);
    if (mHold) {
      audioGroup.setMode(AudioGroup.MODE_ON_HOLD);
    }
 else     if (mMuted) {
      audioGroup.setMode(AudioGroup.MODE_MUTED);
    }
 else {
      audioGroup.setMode(AudioGroup.MODE_NORMAL);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","private void startCall(SdpSessionDescription peerSd){
  stopCall(DONT_RELEASE_SOCKET);
  mPeerSd=peerSd;
  String peerMediaAddress=peerSd.getPeerMediaAddress(AUDIO);
  int peerMediaPort=peerSd.getPeerMediaPort(AUDIO);
  Log.i(TAG,""String_Node_Str"" + peerMediaAddress + ""String_Node_Str""+ peerMediaPort);
  int localPort=getLocalMediaPort();
  int sampleRate=8000;
  int frameSize=sampleRate / 50;
  try {
    mCodec=getCodec(peerSd);
    AudioStream audioStream=mRtpSession;
    audioStream.associate(InetAddress.getByName(peerMediaAddress),peerMediaPort);
    audioStream.setCodec(convert(mCodec),mCodec.payloadType);
    audioStream.setDtmfType(DTMF);
    Log.d(TAG,""String_Node_Str"" + localPort + ""String_Node_Str""+ peerMediaAddress+ ""String_Node_Str""+ peerMediaPort);
    audioStream.setMode(RtpStream.MODE_NORMAL);
    if (!mHold) {
      if (!peerSd.isSending(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_SEND_ONLY);
      }
      if (!peerSd.isReceiving(AUDIO)) {
        Log.d(TAG,""String_Node_Str"");
        audioStream.setMode(RtpStream.MODE_RECEIVE_ONLY);
      }
    }
 else {
      ((AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE)).setMode(AudioManager.MODE_NORMAL);
    }
    AudioGroup audioGroup=new AudioGroup();
    audioStream.join(audioGroup);
    if (mHold) {
      audioGroup.setMode(AudioGroup.MODE_ON_HOLD);
    }
 else     if (mMuted) {
      audioGroup.setMode(AudioGroup.MODE_MUTED);
    }
 else {
      audioGroup.setMode(AudioGroup.MODE_NORMAL);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.95744
181478,"public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg);
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}","public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      long now=SystemClock.uptimeMillis();
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg.toString(now));
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}",0.9540692989524576
181479,"public String toString(){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  b.append(when);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}","String toString(long now){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  TimeUtils.formatDuration(when - now,b);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}",0.9053318824809576
181480,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mToast=Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}",0.8966565349544073
181481,"public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}",0.982725527831094
181482,"public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}","public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}",0.9523809523809524
181483,"public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}","public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}",0.9596662030598052
181484,"public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}",0.9826923076923076
181485,"/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userDara the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}","/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userData the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}",0.9983443708609272
181486,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody.toString(),use7bitOnly);
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody,use7bitOnly);
}",0.9861286254728878
181487,"/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bearerData an instance of BearerData.
 * @return data byta array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}","/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bData an instance of BearerData.
 * @return byte array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}",0.9974640743871512
181488,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param msg message text
 * @param force7BitEncoding ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
        ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}",0.9416543574593796
181489,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets / MAX_USER_DATA_SEPTETS_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS_WITH_HEADER - (septets % MAX_USER_DATA_SEPTETS_WITH_HEADER);
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets + (MAX_USER_DATA_SEPTETS_WITH_HEADER - 1)) / MAX_USER_DATA_SEPTETS_WITH_HEADER;
      ted.codeUnitsRemaining=(ted.msgCount * MAX_USER_DATA_SEPTETS_WITH_HEADER) - septets;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
      ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}",0.9147516679021498
181490,"public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg);
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}","public void dump(Printer pw,String prefix){
  pw.println(prefix + this);
  pw.println(prefix + ""String_Node_Str"" + mRun);
  pw.println(prefix + ""String_Node_Str"" + mThread);
  pw.println(prefix + ""String_Node_Str"" + ((mQueue != null) ? mQueue : ""String_Node_Str""));
  if (mQueue != null) {
synchronized (mQueue) {
      long now=SystemClock.uptimeMillis();
      Message msg=mQueue.mMessages;
      int n=0;
      while (msg != null) {
        pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str""+ msg.toString(now));
        n++;
        msg=msg.next;
      }
      pw.println(prefix + ""String_Node_Str"" + n+ ""String_Node_Str"");
    }
  }
}",0.9540692989524576
181491,"public String toString(){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  b.append(when);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}","String toString(long now){
  StringBuilder b=new StringBuilder();
  b.append(""String_Node_Str"");
  b.append(what);
  b.append(""String_Node_Str"");
  TimeUtils.formatDuration(when - now,b);
  if (arg1 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg1);
  }
  if (arg2 != 0) {
    b.append(""String_Node_Str"");
    b.append(arg2);
  }
  if (obj != null) {
    b.append(""String_Node_Str"");
    b.append(obj);
  }
  b.append(""String_Node_Str"");
  return b.toString();
}",0.9053318824809576
181492,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mToast=Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT);
  ImageView content=new ImageView(this);
  content.setImageResource(com.android.internal.R.drawable.platlogo);
  content.setScaleType(ImageView.ScaleType.FIT_CENTER);
  setContentView(content);
}",0.8966565349544073
181493,"public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOnLocked(){
  if (!mScreenOn) {
    mHistoryCur.states|=HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=true;
    mScreenOnTimer.startRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].startRunningLocked(this);
    }
    noteStartWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}",0.982725527831094
181494,"public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}","public void noteStartWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.startRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=getPidStatsLocked(pid);
    p.mWakeStart=SystemClock.elapsedRealtime();
  }
}",0.9523809523809524
181495,"public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}","public void noteStopWakeLocked(int pid,String name,int type){
  StopwatchTimer t=getWakeTimerLocked(name,type);
  if (t != null) {
    t.stopRunningLocked(BatteryStatsImpl.this);
  }
  if (pid >= 0 && type == WAKE_TYPE_PARTIAL) {
    Pid p=mPids.get(pid);
    if (p != null) {
      p.mWakeSum+=SystemClock.elapsedRealtime() - p.mWakeStart;
      p.mWakeStart=0;
    }
  }
}",0.9596662030598052
181496,"public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",0);
  }
}","public void noteScreenOffLocked(){
  if (mScreenOn) {
    mHistoryCur.states&=~HistoryItem.STATE_SCREEN_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(SystemClock.elapsedRealtime());
    mScreenOn=false;
    mScreenOnTimer.stopRunningLocked(this);
    if (mScreenBrightnessBin >= 0) {
      mScreenBrightnessTimer[mScreenBrightnessBin].stopRunningLocked(this);
    }
    noteStopWakeLocked(-1,-1,""String_Node_Str"",WAKE_TYPE_PARTIAL);
  }
}",0.9826923076923076
181497,"/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userDara the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}","/** 
 * Get an SMS-SUBMIT PDU for a data message to a destination address &amp; port
 * @param destAddr the address of the destination for the message
 * @param userData the data for the message
 * @param statusReportRequested Indicates whether a report is requested for this message.
 * @return a <code>SubmitPdu</code> containing the encoded SCaddress, if applicable, and the encoded message. Returns null on encode error.
 */
public static SubmitPdu getSubmitPdu(String destAddr,UserData userData,boolean statusReportRequested){
  return privateGetSubmitPdu(destAddr,statusReportRequested,userData);
}",0.9983443708609272
181498,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody.toString(),use7bitOnly);
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param messageBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence messageBody,boolean use7bitOnly){
  return BearerData.calcTextEncodingDetails(messageBody,use7bitOnly);
}",0.9861286254728878
181499,"/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bearerData an instance of BearerData.
 * @return data byta array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}","/** 
 * Create serialized representation for BearerData object. (See 3GPP2 C.R1001-F, v1.0, section 4.5 for layout details)
 * @param bData an instance of BearerData.
 * @return byte array of raw encoded SMS bearer data.
 */
public static byte[] encode(BearerData bData){
  bData.hasUserDataHeader=((bData.userData != null) && (bData.userData.userDataHeader != null));
  try {
    BitwiseOutputStream outStream=new BitwiseOutputStream(200);
    outStream.write(8,SUBPARAM_MESSAGE_IDENTIFIER);
    encodeMessageId(bData,outStream);
    if (bData.userData != null) {
      outStream.write(8,SUBPARAM_USER_DATA);
      encodeUserData(bData,outStream);
    }
    if (bData.callbackNumber != null) {
      outStream.write(8,SUBPARAM_CALLBACK_NUMBER);
      encodeCallbackNumber(bData,outStream);
    }
    if (bData.userAckReq || bData.deliveryAckReq || bData.readAckReq|| bData.reportReq) {
      outStream.write(8,SUBPARAM_REPLY_OPTION);
      encodeReplyOption(bData,outStream);
    }
    if (bData.numberOfMessages != 0) {
      outStream.write(8,SUBPARAM_NUMBER_OF_MESSAGES);
      encodeMsgCount(bData,outStream);
    }
    if (bData.validityPeriodRelativeSet) {
      outStream.write(8,SUBPARAM_VALIDITY_PERIOD_RELATIVE);
      encodeValidityPeriodRel(bData,outStream);
    }
    if (bData.privacyIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIVACY_INDICATOR);
      encodePrivacyIndicator(bData,outStream);
    }
    if (bData.languageIndicatorSet) {
      outStream.write(8,SUBPARAM_LANGUAGE_INDICATOR);
      encodeLanguageIndicator(bData,outStream);
    }
    if (bData.displayModeSet) {
      outStream.write(8,SUBPARAM_MESSAGE_DISPLAY_MODE);
      encodeDisplayMode(bData,outStream);
    }
    if (bData.priorityIndicatorSet) {
      outStream.write(8,SUBPARAM_PRIORITY_INDICATOR);
      encodePriorityIndicator(bData,outStream);
    }
    if (bData.alertIndicatorSet) {
      outStream.write(8,SUBPARAM_ALERT_ON_MESSAGE_DELIVERY);
      encodeMsgDeliveryAlert(bData,outStream);
    }
    if (bData.messageStatusSet) {
      outStream.write(8,SUBPARAM_MESSAGE_STATUS);
      encodeMsgStatus(bData,outStream);
    }
    return outStream.toByteArray();
  }
 catch (  BitwiseOutputStream.AccessException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
catch (  CodingException ex) {
    Log.e(LOG_TAG,""String_Node_Str"" + ex);
  }
  return null;
}",0.9974640743871512
181500,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param msg message text
 * @param force7BitEncoding ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
        ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}",0.9416543574593796
181501,"/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets / MAX_USER_DATA_SEPTETS_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS_WITH_HEADER - (septets % MAX_USER_DATA_SEPTETS_WITH_HEADER);
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}","/** 
 * Calculate the number of septets needed to encode the message.
 * @param msgBody the message to encode
 * @param use7bitOnly ignore (but still count) illegal characters if true
 * @return TextEncodingDetails
 */
public static TextEncodingDetails calculateLength(CharSequence msgBody,boolean use7bitOnly){
  TextEncodingDetails ted=new TextEncodingDetails();
  try {
    int septets=GsmAlphabet.countGsmSeptets(msgBody,!use7bitOnly);
    ted.codeUnitCount=septets;
    if (septets > MAX_USER_DATA_SEPTETS) {
      ted.msgCount=(septets + (MAX_USER_DATA_SEPTETS_WITH_HEADER - 1)) / MAX_USER_DATA_SEPTETS_WITH_HEADER;
      ted.codeUnitsRemaining=(ted.msgCount * MAX_USER_DATA_SEPTETS_WITH_HEADER) - septets;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=MAX_USER_DATA_SEPTETS - septets;
    }
    ted.codeUnitSize=ENCODING_7BIT;
  }
 catch (  EncodeException ex) {
    int octets=msgBody.length() * 2;
    ted.codeUnitCount=msgBody.length();
    if (octets > MAX_USER_DATA_BYTES) {
      ted.msgCount=(octets + (MAX_USER_DATA_BYTES_WITH_HEADER - 1)) / MAX_USER_DATA_BYTES_WITH_HEADER;
      ted.codeUnitsRemaining=((ted.msgCount * MAX_USER_DATA_BYTES_WITH_HEADER) - octets) / 2;
    }
 else {
      ted.msgCount=1;
      ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
    }
    ted.codeUnitSize=ENCODING_16BIT;
  }
  return ted;
}",0.9147516679021498
181502,"/** 
 * Retrieves the compelete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}","/** 
 * Retrieves the complete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}",0.9982425307557118
181503,"/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  ret[14]=null;
  resultSuccess(result,ret);
}","/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  resultSuccess(result,ret);
}",0.984126984126984
181504,"/** 
 * Retrieves the compelete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}","/** 
 * Retrieves the complete voice mail number.
 * @hide
 */
public String getCompleteVoiceMailNumber(){
  mContext.enforceCallingOrSelfPermission(CALL_PRIVILEGED,""String_Node_Str"");
  String number=mPhone.getVoiceMailNumber();
  Log.d(LOG_TAG,""String_Node_Str"");
  return number;
}",0.9982425307557118
181505,"/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  ret[14]=null;
  resultSuccess(result,ret);
}","/** 
 * response.obj.result is an String[14] See ril.h for details Please note that registration state 4 (""unknown"") is treated as ""out of service"" above
 */
public void getRegistrationState(Message result){
  String ret[]=new String[14];
  ret[0]=""String_Node_Str"";
  ret[1]=null;
  ret[2]=null;
  ret[3]=null;
  ret[4]=null;
  ret[5]=null;
  ret[6]=null;
  ret[7]=null;
  ret[8]=null;
  ret[9]=null;
  ret[10]=null;
  ret[11]=null;
  ret[12]=null;
  ret[13]=null;
  resultSuccess(result,ret);
}",0.984126984126984
181506,"public void dispatchKey(KeyEvent event){
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
    if (false && event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}","private void dispatchKey(KeyEvent event,boolean sendDone){
  if (false && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  msg.arg1=sendDone ? 1 : 0;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}",0.9393694421988682
181507,"private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}","private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}",0.9574155653450808
181508,"void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}","void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}",0.745
181509,"private void finishKeyEvent(KeyEvent event){
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
}","private void finishKeyEvent(KeyEvent event){
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"");
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.7082294264339152
181510,"public void handleKey(KeyEvent event,Runnable finishedCallback){
  mFinishedCallback=finishedCallback;
  dispatchKey(event);
}","public void handleKey(KeyEvent event,Runnable finishedCallback){
  if (mFinishedCallback != null) {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
  mFinishedCallback=finishedCallback;
  dispatchKey(event,true);
}",0.717948717948718
181511,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"");
finishKeyEvent(event);
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
finishKeyEvent(event);
}
}
}",0.9849081364829396
181512,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,true);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,msg.arg1 != 0);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}",0.9979490891543008
181513,"public void dispatchKey(KeyEvent event){
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
    if (false && event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}","private void dispatchKey(KeyEvent event,boolean sendDone){
  if (false && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (event.getKeyCode() == KeyEvent.KEYCODE_CAMERA) {
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
      debug();
      if (Config.LOGD)       Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
  Message msg=obtainMessage(DISPATCH_KEY);
  msg.obj=event;
  msg.arg1=sendDone ? 1 : 0;
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ mView);
  sendMessageAtTime(msg,event.getEventTime());
}",0.9393694421988682
181514,"private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}","private void deliverKeyEvent(KeyEvent event,boolean sendDone){
  boolean handled=mView != null ? mView.dispatchKeyEventPreIme(event) : true;
  if (handled) {
    if (sendDone) {
      finishKeyEvent(event);
    }
    return;
  }
  if (mLastWasImTarget) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null && mView != null) {
      int seq=enqueuePendingEvent(event,sendDone);
      if (DEBUG_IMF)       Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ event);
      imm.dispatchKeyEvent(mView.getContext(),seq,event,mInputMethodCallback);
      return;
    }
  }
  deliverKeyEventToViewHierarchy(event,sendDone);
}",0.9574155653450808
181515,"void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      if (LOCAL_LOGV)       Log.v(TAG,""String_Node_Str"");
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}","void handleFinishedEvent(int seq,boolean handled){
  final KeyEvent event=(KeyEvent)retrievePendingEvent(seq);
  if (DEBUG_IMF)   Log.v(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event);
  if (event != null) {
    final boolean sendDone=seq >= 0;
    if (!handled) {
      deliverKeyEventToViewHierarchy(event,sendDone);
      return;
    }
 else     if (sendDone) {
      finishKeyEvent(event);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + seq + ""String_Node_Str""+ handled+ ""String_Node_Str""+ event+ ""String_Node_Str"");
    }
  }
}",0.745
181516,"private void finishKeyEvent(KeyEvent event){
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
}","private void finishKeyEvent(KeyEvent event){
  if (LOCAL_LOGV)   Log.v(TAG,""String_Node_Str"");
  if (mFinishedCallback != null) {
    mFinishedCallback.run();
    mFinishedCallback=null;
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.7082294264339152
181517,"public void handleKey(KeyEvent event,Runnable finishedCallback){
  mFinishedCallback=finishedCallback;
  dispatchKey(event);
}","public void handleKey(KeyEvent event,Runnable finishedCallback){
  if (mFinishedCallback != null) {
    Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"");
  }
  mFinishedCallback=finishedCallback;
  dispatchKey(event,true);
}",0.717948717948718
181518,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"");
finishKeyEvent(event);
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
finishKeyEvent(event);
}
}
}",0.9849081364829396
181519,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,true);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing(""String_Node_Str"");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
deliverKeyEvent((KeyEvent)msg.obj,msg.arg1 != 0);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,""String_Node_Str"");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
float appScale=mAttachInfo.mApplicationScale;
mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
}
}
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,""String_Node_Str"" + msg.obj + ""String_Node_Str""+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
}
}",0.9979490891543008
181520,"/** 
 * unregister phone from CallManager
 * @param phone
 */
public void unregisterPhone(Phone phone){
  if (phone != null && !mPhones.contains(phone)) {
    mPhones.remove(phone);
    mRingingCalls.remove(phone.getRingingCall());
    mBackgroundCalls.remove(phone.getBackgroundCall());
    mForegroundCalls.remove(phone.getForegroundCall());
    unregisterForPhoneStates(phone);
    if (phone == mDefaultPhone) {
      if (mPhones.isEmpty()) {
        mDefaultPhone=null;
      }
 else {
        mDefaultPhone=mPhones.get(0);
      }
    }
  }
}","/** 
 * unregister phone from CallManager
 * @param phone
 */
public void unregisterPhone(Phone phone){
  if (phone != null && mPhones.contains(phone)) {
    mPhones.remove(phone);
    mRingingCalls.remove(phone.getRingingCall());
    mBackgroundCalls.remove(phone.getBackgroundCall());
    mForegroundCalls.remove(phone.getForegroundCall());
    unregisterForPhoneStates(phone);
    if (phone == mDefaultPhone) {
      if (mPhones.isEmpty()) {
        mDefaultPhone=null;
      }
 else {
        mDefaultPhone=mPhones.get(0);
      }
    }
  }
}",0.9990850869167428
181521,"/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getX() - event.getRawX();
  return event.getX(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getRawX() - event.getX();
  return event.getX(pointerIndex) + offset;
}",0.988095238095238
181522,"/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getY() - event.getRawY();
  return event.getY(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getRawY() - event.getY();
  return event.getY(pointerIndex) + offset;
}",0.988095238095238
181523,"/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getX() - event.getRawX();
  return event.getX(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawX(int) method; simulate it pending future API approval. 
 */
private static float getRawX(MotionEvent event,int pointerIndex){
  float offset=event.getRawX() - event.getX();
  return event.getX(pointerIndex) + offset;
}",0.988095238095238
181524,"/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getY() - event.getRawY();
  return event.getY(pointerIndex) + offset;
}","/** 
 * MotionEvent has no getRawY(int) method; simulate it pending future API approval. 
 */
private static float getRawY(MotionEvent event,int pointerIndex){
  float offset=event.getRawY() - event.getY();
  return event.getY(pointerIndex) + offset;
}",0.988095238095238
181525,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
    if ((getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
      return;
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
synchronized (mRingingLock) {
      if (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
        return;
      }
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}",0.9541284403669724
181526,"@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}","@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
synchronized (mRingingLock) {
      mIsRinging=true;
    }
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}",0.8816920026437541
181527,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9723661485319516
181528,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
    if ((getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
      return;
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (!Intent.ACTION_MEDIA_BUTTON.equals(action)) {
    return;
  }
  KeyEvent event=(KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
  if (event != null) {
synchronized (mRingingLock) {
      if (mIsRinging || (getMode() == AudioSystem.MODE_IN_CALL) || (getMode() == AudioSystem.MODE_RINGTONE)) {
        return;
      }
    }
synchronized (mRCStack) {
      if (!mRCStack.empty()) {
        Intent targetedIntent=new Intent(Intent.ACTION_MEDIA_BUTTON);
        targetedIntent.putExtras(intent.getExtras());
        targetedIntent.setComponent(mRCStack.peek().mReceiverComponent);
        abortBroadcast();
        context.sendBroadcast(targetedIntent,null);
      }
    }
  }
}",0.9541284403669724
181529,"@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}","@Override public void onCallStateChanged(int state,String incomingNumber){
  if (state == TelephonyManager.CALL_STATE_RINGING) {
synchronized (mRingingLock) {
      mIsRinging=true;
    }
    int ringVolume=AudioService.this.getStreamVolume(AudioManager.STREAM_RING);
    if (ringVolume > 0) {
      requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
    }
  }
 else   if (state == TelephonyManager.CALL_STATE_OFFHOOK) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    requestAudioFocus(AudioManager.STREAM_RING,AudioManager.AUDIOFOCUS_GAIN_TRANSIENT,null,null,IN_VOICE_COMM_FOCUS_ID);
  }
 else   if (state == TelephonyManager.CALL_STATE_IDLE) {
synchronized (mRingingLock) {
      mIsRinging=false;
    }
    abandonAudioFocus(null,IN_VOICE_COMM_FOCUS_ID);
  }
}",0.8816920026437541
181530,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9723661485319516
181531,"@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}",0.979047619047619
181532,"@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}",0.9783037475345168
181533,"public void run(){
synchronized (sLock) {
    nativeFinished(mFinishedToken);
  }
}","public void run(){
synchronized (sLock) {
    if (mFinishedToken == -1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    nativeFinished(mFinishedToken);
    mFinishedToken=-1;
    if (sRecycleCount < RECYCLE_MAX_COUNT) {
      mRecycleNext=sRecycleHead;
      sRecycleHead=this;
      sRecycleCount+=1;
      if (DEBUG_RECYCLING) {
        Slog.d(TAG,""String_Node_Str"" + sRecycleCount);
      }
    }
  }
}",0.2588235294117647
181534,"public FinishedCallback(long finishedToken){
  mFinishedToken=finishedToken;
}","private FinishedCallback(){
}",0.4485981308411215
181535,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9751157407407408
181536,"@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchMotionEvent(InputHandler inputHandler,MotionEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleMotion(event,finishedCallback);
}",0.979047619047619
181537,"@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=new FinishedCallback(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}","@SuppressWarnings(""String_Node_Str"") private static void dispatchKeyEvent(InputHandler inputHandler,KeyEvent event,long finishedToken){
  Runnable finishedCallback=FinishedCallback.obtain(finishedToken);
  inputHandler.handleKey(event,finishedCallback);
}",0.9783037475345168
181538,"public void run(){
synchronized (sLock) {
    nativeFinished(mFinishedToken);
  }
}","public void run(){
synchronized (sLock) {
    if (mFinishedToken == -1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    nativeFinished(mFinishedToken);
    mFinishedToken=-1;
    if (sRecycleCount < RECYCLE_MAX_COUNT) {
      mRecycleNext=sRecycleHead;
      sRecycleHead=this;
      sRecycleCount+=1;
      if (DEBUG_RECYCLING) {
        Slog.d(TAG,""String_Node_Str"" + sRecycleCount);
      }
    }
  }
}",0.2588235294117647
181539,"public FinishedCallback(long finishedToken){
  mFinishedToken=finishedToken;
}","private FinishedCallback(){
}",0.4485981308411215
181540,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9751157407407408
181541,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9723661485319516
181542,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9723661485319516
181543,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9762824048538334
181544,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9762824048538334
181545,"/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}","/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED) || ctTypeStr.equals(ContentType.MULTIPART_ALTERNATIVE)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}",0.986845252331978
181546,"/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (""String_Node_Str"".equals(contentType) || ""String_Node_Str"".equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}","/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (ContentType.TEXT_PLAIN.equals(contentType) || ContentType.APP_SMIL.equals(contentType) || ContentType.TEXT_HTML.equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}",0.9749833960593314
181547,"private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}","private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (ContentType.TEXT_PLAIN.equals(type) || ContentType.APP_SMIL.equals(type) || ContentType.TEXT_HTML.equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}",0.9829942301852416
181548,"/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}","/** 
 * Parse the pdu.
 * @return the pdu structure if parsing successfully.null if parsing error happened or mandatory fields are not set.
 */
public GenericPdu parse(){
  if (mPduDataStream == null) {
    return null;
  }
  mHeaders=parseHeaders(mPduDataStream);
  if (null == mHeaders) {
    return null;
  }
  int messageType=mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
  if (false == checkMandatoryHeader(mHeaders)) {
    log(""String_Node_Str"");
    return null;
  }
  if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
    mBody=parseParts(mPduDataStream);
    if (null == mBody) {
      return null;
    }
  }
switch (messageType) {
case PduHeaders.MESSAGE_TYPE_SEND_REQ:
    SendReq sendReq=new SendReq(mHeaders,mBody);
  return sendReq;
case PduHeaders.MESSAGE_TYPE_SEND_CONF:
SendConf sendConf=new SendConf(mHeaders);
return sendConf;
case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
NotificationInd notificationInd=new NotificationInd(mHeaders);
return notificationInd;
case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
NotifyRespInd notifyRespInd=new NotifyRespInd(mHeaders);
return notifyRespInd;
case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
RetrieveConf retrieveConf=new RetrieveConf(mHeaders,mBody);
byte[] contentType=retrieveConf.getContentType();
if (null == contentType) {
return null;
}
String ctTypeStr=new String(contentType);
if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED) || ctTypeStr.equals(ContentType.MULTIPART_ALTERNATIVE)) {
return retrieveConf;
}
return null;
case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
DeliveryInd deliveryInd=new DeliveryInd(mHeaders);
return deliveryInd;
case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
AcknowledgeInd acknowledgeInd=new AcknowledgeInd(mHeaders);
return acknowledgeInd;
case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
ReadOrigInd readOrigInd=new ReadOrigInd(mHeaders);
return readOrigInd;
case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
ReadRecInd readRecInd=new ReadRecInd(mHeaders);
return readRecInd;
default :
log(""String_Node_Str"");
return null;
}
}",0.986845252331978
181549,"/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (""String_Node_Str"".equals(contentType) || ""String_Node_Str"".equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}","/** 
 * Save data of the part into storage. The source data may be given by a byte[] or a Uri. If it's a byte[], directly save it into storage, otherwise load source data from the dataUri and then save it. If the data is an image, we may scale down it according to user preference.
 * @param part The PDU part which contains data to be saved.
 * @param uri The URI of the part.
 * @param contentType The MIME type of the part.
 * @throws MmsException Cannot find source data or error occurredwhile saving the data.
 */
private void persistData(PduPart part,Uri uri,String contentType) throws MmsException {
  OutputStream os=null;
  InputStream is=null;
  try {
    byte[] data=part.getData();
    if (ContentType.TEXT_PLAIN.equals(contentType) || ContentType.APP_SMIL.equals(contentType) || ContentType.TEXT_HTML.equals(contentType)) {
      ContentValues cv=new ContentValues();
      cv.put(Telephony.Mms.Part.TEXT,new EncodedStringValue(data).getString());
      if (mContentResolver.update(uri,cv,null,null) != 1) {
        throw new MmsException(""String_Node_Str"" + uri.toString());
      }
    }
 else {
      os=mContentResolver.openOutputStream(uri);
      if (data == null) {
        Uri dataUri=part.getDataUri();
        if ((dataUri == null) || (dataUri == uri)) {
          Log.w(TAG,""String_Node_Str"");
          return;
        }
        is=mContentResolver.openInputStream(dataUri);
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        byte[] buffer=new byte[256];
        for (int len=0; (len=is.read(buffer)) != -1; ) {
          os.write(buffer,0,len);
        }
      }
 else {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"" + uri);
        }
        os.write(data);
      }
    }
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new MmsException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + os,e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + is,e);
      }
    }
  }
}",0.9749833960593314
181550,"private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}","private PduPart[] loadParts(long msgId) throws MmsException {
  Cursor c=SqliteWrapper.query(mContext,mContentResolver,Uri.parse(""String_Node_Str"" + msgId + ""String_Node_Str""),PART_PROJECTION,null,null,null);
  PduPart[] parts=null;
  try {
    if ((c == null) || (c.getCount() == 0)) {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + msgId + ""String_Node_Str"");
      }
      return null;
    }
    int partCount=c.getCount();
    int partIdx=0;
    parts=new PduPart[partCount];
    while (c.moveToNext()) {
      PduPart part=new PduPart();
      Integer charset=getIntegerFromPartColumn(c,PART_COLUMN_CHARSET);
      if (charset != null) {
        part.setCharset(charset);
      }
      byte[] contentDisposition=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_DISPOSITION);
      if (contentDisposition != null) {
        part.setContentDisposition(contentDisposition);
      }
      byte[] contentId=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_ID);
      if (contentId != null) {
        part.setContentId(contentId);
      }
      byte[] contentLocation=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_LOCATION);
      if (contentLocation != null) {
        part.setContentLocation(contentLocation);
      }
      byte[] contentType=getByteArrayFromPartColumn(c,PART_COLUMN_CONTENT_TYPE);
      if (contentType != null) {
        part.setContentType(contentType);
      }
 else {
        throw new MmsException(""String_Node_Str"");
      }
      byte[] fileName=getByteArrayFromPartColumn(c,PART_COLUMN_FILENAME);
      if (fileName != null) {
        part.setFilename(fileName);
      }
      byte[] name=getByteArrayFromPartColumn(c,PART_COLUMN_NAME);
      if (name != null) {
        part.setName(name);
      }
      long partId=c.getLong(PART_COLUMN_ID);
      Uri partURI=Uri.parse(""String_Node_Str"" + partId);
      part.setDataUri(partURI);
      String type=toIsoString(contentType);
      if (!ContentType.isImageType(type) && !ContentType.isAudioType(type) && !ContentType.isVideoType(type)) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        InputStream is=null;
        if (ContentType.TEXT_PLAIN.equals(type) || ContentType.APP_SMIL.equals(type) || ContentType.TEXT_HTML.equals(type)) {
          String text=c.getString(PART_COLUMN_TEXT);
          byte[] blob=new EncodedStringValue(text != null ? text : ""String_Node_Str"").getTextString();
          baos.write(blob,0,blob.length);
        }
 else {
          try {
            is=mContentResolver.openInputStream(partURI);
            byte[] buffer=new byte[256];
            int len=is.read(buffer);
            while (len >= 0) {
              baos.write(buffer,0,len);
              len=is.read(buffer);
            }
          }
 catch (          IOException e) {
            Log.e(TAG,""String_Node_Str"",e);
            c.close();
            throw new MmsException(e);
          }
 finally {
            if (is != null) {
              try {
                is.close();
              }
 catch (              IOException e) {
                Log.e(TAG,""String_Node_Str"",e);
              }
            }
          }
        }
        part.setData(baos.toByteArray());
      }
      parts[partIdx++]=part;
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
  return parts;
}",0.9829942301852416
181551,"synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}","synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}",0.9843462246777164
181552,"synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}","synchronized void getAllProperties(){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,""String_Node_Str"");
  mAdapterProperties.clear();
  String properties[]=(String[])getAdapterPropertiesNative();
  if (properties == null) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  for (int i=0; i < properties.length; i++) {
    String name=properties[i];
    String newValue=null;
    int len;
    if (name == null) {
      Log.e(TAG,""String_Node_Str"" + i + ""String_Node_Str"");
      continue;
    }
    if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
      StringBuilder str=new StringBuilder();
      len=Integer.valueOf(properties[++i]);
      for (int j=0; j < len; j++) {
        str.append(properties[++i]);
        str.append(""String_Node_Str"");
      }
      if (len > 0) {
        newValue=str.toString();
      }
    }
 else {
      newValue=properties[++i];
    }
    mAdapterProperties.put(name,newValue);
  }
  String adapterPath=getAdapterPathNative();
  if (adapterPath != null)   mAdapterProperties.put(""String_Node_Str"",adapterPath + ""String_Node_Str"");
}",0.9843462246777164
181553,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}",0.6769662921348315
181554,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}",0.6769662921348315
181555,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}",0.6769662921348315
181556,"/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}","/** 
 * Insert new rows (no where clause allowed). 
 */
SqlArguments(Uri url){
  if (url.getPathSegments().size() == 1) {
    this.table=url.getPathSegments().get(0);
    if (!DatabaseHelper.isValidTable(this.table)) {
      throw new IllegalArgumentException(""String_Node_Str"" + this.table);
    }
    this.where=null;
    this.args=null;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + url);
  }
}",0.6769662921348315
181557,"public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return encoderMap.get(audioEncoder);
}","public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return audioEncoderMap.get(audioEncoder);
}",0.992248062015504
181558,"public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return encoderMap.get(videoEncoder);
}","public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return videoEncoderMap.get(videoEncoder);
}",0.9897810218978104
181559,"public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return encoderMap.get(audioEncoder);
}","public static String getAudioCodecName(int audioEncoder){
  if (audioEncoder != MediaRecorder.AudioEncoder.AMR_NB && audioEncoder != MediaRecorder.AudioEncoder.AMR_WB && audioEncoder != MediaRecorder.AudioEncoder.AAC && audioEncoder != MediaRecorder.AudioEncoder.AAC_PLUS && audioEncoder != MediaRecorder.AudioEncoder.EAAC_PLUS) {
    throw new IllegalArgumentException(""String_Node_Str"" + audioEncoder);
  }
  return audioEncoderMap.get(audioEncoder);
}",0.992248062015504
181560,"public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return encoderMap.get(videoEncoder);
}","public static String getVideoCodecName(int videoEncoder){
  if (videoEncoder != MediaRecorder.VideoEncoder.H263 && videoEncoder != MediaRecorder.VideoEncoder.H264 && videoEncoder != MediaRecorder.VideoEncoder.MPEG_4_SP) {
    throw new IllegalArgumentException(""String_Node_Str"" + videoEncoder);
  }
  return videoEncoderMap.get(videoEncoder);
}",0.9897810218978104
181561,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.6045751633986928
181562,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.8342541436464088
181563,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.6045751633986928
181564,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.8342541436464088
181565,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.6045751633986928
181566,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.8342541436464088
181567,"public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    mStartcount=0;
    mCb.unlinkToDeath(this,0);
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void clearCount(boolean stopSco){
synchronized (mScoClients) {
    if (mStartcount != 0) {
      try {
        mCb.unlinkToDeath(this,0);
      }
 catch (      NoSuchElementException e) {
        Log.w(TAG,""String_Node_Str"" + mStartcount + ""String_Node_Str"");
      }
    }
    mStartcount=0;
    if (stopSco) {
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.6045751633986928
181568,"public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        mCb.unlinkToDeath(this,0);
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}","public void decCount(){
synchronized (mScoClients) {
    if (mStartcount == 0) {
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mStartcount--;
      if (mStartcount == 0) {
        try {
          mCb.unlinkToDeath(this,0);
        }
 catch (        NoSuchElementException e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      requestScoState(BluetoothHeadset.AUDIO_STATE_DISCONNECTED);
    }
  }
}",0.8342541436464088
181569,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              id.views=null;
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}",0.9924103637791154
181570,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
AudioSystem.setParameters(""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
AudioSystem.setParameters(""String_Node_Str"");
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9745152354570638
181571,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
    requestDisallowInterceptTouchEvent(true);
  }
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.989845081906456
181572,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
    requestDisallowInterceptTouchEvent(true);
  }
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  if (atEdge && getChildCount() > 0) {
    int motionPosition=findMotionRow(y);
    if (motionPosition >= 0) {
      final View motionView=getChildAt(motionPosition - mFirstPosition);
      mMotionViewOriginalTop=motionView.getTop();
    }
    mMotionY=y;
    mMotionPosition=motionPosition;
    invalidate();
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.989845081906456
181573,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
AudioSystem.setParameters(""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
AudioSystem.setParameters(""String_Node_Str"");
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9745152354570638
181574,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers == null ? 0 : broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              id.views=null;
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}",0.9924103637791154
181575,"static boolean isDnsReachable(int dns,int timeout){
  try {
    DatagramSocket socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
}","static boolean isDnsReachable(int dns,int timeout){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
 finally {
    if (socket != null) {
      socket.close();
    }
  }
}",0.953808752025932
181576,"static boolean isDnsReachable(int dns,int timeout){
  try {
    DatagramSocket socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
}","static boolean isDnsReachable(int dns,int timeout){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket();
    socket.setSoTimeout(timeout);
    byte[] buf=new byte[DNS_QUERY_BASE_SIZE];
    fillQuery(buf);
    byte parts[]=new byte[4];
    parts[0]=(byte)(dns & 0xff);
    parts[1]=(byte)((dns >> 8) & 0xff);
    parts[2]=(byte)((dns >> 16) & 0xff);
    parts[3]=(byte)((dns >> 24) & 0xff);
    InetAddress dnsAddress=InetAddress.getByAddress(parts);
    DatagramPacket packet=new DatagramPacket(buf,buf.length,dnsAddress,DNS_PORT);
    socket.send(packet);
    DatagramPacket replyPacket=new DatagramPacket(buf,buf.length);
    socket.receive(replyPacket);
    return true;
  }
 catch (  SocketException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  UnknownHostException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  SocketTimeoutException e) {
    return false;
  }
catch (  IOException e) {
    if (V) {
      Slog.v(TAG,""String_Node_Str"",e);
    }
    return false;
  }
catch (  Exception e) {
    if (V || Config.LOGD) {
      Slog.d(TAG,""String_Node_Str"",e);
    }
    return false;
  }
 finally {
    if (socket != null) {
      socket.close();
    }
  }
}",0.953808752025932
181577,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}",0.989384288747346
181578,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}",0.989384288747346
181579,"private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}","private int updatePointerIdentifiers(){
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int nextNumPointers=mNextNumPointers;
  final int lastNumPointers=mLastNumPointers;
  if (nextNumPointers == 1 && lastNumPointers == 1) {
    System.arraycopy(nextData,0,lastData,0,MotionEvent.NUM_SAMPLE_DATA);
    return -1;
  }
  final int[] last2Next=mLast2Next;
  for (int i=0; i < lastNumPointers; i++) {
    last2Next[i]=-1;
  }
  if (DEBUG_POINTERS)   Slog.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers);
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  boolean conflicts=false;
  for (int i=0; i < nextNumPointers; i++) {
    conflicts|=assignPointer(i,true);
  }
  if (conflicts) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] != -2) {
        continue;
      }
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
      int numFound;
      do {
        numFound=0;
        long worstDistance=0;
        int worstJ=-1;
        for (int j=0; j < nextNumPointers; j++) {
          if (next2Last[j] != i) {
            continue;
          }
          numFound++;
          if (worstDistance < next2LastDistance[j]) {
            worstDistance=next2LastDistance[j];
            worstJ=j;
          }
        }
        if (worstJ >= 0) {
          if (DEBUG_POINTERS)           Slog.v(""String_Node_Str"",""String_Node_Str"" + worstJ + ""String_Node_Str""+ worstDistance+ ""String_Node_Str"");
          if (assignPointer(worstJ,false)) {
            next2Last[worstJ]=-1;
          }
        }
      }
 while (numFound > 2);
    }
  }
  int retIndex=-1;
  if (lastNumPointers < nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    int nextId=0;
    int i=0;
    while (i < lastNumPointers) {
      if (mPointerIds[i] > nextId) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        System.arraycopy(mPointerIds,i,mPointerIds,i + 1,lastNumPointers - i);
        System.arraycopy(lastData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,(i + 1) * MotionEvent.NUM_SAMPLE_DATA,(lastNumPointers - i) * MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(next2Last,i,next2Last,i + 1,lastNumPointers - i);
        break;
      }
      i++;
      nextId++;
    }
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"" + nextId + ""String_Node_Str""+ i);
    mLastNumPointers++;
    retIndex=i;
    mPointerIds[i]=nextId;
    for (int j=0; j < nextNumPointers; j++) {
      if (next2Last[j] < 0) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + j);
        next2Last[j]=i;
        break;
      }
    }
  }
  for (int i=0; i < nextNumPointers; i++) {
    int lastIndex=next2Last[i];
    if (lastIndex >= 0) {
      if (DEBUG_POINTERS)       Slog.v(""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ lastIndex);
      System.arraycopy(nextData,i * MotionEvent.NUM_SAMPLE_DATA,lastData,lastIndex * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
    }
  }
  if (lastNumPointers > nextNumPointers) {
    if (DEBUG_POINTERS)     Slog.v(""String_Node_Str"",""String_Node_Str"");
    for (int i=0; i < lastNumPointers; i++) {
      if (last2Next[i] == -1) {
        if (DEBUG_POINTERS)         Slog.v(""String_Node_Str"",""String_Node_Str"" + i);
        retIndex=i;
        break;
      }
    }
  }
  return retIndex;
}",0.989384288747346
181580,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6438356164383562
181581,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6312056737588653
181582,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6438356164383562
181583,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6312056737588653
181584,"public void removePackageFromPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void removePackageFromPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6438356164383562
181585,"public void addPackageToPreferred(String packageName){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS,null);
  Slog.w(TAG,""String_Node_Str"");
}","public void addPackageToPreferred(String packageName){
  Slog.w(TAG,""String_Node_Str"");
}",0.6312056737588653
181586,"/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else   if (mRecycled) {
    throw new RuntimeException(toString() + ""String_Node_Str"");
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}","/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else {
    if (mRecycled) {
      throw new RuntimeException(toString() + ""String_Node_Str"");
    }
    mRecycled=true;
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}",0.9763313609467456
181587,"/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else   if (mRecycled) {
    throw new RuntimeException(toString() + ""String_Node_Str"");
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}","/** 
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling this function you must not ever touch the event again.
 */
public void recycle(){
  if (TRACK_RECYCLED_LOCATION) {
    if (mRecycledLocation != null) {
      throw new RuntimeException(toString() + ""String_Node_Str"",mRecycledLocation);
    }
    mRecycledLocation=new RuntimeException(""String_Node_Str"");
  }
 else {
    if (mRecycled) {
      throw new RuntimeException(toString() + ""String_Node_Str"");
    }
    mRecycled=true;
  }
synchronized (gRecyclerLock) {
    if (gRecyclerUsed < MAX_RECYCLED) {
      gRecyclerUsed++;
      mNumSamples=0;
      mNext=gRecyclerTop;
      gRecyclerTop=this;
    }
  }
}",0.9763313609467456
181588,"public Boolean geocoderIsImplemented(){
  return mGeocodeProvider != null;
}","public boolean geocoderIsImplemented(){
  return mGeocodeProvider != null;
}",0.986842105263158
181589,"public void onItemClick(AdapterView parent,View v,int position,long id){
  onListItemClick((ListView)parent,v,position,id);
}","public void onItemClick(AdapterView<?> parent,View v,int position,long id){
  onListItemClick((ListView)parent,v,position,id);
}",0.9881422924901184
181590,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}",0.856140350877193
181591,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}",0.856140350877193
181592,"SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
  cachePath=PackageHelper.getSdDir(cid);
}","SdInstallArgs(Uri packageURI,String cid){
  super(packageURI,null,PackageManager.INSTALL_EXTERNAL,null);
  this.cid=cid;
}",0.856140350877193
181593,"public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}","public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(Environment.getExternalStorageDirectory().toString(),""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}",0.9542709232096636
181594,"public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}","public void onPictureTaken(byte[] rawData,Camera camera){
  try {
    if (rawData != null) {
      int rawDataLength=rawData.length;
      File rawoutput=new File(Environment.getExternalStorageDirectory().toString(),""String_Node_Str"");
      FileOutputStream outstream=new FileOutputStream(rawoutput);
      outstream.write(rawData);
      Log.v(TAG,""String_Node_Str"" + rawDataLength);
      jpegPictureCallbackResult=true;
    }
 else {
      jpegPictureCallbackResult=false;
    }
    mSnapshotDone.open();
    Log.v(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.v(TAG,e.toString());
  }
}",0.9542709232096636
181595,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9853372434017597
181596,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9980237154150198
181597,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.9162717219589256
181598,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}",0.6503267973856209
181599,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.7835051546391752
181600,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}",0.9635036496350364
181601,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}",0.9632352941176472
181602,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9786028949024544
181603,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}",0.9798792756539236
181604,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9853372434017597
181605,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9980237154150198
181606,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.9162717219589256
181607,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}",0.6503267973856209
181608,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.7835051546391752
181609,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}",0.9635036496350364
181610,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}",0.9632352941176472
181611,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9786028949024544
181612,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}",0.9798792756539236
181613,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9853372434017597
181614,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        if (r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
        if (cpr.app != null && r.setAdj >= VISIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.app,false,true);
        }
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Slog.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Slog.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9853372434017597
181615,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}",0.9795361527967258
181616,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}",0.7621247113163973
181617,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}",0.9795361527967258
181618,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}",0.7621247113163973
181619,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}",0.9795361527967258
181620,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}",0.7621247113163973
181621,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9980237154150198
181622,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.9162717219589256
181623,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}",0.6503267973856209
181624,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.7835051546391752
181625,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}",0.9635036496350364
181626,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}",0.9632352941176472
181627,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9786028949024544
181628,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}",0.9798792756539236
181629,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  if (key == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  final String encodedKey=encode(key,null);
  final int encodedKeyLength=encodedKey.length();
  int encodedKeySearchIndex=0;
  final int encodedKeySearchEnd=query.length() - (encodedKeyLength + 1);
  while (encodedKeySearchIndex <= encodedKeySearchEnd) {
    int keyIndex=query.indexOf(encodedKey,encodedKeySearchIndex);
    if (keyIndex == -1) {
      break;
    }
    final int equalsIndex=keyIndex + encodedKeyLength;
    if (equalsIndex >= query.length()) {
      break;
    }
    if (query.charAt(equalsIndex) != '=') {
      encodedKeySearchIndex=equalsIndex + 1;
      continue;
    }
    if (keyIndex == 0 || query.charAt(keyIndex - 1) == '&') {
      int end=query.indexOf('&',equalsIndex);
      if (end == -1) {
        end=query.length();
      }
      return decode(query.substring(equalsIndex + 1,end));
    }
 else {
      encodedKeySearchIndex=equalsIndex + 1;
    }
  }
  return null;
}",0.9795361527967258
181630,"public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
}","public void testGetQueryParameterEdgeCases(){
  Uri uri;
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"").buildUpon().appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").appendQueryParameter(""String_Node_Str"",""String_Node_Str"").build();
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  assertNull(uri.getQueryParameter(""String_Node_Str""));
  uri=Uri.parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",uri.getQueryParameter(""String_Node_Str""));
}",0.7621247113163973
181631,"/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * TODO document for SDK Abandon audio focus.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int abandonAudioFocus(OnAudioFocusChangeListener l){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  unregisterAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.abandonAudioFocus(mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9980237154150198
181632,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * TODO hide
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.9162717219589256
181633,"/** 
 * TODO document for SDK
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
  IAudioService service=getService();
  try {
    service.unregisterAudioFocusClient(getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}","/** 
 * TODO hide
 */
public void unregisterAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    mAudioFocusIdListenerMap.remove(getIdForAudioFocusListener(l));
  }
}",0.6503267973856209
181634,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  try {
synchronized (mAudioFocusLock) {
      removeFocusStackEntry(clientId,true);
    }
  }
 catch (  java.util.ConcurrentModificationException cme) {
    Log.e(TAG,""String_Node_Str"" + cme);
    cme.printStackTrace();
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.7835051546391752
181635,"public void binderDied(){
synchronized (mFocusStack) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}","public void binderDied(){
synchronized (mAudioFocusLock) {
    Log.w(TAG,""String_Node_Str"");
    removeFocusStackEntryForClient(mCb);
  }
}",0.9635036496350364
181636,"public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mAudioFocusLock) {
    removeFocusStackEntry(clientId,false);
  }
}",0.9632352941176472
181637,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId) && ((cb == null) || !cb.pingBinder())) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mAudioFocusLock) {
    if (!canReassignAudioFocus()) {
      return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  if (!IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
    AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
    try {
      cb.linkToDeath(afdh,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
    }
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9786028949024544
181638,"/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mFocusStack) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}","/** 
 * Helper function: Display in the log the current entries in the audio focus stack
 */
private void dumpFocusStack(PrintWriter pw){
  pw.println(""String_Node_Str"");
synchronized (mAudioFocusLock) {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=stackIterator.next();
      pw.println(""String_Node_Str"" + fse.mSourceRef + ""String_Node_Str""+ fse.mClientId+ ""String_Node_Str""+ fse.mFocusChangeType);
    }
  }
}",0.9798792756539236
181639,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}",0.9416135881104034
181640,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}",0.9416135881104034
181641,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}",0.9416135881104034
181642,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}",0.897770945426595
181643,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}",0.9828138654238276
181644,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}",0.9831479609032692
181645,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9879739978331528
181646,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}",0.8945868945868946
181647,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}",0.9258517034068136
181648,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}",0.9846069268829029
181649,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}",0.9828138654238276
181650,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}",0.9831479609032692
181651,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9879739978331528
181652,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}",0.8945868945868946
181653,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}",0.9258517034068136
181654,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}",0.9846069268829029
181655,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}",0.9828138654238276
181656,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}",0.9831479609032692
181657,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9879739978331528
181658,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}",0.8945868945868946
181659,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}",0.9258517034068136
181660,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}",0.9846069268829029
181661,"/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
    audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
  return;
case SoundEffectConstants.NAVIGATION_DOWN:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}","/** 
 * {@inheritDoc}
 */
public void playSoundEffect(int effectId){
  checkThread();
  try {
    final AudioManager audioManager=getAudioManager();
switch (effectId) {
case SoundEffectConstants.CLICK:
      audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
    return;
case SoundEffectConstants.NAVIGATION_DOWN:
  audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
return;
case SoundEffectConstants.NAVIGATION_LEFT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
return;
case SoundEffectConstants.NAVIGATION_RIGHT:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
return;
case SoundEffectConstants.NAVIGATION_UP:
audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
return;
default :
throw new IllegalArgumentException(""String_Node_Str"" + effectId + ""String_Node_Str""+ SoundEffectConstants.class.getCanonicalName());
}
}
 catch (IllegalStateException e) {
Log.e(TAG,""String_Node_Str"" + e);
e.printStackTrace();
}
}",0.9416135881104034
181662,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}",0.897770945426595
181663,"/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    mMenu.getContext().startActivity(mIntent);
    return true;
  }
  return false;
}","/** 
 * Invokes the item by calling various listeners or callbacks.
 * @return true if the invocation was handled, false otherwise
 */
public boolean invoke(){
  if (mClickListener != null && mClickListener.onMenuItemClick(this)) {
    return true;
  }
  MenuBuilder.Callback callback=mMenu.getCallback();
  if (callback != null && callback.onMenuItemSelected(mMenu.getRootMenu(),this)) {
    return true;
  }
  if (mItemCallback != null) {
    mItemCallback.run();
    return true;
  }
  if (mIntent != null) {
    try {
      mMenu.getContext().startActivity(mIntent);
      return true;
    }
 catch (    ActivityNotFoundException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}",0.897770945426595
181664,"String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","String codeToString(int code){
  if (localLOGV) {
switch (code) {
case LAUNCH_ACTIVITY:
      return ""String_Node_Str"";
case PAUSE_ACTIVITY:
    return ""String_Node_Str"";
case PAUSE_ACTIVITY_FINISHING:
  return ""String_Node_Str"";
case STOP_ACTIVITY_SHOW:
return ""String_Node_Str"";
case STOP_ACTIVITY_HIDE:
return ""String_Node_Str"";
case SHOW_WINDOW:
return ""String_Node_Str"";
case HIDE_WINDOW:
return ""String_Node_Str"";
case RESUME_ACTIVITY:
return ""String_Node_Str"";
case SEND_RESULT:
return ""String_Node_Str"";
case DESTROY_ACTIVITY:
return ""String_Node_Str"";
case BIND_APPLICATION:
return ""String_Node_Str"";
case EXIT_APPLICATION:
return ""String_Node_Str"";
case NEW_INTENT:
return ""String_Node_Str"";
case RECEIVER:
return ""String_Node_Str"";
case CREATE_SERVICE:
return ""String_Node_Str"";
case SERVICE_ARGS:
return ""String_Node_Str"";
case STOP_SERVICE:
return ""String_Node_Str"";
case REQUEST_THUMBNAIL:
return ""String_Node_Str"";
case CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case CLEAN_UP_CONTEXT:
return ""String_Node_Str"";
case GC_WHEN_IDLE:
return ""String_Node_Str"";
case BIND_SERVICE:
return ""String_Node_Str"";
case UNBIND_SERVICE:
return ""String_Node_Str"";
case DUMP_SERVICE:
return ""String_Node_Str"";
case LOW_MEMORY:
return ""String_Node_Str"";
case ACTIVITY_CONFIGURATION_CHANGED:
return ""String_Node_Str"";
case RELAUNCH_ACTIVITY:
return ""String_Node_Str"";
case PROFILER_CONTROL:
return ""String_Node_Str"";
case CREATE_BACKUP_AGENT:
return ""String_Node_Str"";
case DESTROY_BACKUP_AGENT:
return ""String_Node_Str"";
case SUICIDE:
return ""String_Node_Str"";
case REMOVE_PROVIDER:
return ""String_Node_Str"";
case ENABLE_JIT:
return ""String_Node_Str"";
case DISPATCH_PACKAGE_BROADCAST:
return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}",0.9828138654238276
181665,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
maybeSnapshot();
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
maybeSnapshot();
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
maybeSnapshot();
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
case SUICIDE:
Process.killProcess(Process.myPid());
break;
case REMOVE_PROVIDER:
completeRemoveProvider((IContentProvider)msg.obj);
break;
case ENABLE_JIT:
ensureJitEnabled();
break;
case DISPATCH_PACKAGE_BROADCAST:
handleDispatchPackageBroadcast(msg.arg1,(String[])msg.obj);
break;
}
}",0.9831479609032692
181666,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case DISPATCH_PACKAGE_BROADCAST_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int cmd=data.readInt();
String[] packages=data.readStringArray();
dispatchPackageBroadcast(cmd,packages);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9879739978331528
181667,"private void putCachedString(ResourceName name,CharSequence cs){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}","private void putCachedString(ResourceName name,CharSequence cs){
synchronized (sSync) {
    sStringCache.put(name,new WeakReference<CharSequence>(cs));
  }
}",0.8945868945868946
181668,"private void putCachedIcon(ResourceName name,Drawable dr){
  establishPackageRemovedReceiver();
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}","private void putCachedIcon(ResourceName name,Drawable dr){
synchronized (sSync) {
    sIconCache.put(name,new WeakReference<Drawable>(dr));
    if (DEBUG_ICONS)     Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ dr);
  }
}",0.9258517034068136
181669,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true);
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false,true,true);
            }
            if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction())) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp});
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return BROADCAST_SUCCESS;
    }
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    boolean replaced=false;
    if (replacePending) {
      for (int i=mParallelBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mParallelBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mParallelBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mParallelBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=false;
    if (replacePending) {
      for (int i=mOrderedBroadcasts.size() - 1; i >= 0; i--) {
        if (intent.filterEquals(mOrderedBroadcasts.get(i).intent)) {
          if (DEBUG_BROADCAST)           Slog.v(TAG,""String_Node_Str"" + intent);
          mOrderedBroadcasts.set(i,r);
          replaced=true;
          break;
        }
      }
    }
    if (!replaced) {
      mOrderedBroadcasts.add(r);
      scheduleBroadcastsLocked();
    }
  }
  return BROADCAST_SUCCESS;
}",0.9846069268829029
181670,"@Override protected void onRestoreInstanceState(Parcelable state){
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mYear=ss.getYear();
  mMonth=ss.getMonth();
  mDay=ss.getDay();
}","@Override protected void onRestoreInstanceState(Parcelable state){
  SavedState ss=(SavedState)state;
  super.onRestoreInstanceState(ss.getSuperState());
  mYear=ss.getYear();
  mMonth=ss.getMonth();
  mDay=ss.getDay();
  updateSpinners();
}",0.9567099567099568
181671,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}",0.985439173320808
181672,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}",0.985439173320808
181673,"private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null && (ps.pkgFlags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}","private void updateExternalMediaStatusInner(boolean mediaStatus,boolean reportStatus){
  int uidArr[]=null;
  HashSet<String> removeCids=new HashSet<String>();
  HashMap<SdInstallArgs,String> processCids=new HashMap<SdInstallArgs,String>();
  final String list[]=PackageHelper.getSecureContainerList();
  if (list == null || list.length == 0) {
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    int uidList[]=new int[list.length];
    int num=0;
synchronized (mPackages) {
      for (      String cid : list) {
        SdInstallArgs args=new SdInstallArgs(cid);
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + cid);
        String pkgName=args.getPackageName();
        if (pkgName == null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
          continue;
        }
        if (DEBUG_SD_INSTALL)         Log.i(TAG,""String_Node_Str"" + pkgName);
        PackageSetting ps=mSettings.mPackages.get(pkgName);
        if (ps != null && ps.codePathString != null) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ ps.codePathString);
          processCids.put(args,ps.codePathString);
          int uid=ps.userId;
          if (uid != -1) {
            uidList[num++]=uid;
          }
        }
 else {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
          removeCids.add(cid);
        }
      }
    }
    if (num > 0) {
      Arrays.sort(uidList,0,num);
      uidArr=new int[num];
      uidArr[0]=uidList[0];
      int di=0;
      for (int i=1; i < num; i++) {
        if (uidList[i - 1] != uidList[i]) {
          uidArr[di++]=uidList[i];
        }
      }
    }
  }
  if (mediaStatus) {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    loadMediaPackages(processCids,uidArr,removeCids);
    startCleaningPackages();
  }
 else {
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    unloadMediaPackages(processCids,uidArr,reportStatus);
  }
}",0.985439173320808
181674,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9052013422818792
181675,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9052013422818792
181676,"/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
if ((mCurrX == mFinalX) && (mCurrY == mFinalY)) {
mFinished=true;
}
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
if (mCurrX == mFinalX && mCurrY == mFinalY) {
mFinished=true;
}
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}","/** 
 * Call this when you want to know the new location.  If it returns true, the animation is not yet finished.  loc will be altered to provide the new location.
 */
public boolean computeScrollOffset(){
  if (mFinished) {
    return false;
  }
  int timePassed=(int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);
  if (timePassed < mDuration) {
switch (mMode) {
case SCROLL_MODE:
      float x=(float)timePassed * mDurationReciprocal;
    if (mInterpolator == null)     x=viscousFluid(x);
 else     x=mInterpolator.getInterpolation(x);
  mCurrX=mStartX + Math.round(x * mDeltaX);
mCurrY=mStartY + Math.round(x * mDeltaY);
break;
case FLING_MODE:
float timePassedSeconds=timePassed / 1000.0f;
float distance=(mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
mCurrX=mStartX + Math.round(distance * mCoeffX);
mCurrX=Math.min(mCurrX,mMaxX);
mCurrX=Math.max(mCurrX,mMinX);
mCurrY=mStartY + Math.round(distance * mCoeffY);
mCurrY=Math.min(mCurrY,mMaxY);
mCurrY=Math.max(mCurrY,mMinY);
break;
}
}
 else {
mCurrX=mFinalX;
mCurrY=mFinalY;
mFinished=true;
}
return true;
}",0.9052013422818792
181677,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.998890251737632
181678,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}",0.9986338797814208
181679,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9984977466199298
181680,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9957408652768438
181681,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}",0.9980988593155894
181682,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}",0.992863140218304
181683,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9982618771726536
181684,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}",0.9971988795518208
181685,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.998890251737632
181686,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}",0.9986338797814208
181687,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9984977466199298
181688,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9957408652768438
181689,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}",0.9980988593155894
181690,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}",0.992863140218304
181691,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9982618771726536
181692,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}",0.9971988795518208
181693,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.998890251737632
181694,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}",0.9986338797814208
181695,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9984977466199298
181696,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9957408652768438
181697,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}",0.9980988593155894
181698,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}",0.992863140218304
181699,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9982618771726536
181700,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}",0.9971988795518208
181701,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9989033189033188
181702,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      boolean oldOnSd=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (isForwardLocked(deletedPackage) ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldOnSd ? PackageParser.PARSE_ON_SDCARD : 0);
      int oldScanMode=(oldOnSd ? 0 : SCAN_MONITOR) | SCAN_UPDATE_SIGNATURE;
      if (scanPackageLI(restoreFile,oldParseFlags,oldScanMode) == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false,false);
        mSettings.writeLP();
      }
      Slog.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    }
  }
}",0.9986338797814208
181703,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9984977466199298
181704,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9957408652768438
181705,"private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true);
    mSettings.writeLP();
  }
  return true;
}","private boolean deleteSystemPackageLI(PackageParser.Package p,int flags,PackageRemovedInfo outInfo){
  ApplicationInfo applicationInfo=p.applicationInfo;
  if (applicationInfo == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str"");
    return false;
  }
  PackageSetting ps=null;
synchronized (mPackages) {
    ps=mSettings.getDisabledSystemPkg(p.packageName);
  }
  if (ps == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName);
    return false;
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  outInfo.isRemovedPackageSystemUpdate=true;
  boolean deleteCodeAndResources=false;
  if (ps.versionCode < p.mVersionCode) {
    deleteCodeAndResources=true;
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags&=~PackageManager.DONT_DELETE_DATA;
    }
  }
 else {
    if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
      flags|=PackageManager.DONT_DELETE_DATA;
    }
  }
  boolean ret=deleteInstalledPackageLI(p,deleteCodeAndResources,flags,outInfo);
  if (!ret) {
    return false;
  }
synchronized (mPackages) {
    mSettings.enableSystemPackageLP(p.packageName);
    removeNativeBinariesLI(p);
  }
  PackageParser.Package newPkg=scanPackageLI(ps.codePath,PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM,SCAN_MONITOR | SCAN_NO_PATHS);
  if (newPkg == null) {
    Slog.w(TAG,""String_Node_Str"" + p.packageName + ""String_Node_Str""+ mLastScanError);
    return false;
  }
synchronized (mPackages) {
    updatePermissionsLP(newPkg.packageName,newPkg,true,true,false);
    mSettings.writeLP();
  }
  return true;
}",0.9980988593155894
181706,"private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,false);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}","private void updatePermissionsLP(String changingPkg,PackageParser.Package pkgInfo,boolean grantPermissions,boolean replace,boolean replaceAll){
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage+ ""String_Node_Str""+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,""String_Node_Str"" + bp.name + ""String_Node_Str""+ bp.sourcePackage);
        grantPermissions=true;
        it.remove();
      }
    }
  }
  if (grantPermissions) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        grantPermissionsLP(pkg,replaceAll);
      }
    }
  }
  if (pkgInfo != null) {
    grantPermissionsLP(pkgInfo,replace);
  }
}",0.992863140218304
181707,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,(flags & REMOVE_CHATTY) != 0);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
  }
synchronized (mPackages) {
    if (deletedPs != null) {
      schedulePackageCleaning(packageName);
      if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
        if (outInfo != null) {
          outInfo.removedUid=mSettings.removePackageLP(packageName);
        }
        if (deletedPs != null) {
          updatePermissionsLP(deletedPs.name,null,false,false,false);
          if (deletedPs.sharedUser != null) {
            mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
          }
        }
      }
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.9983434566537824
181708,"private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}","private void updateSettingsLI(PackageParser.Package newPackage,String installerPackageName,PackageInstalledInfo res){
  String pkgName=newPackage.packageName;
synchronized (mPackages) {
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_INCOMPLETE);
    mSettings.writeLP();
  }
  if ((res.returnCode=moveDexFilesLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    return;
  }
  if ((res.returnCode=setPermissionsLI(newPackage)) != PackageManager.INSTALL_SUCCEEDED) {
    if (mInstaller != null) {
      mInstaller.rmdex(newPackage.mScanPath);
    }
    return;
  }
 else {
    Log.d(TAG,""String_Node_Str"" + newPackage.mPath);
  }
synchronized (mPackages) {
    updatePermissionsLP(newPackage.packageName,newPackage,newPackage.permissions.size() > 0,true,false);
    res.name=pkgName;
    res.uid=newPackage.applicationInfo.uid;
    res.pkg=newPackage;
    mSettings.setInstallStatus(pkgName,PKG_INSTALL_COMPLETE);
    mSettings.setInstallerPackageName(pkgName,installerPackageName);
    res.returnCode=PackageManager.INSTALL_SUCCEEDED;
    mSettings.writeLP();
  }
}",0.9971988795518208
181709,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}",0.5217391304347826
181710,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}",0.9452380952380952
181711,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.6613616268788682
181712,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}",0.9010654490106544
181713,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}",0.9794945159752028
181714,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.6016451233842538
181715,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.7763215377894277
181716,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}",0.9010654490106544
181717,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}",0.9794945159752028
181718,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.6016451233842538
181719,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.7763215377894277
181720,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}",0.9963693374040764
181721,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}",0.9963693374040764
181722,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}",0.9010654490106544
181723,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}",0.9794945159752028
181724,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.6016451233842538
181725,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.7763215377894277
181726,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}",0.5217391304347826
181727,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}",0.9452380952380952
181728,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.6613616268788682
181729,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + ""String_Node_Str"" + ev.getEventTime()+ ""String_Node_Str""+ mTouchMode);
  }
  int action;
  float x, y;
  long eventTime=ev.getEventTime();
  if (mSupportMultiTouch && ev.getPointerCount() > 1) {
    if (mMinZoomScale < mMaxZoomScale) {
      mScaleDetector.onTouchEvent(ev);
      if (mScaleDetector.isInProgress()) {
        mLastTouchTime=eventTime;
        return true;
      }
      x=mScaleDetector.getFocusX();
      y=mScaleDetector.getFocusY();
      action=ev.getAction() & MotionEvent.ACTION_MASK;
      if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action=MotionEvent.ACTION_DOWN;
      }
 else       if (action == MotionEvent.ACTION_POINTER_UP) {
        mLastTouchX=x;
        mLastTouchY=y;
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (x < 0 || y < 0) {
          return true;
        }
      }
    }
 else {
      return true;
    }
  }
 else {
    action=ev.getAction();
    x=ev.getX();
    y=ev.getY();
  }
  if (x > getViewWidth() - 1) {
    x=getViewWidth() - 1;
  }
  if (y > getViewHeightWithTitle() - 1) {
    y=getViewHeightWithTitle() - 1;
  }
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (!inFullScreenMode() && mShiftIsPressed) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        mTouchMode=TOUCH_SELECT_MODE;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,false);
        mTouchSelection=mExtendSelection=true;
        invalidate();
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mPreviewZoomOnly=false;
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mX=contentX;
          ted.mY=contentY;
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            ted.mViewX=x;
            ted.mViewY=y;
            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
            break;
          }
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (!inFullScreenMode()) {
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      mLastSentTouchTime=eventTime;
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mX=contentX;
      ted.mY=contentY;
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      if (mDeferTouchProcess) {
        ted.mViewX=x;
        ted.mViewY=y;
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
        break;
      }
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess+ ""String_Node_Str""+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mTouchMode != TOUCH_DRAG_MODE) {
      if (mTouchMode == TOUCH_SELECT_MODE) {
        mSelectX=mScrollX + (int)x;
        mSelectY=mScrollY + (int)y;
        if (DebugFlags.WEB_VIEW) {
          Log.v(LOGTAG,""String_Node_Str"" + mSelectX + ""String_Node_Str""+ mSelectY);
        }
        nativeMoveSelection(contentX,contentY,true);
        invalidate();
        break;
      }
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      int ax=Math.abs(deltaX);
      int ay=Math.abs(deltaY);
      if (ax > MAX_SLOPE_FOR_DIAG * ay) {
        mSnapScrollMode=SNAP_X;
        mSnapPositive=deltaX > 0;
      }
 else       if (ay > MAX_SLOPE_FOR_DIAG * ax) {
        mSnapScrollMode=SNAP_Y;
        mSnapPositive=deltaY > 0;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    int newScrollX=pinLocX(mScrollX + deltaX);
    int newDeltaX=newScrollX - mScrollX;
    if (deltaX != newDeltaX) {
      deltaX=newDeltaX;
      fDeltaX=(float)newDeltaX;
    }
    int newScrollY=pinLocY(mScrollY + deltaY);
    int newDeltaY=newScrollY - mScrollY;
    if (deltaY != newDeltaY) {
      deltaY=newDeltaY;
      fDeltaY=(float)newDeltaY;
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mX=contentX;
    ted.mY=contentY;
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    if (mDeferTouchProcess) {
      ted.mViewX=x;
      ted.mViewY=y;
    }
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mX=contentX;
  ted.mY=contentY;
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  if (mDeferTouchProcess) {
    ted.mViewX=x;
    ted.mViewY=y;
  }
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  doDoubleTap();
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_SELECT_MODE:
commitCopy();
mTouchSelection=false;
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,""String_Node_Str"" + ""String_Node_Str"");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
cancelWebCoreTouchEvent(contentX,contentY,true);
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mTouchMode == TOUCH_INIT_MODE) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + mPreventDefault + ""String_Node_Str""+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}",0.9963693374040764
181730,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}",0.5217391304347826
181731,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}",0.9452380952380952
181732,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.6613616268788682
181733,"void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      onVisibilityChanged(visible);
    }
  }
}","void reportVisibility(){
  if (!mDestroyed) {
    boolean visible=mVisible && mScreenOn;
    if (mReportedVisible != visible) {
      mReportedVisible=visible;
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + visible + ""String_Node_Str""+ this);
      if (visible) {
        updateSurface(false,false);
      }
      onVisibilityChanged(visible);
    }
  }
}",0.9010654490106544
181734,"void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
  final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
  final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
  final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
  final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
  onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}","void doOffsetsChanged(){
  if (mDestroyed) {
    return;
  }
  float xOffset;
  float yOffset;
  float xOffsetStep;
  float yOffsetStep;
  boolean sync;
synchronized (mLock) {
    xOffset=mPendingXOffset;
    yOffset=mPendingYOffset;
    xOffsetStep=mPendingXOffsetStep;
    yOffsetStep=mPendingYOffsetStep;
    sync=mPendingSync;
    mPendingSync=false;
    mOffsetMessageEnqueued=false;
  }
  if (mSurfaceCreated) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ xOffset+ ""String_Node_Str""+ yOffset);
    final int availw=mIWallpaperEngine.mReqWidth - mCurWidth;
    final int xPixels=availw > 0 ? -(int)(availw * xOffset + .5f) : 0;
    final int availh=mIWallpaperEngine.mReqHeight - mCurHeight;
    final int yPixels=availh > 0 ? -(int)(availh * yOffset + .5f) : 0;
    onOffsetsChanged(xOffset,yOffset,xOffsetStep,yOffsetStep,xPixels,yPixels);
  }
  if (sync) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"");
      mSession.wallpaperOffsetsComplete(mWindow.asBinder());
    }
 catch (    RemoteException e) {
    }
  }
}",0.9794945159752028
181735,"void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  reportSurfaceDestroyed();
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.getSurface() + ""String_Node_Str""+ this);
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.6016451233842538
181736,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.MATCH_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.MATCH_PARENT;
  final boolean creating=!mCreated;
  final boolean surfaceCreating=!mSurfaceCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || surfaceCreating|| formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
        mCreated=true;
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      if (!mSurfaceHolder.mSurface.isValid()) {
        reportSurfaceDestroyed();
        if (DEBUG)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      try {
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (surfaceCreating) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || surfaceCreating|| formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mSurfaceCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.7763215377894277
181737,"public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
}","public void onCompletion(MediaPlayer mp){
  if (mAudioManager != null) {
    mAudioManager.abandonAudioFocus(null);
  }
synchronized (mCmdQueue) {
    if (mCmdQueue.size() == 0) {
synchronized (mCompletionHandlingLock) {
        if (mLooper != null) {
          mLooper.quit();
        }
        mCompletionThread=null;
      }
    }
  }
}",0.5217391304347826
181738,"public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
mLooper.quit();
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}","public void run(){
  while (true) {
    Command cmd=null;
synchronized (mCmdQueue) {
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
      cmd=mCmdQueue.removeFirst();
    }
switch (cmd.code) {
case PLAY:
      if (mDebug)       Log.d(mTag,""String_Node_Str"");
    startSound(cmd);
  break;
case STOP:
if (mDebug) Log.d(mTag,""String_Node_Str"");
if (mPlayer != null) {
long delay=SystemClock.uptimeMillis() - cmd.requestTime;
if (delay > 1000) {
  Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
}
mPlayer.stop();
mPlayer.release();
mPlayer=null;
mAudioManager.abandonAudioFocus(null);
mAudioManager=null;
if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
  mLooper.quit();
}
}
 else {
Log.w(mTag,""String_Node_Str"");
}
break;
}
synchronized (mCmdQueue) {
if (mCmdQueue.size() == 0) {
mThread=null;
releaseWakeLock();
return;
}
}
}
}",0.9452380952380952
181739,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
synchronized (mCompletionHandlingLock) {
      if ((mLooper != null) && (mLooper.getThread().getState() != Thread.State.TERMINATED)) {
        mLooper.quit();
      }
      mCompletionThread=new CreationAndCompletionThread(cmd);
synchronized (mCompletionThread) {
        mCompletionThread.start();
        mCompletionThread.wait();
      }
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.6613616268788682
181740,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}",0.8528864059590316
181741,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}",0.8662952646239555
181742,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}",0.8606701940035273
181743,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}",0.9243697478991596
181744,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}",0.8528864059590316
181745,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}",0.8662952646239555
181746,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}",0.8606701940035273
181747,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}",0.9243697478991596
181748,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}",0.8528864059590316
181749,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}",0.8662952646239555
181750,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}",0.8606701940035273
181751,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}",0.9243697478991596
181752,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}",0.9212962962962964
181753,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.8162762022194822
181754,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}",0.9824970828471412
181755,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}",0.9279907084785134
181756,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9782439782439782
181757,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}",0.9212962962962964
181758,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.8162762022194822
181759,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}",0.9824970828471412
181760,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}",0.9279907084785134
181761,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9782439782439782
181762,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}",0.9333333333333332
181763,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}",0.966734902763562
181764,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.9509738079247816
181765,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9858079904591532
181766,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}",0.9333333333333332
181767,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}",0.9333333333333332
181768,"private void cancelA2dpDeviceTimeout(String address){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}","private void cancelA2dpDeviceTimeout(){
  mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
}",0.9333333333333332
181769,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}",0.966734902763562
181770,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.9509738079247816
181771,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9858079904591532
181772,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.9509738079247816
181773,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9858079904591532
181774,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        if (!app.killedBackground) {
          numHidden++;
          if (numHidden > MAX_HIDDEN_APPS) {
            Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
            app.killedBackground=true;
            Process.killProcess(app.pid);
          }
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.9509738079247816
181775,"void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  long now=SystemClock.uptimeMillis();
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(lastActivityTime);
  pw.print(""String_Node_Str"");
  pw.println(lruWeight);
  pw.print(""String_Node_Str"");
  pw.print(hidden);
  pw.print(""String_Node_Str"");
  pw.println(empty);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(curSchedGroup);
  pw.print(""String_Node_Str"");
  pw.println(setSchedGroup);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (killedBackground) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(killedBackground);
  }
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.print(bad);
    if (errorReportReceiver != null) {
      pw.print(""String_Node_Str"");
      pw.print(errorReportReceiver.flattenToShortString());
    }
    pw.println();
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9858079904591532
181776,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}",0.976464148877942
181777,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}",0.976464148877942
181778,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}",0.9996924969249692
181779,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}",0.966734902763562
181780,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}",0.9212962962962964
181781,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.8162762022194822
181782,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}",0.9824970828471412
181783,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}",0.9279907084785134
181784,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9782439782439782
181785,"boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mSurface != null && c.mAttachedHidden) {
        c.mAttachedHidden=false;
        c.performShowLocked();
        mLayoutNeeded=true;
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}","boolean performShowLocked(){
  if (DEBUG_VISIBILITY) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mReadyToShow+ ""String_Node_Str""+ isReadyForDisplay()+ ""String_Node_Str""+ (mAttrs.type == TYPE_APPLICATION_STARTING),e);
  }
  if (mReadyToShow && isReadyForDisplay()) {
    if (SHOW_TRANSACTIONS || DEBUG_ORIENTATION)     logSurface(this,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPolicyVisibility+ ""String_Node_Str""+ mAttachedHidden+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.hidden : false)+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ (mAppToken != null ? mAppToken.animating : false));
    if (!showSurfaceRobustlyLocked(this)) {
      return false;
    }
    mLastAlpha=-1;
    mHasDrawn=true;
    mLastHidden=false;
    mReadyToShow=false;
    enableScreenIfNeededLocked();
    applyEnterAnimationLocked(this);
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      if (c.mAttachedHidden) {
        c.mAttachedHidden=false;
        if (c.mSurface != null) {
          c.performShowLocked();
          mLayoutNeeded=true;
        }
      }
    }
    if (mAttrs.type != TYPE_APPLICATION_STARTING && mAppToken != null) {
      mAppToken.firstWindowDrawn=true;
      if (mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW || DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mToken + ""String_Node_Str"");
        if (mAnimation != null) {
          mAnimation=null;
          mAnimating=true;
        }
        mFinishedStarting.add(mAppToken);
        mH.sendEmptyMessage(H.FINISHED_STARTING);
      }
      mAppToken.updateReportedVisibilityLocked();
    }
  }
  return true;
}",0.966734902763562
181786,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}",0.9996924969249692
181787,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}",0.9996924969249692
181788,"void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}","void killAppAtUsersRequest(ProcessRecord app,Dialog fromDialog){
synchronized (this) {
    app.crashing=false;
    app.crashingReport=null;
    app.notResponding=false;
    app.notRespondingReport=null;
    if (app.anrDialog == fromDialog) {
      app.anrDialog=null;
    }
    if (app.waitDialog == fromDialog) {
      app.waitDialog=null;
    }
    if (app.pid > 0 && app.pid != MY_PID) {
      handleAppCrashLocked(app);
      Slog.i(ActivityManagerService.TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
      Process.killProcess(app.pid);
    }
  }
}",0.9212962962962964
181789,"private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}","private final boolean updateOomAdjLocked(){
  boolean didOomAdj=true;
  final HistoryRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,""String_Node_Str"" + TOP_ACT,e);
  }
  mAdjSeq++;
  int numSlots=HIDDEN_APP_MAX_ADJ - HIDDEN_APP_MIN_ADJ + 1;
  int factor=(mLruProcesses.size() - 4) / numSlots;
  if (factor < 1)   factor=1;
  int step=0;
  int numHidden=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=HIDDEN_APP_MIN_ADJ;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (updateOomAdjLocked(app,curHiddenAdj,TOP_APP)) {
      if (curHiddenAdj < EMPTY_APP_ADJ && app.curAdj == curHiddenAdj) {
        step++;
        if (step >= factor) {
          step=0;
          curHiddenAdj++;
        }
      }
      if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
        numHidden++;
        if (numHidden > MAX_HIDDEN_APPS) {
          Slog.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ app.pid+ ""String_Node_Str""+ numHidden+ ""String_Node_Str""+ MAX_HIDDEN_APPS);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,""String_Node_Str"");
          Process.killProcess(app.pid);
        }
      }
    }
 else {
      didOomAdj=false;
    }
  }
  return ENFORCE_PROCESS_LIMIT || mProcessLimit > 0 ? false : didOomAdj;
}",0.8162762022194822
181790,"public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ proc+ ""String_Node_Str""+ adj+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}","public boolean killPids(int[] pids,String pReason){
  if (Binder.getCallingUid() != Process.SYSTEM_UID) {
    throw new SecurityException(""String_Node_Str"");
  }
  String reason=(pReason == null) ? ""String_Node_Str"" : pReason;
  boolean killed=false;
synchronized (mPidsSelfLocked) {
    int[] types=new int[pids.length];
    int worstType=0;
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc != null) {
        int type=proc.setAdj;
        types[i]=type;
        if (type > worstType) {
          worstType=type;
        }
      }
    }
    if (worstType < EMPTY_APP_ADJ && worstType > HIDDEN_APP_MIN_ADJ) {
      worstType=HIDDEN_APP_MIN_ADJ;
    }
    Slog.w(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ worstType);
    for (int i=0; i < pids.length; i++) {
      ProcessRecord proc=mPidsSelfLocked.get(pids[i]);
      if (proc == null) {
        continue;
      }
      int adj=proc.setAdj;
      if (adj >= worstType) {
        Slog.w(TAG,""String_Node_Str"" + proc + ""String_Node_Str""+ adj+ ""String_Node_Str""+ reason);
        EventLog.writeEvent(EventLogTags.AM_KILL,proc.pid,proc.processName,adj,reason);
        killed=true;
        Process.killProcess(pids[i]);
      }
    }
  }
  return killed;
}",0.9824970828471412
181791,"private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}","private final void removeDyingProviderLocked(ProcessRecord proc,ContentProviderRecord cpr){
synchronized (cpr) {
    cpr.launchingApp=null;
    cpr.notifyAll();
  }
  mProvidersByClass.remove(cpr.info.name);
  String names[]=cpr.info.authority.split(""String_Node_Str"");
  for (int j=0; j < names.length; j++) {
    mProvidersByName.remove(names[j]);
  }
  Iterator<ProcessRecord> cit=cpr.clients.iterator();
  while (cit.hasNext()) {
    ProcessRecord capp=cit.next();
    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
      Slog.i(TAG,""String_Node_Str"" + capp.processName + ""String_Node_Str""+ capp.pid+ ""String_Node_Str""+ cpr.info.name+ ""String_Node_Str""+ proc.processName);
      EventLog.writeEvent(EventLogTags.AM_KILL,capp.pid,capp.processName,capp.setAdj,""String_Node_Str"" + proc.processName);
      Process.killProcess(capp.pid);
    }
  }
  mLaunchingProviders.remove(cpr);
}",0.9279907084785134
181792,"public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","public void setServiceForeground(ComponentName className,IBinder token,int id,Notification notification,boolean removeNotification){
  final long origId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ServiceRecord r=findServiceLocked(className,token);
      if (r != null) {
        if (id != 0) {
          if (notification == null) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          if (r.foregroundId != id) {
            r.cancelNotification();
            r.foregroundId=id;
          }
          notification.flags|=Notification.FLAG_FOREGROUND_SERVICE;
          r.foregroundNoti=notification;
          r.isForeground=true;
          r.postNotification();
          if (r.app != null) {
            updateServiceForegroundLocked(r.app,true);
          }
        }
 else {
          if (r.isForeground) {
            r.isForeground=false;
            if (r.app != null) {
              updateLruProcessLocked(r.app,false,true);
              updateServiceForegroundLocked(r.app,true);
            }
          }
          if (removeNotification) {
            r.cancelNotification();
            r.foregroundId=0;
            r.foregroundNoti=null;
          }
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9782439782439782
181793,"private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkExt || checkBoth && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}","private int recommendAppInstallLocation(int installLocation,String archiveFilePath,int flags){
  boolean checkInt=false;
  boolean checkExt=false;
  boolean checkBoth=false;
  check_inner: {
    if ((flags & PackageManager.INSTALL_FORWARD_LOCK) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_INTERNAL) != 0) {
      checkInt=true;
      break check_inner;
    }
 else     if ((flags & PackageManager.INSTALL_EXTERNAL) != 0) {
      checkExt=true;
      break check_inner;
    }
    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
      checkInt=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
      checkExt=true;
      checkBoth=true;
      break check_inner;
    }
 else     if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {
      checkInt=true;
      checkBoth=true;
      break check_inner;
    }
    int installPreference=Settings.System.getInt(getApplicationContext().getContentResolver(),Settings.Secure.DEFAULT_INSTALL_LOCATION,PackageHelper.APP_INSTALL_AUTO);
    if (installPreference == PackageHelper.APP_INSTALL_INTERNAL) {
      checkInt=true;
      break check_inner;
    }
 else     if (installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {
      checkExt=true;
      break check_inner;
    }
    checkInt=true;
  }
  String status=Environment.getExternalStorageState();
  long availSDSize=-1;
  boolean mediaAvailable=false;
  if (status.equals(Environment.MEDIA_MOUNTED)) {
    StatFs sdStats=new StatFs(Environment.getExternalStorageDirectory().getPath());
    availSDSize=(long)sdStats.getAvailableBlocks() * (long)sdStats.getBlockSize();
    mediaAvailable=true;
  }
  StatFs internalStats=new StatFs(Environment.getDataDirectory().getPath());
  long totalInternalSize=(long)internalStats.getBlockCount() * (long)internalStats.getBlockSize();
  long availInternalSize=(long)internalStats.getAvailableBlocks() * (long)internalStats.getBlockSize();
  double pctNandFree=(double)availInternalSize / (double)totalInternalSize;
  File apkFile=new File(archiveFilePath);
  long pkgLen=apkFile.length();
  long reqInstallSize=pkgLen;
  long reqInternalSize=0;
  boolean intThresholdOk=(pctNandFree >= LOW_NAND_FLASH_TRESHOLD);
  boolean intAvailOk=((reqInstallSize + reqInternalSize) < availInternalSize);
  boolean fitsOnSd=false;
  if (mediaAvailable && (reqInstallSize < availSDSize)) {
    if (reqInternalSize == 0) {
      fitsOnSd=true;
    }
 else     if ((reqInternalSize < availInternalSize) && intThresholdOk) {
      fitsOnSd=true;
    }
  }
  boolean fitsOnInt=intThresholdOk && intAvailOk;
  if (checkInt) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
  }
 else   if (checkExt) {
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if (checkBoth) {
    if (fitsOnInt) {
      return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
    }
    if (fitsOnSd) {
      return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
  }
  if ((checkExt || checkBoth) && !mediaAvailable) {
    return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
  }
  return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
}",0.9996924969249692
181794,"public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_CANCEL,listener));
  }
}","public void cancel(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_CANCEL,listener));
  }
}",0.8528864059590316
181795,"public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_START_LISTENING,new StartListeningArgs(recognizerIntent,listener)));
  }
}","public void startListening(Intent recognizerIntent,IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_START_LISTENING,mInternalService.new StartListeningArgs(recognizerIntent,listener)));
  }
}",0.8662952646239555
181796,"public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (checkPermissions(listener)) {
    mHandler.sendMessage(Message.obtain(mHandler,MSG_STOP_LISTENING,listener));
  }
}","public void stopListening(IRecognitionListener listener){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + listener.asBinder());
  if (mInternalService != null && mInternalService.checkPermissions(listener)) {
    mInternalService.mHandler.sendMessage(Message.obtain(mInternalService.mHandler,MSG_STOP_LISTENING,listener));
  }
}",0.8606701940035273
181797,"/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
}","/** 
 * Destroys the   {@code SpeechRecognizer} object.
 */
public void destroy(){
  if (mConnection != null) {
    mContext.unbindService(mConnection);
  }
  mPendingTasks.clear();
  mService=null;
  mConnection=null;
  mListener.mInternalListener=null;
}",0.9243697478991596
181798,"/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=true;
}","/** 
 * Try to parse this message as an email gateway message There are two ways specified in TS 23.040 Section 3.8 : - SMS message ""may have its TP-PID set for internet electronic mail - MT SMS format: [<from-address><space>]<message> - ""Depending on the nature of the gateway, the destination/origination address is either derived from the content of the SMS TP-OA or TP-DA field, or the TP-OA/TP-DA field contains a generic gateway address and the to/from address is added at the beginning as shown above."" (which is supported here) - Multiple addreses separated by commas, no spaces, Subject field delimited by '()' or '##' and '#' Section 9.2.3.24.11 (which are NOT supported here)
 */
protected void extractEmailAddressFromMessageBody(){
  String[] parts=messageBody.split(""String_Node_Str"",2);
  if (parts.length < 2)   return;
  emailFrom=parts[0];
  emailBody=parts[1];
  isEmail=Telephony.Mms.isEmailAddress(emailFrom);
}",0.976464148877942
181799,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}",0.9739696312364424
181800,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}",0.9739696312364424
181801,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}",0.9191919191919192
181802,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}",0.8694096601073346
181803,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}",0.8088888888888889
181804,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}",0.9369024856596558
181805,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}",0.9191919191919192
181806,"private void makeA2dpDeviceUnavailableLater(String address){
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}","private void makeA2dpDeviceUnavailableLater(String address){
  AudioSystem.setParameters(""String_Node_Str"");
  mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
  Message msg=mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT,address);
  mAudioHandler.sendMessageDelayed(msg,BTA2DP_DOCK_TIMEOUT_MILLIS);
}",0.9191919191919192
181807,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}",0.8694096601073346
181808,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}",0.8088888888888889
181809,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}",0.9369024856596558
181810,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}",0.8694096601073346
181811,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}",0.8088888888888889
181812,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}",0.9369024856596558
181813,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  mRingerModeMutedStreams=0;
  setRingerModeInt(getRingerMode(),false);
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  mBluetoothHeadsetConnected=false;
  mBluetoothHeadset=new BluetoothHeadset(context,mBluetoothHeadsetServiceListener);
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  intentFilter.addAction(Intent.ACTION_DOCK_EVENT);
  intentFilter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
  intentFilter=new IntentFilter(Intent.ACTION_MEDIA_BUTTON);
  intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
  context.registerReceiver(mMediaButtonReceiver,intentFilter);
}",0.9739696312364424
181814,"/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
}","/** 
 * This is called when the view is attached to a window.  At this point it has a Surface and will start drawing.  Note that this function is guaranteed to be called before   {@link #onDraw}, however it may be called any time before the first onDraw -- including before or after  {@link #onMeasure}.
 * @see #onDetachedFromWindow()
 */
protected void onAttachedToWindow(){
  if ((mPrivateFlags & REQUEST_TRANSPARENT_REGIONS) != 0) {
    mParent.requestTransparentRegion(this);
  }
  if ((mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
    initialAwakenScrollBars();
    mPrivateFlags&=~AWAKEN_SCROLL_BARS_ON_ATTACH;
  }
}",0.8694096601073346
181815,"/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
}","/** 
 * Called when the visibility of the view or an ancestor of the view is changed.
 * @param changedView The view whose visibility changed. Could be 'this' oran ancestor view.
 * @param visibility The new visibility of changedView: {@link #VISIBLE},  {@link #INVISIBLE} or {@link #GONE}.
 */
protected void onVisibilityChanged(View changedView,int visibility){
  if (visibility == VISIBLE) {
    if (mAttachInfo != null) {
      initialAwakenScrollBars();
    }
 else {
      mPrivateFlags|=AWAKEN_SCROLL_BARS_ON_ATTACH;
    }
  }
}",0.8088888888888889
181816,"/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
}","/** 
 * Called when the window containing has change its visibility (between   {@link #GONE},   {@link #INVISIBLE}, and   {@link #VISIBLE}).  Note that this tells you whether or not your window is being made visible to the window manager; this does <em>not</em> tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.
 * @param visibility The new visibility of the window.
 */
protected void onWindowVisibilityChanged(int visibility){
  if (visibility == VISIBLE) {
    initialAwakenScrollBars();
  }
}",0.9369024856596558
181817,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.9544008483563096
181818,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.9544008483563096
181819,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.9544008483563096
181820,"private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    mPlayer.setOnCompletionListener(this);
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}","private void startSound(Command cmd){
  try {
    if (mDebug)     Log.d(mTag,""String_Node_Str"");
    PlayerCreationThread t=new PlayerCreationThread(cmd);
synchronized (t) {
      t.start();
      t.wait();
    }
    long delay=SystemClock.uptimeMillis() - cmd.requestTime;
    if (delay > 1000) {
      Log.w(mTag,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.w(mTag,""String_Node_Str"" + cmd.uri,e);
  }
}",0.9544008483563096
181821,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}",0.9563327405651058
181822,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}",0.9563327405651058
181823,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}",0.9563327405651058
181824,"/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (r.frontOfTask && index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      next.frontOfTask=true;
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}","/** 
 * @return Returns true if this activity has been removed from the historylist, or false if it is still in the list and will be removed later.
 */
private final boolean finishActivityLocked(HistoryRecord r,int index,int resultCode,Intent resultData,String reason){
  if (r.finishing) {
    Slog.w(TAG,""String_Node_Str"" + r);
    return false;
  }
  r.finishing=true;
  EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName,reason);
  r.task.numActivities--;
  if (index < (mHistory.size() - 1)) {
    HistoryRecord next=(HistoryRecord)mHistory.get(index + 1);
    if (next.task == r.task) {
      if (r.frontOfTask) {
        next.frontOfTask=true;
      }
      if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
        next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
      }
    }
  }
  r.pauseKeyDispatchingLocked();
  if (mFocusedActivity == r) {
    setFocusedActivityLocked(topRunningActivityLocked(null));
  }
  HistoryRecord resultTo=r.resultTo;
  if (resultTo != null) {
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ r.resultWho+ ""String_Node_Str""+ r.requestCode+ ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
    if (r.info.applicationInfo.uid > 0) {
      grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,r.packageName,resultData,r);
    }
    resultTo.addResultLocked(r,r.resultWho,r.requestCode,resultCode,resultData);
    r.resultTo=null;
  }
 else   if (DEBUG_RESULTS)   Slog.v(TAG,""String_Node_Str"" + r);
  r.results=null;
  r.pendingResults=null;
  r.newIntents=null;
  r.icicle=null;
  if (mPendingThumbnails.size() > 0) {
    mCancelledThumbnails.add(r);
  }
  if (mResumedActivity == r) {
    boolean endTask=index <= 0 || ((HistoryRecord)mHistory.get(index - 1)).task != r.task;
    if (DEBUG_TRANSITION)     Slog.v(TAG,""String_Node_Str"" + r);
    mWindowManager.prepareAppTransition(endTask ? WindowManagerPolicy.TRANSIT_TASK_CLOSE : WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE);
    mWindowManager.setAppVisibility(r,false);
    if (mPausingActivity == null) {
      if (DEBUG_PAUSE)       Slog.v(TAG,""String_Node_Str"" + r);
      if (DEBUG_USER_LEAVING)       Slog.v(TAG,""String_Node_Str"");
      startPausingLocked(false,false);
    }
  }
 else   if (r.state != ActivityState.PAUSING) {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
    return finishCurrentActivityLocked(r,index,FINISH_AFTER_PAUSE) == null;
  }
 else {
    if (DEBUG_PAUSE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  return false;
}",0.9563327405651058
181825,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}",0.8657560056523788
181826,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}",0.8657560056523788
181827,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}",0.9748462828395752
181828,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9967628430682618
181829,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9967628430682618
181830,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    if (index != 0) {
      streamState.setLastAudibleIndex(index);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}",0.8657560056523788
181831,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}",0.9748462828395752
181832,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}",0.7680391357521402
181833,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}",0.9748462828395752
181834,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9961342198855728
181835,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9882253994953742
181836,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}",0.718475073313783
181837,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}",0.9781931464174456
181838,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}",0.7680391357521402
181839,"/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}","/** 
 * Checks if the adjustment should change ringer mode instead of just adjusting volume. If so, this will set the proper ringer mode and volume indices on the stream states.
 */
private boolean checkForRingerModeChange(int oldIndex,int direction){
  boolean adjustVolumeIndex=true;
  int newRingerMode=mRingerMode;
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    if (direction == AudioManager.ADJUST_LOWER && (oldIndex + 5) / 10 == 1) {
      newRingerMode=System.getInt(mContentResolver,System.VIBRATE_IN_SILENT,1) == 1 ? AudioManager.RINGER_MODE_VIBRATE : AudioManager.RINGER_MODE_SILENT;
    }
  }
 else {
    if (direction == AudioManager.ADJUST_RAISE) {
      newRingerMode=AudioManager.RINGER_MODE_NORMAL;
    }
 else {
      adjustVolumeIndex=false;
    }
  }
  if (newRingerMode != mRingerMode) {
    setRingerMode(newRingerMode);
    adjustVolumeIndex=false;
  }
  return adjustVolumeIndex;
}",0.9748462828395752
181840,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}",0.7680391357521402
181841,"public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}","public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum,int flags){
synchronized (this) {
    enforceCallingPermission(android.Manifest.permission.GET_TASKS,""String_Node_Str"");
    IPackageManager pm=ActivityThread.getPackageManager();
    final int N=mRecentTasks.size();
    ArrayList<ActivityManager.RecentTaskInfo> res=new ArrayList<ActivityManager.RecentTaskInfo>(maxNum < N ? maxNum : N);
    for (int i=0; i < N && maxNum > 0; i++) {
      TaskRecord tr=mRecentTasks.get(i);
      if (((flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0) || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
        ActivityManager.RecentTaskInfo rti=new ActivityManager.RecentTaskInfo();
        rti.id=tr.numActivities > 0 ? tr.taskId : -1;
        rti.baseIntent=new Intent(tr.intent != null ? tr.intent : tr.affinityIntent);
        rti.origActivity=tr.origActivity;
        if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0) {
          try {
            if (rti.origActivity != null) {
              if (pm.getActivityInfo(rti.origActivity,0) == null) {
                continue;
              }
            }
 else             if (rti.baseIntent != null) {
              if (pm.queryIntentActivities(rti.baseIntent,null,0) == null) {
                continue;
              }
            }
          }
 catch (          RemoteException e) {
          }
        }
        res.add(rti);
        maxNum--;
      }
    }
    return res;
  }
}",0.7680391357521402
181842,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9961342198855728
181843,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9882253994953742
181844,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}",0.718475073313783
181845,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}",0.9781931464174456
181846,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9967628430682618
181847,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9961342198855728
181848,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9882253994953742
181849,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}",0.718475073313783
181850,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}",0.9781931464174456
181851,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}",0.9788672865595942
181852,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.5358361774744027
181853,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9755387303436226
181854,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.5358361774744027
181855,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9755387303436226
181856,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}",0.9788672865595942
181857,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + w.mRootToken.waitingToShow + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ w.mRootToken.hidden+ ""String_Node_Str""+ w.mViewVisibility);
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9961342198855728
181858,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.mObscured && (w.mOrientationChanging || !w.isDrawnLw())) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Slog.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Slog.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Slog.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9882253994953742
181859,"/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && !mDrawPending && !mCommitDrawPending;
}","/** 
 * Returns true if the window has a surface that it has drawn a complete UI in to.  Note that this returns true if the orientation is changing even if the window hasn't redrawn because we don't want to stop things from executing during that time.
 */
public boolean isDrawnLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mDestroying && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending));
}",0.718475073313783
181860,"/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && !mDrawPending && !mCommitDrawPending && !mExiting && !mDestroying;
}","/** 
 * Like   {@link #isVisibleLw}, but also counts a window that is currently ""hidden"" behind the keyguard as visible.  This allows us to apply things like window flags that impact the keyguard. XXX I am starting to think we need to have ANOTHER visibility flag for this ""hidden behind keyguard"" state rather than overloading mPolicyVisibility.  Ungh.
 */
public boolean isVisibleOrBehindKeyguardLw(){
  final AppWindowToken atoken=mAppToken;
  return mSurface != null && !mAttachedHidden && (atoken == null ? mPolicyVisibility : !atoken.hiddenRequested) && (mOrientationChanging || (!mDrawPending && !mCommitDrawPending)) && !mExiting && !mDestroying;
}",0.9781931464174456
181861,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.5358361774744027
181862,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9755387303436226
181863,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}",0.9788672865595942
181864,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.5358361774744027
181865,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9755387303436226
181866,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.5358361774744027
181867,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
case MSG_BTA2DP_DOCK_TIMEOUT:
makeA2dpDeviceUnavailableNow((String)msg.obj);
break;
}
}",0.9755387303436226
181868,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}",0.9788672865595942
181869,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9407783417935702
181870,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}",0.8497854077253219
181871,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9407783417935702
181872,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}",0.8497854077253219
181873,"private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadIntegerSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,30 * 60 * 1000);
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}","private void upgradeScreenTimeoutFromNever(SQLiteDatabase db){
  Cursor c=db.query(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",new String[]{Settings.System.SCREEN_OFF_TIMEOUT,""String_Node_Str""},null,null,null);
  SQLiteStatement stmt=null;
  if (c.getCount() > 0) {
    c.close();
    try {
      stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.SCREEN_OFF_TIMEOUT,Integer.toString(30 * 60 * 1000));
    }
  finally {
      if (stmt != null)       stmt.close();
    }
  }
 else {
    c.close();
  }
}",0.9788672865595942
181874,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9407783417935702
181875,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}",0.8497854077253219
181876,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)&& !mMimeType.equalsIgnoreCase(""String_Node_Str"")) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    ce.mListener=this;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9967628430682618
181877,"/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  removeFocusStackEntry(clientId,true);
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#abandonAudioFocus(IAudioFocusDispatcher) 
 */
public int abandonAudioFocus(IAudioFocusDispatcher fl,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,true);
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9407783417935702
181878,"public void unregisterAudioFocusClient(String clientId){
  removeFocusStackEntry(clientId,false);
}","public void unregisterAudioFocusClient(String clientId){
synchronized (mFocusStack) {
    removeFocusStackEntry(clientId,false);
  }
}",0.8497854077253219
181879,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}",0.9969001859888408
181880,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}",0.9563409563409564
181881,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}",0.9954940457032508
181882,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}",0.9825083736509118
181883,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}",0.9969001859888408
181884,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}",0.9563409563409564
181885,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}",0.9954940457032508
181886,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}",0.9825083736509118
181887,"/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode,true);
}","/** 
 * Something in the current window tells us we need to change the touch mode.  For example, we are not in touch mode, and the user touches the screen. If the touch mode has changed, tell the window manager, and handle it locally.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
boolean ensureTouchMode(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  try {
    sWindowSession.setInTouchMode(inTouchMode);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
  return ensureTouchModeLocally(inTouchMode);
}",0.9969001859888408
181888,"/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @param dispatchFocus
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode,boolean dispatchFocus){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return dispatchFocus && (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}","/** 
 * Ensure that the touch mode for this window is set, and if it is changing, take the appropriate action.
 * @param inTouchMode Whether we want to be in touch mode.
 * @return True if the touch mode changed and focus changed was changed as a result
 */
private boolean ensureTouchModeLocally(boolean inTouchMode){
  if (DBG)   Log.d(""String_Node_Str"",""String_Node_Str"" + inTouchMode + ""String_Node_Str""+ ""String_Node_Str""+ mAttachInfo.mInTouchMode);
  if (mAttachInfo.mInTouchMode == inTouchMode)   return false;
  mAttachInfo.mInTouchMode=inTouchMode;
  mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
  return (inTouchMode) ? enterTouchMode() : leaveTouchMode();
}",0.9563409563409564
181889,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode,false);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0,true);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (mFirst) {
      if (mAddedTouchMode) {
        enterTouchMode();
      }
 else {
        leaveTouchMode();
      }
    }
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mTraversalScheduled=false;
  mWillDrawSoon=true;
  boolean windowResizesToFitContent=false;
  boolean fullRedrawNeeded=mFullRedrawNeeded;
  boolean newSurface=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  int childWidthMeasureSpec;
  int childHeightMeasureSpec;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  float appScale=mAttachInfo.mApplicationScale;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    params=lp;
  }
  Rect frame=mWinFrame;
  if (mFirst) {
    fullRedrawNeeded=true;
    mLayoutRequested=true;
    DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
    desiredWindowWidth=packageMetrics.widthPixels;
    desiredWindowHeight=packageMetrics.heightPixels;
    attachInfo.mSurface=mSurface;
    attachInfo.mTranslucentWindow=lp.format != PixelFormat.OPAQUE;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mKeepScreenOn=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    host.dispatchAttachedToWindow(attachInfo,0);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      fullRedrawNeeded=true;
      mLayoutRequested=true;
      windowResizesToFitContent=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      if (mUseGL) {
        destroyGL();
      }
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  boolean insetsChanged=false;
  if (mLayoutRequested) {
    getRunQueue().executeActions(attachInfo.mHandler);
    if (mFirst) {
      host.fitSystemWindows(mAttachInfo.mContentInsets);
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        insetsChanged=true;
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowResizesToFitContent=true;
        DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
        desiredWindowWidth=packageMetrics.widthPixels;
        desiredWindowHeight=packageMetrics.heightPixels;
      }
    }
    childWidthMeasureSpec=getRootMeasureSpec(desiredWindowWidth,lp.width);
    childHeightMeasureSpec=getRootMeasureSpec(desiredWindowHeight,lp.height);
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ desiredWindowWidth+ ""String_Node_Str""+ desiredWindowHeight+ ""String_Node_Str"");
    host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (attachInfo.mRecomputeGlobalAttributes) {
    attachInfo.mRecomputeGlobalAttributes=false;
    boolean oldVal=attachInfo.mKeepScreenOn;
    attachInfo.mKeepScreenOn=false;
    host.dispatchCollectViewAttributes(0);
    if (attachInfo.mKeepScreenOn != oldVal) {
      params=lp;
    }
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  boolean windowShouldResize=mLayoutRequested && windowResizesToFitContent && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
      if (mWindowAttributes.memoryType == WindowManager.LayoutParams.MEMORY_TYPE_GPU) {
        if (params == null) {
          params=mWindowAttributes;
        }
        mGlWanted=true;
      }
    }
    boolean initialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    try {
      boolean hadSurface=mSurface.isValid();
      int fl=0;
      if (params != null) {
        fl=params.flags;
        if (attachInfo.mKeepScreenOn) {
          params.flags|=WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        }
      }
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.mMeasuredWidth + ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ params);
      }
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (params != null) {
        params.flags=fl;
      }
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        host.fitSystemWindows(mAttachInfo.mContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          fullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mGlWanted && !mUseGL) {
            initializeGL();
            initialized=mGlCanvas != null;
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(""String_Node_Str"",""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    mWidth=frame.width();
    mHeight=frame.height();
    if (initialized) {
      mGlCanvas.setViewport((int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
    }
    boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
    if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
      childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
      childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str""+ contentInsetsChanged);
      host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      int width=host.mMeasuredWidth;
      int height=host.mMeasuredHeight;
      boolean measureAgain=false;
      if (lp.horizontalWeight > 0.0f) {
        width+=(int)((mWidth - width) * lp.horizontalWeight);
        childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (lp.verticalWeight > 0.0f) {
        height+=(int)((mHeight - height) * lp.verticalWeight);
        childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
        measureAgain=true;
      }
      if (measureAgain) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
        host.measure(childWidthMeasureSpec,childHeightMeasureSpec);
      }
      mLayoutRequested=true;
    }
  }
  final boolean didLayout=mLayoutRequested;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    mLayoutRequested=false;
    mScrollMayChange=true;
    if (DEBUG_ORIENTATION || DEBUG_LAYOUT)     Log.v(""String_Node_Str"",""String_Node_Str"" + host + ""String_Node_Str""+ host.mMeasuredWidth+ ""String_Node_Str""+ host.mMeasuredHeight+ ""String_Node_Str"");
    long startTime=0L;
    if (Config.DEBUG && ViewDebug.profileLayout) {
      startTime=SystemClock.elapsedRealtime();
    }
    host.layout(0,0,host.mMeasuredWidth,host.mMeasuredHeight);
    if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
      if (!host.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_LAYOUT)) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ViewDebug.CONSISTENCY_LOG_TAG + ""String_Node_Str"");
      }
    }
    if (Config.DEBUG && ViewDebug.profileLayout) {
      EventLog.writeEvent(60001,SystemClock.elapsedRealtime() - startTime);
    }
    if ((host.mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          sWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    final Rect givenContent=attachInfo.mGivenInternalInsets.contentInsets;
    final Rect givenVisible=attachInfo.mGivenInternalInsets.visibleInsets;
    givenContent.left=givenContent.top=givenContent.right=givenContent.bottom=givenVisible.left=givenVisible.top=givenVisible.right=givenVisible.bottom=0;
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    Rect contentInsets=insets.contentInsets;
    Rect visibleInsets=insets.visibleInsets;
    if (mTranslator != null) {
      contentInsets=mTranslator.getTranslatedContentInsets(contentInsets);
      visibleInsets=mTranslator.getTranslatedVisbileInsets(visibleInsets);
    }
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      try {
        sWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw();
  if (!cancelDraw && !newSurface) {
    mFullRedrawNeeded=false;
    draw(fullRedrawNeeded);
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0 || mReportNextDraw) {
      if (LOCAL_LOGV) {
        Log.v(""String_Node_Str"",""String_Node_Str"" + mWindowAttributes.getTitle());
      }
      mReportNextDraw=false;
      try {
        sWindowSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
 else {
    if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
      mReportNextDraw=true;
    }
    if (fullRedrawNeeded) {
      mFullRedrawNeeded=true;
    }
    scheduleTraversals();
  }
}",0.9954940457032508
181890,"/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused()) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}","/** 
 * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
public boolean executeKeyEvent(KeyEvent event){
  mTempRect.setEmpty();
  if (!canScroll()) {
    if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
      View currentFocused=findFocus();
      if (currentFocused == this)       currentFocused=null;
      View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,View.FOCUS_DOWN);
      return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
    }
    return false;
  }
  boolean handled=false;
  if (event.getAction() == KeyEvent.ACTION_DOWN) {
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_UP:
      if (!event.isAltPressed()) {
        handled=arrowScroll(View.FOCUS_UP);
      }
 else {
        handled=fullScroll(View.FOCUS_UP);
      }
    break;
case KeyEvent.KEYCODE_DPAD_DOWN:
  if (!event.isAltPressed()) {
    handled=arrowScroll(View.FOCUS_DOWN);
  }
 else {
    handled=fullScroll(View.FOCUS_DOWN);
  }
break;
case KeyEvent.KEYCODE_SPACE:
pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
break;
}
}
return handled;
}",0.9825083736509118
181891,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}",0.9567474048442908
181892,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}",0.9990124432154848
181893,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9974861739567622
181894,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9988876529477196
181895,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}",0.8961702127659574
181896,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}",0.9986446191379778
181897,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.932088285229202
181898,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}",0.9963262307127112
181899,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}",0.9987911025145068
181900,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}",0.9901574803149606
181901,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}",0.997511199601792
181902,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}",0.9567474048442908
181903,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}",0.9990124432154848
181904,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9974861739567622
181905,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9988876529477196
181906,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}",0.8961702127659574
181907,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}",0.9986446191379778
181908,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.932088285229202
181909,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}",0.9963262307127112
181910,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}",0.9987911025145068
181911,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}",0.9901574803149606
181912,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}",0.997511199601792
181913,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}",0.9567474048442908
181914,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}",0.9990124432154848
181915,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9974861739567622
181916,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9988876529477196
181917,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}",0.8961702127659574
181918,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}",0.9986446191379778
181919,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.932088285229202
181920,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}",0.9963262307127112
181921,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}",0.9987911025145068
181922,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}",0.9901574803149606
181923,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}",0.997511199601792
181924,"private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[]){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras);
  }
}","private void sendResourcesChangedBroadcast(boolean mediaStatus,ArrayList<String> pkgList,int uidArr[],IIntentReceiver finishedReceiver){
  int size=pkgList.size();
  if (size > 0) {
    Bundle extras=new Bundle();
    extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST,pkgList.toArray(new String[size]));
    if (uidArr != null) {
      extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST,uidArr);
    }
    String action=mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
    sendPackageBroadcast(action,null,extras,finishedReceiver);
  }
}",0.9567474048442908
181925,"void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}","void doHandleMessage(Message msg){
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_SD_INSTALL)       Log.i(TAG,""String_Node_Str"" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,""String_Node_Str"");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        params.startCopy();
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,""String_Node_Str"");
      for (      HandlerParams params : mPendingInstalls) {
        mPendingInstalls.remove(0);
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
if (mPendingInstalls.size() > 0) {
  mPendingInstalls.remove(0);
}
if (mPendingInstalls.size() == 0) {
  if (mBound) {
    disconnectService();
  }
}
 else {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,""String_Node_Str"");
HandlerParams params=mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
HashMap.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.userId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
mSettings.mPackagesToBeCleaned.add(packageName);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,""String_Node_Str"" + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,""String_Node_Str"");
}
}
}
 else {
Slog.e(TAG,""String_Node_Str"" + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
try {
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"");
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
mSettings.writeLP();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
}
}",0.9990124432154848
181926,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras,null);
  }
}",0.9974861739567622
181927,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9988876529477196
181928,"private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr);
  }
  Runtime.getRuntime().gc();
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}","private void unloadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[]){
  if (DEBUG_SD_INSTALL)   Log.i(TAG,""String_Node_Str"");
  ArrayList<String> pkgList=new ArrayList<String>();
  ArrayList<SdInstallArgs> failedList=new ArrayList<SdInstallArgs>();
  Set<SdInstallArgs> keys=processCids.keySet();
  for (  SdInstallArgs args : keys) {
    String cid=args.cid;
    String pkgName=args.getPackageName();
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PackageRemovedInfo outInfo=new PackageRemovedInfo();
synchronized (mInstallLock) {
      boolean res=deletePackageLI(pkgName,false,PackageManager.DONT_DELETE_DATA,outInfo);
      if (res) {
        pkgList.add(pkgName);
      }
 else {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        failedList.add(args);
      }
    }
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(false,pkgList,uidArr,new IIntentReceiver.Stub(){
      public void performReceive(      Intent intent,      int resultCode,      String data,      Bundle extras,      boolean ordered,      boolean sticky) throws RemoteException {
        Runtime.getRuntime().gc();
      }
    }
);
  }
  for (  SdInstallArgs args : keys) {
synchronized (mInstallLock) {
      args.doPostDeleteLI(false);
    }
  }
}",0.8961702127659574
181929,"public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}","public void run(){
  mHandler.removeCallbacks(this);
  int returnCode=currentStatus;
  if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
    int uidArr[]=null;
    ArrayList<String> pkgList=null;
synchronized (mPackages) {
      PackageParser.Package pkg=mPackages.get(mp.packageName);
      if (pkg == null) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
      }
 else       if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
        Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
        returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
      }
 else {
        uidArr=new int[]{pkg.applicationInfo.uid};
        pkgList=new ArrayList<String>();
        pkgList.add(mp.packageName);
      }
    }
    if (returnCode == PackageManager.MOVE_SUCCEEDED) {
      sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            String oldCodePath=pkg.mPath;
            String newCodePath=mp.targetArgs.getCodePath();
            String newResPath=mp.targetArgs.getResourcePath();
            pkg.mPath=newCodePath;
            if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
              pkg.mPath=pkg.mScanPath;
              returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
            }
 else {
              pkg.mScanPath=newCodePath;
              pkg.applicationInfo.sourceDir=newCodePath;
              pkg.applicationInfo.publicSourceDir=newResPath;
              PackageSetting ps=(PackageSetting)pkg.mExtras;
              ps.codePath=new File(pkg.applicationInfo.sourceDir);
              ps.codePathString=ps.codePath.getPath();
              ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
              ps.resourcePathString=ps.resourcePath.getPath();
              if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
 else {
                pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
              }
              ps.setFlags(pkg.applicationInfo.flags);
              mAppDirs.remove(oldCodePath);
              mAppDirs.put(newCodePath,pkg);
              mSettings.writeLP();
            }
          }
        }
        sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
      }
    }
  }
  if (returnCode != PackageManager.MOVE_SUCCEEDED) {
    if (mp.targetArgs != null) {
      mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
    }
  }
 else {
    Runtime.getRuntime().gc();
synchronized (mInstallLock) {
      mp.srcArgs.doPostDeleteLI(true);
    }
  }
  IPackageMoveObserver observer=mp.observer;
  if (observer != null) {
    try {
      observer.packageMoved(mp.packageName,returnCode);
    }
 catch (    RemoteException e) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
}",0.9986446191379778
181930,"private static final void sendPackageBroadcast(String action,String pkg,Bundle extras){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,null,0,null,null,null,false,false);
    }
 catch (    RemoteException ex) {
    }
  }
}","private static final void sendPackageBroadcast(String action,String pkg,Bundle extras,IIntentReceiver finishedReceiver){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am != null) {
    try {
      final Intent intent=new Intent(action,pkg != null ? Uri.fromParts(""String_Node_Str"",pkg,null) : null);
      if (extras != null) {
        intent.putExtras(extras);
      }
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      am.broadcastIntent(null,intent,null,finishedReceiver,0,null,null,null,finishedReceiver != null,false);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.932088285229202
181931,"private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras);
}","private void sendPackageChangedBroadcast(String packageName,boolean killFlag,ArrayList<String> componentNames,int packageUid){
  if (false)   Log.v(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ componentNames);
  Bundle extras=new Bundle(4);
  extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME,componentNames.get(0));
  String nameList[]=new String[componentNames.size()];
  componentNames.toArray(nameList);
  extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST,nameList);
  extras.putBoolean(Intent.EXTRA_DONT_KILL_APP,killFlag);
  extras.putInt(Intent.EXTRA_UID,packageUid);
  sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED,packageName,extras,null);
}",0.9963262307127112
181932,"private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}","private void processPendingMove(final MoveParams mp,final int currentStatus){
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,""String_Node_Str"" + mp.packageName + ""String_Node_Str""+ mp.srcArgs.getCodePath()+ ""String_Node_Str""+ pkg.applicationInfo.sourceDir+ ""String_Node_Str"");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                String oldCodePath=pkg.mPath;
                String newCodePath=mp.targetArgs.getCodePath();
                String newResPath=mp.targetArgs.getResourcePath();
                pkg.mPath=newCodePath;
                if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                  pkg.mPath=pkg.mScanPath;
                  returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                }
 else {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLP();
                }
              }
            }
            sendResourcesChangedBroadcast(true,pkgList,uidArr,null);
          }
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,""String_Node_Str"");
        }
      }
    }
  }
);
}",0.9987911025145068
181933,"void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras);
  }
}","void sendBroadcast(boolean fullRemove,boolean replacing){
  Bundle extras=new Bundle(1);
  extras.putInt(Intent.EXTRA_UID,removedUid >= 0 ? removedUid : uid);
  extras.putBoolean(Intent.EXTRA_DATA_REMOVED,fullRemove);
  if (replacing) {
    extras.putBoolean(Intent.EXTRA_REPLACING,true);
  }
  if (removedPackage != null) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras,null);
  }
  if (removedUid >= 0) {
    sendPackageBroadcast(Intent.ACTION_UID_REMOVED,null,extras,null);
  }
}",0.9901574803149606
181934,"/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}","/** 
 * This method is an internal method that could be get invoked either to delete an installed package or to clean up a failed installation. After deleting an installed package, a broadcast is sent to notify any listeners that the package has been installed. For cleaning up a failed installation, the broadcast is not necessary since the package's installation wouldn't have sent the initial broadcast either The key steps in deleting a package are deleting the package information in internal structures like mPackages, deleting the packages base directories through installd updating mSettings to reflect current status persisting settings for later use sending a broadcast if necessary
 */
private boolean deletePackageX(String packageName,boolean sendBroadCast,boolean deleteCodeAndResources,int flags){
  PackageRemovedInfo info=new PackageRemovedInfo();
  boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str"");
      return false;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags,info);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res;
}",0.997511199601792
181935,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}",0.99601593625498
181936,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}",0.99601593625498
181937,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}",0.99601593625498
181938,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}",0.99601593625498
181939,"private static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}","static final void dumpApplicationMemoryUsage(FileDescriptor fd,PrintWriter pw,List list,String prefix,String[] args){
  final boolean isCheckinRequest=scanArgs(args,""String_Node_Str"");
  long uptime=SystemClock.uptimeMillis();
  long realtime=SystemClock.elapsedRealtime();
  if (isCheckinRequest) {
    pw.println(uptime + ""String_Node_Str"" + realtime);
    pw.flush();
  }
 else {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + uptime + ""String_Node_Str""+ realtime);
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    ProcessRecord r=(ProcessRecord)list.get(i);
    if (r.thread != null) {
      if (!isCheckinRequest) {
        pw.println(""String_Node_Str"" + r.pid + ""String_Node_Str""+ r.processName+ ""String_Node_Str"");
        pw.flush();
      }
      try {
        r.thread.asBinder().dump(fd,args);
      }
 catch (      RemoteException e) {
        if (!isCheckinRequest) {
          pw.println(""String_Node_Str"");
          pw.flush();
        }
      }
    }
  }
}",0.99601593625498
181940,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}",0.9448529411764706
181941,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}",0.9448529411764706
181942,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}",0.9448529411764706
181943,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}",0.9448529411764706
181944,"@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAccounts) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAccounts) {
      writeStatisticsLocked();
    }
  }
}","@Override public void handleMessage(Message msg){
  if (msg.what == MSG_WRITE_STATUS) {
synchronized (mAuthorities) {
      writeStatusLocked();
    }
  }
 else   if (msg.what == MSG_WRITE_STATISTICS) {
synchronized (mAuthorities) {
      writeStatisticsLocked();
    }
  }
}",0.9448529411764706
181945,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}",0.6263083451202263
181946,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9997242900468708
181947,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}",0.6263083451202263
181948,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9997242900468708
181949,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}",0.6263083451202263
181950,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9997242900468708
181951,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}",0.6263083451202263
181952,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9997242900468708
181953,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    final int childIndex=mSelectedPosition - mFirstPosition;
    if (childIndex >= 0 && childIndex < getChildCount()) {
      positionSelector(getChildAt(childIndex));
    }
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9997242900468708
181954,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}",0.9723455793298345
181955,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9817112613937076
181956,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9278055754110078
181957,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}",0.934998249504026
181958,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}",0.9723455793298345
181959,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9814891970716028
181960,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9278055754110078
181961,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}",0.934998249504026
181962,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}",0.9723455793298345
181963,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9814891970716028
181964,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9278055754110078
181965,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}",0.934998249504026
181966,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.966798989534464
181967,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_neverEncrypt,false)) {
    ai.flags|=ApplicationInfo.FLAG_NEVER_ENCRYPT;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_neverEncrypt,false)) {
    ai.flags|=ApplicationInfo.FLAG_NEVER_ENCRYPT;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.96741440377804
181968,"@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE,networkInfo.getState(),NetworkState.DO_NOTHING,State.DISCONNECTED);
  networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
    assertTrue(false);
  }
}","@LargeTest public void testDataConnectionWithWifiToAMToWifi(){
  assertNotNull(""String_Node_Str"",TEST_ACCESS_POINT);
  assertTrue(""String_Node_Str"" + TEST_ACCESS_POINT,cmActivity.connectToWifi(TEST_ACCESS_POINT));
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),true);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  try {
    Thread.sleep(STATE_TRANSITION_SHORT_TIMEOUT);
  }
 catch (  Exception e) {
    Log.v(LOG_TAG,""String_Node_Str"" + e.toString());
  }
  NetworkInfo networkInfo=cmActivity.mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  assertEquals(State.DISCONNECTED,networkInfo.getState());
  cmActivity.setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI,networkInfo.getState(),NetworkState.TO_CONNECTION,State.CONNECTED);
  cmActivity.setAirplaneMode(getInstrumentation().getContext(),false);
  waitForNetworkState(ConnectivityManager.TYPE_WIFI,State.CONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  waitForNetworkState(ConnectivityManager.TYPE_MOBILE,State.DISCONNECTED,STATE_TRANSITION_LONG_TIMEOUT);
  if (!cmActivity.validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
    Log.v(LOG_TAG,""String_Node_Str"");
    Log.v(LOG_TAG,""String_Node_Str"" + cmActivity.getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
    assertTrue(false);
  }
}",0.6263083451202263
181969,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mInternalSdkPlatform));
    serializer.attribute(null,""String_Node_Str"",Integer.toString(mExternalSdkPlatform));
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}",0.9723455793298345
181970,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,""String_Node_Str"" + mSettings.mInternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9814891970716028
181971,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      doGc=true;
synchronized (mInstallLock) {
        final PackageParser.Package pkg=scanPackageLI(new File(codePath),parseFlags,0);
        if (pkg != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + codePath + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    final boolean regrantPermissions=mSettings.mExternalSdkPlatform != mSdkVersion;
    if (regrantPermissions)     Slog.i(TAG,""String_Node_Str"" + mSettings.mExternalSdkPlatform + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"");
    mSettings.mExternalSdkPlatform=mSdkVersion;
    updatePermissionsLP(null,null,true,regrantPermissions);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.9278055754110078
181972,"boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}","boolean readLP(){
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append(""String_Node_Str"");
      Log.i(TAG,""String_Node_Str"");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,""String_Node_Str"" + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append(""String_Node_Str"");
        Slog.i(TAG,""String_Node_Str"");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append(""String_Node_Str"");
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(""String_Node_Str"")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String name=parser.getAttributeValue(null,""String_Node_Str"");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        String nname=parser.getAttributeValue(null,""String_Node_Str"");
        String oname=parser.getAttributeValue(null,""String_Node_Str"");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals(""String_Node_Str"")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,""String_Node_Str"");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,""String_Node_Str"");
          if (external != null) {
            mInternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append(""String_Node_Str"" + e.toString());
    Slog.e(TAG,""String_Node_Str"",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        Slog.w(TAG,""String_Node_Str"" + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
 else {
      String msg=""String_Node_Str"" + pp.name + ""String_Node_Str""+ pp.sharedId+ ""String_Node_Str"";
      mReadMessages.append(msg);
      Slog.e(TAG,msg);
    }
  }
  mPendingPackages.clear();
  mReadMessages.append(""String_Node_Str"" + mPackages.size() + ""String_Node_Str""+ mSharedUsers.size()+ ""String_Node_Str"");
  return true;
}",0.934998249504026
181973,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.966798989534464
181974,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}",0.9486228813559322
181975,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",0.7528641571194763
181976,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}",0.915365653245686
181977,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}",0.9916963226571768
181978,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9601386481802426
181979,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}",0.9486228813559322
181980,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",0.7528641571194763
181981,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}",0.915365653245686
181982,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}",0.9916963226571768
181983,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9601386481802426
181984,"boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}","boolean computeNewConfigurationLocked(Configuration config){
  if (mDisplay == null) {
    return false;
  }
  mQueue.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int dw=rotated ? mInitialDisplayHeight : mInitialDisplayWidth;
  final int dh=rotated ? mInitialDisplayWidth : mInitialDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getMetrics(dm);
  CompatibilityInfo.updateCompatibleScreenFrame(dm,orientation,mCompatibleScreenFrame);
  if (mScreenLayout == Configuration.SCREENLAYOUT_SIZE_UNDEFINED) {
    int longSize=dw;
    int shortSize=dh;
    if (longSize < shortSize) {
      int tmp=longSize;
      longSize=shortSize;
      shortSize=tmp;
    }
    longSize=(int)(longSize / dm.density);
    shortSize=(int)(shortSize / dm.density);
    if (longSize < 470) {
      mScreenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
    }
 else {
      if (longSize > 640 && shortSize >= 480) {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
      }
 else {
        mScreenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
        if (shortSize > 321 || longSize > 570) {
          mScreenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
        }
      }
      if (((longSize * 3) / 5) >= (shortSize - 1)) {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
      }
 else {
        mScreenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
      }
    }
  }
  config.screenLayout=mScreenLayout;
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}",0.9486228813559322
181985,"public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw()) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","public int getOrientationFromWindowsLocked(){
  int pos=mWindows.size() - 1;
  while (pos >= 0) {
    WindowState wtoken=(WindowState)mWindows.get(pos);
    pos--;
    if (wtoken.mAppToken != null) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
      continue;
    }
    int req=wtoken.mAttrs.screenOrientation;
    if ((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) || (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)) {
      continue;
    }
 else {
      return req;
    }
  }
  return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",0.7528641571194763
181986,"private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}","private void stopFreezingDisplayLocked(){
  if (!mDisplayFrozen) {
    return;
  }
  if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
    return;
  }
  mDisplayFrozen=false;
  mH.removeMessages(H.APP_FREEZE_TIMEOUT);
  if (PROFILE_ORIENTATION) {
    Debug.stopMethodTracing();
  }
  Surface.unfreezeDisplay(0);
synchronized (mKeyWaiter) {
    mKeyWaiter.mWasFrozen=true;
    mKeyWaiter.notifyAll();
  }
  if (updateOrientationFromAppTokensLocked()) {
    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
  }
  mH.removeMessages(H.FORCE_GC);
  mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
  mScreenFrozenLock.release();
}",0.915365653245686
181987,"public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}","public int addWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int viewVisibility,Rect outContentInsets){
  int res=mPolicy.checkAddPermission(attrs);
  if (res != WindowManagerImpl.ADD_OKAY) {
    return res;
  }
  boolean reportNewConfig=false;
  WindowState attachedWindow=null;
  WindowState win=null;
synchronized (mWindowMap) {
    if (mDisplay == null) {
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      mDisplay=wm.getDefaultDisplay();
      mInitialDisplayWidth=mDisplay.getWidth();
      mInitialDisplayHeight=mDisplay.getHeight();
      mQueue.setDisplay(mDisplay);
      reportNewConfig=true;
    }
    if (mWindowMap.containsKey(client.asBinder())) {
      Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str"");
      return WindowManagerImpl.ADD_DUPLICATE_ADD;
    }
    if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
      attachedWindow=windowForClientLocked(null,attrs.token,false);
      if (attachedWindow == null) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
      if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
      }
    }
    boolean addToken=false;
    WindowToken token=mTokenMap.get(attrs.token);
    if (token == null) {
      if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      if (attrs.type == TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
      token=new WindowToken(attrs.token,-1,false);
      addToken=true;
    }
 else     if (attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW) {
      AppWindowToken atoken=token.appWindowToken;
      if (atoken == null) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_NOT_APP_TOKEN;
      }
 else       if (atoken.removed) {
        Slog.w(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_APP_EXITING;
      }
      if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
        if (localLOGV)         Slog.v(TAG,""String_Node_Str"" + attrs.getTitle());
        return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
      }
    }
 else     if (attrs.type == TYPE_INPUT_METHOD) {
      if (token.windowType != TYPE_INPUT_METHOD) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
 else     if (attrs.type == TYPE_WALLPAPER) {
      if (token.windowType != TYPE_WALLPAPER) {
        Slog.w(TAG,""String_Node_Str"" + attrs.token + ""String_Node_Str"");
        return WindowManagerImpl.ADD_BAD_APP_TOKEN;
      }
    }
    win=new WindowState(session,client,token,attachedWindow,attrs,viewVisibility);
    if (win.mDeathRecipient == null) {
      Slog.w(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str"");
      return WindowManagerImpl.ADD_APP_EXITING;
    }
    mPolicy.adjustWindowParamsLw(win.mAttrs);
    res=mPolicy.prepareAddWindowLw(win,attrs);
    if (res != WindowManagerImpl.ADD_OKAY) {
      return res;
    }
    res=WindowManagerImpl.ADD_OKAY;
    final long origId=Binder.clearCallingIdentity();
    if (addToken) {
      mTokenMap.put(attrs.token,token);
      mTokenList.add(token);
    }
    win.attach();
    mWindowMap.put(client.asBinder(),win);
    if (attrs.type == TYPE_APPLICATION_STARTING && token.appWindowToken != null) {
      token.appWindowToken.startingWindow=win;
    }
    boolean imMayMove=true;
    if (attrs.type == TYPE_INPUT_METHOD) {
      mInputMethodWindow=win;
      addInputMethodWindowToListLocked(win);
      imMayMove=false;
    }
 else     if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
      mInputMethodDialogs.add(win);
      addWindowToListInOrderLocked(win,true);
      adjustInputMethodDialogsLocked();
      imMayMove=false;
    }
 else {
      addWindowToListInOrderLocked(win,true);
      if (attrs.type == TYPE_WALLPAPER) {
        mLastWallpaperTimeoutTime=0;
        adjustWallpaperWindowsLocked();
      }
 else       if ((attrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
        adjustWallpaperWindowsLocked();
      }
    }
    win.mEnterAnimationPending=true;
    mPolicy.getContentInsetHintLw(attrs,outContentInsets);
    if (mInTouchMode) {
      res|=WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
    }
    if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
      res|=WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
    }
    boolean focusChanged=false;
    if (win.canReceiveKeys()) {
      if ((focusChanged=updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS)) == true) {
        imMayMove=false;
      }
    }
    if (imMayMove) {
      moveInputMethodWindowsIfNeededLocked(false);
    }
    assignLayersLocked();
    if (focusChanged) {
      if (mCurrentFocus != null) {
        mKeyWaiter.handleNewWindowLocked(mCurrentFocus);
      }
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win);
    if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked()) {
      reportNewConfig=true;
    }
  }
  final long origId=Binder.clearCallingIdentity();
  if (reportNewConfig) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return res;
}",0.9916963226571768
181988,"boolean updateOrientationFromAppTokensLocked(){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","boolean updateOrientationFromAppTokensLocked(){
  if (mDisplayFrozen) {
    return false;
  }
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
      if (setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE)) {
        changed=true;
      }
    }
    return changed;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9601386481802426
181989,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}",0.8
181990,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}",0.8
181991,"public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
      mMenu.close(true);
      dialog.dismiss();
      return true;
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}","public boolean onKey(DialogInterface dialog,int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null) {
            ds.startTracking(event,this);
            return true;
          }
        }
      }
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
      Window win=mDialog.getWindow();
      if (win != null) {
        View decor=win.getDecorView();
        if (decor != null) {
          KeyEvent.DispatcherState ds=decor.getKeyDispatcherState();
          if (ds != null && ds.isTracking(event)) {
            mMenu.close(true);
            dialog.dismiss();
            return true;
          }
        }
      }
    }
  }
  return mMenu.performShortcut(keyCode,event,0);
}",0.8
181992,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}",0.9666840187402396
181993,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}",0.9666840187402396
181994,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}",0.9666840187402396
181995,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_name,0);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,0);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent,0);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_ANY_VERSION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if ((flags & PARSE_FORWARD_LOCK) != 0) {
    ai.flags|=ApplicationInfo.FLAG_FORWARD_LOCK;
  }
  if ((flags & PARSE_ON_SDCARD) != 0) {
    ai.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode,false)) {
    ai.flags|=ApplicationInfo.FLAG_VM_SAFE_MODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_permission,0);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
    str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity,0);
  }
 else {
    str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  }
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    CharSequence pname;
    if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {
      pname=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestApplication_process,0);
    }
 else {
      pname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process);
    }
    ai.processName=buildProcessName(ai.packageName,null,pname,flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.966798989534464
181996,"private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}","private final Map<String,KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer,int len){
  String name;
  int count;
  long totalTime;
  int startIndex, endIndex;
  int numUpdatedWlNames=0;
  int i;
  for (i=0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++)   ;
  startIndex=endIndex=i + 1;
synchronized (this) {
    Map<String,KernelWakelockStats> m=mProcWakelockFileStats;
    sKernelWakelockUpdateVersion++;
    while (endIndex < len) {
      for (endIndex=startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++)       ;
      endIndex++;
      String[] nameStringArray=mProcWakelocksName;
      long[] wlData=mProcWakelocksData;
      for (int j=startIndex; j < endIndex; j++) {
        if ((wlBuffer[j] & 0x80) != 0)         wlBuffer[j]=(byte)'?';
      }
      boolean parsed=Process.parseProcLine(wlBuffer,startIndex,endIndex,PROC_WAKELOCKS_FORMAT,nameStringArray,wlData,null);
      name=nameStringArray[0];
      count=(int)wlData[1];
      totalTime=(wlData[2] + 500) / 1000;
      if (parsed && name.length() > 0) {
        if (!m.containsKey(name)) {
          m.put(name,new KernelWakelockStats(count,totalTime,sKernelWakelockUpdateVersion));
          numUpdatedWlNames++;
        }
 else {
          KernelWakelockStats kwlStats=m.get(name);
          if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
            kwlStats.mCount+=count;
            kwlStats.mTotalTime+=totalTime;
          }
 else {
            kwlStats.mCount=count;
            kwlStats.mTotalTime=totalTime;
            kwlStats.mVersion=sKernelWakelockUpdateVersion;
            numUpdatedWlNames++;
          }
        }
      }
      startIndex=endIndex;
    }
    if (m.size() != numUpdatedWlNames) {
      Iterator<KernelWakelockStats> itr=m.values().iterator();
      while (itr.hasNext()) {
        if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
          itr.remove();
        }
      }
    }
    return m;
  }
}",0.9666840187402396
181997,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9427509293680296
181998,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9851570590265792
181999,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9427509293680296
182000,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9851570590265792
