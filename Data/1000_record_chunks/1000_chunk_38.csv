record_number,buggy_code,fixed_code,code_similarity
37001,"@Test public void testBuildUnitMatchesAnalyzedProject(){
  String buildUnitName=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  String projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  buildUnitName=Utilities.getBuildUnitName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",buildUnitName);
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(""String_Node_Str"")));
}","@Test public void testBuildUnitMatchesAnalyzedProject(){
  String buildUnitName=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  String projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  projectKey=""String_Node_Str"";
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,new Project(projectKey)));
  buildUnitName=Utilities.getBuildUnitName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",buildUnitName);
  Project project=new Project(""String_Node_Str"");
  assertTrue(Utilities.buildUnitMatchesAnalyzedProject(buildUnitName,project));
}",0.9493302271403612
37002,"void analyseCylceGroups(ReportContext report,XsdAttributeRoot buildUnit){
  XsdCycleGroups cycleGroups=report.getCycleGroups();
  double cyclicity=0;
  double biggestCycleGroupSize=0;
  double cyclicPackages=0;
  for (  XsdCycleGroup group : cycleGroups.getCycleGroup()) {
    if (""String_Node_Str"".equals(group.getNamedElementGroup()) && getBuildUnitName(group).equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
      int groupSize=group.getCyclePath().size();
      cyclicPackages+=groupSize;
      cyclicity+=groupSize * groupSize;
      if (groupSize > biggestCycleGroupSize) {
        biggestCycleGroupSize=groupSize;
      }
      handlePackageCycleGroup(group);
    }
  }
  saveMeasureToContext(SonargraphSystemMetrics.BIGGEST_CYCLE_GROUP,biggestCycleGroupSize,0);
  saveMeasureToContext(SonargraphBuildUnitMetrics.CYCLICITY,cyclicity,0);
  saveMeasureToContext(SonargraphBuildUnitMetrics.CYCLIC_PACKAGES,cyclicPackages,0);
}","void analyseCylceGroups(ReportContext report,XsdAttributeRoot buildUnit,Project project){
  LOG.debug(""String_Node_Str"" + buildUnit.getName());
  XsdCycleGroups cycleGroups=report.getCycleGroups();
  double cyclicity=0;
  double biggestCycleGroupSize=0;
  double cyclicPackages=0;
  for (  XsdCycleGroup group : cycleGroups.getCycleGroup()) {
    if (""String_Node_Str"".equals(group.getNamedElementGroup()) && getBuildUnitName(group).equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
      int groupSize=group.getCyclePath().size();
      cyclicPackages+=groupSize;
      cyclicity+=groupSize * groupSize;
      if (groupSize > biggestCycleGroupSize) {
        biggestCycleGroupSize=groupSize;
      }
      handlePackageCycleGroup(group);
    }
  }
  saveMeasureToContext(SonargraphSystemMetrics.BIGGEST_CYCLE_GROUP,biggestCycleGroupSize,0);
  saveMeasureToContext(SonargraphBuildUnitMetrics.CYCLICITY,cyclicity,0);
  if (project.isRoot()) {
    double packages=sensorContext.getMeasure(SonargraphBuildUnitMetrics.INTERNAL_PACKAGES).getValue();
    if (packages > 0) {
      double relCyclicity=100.0 * Math.sqrt(cyclicity) / packages;
      double relCyclicPackages=100.0 * cyclicPackages / packages;
      saveMeasureToContext(SonargraphSystemMetrics.RELATIVE_CYCLICITY,relCyclicity,0);
      saveMeasureToContext(SonargraphSystemMetrics.CYCLIC_PACKAGES_PERCENT,relCyclicPackages,1);
    }
 else {
      saveMeasureToContext(SonargraphSystemMetrics.RELATIVE_CYCLICITY,0,0);
      saveMeasureToContext(SonargraphSystemMetrics.CYCLIC_PACKAGES_PERCENT,0,1);
    }
  }
  saveMeasureToContext(SonargraphBuildUnitMetrics.CYCLIC_PACKAGES,cyclicPackages,0);
}",0.69842489435267
37003,"public void analyse(final Project project,SensorContext sensorContext){
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + project.getName());
  LOG.info(""String_Node_Str"");
  this.sensorContext=sensorContext;
  Configuration configuration=project.getConfiguration();
  if (null == report) {
    String reportPath=getReportFileName(project.getFileSystem().getBuildDir().getPath(),configuration);
    report=ReportFileReader.readSonargraphReport(reportPath);
    LOG.info(""String_Node_Str"" + reportPath);
  }
 else {
    LOG.info(""String_Node_Str"" + report.getName());
  }
  XsdAttributeRoot buildUnit=null;
  if (report != null) {
    buildUnit=retrieveBuildUnit(project.getKey(),report);
  }
  if (null == buildUnit) {
    LOG.error(""String_Node_Str"");
    return;
  }
  LOG.info(""String_Node_Str"" + project.getName());
  this.analyseBuildUnit(report,buildUnit);
  double indexCost=configuration.getDouble(SonargraphPluginBase.COST_PER_INDEX_POINT,SonargraphPluginBase.COST_PER_INDEX_POINT_DEFAULT);
  if (indexCost > 0) {
    double structuralDebtCost=sensorContext.getMeasure(SonargraphBuildUnitMetrics.EROSION_INDEX).getValue() * indexCost;
    saveMeasureToContext(SonargraphBuildUnitMetrics.EROSION_COST,structuralDebtCost,0);
  }
  this.analyseSystemMeasures(report,null);
  this.analyseCylceGroups(report,buildUnit);
  if (hasBuildUnitMetric(UNASSIGNED_TYPES)) {
    LOG.info(""String_Node_Str"" + project.getName());
    this.addArchitectureMeasures(report,buildUnit);
  }
  if (ruleFinder != null) {
    this.handleArchitectureViolations(report,buildUnit);
    this.handleWarnings(report,buildUnit);
    this.handleTasks(report,buildUnit);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
  AlertDecorator.setAlertLevels(new SensorProjectContext(sensorContext));
}","public void analyse(final Project project,SensorContext sensorContext){
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + project.getName());
  LOG.info(""String_Node_Str"");
  this.sensorContext=sensorContext;
  Configuration configuration=project.getConfiguration();
  if (Utilities.isRootParentProject(project)) {
    return;
  }
  if (null == report) {
    String reportPath=this.getReportFileName(project.getFileSystem().getBuildDir().getPath(),configuration);
    LOG.info(""String_Node_Str"" + reportPath);
    report=ReportFileReader.readSonargraphReport(reportPath,project.isRoot());
  }
 else {
    LOG.info(""String_Node_Str"" + report.getName());
  }
  XsdAttributeRoot buildUnit=null;
  if (report != null) {
    buildUnit=retrieveBuildUnit(project.getKey(),report);
  }
  if (null == buildUnit) {
    LOG.error(""String_Node_Str"");
    return;
  }
  LOG.info(""String_Node_Str"" + project.getName());
  this.analyseBuildUnit(report,buildUnit);
  double indexCost=configuration.getDouble(SonargraphPluginBase.COST_PER_INDEX_POINT,SonargraphPluginBase.COST_PER_INDEX_POINT_DEFAULT);
  if (indexCost > 0) {
    double structuralDebtCost=sensorContext.getMeasure(SonargraphBuildUnitMetrics.EROSION_INDEX).getValue() * indexCost;
    saveMeasureToContext(SonargraphBuildUnitMetrics.EROSION_COST,structuralDebtCost,0);
  }
  this.analyseSystemMeasures(report,null);
  this.analyseCylceGroups(report,buildUnit,project);
  if (hasBuildUnitMetric(UNASSIGNED_TYPES)) {
    LOG.info(""String_Node_Str"" + project.getName());
    this.addArchitectureMeasures(report,buildUnit);
  }
  if (ruleFinder != null) {
    this.handleArchitectureViolations(report,buildUnit);
    this.handleWarnings(report,buildUnit);
    this.handleTasks(report,buildUnit);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
  AlertDecorator.setAlertLevels(new SensorProjectContext(sensorContext));
}",0.9404696886947024
37004,"void analyseSystemMeasures(ReportContext report,XsdAttributeRoot root){
  Map<String,Number> systemAttributes=new HashMap<String,Number>();
  Utilities.readAttributesToMap(report.getAttributes(),systemAttributes);
  saveMeasureToContext(SonargraphSystemMetrics.ARCHITECTURE_VIOLATIONS,getMetricValueFromMap(VIOLATING_REFERENCES,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.CYCLE_WARNINGS,getMetricValueFromMap(CYCLE_WARNINGS,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.WORKSPACE_WARNINGS,getMetricValueFromMap(WORKSPACE_WARNINGS,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.ALL_WARNINGS,getMetricValueFromMap(ALL_WARNINGS,systemAttributes),0);
}","void analyseSystemMeasures(ReportContext report,XsdAttributeRoot root){
  LOG.debug(""String_Node_Str"");
  Map<String,Number> systemAttributes=new HashMap<String,Number>();
  Utilities.readAttributesToMap(report.getAttributes(),systemAttributes);
  saveMeasureToContext(SonargraphSystemMetrics.ARCHITECTURE_VIOLATIONS,getMetricValueFromMap(VIOLATING_REFERENCES,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.CYCLE_WARNINGS,getMetricValueFromMap(CYCLE_WARNINGS,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.WORKSPACE_WARNINGS,getMetricValueFromMap(WORKSPACE_WARNINGS,systemAttributes),0);
  saveMeasureToContext(SonargraphSystemMetrics.ALL_WARNINGS,getMetricValueFromMap(ALL_WARNINGS,systemAttributes),0);
}",0.9782016348773842
37005,"void analyseBuildUnit(final ReportContext report,final XsdAttributeRoot buildUnit){
  Utilities.readAttributesToMap(buildUnit,buildUnitMetrics);
  Number internalPackages=this.getBuildUnitMetricValue(INTERNAL_PACKAGES);
  if (internalPackages.intValue() == 0) {
    LOG.warn(""String_Node_Str"" + buildUnit.getName());
    return;
  }
  saveExistingMeasureToContext(INTERNAL_PACKAGES,SonargraphBuildUnitMetrics.INTERNAL_PACKAGES,0);
  saveExistingMeasureToContext(ACD,SonargraphSystemMetrics.ACD,1);
  saveExistingMeasureToContext(NCCD,SonargraphSystemMetrics.NCCD,1);
  saveExistingMeasureToContext(INSTRUCTIONS,SonargraphBuildUnitMetrics.INSTRUCTIONS,0);
  saveExistingMeasureToContext(JAVA_FILES,SonargraphBuildUnitMetrics.JAVA_FILES,0);
  saveExistingMeasureToContext(TYPE_DEPENDENCIES,SonargraphBuildUnitMetrics.TYPE_DEPENDENCIES,0);
  saveExistingMeasureToContext(EROSION_REFS,SonargraphBuildUnitMetrics.EROSION_REFS,0);
  saveExistingMeasureToContext(EROSION_TYPES,SonargraphBuildUnitMetrics.EROSION_TYPES,0);
  saveExistingMeasureToContext(STUCTURAL_DEBT_INDEX,SonargraphBuildUnitMetrics.EROSION_INDEX,0).getValue();
}","void analyseBuildUnit(final ReportContext report,final XsdAttributeRoot buildUnit){
  LOG.debug(""String_Node_Str"" + buildUnit.getName());
  Utilities.readAttributesToMap(buildUnit,buildUnitMetrics);
  Number internalPackages=this.getBuildUnitMetricValue(INTERNAL_PACKAGES);
  if (internalPackages.intValue() == 0) {
    LOG.warn(""String_Node_Str"" + buildUnit.getName());
    return;
  }
  saveExistingMeasureToContext(INTERNAL_PACKAGES,SonargraphBuildUnitMetrics.INTERNAL_PACKAGES,0);
  saveExistingMeasureToContext(ACD,SonargraphSystemMetrics.ACD,1);
  saveExistingMeasureToContext(NCCD,SonargraphSystemMetrics.NCCD,1);
  saveExistingMeasureToContext(INSTRUCTIONS,SonargraphBuildUnitMetrics.INSTRUCTIONS,0);
  saveExistingMeasureToContext(JAVA_FILES,SonargraphBuildUnitMetrics.JAVA_FILES,0);
  saveExistingMeasureToContext(TYPE_DEPENDENCIES,SonargraphBuildUnitMetrics.TYPE_DEPENDENCIES,0);
  saveExistingMeasureToContext(EROSION_REFS,SonargraphBuildUnitMetrics.EROSION_REFS,0);
  saveExistingMeasureToContext(EROSION_TYPES,SonargraphBuildUnitMetrics.EROSION_TYPES,0);
  saveExistingMeasureToContext(STUCTURAL_DEBT_INDEX,SonargraphBuildUnitMetrics.EROSION_INDEX,0).getValue();
}",0.9765421372719374
37006,"void handleTasks(ReportContext report,XsdAttributeRoot buildUnit){
  XsdTasks tasks=report.getTasks();
  Map<String,RulePriority> priorityMap=new HashMap<String,RulePriority>();
  Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.TASK_RULE_KEY);
  int count=0;
  if (rule == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  priorityMap.put(""String_Node_Str"",RulePriority.INFO);
  priorityMap.put(""String_Node_Str"",RulePriority.MINOR);
  priorityMap.put(""String_Node_Str"",RulePriority.MAJOR);
  for (  XsdTask task : tasks.getTask()) {
    String bu=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
    bu=Utilities.getBuildUnitName(bu);
    if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
      String priority=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      String description=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      String assignedTo=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      description=handleDescription(description);
      int index=description.indexOf(""String_Node_Str"");
      if (index > 0 && index < 8) {
        count++;
      }
 else {
        if (assignedTo != null) {
          assignedTo='[' + assignedTo.trim() + ']';
          if (assignedTo.length() > 2) {
            description+=' ' + assignedTo;
          }
        }
        for (        XsdPosition pos : task.getPosition()) {
          String relFileName=pos.getFile();
          if (relFileName != null) {
            String fqName=Utilities.relativeFileNameToFqName(relFileName);
            int line=Integer.valueOf(pos.getLine());
            if (line == 0) {
              line=1;
            }
            saveViolation(rule,priorityMap.get(priority),fqName,line,description);
          }
          count++;
        }
      }
    }
  }
  saveMeasureToContext(SonargraphBuildUnitMetrics.TASK_REFS,count,0);
}","void handleTasks(ReportContext report,XsdAttributeRoot buildUnit){
  LOG.debug(""String_Node_Str"" + buildUnit.getName());
  XsdTasks tasks=report.getTasks();
  Map<String,RulePriority> priorityMap=new HashMap<String,RulePriority>();
  Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.TASK_RULE_KEY);
  int count=0;
  if (rule == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  priorityMap.put(""String_Node_Str"",RulePriority.INFO);
  priorityMap.put(""String_Node_Str"",RulePriority.MINOR);
  priorityMap.put(""String_Node_Str"",RulePriority.MAJOR);
  for (  XsdTask task : tasks.getTask()) {
    String bu=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
    bu=Utilities.getBuildUnitName(bu);
    if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
      String priority=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      String description=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      String assignedTo=Utilities.getAttribute(task.getAttribute(),""String_Node_Str"");
      description=handleDescription(description);
      int index=description.indexOf(""String_Node_Str"");
      if (index > 0 && index < 8) {
        count++;
      }
 else {
        if (assignedTo != null) {
          assignedTo='[' + assignedTo.trim() + ']';
          if (assignedTo.length() > 2) {
            description+=' ' + assignedTo;
          }
        }
        for (        XsdPosition pos : task.getPosition()) {
          String relFileName=pos.getFile();
          if (relFileName != null) {
            String fqName=Utilities.relativeFileNameToFqName(relFileName);
            int line=Integer.valueOf(pos.getLine());
            if (line == 0) {
              line=1;
            }
            saveViolation(rule,priorityMap.get(priority),fqName,line,description);
          }
          count++;
        }
      }
    }
  }
  saveMeasureToContext(SonargraphBuildUnitMetrics.TASK_REFS,count,0);
}",0.986280487804878
37007,"void handleArchitectureViolations(ReportContext report,XsdAttributeRoot buildUnit){
  Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.ARCH_RULE_KEY);
  if (rule == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  XsdViolations violations=report.getViolations();
  String uses=""String_Node_Str"";
  for (  XsdArchitectureViolation violation : violations.getArchitectureViolations()) {
    for (    XsdTypeRelation rel : violation.getTypeRelation()) {
      String toType=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String bu=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String type=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String dimension=violation.getDimension();
      String message=""String_Node_Str"";
      if (null != dimension) {
        message=dimension + ""String_Node_Str"";
      }
 else {
        message=""String_Node_Str"";
      }
      int indentation=message.length() - uses.length();
      message=message + type + ""String_Node_Str""+ Utilities.generateSpaces(indentation)+ uses+ toType;
      String explanation=""String_Node_Str"" + Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      bu=Utilities.getBuildUnitName(bu);
      if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
        for (        XsdPosition pos : rel.getPosition()) {
          String relFileName=pos.getFile();
          int line=0;
          try {
            line=Integer.parseInt(pos.getLine());
          }
 catch (          NumberFormatException ex) {
            LOG.error(""String_Node_Str"" + pos.getLine() + ""String_Node_Str""+ ex.getMessage());
            continue;
          }
          if (relFileName != null && (pos.getType() != null) && (line > 0)) {
            String fqName=Utilities.relativeFileNameToFqName(relFileName);
            String msg=message + ""String_Node_Str"" + pos.getType()+ explanation;
            LOG.debug(msg);
            saveViolation(rule,null,fqName,Integer.valueOf(pos.getLine()),msg);
          }
        }
      }
    }
  }
}","void handleArchitectureViolations(ReportContext report,XsdAttributeRoot buildUnit){
  LOG.debug(""String_Node_Str"" + buildUnit.getName());
  Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.ARCH_RULE_KEY);
  if (rule == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  XsdViolations violations=report.getViolations();
  String uses=""String_Node_Str"";
  for (  XsdArchitectureViolation violation : violations.getArchitectureViolations()) {
    for (    XsdTypeRelation rel : violation.getTypeRelation()) {
      String toType=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String bu=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String type=Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      String dimension=violation.getDimension();
      String message=""String_Node_Str"";
      if (null != dimension) {
        message=dimension + ""String_Node_Str"";
      }
 else {
        message=""String_Node_Str"";
      }
      int indentation=message.length() - uses.length();
      message=message + type + ""String_Node_Str""+ Utilities.generateSpaces(indentation)+ uses+ toType;
      String explanation=""String_Node_Str"" + Utilities.getAttribute(rel.getAttribute(),""String_Node_Str"");
      bu=Utilities.getBuildUnitName(bu);
      if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
        for (        XsdPosition pos : rel.getPosition()) {
          String relFileName=pos.getFile();
          int line=0;
          try {
            line=Integer.parseInt(pos.getLine());
          }
 catch (          NumberFormatException ex) {
            LOG.error(""String_Node_Str"" + pos.getLine() + ""String_Node_Str""+ ex.getMessage());
            continue;
          }
          if (relFileName != null && (pos.getType() != null) && (line > 0)) {
            String fqName=Utilities.relativeFileNameToFqName(relFileName);
            String msg=message + ""String_Node_Str"" + pos.getType()+ explanation;
            LOG.debug(msg);
            saveViolation(rule,null,fqName,Integer.valueOf(pos.getLine()),msg);
          }
        }
      }
    }
  }
}",0.9873239436619718
37008,"void handleWarnings(ReportContext report,XsdAttributeRoot buildUnit){
  XsdWarnings warnings=report.getWarnings();
  for (  XsdWarningsByAttributeGroup warningGroup : warnings.getWarningsByAttributeGroup()) {
    String key=SonargraphPluginBase.getRuleKey(warningGroup.getAttributeGroup());
    if (key == null) {
      continue;
    }
    Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,key);
    if (rule == null) {
      LOG.error(""String_Node_Str"");
      continue;
    }
    if (""String_Node_Str"".equals(warningGroup.getAttributeGroup())) {
      handleDuplicateCodeBlocks(warningGroup,rule);
      continue;
    }
    for (    XsdWarningsByAttribute warningByAttribute : warningGroup.getWarningsByAttribute()) {
      String attrName=warningByAttribute.getAttributeName();
      for (      XsdWarning warning : warningByAttribute.getWarning()) {
        String msg=attrName + ""String_Node_Str"" + Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
        String bu=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
        bu=Utilities.getBuildUnitName(bu);
        if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
          if (warning.getPosition().size() > 0) {
            for (            XsdPosition pos : warning.getPosition()) {
              String relFileName=pos.getFile();
              if (relFileName != null) {
                String fqName=Utilities.relativeFileNameToFqName(relFileName);
                saveViolation(rule,null,fqName,Integer.valueOf(pos.getLine()),msg);
              }
            }
          }
 else {
            String elemType=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
            if (""String_Node_Str"".equals(elemType) || ""String_Node_Str"".equals(elemType)) {
              String fileName=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
              String fqName=fileName.substring(0,fileName.lastIndexOf('.')).replace('/','.');
              saveViolation(rule,null,fqName,1,msg);
            }
          }
        }
      }
    }
  }
}","void handleWarnings(ReportContext report,XsdAttributeRoot buildUnit){
  LOG.debug(""String_Node_Str"" + buildUnit.getName());
  XsdWarnings warnings=report.getWarnings();
  for (  XsdWarningsByAttributeGroup warningGroup : warnings.getWarningsByAttributeGroup()) {
    String key=SonargraphPluginBase.getRuleKey(warningGroup.getAttributeGroup());
    if (key == null) {
      continue;
    }
    Rule rule=ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,key);
    if (rule == null) {
      LOG.error(""String_Node_Str"");
      continue;
    }
    if (""String_Node_Str"".equals(warningGroup.getAttributeGroup())) {
      handleDuplicateCodeBlocks(warningGroup,rule);
      continue;
    }
    for (    XsdWarningsByAttribute warningByAttribute : warningGroup.getWarningsByAttribute()) {
      String attrName=warningByAttribute.getAttributeName();
      for (      XsdWarning warning : warningByAttribute.getWarning()) {
        String msg=attrName + ""String_Node_Str"" + Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
        String bu=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
        bu=Utilities.getBuildUnitName(bu);
        if (bu.equals(Utilities.getBuildUnitName(buildUnit.getName()))) {
          if (warning.getPosition().size() > 0) {
            for (            XsdPosition pos : warning.getPosition()) {
              String relFileName=pos.getFile();
              if (relFileName != null) {
                String fqName=Utilities.relativeFileNameToFqName(relFileName);
                saveViolation(rule,null,fqName,Integer.valueOf(pos.getLine()),msg);
              }
            }
          }
 else {
            String elemType=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
            if (""String_Node_Str"".equals(elemType) || ""String_Node_Str"".equals(elemType)) {
              String fileName=Utilities.getAttribute(warning.getAttribute(),""String_Node_Str"");
              String fqName=fileName.substring(0,fileName.lastIndexOf('.')).replace('/','.');
              saveViolation(rule,null,fqName,1,msg);
            }
          }
        }
      }
    }
  }
}",0.9872581406323736
37009,"void handleDuplicateCodeBlocks(XsdWarningsByAttributeGroup warningGroup,Rule rule){
  Map<Integer,List<DuplicateCodeBlock>> duplicateCodeBlocks=new HashMap<Integer,List<DuplicateCodeBlock>>();
  for (  XsdWarningsByAttribute warnings : warningGroup.getWarningsByAttribute()) {
    for (    XsdWarning warning : warnings.getWarning()) {
      DuplicateCodeBlock block=Utilities.createDuplicateCodeBlock(warning);
      if (null == block) {
        continue;
      }
      if (!duplicateCodeBlocks.containsKey(block.getBlockId())) {
        duplicateCodeBlocks.put(block.getBlockId(),new ArrayList<DuplicateCodeBlock>());
      }
      duplicateCodeBlocks.get(block.getBlockId()).add(block);
    }
  }
  for (  Entry<Integer,List<DuplicateCodeBlock>> entry : duplicateCodeBlocks.entrySet()) {
    for (    DuplicateCodeBlock block : entry.getValue()) {
      String message=Utilities.generateDuplicateCodeBlockMessage(block,entry.getValue());
      String fqName=Utilities.relativeFileNameToFqName(block.getElementName());
      saveViolation(rule,null,fqName,block.getStartLine(),message);
    }
  }
}","void handleDuplicateCodeBlocks(XsdWarningsByAttributeGroup warningGroup,Rule rule){
  LOG.debug(""String_Node_Str"");
  Map<Integer,List<DuplicateCodeBlock>> duplicateCodeBlocks=new HashMap<Integer,List<DuplicateCodeBlock>>();
  for (  XsdWarningsByAttribute warnings : warningGroup.getWarningsByAttribute()) {
    for (    XsdWarning warning : warnings.getWarning()) {
      DuplicateCodeBlock block=Utilities.createDuplicateCodeBlock(warning);
      if (null == block) {
        continue;
      }
      if (!duplicateCodeBlocks.containsKey(block.getBlockId())) {
        duplicateCodeBlocks.put(block.getBlockId(),new ArrayList<DuplicateCodeBlock>());
      }
      duplicateCodeBlocks.get(block.getBlockId()).add(block);
    }
  }
  for (  Entry<Integer,List<DuplicateCodeBlock>> entry : duplicateCodeBlocks.entrySet()) {
    for (    DuplicateCodeBlock block : entry.getValue()) {
      String message=Utilities.generateDuplicateCodeBlockMessage(block,entry.getValue());
      String fqName=Utilities.relativeFileNameToFqName(block.getElementName());
      saveViolation(rule,null,fqName,block.getStartLine(),message);
    }
  }
}",0.985663082437276
37010,"/** 
 * Unmarshals the Sonargraph Report into a ReportContext
 * @param reportFileName the file name of the Sonargraph Report to be opened
 * @return {@link ReportContext} if successful, null otherwise
 */
public static ReportContext readSonargraphReport(String reportFileName){
  ReportContext result=null;
  InputStream input=null;
  ClassLoader defaultClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    input=new FileInputStream(reportFileName);
    Thread.currentThread().setContextClassLoader(ReportFileReader.class.getClassLoader());
    JAXBContext context=JAXBContext.newInstance(""String_Node_Str"");
    Unmarshaller u=context.createUnmarshaller();
    result=(ReportContext)u.unmarshal(input);
  }
 catch (  JAXBException e) {
    LOG.error(""String_Node_Str"" + reportFileName,e);
  }
catch (  FileNotFoundException e) {
    LOG.error(""String_Node_Str"" + reportFileName + ""String_Node_Str"");
    LOG.error(""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    Thread.currentThread().setContextClassLoader(defaultClassLoader);
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"" + reportFileName,e);
      }
    }
  }
  return result;
}","/** 
 * Unmarshals the Sonargraph Report into a ReportContext
 * @param reportFileName the file name of the Sonargraph Report to be opened
 * @param isRoot specifies if this project is the root project or a module
 * @return {@link ReportContext} if successful, null otherwise
 */
public static ReportContext readSonargraphReport(String reportFileName,boolean isRoot){
  ReportContext result=null;
  InputStream input=null;
  ClassLoader defaultClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    input=new FileInputStream(reportFileName);
    Thread.currentThread().setContextClassLoader(ReportFileReader.class.getClassLoader());
    JAXBContext context=JAXBContext.newInstance(""String_Node_Str"");
    Unmarshaller u=context.createUnmarshaller();
    result=(ReportContext)u.unmarshal(input);
  }
 catch (  JAXBException e) {
    LOG.error(""String_Node_Str"" + reportFileName,e);
  }
catch (  FileNotFoundException e) {
    if (isRoot) {
      LOG.error(""String_Node_Str"" + reportFileName + ""String_Node_Str"");
      LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      LOG.error(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 finally {
    Thread.currentThread().setContextClassLoader(defaultClassLoader);
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"" + reportFileName,e);
      }
    }
  }
  return result;
}",0.9560761346998536
37011,"@SuppressWarnings(""String_Node_Str"") public void testAnalyse(){
  ReportContext report=ReportFileReader.readSonargraphReport(""String_Node_Str"");
  assertNotNull(report);
  final RuleFinder ruleFinder=mock(RuleFinder.class);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.TASK_RULE_KEY)).thenReturn(SonargraphRulesRepository.TASK);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.CYCLE_GROUP_RULE_KEY)).thenReturn(SonargraphRulesRepository.CYCLE_GROUPS);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.DUPLICATE_RULE_KEY)).thenReturn(SonargraphRulesRepository.DUPLICATES);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.ARCH_RULE_KEY)).thenReturn(SonargraphRulesRepository.ARCH);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.THRESHOLD_RULE_KEY)).thenReturn(SonargraphRulesRepository.THRESHOLD);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.WORKSPACE_RULE_KEY)).thenReturn(SonargraphRulesRepository.WORKSPACE);
  final Configuration config=mock(Configuration.class);
  when(config.getString(any(String.class),any(String.class))).thenAnswer(new Answer<String>(){
    public String answer(    InvocationOnMock invocationOnMock) throws Throwable {
      return (String)invocationOnMock.getArguments()[1];
    }
  }
);
  SonargraphSensor sensor=new SonargraphSensor(ruleFinder,config);
  final SensorContext sensorContext=mock(SensorContext.class);
  when(sensorContext.getResource(any(Resource.class))).thenAnswer(new Answer(){
    public Object answer(    InvocationOnMock invocation){
      Object[] args=invocation.getArguments();
      return args[0];
    }
  }
);
  when(sensorContext.getMeasure(any(Metric.class))).thenAnswer(new Answer(){
    public Object answer(    InvocationOnMock invocation){
      Object arg=invocation.getArguments()[0];
      Measure result=new Measure((Metric)arg);
      result.setValue(0.0);
      return result;
    }
  }
);
  sensor.setSensorContext(sensorContext);
  final IProject project=mock(IProject.class);
  when(project.getConfiguration()).thenReturn(config);
  when(project.getKey()).thenReturn(""String_Node_Str"");
  when(project.getName()).thenReturn(""String_Node_Str"");
  XsdAttributeRoot buildUnit=sensor.retrieveBuildUnit(project.getKey(),report);
  assertNotNull(buildUnit);
  sensor.analyseBuildUnit(report,buildUnit);
}","@SuppressWarnings(""String_Node_Str"") public void testAnalyse(){
  ReportContext report=ReportFileReader.readSonargraphReport(""String_Node_Str"",true);
  assertNotNull(report);
  final RuleFinder ruleFinder=mock(RuleFinder.class);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.TASK_RULE_KEY)).thenReturn(SonargraphRulesRepository.TASK);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.CYCLE_GROUP_RULE_KEY)).thenReturn(SonargraphRulesRepository.CYCLE_GROUPS);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.DUPLICATE_RULE_KEY)).thenReturn(SonargraphRulesRepository.DUPLICATES);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.ARCH_RULE_KEY)).thenReturn(SonargraphRulesRepository.ARCH);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.THRESHOLD_RULE_KEY)).thenReturn(SonargraphRulesRepository.THRESHOLD);
  when(ruleFinder.findByKey(SonargraphPluginBase.PLUGIN_KEY,SonargraphPluginBase.WORKSPACE_RULE_KEY)).thenReturn(SonargraphRulesRepository.WORKSPACE);
  final Configuration config=mock(Configuration.class);
  when(config.getString(any(String.class),any(String.class))).thenAnswer(new Answer<String>(){
    public String answer(    InvocationOnMock invocationOnMock) throws Throwable {
      return (String)invocationOnMock.getArguments()[1];
    }
  }
);
  SonargraphSensor sensor=new SonargraphSensor(ruleFinder,config);
  final SensorContext sensorContext=mock(SensorContext.class);
  when(sensorContext.getResource(any(Resource.class))).thenAnswer(new Answer(){
    public Object answer(    InvocationOnMock invocation){
      Object[] args=invocation.getArguments();
      return args[0];
    }
  }
);
  when(sensorContext.getMeasure(any(Metric.class))).thenAnswer(new Answer(){
    public Object answer(    InvocationOnMock invocation){
      Object arg=invocation.getArguments()[0];
      Measure result=new Measure((Metric)arg);
      result.setValue(0.0);
      return result;
    }
  }
);
  sensor.setSensorContext(sensorContext);
  final IProject project=mock(IProject.class);
  when(project.getConfiguration()).thenReturn(config);
  when(project.getKey()).thenReturn(""String_Node_Str"");
  when(project.getName()).thenReturn(""String_Node_Str"");
  XsdAttributeRoot buildUnit=sensor.retrieveBuildUnit(project.getKey(),report);
  assertNotNull(buildUnit);
  sensor.analyseBuildUnit(report,buildUnit);
}",0.9989905108015344
37012,"public static ReportContext initReport(){
  ReportContext report=ReportFileReader.readSonargraphReport(REPORT);
  assertNotNull(report);
  return report;
}","public static ReportContext initReport(){
  ReportContext report=ReportFileReader.readSonargraphReport(REPORT,false);
  assertNotNull(report);
  return report;
}",0.981012658227848
37013,"@Test public void testAnalyse(){
  Project project=TestHelper.initProject();
  sensor.analyse(project,sensorContext);
}","@Test public void testAnalyse(){
  Project project=new Project(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  project.setConfiguration(TestHelper.initConfig());
  sensor.analyse(project,sensorContext);
  double value=sensorContext.getMeasure(SonargraphSystemMetrics.WORKSPACE_WARNINGS).getValue().doubleValue();
  assertEquals(0.0,value,0.01);
}",0.2989473684210526
37014,"/** 
 * Test method for   {@link com.hello2morrow.sonarplugin.foundation.ReportFileReader#readSonargraphReport(java.lang.String)}.
 */
@Test public void testReadSonargraphReport(){
  assertNotNull(ReportFileReader.readSonargraphReport(reportFileName));
  assertNull(ReportFileReader.readSonargraphReport(""String_Node_Str""));
}","/** 
 * Test method for   {@link com.hello2morrow.sonarplugin.foundation.ReportFileReader#readSonargraphReport(java.lang.String)}.
 */
@Test public void testReadSonargraphReport(){
  assertNotNull(ReportFileReader.readSonargraphReport(reportFileName,false));
  assertNull(ReportFileReader.readSonargraphReport(""String_Node_Str"",false));
}",0.9819277108433736
37015,"public Build addRequestParams(String key,String value){
  return this;
}","public Build addRequestParams(String key,Object value){
  if (requestParams == null) {
    requestParams=new HashMap<String,Object>();
  }
  requestParams.put(key,value);
  return this;
}",0.5173745173745173
37016,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) protected Version checkUpdateInTask(ContextWrapper wrapper){
  log.debug(""String_Node_Str"");
  Object response=null;
  AppUpdateServiceConfiguration config=wrapper.getConfiguration();
  ResponseDelivery responseDelivery=config.getResponseDelivery();
  RequestInfo info=config.getRequestInfo();
  try {
    wrapper.append(""String_Node_Str"");
    response=responseDelivery.submitRequest(info);
    log.trace(""String_Node_Str"" + response.toString());
  }
 catch (  IOException exp) {
    log.error(""String_Node_Str"",exp);
    wrapper.setRequestError(true);
    wrapper.append(""String_Node_Str"");
  }
  Version version=null;
  if (response != null) {
    try {
      wrapper.append(""String_Node_Str"");
      version=responseDelivery.parserResponse(response);
      log.trace(""String_Node_Str"" + version.toString());
    }
 catch (    Exception exp) {
      log.error(""String_Node_Str"",exp);
      wrapper.setParserResponseError(true);
      wrapper.append(""String_Node_Str"");
    }
  }
 else {
    log.trace(""String_Node_Str"");
    wrapper.append(""String_Node_Str"");
  }
  wrapper.setVersion(version);
  return version;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) protected Version checkUpdateInTask(ContextWrapper wrapper){
  log.debug(""String_Node_Str"");
  Object response=null;
  AppUpdateServiceConfiguration config=wrapper.getConfiguration();
  ResponseDelivery responseDelivery=config.getResponseDelivery();
  RequestInfo info=config.getRequestInfo();
  try {
    wrapper.append(""String_Node_Str"");
    response=responseDelivery.submitRequest(info);
  }
 catch (  Throwable exp) {
    log.error(""String_Node_Str"",exp);
    wrapper.setRequestError(true);
    wrapper.append(""String_Node_Str"");
  }
  Version version=null;
  if (response != null) {
    try {
      wrapper.append(""String_Node_Str"");
      version=responseDelivery.parserResponse(response);
      log.trace(""String_Node_Str"" + version.toString());
    }
 catch (    Exception exp) {
      log.error(""String_Node_Str"",exp);
      wrapper.setParserResponseError(true);
      wrapper.append(""String_Node_Str"");
    }
  }
 else {
    log.trace(""String_Node_Str"");
    wrapper.append(""String_Node_Str"");
  }
  wrapper.setVersion(version);
  return version;
}",0.5580786026200873
37017,"@Override public String submitRequest(RequestInfo requestInfo) throws IOException {
  log.debug(""String_Node_Str"");
  String updateUrl=requestInfo.getUpdateUrl();
  StringBuilder builder=new StringBuilder(updateUrl);
  Map<String,Object> requestParams=requestInfo.getRequestParams();
  if (requestParams != null && requestParams.size() > 0) {
    builder.append(updateUrl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    for (    String key : requestParams.keySet()) {
      builder.append(key).append(""String_Node_Str"").append(String.valueOf(requestParams.get(key)));
      builder.append(""String_Node_Str"");
    }
    builder.deleteCharAt(builder.length() - 1);
  }
  URL targetUrl=new URL(builder.toString());
  log.trace(""String_Node_Str"" + builder.toString());
  HttpURLConnection connection=(HttpURLConnection)targetUrl.openConnection();
  connection.setDefaultUseCaches(false);
  connection.setConnectTimeout(5 * 60 * 1000);
  connection.setReadTimeout(5 * 60 * 1000);
  try {
    connection.setRequestMethod(requestInfo.getMethod());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  Map<String,Object> headers=requestInfo.getRequestHeaders();
  if (headers != null) {
    for (    String key : headers.keySet()) {
      connection.addRequestProperty(key,String.valueOf(headers.get(key)));
    }
  }
  InputStream is=connection.getInputStream();
  String response=toStringBuffer(is).toString();
  log.trace(""String_Node_Str"" + response);
  is.close();
  connection.disconnect();
  return response;
}","@Override public String submitRequest(RequestInfo requestInfo) throws IOException {
  log.debug(""String_Node_Str"");
  String updateUrl=requestInfo.getUpdateUrl();
  StringBuilder builder=new StringBuilder(updateUrl);
  Map<String,Object> requestParams=requestInfo.getRequestParams();
  if (requestParams != null && requestParams.size() > 0) {
    builder.append(updateUrl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    for (    String key : requestParams.keySet()) {
      builder.append(URLEncoder.encode(key,CHARSET_NAME));
      builder.append(""String_Node_Str"");
      builder.append(URLEncoder.encode(String.valueOf(requestParams.get(key)),CHARSET_NAME));
      builder.append(""String_Node_Str"");
    }
    builder.deleteCharAt(builder.length() - 1);
  }
  URL targetUrl=new URL(builder.toString());
  log.trace(""String_Node_Str"" + builder.toString());
  HttpURLConnection connection=(HttpURLConnection)targetUrl.openConnection();
  connection.setDefaultUseCaches(false);
  connection.setConnectTimeout(5 * 60 * 1000);
  connection.setReadTimeout(5 * 60 * 1000);
  try {
    connection.setRequestMethod(requestInfo.getMethod());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  Map<String,Object> headers=requestInfo.getRequestHeaders();
  if (headers != null) {
    for (    String key : headers.keySet()) {
      connection.addRequestProperty(key,String.valueOf(headers.get(key)));
    }
  }
  InputStream is=connection.getInputStream();
  String response=toStringBuffer(is).toString();
  log.trace(""String_Node_Str"" + response);
  is.close();
  connection.disconnect();
  return response;
}",0.9657747355320472
37018,"public Version parserResponse(String response) throws Exception {
  log.debug(""String_Node_Str"");
  Version version=null;
  try {
    response=response.substring(response.indexOf(""String_Node_Str""),response.lastIndexOf(""String_Node_Str"") + 1);
    log.trace(""String_Node_Str"" + response);
    JSONObject json=new JSONObject(response);
    if (json.has(ROOT_NODE) && !json.isNull(ROOT_NODE)) {
      log.trace(""String_Node_Str"");
      json=json.getJSONObject(ROOT_NODE);
    }
    version=new Version();
    version.setApp(json.getString(""String_Node_Str""));
    version.setCode(json.getInt(""String_Node_Str""));
    version.setName(json.getString(""String_Node_Str""));
    version.setTitle(json.getString(""String_Node_Str""));
    version.setDescription(json.getString(""String_Node_Str""));
    version.setReleaseTime(new Date(json.getLong(""String_Node_Str"")));
    version.setTargetUrl(json.getString(""String_Node_Str""));
    version.setMD5(json.getString(""String_Node_Str""));
    version.setSHA1(json.getString(""String_Node_Str""));
  }
 catch (  JSONException e) {
    log.warning(""String_Node_Str"",e);
    version=null;
  }
  return version;
}","public Version parserResponse(String response) throws Exception {
  log.debug(""String_Node_Str"");
  Version version=null;
  try {
    response=response.substring(response.indexOf(""String_Node_Str""),response.lastIndexOf(""String_Node_Str"") + 1);
    JSONObject json=new JSONObject(response);
    if (json.has(ROOT_NODE) && !json.isNull(ROOT_NODE)) {
      log.trace(""String_Node_Str"");
      json=json.getJSONObject(ROOT_NODE);
    }
    version=new Version();
    version.setApp(json.getString(""String_Node_Str""));
    version.setCode(json.getInt(""String_Node_Str""));
    version.setName(json.getString(""String_Node_Str""));
    version.setTitle(json.getString(""String_Node_Str""));
    version.setDescription(json.getString(""String_Node_Str""));
    version.setReleaseTime(new Date(json.getLong(""String_Node_Str"")));
    version.setTargetUrl(json.getString(""String_Node_Str""));
    version.setMD5(json.getString(""String_Node_Str""));
    version.setSHA1(json.getString(""String_Node_Str""));
  }
 catch (  JSONException e) {
    log.warning(""String_Node_Str"",e);
    version=null;
  }
  return version;
}",0.9799196787148594
37019,"/** 
 * Process count value according to SCIM 2.0 specification
 * @param countStr
 * @return
 * @throws BadRequestException
 */
public static int processCount(String countStr) throws BadRequestException {
  int count=0;
  if (countStr == null) {
    count=CharonConfiguration.getInstance().getCountValueForPagination();
  }
  try {
    count=Integer.parseInt(countStr);
  }
 catch (  NumberFormatException e) {
    throw new BadRequestException(""String_Node_Str"");
  }
  if (count < 0) {
    count=0;
  }
  return count;
}","/** 
 * Process count value according to SCIM 2.0 specification
 * @param countStr
 * @return
 * @throws BadRequestException
 */
public static int processCount(String countStr) throws BadRequestException {
  int count;
  if (countStr == null || countStr.isEmpty()) {
    count=CharonConfiguration.getInstance().getCountValueForPagination();
  }
 else {
    try {
      count=Integer.parseInt(countStr);
    }
 catch (    NumberFormatException e) {
      throw new BadRequestException(""String_Node_Str"");
    }
  }
  if (count < 0) {
    count=0;
  }
  return count;
}",0.4146788990825688
37020,"/** 
 * Method to list the groups at the /Groups endpoint
 * @param userManager
 * @param filter
 * @param startIndex
 * @param count
 * @param sortBy
 * @param sortOrder
 * @param attributes
 * @param excludeAttributes
 * @return
 */
@Override public SCIMResponse listWithGET(UserManager userManager,String filter,int startIndex,int count,String sortBy,String sortOrder,String attributes,String excludeAttributes){
  FilterTreeManager filterTreeManager=null;
  Node rootNode=null;
  JSONEncoder encoder=null;
  try {
    if (startIndex < 1) {
      startIndex=1;
    }
    if (count == 0) {
      count=CharonConfiguration.getInstance().getCountValueForPagination();
    }
    if (sortOrder != null) {
      if (!(sortOrder.equalsIgnoreCase(SCIMConstants.OperationalConstants.ASCENDING) || sortOrder.equalsIgnoreCase(SCIMConstants.OperationalConstants.DESCENDING))) {
        String error=""String_Node_Str"";
        throw new BadRequestException(error,ResponseCodeConstants.INVALID_VALUE);
      }
    }
    if (sortOrder == null && sortBy != null) {
      sortOrder=SCIMConstants.OperationalConstants.ASCENDING;
    }
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getUserResourceSchema();
    if (filter != null) {
      filterTreeManager=new FilterTreeManager(filter,schema);
      rootNode=filterTreeManager.buildTree();
    }
    encoder=getEncoder();
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    List<Object> returnedGroups;
    int totalResults=0;
    if (userManager != null) {
      List<Object> tempList=userManager.listGroupsWithGET(rootNode,startIndex,count,sortBy,sortOrder,requiredAttributes);
      totalResults=(int)tempList.get(0);
      tempList.remove(0);
      returnedGroups=tempList;
      if (returnedGroups.isEmpty()) {
        String error=""String_Node_Str"";
        throw new NotFoundException(error);
      }
      for (      Object group : returnedGroups) {
        ServerSideValidator.validateRetrievedSCIMObjectInList((Group)group,SCIMSchemaDefinitions.SCIM_GROUP_SCHEMA,attributes,excludeAttributes);
      }
      ListedResource listedResource=createListedResource(returnedGroups,startIndex,totalResults);
      String encodedListedResource=encoder.encodeSCIMObject(listedResource);
      Map<String,String> responseHeaders=new HashMap<String,String>();
      responseHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
      return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedListedResource,responseHeaders);
    }
 else {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
  }
 catch (  CharonException e) {
    return encodeSCIMException(e);
  }
catch (  NotFoundException e) {
    return encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return encodeSCIMException(e);
  }
catch (  IOException e) {
    String error=""String_Node_Str"";
    CharonException charonException=new CharonException(error);
    return AbstractResourceManager.encodeSCIMException(charonException);
  }
}","/** 
 * Method to list the groups at the /Groups endpoint
 * @param userManager
 * @param filter
 * @param startIndex
 * @param count
 * @param sortBy
 * @param sortOrder
 * @param attributes
 * @param excludeAttributes
 * @return
 */
@Override public SCIMResponse listWithGET(UserManager userManager,String filter,int startIndex,int count,String sortBy,String sortOrder,String attributes,String excludeAttributes){
  FilterTreeManager filterTreeManager=null;
  Node rootNode=null;
  JSONEncoder encoder=null;
  try {
    if (startIndex < 1) {
      startIndex=1;
    }
    if (count == 0) {
      count=CharonConfiguration.getInstance().getCountValueForPagination();
    }
    if (sortOrder != null) {
      if (!(sortOrder.equalsIgnoreCase(SCIMConstants.OperationalConstants.ASCENDING) || sortOrder.equalsIgnoreCase(SCIMConstants.OperationalConstants.DESCENDING))) {
        String error=""String_Node_Str"";
        throw new BadRequestException(error,ResponseCodeConstants.INVALID_VALUE);
      }
    }
    if (sortOrder == null && sortBy != null) {
      sortOrder=SCIMConstants.OperationalConstants.ASCENDING;
    }
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getGroupResourceSchema();
    if (filter != null) {
      filterTreeManager=new FilterTreeManager(filter,schema);
      rootNode=filterTreeManager.buildTree();
    }
    encoder=getEncoder();
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    List<Object> returnedGroups;
    int totalResults=0;
    if (userManager != null) {
      List<Object> tempList=userManager.listGroupsWithGET(rootNode,startIndex,count,sortBy,sortOrder,requiredAttributes);
      totalResults=(int)tempList.get(0);
      tempList.remove(0);
      returnedGroups=tempList;
      if (returnedGroups.isEmpty()) {
        String error=""String_Node_Str"";
        throw new NotFoundException(error);
      }
      for (      Object group : returnedGroups) {
        ServerSideValidator.validateRetrievedSCIMObjectInList((Group)group,SCIMSchemaDefinitions.SCIM_GROUP_SCHEMA,attributes,excludeAttributes);
      }
      ListedResource listedResource=createListedResource(returnedGroups,startIndex,totalResults);
      String encodedListedResource=encoder.encodeSCIMObject(listedResource);
      Map<String,String> responseHeaders=new HashMap<String,String>();
      responseHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
      return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedListedResource,responseHeaders);
    }
 else {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
  }
 catch (  CharonException e) {
    return encodeSCIMException(e);
  }
catch (  NotFoundException e) {
    return encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return encodeSCIMException(e);
  }
catch (  IOException e) {
    String error=""String_Node_Str"";
    CharonException charonException=new CharonException(error);
    return AbstractResourceManager.encodeSCIMException(charonException);
  }
}",0.9986447824122872
37021,"/** 
 * Decode BulkRequestData Json Sting.
 * @param bulkResourceString
 * @return BulkRequestData Object
 */
public BulkRequestData decodeBulkData(String bulkResourceString) throws BadRequestException {
  BulkRequestData bulkRequestDataObject=new BulkRequestData();
  List<BulkRequestContent> usersEndpointOperationList=new ArrayList<BulkRequestContent>();
  List<BulkRequestContent> groupsEndpointOperationList=new ArrayList<BulkRequestContent>();
  int failOnErrorsAttribute=0;
  List<String> schemas=new ArrayList<String>();
  JSONObject decodedObject=null;
  try {
    decodedObject=new JSONObject(new JSONTokener(bulkResourceString));
    JSONArray membersAttributeSchemas=(JSONArray)decodedObject.opt(SCIMConstants.CommonSchemaConstants.SCHEMAS);
    for (int i=0; i < membersAttributeSchemas.length(); i++) {
      schemas.add(membersAttributeSchemas.get(i).toString());
    }
    bulkRequestDataObject.setSchemas(schemas);
    JSONArray membersAttributeOperations=(JSONArray)decodedObject.opt(SCIMConstants.OperationalConstants.OPERATIONS);
    for (int i=0; i < membersAttributeOperations.length(); i++) {
      JSONObject member=(JSONObject)membersAttributeOperations.get(i);
      String requestType=member.optString(SCIMConstants.OperationalConstants.PATH);
      if (requestType.equals(null)) {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
      String requestMethod=member.optString(SCIMConstants.OperationalConstants.METHOD);
      if (requestMethod.equals(null)) {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
      String requestVersion=member.optString(SCIMConstants.OperationalConstants.VERSION);
      if (requestMethod.equals(SCIMConstants.OperationalConstants.POST)) {
        if (!member.optString(SCIMConstants.OperationalConstants.BULK_ID).equals(""String_Node_Str"") && !member.optString(SCIMConstants.OperationalConstants.BULK_ID).equals(null)) {
          setRequestData(requestType,requestMethod,requestVersion,member,usersEndpointOperationList,groupsEndpointOperationList);
        }
 else {
          String error=""String_Node_Str"" + ""String_Node_Str"";
          logger.error(error);
          throw new BadRequestException(error,ResponseCodeConstants.INVALID_VALUE);
        }
      }
 else {
        setRequestData(requestType,requestMethod,requestVersion,member,usersEndpointOperationList,groupsEndpointOperationList);
      }
    }
    failOnErrorsAttribute=decodedObject.optInt(SCIMConstants.OperationalConstants.FAIL_ON_ERRORS);
    bulkRequestDataObject.setFailOnErrors(failOnErrorsAttribute);
    bulkRequestDataObject.setUserOperationRequests(usersEndpointOperationList);
    bulkRequestDataObject.setGroupOperationRequests(groupsEndpointOperationList);
  }
 catch (  JSONException e1) {
    String error=""String_Node_Str"";
    logger.error(error);
    throw new BadRequestException(ResponseCodeConstants.INVALID_SYNTAX);
  }
  return bulkRequestDataObject;
}","/** 
 * Decode BulkRequestData Json Sting.
 * @param bulkResourceString
 * @return BulkRequestData Object
 */
public BulkRequestData decodeBulkData(String bulkResourceString) throws BadRequestException {
  BulkRequestData bulkRequestDataObject=new BulkRequestData();
  List<BulkRequestContent> usersEndpointOperationList=new ArrayList<BulkRequestContent>();
  List<BulkRequestContent> groupsEndpointOperationList=new ArrayList<BulkRequestContent>();
  int failOnErrorsAttribute=0;
  List<String> schemas=new ArrayList<String>();
  JSONObject decodedObject=null;
  try {
    decodedObject=new JSONObject(new JSONTokener(bulkResourceString));
    JSONArray membersAttributeSchemas=(JSONArray)decodedObject.opt(SCIMConstants.CommonSchemaConstants.SCHEMAS);
    for (int i=0; i < membersAttributeSchemas.length(); i++) {
      schemas.add(membersAttributeSchemas.get(i).toString());
    }
    bulkRequestDataObject.setSchemas(schemas);
    JSONArray membersAttributeOperations=(JSONArray)decodedObject.opt(SCIMConstants.OperationalConstants.OPERATIONS);
    for (int i=0; i < membersAttributeOperations.length(); i++) {
      JSONObject member=(JSONObject)membersAttributeOperations.get(i);
      String requestType=member.optString(SCIMConstants.OperationalConstants.PATH);
      if (requestType == null) {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
      String requestMethod=member.optString(SCIMConstants.OperationalConstants.METHOD);
      if (requestMethod == null) {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
      String requestVersion=member.optString(SCIMConstants.OperationalConstants.VERSION);
      if (requestMethod.equals(SCIMConstants.OperationalConstants.POST)) {
        if (!member.optString(SCIMConstants.OperationalConstants.BULK_ID).equals(""String_Node_Str"") && member.optString(SCIMConstants.OperationalConstants.BULK_ID) != null) {
          setRequestData(requestType,requestMethod,requestVersion,member,usersEndpointOperationList,groupsEndpointOperationList);
        }
 else {
          String error=""String_Node_Str"" + ""String_Node_Str"";
          logger.error(error);
          throw new BadRequestException(error,ResponseCodeConstants.INVALID_VALUE);
        }
      }
 else {
        setRequestData(requestType,requestMethod,requestVersion,member,usersEndpointOperationList,groupsEndpointOperationList);
      }
    }
    failOnErrorsAttribute=decodedObject.optInt(SCIMConstants.OperationalConstants.FAIL_ON_ERRORS);
    bulkRequestDataObject.setFailOnErrors(failOnErrorsAttribute);
    bulkRequestDataObject.setUserOperationRequests(usersEndpointOperationList);
    bulkRequestDataObject.setGroupOperationRequests(groupsEndpointOperationList);
  }
 catch (  JSONException e1) {
    String error=""String_Node_Str"";
    logger.error(error);
    throw new BadRequestException(ResponseCodeConstants.INVALID_SYNTAX);
  }
  return bulkRequestDataObject;
}",0.9893546240851632
37022,"/** 
 * Encode given bulkResponseData object and return the encoded string
 * @param bulkResponseData
 * @return
 */
public String encodeBulkResponseData(BulkResponseData bulkResponseData) throws InternalErrorException {
  String encodedString=""String_Node_Str"";
  List<BulkResponseContent> userResponseDataList=bulkResponseData.getUserOperationResponse();
  List<BulkResponseContent> groupResponseDataList=bulkResponseData.getGroupOperationResponse();
  JSONObject rootObject=new JSONObject();
  try {
    this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,bulkResponseData.getSchemas().toArray(),rootObject);
    ArrayList<JSONObject> operationResponseList=new ArrayList<>();
    for (    BulkResponseContent userOperationResponse : userResponseDataList) {
      encodeResponseContent(userOperationResponse,operationResponseList);
    }
    for (    BulkResponseContent groupOperationResponse : groupResponseDataList) {
      encodeResponseContent(groupOperationResponse,operationResponseList);
    }
    this.encodeArrayOfValues(SCIMConstants.OperationalConstants.OPERATIONS,operationResponseList.toArray(),rootObject);
    encodedString=rootObject.toString();
  }
 catch (  JSONException e) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  return encodedString;
}","public String encodeBulkResponseData(BulkResponseData bulkResponseData) throws InternalErrorException {
  String encodedString=""String_Node_Str"";
  List<BulkResponseContent> userResponseDataList=bulkResponseData.getUserOperationResponse();
  List<BulkResponseContent> groupResponseDataList=bulkResponseData.getGroupOperationResponse();
  JSONObject rootObject=new JSONObject();
  try {
    this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,bulkResponseData.getSchemas().toArray(),rootObject);
    ArrayList<JSONObject> operationResponseList=new ArrayList<>();
    for (    BulkResponseContent userOperationResponse : userResponseDataList) {
      encodeResponseContent(userOperationResponse,operationResponseList);
    }
    for (    BulkResponseContent groupOperationResponse : groupResponseDataList) {
      encodeResponseContent(groupOperationResponse,operationResponseList);
    }
    this.encodeArrayOfValues(SCIMConstants.OperationalConstants.OPERATIONS,operationResponseList.toArray(),rootObject);
    encodedString=rootObject.toString();
  }
 catch (  JSONException e) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  return encodedString;
}",0.9529175050301812
37023,"public SCIMResponse updateWithPATCH(String existingId,String scimObjectString,UserManager userManager,String attributes,String excludeAttributes){
  try {
    JSONDecoder decoder=getDecoder();
    JSONEncoder encoder=getEncoder();
    List<PatchOperation> opList=decoder.decodeRequest(scimObjectString);
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getGroupResourceSchema();
    Group oldGroup=userManager.getGroup(existingId,ResourceManagerUtil.getAllAttributeURIs(schema));
    if (oldGroup == null) {
      throw new NotFoundException(""String_Node_Str"" + existingId + ""String_Node_Str"");
    }
    Group copyOfOldGroup=(Group)CopyUtil.deepCopy(oldGroup);
    Group originalGroup=(Group)CopyUtil.deepCopy(copyOfOldGroup);
    Group newGroup=null;
    for (    PatchOperation operation : opList) {
      if (operation.getOperation().equals(SCIMConstants.OperationalConstants.ADD)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchAdd(operation,getDecoder(),oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchAdd(operation,getDecoder(),newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REMOVE)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchRemove(operation,oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchRemove(operation,newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REPLACE)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchReplace(operation,getDecoder(),oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchReplace(operation,getDecoder(),newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
    }
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    if (userManager != null) {
      if (oldGroup != null) {
        Group validatedGroup=(Group)ServerSideValidator.validateUpdatedSCIMObject(originalGroup,newGroup,schema);
        newGroup=userManager.updateGroup(originalGroup,validatedGroup,requiredAttributes);
      }
 else {
        String error=""String_Node_Str"" + existingId;
        throw new NotFoundException(error);
      }
    }
 else {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
    String encodedGroup;
    Map<String,String> httpHeaders=new HashMap<String,String>();
    if (newGroup != null) {
      Group copiedGroup=(Group)CopyUtil.deepCopy(newGroup);
      ServerSideValidator.validateReturnedAttributes(copiedGroup,attributes,excludeAttributes);
      encodedGroup=getEncoder().encodeSCIMObject(copiedGroup);
      httpHeaders.put(SCIMConstants.LOCATION_HEADER,getResourceEndpointURL(SCIMConstants.USER_ENDPOINT) + ""String_Node_Str"" + newGroup.getId());
      httpHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
    }
 else {
      String error=""String_Node_Str"";
      throw new CharonException(error);
    }
    return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedGroup,httpHeaders);
  }
 catch (  NotFoundException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  CharonException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  Exception e) {
    CharonException e1=new CharonException(""String_Node_Str"",e);
    return AbstractResourceManager.encodeSCIMException(e1);
  }
}","public SCIMResponse updateWithPATCH(String existingId,String scimObjectString,UserManager userManager,String attributes,String excludeAttributes){
  try {
    if (userManager == null) {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
    JSONDecoder decoder=getDecoder();
    List<PatchOperation> opList=decoder.decodeRequest(scimObjectString);
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getGroupResourceSchema();
    Group oldGroup=userManager.getGroup(existingId,ResourceManagerUtil.getAllAttributeURIs(schema));
    if (oldGroup == null) {
      throw new NotFoundException(""String_Node_Str"" + existingId + ""String_Node_Str"");
    }
    Group copyOfOldGroup=(Group)CopyUtil.deepCopy(oldGroup);
    Group originalGroup=(Group)CopyUtil.deepCopy(copyOfOldGroup);
    Group newGroup=null;
    for (    PatchOperation operation : opList) {
      if (operation.getOperation().equals(SCIMConstants.OperationalConstants.ADD)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchAdd(operation,getDecoder(),oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchAdd(operation,getDecoder(),newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REMOVE)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchRemove(operation,oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchRemove(operation,newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REPLACE)) {
        if (newGroup == null) {
          newGroup=(Group)PatchOperationUtil.doPatchReplace(operation,getDecoder(),oldGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
 else {
          newGroup=(Group)PatchOperationUtil.doPatchReplace(operation,getDecoder(),newGroup,copyOfOldGroup,schema);
          copyOfOldGroup=(Group)CopyUtil.deepCopy(newGroup);
        }
      }
 else {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
    }
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    Group validatedGroup=(Group)ServerSideValidator.validateUpdatedSCIMObject(originalGroup,newGroup,schema);
    newGroup=userManager.updateGroup(originalGroup,validatedGroup,requiredAttributes);
    String encodedGroup;
    Map<String,String> httpHeaders=new HashMap<String,String>();
    if (newGroup != null) {
      Group copiedGroup=(Group)CopyUtil.deepCopy(newGroup);
      ServerSideValidator.validateReturnedAttributes(copiedGroup,attributes,excludeAttributes);
      encodedGroup=getEncoder().encodeSCIMObject(copiedGroup);
      httpHeaders.put(SCIMConstants.LOCATION_HEADER,getResourceEndpointURL(SCIMConstants.USER_ENDPOINT) + ""String_Node_Str"" + newGroup.getId());
      httpHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
    }
 else {
      String error=""String_Node_Str"";
      throw new CharonException(error);
    }
    return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedGroup,httpHeaders);
  }
 catch (  NotFoundException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  CharonException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return AbstractResourceManager.encodeSCIMException(e);
  }
catch (  RuntimeException e) {
    CharonException e1=new CharonException(""String_Node_Str"",e);
    return AbstractResourceManager.encodeSCIMException(e1);
  }
}",0.9476427923844062
37024,"/** 
 * Update the user resource by sequence of operations.
 * @param existingId
 * @param scimObjectString
 * @param userManager
 * @param attributes
 * @param excludeAttributes
 * @return
 */
public SCIMResponse updateWithPATCH(String existingId,String scimObjectString,UserManager userManager,String attributes,String excludeAttributes){
  try {
    JSONDecoder decoder=getDecoder();
    JSONEncoder encoder=getEncoder();
    List<PatchOperation> opList=decoder.decodeRequest(scimObjectString);
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getUserResourceSchema();
    User oldUser=userManager.getMe(existingId,ResourceManagerUtil.getAllAttributeURIs(schema));
    if (oldUser == null) {
      throw new NotFoundException(""String_Node_Str"");
    }
    User copyOfOldUser=(User)CopyUtil.deepCopy(oldUser);
    User originalUser=(User)CopyUtil.deepCopy(copyOfOldUser);
    User newUser=null;
    for (    PatchOperation operation : opList) {
      if (operation.getOperation().equals(SCIMConstants.OperationalConstants.ADD)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchAdd(operation,getDecoder(),oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchAdd(operation,getDecoder(),newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REMOVE)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchRemove(operation,oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchRemove(operation,newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REPLACE)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchReplace(operation,getDecoder(),oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchReplace(operation,getDecoder(),newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
    }
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    if (userManager != null) {
      if (oldUser != null) {
        User validatedUser=(User)ServerSideValidator.validateUpdatedSCIMObject(originalUser,newUser,schema);
        newUser=userManager.updateMe(validatedUser,requiredAttributes);
      }
 else {
        String error=""String_Node_Str"" + existingId;
        throw new NotFoundException(error);
      }
    }
 else {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
    String encodedUser;
    Map<String,String> httpHeaders=new HashMap<String,String>();
    if (newUser != null) {
      User copiedUser=(User)CopyUtil.deepCopy(newUser);
      ServerSideValidator.validateReturnedAttributes(copiedUser,attributes,excludeAttributes);
      encodedUser=getEncoder().encodeSCIMObject(copiedUser);
      httpHeaders.put(SCIMConstants.LOCATION_HEADER,getResourceEndpointURL(SCIMConstants.USER_ENDPOINT) + ""String_Node_Str"" + newUser.getId());
      httpHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
    }
 else {
      String error=""String_Node_Str"";
      throw new CharonException(error);
    }
    return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedUser,httpHeaders);
  }
 catch (  NotFoundException e) {
    return encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return encodeSCIMException(e);
  }
catch (  CharonException e) {
    return encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return encodeSCIMException(e);
  }
catch (  Exception e) {
    CharonException e1=new CharonException(""String_Node_Str"",e);
    return encodeSCIMException(e1);
  }
}","/** 
 * Update the user resource by sequence of operations.
 * @param existingId
 * @param scimObjectString
 * @param userManager
 * @param attributes
 * @param excludeAttributes
 * @return
 */
public SCIMResponse updateWithPATCH(String existingId,String scimObjectString,UserManager userManager,String attributes,String excludeAttributes){
  try {
    if (userManager == null) {
      String error=""String_Node_Str"";
      throw new InternalErrorException(error);
    }
    JSONDecoder decoder=getDecoder();
    List<PatchOperation> opList=decoder.decodeRequest(scimObjectString);
    SCIMResourceTypeSchema schema=SCIMResourceSchemaManager.getInstance().getUserResourceSchema();
    User oldUser=userManager.getMe(existingId,ResourceManagerUtil.getAllAttributeURIs(schema));
    if (oldUser == null) {
      throw new NotFoundException(""String_Node_Str"");
    }
    User copyOfOldUser=(User)CopyUtil.deepCopy(oldUser);
    User originalUser=(User)CopyUtil.deepCopy(copyOfOldUser);
    User newUser=null;
    for (    PatchOperation operation : opList) {
      if (operation.getOperation().equals(SCIMConstants.OperationalConstants.ADD)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchAdd(operation,getDecoder(),oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchAdd(operation,getDecoder(),newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REMOVE)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchRemove(operation,oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchRemove(operation,newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else       if (operation.getOperation().equals(SCIMConstants.OperationalConstants.REPLACE)) {
        if (newUser == null) {
          newUser=(User)PatchOperationUtil.doPatchReplace(operation,getDecoder(),oldUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
 else {
          newUser=(User)PatchOperationUtil.doPatchReplace(operation,getDecoder(),newUser,copyOfOldUser,schema);
          copyOfOldUser=(User)CopyUtil.deepCopy(newUser);
        }
      }
 else {
        throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_SYNTAX);
      }
    }
    Map<String,Boolean> requiredAttributes=ResourceManagerUtil.getOnlyRequiredAttributesURIs((SCIMResourceTypeSchema)CopyUtil.deepCopy(schema),attributes,excludeAttributes);
    User validatedUser=(User)ServerSideValidator.validateUpdatedSCIMObject(originalUser,newUser,schema);
    newUser=userManager.updateMe(validatedUser,requiredAttributes);
    String encodedUser;
    Map<String,String> httpHeaders=new HashMap<String,String>();
    if (newUser != null) {
      User copiedUser=(User)CopyUtil.deepCopy(newUser);
      ServerSideValidator.validateReturnedAttributes(copiedUser,attributes,excludeAttributes);
      encodedUser=getEncoder().encodeSCIMObject(copiedUser);
      httpHeaders.put(SCIMConstants.LOCATION_HEADER,getResourceEndpointURL(SCIMConstants.USER_ENDPOINT) + ""String_Node_Str"" + newUser.getId());
      httpHeaders.put(SCIMConstants.CONTENT_TYPE_HEADER,SCIMConstants.APPLICATION_JSON);
    }
 else {
      String error=""String_Node_Str"";
      throw new CharonException(error);
    }
    return new SCIMResponse(ResponseCodeConstants.CODE_OK,encodedUser,httpHeaders);
  }
 catch (  NotFoundException e) {
    return encodeSCIMException(e);
  }
catch (  BadRequestException e) {
    return encodeSCIMException(e);
  }
catch (  NotImplementedException e) {
    return encodeSCIMException(e);
  }
catch (  CharonException e) {
    return encodeSCIMException(e);
  }
catch (  InternalErrorException e) {
    return encodeSCIMException(e);
  }
catch (  RuntimeException e) {
    CharonException e1=new CharonException(""String_Node_Str"",e);
    return encodeSCIMException(e1);
  }
}",0.9467851783446845
37025,"public String getExcludedAttributesAsString(){
  String excludedAttributes=null;
  StringBuffer str=new StringBuffer();
  for (  String attributeValue : this.excludedAttributes) {
    str.append(""String_Node_Str"").append(attributeValue);
  }
  excludedAttributes=str.toString();
  return excludedAttributes;
}","public String getExcludedAttributesAsString(){
  String excludedAttributes=null;
  StringBuffer str=new StringBuffer();
  for (  String attributeValue : this.excludedAttributes) {
    str.append(""String_Node_Str"").append(attributeValue);
  }
  excludedAttributes=str.toString();
  if (excludedAttributes.equals(""String_Node_Str"")) {
    return null;
  }
  return excludedAttributes;
}",0.8138528138528138
37026,"public String getAttributesAsString(){
  String attributes=null;
  StringBuffer str=new StringBuffer();
  for (  String attributeValue : this.attributes) {
    str.append(""String_Node_Str"").append(attributeValue);
  }
  attributes=str.toString();
  return attributes;
}","public String getAttributesAsString(){
  String attributes=null;
  StringBuffer str=new StringBuffer();
  for (  String attributeValue : this.attributes) {
    str.append(""String_Node_Str"").append(attributeValue);
  }
  attributes=str.toString();
  if (attributes.equals(""String_Node_Str"")) {
    return null;
  }
  return attributes;
}",0.8264462809917356
37027,"public SearchRequest decodeSearchRequestBody(String scimResourceString,SCIMResourceTypeSchema schema) throws BadRequestException {
  FilterTreeManager filterTreeManager=null;
  Node rootNode=null;
  try {
    JSONObject decodedJsonObj=new JSONObject(new JSONTokener(scimResourceString));
    SearchRequest searchRequest=new SearchRequest();
    ArrayList<String> attributes=new ArrayList<>();
    ArrayList<String> excludedAttributes=new ArrayList<>();
    JSONArray attributesValues=(JSONArray)decodedJsonObj.opt(SCIMConstants.OperationalConstants.ATTRIBUTES);
    JSONArray excludedAttributesValues=(JSONArray)decodedJsonObj.opt(SCIMConstants.OperationalConstants.EXCLUDED_ATTRIBUTES);
    JSONArray schemas=(JSONArray)decodedJsonObj.opt(SCIMConstants.CommonSchemaConstants.SCHEMAS);
    if (schemas.length() != 1) {
      throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_VALUE);
    }
    if (attributesValues != null) {
      for (int i=0; i < attributesValues.length(); i++) {
        attributes.add((String)attributesValues.get(i));
      }
    }
    if (excludedAttributesValues != null) {
      for (int i=0; i < excludedAttributesValues.length(); i++) {
        excludedAttributes.add((String)excludedAttributesValues.get(i));
      }
    }
    if (decodedJsonObj.optString(SCIMConstants.OperationalConstants.FILTER) != null) {
      filterTreeManager=new FilterTreeManager(decodedJsonObj.optString(SCIMConstants.OperationalConstants.FILTER),schema);
      rootNode=filterTreeManager.buildTree();
    }
    searchRequest.setAttributes(attributes);
    searchRequest.setExcludedAttributes(excludedAttributes);
    searchRequest.setSchema((String)schemas.get(0));
    searchRequest.setCount(decodedJsonObj.optInt(SCIMConstants.OperationalConstants.COUNT));
    searchRequest.setStartIndex(decodedJsonObj.optInt(SCIMConstants.OperationalConstants.START_INDEX));
    searchRequest.setFilter(rootNode);
    if (!decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_BY).equals(""String_Node_Str"")) {
      searchRequest.setSortBy(decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_BY));
    }
    if (!decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_ORDER).equals(""String_Node_Str"")) {
      searchRequest.setSortOder(decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_ORDER));
    }
    return searchRequest;
  }
 catch (  JSONException|IOException e) {
    logger.error(""String_Node_Str"");
    throw new BadRequestException(ResponseCodeConstants.INVALID_SYNTAX);
  }
}","public SearchRequest decodeSearchRequestBody(String scimResourceString,SCIMResourceTypeSchema schema) throws BadRequestException {
  FilterTreeManager filterTreeManager=null;
  Node rootNode=null;
  try {
    JSONObject decodedJsonObj=new JSONObject(new JSONTokener(scimResourceString));
    SearchRequest searchRequest=new SearchRequest();
    ArrayList<String> attributes=new ArrayList<>();
    ArrayList<String> excludedAttributes=new ArrayList<>();
    JSONArray attributesValues=(JSONArray)decodedJsonObj.opt(SCIMConstants.OperationalConstants.ATTRIBUTES);
    JSONArray excludedAttributesValues=(JSONArray)decodedJsonObj.opt(SCIMConstants.OperationalConstants.EXCLUDED_ATTRIBUTES);
    JSONArray schemas=(JSONArray)decodedJsonObj.opt(SCIMConstants.CommonSchemaConstants.SCHEMAS);
    if (schemas.length() != 1) {
      throw new BadRequestException(""String_Node_Str"",ResponseCodeConstants.INVALID_VALUE);
    }
    if (attributesValues != null) {
      for (int i=0; i < attributesValues.length(); i++) {
        attributes.add((String)attributesValues.get(i));
      }
    }
    if (excludedAttributesValues != null) {
      for (int i=0; i < excludedAttributesValues.length(); i++) {
        excludedAttributes.add((String)excludedAttributesValues.get(i));
      }
    }
    if (decodedJsonObj.opt(SCIMConstants.OperationalConstants.FILTER) != null) {
      filterTreeManager=new FilterTreeManager((String)decodedJsonObj.opt(SCIMConstants.OperationalConstants.FILTER),schema);
      rootNode=filterTreeManager.buildTree();
    }
    searchRequest.setAttributes(attributes);
    searchRequest.setExcludedAttributes(excludedAttributes);
    searchRequest.setSchema((String)schemas.get(0));
    searchRequest.setCount(decodedJsonObj.optInt(SCIMConstants.OperationalConstants.COUNT));
    searchRequest.setStartIndex(decodedJsonObj.optInt(SCIMConstants.OperationalConstants.START_INDEX));
    searchRequest.setFilter(rootNode);
    if (!decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_BY).equals(""String_Node_Str"")) {
      searchRequest.setSortBy(decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_BY));
    }
    if (!decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_ORDER).equals(""String_Node_Str"")) {
      searchRequest.setSortOder(decodedJsonObj.optString(SCIMConstants.OperationalConstants.SORT_ORDER));
    }
    return searchRequest;
  }
 catch (  JSONException|IOException e) {
    logger.error(""String_Node_Str"");
    throw new BadRequestException(ResponseCodeConstants.INVALID_SYNTAX);
  }
}",0.9960876369327074
37028,"public Group getGroup(String id,Map<String,Boolean> requiredAttributes) throws NotImplementedException, BadRequestException, CharonException ;","public Group getGroup(String id,Map<String,Boolean> requiredAttributes) throws NotImplementedException, BadRequestException, CharonException, NotFoundException ;",0.9372937293729372
37029,"/** 
 * Decode the listed resource sent in the payload of response for filter/retrieve requests.
 * @param scimString
 * @return
 * @throws CharonException
 */
public ListedResource decodeListedResource(String scimString,ResourceSchema resourceSchemaOfListedResource,AbstractSCIMObject scimObjectOfListedResource) throws CharonException, BadRequestException {
  ListedResource listedResource=null;
  try {
    JSONObject decodedJsonObj=new JSONObject(new JSONTokener(scimString));
    Object totalResults=decodedJsonObj.opt(SCIMConstants.ListedResourcesConstants.TOTAL_RESULTS);
    listedResource=new ListedResource();
    listedResource.setTotalResults((Integer)totalResults);
    Object resources=decodedJsonObj.opt(SCIMConstants.ListedResourcesConstants.RESOURCES);
    List<SCIMObject> scimObjects=new ArrayList<SCIMObject>();
    for (int i=0; i < (((JSONArray)resources).length()); i++) {
      String scimResourceString=((JSONArray)resources).getString(i);
      SCIMObject scimObject=this.decodeResource(scimResourceString,resourceSchemaOfListedResource,scimObjectOfListedResource);
      scimObjects.add(scimObject);
    }
    listedResource.setScimObjects(scimObjects);
  }
 catch (  JSONException e) {
    String error=""String_Node_Str"";
    throw new BadRequestException();
  }
  return listedResource;
}","/** 
 * Decode the listed resource sent in the payload of response for filter/retrieve requests.
 * @param scimString
 * @return
 * @throws CharonException
 */
public ListedResource decodeListedResource(String scimString,ResourceSchema resourceSchemaOfListedResource,AbstractSCIMObject scimObjectOfListedResource) throws CharonException, BadRequestException {
  ListedResource listedResource=null;
  try {
    JSONObject decodedJsonObj=new JSONObject(new JSONTokener(scimString));
    Object totalResults=decodedJsonObj.opt(SCIMConstants.ListedResourcesConstants.TOTAL_RESULTS);
    listedResource=new ListedResource();
    listedResource.setTotalResults((Integer)totalResults);
    Object resources=decodedJsonObj.opt(SCIMConstants.ListedResourcesConstants.RESOURCES);
    List<SCIMObject> scimObjects=new ArrayList<SCIMObject>();
    for (int i=0; i < (((JSONArray)resources).length()); i++) {
      Object object=((JSONArray)resources).get(i);
      String scimResourceString=null;
      if (object instanceof String) {
        scimResourceString=((JSONArray)resources).getString(i);
      }
 else       if (object instanceof JSONObject) {
        scimResourceString=((JSONArray)resources).getJSONObject(i).toString();
      }
      SCIMObject scimObject=this.decodeResource(scimResourceString,resourceSchemaOfListedResource,scimObjectOfListedResource);
      scimObjects.add(scimObject);
    }
    listedResource.setScimObjects(scimObjects);
  }
 catch (  JSONException e) {
    String error=""String_Node_Str"";
    throw new BadRequestException();
  }
  return listedResource;
}",0.884442911348741
37030,"public long getLargestPalindrome(long N){
  N--;
  if (Utils.isPalindrome(N)) {
    return N;
  }
 else {
    return getLargestPalindrome(N);
  }
}","public long getLargestPalindrome(long N){
  N--;
  if (Utils.isPalindrome(N)) {
    return N;
  }
 else {
    return getLargestPalindrome(N - 1);
  }
}",0.9865771812080536
37031,"public static long kthFac(int k,int n){
  long res=1;
  long limit=n;
  for (long i=2; i <= limit; i++) {
    res*=i;
    if (i == limit && k > 1) {
      k--;
      limit=res;
    }
  }
  return res;
}","public static long kthFac(int k,int n){
  long res=1;
  long limit=n;
  for (long i=2; i <= limit; i++) {
    res*=i;
    if (i == limit && k > 0) {
      k--;
      limit=res;
    }
  }
  return res;
}",0.995049504950495
37032,"@Test public void test(){
  assertEquals(1,FaultyProblem5.kthFac(0,1));
  assertEquals(2,FaultyProblem5.kthFac(1,2));
  assertEquals(720,FaultyProblem5.kthFac(3,3));
}","@Test public void test(){
  assertEquals(1,FaultyProblem5.kthFac(0,1));
  assertEquals(2,FaultyProblem5.kthFac(1,2));
  assertEquals(720,FaultyProblem5.kthFac(2,3));
}",0.994011976047904
37033,"@Test public void test(){
  assertEquals(1,FaultyProblem6.pow(1,999999999));
  assertEquals(8,FaultyProblem6.pow(2,3));
  assertEquals(16,FaultyProblem6.pow(2,4));
  assertEquals(4,FaultyProblem6.pow(4,0));
}","@Test public void test(){
  assertEquals(1,FaultyProblem6.pow(1,999999999));
  assertEquals(8,FaultyProblem6.pow(2,3));
  assertEquals(16,FaultyProblem6.pow(2,4));
  assertEquals(1,FaultyProblem6.pow(4,0));
}",0.8990384615384616
37034,"@Override public boolean onOptionsItemSelected(MenuItem item){
  boolean result=true;
switch (item.getItemId()) {
case R.id.action_itinerary:
    computeItinerary();
  result=false;
break;
case R.id.action_route:
computeOptimizedItinerary();
result=false;
break;
case R.id.action_locate_ext_poi:
locateExtPoi();
result=false;
break;
case R.id.action_clear_itinerary:
mItineraryRenderer.clear();
result=false;
break;
case R.id.action_clear_all:
mItineraryRenderer.clear();
mMapView.clearRenderer(GfxRto.class);
result=false;
break;
case R.id.action_information:
displayUIInformation();
result=false;
break;
case R.id.action_switch_site:
MainActivity act=(MainActivity)getActivity();
result=false;
break;
}
return result;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  boolean result=true;
switch (item.getItemId()) {
case R.id.action_itinerary:
    computeItinerary();
  result=false;
break;
case R.id.action_route:
computeOptimizedItinerary();
result=false;
break;
case R.id.action_locate_ext_poi:
locateExtPoi();
result=false;
break;
case R.id.action_clear_itinerary:
if (mItineraryRenderer != null) {
mItineraryRenderer.clear();
}
result=false;
break;
case R.id.action_clear_all:
if (mItineraryRenderer != null) {
mItineraryRenderer.clear();
}
mMapView.clearRenderer(GfxRto.class);
result=false;
break;
case R.id.action_information:
displayUIInformation();
result=false;
break;
case R.id.action_switch_site:
MainActivity act=(MainActivity)getActivity();
result=false;
break;
}
return result;
}",0.8811096433289299
37035,"/** 
 * This method shows how to compute an itinerary between two points
 */
private void computeItinerary(){
  mItineraryRenderer.setDisplayEnabled(false);
  ISPosition arrival=new ISPosition(mMapView.getMapId(),20,20);
  mItineraryProvider.requestItineraryFromCurrentLocation(arrival,true,this,PMR_ENABLED);
  if (!ISLocationProvider.getInstance().isStarted()) {
    startLocation();
  }
}","/** 
 * This method shows how to compute an itinerary between two points
 */
private void computeItinerary(){
  if (mItineraryRenderer != null) {
    mItineraryRenderer.setDisplayEnabled(false);
  }
  if (mItineraryProvider != null) {
    ISPosition arrival=new ISPosition(mMapView.getMapId(),20,20);
    mItineraryProvider.requestItineraryFromCurrentLocation(arrival,true,this,PMR_ENABLED);
  }
  if (!ISLocationProvider.getInstance().isStarted()) {
    startLocation();
  }
}",0.9009216589861752
37036,"/** 
 * This method shows how to compute a route between different positions
 */
private void computeOptimizedItinerary(){
  int positionNbr=4;
  ArrayList<ISPosition> pos=new ArrayList<ISPosition>();
  for (int i=0; i < positionNbr; i++) {
    double x=Math.random() * 50;
    double y=Math.random() * 50;
    if (mMaps.size() > 1 && i > positionNbr / 2) {
      ISMap otherMap=null;
      for (      ISMap map : mMaps) {
        if (map.getId() != mCurrentMap.getId()) {
          otherMap=map;
          break;
        }
      }
      if (otherMap != null) {
        ISPosition p=new ISPosition(otherMap.getId(),x,y);
        pos.add(p);
      }
    }
 else {
      ISPosition p=new ISPosition(mCurrentMap.getId(),x,y);
      pos.add(p);
    }
  }
  mItineraryProvider.requestOptimizedItinerary(pos,ISItineraryProvider.ISEOptimizationMode.NearestNeighbourShortestPath,true,false,this,false);
}","/** 
 * This method shows how to compute a route between different positions
 */
private void computeOptimizedItinerary(){
  int positionNbr=4;
  ArrayList<ISPosition> pos=new ArrayList<ISPosition>();
  for (int i=0; i < positionNbr; i++) {
    double x=Math.random() * 50;
    double y=Math.random() * 50;
    if (mMaps.size() > 1 && i > positionNbr / 2) {
      ISMap otherMap=null;
      for (      ISMap map : mMaps) {
        if (map.getId() != mCurrentMap.getId()) {
          otherMap=map;
          break;
        }
      }
      if (otherMap != null) {
        ISPosition p=new ISPosition(otherMap.getId(),x,y);
        pos.add(p);
      }
    }
 else {
      ISPosition p=new ISPosition(mCurrentMap.getId(),x,y);
      pos.add(p);
    }
  }
  if (mItineraryProvider != null) {
    mItineraryProvider.requestOptimizedItinerary(pos,ISItineraryProvider.ISEOptimizationMode.NearestNeighbourShortestPath,true,false,this,false);
  }
}",0.941112322791712
37037,"/** 
 * Callback for itinerary request completion
 * @param aSuccess true if the request was successful
 * @param aRequest the request object containing itinerary data
 * @param error an error object containing a code and a message, null if request was successful 
 */
@Override public void onItineraryRequestDone(boolean aSuccess,ISItineraryProvider.ISBaseRequest aRequest,final ISError error){
  if (aSuccess)   mItineraryRenderer.setDisplayEnabled(true);
 else {
    String message=getString(R.string.error_itinerary_computation_failed) + ""String_Node_Str"" + error;
    Crouton.makeText(getActivity(),message,Style.ALERT).show();
  }
}","/** 
 * Callback for itinerary request completion
 * @param aSuccess true if the request was successful
 * @param aRequest the request object containing itinerary data
 * @param error an error object containing a code and a message, null if request was successful 
 */
@Override public void onItineraryRequestDone(boolean aSuccess,ISItineraryProvider.ISBaseRequest aRequest,final ISError error){
  if (aSuccess) {
    if (mItineraryRenderer != null) {
      mItineraryRenderer.setDisplayEnabled(true);
    }
  }
 else {
    String message=getString(R.string.error_itinerary_computation_failed) + ""String_Node_Str"" + error;
    Crouton.makeText(getActivity(),message,Style.ALERT).show();
  }
}",0.956390977443609
37038,"protected void messageReceived(ChannelHandlerContext ctx,String msg) throws Exception {
  LOGGER.info(""String_Node_Str"",msg);
  if (StringUtils.isBlank(msg) || !StringUtils.equals(CMD_SHUTDOWN,msg)) {
    ChannelFuture future=ctx.writeAndFlush(""String_Node_Str"" + msg);
    future.addListener(ChannelFutureListener.CLOSE).channel().close();
    return;
  }
  ChannelFuture future=ctx.writeAndFlush(""String_Node_Str"");
  ctx.writeAndFlush(ManageServerInitializer.LINE_DELIMITER);
  LOGGER.info(""String_Node_Str"");
  Main.doShutdown();
  LOGGER.info(""String_Node_Str"");
  future.addListener(ChannelFutureListener.CLOSE).channel().close();
  LOGGER.info(""String_Node_Str"");
}","/** 
 * messageReceived.
 * @param ctx ctx.
 * @param msg msg.
 * @throws Exception Exception.
 */
protected void messageReceived(ChannelHandlerContext ctx,String msg) throws Exception {
  LOGGER.info(""String_Node_Str"",msg);
  if (StringUtils.isBlank(msg) || !StringUtils.equals(CMD_SHUTDOWN,msg)) {
    ChannelFuture future=ctx.writeAndFlush(""String_Node_Str"" + msg);
    future.addListener(ChannelFutureListener.CLOSE).channel().close();
    return;
  }
  ChannelFuture future=ctx.writeAndFlush(""String_Node_Str"");
  ctx.writeAndFlush(ManageServerInitializer.LINE_DELIMITER);
  LOGGER.info(""String_Node_Str"");
  Main.doShutdown();
  LOGGER.info(""String_Node_Str"");
  future.addListener(ChannelFutureListener.CLOSE).channel().close();
  LOGGER.info(""String_Node_Str"");
}",0.9313929313929314
37039,"/** 
 * run server.
 * @throws Exception Exception.
 */
public ChannelFuture start() throws Exception {
  ServerBootstrap bootstrap=new ServerBootstrap();
  bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(this.serverInitializer);
  serverChannelFuture=bootstrap.bind(port);
  return serverChannelFuture;
}","/** 
 * run server.
 * @return ChannelFuture.
 * @throws Exception Exception.
 */
public ChannelFuture start() throws Exception {
  ServerBootstrap bootstrap=new ServerBootstrap();
  bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(this.serverInitializer);
  serverChannelFuture=bootstrap.bind(port);
  return serverChannelFuture;
}",0.967741935483871
37040,"public void messageReceived(ChannelHandlerContext ctx,String request){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  String remoteAddr=socketAddress.getAddress().getHostAddress();
  LOGGER.info(""String_Node_Str"",remoteAddr);
  String response=StringUtils.EMPTY;
  if (ConnectionControlService.exceedRateLimit(remoteAddr)) {
    LOGGER.debug(""String_Node_Str"");
    response=get429Response();
    writeResponseAndcloseConnection(ctx,response);
    return;
  }
  if (request.isEmpty()) {
    response=""String_Node_Str"";
  }
 else {
    ProxyService proxyService=ProxyService.getInstance();
    try {
      response=proxyService.execute(request);
    }
 catch (    ServiceException e) {
      response=e.getMessage();
    }
catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",e);
      response=""String_Node_Str"";
    }
  }
  writeResponseAndcloseConnection(ctx,response);
}","/** 
 * messageReceived.
 * @param ctx ctx.
 * @param request request.
 */
public void messageReceived(ChannelHandlerContext ctx,String request){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  String remoteAddr=socketAddress.getAddress().getHostAddress();
  LOGGER.info(""String_Node_Str"",remoteAddr);
  String response=StringUtils.EMPTY;
  if (ConnectionControlService.exceedRateLimit(remoteAddr)) {
    LOGGER.debug(""String_Node_Str"");
    response=get429Response();
    writeResponseAndcloseConnection(ctx,response);
    return;
  }
  if (request.isEmpty()) {
    response=""String_Node_Str"";
  }
 else {
    ProxyService proxyService=ProxyService.getInstance();
    try {
      response=proxyService.execute(request);
    }
 catch (    ServiceException e) {
      response=e.getMessage();
    }
catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",e);
      response=""String_Node_Str"";
    }
  }
  writeResponseAndcloseConnection(ctx,response);
}",0.9609171443460136
37041,"/** 
 * main service method.This will parse command, construct URI and request RDAP server for JSON response, and then convert JSON result to text format.
 * @param commandStr commandStr.
 * @return query result.
 * @throws ServiceException ServiceException.
 */
public String execute(String commandStr) throws Exception {
  LOGGER.info(""String_Node_Str"",commandStr);
  String requestURI=StringUtils.EMPTY;
  try {
    Command command=CommandParser.parse(commandStr);
    requestURI=generateRequestURI(command);
    if (StringUtils.isBlank(requestURI)) {
      LOGGER.error(""String_Node_Str"");
      throw new ServiceException(""String_Node_Str"" + commandStr);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.error(""String_Node_Str"");
    requestURI=generateRequestURIForError();
  }
  RestResponse restResponse=RestClient.getInstance().execute(requestURI);
  if (null == restResponse || StringUtils.isBlank(restResponse.getBody())) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"" + commandStr);
  }
  Map jsonMap=JsonUtil.deserializateJsonToMap(restResponse);
  String result=ResponseFormater.format(jsonMap);
  return result;
}","/** 
 * main service method.This will parse command, construct URI and request RDAP server for JSON response, and then convert JSON result to text format.
 * @param commandStr commandStr.
 * @return query result.
 * @throws Exception Exception.
 */
public String execute(String commandStr) throws Exception {
  LOGGER.info(""String_Node_Str"",commandStr);
  String requestURI=StringUtils.EMPTY;
  try {
    Command command=CommandParser.parse(commandStr);
    requestURI=generateRequestURI(command);
    if (StringUtils.isBlank(requestURI)) {
      LOGGER.error(""String_Node_Str"");
      throw new ServiceException(""String_Node_Str"" + commandStr);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.error(""String_Node_Str"");
    requestURI=generateRequestURIForError();
  }
  RestResponse restResponse=RestClient.getInstance().execute(requestURI);
  if (null == restResponse || StringUtils.isBlank(restResponse.getBody())) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"" + commandStr);
  }
  Map jsonMap=JsonUtil.deserializateJsonToMap(restResponse);
  String result=ResponseFormater.format(jsonMap);
  return result;
}",0.9941569282136896
37042,"/** 
 * constructor with cause.
 */
public ServiceException(Throwable cause){
  super(cause);
}","/** 
 * constructor with cause.
 * @param cause cause.
 */
public ServiceException(Throwable cause){
  super(cause);
}",0.892018779342723
37043,"/** 
 * validate and format command.
 * @param commandStr commandStr.
 * @return formated command.
 * @throws ServiceException if validate error.
 */
private static String validateAndFormatCommandStr(String commandStr) throws ServiceException {
  if (StringUtils.isBlank(commandStr)) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"");
  }
  commandStr=StringUtils.trim(commandStr);
  if (StringUtils.isBlank(commandStr)) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"");
  }
  return commandStr;
}","/** 
 * validate and format command.
 * @param commandStr commandStr.
 * @return formated command.
 */
private static String validateAndFormatCommandStr(String commandStr){
  if (StringUtils.isBlank(commandStr)) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"");
  }
  commandStr=StringUtils.trim(commandStr);
  if (StringUtils.isBlank(commandStr)) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"");
  }
  return commandStr;
}",0.8907407407407407
37044,"/** 
 * parse command string to Command.
 * @param commandStr command string.
 * @return Command.
 * @throws ServiceException ServiceException.
 */
public static Command parse(String commandStr) throws ServiceException {
  LOGGER.debug(""String_Node_Str"",commandStr);
  commandStr=validateAndFormatCommandStr(commandStr);
  String[] commandSplits=StringUtils.split(commandStr);
  Options supportedOptions=initSupportedOptions();
  CommandLine line=null;
  CommandLineParser parser=new GnuParser();
  try {
    line=parser.parse(supportedOptions,commandSplits,false);
  }
 catch (  ParseException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new ServiceException(""String_Node_Str"");
  }
  return doParseCommand(line.getArgList());
}","/** 
 * parse command string to Command.
 * @param commandStr command string.
 * @return Command. ServiceException.
 */
@SuppressWarnings(""String_Node_Str"") public static Command parse(String commandStr){
  LOGGER.debug(""String_Node_Str"",commandStr);
  commandStr=validateAndFormatCommandStr(commandStr);
  String[] commandSplits=StringUtils.split(commandStr);
  Options supportedOptions=initSupportedOptions();
  CommandLine line=null;
  CommandLineParser parser=new GnuParser();
  try {
    line=parser.parse(supportedOptions,commandSplits,false);
  }
 catch (  ParseException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new ServiceException(""String_Node_Str"");
  }
  return doParseCommand(line.getArgList());
}",0.9384404924760602
37045,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_NAME=CommandOption.DOMAIN_SEARCH_BY_NAME.getOption();
  String OPTION_NSLDHNAME=CommandOption.DOMAIN_SEARCH_BY_NSLDHNAME.getOption();
  String OPTION_NSIP=CommandOption.DOMAIN_SEARCH_BY_NSIP.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_NSLDHNAME + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_NSLDHNAME);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_NSLDHNAME + ""String_Node_Str""+ argumentWithoutPrefix;
    System.out.println(uri);
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_NSIP + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_NSIP);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_NSIP + ""String_Node_Str""+ argumentWithoutPrefix;
  }
 else {
    uri=uri + OPTION_NAME + ""String_Node_Str""+ urlEncode(argumentList.get(0));
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String optionName=CommandOption.DOMAIN_SEARCH_BY_NAME.getOption();
  String optionNsLdhName=CommandOption.DOMAIN_SEARCH_BY_NSLDHNAME.getOption();
  String optionNsIp=CommandOption.DOMAIN_SEARCH_BY_NSIP.getOption();
  if (isPrefixedArgument(argumentList.get(0),optionNsLdhName + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),optionNsLdhName);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + optionNsLdhName + ""String_Node_Str""+ argumentWithoutPrefix;
    System.out.println(uri);
  }
 else   if (isPrefixedArgument(argumentList.get(0),optionNsIp + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),optionNsIp);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + optionNsIp + ""String_Node_Str""+ argumentWithoutPrefix;
  }
 else {
    uri=uri + optionName + ""String_Node_Str""+ urlEncode(argumentList.get(0));
  }
  return uri;
}",0.8957795004306632
37046,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_FN=CommandOption.ENTITY_SEARCH_FN.getOption();
  String OPTION_HANDLE=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_FN + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_FN);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_FN + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_HANDLE + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_HANDLE);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_HANDLE + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String optionFn=CommandOption.ENTITY_SEARCH_FN.getOption();
  String optionHandle=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),optionFn + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),optionFn);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + optionFn + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else   if (isPrefixedArgument(argumentList.get(0),optionHandle + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),optionHandle);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + optionHandle + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}",0.924
37047,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_IP=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String OPTION_NAME=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_IP + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_IP);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_IP + ""String_Node_Str""+ argumentWithoutPrefix;
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + OPTION_NAME + ""String_Node_Str""+ urlEncode(argumntList.get(0));
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String optionIp=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String optionName=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),optionIp + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),optionIp);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + optionIp + ""String_Node_Str""+ argumentWithoutPrefix;
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + optionName + ""String_Node_Str""+ urlEncode(argumntList.get(0));
  }
  return uri;
}",0.9372037914691944
37048,"/** 
 * write response for responseEntity.
 * @param responseEntity response entity for error message.
 * @param response HttpServletResponse.
 * @throws IOException IOException.
 */
public static void writeResponse(ResponseEntity responseEntity,HttpServletResponse response) throws IOException {
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpHeaders headers=responseEntity.getHeaders();
  Set<String> headerKeys=headers.keySet();
  for (  String headerKey : headerKeys) {
    List<String> headerValues=headers.get(headerKey);
    for (    String headerValue : headerValues) {
      response.setHeader(headerKey,headerValue);
    }
  }
  response.setCharacterEncoding(StringUtil.CHAR_SET_UTF8);
  PrintWriter writer=response.getWriter();
  response.setStatus(responseEntity.getStatusCode().value());
  String jsonStr=beanToJSON(responseEntity.getBody());
  writer.print(jsonStr);
}","/** 
 * write response for responseEntity.
 * @param responseEntity response entity for error message.
 * @param response HttpServletResponse.
 * @throws IOException IOException.
 */
public static void writeResponse(ResponseEntity responseEntity,HttpServletResponse response) throws IOException {
  response.setHeader(""String_Node_Str"",RdapProperties.RESPONSE_CONTENT_TYPE);
  HttpHeaders headers=responseEntity.getHeaders();
  Set<String> headerKeys=headers.keySet();
  for (  String headerKey : headerKeys) {
    List<String> headerValues=headers.get(headerKey);
    for (    String headerValue : headerValues) {
      response.setHeader(headerKey,headerValue);
    }
  }
  response.setCharacterEncoding(StringUtil.CHAR_SET_UTF8);
  PrintWriter writer=response.getWriter();
  response.setStatus(responseEntity.getStatusCode().value());
  String jsonStr=beanToJSON(responseEntity.getBody());
  writer.print(jsonStr);
}",0.9741616272677296
37049,"/** 
 * create error response.
 * @param errorStatus HttpStatus of error message
 * @return ResponseEntity
 */
public static ResponseEntity<ErrorMessage> createCommonErrorResponse(HttpStatus errorStatus){
  ErrorMessage errorMessage=getErrorMessageByErrorCode(errorStatus.toString());
  HttpHeaders headers=generateCrossOriginHeader();
  ResponseEntity<ErrorMessage> responseEntity=new ResponseEntity<ErrorMessage>(errorMessage,headers,errorStatus);
  queryFilterManager.postQuery(null,responseEntity,queryFilters);
  return responseEntity;
}","/** 
 * create error response.
 * @param errorStatus HttpStatus of error message
 * @return ResponseEntity
 */
public static ResponseEntity<ErrorMessage> createCommonErrorResponse(HttpStatus errorStatus){
  ErrorMessage errorMessage=getErrorMessageByErrorCode(errorStatus.toString());
  HttpHeaders headers=generateContentTypeAndCrossOriginHeader();
  ResponseEntity<ErrorMessage> responseEntity=new ResponseEntity<ErrorMessage>(errorMessage,headers,errorStatus);
  queryFilterManager.postQuery(null,responseEntity,queryFilters);
  return responseEntity;
}",0.9872495446265938
37050,"/** 
 * create response with HTTP status code 200.
 * @param response model T of response.
 * @param < T > a model
 * @return ResponseEntity<T> ResponseEntity model.
 */
public static <T>ResponseEntity<T> createResponse200(T response){
  HttpHeaders headers=generateCrossOriginHeader();
  return new ResponseEntity<T>(response,headers,HttpStatus.OK);
}","/** 
 * create response with HTTP status code 200.
 * @param response model T of response.
 * @param < T > a model
 * @return ResponseEntity<T> ResponseEntity model.
 */
public static <T>ResponseEntity<T> createResponse200(T response){
  HttpHeaders headers=generateContentTypeAndCrossOriginHeader();
  return new ResponseEntity<T>(response,headers,HttpStatus.OK);
}",0.98050139275766
37051,"@Override public void validate(QueryParam queryParam,ValidationResult validationResult){
  String q=queryParam.getQ();
  String[] splits=StringUtils.split(q,""String_Node_Str"");
  for (  String split : splits) {
    if (2 != StringUtils.indexOf(split,""String_Node_Str"")) {
      return;
    }
    if (!IdnaUtil.checkIfValidALabelDomain(q)) {
      validationResult.addError(QueryValidationError.build400Error());
      return;
    }
  }
}","@Override public void validate(QueryParam queryParam,ValidationResult validationResult){
  String q=queryParam.getQ();
  String[] splits=StringUtils.split(q,""String_Node_Str"");
  for (  String split : splits) {
    if (2 != StringUtils.indexOf(split,""String_Node_Str"")) {
      continue;
    }
    if (!IdnaUtil.checkIfValidALabelDomain(q)) {
      validationResult.addError(QueryValidationError.build400Error());
      return;
    }
  }
}",0.9840182648401826
37052,"protected Long findIdByHandle(final String handle,String idColumnName,String tableName){
  final String sql=String.format(TPL_FIND_ID_BY_HANDLE,idColumnName,tableName);
  LOGGER.debug(""String_Node_Str"",sql);
  List<Long> ids=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,handle);
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (ids.size() > 0) {
    return ids.get(0);
  }
  return null;
}","/** 
 * query id by handle.
 * @param handle handle.
 * @param idColumnName idColumnName.
 * @param tableName tableName.
 * @return id
 */
protected Long findIdByHandle(final String handle,String idColumnName,String tableName){
  final String sql=String.format(TPL_FIND_ID_BY_HANDLE,idColumnName,tableName);
  LOGGER.debug(""String_Node_Str"",sql);
  List<Long> ids=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,handle);
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (ids.size() > 0) {
    return ids.get(0);
  }
  return null;
}",0.912192040429564
37053,"protected void delete(final String ids,final String tableName,final String idColumnName){
  final String sql=String.format(TPL_DELETE_BY_ID,tableName,idColumnName,ids);
  jdbcTemplate.update(sql);
}","/** 
 * delete data.
 * @param ids ids.
 * @param tableName table name.
 * @param idColumnName idColumnName.
 */
protected void delete(final String ids,final String tableName,final String idColumnName){
  final String sql=String.format(TPL_DELETE_BY_ID,tableName,idColumnName,ids);
  jdbcTemplate.update(sql);
}",0.7779960707269156
37054,"protected void deleteRel(final BaseModel outerModel,String tableName){
  final String sql=String.format(TPL_DELETE_REL_BY_OUTERIDANDTYPE,tableName);
  jdbcTemplate.update(sql,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
    }
  }
);
}","/** 
 * delete relation.
 * @param outerModel outer object. 
 * @param tableName table name.
 */
protected void deleteRel(final BaseModel outerModel,String tableName){
  final String sql=String.format(TPL_DELETE_REL_BY_OUTERIDANDTYPE,tableName);
  jdbcTemplate.update(sql,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
    }
  }
);
}",0.8903954802259887
37055,"protected void saveStatus(final T model,final List<String> statusList,String tableName,String outerModelIdColumnName){
  final List<String> notEmptyStatusList=StringUtil.getNotEmptyStringList(statusList);
  if (notEmptyStatusList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  String sql=String.format(TPL_CREATE_STATUS,tableName,outerModelIdColumnName);
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyStatusList.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      ps.setLong(1,model.getId());
      ps.setString(2,notEmptyStatusList.get(i));
    }
  }
);
}","/** 
 * save status.
 * @param model object derived from BaseModel. 
 * @param statusList status list.
 * @param tableName table name.
 * @param outerModelIdColumnName outerModelIdColumnName.
 */
protected void saveStatus(final T model,final List<String> statusList,String tableName,String outerModelIdColumnName){
  final List<String> notEmptyStatusList=StringUtil.getNotEmptyStringList(statusList);
  if (notEmptyStatusList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  String sql=String.format(TPL_CREATE_STATUS,tableName,outerModelIdColumnName);
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyStatusList.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      ps.setLong(1,model.getId());
      ps.setString(2,notEmptyStatusList.get(i));
    }
  }
);
}",0.8790123456790123
37056,"protected void deleteStatus(final T model,String tableName,String modelIdColumnName){
  if (null == model || null == model.getId()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  String sql=String.format(TPL_DELETE_STATUS,tableName,modelIdColumnName);
  jdbcTemplate.update(sql,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setLong(1,model.getId());
    }
  }
);
}","/** 
 * delete status.
 * @param model object extends BaseModel.
 * @param tableName table name.
 * @param modelIdColumnName modelIdColumnName.
 */
protected void deleteStatus(final T model,String tableName,String modelIdColumnName){
  if (null == model || null == model.getId()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  String sql=String.format(TPL_DELETE_STATUS,tableName,modelIdColumnName);
  jdbcTemplate.update(sql,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setLong(1,model.getId());
    }
  }
);
}",0.8565891472868217
37057,"protected List<Long> findIdsByOuterIdAndType(final BaseModel outerModel,String idColumnName,String tableName){
  final String sql=String.format(TPL_FINDIDS_BY_OUTERIDANDTYPE,idColumnName,tableName);
  LOGGER.debug(""String_Node_Str"",sql);
  List<Long> ids=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (ids.size() > 0) {
    return ids;
  }
  return null;
}","/** 
 * query id by outer id and type.
 * @param outerModel outer object.
 * @param idColumnName idColumnName.
 * @param tableName tableName. 
 * @return  id list
 */
protected List<Long> findIdsByOuterIdAndType(final BaseModel outerModel,String idColumnName,String tableName){
  final String sql=String.format(TPL_FINDIDS_BY_OUTERIDANDTYPE,idColumnName,tableName);
  LOGGER.debug(""String_Node_Str"",sql);
  List<Long> ids=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (ids.size() > 0) {
    return ids;
  }
  return null;
}",0.9070673344462994
37058,void updateRel(BaseModel outerModel);,"/** 
 * update the relation between entity and other object.
 * @param outerModel outer object.
 */
void updateRel(BaseModel outerModel);",0.425287356321839
37059,"void saveAsInnerObjects(BaseModel outerModel,List<DTO> models);","/** 
 * save model list, as nested models of other Model.
 * @param outerModel outer object.
 * @param models object list.
 */
void saveAsInnerObjects(BaseModel outerModel,List<DTO> models);",0.4980237154150198
37060,"void updateAsInnerObjects(BaseModel outerModel,List<DTO> models);","/** 
 * update model list, as nested models of other Model.
 * @param outerModel outer object.
 * @param models object list.
 */
void updateAsInnerObjects(BaseModel outerModel,List<DTO> models);",0.5019305019305019
37061,T save(T model);,"/** 
 * save method.
 * @param model model.
 * @return object.
 */
T save(T model);",0.3232323232323232
37062,Long findIdByHandle(String handle);,"/** 
 * @param handle handle.
 * @return long
 */
Long findIdByHandle(String handle);",0.5833333333333334
37063,void update(T model);,"/** 
 * update method.
 * @param model model
 */
void update(T model);",0.4615384615384615
37064,void delete(T model);,"/** 
 * delete method.
 * @param model model.
 */
void delete(T model);",0.4565217391304347
37065,void deleteRel(BaseModel outerModel);,"/** 
 * delete the relation between entity and other object
 * @param outerModel outer object.
 */
void deleteRel(BaseModel outerModel);",0.4277456647398844
37066,void saveStatus(T model);,"/** 
 * save status.
 * @param model model.
 */
void saveStatus(T model);",0.5102040816326531
37067,void updateStatus(T model);,"/** 
 * update status.
 * @param model model.
 */
void updateStatus(T model);",0.5192307692307693
37068,void deleteStatus(T model);,"/** 
 * delete status.
 * @param model model.
 */
void deleteStatus(T model);",0.5192307692307693
37069,void deleteAsInnerObjects(BaseModel outerModel);,"/** 
 * delete model list, as nested models of other Model.
 * @param outerModel outer object.
 */
void deleteAsInnerObjects(BaseModel outerModel);",0.4923076923076923
37070,void saveRel(BaseModel outerModel);,"/** 
 * save the relation between entity and other object.
 * @param outerModel outer object.
 */
void saveRel(BaseModel outerModel);",0.4166666666666667
37071,"/** 
 * check if is update URI.
 * @param uri URI.
 * @return true if is update URI, false if not.
 */
public static boolean isUpdateUri(HttpServletRequest request){
  String uri=request.getRequestURI();
  String contextPath=request.getContextPath();
  if (StringUtils.equals(contextPath,""String_Node_Str"")) {
    contextPath=StringUtils.EMPTY;
  }
  return StringUtils.startsWith(uri,contextPath + ""String_Node_Str"");
}","/** 
 * check if is update URI.
 * @param request HttpServletRequest.
 * @return true if is update URI, false if not.
 */
public static boolean isUpdateUri(HttpServletRequest request){
  String uri=request.getRequestURI();
  String contextPath=request.getContextPath();
  if (StringUtils.equals(contextPath,""String_Node_Str"")) {
    contextPath=StringUtils.EMPTY;
  }
  return StringUtils.startsWith(uri,contextPath + ""String_Node_Str"");
}",0.9615832363213038
37072,"/** 
 * create autnum.
 * @param autnumDto autnumDto
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody AutnumDto autnumDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(autnumDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * create as number.
 * @param autnumDto autnumDto
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody AutnumDto autnumDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(autnumDto);
  return RestResponse.createUpdateResponse(response);
}",0.9613899613899614
37073,"/** 
 * update autnum.
 * @param autnumDto autnumDto
 * @param handle handle
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody AutnumDto autnumDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  autnumDto.setHandle(handle);
  UpdateResponse response=updateService.execute(autnumDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * update as number.
 * @param autnumDto autnumDto
 * @param handle handle
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody AutnumDto autnumDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  autnumDto.setHandle(handle);
  UpdateResponse response=updateService.execute(autnumDto);
  return RestResponse.createUpdateResponse(response);
}",0.9666666666666668
37074,"/** 
 * delete autnum.
 * @param handle handle
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  AutnumDto dto=new AutnumDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * delete as number.
 * @param handle handle
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  AutnumDto dto=new AutnumDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}",0.964349376114082
37075,"/** 
 * @param typeStr typeStr.
 * @param fieldName fieldName.
 * @param validationResult validationResult.
 */
protected void checkDomainTypeNotEmptyAndValid(String typeStr,ValidationResult validationResult){
  String fieldName=""String_Node_Str"";
  checkNotEmpty(typeStr,fieldName,validationResult);
  checkDomainTypeValid(typeStr,fieldName,validationResult);
}","/** 
 * @param typeStr typeStr.
 * @param validationResult validationResult.
 */
protected void checkDomainTypeNotEmptyAndValid(String typeStr,ValidationResult validationResult){
  String fieldName=""String_Node_Str"";
  checkNotEmpty(typeStr,fieldName,validationResult);
  checkDomainTypeValid(typeStr,fieldName,validationResult);
}",0.9552669552669552
37076,"/** 
 * extract telephone from ResultSet.
 * @param rs ResultSet.
 * @param entityTel entityTel.
 * @return EntityTelephone EntityTelephone.
 * @throws SQLException SQLException.
 */
private EntityTelephone extractEntityTelFromRs(ResultSet rs) throws SQLException {
  EntityTelephone telephone=EntityTelephone.buildTextTel(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""));
  telephone.setTypes(rs.getString(""String_Node_Str""));
  telephone.setPref(getIntegerFromRs(rs,""String_Node_Str""));
  return telephone;
}","/** 
 * extract telephone from ResultSet.
 * @param rs ResultSet.
 * @return EntityTelephone EntityTelephone.
 * @throws SQLException SQLException.
 */
private EntityTelephone extractEntityTelFromRs(ResultSet rs) throws SQLException {
  EntityTelephone telephone=EntityTelephone.buildTextTel(rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""));
  telephone.setTypes(rs.getString(""String_Node_Str""));
  telephone.setPref(getIntegerFromRs(rs,""String_Node_Str""));
  return telephone;
}",0.969637610186092
37077,"/** 
 * build telephone URI.
 * @param tel tel.
 * @param vcard vcard.
 * @return TelUri list if tel number is valid, return null if not.
 */
private void addTelephoneToVcard(EntityTelephone tel,VCard vcard){
  if (tel.isEmpty()) {
    return;
  }
  try {
    Builder telBuilder=new TelUri.Builder(tel.getNumber());
    if (StringUtils.isNotBlank(tel.getExtNumber())) {
      telBuilder.extension(tel.getExtNumber());
    }
    TelUri telUri=telBuilder.build();
    Telephone telephone=new Telephone(telUri);
    List<TelephoneType> types=parseTelephoneTypes(tel.getTypes());
    for (    TelephoneType type : types) {
      telephone.addType(type);
    }
    addPref(tel,telephone);
    vcard.addTelephoneNumber(telephone);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e.getMessage(),tel);
  }
}","/** 
 * build telephone URI.
 * @param tel tel.
 * @param vcard vcard.
 */
private void addTelephoneToVcard(EntityTelephone tel,VCard vcard){
  if (tel.isEmpty()) {
    return;
  }
  try {
    Builder telBuilder=new TelUri.Builder(tel.getNumber());
    if (StringUtils.isNotBlank(tel.getExtNumber())) {
      telBuilder.extension(tel.getExtNumber());
    }
    TelUri telUri=telBuilder.build();
    Telephone telephone=new Telephone(telUri);
    List<TelephoneType> types=parseTelephoneTypes(tel.getTypes());
    for (    TelephoneType type : types) {
      telephone.addType(type);
    }
    addPref(tel,telephone);
    vcard.addTelephoneNumber(telephone);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e.getMessage(),tel);
  }
}",0.9571337172104928
37078,"protected Network convertDtoToModelWithoutIpVersion(IpDto dto){
  Network network=convertDtoToNetwork(dto);
  super.convertCustomProperties(dto,network);
  return network;
}","/** 
 * convert DTO to model without ip version.
 * @param dto dto.
 * @return Network.
 */
protected Network convertDtoToModelWithoutIpVersion(IpDto dto){
  Network network=convertDtoToNetwork(dto);
  super.convertCustomProperties(dto,network);
  return network;
}",0.7899543378995434
37079,"private Network convertDtoToNetwork(IpDto dto){
  Network network=new Network();
  BeanUtil.copyProperties(dto,network,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return network;
}","/** 
 * convert DTO to network.
 * @param dto dto.
 * @return Network.
 */
private Network convertDtoToNetwork(IpDto dto){
  Network network=new Network();
  BeanUtil.copyProperties(dto,network,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return network;
}",0.8496993987975952
37080,"protected ValidationResult validateWithoutIpVersion(IpDto dto,ValidationResult validationResult){
  LOGGER.debug(""String_Node_Str"");
  checkIpNotEmptyAndValid(dto.getStartAddress(),validationResult,""String_Node_Str"");
  checkIpNotEmptyAndValid(dto.getEndAddress(),validationResult,""String_Node_Str"");
  checkMaxLength(dto.getName(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getType(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getCountry(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getParentHandle(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLength(dto.getCidr(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}","/** 
 * validate without IP version.
 * @param dto dto.
 * @param validationResult validationResult.
 * @return validationResult.
 */
protected ValidationResult validateWithoutIpVersion(IpDto dto,ValidationResult validationResult){
  LOGGER.debug(""String_Node_Str"");
  checkIpNotEmptyAndValid(dto.getStartAddress(),validationResult,""String_Node_Str"");
  checkIpNotEmptyAndValid(dto.getEndAddress(),validationResult,""String_Node_Str"");
  checkMaxLength(dto.getName(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getType(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getCountry(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getParentHandle(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLength(dto.getCidr(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}",0.9291754756871036
37081,"private void checkIpNotEmptyAndValid(String ip,ValidationResult validationResult,String fieldName){
  checkNotEmpty(ip,fieldName,validationResult);
  checkIp(ip,fieldName,validationResult);
}","/** 
 * check if IP is notEmpty and valid.
 * @param ip IP.
 * @param validationResult validationResult.
 * @param fieldName fieldName.
 */
private void checkIpNotEmptyAndValid(String ip,ValidationResult validationResult,String fieldName){
  checkNotEmpty(ip,fieldName,validationResult);
  checkIp(ip,fieldName,validationResult);
}",0.7318007662835249
37082,"/** 
 * batch create DsData.
 * @param outerModel outer object	 
 * @param models DsData of outer Object
 */
@Override public void saveAsInnerObjects(BaseModel outerModel,List<DsDataDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  DsDataDto model : models) {
    Long dsDataId=createDsData(model);
    secureDnsUpdateDao.createRelSecureDnsDskey(outerModel.getId(),ModelType.DSDATA,dsDataId);
    DsData dsDataAsOuter=new DsData();
    dsDataAsOuter.setId(dsDataId);
    linkUpdateDao.saveAsInnerObjects(dsDataAsOuter,model.getLinks());
    eventUpdateDao.saveAsInnerObjects(dsDataAsOuter,model.getEvents());
  }
}","/** 
 * batch create DsData.
 * @param outerModel outer object
 * @param models DsData of outer Object
 */
@Override public void saveAsInnerObjects(BaseModel outerModel,List<DsDataDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  DsDataDto model : models) {
    Long dsDataId=createDsData(model);
    secureDnsUpdateDao.createRelSecureDnsDskey(outerModel.getId(),ModelType.DSDATA,dsDataId);
    DsData dsDataAsOuter=new DsData();
    dsDataAsOuter.setId(dsDataId);
    linkUpdateDao.saveAsInnerObjects(dsDataAsOuter,model.getLinks());
    eventUpdateDao.saveAsInnerObjects(dsDataAsOuter,model.getEvents());
  }
}",0.9984567901234568
37083,"/** 
 * @param dto dto.
 * @return Autnum.
 */
private Autnum convertDtoToAutnum(AutnumDto dto){
  Autnum autnum=new Autnum();
  BeanUtil.copyProperties(dto,autnum,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return autnum;
}","/** 
 * covert autnumDto to autnum.
 * @param dto dto.
 * @return Autnum.
 */
private Autnum convertDtoToAutnum(AutnumDto dto){
  Autnum autnum=new Autnum();
  BeanUtil.copyProperties(dto,autnum,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return autnum;
}",0.9429097605893186
37084,"/** 
 * @param dto autnumdto.
 * @return Autnum.
 */
protected Autnum convertDtoToModel(AutnumDto dto){
  Autnum autnum=convertDtoToAutnum(dto);
  super.convertCustomProperties(dto,autnum);
  return autnum;
}","/** 
 * covert autnumDto to autnum. meantime covert custom properties.
 * @param dto autnumdto.
 * @return Autnum.
 */
protected Autnum convertDtoToModel(AutnumDto dto){
  Autnum autnum=convertDtoToAutnum(dto);
  super.convertCustomProperties(dto,autnum);
  return autnum;
}",0.8630705394190872
37085,"/** 
 * @param dto dto.
 * @param validationResult validationResult.
 * @return ValidationResult.
 */
protected ValidationResult validateForSaveAndUpdate(AutnumDto dto,ValidationResult validationResult){
  LOGGER.debug(""String_Node_Str"");
  checkNotNullAndMinMaxBigInt(dto.getStartAutnum(),""String_Node_Str"",validationResult);
  checkNotNullAndMinMaxBigInt(dto.getEndAutnum(),""String_Node_Str"",validationResult);
  checkMaxLength(dto.getName(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getType(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getCountry(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}","/** 
 * validate dto. 
 * @param dto dto.
 * @param validationResult validationResult.
 * @return ValidationResult.
 */
protected ValidationResult validateForSaveAndUpdate(AutnumDto dto,ValidationResult validationResult){
  LOGGER.debug(""String_Node_Str"");
  checkNotNullAndMinMaxBigInt(dto.getStartAutnum(),""String_Node_Str"",validationResult);
  checkNotNullAndMinMaxBigInt(dto.getEndAutnum(),""String_Node_Str"",validationResult);
  checkMaxLength(dto.getName(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getType(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getCountry(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}",0.988957055214724
37086,"/** 
 * create.
 * @param domainDto domainDto.
 * @param request request.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody DomainDto domainDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(domainDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * create domain.
 * @param domainDto domainDto.
 * @param request HttpServletRequest.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody DomainDto domainDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(domainDto);
  return RestResponse.createUpdateResponse(response);
}",0.7655310621242485
37087,"/** 
 * @param domainDto domainDto.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody DomainDto domainDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  domainDto.setHandle(handle);
  UpdateResponse response=updateService.execute(domainDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * update domain.
 * @param domainDto domainDto.
 * @param handle handle.
 * @param request HttpServletRequest.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody DomainDto domainDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  domainDto.setHandle(handle);
  UpdateResponse response=updateService.execute(domainDto);
  return RestResponse.createUpdateResponse(response);
}",0.9089332176929747
37088,"/** 
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  DomainDto dto=new DomainDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * delete domain.
 * @param handle handle.
 * @param request HttpServletRequest.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  DomainDto dto=new DomainDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}",0.902143522833178
37089,"/** 
 * batch create link.
 * @param outerModel outer object
 * @param models links of outer Object
 */
@Override public void saveAsInnerObjects(final BaseModel outerModel,final List<EntityAddressDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  final List<EntityAddressDto> notEmptyModels=getNotEmptyList(models);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyModels.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      EntityAddressDto model=notEmptyModels.get(i);
      ps.setString(1,model.getPostbox());
      ps.setString(2,model.getExtendedAddress());
      ps.setString(3,model.getStreetAddress());
      ps.setString(4,model.getLocality());
      ps.setString(5,model.getRegion());
      ps.setString(6,model.getPostalcode());
      ps.setString(7,model.getCountry());
      ps.setLong(8,outerModel.getId());
      ps.setString(9,model.getTypes());
      ps.setLong(10,model.getPref());
    }
  }
);
}","/** 
 * create entityAddress.
 * @param outerModel outer object.
 * @param models entityAddressDto.
 */
@Override public void saveAsInnerObjects(final BaseModel outerModel,final List<EntityAddressDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  final List<EntityAddressDto> notEmptyModels=getNotEmptyList(models);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyModels.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      EntityAddressDto model=notEmptyModels.get(i);
      ps.setString(1,model.getPostbox());
      ps.setString(2,model.getExtendedAddress());
      ps.setString(3,model.getStreetAddress());
      ps.setString(4,model.getLocality());
      ps.setString(5,model.getRegion());
      ps.setString(6,model.getPostalcode());
      ps.setString(7,model.getCountry());
      ps.setLong(8,outerModel.getId());
      ps.setString(9,model.getTypes());
      ps.setLong(10,model.getPref());
    }
  }
);
}",0.9674935842600512
37090,"/** 
 * @param entityAddressList entityAddressList
 * @return notEmptyList
 */
private List<EntityAddressDto> getNotEmptyList(List<EntityAddressDto> entityAddressList){
  List<EntityAddressDto> notEmptyList=new ArrayList<EntityAddressDto>();
  if (null == entityAddressList) {
    return notEmptyList;
  }
  for (  EntityAddressDto entityAddress : entityAddressList) {
    if (StringUtils.isNotBlank(entityAddress.getExtendedAddress()) || StringUtils.isNotBlank(entityAddress.getCountry()) || StringUtils.isNotBlank(entityAddress.getLocality())|| StringUtils.isNotBlank(entityAddress.getPostalcode())|| StringUtils.isNotBlank(entityAddress.getPostbox())|| StringUtils.isNotBlank(entityAddress.getRegion())|| StringUtils.isNotBlank(entityAddress.getStreetAddress())) {
      notEmptyList.add(entityAddress);
    }
  }
  return notEmptyList;
}","/** 
 * get not empty entityAddressDto list.
 * @param entityAddressList entityAddressList
 * @return notEmptyList
 */
private List<EntityAddressDto> getNotEmptyList(List<EntityAddressDto> entityAddressList){
  List<EntityAddressDto> notEmptyList=new ArrayList<EntityAddressDto>();
  if (null == entityAddressList) {
    return notEmptyList;
  }
  for (  EntityAddressDto entityAddress : entityAddressList) {
    if (StringUtils.isNotBlank(entityAddress.getExtendedAddress()) || StringUtils.isNotBlank(entityAddress.getCountry()) || StringUtils.isNotBlank(entityAddress.getLocality())|| StringUtils.isNotBlank(entityAddress.getPostalcode())|| StringUtils.isNotBlank(entityAddress.getPostbox())|| StringUtils.isNotBlank(entityAddress.getRegion())|| StringUtils.isNotBlank(entityAddress.getStreetAddress())) {
      notEmptyList.add(entityAddress);
    }
  }
  return notEmptyList;
}",0.9767711962833914
37091,"/** 
 * batch create link.
 * @param outerModel outer object
 * @param models links of outer Object
 */
@Override public void saveAsInnerObjects(final BaseModel outerModel,final List<EntityTelephoneDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  final List<EntityTelephoneDto> notEmptyModels=getNotEmptyList(models);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyModels.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      EntityTelephoneDto model=notEmptyModels.get(i);
      ps.setString(1,model.getTypes());
      ps.setString(2,model.getNumber());
      ps.setString(3,model.getExtNumber());
      ps.setLong(4,outerModel.getId());
      ps.setLong(5,model.getPref());
    }
  }
);
}","/** 
 * create entity telephone.
 * @param outerModel outer object.
 * @param models entityTelephoneDto.
 */
@Override public void saveAsInnerObjects(final BaseModel outerModel,final List<EntityTelephoneDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  final List<EntityTelephoneDto> notEmptyModels=getNotEmptyList(models);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return notEmptyModels.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      EntityTelephoneDto model=notEmptyModels.get(i);
      ps.setString(1,model.getTypes());
      ps.setString(2,model.getNumber());
      ps.setString(3,model.getExtNumber());
      ps.setLong(4,outerModel.getId());
      ps.setLong(5,model.getPref());
    }
  }
);
}",0.9575952764358562
37092,"/** 
 * @param entityTelList entityTelList
 * @return notEmptyList
 */
public static List<EntityTelephoneDto> getNotEmptyList(List<EntityTelephoneDto> entityTelList){
  List<EntityTelephoneDto> notEmptyList=new ArrayList<EntityTelephoneDto>();
  if (null == entityTelList) {
    return notEmptyList;
  }
  for (  EntityTelephoneDto entityTel : entityTelList) {
    if (StringUtils.isNotBlank(entityTel.getNumber())) {
      notEmptyList.add(entityTel);
    }
  }
  return notEmptyList;
}","/** 
 * get not empty entityTelephoneDto list.
 * @param entityTelList entityTelList.
 * @return notEmptyList
 */
public static List<EntityTelephoneDto> getNotEmptyList(List<EntityTelephoneDto> entityTelList){
  List<EntityTelephoneDto> notEmptyList=new ArrayList<EntityTelephoneDto>();
  if (null == entityTelList) {
    return notEmptyList;
  }
  for (  EntityTelephoneDto entityTel : entityTelList) {
    if (StringUtils.isNotBlank(entityTel.getNumber())) {
      notEmptyList.add(entityTel);
    }
  }
  return notEmptyList;
}",0.9577187807276304
37093,"/** 
 * @param outerModel outer object
 */
public void saveRel(BaseModel outerModel){
  if (null == outerModel || null == outerModel.getDto()) {
    return;
  }
  List<EntityHandleDto> entityHandles=outerModel.getDto().getEntities();
  if (null == entityHandles || entityHandles.size() == 0) {
    return;
  }
  for (  EntityHandleDto entityHandleDto : entityHandles) {
    Long entityId=this.findIdByHandle(entityHandleDto.getHandle());
    if (null != entityId) {
      createRelEntity(outerModel,entityHandleDto,entityId);
    }
  }
}","/** 
 * save the relation between entity with object.
 * @param outerModel outer object
 */
public void saveRel(BaseModel outerModel){
  if (null == outerModel || null == outerModel.getDto()) {
    return;
  }
  List<EntityHandleDto> entityHandles=outerModel.getDto().getEntities();
  if (null == entityHandles || entityHandles.size() == 0) {
    return;
  }
  for (  EntityHandleDto entityHandleDto : entityHandles) {
    Long entityId=this.findIdByHandle(entityHandleDto.getHandle());
    if (null != entityId) {
      createRelEntity(outerModel,entityHandleDto,entityId);
    }
  }
}",0.956366874443455
37094,"/** 
 * @param outerModel outerModel.
 * @param entityHandleDto entityHandleDto.
 * @param entityId entityId.
 */
private void createRelEntity(final BaseModel outerModel,final EntityHandleDto entityHandleDto,final Long entityId){
  final List<String> roles=entityHandleDto.getRoles();
  if (roles == null || roles.size() == 0) {
    return;
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return roles.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      ps.setLong(3,entityId);
      ps.setString(4,roles.get(i));
    }
  }
);
}","/** 
 * save the relation between entity with object to database.
 * @param outerModel outerModel.
 * @param entityHandleDto entityHandleDto.
 * @param entityId entityId.
 */
private void createRelEntity(final BaseModel outerModel,final EntityHandleDto entityHandleDto,final Long entityId){
  final List<String> roles=entityHandleDto.getRoles();
  if (roles == null || roles.size() == 0) {
    return;
  }
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.batchUpdate(sql,new BatchPreparedStatementSetter(){
    public int getBatchSize(){
      return roles.size();
    }
    @Override public void setValues(    PreparedStatement ps,    int i) throws SQLException {
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      ps.setLong(3,entityId);
      ps.setString(4,roles.get(i));
    }
  }
);
}",0.9644729178800232
37095,"/** 
 * @param nsDto nsDto.
 * @param request request.
 * @return ResponseEntity ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody NameserverDto nsDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(nsDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * create nameserver.
 * @param nsDto nsDto.
 * @param request HttpServletRequest
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.POST) @ResponseBody public ResponseEntity create(@RequestBody NameserverDto nsDto,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  UpdateResponse response=createService.execute(nsDto);
  return RestResponse.createUpdateResponse(response);
}",0.8277268093781855
37096,"/** 
 * @param nsDto nsDto.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody NameserverDto nsDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  nsDto.setHandle(handle);
  UpdateResponse response=updateService.execute(nsDto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * update nameserver.
 * @param nsDto nsDto.
 * @param handle handle.
 * @param request HttpServletRequest.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.PUT) @ResponseBody public ResponseEntity update(@RequestBody NameserverDto nsDto,@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  nsDto.setHandle(handle);
  UpdateResponse response=updateService.execute(nsDto);
  return RestResponse.createUpdateResponse(response);
}",0.8851884312007011
37097,"/** 
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  NameserverDto dto=new NameserverDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}","/** 
 * delete nameserver.
 * @param handle handle.
 * @param request HttpServletRequest.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException
 */
@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""},method=RequestMethod.DELETE) @ResponseBody public ResponseEntity delete(@PathVariable String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"");
  NameserverDto dto=new NameserverDto();
  dto.setHandle(handle);
  UpdateResponse response=deleteService.execute(dto);
  return RestResponse.createUpdateResponse(response);
}",0.8880866425992779
37098,"/** 
 * dto dto.
 */
protected Autnum convertDtoToModel(AutnumDto dto){
  Autnum autnum=convertDtoToAutnum(dto);
  super.convertCustomProperties(dto,autnum);
  return autnum;
}","/** 
 * @param dto autnumdto.
 * @return Autnum.
 */
protected Autnum convertDtoToModel(AutnumDto dto){
  Autnum autnum=convertDtoToAutnum(dto);
  super.convertCustomProperties(dto,autnum);
  return autnum;
}",0.8802083333333334
37099,"private void checkKeyData(SecureDnsDto secureDns,ValidationResult validationResult){
  List<KeyDataDto> keyDatas=secureDns.getKeyData();
  if (null == keyDatas) {
    return;
  }
  for (  KeyDataDto keyData : keyDatas) {
    checkNotNullAndMinMaxInt(keyData.getFlags(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(keyData.getProtocol(),""String_Node_Str"",validationResult);
    checkMaxLength(keyData.getPublicKey(),UpdateValidateUtil.MAX_LENGTH_2048,""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(keyData.getAlgorithm(),""String_Node_Str"",validationResult);
    checkEvents(keyData.getEvents(),validationResult);
    checkLinks(keyData.getLinks(),validationResult);
  }
}","/** 
 * @param secureDns secureDns.
 * @param validationResult validationResult.
 */
private void checkKeyData(SecureDnsDto secureDns,ValidationResult validationResult){
  List<KeyDataDto> keyDatas=secureDns.getKeyData();
  if (null == keyDatas) {
    return;
  }
  for (  KeyDataDto keyData : keyDatas) {
    checkNotNullAndMinMaxInt(keyData.getFlags(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(keyData.getProtocol(),""String_Node_Str"",validationResult);
    checkMaxLength(keyData.getPublicKey(),UpdateValidateUtil.MAX_LENGTH_2048,""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(keyData.getAlgorithm(),""String_Node_Str"",validationResult);
    checkEvents(keyData.getEvents(),validationResult);
    checkLinks(keyData.getLinks(),validationResult);
  }
}",0.9435215946843852
37100,"public UpdateDao<Variants,VariantDto> getVariantUpdateDao(){
  return variantUpdateDao;
}","/** 
 * @return variantUpdateDao.
 */
public UpdateDao<Variants,VariantDto> getVariantUpdateDao(){
  return variantUpdateDao;
}",0.8240740740740741
37101,"protected void saveVariants(DomainDto dto,Domain domain){
  LOGGER.debug(""String_Node_Str"");
  List<VariantDto> variantDtos=dto.getVariants();
  if (null == variantDtos || variantDtos.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  variantUpdateDao.saveAsInnerObjects(domain,variantDtos);
}","/** 
 * @param dto domainDto.
 * @param domain domain.
 */
protected void saveVariants(DomainDto dto,Domain domain){
  LOGGER.debug(""String_Node_Str"");
  List<VariantDto> variantDtos=dto.getVariants();
  if (null == variantDtos || variantDtos.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  variantUpdateDao.saveAsInnerObjects(domain,variantDtos);
}",0.9131075110456554
37102,"public UpdateDao<Network,IpDto> getNetworkDao(){
  return networkDao;
}","/** 
 * @return networkDao.
 */
public UpdateDao<Network,IpDto> getNetworkDao(){
  return networkDao;
}",0.8160919540229885
37103,"private void checkVariants(DomainDto domainDto,ValidationResult validationResult){
  List<VariantDto> variants=domainDto.getVariants();
  if (null == variants) {
    return;
  }
  for (  VariantDto variant : variants) {
    checkMaxLength(variant.getIdnTable(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
    List<String> relations=variant.getRelation();
    if (null != relations) {
      for (      String relation : relations) {
        checkMaxLength(relation,MAX_LENGTH_255,""String_Node_Str"",validationResult);
      }
    }
    List<VariantNameDto> variantNames=variant.getVariantNames();
    if (null != variantNames) {
      for (      VariantNameDto variantName : variantNames) {
        checkNotEmptyAndMaxLength(variantName.getLdhName(),MAX_LENGTH_LDHNAME,""String_Node_Str"",validationResult);
        checkNotEmptyAndMaxLength(variantName.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
      }
    }
  }
}","/** 
 * @param domainDto domainDto.
 * @param validationResult validationResult.
 */
private void checkVariants(DomainDto domainDto,ValidationResult validationResult){
  List<VariantDto> variants=domainDto.getVariants();
  if (null == variants) {
    return;
  }
  for (  VariantDto variant : variants) {
    checkMaxLength(variant.getIdnTable(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
    List<String> relations=variant.getRelation();
    if (null != relations) {
      for (      String relation : relations) {
        checkMaxLength(relation,MAX_LENGTH_255,""String_Node_Str"",validationResult);
      }
    }
    List<VariantNameDto> variantNames=variant.getVariantNames();
    if (null != variantNames) {
      for (      VariantNameDto variantName : variantNames) {
        checkNotEmptyAndMaxLength(variantName.getLdhName(),MAX_LENGTH_LDHNAME,""String_Node_Str"",validationResult);
        checkNotEmptyAndMaxLength(variantName.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
      }
    }
  }
}",0.9573507275464124
37104,"public UpdateDao<SecureDns,SecureDnsDto> getSecureDnsUpdateDao(){
  return secureDnsUpdateDao;
}","/** 
 * @return secureDnsUpdateDao.
 */
public UpdateDao<SecureDns,SecureDnsDto> getSecureDnsUpdateDao(){
  return secureDnsUpdateDao;
}",0.8275862068965517
37105,"private void checkSecureDns(DomainDto domainDto,ValidationResult validationResult){
  SecureDnsDto secureDns=domainDto.getSecureDNS();
  if (null == secureDns) {
    return;
  }
  checkMinMaxInt(secureDns.getMaxSigLife(),""String_Node_Str"",validationResult);
  checkDsData(secureDns,validationResult);
  checkKeyData(secureDns,validationResult);
}","/** 
 * @param domainDto domainDto.
 * @param validationResult validationResult.
 */
private void checkSecureDns(DomainDto domainDto,ValidationResult validationResult){
  SecureDnsDto secureDns=domainDto.getSecureDNS();
  if (null == secureDns) {
    return;
  }
  checkMinMaxInt(secureDns.getMaxSigLife(),""String_Node_Str"",validationResult);
  checkDsData(secureDns,validationResult);
  checkKeyData(secureDns,validationResult);
}",0.8906048906048906
37106,"protected void updateVariants(DomainDto dto,Domain domain){
  deleteVariants(domain);
  saveVariants(dto,domain);
}","/** 
 * @param dto dto.
 * @param domain domain.
 */
protected void updateVariants(DomainDto dto,Domain domain){
  deleteVariants(domain);
  saveVariants(dto,domain);
}",0.8127208480565371
37107,"private void checkDsData(SecureDnsDto secureDns,ValidationResult validationResult){
  List<DsDataDto> dsDatas=secureDns.getDsData();
  if (null == dsDatas) {
    return;
  }
  for (  DsDataDto dsData : dsDatas) {
    checkNotNullAndMinMaxInt(dsData.getKeyTag(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(dsData.getAlgorithm(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(dsData.getDigestType(),""String_Node_Str"",validationResult);
    checkNotEmptyAndMaxLength(dsData.getDigest(),UpdateValidateUtil.MAX_LENGTH_2048,""String_Node_Str"",validationResult);
    checkEvents(dsData.getEvents(),validationResult);
    checkLinks(dsData.getLinks(),validationResult);
  }
}","/** 
 * @param secureDns secureDns.
 * @param validationResult validationResult.
 */
private void checkDsData(SecureDnsDto secureDns,ValidationResult validationResult){
  List<DsDataDto> dsDatas=secureDns.getDsData();
  if (null == dsDatas) {
    return;
  }
  for (  DsDataDto dsData : dsDatas) {
    checkNotNullAndMinMaxInt(dsData.getKeyTag(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(dsData.getAlgorithm(),""String_Node_Str"",validationResult);
    checkNotNullAndMinMaxInt(dsData.getDigestType(),""String_Node_Str"",validationResult);
    checkNotEmptyAndMaxLength(dsData.getDigest(),UpdateValidateUtil.MAX_LENGTH_2048,""String_Node_Str"",validationResult);
    checkEvents(dsData.getEvents(),validationResult);
    checkLinks(dsData.getLinks(),validationResult);
  }
}",0.9432955303535692
37108,"private Domain convertDtoToDomain(DomainDto dto){
  Domain domain=new Domain();
  BeanUtil.copyProperties(dto,domain,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return domain;
}","/** 
 * @param dto domainDto.
 * @return domain 
 */
private Domain convertDtoToDomain(DomainDto dto){
  Domain domain=new Domain();
  BeanUtil.copyProperties(dto,domain,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return domain;
}",0.9023941068139965
37109,"protected ValidationResult validateWithoutType(DomainDto domainDto,ValidationResult validationResult){
  checkNotEmptyAndMaxLength(domainDto.getLdhName(),MAX_LENGTH_LDHNAME,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(domainDto.getHandle(),validationResult);
  checkMaxLength(domainDto.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
  checkVariants(domainDto,validationResult);
  checkSecureDns(domainDto,validationResult);
  checkPublicIds(domainDto.getPublicIds(),validationResult);
  validateBaseDto(domainDto,validationResult);
  return validationResult;
}","/** 
 * @param domainDto domainDto.
 * @param validationResult validationResult.
 * @return ValidationResult
 */
protected ValidationResult validateWithoutType(DomainDto domainDto,ValidationResult validationResult){
  checkNotEmptyAndMaxLength(domainDto.getLdhName(),MAX_LENGTH_LDHNAME,""String_Node_Str"",validationResult);
  checkNotEmptyAndMaxLengthForHandle(domainDto.getHandle(),validationResult);
  checkMaxLength(domainDto.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
  checkVariants(domainDto,validationResult);
  checkSecureDns(domainDto,validationResult);
  checkPublicIds(domainDto.getPublicIds(),validationResult);
  validateBaseDto(domainDto,validationResult);
  return validationResult;
}",0.916358253145818
37110,"protected void updateSecureDns(DomainDto dto,Domain domain){
  deleteSecureDns(domain);
  saveSecureDns(dto,domain);
}","/** 
 * @param dto domainDto.
 * @param domain  domain.
 */
protected void updateSecureDns(DomainDto dto,Domain domain){
  deleteSecureDns(domain);
  saveSecureDns(dto,domain);
}",0.7972972972972973
37111,"/** 
 * @param domain
 */
protected void deleteSecureDns(Domain domain){
  secureDnsUpdateDao.deleteAsInnerObjects(domain);
}","/** 
 * @param domain domain.       
 */
protected void deleteSecureDns(Domain domain){
  secureDnsUpdateDao.deleteAsInnerObjects(domain);
}",0.9433962264150944
37112,"protected void deleteVariants(Domain domain){
  variantUpdateDao.deleteAsInnerObjects(domain);
}","/** 
 * @param domain domain.
 */
protected void deleteVariants(Domain domain){
  variantUpdateDao.deleteAsInnerObjects(domain);
}",0.8495575221238938
37113,"public UpdateDao<Nameserver,NameserverDto> getNameserverDao(){
  return nameserverDao;
}","/** 
 * @return nameserverDao.
 */
public UpdateDao<Nameserver,NameserverDto> getNameserverDao(){
  return nameserverDao;
}",0.8341232227488151
37114,"protected void deleteEntityAddresses(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  entityAddressDao.deleteAsInnerObjects(entity);
}","/** 
 * @param entity entity.
 */
protected void deleteEntityAddresses(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  entityAddressDao.deleteAsInnerObjects(entity);
}",0.8903225806451613
37115,"protected void updateEntityAddresses(Entity entity){
  deleteEntityAddresses(entity);
  saveEntityAddresses(entity);
}","/** 
 * @param entity entity.
 */
protected void updateEntityAddresses(Entity entity){
  deleteEntityAddresses(entity);
  saveEntityAddresses(entity);
}",0.8740740740740741
37116,"protected void deleteEntityTels(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  entityTelDao.deleteAsInnerObjects(entity);
}","/** 
 * @param entity entity.
 */
protected void deleteEntityTels(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  entityTelDao.deleteAsInnerObjects(entity);
}",0.8835616438356164
37117,"protected void updateEntityTels(Entity entity){
  deleteEntityTels(entity);
  saveEntityTels(entity);
}","/** 
 * @param entity entity.
 */
protected void updateEntityTels(Entity entity){
  deleteEntityTels(entity);
  saveEntityTels(entity);
}",0.8583333333333333
37118,"private void checkEntityAddress(EntityDto dto,ValidationResult validationResult){
  List<EntityAddressDto> entityAddressList=dto.getAddresses();
  if (null == entityAddressList || entityAddressList.isEmpty()) {
    return;
  }
  for (  EntityAddressDto entityAddress : entityAddressList) {
    checkMaxLength(entityAddress.getCountry(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getExtendedAddress(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getLocality(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getPostalcode(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getPostbox(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getTypes(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getStreetAddress(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getRegion(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMinMaxInt(entityAddress.getPref(),ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
  }
}","/** 
 * @param dto entityDto.
 * @param validationResult validationResult.
 */
private void checkEntityAddress(EntityDto dto,ValidationResult validationResult){
  List<EntityAddressDto> entityAddressList=dto.getAddresses();
  if (null == entityAddressList || entityAddressList.isEmpty()) {
    return;
  }
  for (  EntityAddressDto entityAddress : entityAddressList) {
    checkMaxLength(entityAddress.getCountry(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getExtendedAddress(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getLocality(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getPostalcode(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getPostbox(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getTypes(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getStreetAddress(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMaxLength(entityAddress.getRegion(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
    checkMinMaxInt(entityAddress.getPref(),ERROR_PROP_NAME_PREFIX_ENTITY_ADDR + ""String_Node_Str"",validationResult);
  }
}",0.9744584545748464
37119,"private void checkEntityTel(EntityDto dto,ValidationResult validationResult){
  List<EntityTelephoneDto> entityTelList=dto.getTelephones();
  if (null == entityTelList || entityTelList.isEmpty()) {
    return;
  }
  for (  EntityTelephoneDto entityTelephone : entityTelList) {
    checkMaxLength(entityTelephone.getExtNumber(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMaxLength(entityTelephone.getNumber(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMaxLength(entityTelephone.getTypes(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMinMaxInt(entityTelephone.getPref(),ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
  }
}","/** 
 * @param dto entityDto.
 * @param validationResult validationResult.
 */
private void checkEntityTel(EntityDto dto,ValidationResult validationResult){
  List<EntityTelephoneDto> entityTelList=dto.getTelephones();
  if (null == entityTelList || entityTelList.isEmpty()) {
    return;
  }
  for (  EntityTelephoneDto entityTelephone : entityTelList) {
    checkMaxLength(entityTelephone.getExtNumber(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMaxLength(entityTelephone.getNumber(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMaxLength(entityTelephone.getTypes(),MAX_LENGTH_255,ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
    checkMinMaxInt(entityTelephone.getPref(),ERROR_PROP_NAME_PREFIX_ENTITY_TEL + ""String_Node_Str"",validationResult);
  }
}",0.9533372711163616
37120,"protected void saveEntityTels(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  EntityDto dto=(EntityDto)entity.getDto();
  List<EntityTelephoneDto> entityTelList=dto.getTelephones();
  if (null == entityTelList || entityTelList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  entityTelDao.saveAsInnerObjects(entity,entityTelList);
}","/** 
 * @param entity entity.
 */
protected void saveEntityTels(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  EntityDto dto=(EntityDto)entity.getDto();
  List<EntityTelephoneDto> entityTelList=dto.getTelephones();
  if (null == entityTelList || entityTelList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  entityTelDao.saveAsInnerObjects(entity,entityTelList);
}",0.9544235924932976
37121,"protected Entity convertDtoToModel(EntityDto dto){
  Entity entity=convertDtoToEntity(dto);
  super.convertCustomProperties(dto,entity);
  return entity;
}","/** 
 * @param dto entityDto.
 * @return entity.
 */
protected Entity convertDtoToModel(EntityDto dto){
  Entity entity=convertDtoToEntity(dto);
  super.convertCustomProperties(dto,entity);
  return entity;
}",0.8539944903581267
37122,"private Entity convertDtoToEntity(EntityDto dto){
  Entity entity=new Entity();
  BeanUtil.copyProperties(dto,entity,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return entity;
}","/** 
 * @param dto entityDto.
 * @return entity.
 */
private Entity convertDtoToEntity(EntityDto dto){
  Entity entity=new Entity();
  BeanUtil.copyProperties(dto,entity,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  return entity;
}",0.9084628670120898
37123,"protected void saveEntityAddresses(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  EntityDto dto=(EntityDto)entity.getDto();
  List<EntityAddressDto> entityAddressList=dto.getAddresses();
  if (null == entityAddressList || entityAddressList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  entityAddressDao.saveAsInnerObjects(entity,entityAddressList);
}","/** 
 * @param entity entity.
 */
protected void saveEntityAddresses(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  EntityDto dto=(EntityDto)entity.getDto();
  List<EntityAddressDto> entityAddressList=dto.getAddresses();
  if (null == entityAddressList || entityAddressList.isEmpty()) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  entityAddressDao.saveAsInnerObjects(entity,entityAddressList);
}",0.9569620253164556
37124,"protected ValidationResult validateForSaveAndUpdate(EntityDto dto,ValidationResult validationResult){
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  checkNotEmptyAndMaxLength(dto.getFn(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getKind(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getEmail(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getTitle(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getOrg(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getUrl(),MAX_LENGTH_PORT43,""String_Node_Str"",validationResult);
  checkEntityAddress(dto,validationResult);
  checkEntityTel(dto,validationResult);
  checkPublicIds(dto.getPublicIds(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}","/** 
 * @param dto entityDto.
 * @param validationResult validationResult.
 * @return ValidationResult
 */
protected ValidationResult validateForSaveAndUpdate(EntityDto dto,ValidationResult validationResult){
  checkNotEmptyAndMaxLengthForHandle(dto.getHandle(),validationResult);
  checkNotEmptyAndMaxLength(dto.getFn(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getKind(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getEmail(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getTitle(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getOrg(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
  checkMaxLength(dto.getUrl(),MAX_LENGTH_PORT43,""String_Node_Str"",validationResult);
  checkEntityAddress(dto,validationResult);
  checkEntityTel(dto,validationResult);
  checkPublicIds(dto.getPublicIds(),validationResult);
  validateBaseDto(dto,validationResult);
  return validationResult;
}",0.9434161819143312
37125,"private AutnumDto generateAutnumDto(){
  AutnumDto autnum=new AutnumDto();
  autnum.setHandle(""String_Node_Str"");
  autnum.setStartAutnum(1L);
  autnum.setEndAutnum(1L);
  autnum.setName(""String_Node_Str"");
  autnum.setPort43(""String_Node_Str"");
  autnum.setCountry(""String_Node_Str"");
  autnum.setLang(""String_Node_Str"");
  autnum.setType(""String_Node_Str"");
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  autnum.setCustomProperties(customProperties);
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  autnum.setStatus(status);
  return autnum;
}","private AutnumDto generateAutnumDto(){
  AutnumDto autnum=new AutnumDto();
  autnum.setHandle(""String_Node_Str"");
  autnum.setStartAutnum(1L);
  autnum.setEndAutnum(1L);
  autnum.setName(""String_Node_Str"");
  autnum.setPort43(""String_Node_Str"");
  autnum.setCountry(""String_Node_Str"");
  autnum.setLang(""String_Node_Str"");
  autnum.setType(""String_Node_Str"");
  Map<String,String> customProperties=new LinkedHashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  autnum.setCustomProperties(customProperties);
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  autnum.setStatus(status);
  return autnum;
}",0.9960526315789474
37126,"private DomainDto generateDomainDto(){
  DomainDto domain=new DomainDto();
  domain.setHandle(""String_Node_Str"");
  domain.setLdhName(""String_Node_Str"");
  domain.setUnicodeName(""String_Node_Str"");
  domain.setPort43(""String_Node_Str"");
  domain.setLang(""String_Node_Str"");
  domain.setType(DomainType.DNR.getName());
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  domain.setCustomProperties(customProperties);
  return domain;
}","private DomainDto generateDomainDto(){
  DomainDto domain=new DomainDto();
  domain.setHandle(""String_Node_Str"");
  domain.setLdhName(""String_Node_Str"");
  domain.setUnicodeName(""String_Node_Str"");
  domain.setPort43(""String_Node_Str"");
  domain.setLang(""String_Node_Str"");
  domain.setType(DomainType.DNR.getName());
  Map<String,String> customProperties=new LinkedHashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  domain.setCustomProperties(customProperties);
  return domain;
}",0.9948006932409011
37127,"private EntityDto generateEntityDto(){
  EntityDto entity=new EntityDto();
  entity.setHandle(""String_Node_Str"");
  entity.setEmail(""String_Node_Str"");
  entity.setFn(""String_Node_Str"");
  entity.setKind(""String_Node_Str"");
  entity.setOrg(""String_Node_Str"");
  entity.setPort43(""String_Node_Str"");
  entity.setLang(""String_Node_Str"");
  entity.setTitle(""String_Node_Str"");
  entity.setUrl(""String_Node_Str"");
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  entity.setCustomProperties(customProperties);
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  entity.setStatus(status);
  return entity;
}","private EntityDto generateEntityDto(){
  EntityDto entity=new EntityDto();
  entity.setHandle(""String_Node_Str"");
  entity.setEmail(""String_Node_Str"");
  entity.setFn(""String_Node_Str"");
  entity.setKind(""String_Node_Str"");
  entity.setOrg(""String_Node_Str"");
  entity.setPort43(""String_Node_Str"");
  entity.setLang(""String_Node_Str"");
  entity.setTitle(""String_Node_Str"");
  entity.setUrl(""String_Node_Str"");
  Map<String,String> customProperties=new LinkedHashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  entity.setCustomProperties(customProperties);
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  entity.setStatus(status);
  return entity;
}",0.9962962962962963
37128,"private NameserverDto generateNsDto(){
  NameserverDto nameserver=new NameserverDto();
  nameserver.setHandle(""String_Node_Str"");
  nameserver.setLdhName(""String_Node_Str"");
  nameserver.setUnicodeName(""String_Node_Str"");
  nameserver.setPort43(""String_Node_Str"");
  nameserver.setLang(""String_Node_Str"");
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  nameserver.setStatus(status);
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  nameserver.setCustomProperties(customProperties);
  return nameserver;
}","private NameserverDto generateNsDto(){
  NameserverDto nameserver=new NameserverDto();
  nameserver.setHandle(""String_Node_Str"");
  nameserver.setLdhName(""String_Node_Str"");
  nameserver.setUnicodeName(""String_Node_Str"");
  nameserver.setPort43(""String_Node_Str"");
  nameserver.setLang(""String_Node_Str"");
  List<String> status=new ArrayList<String>();
  status.add(""String_Node_Str"");
  status.add(""String_Node_Str"");
  nameserver.setStatus(status);
  Map<String,String> customProperties=new LinkedHashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  nameserver.setCustomProperties(customProperties);
  return nameserver;
}",0.9958217270194986
37129,"private boolean checkContentTypeForUpdate(HttpServletRequest request){
  String contentTypeHeader=request.getHeader(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",contentTypeHeader);
  if (StringUtils.isBlank(contentTypeHeader)) {
    return false;
  }
  List<MediaType> mediaTypes=StringUtil.parseMediaTypes(contentTypeHeader);
  if (null == mediaTypes) {
    return false;
  }
  return true;
}","private boolean checkContentTypeForUpdate(HttpServletRequest request){
  String contentTypeHeader=request.getHeader(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",contentTypeHeader);
  if (StringUtils.isBlank(contentTypeHeader)) {
    return false;
  }
  MediaType mediaType=StringUtil.parseMediaType(contentTypeHeader);
  if (null == mediaType) {
    return false;
  }
  return true;
}",0.9886506935687264
37130,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  AutnumDto autnum=generateAutnumDto();
  String content=JsonHelper.serialize(autnum);
  mockMvc.perform(post(URI_AUTNUM_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(autnum.getHandle()));
  mockMvc.perform(post(URI_AUTNUM_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),autnum.getHandle()))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  AutnumDto autnum=generateAutnumDto();
  String content=JsonHelper.serialize(autnum);
  mockMvc.perform(post(URI_AUTNUM_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(autnum.getHandle()));
  mockMvc.perform(post(URI_AUTNUM_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isConflict()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(409)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),autnum.getHandle()))));
}",0.9899665551839464
37131,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  DomainDto domain=generateDomainDto();
  String content=JsonHelper.serialize(domain);
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(domain.getHandle()));
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),domain.getHandle()))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  DomainDto domain=generateDomainDto();
  String content=JsonHelper.serialize(domain);
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(domain.getHandle()));
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isConflict()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(409)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),domain.getHandle()))));
}",0.9899665551839464
37132,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  EntityDto entity=generateEntityDto();
  String content=JsonHelper.serialize(entity);
  mockMvc.perform(post(URI_ENTITY_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(entity.getHandle()));
  mockMvc.perform(post(URI_ENTITY_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),entity.getHandle()))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  EntityDto entity=generateEntityDto();
  String content=JsonHelper.serialize(entity);
  mockMvc.perform(post(URI_ENTITY_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(entity.getHandle()));
  mockMvc.perform(post(URI_ENTITY_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isConflict()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(409)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),entity.getHandle()))));
}",0.9899665551839464
37133,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  NameserverDto ns=generateNsDto();
  String content=JsonHelper.serialize(ns);
  mockMvc.perform(post(URI_NS_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(ns.getHandle()));
  mockMvc.perform(post(URI_NS_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),ns.getHandle()))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  NameserverDto ns=generateNsDto();
  String content=JsonHelper.serialize(ns);
  mockMvc.perform(post(URI_NS_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(ns.getHandle()));
  mockMvc.perform(post(URI_NS_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isConflict()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(409)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),ns.getHandle()))));
}",0.9896907216494846
37134,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  IpDto ipDto=generateIpDto();
  String content=JsonHelper.serialize(ipDto);
  mockMvc.perform(post(URI_IP_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(ipDto.getHandle()));
  mockMvc.perform(post(URI_IP_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),ipDto.getHandle()))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_already_exist() throws Exception {
  IpDto ipDto=generateIpDto();
  String content=JsonHelper.serialize(ipDto);
  mockMvc.perform(post(URI_IP_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(ipDto.getHandle()));
  mockMvc.perform(post(URI_IP_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isConflict()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(409)).andExpect(jsonPath(""String_Node_Str"").value(4091)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4091.getMessage(),ipDto.getHandle()))));
}",0.9897377423033068
37135,"private boolean checkContentTypeForUpdate(HttpServletRequest request){
  String contentTypeHeader=request.getHeader(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",contentTypeHeader);
  if (StringUtils.isBlank(contentTypeHeader)) {
    return false;
  }
  List<MediaType> mediaTypes=StringUtil.parseMediaTypes(contentTypeHeader);
  if (null == mediaTypes) {
    return false;
  }
  return true;
}","private boolean checkContentTypeForUpdate(HttpServletRequest request){
  String contentTypeHeader=request.getHeader(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",contentTypeHeader);
  if (StringUtils.isBlank(contentTypeHeader)) {
    return false;
  }
  MediaType mediaType=StringUtil.parseMediaType(contentTypeHeader);
  if (null == mediaType) {
    return false;
  }
  return true;
}",0.9886506935687264
37136,"/** 
 * parse string IP to byte array.
 * @param ipPrefix ipPrefix.
 * @param ipVersion ipVersion.
 * @return bytes.
 */
public static byte[] ipToByteArray(String ipPrefix,IpVersion ipVersion){
  if (null == ipVersion || ipVersion.isNotValidIp()) {
    return null;
  }
  if (ipVersion.isV4()) {
    return IpV4.toByteArray(ipPrefix);
  }
  if (ipVersion.isV6()) {
    return IpV6.toByteArray(ipPrefix);
  }
  return null;
}","/** 
 * ipToByteArray.
 * @param ipPrefix IP.
 * @return bytes.
 */
public static byte[] ipToByteArray(String ipPrefix){
  IpVersion ipVersion=getIpVersionOfIp(ipPrefix);
  if (null == ipVersion || ipVersion.isNotValidIp()) {
    return null;
  }
  if (ipVersion.isV4()) {
    return IpV4.toByteArray(ipPrefix);
  }
  if (ipVersion.isV6()) {
    return IpV6.toByteArray(ipPrefix);
  }
  return null;
}",0.8242424242424242
37137,"public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(SQL_SAVE_IP,Statement.RETURN_GENERATED_KEYS);
  ps.setString(1,model.getHandle());
  ps.setBytes(2,IpUtil.ipToByteArray(model.getEndAddress(),model.getIpVersion()));
  ps.setBytes(3,IpUtil.ipToByteArray(model.getStartAddress(),model.getIpVersion()));
  ps.setString(4,model.getIpVersion().getName());
  ps.setString(5,model.getName());
  ps.setString(6,model.getType());
  ps.setString(7,model.getCountry());
  ps.setString(8,model.getParentHandle());
  ps.setString(9,model.getPort43());
  ps.setString(10,model.getLang());
  ps.setString(11,model.getCidr());
  ps.setString(12,model.getCustomPropertiesJsonVal());
  return ps;
}","public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(SQL_SAVE_IP,Statement.RETURN_GENERATED_KEYS);
  ps.setString(1,model.getHandle());
  ps.setBytes(2,IpUtil.ipToByteArray(model.getEndAddress()));
  ps.setBytes(3,IpUtil.ipToByteArray(model.getStartAddress()));
  ps.setString(4,model.getIpVersion().getName());
  ps.setString(5,model.getName());
  ps.setString(6,model.getType());
  ps.setString(7,model.getCountry());
  ps.setString(8,model.getParentHandle());
  ps.setString(9,model.getPort43());
  ps.setString(10,model.getLang());
  ps.setString(11,model.getCidr());
  ps.setString(12,model.getCustomPropertiesJsonVal());
  return ps;
}",0.9721485411140584
37138,"@Override public Network save(final Network model){
  KeyHolder keyHolder=new GeneratedKeyHolder();
  jdbcTemplate.update(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(SQL_SAVE_IP,Statement.RETURN_GENERATED_KEYS);
      ps.setString(1,model.getHandle());
      ps.setBytes(2,IpUtil.ipToByteArray(model.getEndAddress(),model.getIpVersion()));
      ps.setBytes(3,IpUtil.ipToByteArray(model.getStartAddress(),model.getIpVersion()));
      ps.setString(4,model.getIpVersion().getName());
      ps.setString(5,model.getName());
      ps.setString(6,model.getType());
      ps.setString(7,model.getCountry());
      ps.setString(8,model.getParentHandle());
      ps.setString(9,model.getPort43());
      ps.setString(10,model.getLang());
      ps.setString(11,model.getCidr());
      ps.setString(12,model.getCustomPropertiesJsonVal());
      return ps;
    }
  }
,keyHolder);
  model.setId(keyHolder.getKey().longValue());
  return model;
}","@Override public Network save(final Network model){
  KeyHolder keyHolder=new GeneratedKeyHolder();
  jdbcTemplate.update(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(SQL_SAVE_IP,Statement.RETURN_GENERATED_KEYS);
      ps.setString(1,model.getHandle());
      ps.setBytes(2,IpUtil.ipToByteArray(model.getEndAddress()));
      ps.setBytes(3,IpUtil.ipToByteArray(model.getStartAddress()));
      ps.setString(4,model.getIpVersion().getName());
      ps.setString(5,model.getName());
      ps.setString(6,model.getType());
      ps.setString(7,model.getCountry());
      ps.setString(8,model.getParentHandle());
      ps.setString(9,model.getPort43());
      ps.setString(10,model.getLang());
      ps.setString(11,model.getCidr());
      ps.setString(12,model.getCustomPropertiesJsonVal());
      return ps;
    }
  }
,keyHolder);
  model.setId(keyHolder.getKey().longValue());
  return model;
}",0.9489603024574668
37139,"@Override public void update(final Network model){
  jdbcTemplate.update(SQL_UPDATE_IP,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setBytes(1,IpUtil.ipToByteArray(model.getEndAddress(),model.getIpVersion()));
      ps.setBytes(2,IpUtil.ipToByteArray(model.getStartAddress(),model.getIpVersion()));
      ps.setString(3,model.getIpVersion().getName());
      ps.setString(4,model.getName());
      ps.setString(5,model.getType());
      ps.setString(6,model.getCountry());
      ps.setString(7,model.getParentHandle());
      ps.setString(8,model.getPort43());
      ps.setString(9,model.getLang());
      ps.setString(10,model.getCidr());
      ps.setString(11,model.getCustomPropertiesJsonVal());
      ps.setLong(12,model.getId());
    }
  }
);
}","@Override public void update(final Network model){
  jdbcTemplate.update(SQL_UPDATE_IP,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setBytes(1,IpUtil.ipToByteArray(model.getEndAddress()));
      ps.setBytes(2,IpUtil.ipToByteArray(model.getStartAddress()));
      ps.setString(3,model.getIpVersion().getName());
      ps.setString(4,model.getName());
      ps.setString(5,model.getType());
      ps.setString(6,model.getCountry());
      ps.setString(7,model.getParentHandle());
      ps.setString(8,model.getPort43());
      ps.setString(9,model.getLang());
      ps.setString(10,model.getCidr());
      ps.setString(11,model.getCustomPropertiesJsonVal());
      ps.setLong(12,model.getId());
    }
  }
);
}",0.973651191969887
37140,"/** 
 * parseTelephoneTypes.
 * @param typesStr types String, split by ';'.
 * @return TelephoneType list.
 */
private List<TelephoneType> parseTelephoneTypes(String typesStr){
  List<TelephoneType> types=new ArrayList<TelephoneType>();
  String[] typeSplitStrArray=StringUtils.split(typesStr,""String_Node_Str"");
  for (  String typeSplit : typeSplitStrArray) {
    TelephoneType type=TelephoneType.find(typeSplit);
    if (null != type) {
      types.add(type);
    }
  }
  return types;
}","/** 
 * parseTelephoneTypes.
 * @param typesStr types String, split by ';'.
 * @return TelephoneType list.
 */
private List<TelephoneType> parseTelephoneTypes(String typesStr){
  List<TelephoneType> types=new ArrayList<TelephoneType>();
  String[] typeSplitStrArray=StringUtils.split(typesStr,""String_Node_Str"");
  if (null == typeSplitStrArray) {
    return types;
  }
  for (  String typeSplit : typeSplitStrArray) {
    TelephoneType type=TelephoneType.find(typeSplit);
    if (null != type) {
      types.add(type);
    }
  }
  return types;
}",0.9450337512054002
37141,"@Override protected void execute(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  getDao().update(entity);
  LOGGER.debug(""String_Node_Str"");
  getDao().updateStatus(entity);
  EntityDto dto=(EntityDto)entity.getDto();
  updateEntityAddresses(entity);
  updateEntitiesRel(entity);
  updatePublicIds(dto.getPublicIds(),entity);
  updateBaseModel(entity);
}","@Override protected void execute(Entity entity){
  LOGGER.debug(""String_Node_Str"");
  getDao().update(entity);
  LOGGER.debug(""String_Node_Str"");
  getDao().updateStatus(entity);
  EntityDto dto=(EntityDto)entity.getDto();
  updateEntityAddresses(entity);
  updateEntityTels(entity);
  updatePublicIds(dto.getPublicIds(),entity);
  updateBaseModel(entity);
}",0.99023709902371
37142,"public static void checkValidAndMinMaxDate(String dateString,Date minValue,Date maxValue,String fieldName,ValidationResult validationResult){
  if (StringUtils.isEmpty(dateString)) {
    return;
  }
  Date dateValue=DateUtil.parseUTC(dateString);
  if (null == dateValue) {
    validationResult.addError(UpdateValidationError.build4008Error(fieldName));
    return;
  }
  checkMinMaxDate(dateValue,minValue,maxValue,fieldName,validationResult);
}","public static void checkValidAndMinMaxDate(String dateString,Date minValue,Date maxValue,String fieldName,ValidationResult validationResult){
  if (StringUtils.isEmpty(dateString)) {
    return;
  }
  Date dateValue=DateUtil.parseUTC(dateString);
  if (null == dateValue) {
    validationResult.addError(UpdateValidationError.build4007Error(fieldName));
    return;
  }
  checkMinMaxDate(dateValue,minValue,maxValue,fieldName,validationResult);
}",0.9977578475336324
37143,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_event_date() throws Exception {
  DomainDto domain=generateDomainDto();
  List<EventDto> events=new ArrayList<EventDto>();
  domain.setEvents(events);
  EventDto event=new EventDto();
  events.add(event);
  event.setEventAction(""String_Node_Str"");
  event.setEventActor(""String_Node_Str"");
  event.setEventDate(""String_Node_Str"");
  String content=JsonHelper.serialize(domain);
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4008)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4008.getMessage(),""String_Node_Str""))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_event_date() throws Exception {
  DomainDto domain=generateDomainDto();
  List<EventDto> events=new ArrayList<EventDto>();
  domain.setEvents(events);
  EventDto event=new EventDto();
  events.add(event);
  event.setEventAction(""String_Node_Str"");
  event.setEventActor(""String_Node_Str"");
  event.setEventDate(""String_Node_Str"");
  String content=JsonHelper.serialize(domain);
  mockMvc.perform(post(URI_DOMAIN_U).contentType(MediaType.parseMediaType(rdapJson)).content(content)).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4007)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4007.getMessage(),""String_Node_Str""))));
}",0.9977949283351708
37144,"/** 
 * check if mediaTypes contains supported media type.
 * @param mediaTypes mediaTypes.
 * @return true if contain, false if not.
 */
private boolean containsSupportedMediaType(List<MediaType> mediaTypes){
  LOGGER.debug(""String_Node_Str"",SUPPORTED_MEDIA_TYPE);
  for (  MediaType supportedMediaType : SUPPORTED_MEDIA_TYPE) {
    for (    MediaType mediaType : SUPPORTED_MEDIA_TYPE) {
      if (StringUtils.equalsIgnoreCase(supportedMediaType.getType(),mediaType.getType()) && StringUtils.equalsIgnoreCase(supportedMediaType.getSubtype(),mediaType.getSubtype())) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * check if mediaTypes contains supported media type.
 * @param mediaTypes mediaTypes.
 * @return true if contain, false if not.
 */
private boolean containsSupportedMediaType(List<MediaType> mediaTypes){
  LOGGER.debug(""String_Node_Str"",SUPPORTED_MEDIA_TYPE);
  for (  MediaType supportedMediaType : SUPPORTED_MEDIA_TYPE) {
    for (    MediaType mediaType : mediaTypes) {
      if (StringUtils.equalsIgnoreCase(supportedMediaType.getType(),mediaType.getType()) && StringUtils.equalsIgnoreCase(supportedMediaType.getSubtype(),mediaType.getSubtype())) {
        return true;
      }
    }
  }
  return false;
}",0.9758064516129032
37145,"private void checkVariants(DomainDto domainDto,ValidationResult validationResult){
  List<VariantDto> variants=domainDto.getVariants();
  if (null == variants) {
    return;
  }
  for (  VariantDto variant : variants) {
    checkMaxLength(variant.getIdnTable(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
    List<String> relations=variant.getRelation();
    if (null != relations) {
      for (      String relation : relations) {
        checkMaxLength(relation,MAX_LENGTH_255,""String_Node_Str"",validationResult);
      }
    }
    List<VariantNameDto> variantNames=variant.getVariantNames();
    if (null != variantNames) {
      for (      VariantNameDto variantName : variantNames) {
        checkNotEmptyAndMaxLength(variantName.getLdhName(),MAX_LENGTH_HANDLE,""String_Node_Str"",validationResult);
        checkNotEmptyAndMaxLength(variantName.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
      }
    }
  }
}","private void checkVariants(DomainDto domainDto,ValidationResult validationResult){
  List<VariantDto> variants=domainDto.getVariants();
  if (null == variants) {
    return;
  }
  for (  VariantDto variant : variants) {
    checkMaxLength(variant.getIdnTable(),MAX_LENGTH_255,""String_Node_Str"",validationResult);
    List<String> relations=variant.getRelation();
    if (null != relations) {
      for (      String relation : relations) {
        checkMaxLength(relation,MAX_LENGTH_255,""String_Node_Str"",validationResult);
      }
    }
    List<VariantNameDto> variantNames=variant.getVariantNames();
    if (null != variantNames) {
      for (      VariantNameDto variantName : variantNames) {
        checkNotEmptyAndMaxLength(variantName.getLdhName(),MAX_LENGTH_LDHNAME,""String_Node_Str"",validationResult);
        checkNotEmptyAndMaxLength(variantName.getUnicodeName(),MAX_LENGTH_UNICODENAME,""String_Node_Str"",validationResult);
      }
    }
  }
}",0.996329313057158
37146,"/** 
 * set network id to domain.
 * @param dto DTO.
 * @param domain domain.
 */
private void convertNetworkIdIfExist(DomainDto dto,Domain domain){
  if (!DomainType.ARPA.equals(DomainType.getByTypeName(dto.getType()))) {
    return;
  }
  if (StringUtils.isBlank(dto.getNetworkHandle())) {
    return;
  }
  Long networkId=networkDao.findIdByHandle(dto.getNetworkHandle());
  if (null != networkId) {
    domain.setNetworkId(networkId);
  }
}","/** 
 * set network id to domain.
 * @param dto DTO.
 * @param domain domain.
 */
private void convertNetworkIdIfExist(DomainDto dto,Domain domain){
  if (StringUtils.isBlank(dto.getNetworkHandle())) {
    return;
  }
  Long networkId=networkDao.findIdByHandle(dto.getNetworkHandle());
  if (null != networkId) {
    domain.setNetworkId(networkId);
  }
}",0.8872180451127819
37147,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(delete(URI_DOMAIN_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson))).andExpect(status().isBadRequest()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(delete(URI_DOMAIN_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}",0.985413290113452
37148,"@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(put(URI_DOMAIN_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson)).content(""String_Node_Str"")).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}","@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(put(URI_DOMAIN_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson)).content(""String_Node_Str"")).andExpect(status().isNotFound()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}",0.9832775919732442
37149,"@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(delete(URI_NS_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson))).andExpect(status().isBadRequest()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}","@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(delete(URI_NS_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}",0.9844559585492229
37150,"@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(put(URI_NS_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson)).content(""String_Node_Str"")).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}","@Test @DatabaseTearDown(""String_Node_Str"") public void test_invalid_handle_not_exist() throws Exception {
  String notExistHandle=""String_Node_Str"";
  mockMvc.perform(put(URI_NS_U + notExistHandle).contentType(MediaType.parseMediaType(rdapJson)).content(""String_Node_Str"")).andExpect(status().isNotFound()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(4041)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(String.format(ServiceErrorCode.ERROR_4041.getMessage(),notExistHandle))));
}",0.9831649831649832
37151,"public String excute(String param,HttpMethodType httpMethod,ObjectType objectType) throws Exception {
  URL url=new URL(makeUrl(objectType));
  URLConnection urlConnection=url.openConnection();
  HttpURLConnection httpURLConnection=(HttpURLConnection)urlConnection;
  httpURLConnection.setConnectTimeout(connectTimeout);
  httpURLConnection.setReadTimeout(readTimeout);
  httpURLConnection.setDoInput(true);
  if (!httpMethod.equals(HttpMethodType.PUT)) {
    httpURLConnection.setDoOutput(true);
    httpURLConnection.setInstanceFollowRedirects(false);
  }
 else {
    httpURLConnection.setDoOutput(false);
    httpURLConnection.setInstanceFollowRedirects(true);
  }
  httpURLConnection.setUseCaches(false);
  httpURLConnection.setRequestMethod(httpMethod.name());
  httpURLConnection.setRequestProperty(""String_Node_Str"",MEDIA_TYPE);
  httpURLConnection.connect();
  httpURLConnection.getOutputStream().write(param.getBytes());
  if (httpURLConnection.getResponseCode() != 200) {
  }
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream()));
  StringBuilder sb=new StringBuilder();
  String line;
  while ((line=reader.readLine()) != null) {
    sb.append(line);
  }
  return sb.toString();
}","public String excute(String param,HttpMethodType httpMethod,ObjectType objectType) throws Exception {
  URL url=new URL(makeUrl(objectType));
  URLConnection urlConnection=url.openConnection();
  HttpURLConnection httpURLConnection=(HttpURLConnection)urlConnection;
  httpURLConnection.setConnectTimeout(connectTimeout);
  httpURLConnection.setReadTimeout(readTimeout);
  httpURLConnection.setDoInput(true);
  if (!httpMethod.equals(HttpMethodType.PUT)) {
    httpURLConnection.setDoOutput(true);
    httpURLConnection.setInstanceFollowRedirects(false);
  }
 else {
    httpURLConnection.setDoOutput(false);
    httpURLConnection.setInstanceFollowRedirects(true);
  }
  httpURLConnection.setUseCaches(false);
  httpURLConnection.setRequestMethod(httpMethod.name());
  httpURLConnection.setRequestProperty(""String_Node_Str"",MEDIA_TYPE);
  httpURLConnection.connect();
  OutputStream out=httpURLConnection.getOutputStream();
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out,""String_Node_Str""));
  writer.write(param);
  writer.flush();
  writer.close();
  out.close();
  if (httpURLConnection.getResponseCode() != 200) {
  }
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream()));
  StringBuilder sb=new StringBuilder();
  String line;
  while ((line=reader.readLine()) != null) {
    sb.append(line);
  }
  return sb.toString();
}",0.924886191198786
37152,"@Test public void test_invalid_variant_ldhName_exceedMaxLength() throws Exception {
  DomainDto dto=generateDomainDto();
  List<VariantDto> variantDto=new ArrayList<VariantDto>();
  dto.setVariants(variantDto);
  VariantDto v=new VariantDto();
  v.setIdnTable(""String_Node_Str"");
  variantDto.add(v);
  String stringExceedOneMoreChar=createStringWithLength(UpdateValidateUtil.MAX_LENGTH_HANDLE + 1);
  List<VariantNameDto> variantNames=new ArrayList<VariantNameDto>();
  VariantNameDto name=new VariantNameDto();
  variantNames.add(name);
  name.setLdhName(stringExceedOneMoreChar);
  v.setVariantNames(variantNames);
  UpdateResponse response=createService.execute(dto);
  assertNotNull(response);
  assertEquals(400,response.getErrorCode());
  assertEquals(4003,response.getSubErrorCode());
}","@Test public void test_invalid_variant_ldhName_exceedMaxLength() throws Exception {
  DomainDto dto=generateDomainDto();
  List<VariantDto> variantDto=new ArrayList<VariantDto>();
  dto.setVariants(variantDto);
  VariantDto v=new VariantDto();
  v.setIdnTable(""String_Node_Str"");
  variantDto.add(v);
  String stringExceedOneMoreChar=createStringWithLength(UpdateValidateUtil.MAX_LENGTH_LDHNAME + 1);
  List<VariantNameDto> variantNames=new ArrayList<VariantNameDto>();
  VariantNameDto name=new VariantNameDto();
  variantNames.add(name);
  name.setLdhName(stringExceedOneMoreChar);
  v.setVariantNames(variantNames);
  UpdateResponse response=createService.execute(dto);
  assertNotNull(response);
  assertEquals(400,response.getErrorCode());
  assertEquals(4003,response.getSubErrorCode());
}",0.9955947136563876
37153,"@Override public void update(final Domain model){
  jdbcTemplate.update(SQL_UPDATE_DOMAIN,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setString(1,model.getLdhName());
      ps.setString(2,model.getUnicodeName());
      ps.setString(3,model.getPort43());
      ps.setString(4,model.getLang());
      ps.setObject(5,model.getNetworkId());
      ps.setString(6,model.getCustomPropertiesJsonVal());
    }
  }
);
}","@Override public void update(final Domain model){
  jdbcTemplate.update(SQL_UPDATE_DOMAIN,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setString(1,model.getLdhName());
      ps.setString(2,model.getUnicodeName());
      ps.setString(3,model.getPort43());
      ps.setString(4,model.getLang());
      ps.setObject(5,model.getNetworkId());
      ps.setString(6,model.getCustomPropertiesJsonVal());
      ps.setLong(7,model.getId());
    }
  }
);
}",0.9647532729103726
37154,"@Override public void update(final Nameserver model){
  jdbcTemplate.update(SQL_UPDATE_NAMESERVER,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setString(1,model.getLdhName());
      ps.setString(2,model.getUnicodeName());
      ps.setString(3,model.getPort43());
      ps.setString(4,model.getLang());
      ps.setString(5,model.getCustomPropertiesJsonVal());
    }
  }
);
}","@Override public void update(final Nameserver model){
  jdbcTemplate.update(SQL_UPDATE_NAMESERVER,new PreparedStatementSetter(){
    public void setValues(    PreparedStatement ps) throws SQLException {
      ps.setString(1,model.getLdhName());
      ps.setString(2,model.getUnicodeName());
      ps.setString(3,model.getPort43());
      ps.setString(4,model.getLang());
      ps.setString(5,model.getCustomPropertiesJsonVal());
      ps.setLong(6,model.getId());
    }
  }
);
}",0.9619978284473398
37155,"/** 
 * do pre process request method.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  boolean httpMethodIsValid=httpMethodIsValid(request);
  LOGGER.debug(""String_Node_Str"",httpMethodIsValid);
  if (!httpMethodIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponse.createResponse405();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  boolean mediaTypeIsValid=mediaTypeIsValid(request);
  LOGGER.debug(""String_Node_Str"",mediaTypeIsValid);
  if (!mediaTypeIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponse.createResponse415();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  return true;
}","/** 
 * do pre process request method.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  boolean httpMethodIsValid=httpMethodIsValid(request);
  LOGGER.debug(""String_Node_Str"",httpMethodIsValid);
  if (!httpMethodIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponse.createResponse405();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  if (FilterHelper.isUpdateUri(request)) {
    boolean contentTypeValid=checkContentTypeForUpdate(request);
    if (!contentTypeValid) {
      ResponseEntity<ErrorMessage> responseEntity=RestResponse.createResponse415();
      FilterHelper.writeResponse(responseEntity,response);
      return contentTypeValid;
    }
    return true;
  }
  boolean mediaTypeIsValid=mediaTypeIsValid(request);
  LOGGER.debug(""String_Node_Str"",mediaTypeIsValid);
  if (!mediaTypeIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponse.createResponse415();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  return true;
}",0.8463636363636363
37156,"private void assertDomain(String updateLdhName,String updateLang,String originalHandle,String updatePort43) throws Exception {
  List<Map<?,?>> resultList=getTableDataForSql(""String_Node_Str"",""String_Node_Str"");
  assertTrue(resultList.size() > 0);
  Map<?,?> actualDomain=resultList.get(0);
  assertEquals(originalHandle,actualDomain.get(""String_Node_Str""));
  assertEquals(DomainType.DNR.getName(),actualDomain.get(""String_Node_Str""));
  assertEquals(updateLdhName,actualDomain.get(""String_Node_Str""));
  assertEquals(updateLdhName,actualDomain.get(""String_Node_Str""));
  assertEquals(updateLang,actualDomain.get(""String_Node_Str""));
  assertEquals(updatePort43,actualDomain.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",actualDomain.get(""String_Node_Str""));
}","private void assertDomain(String updateLdhName,String updateLang,String originalHandle,String updatePort43,String customPropertiesStr) throws Exception {
  List<Map<?,?>> resultList=getTableDataForSql(""String_Node_Str"",""String_Node_Str"" + originalHandle + ""String_Node_Str"");
  assertTrue(resultList.size() > 0);
  Map<?,?> actualDomain=resultList.get(0);
  assertEquals(originalHandle,actualDomain.get(""String_Node_Str""));
  assertEquals(DomainType.DNR.getName(),actualDomain.get(""String_Node_Str""));
  assertEquals(updateLdhName,actualDomain.get(""String_Node_Str""));
  assertEquals(updateLdhName,actualDomain.get(""String_Node_Str""));
  assertEquals(updateLang,actualDomain.get(""String_Node_Str""));
  assertEquals(updatePort43,actualDomain.get(""String_Node_Str""));
  assertEquals(customPropertiesStr,actualDomain.get(""String_Node_Str""));
}",0.9380421313506816
37157,"@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_update_domain_and_status() throws Exception {
  List<Map<?,?>> resultList=getTableDataForSql(""String_Node_Str"",""String_Node_Str"");
  assertTrue(resultList.size() > 0);
  Map<?,?> existDomain=resultList.get(0);
  Integer domainId=(Integer)existDomain.get(""String_Node_Str"");
  assertNotNull(domainId);
  String updateLdhName=""String_Node_Str"";
  String updateLang=""String_Node_Str"";
  String originalHandle=""String_Node_Str"";
  String updatePort43=""String_Node_Str"";
  String updateHandle=""String_Node_Str"";
  String updateStatusRenewProbibited=""String_Node_Str"";
  String updateStatusTransferProbibited=""String_Node_Str"";
  String updateStatusDeleteProbibited=""String_Node_Str"";
  Domain domain=new Domain();
  domain.setId(Long.valueOf(domainId));
  domain.setHandle(updateHandle);
  domain.setLdhName(updateLdhName);
  domain.setUnicodeName(updateLdhName);
  domain.setPort43(updatePort43);
  domain.setLang(updateLang);
  domain.setType(DomainType.ARPA);
  List<String> expectedStatus=new ArrayList<String>();
  expectedStatus.add(updateStatusRenewProbibited);
  expectedStatus.add(updateStatusTransferProbibited);
  expectedStatus.add(updateStatusDeleteProbibited);
  domain.setStatus(expectedStatus);
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  domain.setCustomProperties(customProperties);
  domain.setCustomPropertiesJsonVal(JsonUtil.serializeMap(customProperties));
  updateDao.update(domain);
  updateDao.updateStatus(domain);
  assertDomain(updateLdhName,updateLang,originalHandle,updatePort43);
  assertStatus();
}","@Test @DatabaseSetup(""String_Node_Str"") @DatabaseTearDown(""String_Node_Str"") public void test_update_domain_and_status() throws Exception {
  List<Map<?,?>> resultList=getTableDataForSql(""String_Node_Str"",""String_Node_Str"");
  assertTrue(resultList.size() > 0);
  Map<?,?> existDomain=resultList.get(0);
  Integer domainId=(Integer)existDomain.get(""String_Node_Str"");
  assertNotNull(domainId);
  String updateLdhName=""String_Node_Str"";
  String updateLang=""String_Node_Str"";
  String originalHandle=""String_Node_Str"";
  String updatePort43=""String_Node_Str"";
  String updateHandle=""String_Node_Str"";
  String updateStatusRenewProbibited=""String_Node_Str"";
  String updateStatusTransferProbibited=""String_Node_Str"";
  String updateStatusDeleteProbibited=""String_Node_Str"";
  Domain domain=new Domain();
  domain.setId(Long.valueOf(domainId));
  domain.setHandle(updateHandle);
  domain.setLdhName(updateLdhName);
  domain.setUnicodeName(updateLdhName);
  domain.setPort43(updatePort43);
  domain.setLang(updateLang);
  domain.setType(DomainType.ARPA);
  List<String> expectedStatus=new ArrayList<String>();
  expectedStatus.add(updateStatusRenewProbibited);
  expectedStatus.add(updateStatusTransferProbibited);
  expectedStatus.add(updateStatusDeleteProbibited);
  domain.setStatus(expectedStatus);
  Map<String,String> customProperties=new HashMap<String,String>();
  customProperties.put(""String_Node_Str"",""String_Node_Str"");
  domain.setCustomProperties(customProperties);
  domain.setCustomPropertiesJsonVal(JsonUtil.serializeMap(customProperties));
  updateDao.update(domain);
  updateDao.updateStatus(domain);
  assertDomain(updateLdhName,updateLang,originalHandle,updatePort43,""String_Node_Str"");
  assertDomain(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertStatus();
}",0.964659315804354
37158,"/** 
 * setServiceFilters.
 * @param serviceFilters serviceFilters.
 */
@Resource(name=""String_Node_Str"") public void setServiceFilters(List<QueryFilter> serviceFilters){
  RestResponse.queryFilters=serviceFilters;
}","/** 
 * setServiceFilters.
 * @param serviceFilters serviceFilters.
 */
@Resource(name=""String_Node_Str"") @Qualifier(""String_Node_Str"") public void setServiceFilters(List<QueryFilter> serviceFilters){
  RestResponse.queryFilters=serviceFilters;
}",0.935064935064935
37159,"private void queryDomainStatus(Domain domain){
  final long domainId=domain.getId();
  List<String> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(SQL_QUERY_DOMAIN_STATUS);
      ps.setLong(1,domainId);
      return ps;
    }
  }
,new StatusResultSetExtractor());
  if (null != result && result.size() != 0) {
    domain.setStatus(result);
  }
}","public void queryDomainStatus(Domain domain){
  if (domain != null) {
    final long domainId=domain.getId();
    List<String> result=jdbcTemplate.query(new PreparedStatementCreator(){
      @Override public PreparedStatement createPreparedStatement(      Connection connection) throws SQLException {
        PreparedStatement ps=connection.prepareStatement(SQL_QUERY_DOMAIN_STATUS);
        ps.setLong(1,domainId);
        return ps;
      }
    }
,new StatusResultSetExtractor());
    if (null != result && result.size() != 0) {
      domain.setStatus(result);
    }
  }
}",0.94257064721969
37160,"@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainSearchParam=(DomainSearchParam)queryParam;
  final String domainName=domainSearchParam.getQ();
  final String punyName=domainSearchParam.getPunyName();
  final String domainNameLikeClause=generateLikeClause(domainName);
  final String punyNameLikeClause=generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + DomainQueryDaoImpl.SQL_LEFT_JOIN_DOMAIN_STATUS + ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=domainSearchParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  List<Domain> result=null;
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,domainNameLikeClause);
      ps.setLong(3,startRow);
      ps.setLong(4,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  return result;
}","@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainSearchParam=(DomainSearchParam)queryParam;
  final String domainName=domainSearchParam.getQ();
  final String punyName=domainSearchParam.getPunyName();
  final String domainNameLikeClause=generateLikeClause(domainName);
  final String punyNameLikeClause=generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  final PageBean page=domainSearchParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  List<Domain> result=null;
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,domainNameLikeClause);
      ps.setLong(3,startRow);
      ps.setLong(4,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  for (  Domain domain : result) {
    domainDao.queryDomainStatus(domain);
  }
  return result;
}",0.9390243902439024
37161,"@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  List<Domain> result=null;
  final PageBean page=domainQueryParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  String ipPrefix=domainQueryParam.getQ();
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ipPrefix);
  final byte[] ipBytes=IpUtil.ipToByteArray(ipPrefix,ipVersion);
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + DomainQueryDaoImpl.SQL_LEFT_JOIN_DOMAIN_STATUS + ""String_Node_Str"";
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setBytes(1,ipBytes);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  return result;
}","@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  List<Domain> result=null;
  final PageBean page=domainQueryParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  String ipPrefix=domainQueryParam.getQ();
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ipPrefix);
  final byte[] ipBytes=IpUtil.ipToByteArray(ipPrefix,ipVersion);
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setBytes(1,ipBytes);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  for (  Domain domain : result) {
    domainDao.queryDomainStatus(domain);
  }
  return result;
}",0.934747145187602
37162,"@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  final String punyNameLikeClause=generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + DomainQueryDaoImpl.SQL_LEFT_JOIN_DOMAIN_STATUS + ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=queryParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  return result;
}","@Override public List<Domain> search(QueryParam queryParam,JdbcTemplate jdbcTemplate){
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  final String punyNameLikeClause=generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=queryParam.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  DomainQueryDaoImpl domainDao=new DomainQueryDaoImpl();
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,domainDao.new DomainWithStatusResultSetExtractor());
  for (  Domain domain : result) {
    domainDao.queryDomainStatus(domain);
  }
  return result;
}",0.9323181049069372
37163,"/** 
 * batch create KeyData.
 * @param outerObjectId object id of outer object	 
 * @param models KeyData of outer Object
 */
@Override public void batchCreateAsInnerObjects(BaseModel outerModel,List<KeyDataDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  KeyDataDto model : models) {
    Long keyDataId=createKeyData(model);
    secureDnsUpdateDao.createRelSecureDnsDskey(outerModel.getId(),ModelType.KEYDATA,keyDataId);
    KeyData keyDataAsOuter=new KeyData();
    keyDataAsOuter.setId(keyDataId);
    linkUpdateDao.batchCreateAsInnerObjects(keyDataAsOuter,model.getLinks());
    eventUpdateDao.batchCreateAsInnerObjects(keyDataAsOuter,model.getEvents());
  }
}","/** 
 * batch create KeyData.
 * @param outerModel outer object	 
 * @param models KeyData of outer Object
 */
@Override public void batchCreateAsInnerObjects(BaseModel outerModel,List<KeyDataDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  KeyDataDto model : models) {
    Long keyDataId=createKeyData(model);
    secureDnsUpdateDao.createRelSecureDnsDskey(outerModel.getId(),ModelType.KEYDATA,keyDataId);
    KeyData keyDataAsOuter=new KeyData();
    keyDataAsOuter.setId(keyDataId);
    linkUpdateDao.batchCreateAsInnerObjects(keyDataAsOuter,model.getLinks());
    eventUpdateDao.batchCreateAsInnerObjects(keyDataAsOuter,model.getEvents());
  }
}",0.9812409812409812
37164,"/** 
 * batch create publicId.
 * @param outerObjectId object id of outer object
 * @param outerModelType model type of outer object
 * @param models PublicId of outer Object
 */
@Override public void batchCreateAsInnerObjects(BaseModel outerModel,List<PublicIdDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  PublicIdDto model : models) {
    Long publicId=queryByIndentifierAndType(model);
    if (null == publicId) {
      publicId=createPublicId(model);
    }
    createRelPublicId(outerModel,publicId);
  }
}","/** 
 * batch create publicId.
 * @param outerModel outer object
 * @param models PublicId of outer Object
 */
@Override public void batchCreateAsInnerObjects(BaseModel outerModel,List<PublicIdDto> models){
  if (null == models || models.size() == 0) {
    return;
  }
  for (  PublicIdDto model : models) {
    Long publicId=queryByIndentifierAndType(model);
    if (null == publicId) {
      publicId=createPublicId(model);
    }
    createRelPublicId(outerModel,publicId);
  }
}",0.933980582524272
37165,"/** 
 * @param outerObjectId object id of outer object
 * @param outerModelType model type of outer object
 * @param publicId publicId
 */
private void createRelPublicId(final BaseModel outerModel,final Long publicId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.update(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      ps.setLong(3,publicId);
      return ps;
    }
  }
);
}","/** 
 * @param outerModel outer object
 * @param publicId publicId
 */
private void createRelPublicId(final BaseModel outerModel,final Long publicId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  jdbcTemplate.update(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerModel.getId());
      ps.setString(2,outerModel.getObjectType().getName());
      ps.setLong(3,publicId);
      return ps;
    }
  }
);
}",0.9452495974235104
37166,"/** 
 * query publicId from RDAP_PUBLICID by IDENTIFIER and TYPE.
 * @param model PublicId object.
 * @return public id
 */
private Long queryByIndentifierAndType(final PublicIdDto model){
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  List<Long> PublicIds=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,model.getIdentifier());
      ps.setString(2,model.getType());
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (PublicIds.size() > 0) {
    return PublicIds.get(0);
  }
  return null;
}","/** 
 * query publicId from RDAP_PUBLICID by IDENTIFIER and TYPE.
 * @param model PublicId object.
 * @return public id
 */
private Long queryByIndentifierAndType(final PublicIdDto model){
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  List<Long> publicIds=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,model.getIdentifier());
      ps.setString(2,model.getType());
      return ps;
    }
  }
,new RowMapper<Long>(){
    public Long mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return rs.getLong(""String_Node_Str"");
    }
  }
);
  if (publicIds.size() > 0) {
    return publicIds.get(0);
  }
  return null;
}",0.9963985594237696
37167,"/** 
 * query common domain and its status from database, without inner objects.
 * @param queryParam query parameter include punyname.
 * @return domain object without inner objects.
 */
private Domain queryDomainWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  LOGGER.debug(""String_Node_Str"",punyName);
  final String sql=""String_Node_Str"" + SQL_LEFT_JOIN_DOMAIN_STATUS + ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}","/** 
 * query common domain and its status from database, without inner objects.
 * @param queryParam query parameter include punyname.
 * @return domain object without inner objects.
 */
private Domain queryDomainWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  LOGGER.debug(""String_Node_Str"",punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}",0.9840085287846482
37168,"@Override public List<Domain> extractData(ResultSet rs) throws SQLException {
  List<Domain> result=new ArrayList<Domain>();
  Map<Long,Domain> domainMapById=new HashMap<Long,Domain>();
  while (rs.next()) {
    Long domainId=rs.getLong(""String_Node_Str"");
    Domain domain=domainMapById.get(domainId);
    if (null == domain) {
      domain=new Domain();
      extractDomainFromRs(rs,domain);
      extractCustomPropertiesFromRs(rs,domain);
      result.add(domain);
      domainMapById.put(domainId,domain);
    }
    domain.addStatus(rs.getString(""String_Node_Str""));
  }
  return result;
}","@Override public List<String> extractData(ResultSet rs) throws SQLException {
  List<String> result=new ArrayList<String>();
  while (rs.next()) {
    String status=rs.getString(""String_Node_Str"");
    if (!result.contains(status)) {
      result.add(status);
    }
  }
  return result;
}",0.4807256235827664
37169,"/** 
 * query domain (RIR or DNR).
 * @param queryParam QueryParam include punyname.
 * @return domain object.
 */
@Override public Domain query(QueryParam queryParam){
  LOGGER.debug(""String_Node_Str"" + queryParam);
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  if (domainQueryParam.isRirDomain()) {
    Domain domain=queryArpaWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    LOGGER.debug(""String_Node_Str"" + domain);
    return domain;
  }
 else {
    Domain domain=queryDomainWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    LOGGER.debug(""String_Node_Str"" + domain);
    return domain;
  }
}","/** 
 * query domain (RIR or DNR).
 * @param queryParam QueryParam include punyname.
 * @return domain object.
 */
@Override public Domain query(QueryParam queryParam){
  LOGGER.debug(""String_Node_Str"" + queryParam);
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  if (domainQueryParam.isRirDomain()) {
    Domain domain=queryArpaWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    LOGGER.debug(""String_Node_Str"" + domain);
    queryDomainStatus(domain);
    return domain;
  }
 else {
    Domain domain=queryDomainWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    LOGGER.debug(""String_Node_Str"" + domain);
    queryDomainStatus(domain);
    return domain;
  }
}",0.9555236728837876
37170,"@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql);
  ps.setString(1,punyName);
  return ps;
}","@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(SQL_QUERY_DOMAIN_STATUS);
  ps.setLong(1,domainId);
  return ps;
}",0.8867924528301887
37171,"/** 
 * query domain by arpa, without inner objects. <p> different sql for ipv4 and ipv6.
 * @param queryParam query parameter include punyname
 * @return domain the domain object without inner objects
 */
private Domain queryArpaWithoutInnerObjects(QueryParam queryParam){
  final String arpaName=queryParam.getQ();
  final NetworkInBytes network=ArpaUtil.parseArpa(arpaName);
  List<Domain> result=null;
  final int hexCharSize=IpUtil.getHexCharSize(network.getIpVersion());
  String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + SQL_LEFT_JOIN_DOMAIN_STATUS + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final String finalSql=sql;
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(finalSql);
      ps.setBytes(1,network.getStartAddress());
      ps.setBytes(2,network.getStartAddress());
      ps.setString(3,network.getIpVersion().getName());
      ps.setInt(4,hexCharSize);
      ps.setInt(5,hexCharSize);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}","/** 
 * query domain by arpa, without inner objects. <p> different sql for ipv4 and ipv6.
 * @param queryParam query parameter include punyname
 * @return domain the domain object without inner objects
 */
private Domain queryArpaWithoutInnerObjects(QueryParam queryParam){
  final String arpaName=queryParam.getQ();
  final NetworkInBytes network=ArpaUtil.parseArpa(arpaName);
  List<Domain> result=null;
  final int hexCharSize=IpUtil.getHexCharSize(network.getIpVersion());
  String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final String finalSql=sql;
  result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(finalSql);
      ps.setBytes(1,network.getStartAddress());
      ps.setBytes(2,network.getStartAddress());
      ps.setString(3,network.getIpVersion().getName());
      ps.setInt(4,hexCharSize);
      ps.setInt(5,hexCharSize);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}",0.9881271543469936
37172,"protected void convertCustomProperties(DTO dto,MODEL model){
  Map<String,String> customProperties=dto.getCustomProperties();
  model.setCustomProperties(customProperties);
  model.setCustomPropertiesJsonVal(JsonUtil.serializeMap(customProperties));
}","protected void convertCustomProperties(DTO dto,MODEL model){
  Map<String,String> customProperties=dto.getCustomProperties();
  model.setCustomProperties(customProperties);
  if (null == customProperties || customProperties.isEmpty()) {
    return;
  }
  model.setCustomPropertiesJsonVal(JsonUtil.serializeMap(customProperties));
}",0.8625429553264605
37173,"public static Date parse(String dateString,String format){
  try {
    Date date=new SimpleDateFormat(format).parse(dateString);
    return date;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}","public static Date parse(String dateString,String format){
  try {
    SimpleDateFormat sdf=new SimpleDateFormat(format);
    sdf.setLenient(false);
    Date date=sdf.parse(dateString);
    return date;
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}",0.8582230623818525
37174,"/** 
 * check if is update URI.
 * @param uri URI.
 * @return true if is update URI, false if not.
 */
public static boolean isUpdateUri(String uri){
  return StringUtils.startsWith(uri,""String_Node_Str"");
}","/** 
 * check if is update URI.
 * @param uri URI.
 * @return true if is update URI, false if not.
 */
public static boolean isUpdateUri(HttpServletRequest request){
  String uri=request.getRequestURI();
  String contextPath=request.getContextPath();
  if (StringUtils.equals(contextPath,""String_Node_Str"")) {
    contextPath=StringUtils.EMPTY;
  }
  return StringUtils.startsWith(uri,contextPath + ""String_Node_Str"");
}",0.5231259968102073
37175,"@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  String uri=req.getRequestURI();
  if (FilterHelper.isUpdateUri(uri)) {
    return false;
  }
  return true;
}","@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  if (FilterHelper.isUpdateUri(req)) {
    return false;
  }
  return true;
}",0.8938547486033519
37176,"@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  String uri=req.getRequestURI();
  if (FilterHelper.isUpdateUri(uri)) {
    return false;
  }
  return true;
}","@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  if (FilterHelper.isUpdateUri(req)) {
    return false;
  }
  return true;
}",0.8938547486033519
37177,"/** 
 * check if HTTP METHOD is valid.
 * @param request HttpServletRequest
 * @return true if valid, false if not
 */
private boolean httpMethodIsValid(HttpServletRequest request){
  String method=request.getMethod();
  String uri=request.getRequestURI();
  if (FilterHelper.isUpdateUri(uri)) {
    boolean httpMethodIsValid=UPDATE_ALLOW_METHODS.contains(method);
    return httpMethodIsValid;
  }
 else {
    boolean httpMethodIsValid=QUERY_ALLOW_METHODS.contains(method);
    return httpMethodIsValid;
  }
}","/** 
 * check if HTTP METHOD is valid.
 * @param request HttpServletRequest
 * @return true if valid, false if not
 */
private boolean httpMethodIsValid(HttpServletRequest request){
  String method=request.getMethod();
  if (FilterHelper.isUpdateUri(request)) {
    boolean httpMethodIsValid=UPDATE_ALLOW_METHODS.contains(method);
    return httpMethodIsValid;
  }
 else {
    boolean httpMethodIsValid=QUERY_ALLOW_METHODS.contains(method);
    return httpMethodIsValid;
  }
}",0.8985801217038539
37178,"@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  String uri=req.getRequestURI();
  if (FilterHelper.isUpdateUri(uri)) {
    return false;
  }
  return true;
}","@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  if (FilterHelper.isUpdateUri(req)) {
    return false;
  }
  return true;
}",0.8938547486033519
37179,"@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  String uri=req.getRequestURI();
  if (FilterHelper.isUpdateUri(uri)) {
    return false;
  }
  return true;
}","@Override public boolean needFilter(HttpServletRequest req,HttpServletResponse res){
  if (FilterHelper.isUpdateUri(req)) {
    return false;
  }
  return true;
}",0.8938547486033519
37180,"/** 
 * set network id to domain.
 * @param dto DTO.
 * @param domain domain.
 */
private void convertNetworkIdIfExist(DomainDto dto,Domain domain){
  if (StringUtils.isBlank(dto.getNetworkHandle())) {
    return;
  }
  Long networkId=dao.findIdByHandle(dto.getNetworkHandle());
  if (null != networkId) {
    domain.setNetworkId(networkId);
  }
}","/** 
 * set network id to domain.
 * @param dto DTO.
 * @param domain domain.
 */
private void convertNetworkIdIfExist(DomainDto dto,Domain domain){
  if (StringUtils.isBlank(dto.getNetworkHandle())) {
    return;
  }
  Long networkId=networkDao.findIdByHandle(dto.getNetworkHandle());
  if (null != networkId) {
    domain.setNetworkId(networkId);
  }
}",0.9871611982881596
37181,"/** 
 * check if is not-resolved-ascii domain.
 * @param domainName domainName.
 * @param punyDomainName punyDomainName.
 * @param punyWithoutLastPoint punyWithoutLastPoint.
 * @param domainNameWithoutLastPoint domainNameWithoutLastPoint.
 * @param forSearch forSearch.
 * @return true if is not-resolved-ascii domain.
 */
private static boolean nonReservedAsciiDomain(String domainName,String punyDomainName,String punyWithoutLastPoint,String domainNameWithoutLastPoint,boolean forSearch){
  if (!forSearch && StringUtils.startsWith(domainName,ACE_PREFIX)) {
    return false;
  }
  return domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint);
}","/** 
 * check if is not-resolved-ascii domain.
 * @param domainName domainName.
 * @param punyDomainName punyDomainName.
 * @param punyWithoutLastPoint punyWithoutLastPoint.
 * @param domainNameWithoutLastPoint domainNameWithoutLastPoint.
 * @param forSearch forSearch.
 * @return true if is not-resolved-ascii domain.
 */
private static boolean nonReservedAsciiDomain(String domainName,String punyDomainName,String punyWithoutLastPoint,String domainNameWithoutLastPoint,boolean forSearch){
  if (!forSearch && StringUtils.startsWith(domainName,ACE_PREFIX)) {
    return false;
  }
  if (!forSearch && 2 == StringUtils.indexOf(domainName,""String_Node_Str"")) {
    return false;
  }
  return domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint);
}",0.9320652173913044
37182,"/** 
 * test validateSearchStringIsValidIdna.
 */
@Test public void testValidateSearchStringIsValidIdna(){
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateSearchStringIsValidIdna.
 */
@Test public void testValidateSearchStringIsValidIdna(){
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
}",0.9903466432645898
37183,"/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",false));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",false));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",true));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}",0.7760934633581152
37184,"/** 
 * convert VCARD to JSON.
 * @return JSON string.
 */
public String toJSON(){
  VCard vcard=new VCard();
  if (null == entity) {
    return this.writeJSON(vcard);
  }
  for (  JcardPropertyConverter converter : converters) {
    converter.convertAndSetProperty(vcard,entity);
  }
  return this.writeJSON(vcard);
}","/** 
 * convert VCARD to JSON.
 * @return JSON string.
 */
public String toJSON(){
  VCard vcard=new VCard();
  if (null == entity) {
    return this.writeJSON(vcard);
  }
  for (  JcardPropertyConverter converter : converters) {
    converter.convertAndSetProperty(vcard,entity);
  }
  if (!vcard.iterator().hasNext()) {
    return null;
  }
  return this.writeJSON(vcard);
}",0.8933717579250721
37185,"/** 
 * do pre process request address.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  if (ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax()) {
    writeError509Response(response);
    return false;
  }
  return true;
}","/** 
 * do pre process request address.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String ip=request.getRemoteAddr();
  if (ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(ip)) {
    writeError509Response(response);
    return false;
  }
  return true;
}",0.960960960960961
37186,"/** 
 * do post process.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true .
 */
@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  return true;
}","/** 
 * do post process.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true .
 */
@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String ip=request.getRemoteAddr();
  ConnectionControlService.decrementAndGetCurrentQueryCount(ip);
  return true;
}",0.759018759018759
37187,"/** 
 * increment concurrent query count, and check if exceed max count.MUST call decrementAndGetCurrentQueryCount after query.
 * @return true if exceed, false if not.
 */
public static boolean incrementConcurrentQCountAndCheckIfExceedMax(){
  LOGGER.debug(""String_Node_Str"");
  if (isConcurrentCountNotLimit()) {
    return false;
  }
  int count=CONCURRENT_Q_COUNT.getAndIncrement();
  LOGGER.debug(""String_Node_Str"",count);
  if (count > RdapProperties.getMaxConcurrentCount() - 1) {
    LOGGER.debug(""String_Node_Str"",RdapProperties.getMaxConcurrentCount());
    return true;
  }
  return false;
}","/** 
 * increment concurrent query count, and check if exceed max count.MUST call decrementAndGetCurrentQueryCount after query.
 * @param ip
 * @return true if exceed, false if not.
 */
public static boolean incrementConcurrentQCountAndCheckIfExceedMax(String ip){
  LOGGER.debug(""String_Node_Str"");
  if (isConcurrentCountNotLimit()) {
    return false;
  }
  if (isInIpWhiteList(ip)) {
    return false;
  }
  int count=CONCURRENT_Q_COUNT.getAndIncrement();
  LOGGER.debug(""String_Node_Str"",count);
  if (count > RdapProperties.getMaxConcurrentCount() - 1) {
    LOGGER.debug(""String_Node_Str"",RdapProperties.getMaxConcurrentCount());
    return true;
  }
  return false;
}",0.94283476898982
37188,"/** 
 * decrement current query count.
 */
public static void decrementAndGetCurrentQueryCount(){
  LOGGER.debug(""String_Node_Str"");
  if (isConcurrentCountNotLimit()) {
    return;
  }
  int count=CONCURRENT_Q_COUNT.decrementAndGet();
  LOGGER.debug(""String_Node_Str"",count);
}","/** 
 * decrement current query count.
 * @param ip
 */
public static void decrementAndGetCurrentQueryCount(String ip){
  LOGGER.debug(""String_Node_Str"");
  if (isConcurrentCountNotLimit()) {
    return;
  }
  if (isInIpWhiteList(ip)) {
    return;
  }
  int count=CONCURRENT_Q_COUNT.decrementAndGet();
  LOGGER.debug(""String_Node_Str"",count);
}",0.8924558587479936
37189,"/** 
 * get exceed rate limit.
 * @param ip client ip.
 * @return true if exceed rate limit,false if not.
 */
public static boolean exceedRateLimit(String ip){
  if (!hasLimit()) {
    return false;
  }
  LOGGER.debug(""String_Node_Str"",ip);
  if (StringUtils.isBlank(ip)) {
    return false;
  }
  if (isInIpWhiteList(ip)) {
    return false;
  }
  Long lastAccessTime=CLIENT_IP2LAST_ACCESS_TIME_MAP.get(ip);
  long currentTimeMillis=System.currentTimeMillis();
  if (hasLimit()) {
    CLIENT_IP2LAST_ACCESS_TIME_MAP.put(ip,currentTimeMillis);
  }
  if (null == lastAccessTime) {
    return false;
  }
  long accessTimeInterval=currentTimeMillis - lastAccessTime;
  if (PrincipalHolder.getPrincipal().isAnonymous()) {
    LOGGER.debug(""String_Node_Str"");
    return accessTimeInterval <= MIN_SECONDS_ACCESS_INTERVAL_FOR_ANONYMOUS;
  }
 else {
    LOGGER.debug(""String_Node_Str"");
    return accessTimeInterval <= MIN_SECONDS_ACCESS_INTERVAL_AUTHED;
  }
}","/** 
 * get exceed rate limit.
 * @param ip client ip.
 * @return true if exceed rate limit,false if not.
 */
public static boolean exceedRateLimit(String ip){
  if (!hasLimit()) {
    return false;
  }
  LOGGER.debug(""String_Node_Str"",ip);
  if (isInIpWhiteList(ip)) {
    return false;
  }
  Long lastAccessTime=CLIENT_IP2LAST_ACCESS_TIME_MAP.get(ip);
  long currentTimeMillis=System.currentTimeMillis();
  if (hasLimit()) {
    CLIENT_IP2LAST_ACCESS_TIME_MAP.put(ip,currentTimeMillis);
  }
  if (null == lastAccessTime) {
    return false;
  }
  long accessTimeInterval=currentTimeMillis - lastAccessTime;
  if (PrincipalHolder.getPrincipal().isAnonymous()) {
    LOGGER.debug(""String_Node_Str"");
    return accessTimeInterval <= MIN_SECONDS_ACCESS_INTERVAL_FOR_ANONYMOUS;
  }
 else {
    LOGGER.debug(""String_Node_Str"");
    return accessTimeInterval <= MIN_SECONDS_ACCESS_INTERVAL_AUTHED;
  }
}",0.970318402590394
37190,"/** 
 * check if ip in white list.
 * @param ip ip.
 * @return true if in white list, false if not.
 */
private static boolean isInIpWhiteList(String ip){
  LOGGER.debug(""String_Node_Str"",IP_WHITE_LIST_FOR_ACCESS_INTERVAL);
  LOGGER.debug(""String_Node_Str"",ip);
  List<String> whiteList=IP_WHITE_LIST_FOR_ACCESS_INTERVAL;
  if (null != whiteList && whiteList.contains(ip)) {
    return true;
  }
  return false;
}","/** 
 * check if ip in white list.
 * @param ip ip.
 * @return true if in white list, false if not.
 */
private static boolean isInIpWhiteList(String ip){
  LOGGER.debug(""String_Node_Str"",IP_WHITE_LIST_FOR_ACCESS_INTERVAL);
  LOGGER.debug(""String_Node_Str"",ip);
  if (StringUtils.isBlank(ip)) {
    return false;
  }
  List<String> whiteList=IP_WHITE_LIST_FOR_ACCESS_INTERVAL;
  if (null != whiteList && whiteList.contains(ip)) {
    return true;
  }
  return false;
}",0.9375709421112371
37191,"/** 
 * test incrementConcurrentQCountAndCheckIfExceedMax.
 */
@Test public void testIncrementConcurrentQCountAndCheckIfExceedMax(){
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3);
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
  assertTrue(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  assertTrue(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax());
}","/** 
 * test incrementConcurrentQCountAndCheckIfExceedMax.
 */
@Test public void testIncrementConcurrentQCountAndCheckIfExceedMax(){
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3);
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
  assertTrue(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
  ConnectionControlService.decrementAndGetCurrentQueryCount(""String_Node_Str"");
  assertTrue(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
  ConnectionControlService.decrementAndGetCurrentQueryCount(""String_Node_Str"");
  ConnectionControlService.decrementAndGetCurrentQueryCount(""String_Node_Str"");
  assertFalse(ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax(""String_Node_Str""));
}",0.9255474452554744
37192,"/** 
 * Query template method. <pre> All sub classes should call this method for query. Note:queryParam.convertParam()  and queryParam.convertParam()  can throw any Exception, and these exceptions will handled  as HTTP 400 error. </pre>
 * @param queryParam queryParam.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") protected ResponseEntity queryTemplate(QueryParam queryParam){
  try {
    queryParam.fillParam();
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  QueryFilterResult preParamFilterResult=queryFilterManager.preParamValidate(queryParam,getQueryFilters());
  if (null != preParamFilterResult && preParamFilterResult.hasResult()) {
    return preParamFilterResult.getResult();
  }
  ValidationResult validateResult=validateParam(queryParam);
  if (validateResult.hasError()) {
    return handleError(validateResult);
  }
  QueryFilterResult postParamFilterResult=queryFilterManager.postParamValidate(queryParam,getQueryFilters());
  if (null != postParamFilterResult && postParamFilterResult.hasResult()) {
    return postParamFilterResult.getResult();
  }
  try {
    queryParam.convertParam();
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  ResponseEntity result=doQuery(queryParam);
  QueryFilterResult postQueryResult=queryFilterManager.postQuery(queryParam,result,getQueryFilters());
  if (null != postQueryResult && postQueryResult.hasResult()) {
    return postQueryResult.getResult();
  }
  return result;
}","/** 
 * Query template method. <pre> All sub classes should call this method for query. Note:queryParam.convertParam()  and queryParam.convertParam()  can throw any Exception, and these exceptions will handled  as HTTP 400 error. </pre>
 * @param queryParam queryParam.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") protected ResponseEntity queryTemplate(QueryParam queryParam){
  try {
    queryParam.fillParam();
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
    return RestResponseUtil.createResponse400();
  }
  QueryFilterResult preParamFilterResult=queryFilterManager.preParamValidate(queryParam,getQueryFilters());
  if (null != preParamFilterResult && preParamFilterResult.hasResult()) {
    return preParamFilterResult.getResult();
  }
  ValidationResult validateResult=validateParam(queryParam);
  if (validateResult.hasError()) {
    return handleError(validateResult);
  }
  QueryFilterResult postParamFilterResult=queryFilterManager.postParamValidate(queryParam,getQueryFilters());
  if (null != postParamFilterResult && postParamFilterResult.hasResult()) {
    return postParamFilterResult.getResult();
  }
  try {
    queryParam.convertParam();
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
    return RestResponseUtil.createResponse400();
  }
  ResponseEntity result=doQuery(queryParam);
  QueryFilterResult postQueryResult=queryFilterManager.postQuery(queryParam,result,getQueryFilters());
  if (null != postQueryResult && postQueryResult.hasResult()) {
    return postQueryResult.getResult();
  }
  return result;
}",0.9756254008980116
37193,"/** 
 * get query filters.
 * @return service filters.
 */
protected List<QueryFilter> getQueryFilters(){
  return new ArrayList<QueryFilter>();
}","/** 
 * get query filters.
 * @return service filters.
 */
protected List<QueryFilter> getQueryFilters(){
  LOGGER.warn(""String_Node_Str"");
  return new ArrayList<QueryFilter>();
}",0.8957055214723927
37194,"/** 
 * handle error in validation result. <pre> unrecognized error will be handled as HTTP 400 error. </pre>
 * @param result result.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") private ResponseEntity handleError(ValidationResult result){
  ValidationError error=result.getFirstError();
  if (null != error) {
    HttpValidationError httpError=(HttpValidationError)error;
    return RestResponseUtil.createCommonErrorResponse(httpError.getStatusCode());
  }
  return RestResponseUtil.createResponse400();
}","/** 
 * handle error in validation result. <pre> unrecognized error will be handled as HTTP 400 error. </pre>
 * @param result result.
 * @return ResponseEntity.
 */
@SuppressWarnings(""String_Node_Str"") private ResponseEntity handleError(ValidationResult result){
  ValidationError error=result.getFirstError();
  if (null != error) {
    HttpValidationError httpError=(HttpValidationError)error;
    return RestResponseUtil.createCommonErrorResponse(httpError.getStatusCode());
  }
  LOGGER.warn(""String_Node_Str"",result);
  return RestResponseUtil.createResponse400();
}",0.9628286491387126
37195,"/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @param forSearch is for search.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName,boolean forSearch){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (domainName.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (StringUtils.containsAny(domainName,DISALLOWED_DELIMITERS)) {
    return false;
  }
  if (!forSearch && !isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint)) {
    return isLdh(domainName);
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}","/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @param forSearch is for search.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName,boolean forSearch){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (domainName.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (StringUtils.containsAny(domainName,DISALLOWED_DELIMITERS)) {
    return false;
  }
  if (!forSearch && !isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (nonReservedAsciiDomain(domainName,punyDomainName,punyWithoutLastPoint,domainNameWithoutLastPoint,forSearch)) {
    return isLdh(domainName);
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}",0.8173108688470433
37196,"/** 
 * testUrlDecodeAndReplaceAsciiToLowercase.
 * @throws DecodeException 
 */
@Test public void testUrlDecodeAndReplaceAsciiToLowercase() throws DecodeException {
  assertEquals(""String_Node_Str"",DomainUtil.urlDecodeAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
}","/** 
 * testUrlDecodeAndReplaceAsciiToLowercase.
 * @throws DecodeException
 */
@Test public void testUrlDecodeAndReplaceAsciiToLowercase() throws DecodeException {
  assertEquals(""String_Node_Str"",DomainUtil.urlDecodeAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.replaceAsciiToLowercase(""String_Node_Str""));
}",0.999064546304958
37197,"/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",false));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",false));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}",0.9169048792508624
37198,"@Override protected void initValidators(){
  addValidator(DOMAIN_NAME_VALIDATOR);
}","@Override protected void initValidators(){
  addValidator(DOMAIN_NAME_ALABEL_VALIDATOR);
  addValidator(DOMAIN_NAME_VALIDATOR);
}",0.7830188679245284
37199,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}",0.9617575264442636
37200,"@Override public boolean supports(Class<?> clazz){
  Class superClazz=clazz.getSuperclass();
  return superClazz.equals(DomainSearchParam.class) || superClazz.equals(NameserverSearchParam.class) || superClazz.equals(EntitySearchParam.class);
}","@Override public boolean supports(Class<?> clazz){
  Class superClazz=clazz.getSuperclass();
  return superClazz.equals(DomainSearchParam.class) || superClazz.equals(NameserverSearchParam.class) || superClazz.equals(EntitySearchParam.class)|| clazz.equals(HelpQueryParam.class);
}",0.9292543021032504
37201,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=RequestUtil.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(new HelpQueryParam(""String_Node_Str""));
  if (null != result) {
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  return super.query(new HelpQueryParam(request));
}",0.7406876790830945
37202,"/** 
 * default constructor.
 * @param q query string.
 */
public HelpQueryParam(String q){
  super(q);
}","/** 
 * default constructor.
 * @param q query string.
 */
public HelpQueryParam(HttpServletRequest request){
  super(request);
}",0.8632478632478633
37203,"@Override protected void initValidators(){
}","@Override protected void initValidators(){
  super.addValidator(new SearchUriValidator());
}",0.6470588235294118
37204,"/** 
 * Before.
 * @throws Exception Exception.
 */
@Before public void before() throws Exception {
  resetDefaultMaxSizeSearch();
}","/** 
 * Before.
 * @throws Exception Exception.
 */
@Before public void before() throws Exception {
  resetDefaultMaxSizeSearch();
  rdapConformanceService.initRdapConformance();
}",0.8461538461538461
37205,"/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  mockMvc.perform(get(URI_DOMAIN_Q + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  mockMvc.perform(get(URI_DOMAIN_Q + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.9875518672199172
37206,"/** 
 * common query exist IP 200.
 * @param queryIP query ip address.
 * @param lang a string of language
 * @throws Exception Exception.
 */
private void commonQueryHelp() throws Exception {
  mockMvc.perform(get(urlPath).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * common query exist IP 200.
 * @param queryIP query ip address.
 * @param lang a string of language
 * @throws Exception Exception.
 */
private void commonQueryHelp() throws Exception {
  mockMvc.perform(get(urlPath).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.941747572815534
37207,"@Override public QueryFilterResult postQuery(QueryParam queryParam,ResponseEntity responseEntity){
  customColumnPolicyService.applyPolicy(responseEntity);
  return null;
}","@Override public QueryFilterResult postQuery(QueryParam queryParam,ResponseEntity responseEntity){
  Object responseBody=responseEntity.getBody();
  if (null == responseBody) {
    return null;
  }
  if (responseBody instanceof ErrorMessage) {
    return null;
  }
  customColumnPolicyService.applyPolicy(responseBody);
  return null;
}",0.65748031496063
37208,"/** 
 * add notices to model.
 * @param model model.
 */
public void addNotices(BaseModel model){
  if (null == model) {
    return;
  }
  List<Notice> notices=noticeService.getAllNotTruncatedNotice();
  addTruncatedNotice(model,notices);
  model.setNotices(notices);
}","/** 
 * add notices to model.
 * @param model model.
 */
public void addNotices(BaseModel model){
  if (null == model) {
    return;
  }
  List<Notice> notices=new ArrayList<Notice>();
  List<Notice> notTruncatedNotices=noticeService.getAllNotTruncatedNotice();
  if (null != notTruncatedNotices) {
    notices.addAll(notTruncatedNotices);
  }
  List<Notice> truncatedNotices=getTruncatedNotice(model);
  if (null != truncatedNotices) {
    notices.addAll(truncatedNotices);
  }
  model.setNotices(notices);
}",0.5681233933161953
37209,"/** 
 * check if str is valid search pattern. <pre> StringUtil.checkIsValidSearchPattern(null)      = false StringUtil.checkIsValidSearchPattern("""")        = false StringUtil.checkIsValidSearchPattern("" "")       = false StringUtil.checkIsValidSearchPattern(""*"")       = false StringUtil.checkIsValidSearchPattern(""*bob"")    = false StringUtil.checkIsValidSearchPattern(""*bob*"")   = false </pre>
 * @param str str.
 * @return true if valid,false if not.
 */
public static boolean checkIsValidSearchPattern(String str){
  if (StringUtils.isBlank(str)) {
    return false;
  }
  if (ASTERISK.equals(str) || str.startsWith(ASTERISK)) {
    return false;
  }
  return containsAtMostOnce(str,ASTERISK);
}","/** 
 * check if str is valid search pattern. <pre> StringUtil.checkIsValidSearchPattern(null)      = false StringUtil.checkIsValidSearchPattern("""")        = false StringUtil.checkIsValidSearchPattern("" "")       = false StringUtil.checkIsValidSearchPattern(""*"")       = false StringUtil.checkIsValidSearchPattern(""*bob"")    = true StringUtil.checkIsValidSearchPattern(""*bob*"")   = false </pre>
 * @param str str.
 * @return true if valid,false if not.
 */
public static boolean checkIsValidSearchPattern(String str){
  if (StringUtils.isBlank(str)) {
    return false;
  }
  if (ASTERISK.equals(str)) {
    return false;
  }
  return containsAtMostOnce(str,ASTERISK);
}",0.8895391367959035
37210,"/** 
 * test checkIsValidSearchPattern.
 */
@Test public void testCheckIsValidSearchPattern() throws UnsupportedEncodingException {
  assertTrue(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertTrue(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
}","/** 
 * test checkIsValidSearchPattern.
 */
@Test public void testCheckIsValidSearchPattern() throws UnsupportedEncodingException {
  assertTrue(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertTrue(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertTrue(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
  assertFalse(StringUtil.checkIsValidSearchPattern(""String_Node_Str""));
}",0.9224932249322492
37211,"/** 
 * test search 422 and 400.
 * @throws Exception
 */
@Test public void testSearchQStatus() throws Exception {
  RestResponseUtil.initErrorMessages();
  List<String> q422List=new ArrayList<String>();
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  List<String> q400List=new ArrayList<String>();
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  List<String> q200List=new ArrayList<String>();
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  for (  String q : q422List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isUnprocessableEntity()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(422));
  }
  for (  String q : q400List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400));
  }
  for (  String q : q200List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isNotFound()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(404));
  }
}","/** 
 * test search 422 and 400.
 * @throws Exception
 */
@Test public void testSearchQStatus() throws Exception {
  RestResponseUtil.initErrorMessages();
  List<String> q422List=new ArrayList<String>();
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  q422List.add(""String_Node_Str"");
  List<String> q404List=new ArrayList<String>();
  q404List.add(""String_Node_Str"");
  q404List.add(""String_Node_Str"");
  List<String> q400List=new ArrayList<String>();
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  q400List.add(""String_Node_Str"");
  List<String> q200List=new ArrayList<String>();
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  q200List.add(""String_Node_Str"");
  for (  String q : q422List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isUnprocessableEntity()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(422));
  }
  for (  String q : q404List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isNotFound()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(404));
  }
  for (  String q : q400List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isBadRequest()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(400));
  }
  for (  String q : q200List) {
    mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + encodeWithIso8859(q)).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isNotFound()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(404));
  }
}",0.8847695390781564
37212,"/** 
 * query redirect domain or nameserver.
 * @param queryParam queryParam.
 * @param paramName the string param.
 * @return ResponseEntity.
 */
protected ResponseEntity queryRedirectDomainOrNs(QueryParam queryParam,String paramName){
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryDomain(queryParam);
  String servicePartUri=QueryUri.DOMAIN.getName();
  if (queryParam instanceof NameserverQueryParam) {
    servicePartUri=QueryUri.NAMESERVER.getName();
  }
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(paramName,servicePartUri,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}","/** 
 * query redirect domain or nameserver.
 * @param queryParam queryParam.
 * @param paramName the string param.
 * @return ResponseEntity.
 */
protected ResponseEntity queryRedirectDomainOrNs(QueryParam queryParam,String paramName){
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryDomain(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(paramName,queryParam.getQueryUri().getName(),redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}",0.8716956802063185
37213,"@Override public boolean supports(Class<?> clazz){
  return clazz.equals(DomainQueryParam.class);
}","@Override public boolean supports(Class<?> clazz){
  return clazz.equals(DomainQueryParam.class) || clazz.equals(NameserverQueryParam.class);
}",0.8181818181818182
37214,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  QueryParam queryParam=new DomainQueryParam(request);
  return super.query(queryParam);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  QueryParam queryParam=new NameserverQueryParam(request);
  return super.query(queryParam);
}",0.991150442477876
37215,"@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  String punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  super.setQ(decodeDomain);
  setPunyName(punyDomainName);
}","@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCase(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  String punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  super.setQ(decodeDomain);
  setPunyName(punyDomainName);
}",0.9788359788359788
37216,"@Override public void fillParam() throws Exception {
  String domainName=getLastSplitInURI(getRequest());
  super.setOriginalQ(domainName);
  String decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  super.setQ(decodeDomain);
}","@Override public void fillParam() throws Exception {
  String domainName=getLastSplitInURI(getRequest());
  super.setOriginalQ(domainName);
  String decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  super.setQ(decodeDomain);
}",0.8785714285714286
37217,"@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}","@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCase(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}",0.9683794466403162
37218,"@Override public void fillParam() throws Exception {
  String domainName=getParameter(getRequest(),DomainSearchType.NAME.getName());
  String decodeDomain=domainName;
  decodeDomain=DomainUtil.iso8859Decode(domainName);
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}","@Override public void fillParam() throws Exception {
  String domainName=getParameter(getRequest(),DomainSearchType.NAME.getName());
  String decodeDomain=domainName;
  decodeDomain=DomainUtil.iso8859Decode(domainName);
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(decodeDomain);
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}",0.9232804232804231
37219,"@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}","@Override public void convertParam() throws Exception {
  String decodeDomain=getQ();
  decodeDomain=StringUtil.foldCase(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}",0.9683794466403162
37220,"@Override public void fillParam() throws Exception {
  String domainName=getParameter(getRequest(),DomainSearchType.NSLDHNAME.getName());
  String decodeDomain=domainName;
  decodeDomain=DomainUtil.iso8859Decode(domainName);
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}","@Override public void fillParam() throws Exception {
  String domainName=getParameter(getRequest(),DomainSearchType.NSLDHNAME.getName());
  String decodeDomain=domainName;
  decodeDomain=DomainUtil.iso8859Decode(domainName);
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(decodeDomain);
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  setQ(decodeDomain);
  setPunyName(decodeDomain);
}",0.9242819843342036
37221,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(QueryParamHelper.buildQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(new HelpQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.988056460369164
37222,"@Override public boolean supports(Class<?> clazz){
  return clazz.equals(DomainSearchByDomainNameParam.class) || clazz.equals(DomainSearchByNsNameParam.class) || clazz.equals(NameserverSearchByNameParam.class);
}","@Override public boolean supports(Class<?> clazz){
  return clazz.equals(DomainSearchByDomainNameParam.class) || clazz.equals(NameserverSearchByNameParam.class);
}",0.8693333333333333
37223,"@Override public boolean support(QueryParam queryParam){
  return queryParam instanceof DomainSearchByNsNameParam;
}","@Override public boolean support(QueryParam queryParam){
  return queryParam instanceof DomainSearchByNsLdhNameParam;
}",0.9872340425531916
37224,"/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    UriComponents uriComponents=UriComponentsBuilder.fromHttpUrl(str).build();
    return uriComponents.encode().toUriString();
  }
 catch (  Exception e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    UriComponents uriComponents=UriComponentsBuilder.fromUriString(str).build();
    return uriComponents.encode().toUriString();
  }
 catch (  Exception e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}",0.983640081799591
37225,"@Test public void test_encodedURL_with_space() throws UnsupportedEncodingException {
  String url=""String_Node_Str"";
  String param=""String_Node_Str"";
  String qEncode=URLEncoder.encode(param,""String_Node_Str"");
  String result=StringUtil.urlEncode(url + param);
  assertEquals(""String_Node_Str"",result);
}","@Test public void test_encodedURL_with_space() throws UnsupportedEncodingException {
  String url=""String_Node_Str"";
  String param=""String_Node_Str"";
  String result=StringUtil.urlEncode(url + param);
  assertEquals(""String_Node_Str"",result);
}",0.8892921960072595
37226,"/** 
 * test decoded URL.
 * @throws UnsupportedEncodingException
 */
@Test public void testDecodedURLForIDN() throws UnsupportedEncodingException {
  String decodedURL=""String_Node_Str"";
  String encodeURL=URLEncoder.encode(decodedURL,""String_Node_Str"");
  String expectURL=""String_Node_Str"";
  String result=StringUtil.urlEncode(decodedURL);
  assertEquals(expectURL,result);
}","/** 
 * test decoded URL.
 * @throws UnsupportedEncodingException
 */
@Test public void testDecodedURLForIDN() throws UnsupportedEncodingException {
  String decodedURL=""String_Node_Str"";
  String expectURL=""String_Node_Str"";
  String result=StringUtil.urlEncode(decodedURL);
  assertEquals(expectURL,result);
}",0.6869565217391305
37227,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(registryUrls);
  IpVersion ipVersion=IpUtil.getIpVersionOfNetwork(key);
  if (ipVersion.isNotValidIp()) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(key,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(registryUrls);
  IpVersion ipVersion=IpUtil.getIpVersionOfNetwork(key);
  if (ipVersion.isNotValidIp()) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  try {
    QueryParam queryParam=queryParser.parseIpQueryParam(key,ipVersion);
    networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
    redirects.add(networkRedirect);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",key,registryUrls);
  }
  return redirects;
}",0.9090909090909092
37228,"/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 < StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  return false;
}","/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 < StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName,true)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName,true)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName,true)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName,true)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName,true)) {
    return true;
  }
  return false;
}",0.9900596421471172
37229,"/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (domainName.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (StringUtils.containsAny(domainName,DISALLOWED_DELIMITERS)) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint)) {
    return isLdh(domainName);
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}","/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @param forSearch is for search.            
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName,boolean forSearch){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (domainName.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (StringUtils.containsAny(domainName,DISALLOWED_DELIMITERS)) {
    return false;
  }
  if (!forSearch && !isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint)) {
    return isLdh(domainName);
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}",0.9732837335136963
37230,"/** 
 * check if IPv4 is valid.
 * @param cidr IP.
 * @return true if valid, false if not.
 */
public static boolean isValidIpV4(String cidr){
  if (StringUtils.isBlank(cidr)) {
    return false;
  }
  cidr=addDefaultMaskIfNotExist(cidr);
  try {
    new SubnetUtils(cidr);
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}","/** 
 * check if IPv4 is valid.
 * @param cidr IP.
 * @return true if valid, false if not.
 */
public static boolean isValidIpV4(String cidr){
  if (StringUtils.isBlank(cidr)) {
    return false;
  }
  if (hasPrefixZero(cidr)) {
    return false;
  }
  cidr=addDefaultMaskIfNotExist(cidr);
  try {
    new SubnetUtils(cidr);
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}",0.9304229195088676
37231,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  LOGGER.debug(""String_Node_Str"",decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS,false)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  LOGGER.debug(""String_Node_Str"",decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}",0.9981684981684982
37232,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain,false)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9983982915109452
37233,"/** 
 * query inner objects of domain,and set them to domain object.
 * @param domains domain list.
 */
private void queryAndSetInnerObjectsWithoutNotice(List<Domain> domains){
  if (null == domains) {
    return;
  }
  for (  Domain domain : domains) {
    queryAndSetInnerObjects(domain);
    queryAndSetVariants(domain);
  }
}","/** 
 * query inner objects of domain,and set them to domain object.
 * @param domains domain list.
 */
private void queryAndSetInnerObjectsWithoutNotice(List<Domain> domains){
  if (null == domains) {
    return;
  }
  for (  Domain domain : domains) {
    queryAndSetInnerObjects(domain);
    queryAndSetVariants(domain);
    queryAndSetInnerNetwork(domain);
  }
}",0.9467625899280576
37234,"/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str"",false));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}",0.999404289118348
37235,"/** 
 * validate domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateDomainNameIsValidIdna(String domainName){
  String decodeDomain=domainName;
  try {
    decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  }
 catch (  DecodeException e) {
    e.printStackTrace();
  }
  return DomainUtil.validateDomainNameIsValidIdna(decodeDomain);
}","/** 
 * validate domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateDomainNameIsValidIdna(String domainName){
  String decodeDomain=domainName;
  try {
    decodeDomain=DomainUtil.urlDecodeAndReplaceAsciiToLowercase(domainName);
  }
 catch (  DecodeException e) {
    e.printStackTrace();
  }
  return DomainUtil.validateDomainNameIsValidIdna(decodeDomain,false);
}",0.9925187032418952
37236,"@Test public void test_parse_IPV4(){
  String ipPrefix=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ipPrefix);
  assertEquals(IpVersion.V4,ipVersion);
  byte[] bytes=IpUtil.ipToByteArray(ipPrefix,ipVersion);
  String ipString=IpUtil.toString(bytes,ipVersion);
  String hex1=DatatypeConverter.printHexBinary(bytes);
  System.err.println(""String_Node_Str"" + hex1);
}","@Test public void test_parse_IPV4(){
  String ipPrefix=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ipPrefix);
  assertEquals(IpVersion.V4,ipVersion);
  byte[] bytes=IpUtil.ipToByteArray(ipPrefix,ipVersion);
  String ipString=IpUtil.toString(bytes,ipVersion);
  String hex1=DatatypeConverter.printHexBinary(bytes);
}",0.9333333333333332
37237,"@Test public void test_generate_ARPA(){
  NetworkInBytes networkInBytes=IpUtil.parseArpa(""String_Node_Str"");
  String hex1=DatatypeConverter.printHexBinary(networkInBytes.getStartAddress());
  System.err.println(""String_Node_Str"" + hex1);
  String hex2=DatatypeConverter.printHexBinary(networkInBytes.getEndAddress());
  System.err.println(""String_Node_Str"" + hex2);
}","@Test public void test_generate_ARPA(){
  NetworkInBytes networkInBytes=IpUtil.parseArpa(""String_Node_Str"");
  String hex1=DatatypeConverter.printHexBinary(networkInBytes.getStartAddress());
  String hex2=DatatypeConverter.printHexBinary(networkInBytes.getEndAddress());
}",0.85
37238,"@Test public void test_parse_network_V4(){
  String network=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfNetwork(network);
  assertEquals(IpVersion.V4,ipVersion);
  NetworkInBytes networkInBytes=IpUtil.parseNetwork(network,ipVersion);
  String hex1=DatatypeConverter.printHexBinary(networkInBytes.getStartAddress());
  System.err.println(""String_Node_Str"" + hex1);
  String hex2=DatatypeConverter.printHexBinary(networkInBytes.getEndAddress());
  System.err.println(""String_Node_Str"" + hex2);
  assertEquals(IpVersion.V4,networkInBytes.getIpVersion());
}","@Test public void test_parse_network_V4(){
  String network=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfNetwork(network);
  assertEquals(IpVersion.V4,ipVersion);
  NetworkInBytes networkInBytes=IpUtil.parseNetwork(network,ipVersion);
  String hex1=DatatypeConverter.printHexBinary(networkInBytes.getStartAddress());
  String hex2=DatatypeConverter.printHexBinary(networkInBytes.getEndAddress());
  assertEquals(IpVersion.V4,networkInBytes.getIpVersion());
}",0.9082217973231358
37239,"@Test public void test_toByteArray_IPV4(){
  String ip=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ip);
  String hex=DatatypeConverter.printHexBinary(IpUtil.ipToByteArray(ip,ipVersion));
  System.err.println(""String_Node_Str"" + hex);
}","@Test public void test_toByteArray_IPV4(){
  String ip=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ip);
  String hex=DatatypeConverter.printHexBinary(IpUtil.ipToByteArray(ip,ipVersion));
}",0.8989247311827957
37240,"@Test public void test_toByteArray_IPV6(){
  String ip=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ip);
  String hex=DatatypeConverter.printHexBinary(IpUtil.ipToByteArray(ip,ipVersion));
  System.err.println(""String_Node_Str"" + hex);
}","@Test public void test_toByteArray_IPV6(){
  String ip=""String_Node_Str"";
  IpVersion ipVersion=IpUtil.getIpVersionOfIp(ip);
  String hex=DatatypeConverter.printHexBinary(IpUtil.ipToByteArray(ip,ipVersion));
}",0.8989247311827957
37241,"/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    String decodedURL=URLDecoder.decode(str,CHAR_SET_UTF8);
    decodedURL=decodedURL.replaceAll(""String_Node_Str"",URLEncoder.encode(""String_Node_Str"",CHAR_SET_UTF8));
    URI uri=new URI(decodedURL);
    result=uri.toASCIIString();
  }
 catch (  Exception e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    UriComponents uriComponents=UriComponentsBuilder.fromHttpUrl(str).build();
    return uriComponents.encode().toUriString();
  }
 catch (  Exception e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}",0.7012025901942646
37242,"/** 
 * test decoded URL.
 * @throws UnsupportedEncodingException
 */
@Test public void testDecodedURLForIDN() throws UnsupportedEncodingException {
  String decodedURL=""String_Node_Str"";
  String encodeURL=URLEncoder.encode(decodedURL,""String_Node_Str"");
  String expectURL=""String_Node_Str"";
  String result=StringUtil.urlEncode(decodedURL);
  assertEquals(expectURL,result);
  result=StringUtil.urlEncode(encodeURL);
  assertEquals(expectURL,result);
}","/** 
 * test decoded URL.
 * @throws UnsupportedEncodingException
 */
@Test public void testDecodedURLForIDN() throws UnsupportedEncodingException {
  String decodedURL=""String_Node_Str"";
  String encodeURL=URLEncoder.encode(decodedURL,""String_Node_Str"");
  String expectURL=""String_Node_Str"";
  String result=StringUtil.urlEncode(decodedURL);
  assertEquals(expectURL,result);
}",0.9088729016786572
37243,"/** 
 * test foldCase,get unicode from  http://www.unicode.org/Public/3.2-Update/CaseFolding-3.2.0.txt.
 */
@Test public void testFoldCase(){
  final String strTLD=""String_Node_Str"";
  char ch=0x00DF;
  String strNew=""String_Node_Str"" + strTLD;
  String strOrg=String.valueOf(ch);
  String strFold=StringUtil.foldCase(strOrg) + strTLD;
  assertEquals(strNew,strFold);
  strNew=""String_Node_Str"" + strTLD;
  strOrg=String.valueOf((char)0x0049) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  String strNew1=String.valueOf((char)0x0069);
  String strNew2=String.valueOf((char)0x0307);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0130) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x02BC);
  strNew2=String.valueOf((char)0x006E);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0149) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x006A);
  strNew2=String.valueOf((char)0x030C);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x01F0) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  int intFold=0x0390;
  strNew1=String.valueOf((char)0x03B9);
  strNew2=String.valueOf((char)0x0308);
  String strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)intFold) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0308);
  strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x03B0) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0565);
  strNew2=String.valueOf((char)0x0582);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0587) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  strNew1=String.valueOf((char)0x0068);
  strNew2=String.valueOf((char)0x0331);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E96) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0074);
  strNew2=String.valueOf((char)0x0308);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E97) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0077);
  strNew2=String.valueOf((char)0x030A);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E98) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0079);
  strNew2=String.valueOf((char)0x030A);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E99) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0061);
  strNew2=String.valueOf((char)0x02BE);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E9A) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1F50) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0300);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F52) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F54) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0342);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F56) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x1f00);
  strNew2=String.valueOf((char)0x03b9);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1F88) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
}","/** 
 * test foldCase,get unicode from http://www.unicode.org/Public/3.2-Update/CaseFolding-3.2.0.txt.
 */
@Test public void testFoldCase(){
  final String strTLD=""String_Node_Str"";
  char ch=0x00DF;
  String strNew=""String_Node_Str"" + strTLD;
  String strOrg=String.valueOf(ch);
  String strFold=StringUtil.foldCase(strOrg) + strTLD;
  assertEquals(strNew,strFold);
  strNew=""String_Node_Str"" + strTLD;
  strOrg=String.valueOf((char)0x0049) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  String strNew1=String.valueOf((char)0x0069);
  String strNew2=String.valueOf((char)0x0307);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0130) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x02BC);
  strNew2=String.valueOf((char)0x006E);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0149) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x006A);
  strNew2=String.valueOf((char)0x030C);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x01F0) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  int intFold=0x0390;
  strNew1=String.valueOf((char)0x03B9);
  strNew2=String.valueOf((char)0x0308);
  String strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)intFold) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0308);
  strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x03B0) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0565);
  strNew2=String.valueOf((char)0x0582);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x0587) + strTLD;
  strFold=StringUtil.foldCase(strOrg);
  assertEquals(strNew,strFold);
  strNew1=String.valueOf((char)0x0068);
  strNew2=String.valueOf((char)0x0331);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E96) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0074);
  strNew2=String.valueOf((char)0x0308);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E97) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0077);
  strNew2=String.valueOf((char)0x030A);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E98) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0079);
  strNew2=String.valueOf((char)0x030A);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E99) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x0061);
  strNew2=String.valueOf((char)0x02BE);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1E9A) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1F50) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0300);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F52) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0301);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F54) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x03C5);
  strNew2=String.valueOf((char)0x0313);
  strNew3=String.valueOf((char)0x0342);
  strNew=strNew1 + strNew2 + strNew3+ strTLD;
  strOrg=String.valueOf((char)0x1F56) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
  strNew1=String.valueOf((char)0x1f00);
  strNew2=String.valueOf((char)0x03b9);
  strNew=strNew1 + strNew2 + strTLD;
  strOrg=String.valueOf((char)0x1F88) + strTLD;
  assertEquals(strNew,StringUtil.foldCase(strOrg));
}",0.9998848589522163
37244,"/** 
 * get IpVersion by name.
 * @param name name.
 * @return IpVersion if name is valid, null if not
 */
public static IpVersion getIpVersion(String name){
  IpVersion[] ipVersions=IpVersion.values();
  for (  IpVersion ipVersion : ipVersions) {
    if (ipVersion.getName().equals(name)) {
      return ipVersion;
    }
  }
  return null;
}","/** 
 * get IpVersion by name.
 * @param name name.
 * @return IpVersion if name is valid, null if not
 */
public static IpVersion getIpVersion(String name){
  IpVersion[] ipVersions=IpVersion.values();
  for (  IpVersion ipVersion : ipVersions) {
    if (ipVersion.getName().equalsIgnoreCase(name)) {
      return ipVersion;
    }
  }
  return null;
}",0.9855907780979828
37245,"/** 
 * <pre> generate PreparedStatementCreator by executing sql. select network ip by high address and low address and match the  most accurate one. </pre>
 * @param queryParam queryParam of network.
 * @param ipTableName the database ip table name.
 * @return PreparedStatementCreator.
 */
public static PreparedStatementCreator generatePStatCreator(QueryParam queryParam,String ipTableName){
  NetworkQueryParam ipQueryParam=(NetworkQueryParam)queryParam;
  final NetworkInBytes network=ipQueryParam.getNetworkInBytes();
  final int hexCharSize=IpUtil.getHexCharSize(network.getIpVersion());
  String sql=""String_Node_Str"" + ipTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final String finalSql=sql;
  PreparedStatementCreator pstatCreator=new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=null;
      ps=connection.prepareStatement(finalSql);
      ps.setBytes(1,network.getStartAddress());
      ps.setBytes(2,network.getEndAddress());
      ps.setString(3,network.getIpVersion().getName());
      ps.setInt(4,hexCharSize);
      ps.setInt(5,hexCharSize);
      return ps;
    }
  }
;
  return pstatCreator;
}","/** 
 * <pre> generate PreparedStatementCreator by executing sql. select network ip by high address and low address and match the  most accurate one. </pre>
 * @param queryParam queryParam of network.
 * @param ipTableName the database ip table name.
 * @return PreparedStatementCreator.
 */
public static PreparedStatementCreator generatePStatCreator(QueryParam queryParam,String ipTableName){
  NetworkQueryParam ipQueryParam=(NetworkQueryParam)queryParam;
  final NetworkInBytes network=ipQueryParam.getNetworkInBytes();
  final int hexCharSize=IpUtil.getHexCharSize(network.getIpVersion());
  String sql=""String_Node_Str"" + ipTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateNetworkVersionSql(""String_Node_Str"")+ ""String_Node_Str"";
  final String finalSql=sql;
  PreparedStatementCreator pstatCreator=new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=null;
      ps=connection.prepareStatement(finalSql);
      ps.setBytes(1,network.getStartAddress());
      ps.setBytes(2,network.getEndAddress());
      ps.setString(3,network.getIpVersion().getName());
      ps.setInt(4,hexCharSize);
      ps.setInt(5,hexCharSize);
      return ps;
    }
  }
;
  return pstatCreator;
}",0.9746588693957114
37246,"/** 
 * query IPAddress from RDAP_NAMESERVER_IP for nameserver, without inner objects.
 * @param outerObjectId nameserver id which as the relation with nameserver.
 * @return IPAddress will be set to nameserver.
 */
private IPAddress queryWithoutInnerObjects(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"";
  IPAddress result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      return ps;
    }
  }
,new NetworkResultSetExtractor());
  return result;
}","/** 
 * query IPAddress from RDAP_NAMESERVER_IP for nameserver, without inner objects.
 * @param outerObjectId nameserver id which as the relation with nameserver.
 * @return IPAddress will be set to nameserver.
 */
private IPAddress queryWithoutInnerObjects(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ super.generateNetworkRangeSql(""String_Node_Str"",""String_Node_Str"");
  IPAddress result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      return ps;
    }
  }
,new NetworkResultSetExtractor());
  return result;
}",0.9402173913043478
37247,"/** 
 * query network from RDAP_IP, without inner objects.Only support ENTITY.
 * @param outerObjectId entity id.
 * @return network list
 */
private List<Network> queryWithoutInnerObjectsForEntity(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<Network> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      ps.setString(2,ModelType.IP.getName());
      return ps;
    }
  }
,new NetworkWithStatusResultSetExtractor());
  return result;
}","/** 
 * query network from RDAP_IP, without inner objects.Only support ENTITY.
 * @param outerObjectId entity id.
 * @return network list
 */
private List<Network> queryWithoutInnerObjectsForEntity(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + super.generateNetworkRangeSql(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ super.generateNetworkRangeSql(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  List<Network> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      ps.setString(2,ModelType.IP.getName());
      return ps;
    }
  }
,new NetworkWithStatusResultSetExtractor());
  return result;
}",0.9005649717514125
37248,"/** 
 * check if is ARPA domain.
 * @return true if is, false if not.
 */
public boolean isArpaDomain(){
  return DomainType.ARPA.equals(type);
}","/** 
 * check if is ARPA domain.
 * @return true if is, false if not.
 */
@JsonIgnore public boolean isArpaDomain(){
  return DomainType.ARPA.equals(type);
}",0.9602649006622516
37249,"/** 
 * check if is DNR domain.
 * @return true if is, false if not.
 */
public boolean isDnrDomain(){
  return DomainType.DNR.equals(type);
}","/** 
 * check if is DNR domain.
 * @return true if is, false if not.
 */
@JsonIgnore public boolean isDnrDomain(){
  return DomainType.DNR.equals(type);
}",0.9594594594594594
37250,"/** 
 * get IP version of CIDR str.
 * @param cidr ip str.
 * @return IP version.
 */
public static IpVersion getIpVersionOfNetwork(String cidr){
  if (IpV4.isValidIpV4(cidr)) {
    return IpVersion.V4;
  }
 else   if (IpV6.isValidIpV6(cidr)) {
    return IpVersion.V6;
  }
  return IpVersion.INVALID;
}","/** 
 * get IP version of CIDR str.
 * @param cidr ip str.
 * @return IP version.
 */
public static IpVersion getIpVersionOfNetwork(String cidr){
  if (StringUtils.contains(cidr,""String_Node_Str"")) {
    return IpVersion.INVALID;
  }
  if (IpV4.isValidIpV4(cidr)) {
    return IpVersion.V4;
  }
 else   if (IpV6.isValidIpV6(cidr)) {
    return IpVersion.V6;
  }
  return IpVersion.INVALID;
}",0.8731988472622478
37251,"/** 
 * get model type, value is simple name of class.
 * @return simple name of class
 */
public ModelType getObjectType(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * get model type, value is simple name of class.
 * @return simple name of class
 */
public ModelType getObjectType(){
  return ModelType.BASE;
}",0.8082595870206489
37252,"/** 
 * search domain using nsLdhName.
 * @param params query parameter include domain punyname.
 * @return domain list.
 */
private List<Domain> searchWithoutInnerObjectsByNsLdhName(final QueryParam params){
  DomainSearchParam domainQueryParam=(DomainSearchParam)params;
  final String nsName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String nsNameLikeClause=super.generateLikeClause(nsName);
  final String punyNameLikeClause=super.generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=params.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,nsNameLikeClause);
      ps.setString(3,punyNameLikeClause);
      ps.setString(4,nsNameLikeClause);
      ps.setLong(5,startRow);
      ps.setLong(6,page.getMaxRecords());
      return ps;
    }
  }
,new DomainResultSetExtractor());
  return result;
}","/** 
 * search domain using nsLdhName.
 * @param params query parameter include domain punyname.
 * @return domain list.
 */
private List<Domain> searchWithoutInnerObjectsByNsLdhName(final QueryParam params){
  DomainSearchParam domainQueryParam=(DomainSearchParam)params;
  final String nsName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String nsNameLikeClause=super.generateLikeClause(nsName);
  final String punyNameLikeClause=super.generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=params.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,punyNameLikeClause);
      ps.setLong(3,startRow);
      ps.setLong(4,page.getMaxRecords());
      return ps;
    }
  }
,new DomainResultSetExtractor());
  return result;
}",0.9469115191986645
37253,"/** 
 * search domain count by nsLdhName  <p> select the counter number of domain from database.
 * @param queryParam QueryParam.
 * @return domain count.
 */
private Long searchCountByNsLdhName(QueryParam queryParam){
  LOGGER.debug(""String_Node_Str"" + queryParam);
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  final String domainName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String domainNameLikeClause=super.generateLikeClause(domainName);
  final String punyNameLikeClause=super.generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Long domainCount=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,domainNameLikeClause);
      ps.setString(3,punyNameLikeClause);
      ps.setString(4,domainNameLikeClause);
      return ps;
    }
  }
,new CountResultSetExtractor());
  LOGGER.debug(""String_Node_Str"" + domainCount);
  return domainCount;
}","/** 
 * search domain count by nsLdhName  <p> select the counter number of domain from database.
 * @param queryParam QueryParam.
 * @return domain count.
 */
private Long searchCountByNsLdhName(QueryParam queryParam){
  LOGGER.debug(""String_Node_Str"" + queryParam);
  DomainSearchParam domainQueryParam=(DomainSearchParam)queryParam;
  final String domainName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String domainNameLikeClause=super.generateLikeClause(domainName);
  final String punyNameLikeClause=super.generateLikeClause(punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Long domainCount=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyNameLikeClause);
      ps.setString(2,punyNameLikeClause);
      return ps;
    }
  }
,new CountResultSetExtractor());
  LOGGER.debug(""String_Node_Str"" + domainCount);
  return domainCount;
}",0.9641255605381166
37254,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(value=""String_Node_Str"") public void testSearchTruncatedDomain() throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + ""String_Node_Str"").accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(true)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize(5))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(jsonPath(""String_Node_Str"").value(true)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize((int)5l))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
  ;
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(value=""String_Node_Str"") public void testSearchTruncatedDomain() throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"" + ""String_Node_Str"").accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(true)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize(5))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize(2))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
  ;
}",0.9601465872652314
37255,"/** 
 * search domain by nsIp 
 */
private void searchDomain(String strObject,String domainName) throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + strObject).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(domainName)))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(domainName)))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * search domain 
 */
private void searchDomain(String strObject,String domainName) throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + strObject).accept(MediaType.parseMediaType(rdapJson))).andExpect(status().isOk()).andExpect(content().contentType(rdapJson)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(domainName)))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(domainName)))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(rdapJson)).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.997995991983968
37256,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  if (null == argumentList || argumentList.isEmpty()) {
    throw new ServiceException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(argumentList.get(0))) {
    throw new ServiceException(""String_Node_Str"");
  }
  return ""String_Node_Str"" + urlEncode(argumentList.get(0));
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  if (null == argumentList || argumentList.isEmpty()) {
    throw new ServiceException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(argumentList.get(0))) {
    throw new ServiceException(""String_Node_Str"");
  }
  return ""String_Node_Str"" + argumentList.get(0);
}",0.9860583016476552
37257,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  if (!validateAsNumber(startAsNumber,endAsNumber)) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}",0.9453061224489796
37258,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",ipMask,e);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",ipMask,e);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  if (!validateMask(ipMaskLongVal)) {
    logger.error(""String_Node_Str"",ipMask);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}",0.9293193717277488
37259,"/** 
 * set ObjectClassNameEnum.
 * @param objectClassNameEnum objectClassName for set.
 */
public void setObjectClassName(ObjectClassNameEnum objectClassName){
  this.objectClassName=objectClassName;
}","/** 
 * set ObjectClassNameEnum.
 * @param objectClassName objectClassName for set.
 */
public void setObjectClassName(ObjectClassNameEnum objectClassName){
  this.objectClassName=objectClassName;
}",0.99
37260,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.9712793733681462
37261,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity ResponseEntity.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.951219512195122
37262,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9898477157360406
37263,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9932885906040269
37264,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9755826859045506
37265,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}",0.9861373660995588
37266,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9823151125401928
37267,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9864615384615384
37268,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9879253567508232
37269,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request) throws DecodeException {
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 * @throws DecodeException DecodeException.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request) throws DecodeException {
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9897911832946636
37270,"/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request) throws DecodeException {
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}","/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 * @throws DecodeException DecodeException.
 */
public String getLastSplitInURI(HttpServletRequest request) throws DecodeException {
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}",0.9574468085106383
37271,"/** 
 * delete old redirects. <p> NOTICE not to delete another IP type rows which just inserted. </p>
 * @param maxOldId maxOldId.
 * @param bootstraps
 */
private void deleteOld(Long maxOldId,List<Redirect> bootstraps){
  if (null == maxOldId) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (null == bootstraps || bootstraps.size() == 0) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  NetworkRedirect redirect=(NetworkRedirect)bootstraps.get(0);
  IpVersion ipVersion=redirect.getNetworkQueryParam().getQueryIpVersion();
  jdbcTemplate.update(DELETE_SMALLER_THAN_ID,maxOldId,ipVersion.getName());
}","/** 
 * delete old redirects. <p> NOTICE not to delete another IP type rows which just inserted. </p>
 * @param maxOldId maxOldId.
 * @param bootstraps bootstraps.
 */
private void deleteOld(Long maxOldId,List<Redirect> bootstraps){
  if (null == maxOldId) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  if (null == bootstraps || bootstraps.size() == 0) {
    LOGGER.info(""String_Node_Str"");
    return;
  }
  NetworkRedirect redirect=(NetworkRedirect)bootstraps.get(0);
  IpVersion ipVersion=redirect.getNetworkQueryParam().getQueryIpVersion();
  jdbcTemplate.update(DELETE_SMALLER_THAN_ID,maxOldId,ipVersion.getName());
}",0.9904153354632588
37272,"/** 
 * constructor with cause.
 */
public DecodeException(Throwable cause){
  super(cause);
}","/** 
 * constructor with cause.
 * @param cause cause.
 */
public DecodeException(Throwable cause){
  super(cause);
}",0.8909952606635071
37273,"/** 
 * constructor.
 */
public AutnumRedirect(Long startAutnum,Long endAutnum,List<String> urls){
  super();
  this.startAutnum=startAutnum;
  this.endAutnum=endAutnum;
  super.urls=urls;
}","/** 
 * constructor.
 * @param startAutnum startAutnum.
 * @param endAutnum endAutnum.
 * @param urls urls.
 */
public AutnumRedirect(Long startAutnum,Long endAutnum,List<String> urls){
  super();
  this.startAutnum=startAutnum;
  this.endAutnum=endAutnum;
  super.urls=urls;
}",0.8137044967880086
37274,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    LOGGER.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    LOGGER.error(""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    LOGGER.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}",0.7609841827768014
37275,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    LOGGER.error(""String_Node_Str"");
    LOGGER.error(""String_Node_Str"",key);
    LOGGER.error(""String_Node_Str"",registryUrls);
    return redirects;
  }
  redirects.add(new DomainRedirect(key,registryUrls));
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"");
    logger.error(""String_Node_Str"",key);
    logger.error(""String_Node_Str"",registryUrls);
    return redirects;
  }
  redirects.add(new DomainRedirect(key,registryUrls));
  return redirects;
}",0.6901098901098901
37276,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",ipMask,e);
    LOGGER.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",ipMask,e);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}",0.9887323943661972
37277,"/** 
 * save redirect from bootstrap.
 * @param bootstrapRegistries bootstrapRegistries.
 */
public void handle(){
  BootstrapRegistries bootstrapRegistries=dataProvider.getDataFromRegistry(getRegistryRelativateUrl());
  if (null == bootstrapRegistries) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  List<Redirect> redirects=generateRedirectsFromBootstraps(bootstrapRegistries);
  LOGGER.debug(""String_Node_Str"",redirects);
  saveRedirects(redirects);
}","/** 
 * save redirect from bootstrap.
 */
public void handle(){
  BootstrapRegistries bootstrapRegistries=dataProvider.getDataFromRegistry(getRegistryRelativateUrl());
  if (null == bootstrapRegistries) {
    logger.error(""String_Node_Str"");
    return;
  }
  List<Redirect> redirects=generateRedirectsFromBootstraps(bootstrapRegistries);
  logger.debug(""String_Node_Str"",redirects);
  saveRedirects(redirects);
}",0.9144811858608894
37278,"/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new DecodeException(""String_Node_Str"",e);
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 * @throws DecodeException DecodeException.
 */
public static String urlDecode(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new DecodeException(""String_Node_Str"",e);
  }
  return result;
}",0.960144927536232
37279,"/** 
 * validate domain length, length is without last dot.
 * @param domainWithoutLastDot domain without last dot.
 * @return true if valid,false if not.
 */
private static boolean validateDomainLength(String domainWithoutLastDot){
  if (StringUtils.isBlank(domainWithoutLastDot)) {
    return false;
  }
  if (domainWithoutLastDot.length() < MIN_DOMAIN_LENGTH_WITHOUT_LAST_DOT || domainWithoutLastDot.length() > MAX_DOMAIN_LENGTH_WITHOUT_LAST_DOT) {
    return false;
  }
  return true;
}","/** 
 * validate domain length, length is without last dot.
 * @param domainWithoutLastDot domain without last dot.
 * @return true if valid,false if not.
 */
private static boolean validateDomainLength(String domainWithoutLastDot){
  if (StringUtils.isBlank(domainWithoutLastDot)) {
    return false;
  }
  int domainLength=domainWithoutLastDot.length();
  if (domainLength < MIN_DOMAIN_LENGTH_WITHOUT_LAST_DOT) {
    return false;
  }
  if (domainLength > MAX_DOMAIN_LENGTH_WITHOUT_LAST_DOT) {
    return false;
  }
  return true;
}",0.888671875
37280,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (StringUtils.isBlank(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  key=StringUtils.trim(key);
  key=StringUtils.removeStart(key,""String_Node_Str"");
  key=StringUtils.removeEnd(key,""String_Node_Str"");
  String[] splits=StringUtils.split(key,AS_START_END_SEPARATOR);
  if (splits.length != 2) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(splits));
    return redirects;
  }
  Long startAsNumber=0L;
  Long endAsNumber=0L;
  try {
    startAsNumber=Long.parseLong(StringUtils.trim(splits[0]));
    endAsNumber=Long.parseLong(StringUtils.trim(splits[1]));
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",new Object[]{splits[0],splits[1],e});
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  if (!validateAsNumber(startAsNumber,endAsNumber)) {
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  AutnumRedirect autnumRedirect=new AutnumRedirect(startAsNumber,endAsNumber,registryUrls);
  redirects.add(autnumRedirect);
  return redirects;
}",0.9453061224489796
37281,"@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",ipMask,e);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}","@Override List<Redirect> generateRedirects(String key,List<String> registryUrls){
  List<Redirect> redirects=new ArrayList<Redirect>();
  if (!validateKey(key) || !removeEmptyUrlsAndValidate(registryUrls)) {
    return redirects;
  }
  key=StringUtils.lowerCase(key);
  String[] splits=StringUtils.split(key,CIDR_SEPARATOR);
  if (splits.length != 2) {
    return redirects;
  }
  String ipPrefix=splits[0];
  String ipMask=splits[1];
  long ipMaskLongVal=0;
  try {
    ipMaskLongVal=Long.parseLong(ipMask);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",ipMask,e);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  if (!validateMask(ipMaskLongVal)) {
    logger.error(""String_Node_Str"",ipMask);
    logger.error(""String_Node_Str"",key,registryUrls);
    return redirects;
  }
  NetworkRedirect networkRedirect=new NetworkRedirect(ipPrefix,ipMask,registryUrls);
  IpVersion ipVersion=parseIpVersion(ipPrefix);
  if (null == ipVersion) {
    return redirects;
  }
  QueryParam queryParam=queryParser.parseIpQueryParam(ipPrefix,ipMaskLongVal,ipVersion);
  networkRedirect.setNetworkQueryParam((NetworkQueryParam)queryParam);
  redirects.add(networkRedirect);
  return redirects;
}",0.9293193717277488
37282,"@Override public void messageReceived(ChannelHandlerContext ctx,String request){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  String remoteAddr=socketAddress.getAddress().getHostAddress();
  LOGGER.info(""String_Node_Str"",remoteAddr);
  String response=StringUtils.EMPTY;
  if (ConnectionControlService.exceedRateLimit(remoteAddr)) {
    LOGGER.debug(""String_Node_Str"");
    response=get429Response();
    writeResponseAndcloseConnection(ctx,response);
    return;
  }
  if (request.isEmpty()) {
    response=""String_Node_Str"";
  }
 else {
    ProxyService proxyService=ProxyService.getInstance();
    try {
      response=proxyService.execute(request);
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",e);
      response=""String_Node_Str"";
    }
  }
  writeResponseAndcloseConnection(ctx,response);
}","@Override public void messageReceived(ChannelHandlerContext ctx,String request){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  String remoteAddr=socketAddress.getAddress().getHostAddress();
  LOGGER.info(""String_Node_Str"",remoteAddr);
  String response=StringUtils.EMPTY;
  if (ConnectionControlService.exceedRateLimit(remoteAddr)) {
    LOGGER.debug(""String_Node_Str"");
    response=get429Response();
    writeResponseAndcloseConnection(ctx,response);
    return;
  }
  if (request.isEmpty()) {
    response=""String_Node_Str"";
  }
 else {
    ProxyService proxyService=ProxyService.getInstance();
    try {
      response=proxyService.execute(request);
    }
 catch (    ServiceException e) {
      response=e.getMessage();
    }
catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",e);
      response=""String_Node_Str"";
    }
  }
  writeResponseAndcloseConnection(ctx,response);
}",0.9609810479375696
37283,"/** 
 * main service method.This will parse command, construct URI and request RDAP server for JSON response, and then convert JSON result to text format.
 * @param commandStr commandStr.
 * @return query result.
 * @throws ServiceException ServiceException.
 */
public String execute(String commandStr) throws Exception {
  LOGGER.info(""String_Node_Str"",commandStr);
  String requestURI=StringUtils.EMPTY;
  try {
    Command command=CommandParser.parse(commandStr);
    requestURI=generateRequestURI(command);
    if (StringUtils.isBlank(requestURI)) {
      LOGGER.error(""String_Node_Str"");
      throw new ServiceException(""String_Node_Str"" + commandStr);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.error(""String_Node_Str"");
    requestURI=generateRequestURIForError();
  }
  RestResponse restResponse=RestClient.getInstance().execute(requestURI);
  Map jsonMap=JsonUtil.deserializateJsonToMap(restResponse);
  String result=ResponseFormater.format(jsonMap);
  return result;
}","/** 
 * main service method.This will parse command, construct URI and request RDAP server for JSON response, and then convert JSON result to text format.
 * @param commandStr commandStr.
 * @return query result.
 * @throws ServiceException ServiceException.
 */
public String execute(String commandStr) throws Exception {
  LOGGER.info(""String_Node_Str"",commandStr);
  String requestURI=StringUtils.EMPTY;
  try {
    Command command=CommandParser.parse(commandStr);
    requestURI=generateRequestURI(command);
    if (StringUtils.isBlank(requestURI)) {
      LOGGER.error(""String_Node_Str"");
      throw new ServiceException(""String_Node_Str"" + commandStr);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.error(""String_Node_Str"");
    requestURI=generateRequestURIForError();
  }
  RestResponse restResponse=RestClient.getInstance().execute(requestURI);
  if (null == restResponse || StringUtils.isBlank(restResponse.getBody())) {
    LOGGER.error(""String_Node_Str"");
    throw new ServiceException(""String_Node_Str"" + commandStr);
  }
  Map jsonMap=JsonUtil.deserializateJsonToMap(restResponse);
  String result=ResponseFormater.format(jsonMap);
  return result;
}",0.9183123877917416
37284,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_FN=CommandOption.ENTITY_SEARCH_FN.getOption();
  String OPTION_HANDLE=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_FN)) {
    uri=uri + OPTION_FN + ""String_Node_Str""+ removePrefix(argumentList.get(0),OPTION_FN);
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_HANDLE)) {
    uri=uri + OPTION_HANDLE + ""String_Node_Str""+ removePrefix(argumentList.get(0),OPTION_HANDLE);
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_FN=CommandOption.ENTITY_SEARCH_FN.getOption();
  String OPTION_HANDLE=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_FN + PARAM_SEPARATOR)) {
    uri=uri + OPTION_FN + PARAM_SEPARATOR+ removePrefix(argumentList.get(0),OPTION_FN);
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_HANDLE + PARAM_SEPARATOR)) {
    uri=uri + OPTION_HANDLE + PARAM_SEPARATOR+ removePrefix(argumentList.get(0),OPTION_HANDLE);
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}",0.9338624338624338
37285,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_IP=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String OPTION_NAME=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_IP)) {
    uri=uri + OPTION_IP + ""String_Node_Str""+ removePrefix(argumentList.get(0),OPTION_IP);
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + OPTION_NAME + ""String_Node_Str""+ argumntList.get(0);
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_IP=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String OPTION_NAME=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_IP + PARAM_SEPARATOR)) {
    uri=uri + OPTION_IP + ""String_Node_Str""+ removePrefix(argumentList.get(0),OPTION_IP);
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + OPTION_NAME + ""String_Node_Str""+ argumntList.get(0);
  }
  return uri;
}",0.9873417721518988
37286,"/** 
 * get prefixed agrument.
 * @param prefixedArgument prefixedArgument.
 * @param prefix prefix.
 * @return value.
 */
protected String removePrefix(String prefixedArgument,String prefix){
  if (StringUtils.isBlank(prefixedArgument)) {
    return StringUtils.EMPTY;
  }
  return StringUtils.removeStart(prefixedArgument,prefix + ""String_Node_Str"");
}","/** 
 * get prefixed agrument.
 * @param prefixedArgument prefixedArgument.
 * @param prefix prefix.
 * @return value.
 */
protected String removePrefix(String prefixedArgument,String prefix){
  if (StringUtils.isBlank(prefixedArgument)) {
    return StringUtils.EMPTY;
  }
  return StringUtils.removeStart(prefixedArgument,prefix + PARAM_SEPARATOR);
}",0.9575070821529744
37287,"/** 
 * call this method to start timer.
 */
public static void schedule(){
  timer.schedule(new TimerTask(){
    @Override public void run(){
      ConnectionControlService.clearIpMap();
    }
  }
,TIMER_DELAY,INTERVAL);
}","/** 
 * call this method to start TIMER.
 */
public static void schedule(){
  TIMER.schedule(new TimerTask(){
    @Override public void run(){
      ConnectionControlService.clearIpMap();
    }
  }
,TIMER_DELAY,INTERVAL);
}",0.9551569506726456
37288,"/** 
 * stop timer.
 */
public static void stop(){
  timer.cancel();
  timer.purge();
}","/** 
 * stop TIMER.
 */
public static void stop(){
  TIMER.cancel();
  TIMER.purge();
}",0.8275862068965517
37289,"public void setCommandType(CommandOption commandType){
  this.commandType=commandType;
}","/** 
 * set commandType.
 * @param commandType commandType.
 */
public void setCommandType(CommandOption commandType){
  this.commandType=commandType;
}",0.7333333333333333
37290,"public Map<String,String> getAllOptionsMap(){
  return allOptionsMap;
}","/** 
 * get allOptionsMap.
 * @return allOptionsMap.
 */
public Map<String,String> getAllOptionsMap(){
  return allOptionsMap;
}",0.7135678391959799
37291,"public void setArgumentList(List<String> argumentList){
  this.argumentList=argumentList;
}","/** 
 * set argumentList.
 * @param argumentList argumentList.
 */
public void setArgumentList(List<String> argumentList){
  this.argumentList=argumentList;
}",0.7309236947791165
37292,"public void setAllOptionsMap(Map<String,String> allOptionsMap){
  this.allOptionsMap=allOptionsMap;
}","/** 
 * set allOptionsMap.
 * @param allOptionsMap allOptionsMap.
 */
public void setAllOptionsMap(Map<String,String> allOptionsMap){
  this.allOptionsMap=allOptionsMap;
}",0.7426470588235294
37293,"public List<String> getArgumentList(){
  return argumentList;
}","/** 
 * get argumentList.
 * @return argumentList.
 */
public List<String> getArgumentList(){
  return argumentList;
}",0.6961325966850829
37294,"/** 
 * get prefixed agrument.
 * @param prefixedArgument prefixedArgument.
 * @param prefix prefix.
 * @return value.
 */
protected String removePrefix(String prefixedArgument,String prefix){
  if (StringUtils.isBlank(prefixedArgument)) {
    return StringUtils.EMPTY;
  }
  return StringUtils.removeStart(prefixedArgument,prefix + PARAM_SEPARATOR);
}","/** 
 * get prefixed argument.
 * @param prefixedArgument prefixedArgument.
 * @param prefix prefix.
 * @return value.
 */
protected String removePrefix(String prefixedArgument,String prefix){
  if (StringUtils.isBlank(prefixedArgument)) {
    return StringUtils.EMPTY;
  }
  return StringUtils.removeStart(prefixedArgument,prefix + PARAM_SEPARATOR);
}",0.9943181818181818
37295,"public static Integer getServicePort(){
  return servicePort;
}","/** 
 * get servicePort.
 * @return servicePort.
 */
public static Integer getServicePort(){
  return servicePort;
}",0.7039106145251397
37296,"public static void setResponseFormater(String responseFormater){
  LOGGER.info(""String_Node_Str"",responseFormater);
  RdapProperties.responseFormater=responseFormater;
}","/** 
 * set responseFormater.
 * @param responseFormater responseFormater.
 */
public static void setResponseFormater(String responseFormater){
  LOGGER.info(""String_Node_Str"",responseFormater);
  RdapProperties.responseFormater=responseFormater;
}",0.8105515587529976
37297,"public static Integer getManagePort(){
  return managePort;
}","/** 
 * set servicePort.
 * @return servicePort.
 */
public static Integer getManagePort(){
  return managePort;
}",0.6971428571428572
37298,"public static void setManagePort(Integer managePort){
  LOGGER.info(""String_Node_Str"",managePort);
  RdapProperties.managePort=managePort;
}","/** 
 * get managePort.
 * @param managePort managePort.
 */
public static void setManagePort(Integer managePort){
  LOGGER.info(""String_Node_Str"",managePort);
  RdapProperties.managePort=managePort;
}",0.8211143695014663
37299,"public static void setMinSecondsAccessInterval(Long minSecondsAccessInterval){
  LOGGER.info(""String_Node_Str"",minSecondsAccessInterval);
  RdapProperties.minSecondsAccessInterval=minSecondsAccessInterval;
}","/** 
 * set minSecondsAccessInterval.
 * @param minSecondsAccessInterval .
 */
public static void setMinSecondsAccessInterval(Long minSecondsAccessInterval){
  LOGGER.info(""String_Node_Str"",minSecondsAccessInterval);
  RdapProperties.minSecondsAccessInterval=minSecondsAccessInterval;
}",0.8397565922920892
37300,"public static String getRdapServerBaseUrl(){
  return rdapServerBaseUrl;
}","/** 
 * get rdapServerBaseUrl.
 * @return rdapServerBaseUrl.
 */
public static String getRdapServerBaseUrl(){
  return rdapServerBaseUrl;
}",0.6948356807511737
37301,"public static void setRdapServerBaseUrl(String rdapServerBaseUrl){
  LOGGER.info(""String_Node_Str"",rdapServerBaseUrl);
  RdapProperties.rdapServerBaseUrl=rdapServerBaseUrl;
}","/** 
 * set rdapServerBaseUrl.
 * @param rdapServerBaseUrl rdapServerBaseUrl.
 */
public static void setRdapServerBaseUrl(String rdapServerBaseUrl){
  LOGGER.info(""String_Node_Str"",rdapServerBaseUrl);
  RdapProperties.rdapServerBaseUrl=rdapServerBaseUrl;
}",0.8093023255813954
37302,"public static String getResponseFormater(){
  return responseFormater;
}","/** 
 * get responseFormater.
 * @return responseFormater.
 */
public static String getResponseFormater(){
  return responseFormater;
}",0.6956521739130435
37303,"public static void setServicePort(Integer servicePort){
  LOGGER.info(""String_Node_Str"",servicePort);
  RdapProperties.servicePort=servicePort;
}","/** 
 * set managePort.
 * @param servicePort managePort.
 */
public static void setServicePort(Integer servicePort){
  LOGGER.info(""String_Node_Str"",servicePort);
  RdapProperties.servicePort=servicePort;
}",0.8238636363636364
37304,"public static Long getMinSecondsAccessInterval(){
  return minSecondsAccessInterval;
}","/** 
 * get minSecondsAccessInterval.
 * @return minSecondsAccessInterval.
 */
public static Long getMinSecondsAccessInterval(){
  return minSecondsAccessInterval;
}",0.6852589641434262
37305,"/** 
 * get singleton instance.
 * @return
 */
public static RestClient getInstance(){
  return restClient;
}","/** 
 * get singleton instance.
 * @return instance.
 */
public static RestClient getInstance(){
  return restClient;
}",0.956140350877193
37306,"/** 
 * @param url
 * @return
 */
public RestResponse execute(String url) throws ServiceException {
  CloseableHttpClient client=HttpClients.createDefault();
  RequestConfig requestConfig=RequestConfig.custom().setRedirectsEnabled(false).build();
  HttpGet request=new HttpGet(url);
  request.setConfig(requestConfig);
  request.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpResponse response=null;
  String responseBody=StringUtils.EMPTY;
  int statusCode=HttpStatus.SC_OK;
  String locationHeader=StringUtils.EMPTY;
  try {
    response=client.execute(request);
    HttpEntity entity=response.getEntity();
    statusCode=response.getStatusLine().getStatusCode();
    Header[] headers=response.getHeaders(""String_Node_Str"");
    if (null != headers && headers.length > 0) {
      locationHeader=headers[0].getValue();
    }
    if (entity != null) {
      InputStream inStream=entity.getContent();
      responseBody=convertStreamToString(inStream);
      inStream.close();
    }
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    throw new ServiceException(""String_Node_Str"");
  }
  RestResponse result=new RestResponse();
  result.setBody(responseBody);
  result.setStatusCode(statusCode);
  result.setLocationHeader(locationHeader);
  return result;
}","/** 
 * call rest service.
 * @param url url.
 * @return rest response.
 */
public RestResponse execute(String url) throws ServiceException {
  CloseableHttpClient client=HttpClients.createDefault();
  RequestConfig requestConfig=RequestConfig.custom().setRedirectsEnabled(false).build();
  HttpGet request=new HttpGet(url);
  request.setConfig(requestConfig);
  request.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpResponse response=null;
  String responseBody=StringUtils.EMPTY;
  int statusCode=HttpStatus.SC_OK;
  String locationHeader=StringUtils.EMPTY;
  try {
    response=client.execute(request);
    HttpEntity entity=response.getEntity();
    statusCode=response.getStatusLine().getStatusCode();
    Header[] headers=response.getHeaders(""String_Node_Str"");
    if (null != headers && headers.length > 0) {
      locationHeader=headers[0].getValue();
    }
    if (entity != null) {
      InputStream inStream=entity.getContent();
      responseBody=convertStreamToString(inStream);
      inStream.close();
    }
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    throw new ServiceException(""String_Node_Str"");
  }
  RestResponse result=new RestResponse();
  result.setBody(responseBody);
  result.setStatusCode(statusCode);
  result.setLocationHeader(locationHeader);
  return result;
}",0.9839326702371844
37307,"/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new DecodeException(""String_Node_Str"",e);
  }
  return result;
}",0.8092105263157895
37308,"/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
@Deprecated public static String decodeAndReplaceAsciiToLowercase(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  LOGGER.debug(""String_Node_Str"",str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}","/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
@Deprecated public static String decodeAndReplaceAsciiToLowercase(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  LOGGER.debug(""String_Node_Str"",str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}",0.9824561403508772
37309,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.9836065573770492
37310,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9790575916230366
37311,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9943741209563994
37312,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.996300863131936
37313,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.986159169550173
37314,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request){
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}",0.9922730199613652
37315,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9900826446280993
37316,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9924575738529228
37317,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9932885906040269
37318,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request) throws DecodeException {
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9943422913719944
37319,"@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException || ex instanceof HttpMediaTypeNotAcceptableException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof DecodeException) {
    responseEntity=RestResponseUtil.createResponse400();
  }
 else   if (ex instanceof InvalidMediaTypeException || ex instanceof HttpMediaTypeNotAcceptableException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.9217134416543574
37320,"/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}","/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request) throws DecodeException {
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}",0.9751552795031057
37321,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + argument;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + urlEncode(argument);
}",0.9473684210526316
37322,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  String uri=""String_Node_Str"" + argument;
  LOGGER.info(""String_Node_Str"",uri);
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  String uri=""String_Node_Str"" + urlEncode(argument);
  LOGGER.info(""String_Node_Str"",uri);
  return uri;
}",0.9568
37323,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumntList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumntList);
  String argument=argumntList.get(0);
  return ""String_Node_Str"" + argument;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumntList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumntList);
  String argument=argumntList.get(0);
  return ""String_Node_Str"" + urlEncode(argument);
}",0.9467455621301776
37324,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + argument;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + urlEncode(argument);
}",0.9473684210526316
37325,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_FN=CommandOption.ENTITY_SEARCH_FN.getOption();
  String OPTION_HANDLE=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_FN + PARAM_SEPARATOR)) {
    uri=uri + OPTION_FN + PARAM_SEPARATOR+ removePrefix(argumentList.get(0),OPTION_FN);
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_HANDLE + PARAM_SEPARATOR)) {
    uri=uri + OPTION_HANDLE + PARAM_SEPARATOR+ removePrefix(argumentList.get(0),OPTION_HANDLE);
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_FN=CommandOption.ENTITY_SEARCH_FN.getOption();
  String OPTION_HANDLE=CommandOption.ENTITY_SEARCH_HANDLE.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_FN + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_FN);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_FN + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else   if (isPrefixedArgument(argumentList.get(0),OPTION_HANDLE + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_HANDLE);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_HANDLE + PARAM_SEPARATOR+ argumentWithoutPrefix;
  }
 else {
    throw new ServiceException(""String_Node_Str"");
  }
  return uri;
}",0.588963963963964
37326,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  if (null == argumentList || argumentList.isEmpty()) {
    throw new ServiceException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(argumentList.get(0))) {
    throw new ServiceException(""String_Node_Str"");
  }
  return ""String_Node_Str"" + argumentList.get(0);
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  if (null == argumentList || argumentList.isEmpty()) {
    throw new ServiceException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(argumentList.get(0))) {
    throw new ServiceException(""String_Node_Str"");
  }
  return ""String_Node_Str"" + urlEncode(argumentList.get(0));
}",0.9860583016476552
37327,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + argument;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String argument=argumentList.get(0);
  return ""String_Node_Str"" + urlEncode(argument);
}",0.9473684210526316
37328,"@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_IP=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String OPTION_NAME=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_IP + PARAM_SEPARATOR)) {
    uri=uri + OPTION_IP + ""String_Node_Str""+ removePrefix(argumentList.get(0),OPTION_IP);
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + OPTION_NAME + ""String_Node_Str""+ argumntList.get(0);
  }
  return uri;
}","@Override protected String getRelativeRequestURI(Command command){
  List<String> argumentList=command.getArgumentList();
  throwExceptionIfArguementIsEmpty(argumentList);
  String uri=""String_Node_Str"";
  String OPTION_IP=CommandOption.NAMESERVER_SEARCH_BY_IP.getOption();
  String OPTION_NAME=CommandOption.NAMESERVER_SEARCH_BY_NAME.getOption();
  if (isPrefixedArgument(argumentList.get(0),OPTION_IP + PARAM_SEPARATOR)) {
    String argumentWithoutPrefix=removePrefix(argumentList.get(0),OPTION_IP);
    argumentWithoutPrefix=urlEncode(argumentWithoutPrefix);
    uri=uri + OPTION_IP + ""String_Node_Str""+ argumentWithoutPrefix;
  }
 else {
    List<String> argumntList=command.getArgumentList();
    throwExceptionIfArguementIsEmpty(argumntList);
    uri=uri + OPTION_NAME + ""String_Node_Str""+ urlEncode(argumntList.get(0));
  }
  return uri;
}",0.8717294192724953
37329,"/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new DecodeException(""String_Node_Str"",e);
  }
  return result;
}",0.8092105263157895
37330,"/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
@Deprecated public static String decodeAndReplaceAsciiToLowercase(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  LOGGER.debug(""String_Node_Str"",str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}","/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
@Deprecated public static String decodeAndReplaceAsciiToLowercase(String str) throws DecodeException {
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  LOGGER.debug(""String_Node_Str"",str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}",0.9824561403508772
37331,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.9836065573770492
37332,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request) throws DecodeException {
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9790575916230366
37333,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.urlDecode(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9943741209563994
37334,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.urlDecode(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.foldCaseAndNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.996300863131936
37335,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.986159169550173
37336,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request){
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nsName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nsName,HttpServletRequest request) throws DecodeException {
  nsName=queryParser.getLastSplitInURI(request);
  String decodeNS=nsName;
  String punyNSName=decodeNS;
  decodeNS=DomainUtil.urlDecode(nsName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.foldCaseAndNormalization(decodeNS);
  try {
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nsName);
}",0.9922730199613652
37337,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  handle=StringUtil.foldCaseAndNormalization(handle);
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9900826446280993
37338,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response) throws DecodeException {
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9924575738529228
37339,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request) throws DecodeException {
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  decodeDomain=DomainUtil.urlDecode(domainName);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.foldCaseAndNormalization(decodeDomain);
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9932885906040269
37340,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request) throws DecodeException {
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  paramValue=StringUtil.foldCaseAndNormalization(paramValue);
  paramValue=StringUtils.trim(paramValue);
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9943422913719944
37341,"@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException || ex instanceof HttpMediaTypeNotAcceptableException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof DecodeException) {
    responseEntity=RestResponseUtil.createResponse400();
  }
 else   if (ex instanceof InvalidMediaTypeException || ex instanceof HttpMediaTypeNotAcceptableException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.9217134416543574
37342,"/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}","/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request) throws DecodeException {
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}",0.9751552795031057
37343,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(DELIMITER_BASED_FRAME_DECODER);
  pipeline.addLast(DECODER);
  pipeline.addLast(ENCODER);
  pipeline.addLast(MANAGE_HANDLER);
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
  pipeline.addLast(DECODER);
  pipeline.addLast(ENCODER);
  pipeline.addLast(MANAGE_HANDLER);
}",0.8405797101449275
37344,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(DELIMITER_BASED_FRAME_DECODER);
  pipeline.addLast(DECODER);
  pipeline.addLast(ENCODER);
  pipeline.addLast(SERVICE_HANDLER);
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
  pipeline.addLast(DECODER);
  pipeline.addLast(ENCODER);
  pipeline.addLast(SERVICE_HANDLER);
}",0.8411552346570397
37345,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline p=ch.pipeline();
  p.addLast(new LoggingHandler(LogLevel.INFO));
  p.addLast(ManageServerInitializer.DELIMITER_BASED_FRAME_DECODER);
  p.addLast(ManageServerInitializer.DECODER);
  p.addLast(ManageServerInitializer.ENCODER);
  p.addLast(new ShutdownClientHandler());
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline p=ch.pipeline();
  p.addLast(new LoggingHandler(LogLevel.INFO));
  p.addLast(new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
  p.addLast(ManageServerInitializer.DECODER);
  p.addLast(ManageServerInitializer.ENCODER);
  p.addLast(new ShutdownClientHandler());
}",0.6132596685082873
37346,"/** 
 * shutdown.
 * @throws InterruptedException InterruptedException.
 */
public static void shutdown() throws InterruptedException {
  Bootstrap boot=new Bootstrap();
  boot.group(EVENT_GROUP).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY,true).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline p=ch.pipeline();
      p.addLast(new LoggingHandler(LogLevel.INFO));
      p.addLast(ManageServerInitializer.DELIMITER_BASED_FRAME_DECODER);
      p.addLast(ManageServerInitializer.DECODER);
      p.addLast(ManageServerInitializer.ENCODER);
      p.addLast(new ShutdownClientHandler());
    }
  }
);
  channelFuture=boot.connect(HOST,MANAGE_PORT).sync();
}","/** 
 * shutdown.
 * @throws InterruptedException InterruptedException.
 */
public static void shutdown() throws InterruptedException {
  Bootstrap boot=new Bootstrap();
  boot.group(EVENT_GROUP).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY,true).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline p=ch.pipeline();
      p.addLast(new LoggingHandler(LogLevel.INFO));
      p.addLast(new DelimiterBasedFrameDecoder(8192,Delimiters.lineDelimiter()));
      p.addLast(ManageServerInitializer.DECODER);
      p.addLast(ManageServerInitializer.ENCODER);
      p.addLast(new ShutdownClientHandler());
    }
  }
);
  channelFuture=boot.connect(HOST,MANAGE_PORT).sync();
}",0.9318766066838048
37347,"@Test public void testGetProp(){
  assertNotNull(RdapProperties.getMinSecondsAccessInterval());
  assertNotNull(RdapProperties.getPort());
  assertNotNull(RdapProperties.getRdapServerBaseUrl());
  assertNotNull(RdapProperties.getResponseFormater());
}","@Test public void testGetProp(){
  assertNotNull(RdapProperties.getMinSecondsAccessInterval());
  assertNotNull(RdapProperties.getServicePort());
  assertNotNull(RdapProperties.getManagePort());
  assertNotNull(RdapProperties.getRdapServerBaseUrl());
  assertNotNull(RdapProperties.getResponseFormater());
}",0.7311827956989247
37348,"/** 
 * test exceedRateLimit.
 * @throws InterruptedException InterruptedException.
 */
@Test public void testExceedRateLimit() throws InterruptedException {
  String clientIp=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",1L);
  assertFalse(ConnectionControlService.exceedRateLimit(null));
  assertFalse(ConnectionControlService.exceedRateLimit(""String_Node_Str""));
  assertFalse(ConnectionControlService.exceedRateLimit(clientIp));
  Thread.sleep(2);
  assertFalse(ConnectionControlService.exceedRateLimit(clientIp));
  ReflectionTestUtils.setField(prop,""String_Node_Str"",1000L);
  assertTrue(ConnectionControlService.exceedRateLimit(clientIp));
}","/** 
 * test exceedRateLimit.
 * @throws InterruptedException InterruptedException.
 */
@Test public void testExceedRateLimit() throws InterruptedException {
  String clientIp=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",1L);
  assertFalse(ConnectionControlService.exceedRateLimit(null));
  assertFalse(ConnectionControlService.exceedRateLimit(""String_Node_Str""));
  assertFalse(ConnectionControlService.exceedRateLimit(clientIp));
  Thread.sleep(2);
  assertFalse(ConnectionControlService.exceedRateLimit(clientIp));
  ReflectionTestUtils.setField(prop,""String_Node_Str"",1000L);
}",0.9518950437317784
37349,"/** 
 * format object.
 * @param key key.
 * @param object object.
 * @param result result.
 */
public void formatObject(String key,Object object,StringBuffer result){
  if (""String_Node_Str"".equals(key)) {
    result.append(MAX_INDENTS,0,getDepth());
    String displayValue=getTextFormatedVcardStr(object);
    String replacement=StringUtils.substring(MAX_INDENTS,0,getDepth() + 1);
    displayValue=LINE_SEPARATOR + displayValue;
    displayValue=StringUtils.removeEnd(displayValue,LINE_SEPARATOR);
    displayValue=StringUtils.replace(displayValue,LINE_SEPARATOR,LINE_SEPARATOR + replacement);
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(displayValue);
    result.append(LINE_SEPARATOR);
  }
 else   if (object instanceof String) {
    result.append(MAX_INDENTS,0,getDepth());
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(object);
    result.append(LINE_SEPARATOR);
  }
 else   if (object instanceof Map) {
    result.append(MAX_INDENTS,0,getDepth());
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(LINE_SEPARATOR);
    depth.get().increment();
    formatMap((Map)object,result);
    depth.get().decrement();
  }
 else   if (object instanceof List) {
    formatList(key,(List)object,result);
  }
}","/** 
 * format object.
 * @param key key.
 * @param object object.
 * @param result result.
 */
public void formatObject(String key,Object object,StringBuffer result){
  if (""String_Node_Str"".equals(key)) {
    result.append(MAX_INDENTS,0,getDepth());
    String displayValue=getTextFormatedVcardStr(object);
    String replacement=StringUtils.substring(MAX_INDENTS,0,getDepth() + 1);
    displayValue=LINE_SEPARATOR + displayValue;
    displayValue=StringUtils.removeEnd(displayValue,LINE_SEPARATOR);
    displayValue=StringUtils.replace(displayValue,LINE_SEPARATOR,LINE_SEPARATOR + replacement);
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(displayValue);
    result.append(LINE_SEPARATOR);
  }
 else   if (object instanceof Map) {
    result.append(MAX_INDENTS,0,getDepth());
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(LINE_SEPARATOR);
    depth.get().increment();
    formatMap((Map)object,result);
    depth.get().decrement();
  }
 else   if (object instanceof List) {
    formatList(key,(List)object,result);
  }
 else {
    result.append(MAX_INDENTS,0,getDepth());
    result.append(key);
    result.append(KEY_VALUE_SEPARATOR);
    result.append(object);
    result.append(LINE_SEPARATOR);
  }
}",0.8478764478764479
37350,"/** 
 * check if decodeUri contain non-ascii-printable chars.
 * @param decodeUri decodeUri
 * @return true if contains,false if not.
 */
public static boolean containNonAsciiPrintableChars(String decodeUri){
  if (StringUtils.isBlank(decodeUri)) {
    return false;
  }
  return !StringUtils.isAsciiPrintable(decodeUri);
}","/** 
 * check if decodeUri contain non-ASCII-printable chars.
 * @param decodeUri decodeUri
 * @return true if contains,false if not.
 */
public static boolean containNonAsciiPrintableChars(String decodeUri){
  if (StringUtils.isBlank(decodeUri)) {
    return false;
  }
  return !StringUtils.isAsciiPrintable(decodeUri);
}",0.9845201238390092
37351,"/** 
 * do pre process request method.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  boolean httpMethodIsValid=httpMethodIsValid(request);
  if (!httpMethodIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse405();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  boolean contentTypeIsValid=contentTypeIsValid(request);
  if (!contentTypeIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse415();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  return true;
}","/** 
 * do pre process request method.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  boolean httpMethodIsValid=httpMethodIsValid(request);
  LOGGER.debug(""String_Node_Str"",httpMethodIsValid);
  if (!httpMethodIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse405();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  boolean mediaTypeIsValid=mediaTypeIsValid(request);
  LOGGER.debug(""String_Node_Str"",mediaTypeIsValid);
  if (!mediaTypeIsValid) {
    ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse415();
    FilterHelper.writeResponse(responseEntity,response);
    return false;
  }
  return true;
}",0.920741989881956
37352,"@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException || ex instanceof HttpMediaTypeNotAcceptableException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.9556485355648536
37353,"/** 
 * check if content type is valid.
 * @param request HttpServletRequest
 * @return true if valid, false if not
 */
private boolean contentTypeIsValid(HttpServletRequest request){
  String acceptHeader=request.getHeader(""String_Node_Str"");
  if (StringUtils.isBlank(acceptHeader)) {
    return true;
  }
  if (VALID_CONTENT_TYPE.equals(acceptHeader) || acceptHeader.startsWith(VALID_CONTENT_TYPE + ""String_Node_Str"")) {
    return true;
  }
  return false;
}","/** 
 * check if content type is valid.
 * @param request HttpServletRequest
 * @return true if valid, false if not
 */
private boolean contentTypeIsValid(HttpServletRequest request){
  String acceptHeader=request.getHeader(""String_Node_Str"");
  if (StringUtils.isBlank(acceptHeader)) {
    return true;
  }
  if (VALID_CONTENT_TYPE.equals(acceptHeader) || acceptHeader.startsWith(VALID_CONTENT_TYPE + ""String_Node_Str"") || acceptHeader.startsWith(VALID_CONTENT_TYPE + ""String_Node_Str"")|| acceptHeader.contains(""String_Node_Str"" + VALID_CONTENT_TYPE + ""String_Node_Str"")|| acceptHeader.endsWith(""String_Node_Str"" + VALID_CONTENT_TYPE)) {
    return true;
  }
  return false;
}",0.8112379280070237
37354,"/** 
 * get name.
 * @return name.
 */
public String getName(){
  return name;
}","/** 
 * get name.
 * @return name.
 */
@JsonValue public String getName(){
  return name;
}",0.935672514619883
37355,"/** 
 * do pre process url.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  if (StringUtils.isBlank(path)) {
    writeError400Response(response);
    return false;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return false;
  }
  try {
    decodeUri=urlDecode(uri);
  }
 catch (  Exception e) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (containInvalidSpace(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (pathContainInvalidChar(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX + ""String_Node_Str"")) {
      LOGGER.debug(""String_Node_Str"",uriWithoutPrefixSlash,RDAP_URL_PREFIX);
      writeError400Response(response);
      return false;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
 else     if (uriWithoutPrefixSlash.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
  }
  return true;
}","/** 
 * do pre process url.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  LOGGER.info(""String_Node_Str"",path);
  if (StringUtils.isBlank(path) || ""String_Node_Str"".equals(path)) {
    writeError400Response(response);
    return false;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return false;
  }
  try {
    decodeUri=urlDecode(uri);
  }
 catch (  Exception e) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (containInvalidSpace(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (pathContainInvalidChar(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX + ""String_Node_Str"")) {
      LOGGER.debug(""String_Node_Str"",uriWithoutPrefixSlash,RDAP_URL_PREFIX);
      writeError400Response(response);
      return false;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
 else     if (uriWithoutPrefixSlash.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
  }
  return true;
}",0.9813060179257362
37356,"/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
private static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}",0.9856209150326798
37357,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9605700712589074
37358,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9742715437073776
37359,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9577393075356416
37360,"/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}","/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}",0.956810631229236
37361,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.980169971671388
37362,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9744058500914076
37363,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.999752658916646
37364,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.999840891010342
37365,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. <pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9994148624926856
37366,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName,HttpServletRequest request){
  nameserverName=queryParser.getLastSplitInURI(request);
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName,HttpServletRequest request){
  nameserverName=queryParser.getLastSplitInURI(request);
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.991442542787286
37367,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9995627459554
37368,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9996832435856826
37369,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9923539049699618
37370,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. <pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.999734113267748
37371,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask){
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.8972111553784861
37372,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr){
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9232323232323232
37373,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. <pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"");
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. <pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.901712111604312
37374,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName,HttpServletRequest request){
  nameserverName=queryParser.getLastSplitInURI(request);
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.9734177215189872
37375,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.978095663835494
37376,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9842291599613776
37377,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9774901519414744
37378,"/** 
 * do pre process url.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  if (StringUtils.isBlank(path)) {
    writeError400Response(response);
    return false;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return false;
  }
  try {
    decodeUri=urlDecode(uri);
  }
 catch (  Exception e) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (containInvalidSpace(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX)) {
      writeError400Response(response);
      return false;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
 else     if (uriWithoutPrefixSlash.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
  }
  return true;
}","/** 
 * do pre process url.
 * @param request request.
 * @param response response.
 * @throws Exception Exception.
 * @return true if success processed,and can do service operation; false ifnot.
 */
@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  if (StringUtils.isBlank(path)) {
    writeError400Response(response);
    return false;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return false;
  }
  try {
    decodeUri=urlDecode(uri);
  }
 catch (  Exception e) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return false;
  }
  if (containInvalidSpace(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (pathContainInvalidChar(decodeUri)) {
    writeError400Response(response);
    return false;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX + ""String_Node_Str"")) {
      LOGGER.debug(""String_Node_Str"",uriWithoutPrefixSlash,RDAP_URL_PREFIX);
      writeError400Response(response);
      return false;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
 else     if (uriWithoutPrefixSlash.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return false;
    }
  }
  return true;
}",0.8576933663638866
37379,"/** 
 * set error message service.
 * @param errorMessageService error message service to set.
 */
@Autowired public void setErrorMessageService(ErrorMessageService errorMessageService){
  RestResponseUtil.errorMessageService=errorMessageService;
}","/** 
 * set error message service.
 * @param errorMsgService error message service to set.
 */
@Autowired public void setErrorMessageService(ErrorMessageService errorMsgService){
  RestResponseUtil.errorMessageService=errorMsgService;
}",0.950413223140496
37380,"/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}","/** 
 * <pre> query ip by ip and mask. URI:/ip/{ipAddr}/{mask}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask,HttpServletRequest request){
  ipAddr=queryParser.getLastSecondSplitInURI(request);
  mask=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.980169971671388
37381,"/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}","/** 
 * <pre> query ip by ip address. URI:/ip/{ipAddr}  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param ipAddr the query ip
 * @param request request.
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr,HttpServletRequest request){
  ipAddr=queryParser.getLastSplitInURI(request);
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9744058500914076
37382,"/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search domain by domain name. URI:/domains?name={domain name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request quest for httpServlet.
 * @param response response for httpServlet.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.999752658916646
37383,"/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search nameserver by name or ip. URI:/nameservers?name={nsName}  OR /nameservers?ip={ip}  parameter 'ip' can only be precise ip address.  This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.999840891010342
37384,"/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. <pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> Query help. URI:/help. This service is not under permission control. This service is not under policy control. </pre>
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryHelp(HttpServletRequest request,HttpServletResponse response){
  String lastSpliInURI=queryParser.getLastSplitInURI(request);
  if (!""String_Node_Str"".equals(lastSpliInURI)) {
    return RestResponseUtil.createResponse400();
  }
  Help result=queryService.queryHelp(queryParser.parseQueryParam(""String_Node_Str""));
  if (null != result) {
    responseDecorator.decorateResponseForHelp(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9994148624926856
37385,"/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName,HttpServletRequest request){
  nameserverName=queryParser.getLastSplitInURI(request);
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * <pre> query nameserver by nameserver name. URI:/nameserver/{nameserver name} This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @param request request.
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName,HttpServletRequest request){
  nameserverName=queryParser.getLastSplitInURI(request);
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.991442542787286
37386,"/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query entity. Uri:/entity/{handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param handle entity handle.
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryEntity(@PathVariable String handle,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + handle);
  handle=queryParser.getLastSplitInURI(request);
  handle=StringUtils.trim(handle);
  if (!StringUtil.isValidEntityHandleOrName(handle)) {
    return RestResponseUtil.createResponse400();
  }
  Entity result=queryService.queryEntity(queryParser.parseQueryParam(handle));
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9995627459554
37387,"/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> query autnum. URI:/autnum/{autnum} First query autnum in local registry, if not exist, then query  for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.debug(""String_Node_Str"" + autnum);
  autnum=queryParser.getLastSplitInURI(request);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (redirectService.isValidRedirect(redirect)) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9996832435856826
37388,"/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. <pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * <pre> query domain by domain name. URI:/domain/{domainName} If domain tld is configured in 'inTlds' and not in 'notInTlds' of rdap.properties file, will query in local registry;  If domain tld is configured in 'notInTlds' and not in 'inTlds', will query for redirect. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. </pre>
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request request.
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName,HttpServletRequest request){
  domainName=queryParser.getLastSplitInURI(request);
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9923539049699618
37389,"/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. <pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * <pre> search entity by handle or name. URI:/entities?fn={entity name} ; /entities?handle={handle}. This service is under permission control, @see AccessControlManager. This service is under policy control, @see PolicyControlService. The first appearance parameter 'fn' and 'handle' will be handled, and other parameters will be ignored. Parameter will be trimed. </pre>
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.debug(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.debug(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.999734113267748
37390,"/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
private static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
public static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}",0.9856209150326798
37391,"/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}","/** 
 * get last split in URI. <p> For spring will ignore ending params, eg: /cnnic.cn%1a. <p> eg: for URI '/domain/cnnic.cn' return 'cnnic.cn'.
 * @param request request.
 * @return param value.
 */
public String getLastSplitInURI(HttpServletRequest request){
  String path=request.getRequestURI();
  String result=StringUtils.substringAfterLast(path,""String_Node_Str"");
  result=DomainUtil.urlDecode(result);
  LOGGER.debug(""String_Node_Str"",result);
  return result;
}",0.956810631229236
37392,"@Override public ModelType getObjectType(){
  return ModelType.HELP;
}","/** 
 * @return objectType: HELP.
 */
@Override public ModelType getObjectType(){
  return ModelType.HELP;
}",0.7865168539325843
37393,"@Override public String toString(){
  return new ToStringBuilder(this).append(""String_Node_Str"").toString();
}","/** 
 * @return String.
 */
@Override public String toString(){
  return new ToStringBuilder(this).append(""String_Node_Str"").toString();
}",0.8870967741935484
37394,"/** 
 * trucate the string.
 * @param strMethod set the method string trucated.
 * @return string of method.
 */
private String trucateStringFromMethod(String strMethod){
  LOGGER.info(""String_Node_Str"" + strMethod);
  final String strSet=""String_Node_Str"";
  final String strGet=""String_Node_Str"";
  final String strIs=""String_Node_Str"";
  if (!strMethod.startsWith(strSet) && !strMethod.startsWith(strGet) && !strMethod.startsWith(strIs)) {
    LOGGER.info(""String_Node_Str"");
    return null;
  }
  int posAfterSet=strSet.length();
  if (strMethod.startsWith(strIs)) {
    posAfterSet=strIs.length();
  }
  String strMethodField=strMethod.substring(posAfterSet);
  String strFieldFirstLetter=strMethodField.substring(0,1);
  String strReplace=StringUtils.lowerCase(strFieldFirstLetter);
  strMethodField=strMethodField.replaceFirst(strFieldFirstLetter,strReplace);
  LOGGER.info(""String_Node_Str"" + strMethodField);
  return strMethodField;
}","/** 
 * trucate the string.
 * @param strMethod set the method string trucated.
 * @return string of method.
 */
private String trucateStringFromMethod(String strMethod){
  final String strSet=""String_Node_Str"";
  final String strGet=""String_Node_Str"";
  final String strIs=""String_Node_Str"";
  if (!strMethod.startsWith(strSet) && !strMethod.startsWith(strGet) && !strMethod.startsWith(strIs)) {
    return null;
  }
  int posAfterSet=strSet.length();
  if (strMethod.startsWith(strIs)) {
    posAfterSet=strIs.length();
  }
  String strMethodField=strMethod.substring(posAfterSet);
  String strFieldFirstLetter=strMethodField.substring(0,1);
  String strReplace=StringUtils.lowerCase(strFieldFirstLetter);
  strMethodField=strMethodField.replaceFirst(strFieldFirstLetter,strReplace);
  return strMethodField;
}",0.8992601024473534
37395,"/** 
 * get the baseModel property value.
 * @param objModel model of object.
 */
@Override public void applyPolicy(final Object objModel){
  LOGGER.info(""String_Node_Str"" + objModel);
  if (objModel == null) {
    return;
  }
  Map<String,Set<String>> mapObjFields=loadPolicyFieldsByMap();
  if (null == mapObjFields) {
    return;
  }
  String strObjType=null;
  if (objModel.getClass().getSuperclass() == BaseModel.class || objModel.getClass().getSuperclass() == BaseSearchModel.class) {
    strObjType=getModelString(objModel);
  }
  if (strObjType == null) {
    return;
  }
  Set<String> setFields=mapObjFields.get(strObjType);
  Method[] allMethods=ReflectionUtils.getUniqueDeclaredMethods(objModel.getClass());
  for (  Method mthd : allMethods) {
    String strMethod=mthd.getName();
    String strMethodField=trucateStringFromMethod(strMethod);
    if (strMethodField == null) {
      continue;
    }
    Object value=null;
    final String strSetFirstWord=""String_Node_Str"";
    boolean isSetMethod=strMethod.startsWith(strSetFirstWord);
    boolean isGetMethod=strMethod.startsWith(""String_Node_Str"");
    String strIsBool=mthd.getReturnType().toString();
    if (!strIsBool.contains(""String_Node_Str"") && isGetMethod) {
      value=getPropertyValue(objModel,strMethodField);
    }
    if (setFields != null) {
      Iterator<String> iter=setFields.iterator();
      while (iter.hasNext()) {
        String strField=iter.next();
        if (strMethodField.equalsIgnoreCase(strField) && isSetMethod) {
          setPropertyNull(objModel,strMethodField);
          break;
        }
      }
    }
    if (value == null) {
      continue;
    }
    if (mthd.getReturnType() == List.class) {
      setInnerListPolicy(value);
    }
 else {
      applyPolicy(value);
    }
  }
  return;
}","/** 
 * get the baseModel property value.
 * @param objModel model of object.
 */
@Override public void applyPolicy(final Object objModel){
  if (objModel == null) {
    return;
  }
  Map<String,Set<String>> mapObjFields=loadPolicyFieldsByMap();
  if (null == mapObjFields) {
    return;
  }
  String strObjType=null;
  if (objModel.getClass().getSuperclass() == BaseModel.class || objModel.getClass().getSuperclass() == BaseSearchModel.class) {
    strObjType=getModelString(objModel);
  }
  if (strObjType == null) {
    return;
  }
  Set<String> setFields=mapObjFields.get(strObjType);
  Method[] allMethods=ReflectionUtils.getUniqueDeclaredMethods(objModel.getClass());
  for (  Method mthd : allMethods) {
    String strMethod=mthd.getName();
    String strMethodField=trucateStringFromMethod(strMethod);
    if (strMethodField == null) {
      continue;
    }
    Object value=null;
    final String strSetFirstWord=""String_Node_Str"";
    boolean isSetMethod=strMethod.startsWith(strSetFirstWord);
    boolean isGetMethod=strMethod.startsWith(""String_Node_Str"");
    String strIsBool=mthd.getReturnType().toString();
    if (!strIsBool.contains(""String_Node_Str"") && isGetMethod) {
      value=getPropertyValue(objModel,strMethodField);
    }
    if (setFields != null) {
      Iterator<String> iter=setFields.iterator();
      while (iter.hasNext()) {
        String strField=iter.next();
        if (strMethodField.equalsIgnoreCase(strField) && isSetMethod) {
          setPropertyNull(objModel,strMethodField);
          break;
        }
      }
    }
    if (value == null) {
      continue;
    }
    if (mthd.getReturnType() == List.class) {
      setInnerListPolicy(value);
    }
 else {
      applyPolicy(value);
    }
  }
  return;
}",0.1694436599830556
37396,"/** 
 * set the inner object policy.
 * @param object object to set.
 */
private void setInnerListPolicy(final Object object){
  LOGGER.info(""String_Node_Str"" + object);
  List<?> listObjs=(List<?>)object;
  if (listObjs != null) {
    for (int iObj=0; iObj < listObjs.size(); ++iObj) {
      applyPolicy(listObjs.get(iObj));
    }
  }
}","/** 
 * set the inner object policy.
 * @param object object to set.
 */
private void setInnerListPolicy(final Object object){
  List<?> listObjs=(List<?>)object;
  if (listObjs != null) {
    for (int iObj=0; iObj < listObjs.size(); ++iObj) {
      applyPolicy(listObjs.get(iObj));
    }
  }
}",0.9318541996830428
37397,"/** 
 * get Model String.
 * @param objModel the model of object.
 * @return string of object type.
 */
private String getModelString(final Object objModel){
  LOGGER.info(""String_Node_Str"" + objModel);
  String strObjType=null;
  ModelType modelType=((BaseModel)objModel).getObjectType();
  strObjType=modelType.getName();
  if (strObjType == ""String_Node_Str"") {
    LOGGER.info(""String_Node_Str"");
    return null;
  }
  LOGGER.info(""String_Node_Str"" + strObjType);
  return strObjType;
}","/** 
 * get Model String.
 * @param objModel the model of object.
 * @return string of object type.
 */
private String getModelString(final Object objModel){
  String strObjType=null;
  ModelType modelType=((BaseModel)objModel).getObjectType();
  strObjType=modelType.getName();
  if (strObjType == ""String_Node_Str"") {
    LOGGER.info(""String_Node_Str"");
    return null;
  }
  return strObjType;
}",0.5280898876404494
37398,"/** 
 * test search exist truncated nameserver.
 * @throws Exception throw a exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchTruncatedNameserver() throws Exception {
  String nsHead=""String_Node_Str"";
  String ipHead=""String_Node_Str"";
  String nsName=nsHead + ""String_Node_Str"";
  String nsIpV6=ipHead + ""String_Node_Str"";
  String ipHighCase=ipHead + ""String_Node_Str"";
  searchTruncatedNS(nsName);
  searchTruncatedNS(nsIpV6);
  searchTruncatedNS(ipHighCase);
}","/** 
 * test search exist truncated nameserver.
 * @throws Exception throw a exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchTruncatedNameserver() throws Exception {
  RestResponseUtil.initErrorMessages();
  String nsHead=""String_Node_Str"";
  String ipHead=""String_Node_Str"";
  String nsName=nsHead + ""String_Node_Str"";
  String nsIpV6=ipHead + ""String_Node_Str"";
  String ipHighCase=ipHead + ""String_Node_Str"";
  searchTruncatedNS(nsName);
  searchTruncatedNS(nsIpV6);
  searchTruncatedNS(ipHighCase);
}",0.9636363636363636
37399,"/** 
 * test search exist nameserver.
 * @throws Exception throw a exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchExistNameserver() throws Exception {
  String nsNameCn=""String_Node_Str"";
  String ipHead=""String_Node_Str"";
  String nsNameIpV4=ipHead + ""String_Node_Str"";
  String nsNameIpV6Full=ipHead + ""String_Node_Str"";
  String nsNameIpV6Omit=ipHead + ""String_Node_Str"";
  String nsIpV4=ipHead + ""String_Node_Str"";
  String nsIpZero=ipHead + ""String_Node_Str"";
  String nsIpV4V6=ipHead + ""String_Node_Str"";
  String nsBoth1=nsNameCn + ""String_Node_Str"" + ipHead+ ""String_Node_Str"";
  String nsBoth2=ipHead + ""String_Node_Str"" + ""String_Node_Str""+ nsNameCn;
  String nsComplex=""String_Node_Str"";
  searchByObject(nsNameCn);
  searchByObject(nsNameIpV4);
  searchByObject(nsNameIpV6Full);
  searchByObject(nsNameIpV6Omit);
  searchByObject(nsIpV4);
  searchByObject(nsIpZero);
  searchByObject(nsIpV4V6);
  searchByObject(nsBoth1);
  searchByObject(nsBoth2);
  searchByObject(nsComplex);
}","/** 
 * test search exist nameserver.
 * @throws Exception throw a exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchExistNameserver() throws Exception {
  RestResponseUtil.initErrorMessages();
  String nsNameCn=""String_Node_Str"";
  String ipHead=""String_Node_Str"";
  String nsNameIpV4=ipHead + ""String_Node_Str"";
  String nsNameIpV6Full=ipHead + ""String_Node_Str"";
  String nsNameIpV6Omit=ipHead + ""String_Node_Str"";
  String nsIpV4=ipHead + ""String_Node_Str"";
  String nsIpZero=ipHead + ""String_Node_Str"";
  String nsIpV4V6=ipHead + ""String_Node_Str"";
  String nsBoth1=nsNameCn + ""String_Node_Str"" + ipHead+ ""String_Node_Str"";
  String nsBoth2=ipHead + ""String_Node_Str"" + ""String_Node_Str""+ nsNameCn;
  String nsComplex=""String_Node_Str"";
  searchByObject(nsNameCn);
  searchByObject(nsNameIpV4);
  searchByObject(nsNameIpV6Full);
  searchByObject(nsNameIpV6Omit);
  searchByObject(nsIpV4);
  searchByObject(nsIpZero);
  searchByObject(nsIpV4V6);
  searchByObject(nsBoth1);
  searchByObject(nsBoth2);
  searchByObject(nsComplex);
}",0.9814471243042672
37400,"/** 
 * test query exist nameserver.
 * @throws Exception exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistNameserver() throws Exception {
  RestResponseUtil.initConformanceService();
  String nsName=""String_Node_Str"";
  String nsNameWithPrefixBlank=""String_Node_Str"";
  String nsChineseLDH=""String_Node_Str"";
  String nsLangEn=""String_Node_Str"";
  String nsLangZh=""String_Node_Str"";
  String nsNameWithUpperCase=""String_Node_Str"";
  commonQueryExistNS(nsName,nsLangEn);
  commonQueryExistNS(nsNameWithPrefixBlank,nsLangEn);
  commonQueryExistNS(nsNameWithUpperCase,nsLangEn);
  nsChineseLDH=StringUtil.urlEncode(nsChineseLDH);
  commonQueryExistNS(nsChineseLDH,nsLangZh);
}","/** 
 * test query exist nameserver.
 * @throws Exception exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistNameserver() throws Exception {
  RestResponseUtil.initErrorMessages();
  RestResponseUtil.initConformanceService();
  String nsName=""String_Node_Str"";
  String nsNameWithPrefixBlank=""String_Node_Str"";
  String nsChineseLDH=""String_Node_Str"";
  String nsLangEn=""String_Node_Str"";
  String nsLangZh=""String_Node_Str"";
  String nsNameWithUpperCase=""String_Node_Str"";
  commonQueryExistNS(nsName,nsLangEn);
  commonQueryExistNS(nsNameWithPrefixBlank,nsLangEn);
  commonQueryExistNS(nsNameWithUpperCase,nsLangEn);
  nsChineseLDH=StringUtil.urlEncode(nsChineseLDH);
  commonQueryExistNS(nsChineseLDH,nsLangZh);
}",0.9737876802096984
37401,"/** 
 * test query exist nameserver.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") public void testQueryInvalidNS() throws Exception {
  commonQueryInvalidNS(""String_Node_Str"");
  commonQueryInvalidNS(""String_Node_Str"");
}","/** 
 * test query exist nameserver.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") public void testQueryInvalidNS() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidNS(""String_Node_Str"");
  commonQueryInvalidNS(""String_Node_Str"");
}",0.9242424242424242
37402,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test public void testQueryNonExistNS() throws Exception {
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test public void testQueryNonExistNS() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
  commonQueryNonExistNS(""String_Node_Str"");
}",0.9441340782122905
37403,"/** 
 * test query non exist.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExist(){
  Long nonExistAutnumId=10000L;
  List<Variants> variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.AUTNUM);
  assertNotNull(variants);
  assertEquals(variants.size(),0);
}","/** 
 * test query non exist.
 */
@Test @DatabaseTearDown(""String_Node_Str"") public void testQueryNonExist(){
  Long nonExistAutnumId=10000L;
  List<Variants> variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.DOMAIN);
  assertNotNull(variants);
  assertEquals(variants.size(),0);
  variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.AUTNUM);
  assertNull(variants);
}",0.6773333333333333
37404,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(value=""String_Node_Str"") public void testSearchExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(value=""String_Node_Str"") public void testSearchExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.9890510948905108
37405,"/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.987012987012987
37406,"/** 
 * test query non exist.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExist(){
  Long nonExistAutnumId=10000L;
  List<Variants> variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.AUTNUM);
  assertNotNull(variants);
  assertEquals(variants.size(),0);
}","/** 
 * test query non exist.
 */
@Test @DatabaseTearDown(""String_Node_Str"") public void testQueryNonExist(){
  Long nonExistAutnumId=10000L;
  List<Variants> variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.DOMAIN);
  assertNotNull(variants);
  assertEquals(variants.size(),0);
  variants=variantsQueryDao.queryAsInnerObjects(nonExistAutnumId,ModelType.AUTNUM);
  assertNull(variants);
}",0.6773333333333333
37407,"/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
  responseEntity=RestResponseUtil.createResponse500();
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
 else {
    responseEntity=RestResponseUtil.createResponse500();
  }
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.9882154882154882
37408,"@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  Principal principal=Principal.getAnonymousPrincipal();
  if (StringUtils.isNotBlank(tempPass)) {
    String AUTH_BASIC_PREFIX=""String_Node_Str"";
    if (!StringUtils.startsWith(tempPass,AUTH_BASIC_PREFIX)) {
      writeError401Response(response);
      return false;
    }
    tempPass=tempPass.substring(AUTH_BASIC_PREFIX.length(),tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      writeError401Response(response);
      return false;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    int indexOfSeparator=tempPassdeCode.indexOf(""String_Node_Str"");
    if (-1 == indexOfSeparator) {
      writeError401Response(response);
      return false;
    }
    userReqId=tempPassdeCode.substring(0,indexOfSeparator);
    userReqPwd=tempPassdeCode.substring(indexOfSeparator + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return false;
    }
 else {
      principal=new Principal(user.getUserId());
    }
  }
  PrincipalHolder.setPrincipal(principal);
  return true;
}","@Override public boolean preProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  Principal principal=Principal.getAnonymousPrincipal();
  if (StringUtils.isNotBlank(tempPass)) {
    String AUTH_BASIC_PREFIX=""String_Node_Str"";
    if (!StringUtils.startsWithIgnoreCase(tempPass,AUTH_BASIC_PREFIX)) {
      writeError401Response(response);
      return false;
    }
    tempPass=tempPass.substring(AUTH_BASIC_PREFIX.length(),tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      writeError401Response(response);
      return false;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    int indexOfSeparator=tempPassdeCode.indexOf(""String_Node_Str"");
    if (-1 == indexOfSeparator) {
      writeError401Response(response);
      return false;
    }
    userReqId=tempPassdeCode.substring(0,indexOfSeparator);
    userReqPwd=tempPassdeCode.substring(indexOfSeparator + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return false;
    }
 else {
      principal=new Principal(user.getUserId());
    }
  }
  PrincipalHolder.setPrincipal(principal);
  return true;
}",0.9969493593654668
37409,"/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9671015314804312
37410,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.976429809358752
37411,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.9631811487481592
37412,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9572901325478644
37413,"/** 
 * query domain (RIR or DNR).
 * @param queryParam QueryParam.
 * @return domain .
 */
@Override public Domain query(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  if (domainQueryParam.isRirDomain()) {
    Domain domain=queryArpaWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    queryAndSetInnerNetwork(domain);
    return domain;
  }
 else {
    Domain domain=queryDomainWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    return domain;
  }
}","/** 
 * query domain (RIR or DNR).
 * @param queryParam QueryParam.
 * @return domain .
 */
@Override public Domain query(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  if (domainQueryParam.isRirDomain()) {
    Domain domain=queryArpaWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    queryAndSetInnerNetwork(domain);
    return domain;
  }
 else {
    Domain domain=queryDomainWithoutInnerObjects(queryParam);
    queryAndSetInnerObjects(domain);
    queryAndSetVariants(domain);
    return domain;
  }
}",0.9703504043126684
37414,"/** 
 * query inner objects of domain,and set fill them to domain.
 * @param domains domain list.
 */
private void queryAndSetInnerObjectsWithoutNotice(List<Domain> domains){
  if (null == domains) {
    return;
  }
  for (  Domain domain : domains) {
    queryAndSetInnerObjects(domain);
  }
}","/** 
 * query inner objects of domain,and set fill them to domain.
 * @param domains domain list.
 */
private void queryAndSetInnerObjectsWithoutNotice(List<Domain> domains){
  if (null == domains) {
    return;
  }
  for (  Domain domain : domains) {
    queryAndSetInnerObjects(domain);
    queryAndSetVariants(domain);
  }
}",0.9468599033816424
37415,"/** 
 * query inner objects of domain,and set fill them to domain.
 * @param domain inner objects will be filled.
 */
private void queryAndSetInnerObjects(Domain domain){
  if (null == domain) {
    return;
  }
  Long domainId=domain.getId();
  ModelType type=domain.getDomainType();
  List<Variants> variants=variantsQueryDao.queryAsInnerObjects(domainId,type);
  domain.setVariants(variants);
  List<Nameserver> nameServers=nameserverQueryDao.queryAsInnerObjects(domainId,type);
  domain.setNameServers(nameServers);
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(domainId,type);
  if (null != secureDnsList && secureDnsList.size() > 0) {
    domain.setSecureDns(secureDnsList.get(0));
  }
  List<PublicId> publicIds=publicIdQueryDao.queryAsInnerObjects(domainId,type);
  domain.setPublicIds(publicIds);
  List<Remark> remarks=remarkQueryDao.queryAsInnerObjects(domainId,type);
  domain.setRemarks(remarks);
  List<Link> links=linkQueryDao.queryAsInnerObjects(domainId,type);
  domain.setLinks(links);
  List<Event> events=eventQueryDao.queryAsInnerObjects(domainId,type);
  domain.setEvents(events);
  List<Entity> entities=entityQueryDao.queryAsInnerObjects(domainId,type);
  domain.setEntities(entities);
}","/** 
 * query inner objects of domain,and set fill them to domain.
 * @param domain inner objects will be filled.
 */
private void queryAndSetInnerObjects(Domain domain){
  if (null == domain) {
    return;
  }
  Long domainId=domain.getId();
  ModelType type=domain.getDomainType();
  List<Nameserver> nameServers=nameserverQueryDao.queryAsInnerObjects(domainId,type);
  domain.setNameServers(nameServers);
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(domainId,type);
  if (null != secureDnsList && secureDnsList.size() > 0) {
    domain.setSecureDns(secureDnsList.get(0));
  }
  List<PublicId> publicIds=publicIdQueryDao.queryAsInnerObjects(domainId,type);
  domain.setPublicIds(publicIds);
  List<Remark> remarks=remarkQueryDao.queryAsInnerObjects(domainId,type);
  domain.setRemarks(remarks);
  List<Link> links=linkQueryDao.queryAsInnerObjects(domainId,type);
  domain.setLinks(links);
  List<Event> events=eventQueryDao.queryAsInnerObjects(domainId,type);
  domain.setEvents(events);
  List<Entity> entities=entityQueryDao.queryAsInnerObjects(domainId,type);
  domain.setEntities(entities);
}",0.9529062367416208
37416,"@Override public List<Variants> queryAsInnerObjects(final Long outerObjectId,final ModelType outerModelType){
  List<Variant> variantList=queryWithoutInnerObjects(outerObjectId);
  List<Variants> result=geneVariantsList(variantList);
  return result;
}","@Override public List<Variants> queryAsInnerObjects(final Long outerObjectId,final ModelType outerModelType){
  if (!ModelType.DOMAIN.equals(outerModelType)) {
    return null;
  }
  List<Variant> variantList=queryWithoutInnerObjects(outerObjectId);
  List<Variants> result=geneVariantsList(variantList);
  return result;
}",0.8765217391304347
37417,"/** 
 * main method.
 * @param args args.
 */
public static void main(String[] args){
  LOGGER.info(""String_Node_Str"");
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
  LOGGER.info(""String_Node_Str"");
}","/** 
 * main method.
 * @param args args.
 */
public static void main(String[] args){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",args);
  if (null == args || args.length < 1 || StringUtils.isBlank(args[0])) {
    LOGGER.info(""String_Node_Str"");
    printUsage();
    return;
  }
  String arg=args[0];
  if (!(isInitSchemaCmd(arg) || isInitDataCmd(arg))) {
    printUsage();
    return;
  }
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  if (isInitSchemaCmd(arg)) {
    initDao.initSchema();
  }
  if (isInitDataCmd(arg)) {
    initDao.initData();
  }
  LOGGER.info(""String_Node_Str"");
}",0.2914669223394056
37418,"/** 
 * Execute the given SQL script. <p> The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p> <b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from
 * @param continueOnError whether or not to continue without throwing an exception in the event of an error
 * @throws DataAccessException if there is an error executing a statement and {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 */
private static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,String databaseName,boolean continueOnError) throws DataAccessException {
  long startTime=System.currentTimeMillis();
  List<String> statements=new LinkedList<String>();
  LineNumberReader reader=null;
  try {
    reader=new LineNumberReader(resource.getReader());
    String script=readScript(reader);
    char delimiter=DEFAULT_STATEMENT_SEPARATOR;
    if (!containsSqlScriptDelimiters(script,delimiter)) {
      delimiter='\n';
    }
    splitSqlScript(script,delimiter,statements);
    int lineNumber=0;
    for (    String statement : statements) {
      lineNumber++;
      try {
        jdbcTemplate.update(""String_Node_Str"" + databaseName + ""String_Node_Str"");
      }
 catch (      DataAccessException ex) {
        LOGGER.error(""String_Node_Str"",databaseName,ex.getMessage());
      }
      try {
        int rowsAffected=jdbcTemplate.update(statement);
        LOGGER.info(rowsAffected + ""String_Node_Str"" + statement);
      }
 catch (      DataAccessException ex) {
        if (continueOnError) {
          LOGGER.error(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ resource+ ""String_Node_Str""+ statement,ex);
        }
 else {
          throw ex;
        }
      }
    }
    long elapsedTime=System.currentTimeMillis() - startTime;
    LOGGER.info(String.format(""String_Node_Str"",resource,elapsedTime));
  }
 catch (  IOException ex) {
    throw new DataAccessResourceFailureException(""String_Node_Str"" + resource,ex);
  }
 finally {
    try {
      if (reader != null) {
        reader.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}","/** 
 * Execute the given SQL script. <p> The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p> <b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from
 * @param continueOnError whether or not to continue without throwing an exception in the event of an error
 * @throws DataAccessException if there is an error executing a statement and {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 */
private static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,String databaseName,boolean continueOnError) throws DataAccessException {
  long startTime=System.currentTimeMillis();
  List<String> statements=new LinkedList<String>();
  LineNumberReader reader=null;
  try {
    reader=new LineNumberReader(resource.getReader());
    String script=readScript(reader);
    char delimiter=DEFAULT_STATEMENT_SEPARATOR;
    if (!containsSqlScriptDelimiters(script,delimiter)) {
      delimiter='\n';
    }
    splitSqlScript(script,delimiter,statements);
    int lineNumber=0;
    for (    String statement : statements) {
      lineNumber++;
      executeUseDatabaseStatement(statement,jdbcTemplate,databaseName);
      try {
        int rowsAffected=jdbcTemplate.update(statement);
        LOGGER.info(rowsAffected + ""String_Node_Str"" + statement);
      }
 catch (      DataAccessException ex) {
        if (continueOnError) {
          LOGGER.error(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ resource+ ""String_Node_Str""+ statement,ex);
        }
 else {
          throw ex;
        }
      }
    }
    long elapsedTime=System.currentTimeMillis() - startTime;
    LOGGER.info(String.format(""String_Node_Str"",resource,elapsedTime));
  }
 catch (  IOException ex) {
    throw new DataAccessResourceFailureException(""String_Node_Str"" + resource,ex);
  }
 finally {
    try {
      if (reader != null) {
        reader.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}",0.7971298108284409
37419,"/** 
 * initData.
 */
public void initData(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",SQL_RESOURCE_DATA_PATH,databaseName);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_DATA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}","/** 
 * initData.
 * @param arg
 */
public void initData(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",SQL_RESOURCE_DATA_PATH,databaseName);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_DATA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}",0.975
37420,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  LOGGER.debug(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  boolean success=preProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  if (!success) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  chain.doFilter(request,response);
  LOGGER.debug(""String_Node_Str"");
  success=postProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  LOGGER.debug(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  if (ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax()) {
    writeError509Response(response);
    ConnectionControlService.decrementAndGetCurrentQueryCount();
    return;
  }
  boolean success=preProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  if (!success) {
    LOGGER.error(""String_Node_Str"");
    ConnectionControlService.decrementAndGetCurrentQueryCount();
    return;
  }
  try {
    chain.doFilter(request,response);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
  }
  LOGGER.debug(""String_Node_Str"");
  success=postProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  ConnectionControlService.decrementAndGetCurrentQueryCount();
}",0.6695544554455446
37421,"/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
  responseEntity=RestResponseUtil.createResponse500();
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
  responseEntity=RestResponseUtil.createResponse500();
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.4911971830985915
37422,"@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  return true;
}","@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  return true;
}",0.8037383177570093
37423,"/** 
 * get Model String.
 * @param objModel the model of object.
 * @return string of object type.
 */
private String getModelString(final Object objModel){
  String strObjType=null;
  ModelType modelType=((BaseModel)objModel).getObjectType();
  strObjType=modelType.getName();
  return strObjType;
}","/** 
 * get Model String.
 * @param objModel the model of object.
 * @return string of object type.
 */
private String getModelString(final Object objModel){
  String strObjType=null;
  ModelType modelType=((BaseModel)objModel).getObjectType();
  strObjType=modelType.getName();
  if (strObjType == ""String_Node_Str"") {
    return null;
  }
  return strObjType;
}",0.8493975903614458
37424,"/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
public static String decodeAndReplaceAsciiToLowercase(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}","/** 
 * decode,and replace ASCII char to lower case.
 * @param str string.
 * @return str.
 */
public static String decodeAndReplaceAsciiToLowercase(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  str=urlDecode(str);
  LOGGER.debug(""String_Node_Str"",str);
  StringBuffer asciiLowerCasedSb=new StringBuffer();
  for (int i=0; i < str.length(); i++) {
    int c=str.charAt(i);
    char charVal=str.charAt(i);
    if (c <= MAX_ASCII_CODE) {
      asciiLowerCasedSb.append(StringUtils.lowerCase(String.valueOf(charVal)));
    }
 else {
      asciiLowerCasedSb.append(String.valueOf(charVal));
    }
  }
  return asciiLowerCasedSb.toString();
}",0.9695550351288056
37425,"/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 < StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  return false;
}","/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 < StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  return false;
}",0.9266837169650468
37426,"/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9671015314804312
37427,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.976429809358752
37428,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=StringUtil.getNormalization(decodeNS);
  LOGGER.debug(""String_Node_Str"",decodeNS);
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.9641495041952708
37429,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  LOGGER.debug(""String_Node_Str"",decodeDomain);
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9593869731800766
37430,"/** 
 * query arpa, without inner objects.
 * @param queryParam query parameter
 * @return domain
 */
private Domain queryDomainWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}","/** 
 * query arpa, without inner objects.
 * @param queryParam query parameter
 * @return domain
 */
private Domain queryDomainWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  LOGGER.debug(""String_Node_Str"",punyName);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}",0.97423887587822
37431,"/** 
 * test validateSearchStringIsValidIdna.
 */
@Test public void testValidateSearchStringIsValidIdna(){
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateSearchStringIsValidIdna.
 */
@Test public void testValidateSearchStringIsValidIdna(){
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertTrue(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
  assertFalse(validateSearchStringIsValidIdna(""String_Node_Str""));
}",0.4623831428995399
37432,"/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(validateDomainNameIsValidIdna(domain));
  }
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(null));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(validateDomainNameIsValidIdna(""String_Node_Str""));
}",0.9802451625975078
37433,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  String domainNameWithLastDot=""String_Node_Str"";
  String domainNameWithPrefixBlank=""String_Node_Str"";
  commonQueryExistDomain(domainName,domainName,domainName);
  commonQueryExistDomain(domainNameWithLastDot,domainName,domainName);
  commonQueryExistDomain(domainNameWithPrefixBlank,domainName,domainName);
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  String domainNameWithLastDot=""String_Node_Str"";
  String domainNameWithPrefixBlank=""String_Node_Str"";
  String domainNameWithUpperCase=""String_Node_Str"";
  String domainNameInFullWith=""String_Node_Str"";
  commonQueryExistDomain(domainName,domainName,domainName);
  commonQueryExistDomain(domainNameWithLastDot,domainName,domainName);
  commonQueryExistDomain(domainNameWithPrefixBlank,domainName,domainName);
  commonQueryExistDomain(domainNameWithUpperCase,domainName,domainName);
  commonQueryExistDomain(domainNameInFullWith,domainName,domainName);
}",0.8154311649016641
37434,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}",0.9805060141020324
37435,"/** 
 * common query non-exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryNonExistDomain(String queryDomainName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + queryDomainName).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * common query non-exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryNonExistDomain(String queryDomainName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.9828926905132191
37436,"/** 
 * common query invalid domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryInvalidDomain(String domainName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + domainName).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isBadRequest()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * common query invalid domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryInvalidDomain(String domainName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + StringUtil.urlEncode(domainName)).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isBadRequest()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.9667721518987342
37437,"/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  ResultActions r=mockMvc.perform(get(""String_Node_Str"" + queryDomainName).accept(MediaType.parseMediaType(""String_Node_Str"")));
  mockMvc.perform(get(""String_Node_Str"" + queryDomainName).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * common query exist domain.
 * @param domainName domain name.
 * @throws Exception Exception.
 */
private void commonQueryExistDomain(String queryDomainName,String expectedLdhName,String expectedUnicodeName) throws Exception {
  mockMvc.perform(get(""String_Node_Str"" + StringUtil.urlEncode(queryDomainName)).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(expectedLdhName)).andExpect(jsonPath(""String_Node_Str"").value(expectedUnicodeName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.961308750973773
37438,"/** 
 * test query exist ns.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistNameserver() throws Exception {
  String nsName=""String_Node_Str"";
  String nsNameWithPrefixBlank=""String_Node_Str"";
  String nsChineseLDH=""String_Node_Str"";
  String nsChineseUnicode=""String_Node_Str"";
  String nsLangEn=""String_Node_Str"";
  String nsLangZh=""String_Node_Str"";
  commonQueryExistNS(nsName,nsName,nsName,nsLangEn);
  commonQueryExistNS(nsNameWithPrefixBlank,nsName,nsName,nsLangEn);
  String nsChineseOrg=nsChineseLDH;
  nsChineseLDH=StringUtil.urlEncode(nsChineseLDH);
  commonQueryExistNS(nsChineseLDH,nsChineseOrg,nsChineseUnicode,nsLangZh);
}","/** 
 * test query exist ns.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistNameserver() throws Exception {
  String nsName=""String_Node_Str"";
  String nsNameWithPrefixBlank=""String_Node_Str"";
  String nsChineseLDH=""String_Node_Str"";
  String nsChineseUnicode=""String_Node_Str"";
  String nsLangEn=""String_Node_Str"";
  String nsLangZh=""String_Node_Str"";
  String nsNameWithUpperCase=""String_Node_Str"";
  String nsNameInFullWith=""String_Node_Str"";
  commonQueryExistNS(nsName,nsName,nsName,nsLangEn);
  commonQueryExistNS(nsNameWithPrefixBlank,nsName,nsName,nsLangEn);
  commonQueryExistNS(nsNameWithUpperCase,nsName,nsName,nsLangEn);
  commonQueryExistNS(nsNameInFullWith,nsName,nsName,nsLangEn);
  String nsChineseOrg=nsChineseLDH;
  nsChineseLDH=StringUtil.urlEncode(nsChineseLDH);
  commonQueryExistNS(nsChineseLDH,nsChineseOrg,nsChineseUnicode,nsLangZh);
}",0.8661037394451147
37439,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  LOGGER.debug(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  boolean success=preProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  if (!success) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  chain.doFilter(request,response);
  LOGGER.debug(""String_Node_Str"");
  success=postProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  LOGGER.debug(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  if (ConnectionControlService.incrementConcurrentQCountAndCheckIfExceedMax()) {
    ConnectionControlService.decrementAndGetCurrentQueryCount();
    writeError509Response(response);
    return;
  }
  boolean success=preProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  if (!success) {
    LOGGER.error(""String_Node_Str"");
    ConnectionControlService.decrementAndGetCurrentQueryCount();
    return;
  }
  try {
    chain.doFilter(request,response);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
  }
  LOGGER.debug(""String_Node_Str"");
  success=postProcess(request,response);
  LOGGER.debug(""String_Node_Str"",success);
  ConnectionControlService.decrementAndGetCurrentQueryCount();
}",0.6695544554455446
37440,"/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
  responseEntity=RestResponseUtil.createResponse500();
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}","/** 
 * handle exception.
 */
@Override protected ModelAndView doResolveException(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex){
  ResponseEntity<ErrorMessage> responseEntity=null;
  LOGGER.error(""String_Node_Str"",ex);
  if (ex instanceof InvalidMediaTypeException) {
    responseEntity=RestResponseUtil.createResponse415();
  }
  responseEntity=RestResponseUtil.createResponse500();
  try {
    FilterHelper.writeResponse(responseEntity,response);
  }
 catch (  IOException e) {
    LOGGER.error(e.getMessage());
  }
  return new ModelAndView();
}",0.4911971830985915
37441,"@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  ConnectionControlService.decrementAndGetCurrentQueryCount();
  return true;
}","@Override public boolean postProcess(HttpServletRequest request,HttpServletResponse response) throws Exception {
  return true;
}",0.8037383177570093
37442,"/** 
 * increment concurrent query count, and check if exceed max count.MUST call decrementAndGetCurrentQueryCount after query.
 * @return true if exceed, false if not.
 */
public static boolean incrementConcurrentQCountAndCheckIfExceedMax(){
  int count=CONCURRENT_Q_COUNT.getAndIncrement();
  LOGGER.debug(""String_Node_Str"",count);
  if (count >= RdapProperties.getMaxConcurrentCount() - 1) {
    LOGGER.debug(""String_Node_Str"",RdapProperties.getMaxConcurrentCount());
    return true;
  }
  return false;
}","/** 
 * increment concurrent query count, and check if exceed max count.MUST call decrementAndGetCurrentQueryCount after query.
 * @return true if exceed, false if not.
 */
public static boolean incrementConcurrentQCountAndCheckIfExceedMax(){
  int count=CONCURRENT_Q_COUNT.getAndIncrement();
  LOGGER.debug(""String_Node_Str"",count);
  if (count > RdapProperties.getMaxConcurrentCount() - 1) {
    LOGGER.debug(""String_Node_Str"",RdapProperties.getMaxConcurrentCount());
    return true;
  }
  return false;
}",0.9990167158308751
37443,"/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 != StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  return false;
}","/** 
 * validate domain search string represent a valid IDNA domain.
 * @param searchString domain or name server string.
 * @return true if is valid IDNA2008 domain, false if not.
 */
public static boolean validateSearchStringIsValidIdna(String searchString){
  if (StringUtils.isBlank(searchString)) {
    return false;
  }
  if (searchString.contains(BLANK_IN_DOMAIN)) {
    return false;
  }
  if (1 < StringUtils.countMatches(searchString,StringUtil.ASTERISK)) {
    return false;
  }
  String domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,StringUtil.TLD_SPLITOR);
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(StringUtil.ASTERISK,""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  domainName=searchString.replace(""String_Node_Str"",""String_Node_Str"");
  if (validateDomainNameIsValidIdna(domainName)) {
    return true;
  }
  return false;
}",0.9986382206082616
37444,"/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    policyControlService.applyPolicy(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (!StringUtil.checkIsValidSearchPattern(decodeDomain)) {
    return RestResponseUtil.createResponse422();
  }
  if (!DomainUtil.validateSearchStringIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    policyControlService.applyPolicy(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9980753368160572
37445,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    policyControlService.applyPolicy(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  final String strIp=""String_Node_Str"";
  final String strName=""String_Node_Str"";
  NameserverQueryParam nsQueryParam=null;
  final String[] strParamOrg={strIp,strName};
  String nameParam=queryParser.getFirstParameter(request,strParamOrg);
  if (StringUtils.isBlank(nameParam)) {
    return RestResponseUtil.createResponse400();
  }
  if (0 == nameParam.compareTo(strIp)) {
    name=queryParser.getParameter(request,strIp);
    if (StringUtils.isBlank(name) || !IpUtil.isIpV4StrWholeValid(name) && !IpUtil.isIpV6StrValid(name)) {
      return RestResponseUtil.createResponse400();
    }
    name=StringUtils.lowerCase(name);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(name,name);
    nsQueryParam.setIsSearchByIp(true);
  }
 else   if (0 == nameParam.compareTo(strName)) {
    name=queryParser.getParameter(request,strName);
    String decodeNameserver=name;
    try {
      decodeNameserver=DomainUtil.iso8859Decode(name);
      decodeNameserver=DomainUtil.decodeAndReplaceAsciiToLowercase(decodeNameserver);
    }
 catch (    Exception e) {
      return RestResponseUtil.createResponse400();
    }
    if (StringUtils.isBlank(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=StringUtil.getNormalization(decodeNameserver);
    if (!StringUtil.checkIsValidSearchPattern(decodeNameserver)) {
      return RestResponseUtil.createResponse422();
    }
    if (!DomainUtil.validateSearchStringIsValidIdna(decodeNameserver)) {
      return RestResponseUtil.createResponse400();
    }
    decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
    decodeNameserver=StringUtils.lowerCase(decodeNameserver);
    nsQueryParam=(NameserverQueryParam)queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver);
    nsQueryParam.setIsSearchByIp(false);
  }
 else {
    return RestResponseUtil.createResponse400();
  }
  NameserverSearch nsSearch=searchService.searchNameserver(nsQueryParam);
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    policyControlService.applyPolicy(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.99880810488677
37446,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.9972386587771204
37447,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9972122660294704
37448,"/** 
 * validate search domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateSearchStringIsValidIdna(String domainName){
  String decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
  return DomainUtil.validateSearchStringIsValidIdna(decodeDomain);
}","/** 
 * validate search domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateSearchStringIsValidIdna(String domainName){
  String decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
  return DomainUtil.validateSearchStringIsValidIdna(decodeDomain);
}",0.9886547811993516
37449,"/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrimDecodedStr(){
  String result=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
}","/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrimDecodedStr(){
  String result=DomainUtil.decodeAndReplaceAsciiToLowercase(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
}",0.983132530120482
37450,"/** 
 * validate domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateDomainNameIsValidIdna(String domainName){
  String decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
  return DomainUtil.validateDomainNameIsValidIdna(decodeDomain);
}","/** 
 * validate domain.
 * @param domainName domain name.
 * @return boolean.
 */
private boolean validateDomainNameIsValidIdna(String domainName){
  String decodeDomain=DomainUtil.decodeAndReplaceAsciiToLowercase(domainName);
  return DomainUtil.validateDomainNameIsValidIdna(decodeDomain);
}",0.9882352941176472
37451,"/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrim(){
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
}","/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrim(){
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndReplaceAsciiToLowercase(""String_Node_Str""));
}",0.9707112970711296
37452,"/** 
 * constructor.
 * @param q for query string.
 * @param punyName nameserver puny name.
 */
public NameserverQueryParam(String q,String punyName){
  super(q);
  this.punyName=punyName;
}","/** 
 * constructor.
 * @param q for query string.
 * @param punyName nameserver puny name.
 */
public NameserverQueryParam(String q,String punyName){
  super(q,punyName);
}",0.9421487603305784
37453,"/** 
 * query ip by mask.
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask){
  ResponseEntity res=queryIpAddress(ipAddr,mask);
  return res;
}","/** 
 * query ip by mask.
 * @param ipAddr the query ip
 * @param mask the ip mask
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIpWithMask(@PathVariable String ipAddr,@PathVariable String mask){
  return queryIpAddress(ipAddr,mask,ipAddr + ""String_Node_Str"" + mask);
}",0.9028871391076116
37454,"/** 
 * query ip by address.
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr){
  ResponseEntity res=queryIpAddress(ipAddr,""String_Node_Str"");
  return res;
}","/** 
 * query ip by address.
 * @param ipAddr the query ip
 * @return ResponseEntity
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryIp(@PathVariable String ipAddr){
  return queryIpAddress(ipAddr,""String_Node_Str"",ipAddr);
}",0.9215358931552587
37455,"/** 
 * invoked by upper functions.
 * @param ipAddr the query ip
 * @param ipMask the ip mask,can be 0.
 * @return
 */
public ResponseEntity queryIpAddress(String ipAddr,String ipMask){
  String strIp=ipAddr;
  String strMask=ipMask;
  final long maskHighV6=128;
  final long maskLow=0;
  final long maskHighV4=32;
  long numMask=0;
  if (!StringUtils.isNumeric(ipMask)) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isNotBlank(ipMask)) {
    numMask=StringUtil.parseUnsignedLong(strMask);
  }
  IpVersion ipVersion=IpVersion.V6;
  boolean isV4=IpUtil.isIpV4StrWholeValid(strIp);
  boolean isV6=IpUtil.isIpV6StrValid(strIp);
  if (!isV4 && !isV6) {
    return RestResponseUtil.createResponse400();
  }
  if (isV4) {
    if (numMask > maskHighV4 || numMask < maskLow) {
      return RestResponseUtil.createResponse400();
    }
    ipVersion=IpVersion.V4;
  }
 else   if (isV6) {
    if (numMask > maskHighV6 || numMask < maskLow) {
      return RestResponseUtil.createResponse400();
    }
    ipVersion=IpVersion.V6;
  }
  StringUtils.lowerCase(strIp);
  QueryParam queryParam=queryParser.parseIpQueryParam(strIp,numMask,ipVersion);
  Network ip=queryService.queryIp(queryParam);
  if (null != ip) {
    if (!accessControlManager.hasPermission(ip)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ip);
    return RestResponseUtil.createResponse200(ip);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryIp(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    LOGGER.info(""String_Node_Str"",redirect.getUrl());
    return RestResponseUtil.createResponse301(redirect.getUrl());
  }
  LOGGER.info(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}","/** 
 * invoked by upper functions.
 * @param ipAddr the query ip.
 * @param ipMask the ip mask,can be 0.
 * @param originQueryParam originQueryParam.
 * @return ResponseEntity ResponseEntity.
 */
private ResponseEntity queryIpAddress(String ipAddr,String ipMask,String originQueryParam){
  String strIp=ipAddr;
  String strMask=ipMask;
  final long maskHighV6=128;
  final long maskLow=0;
  final long maskHighV4=32;
  long numMask=0;
  if (!StringUtils.isNumeric(ipMask)) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isNotBlank(ipMask)) {
    numMask=StringUtil.parseUnsignedLong(strMask);
  }
  IpVersion ipVersion=IpVersion.V6;
  boolean isV4=IpUtil.isIpV4StrWholeValid(strIp);
  boolean isV6=IpUtil.isIpV6StrValid(strIp);
  if (!isV4 && !isV6) {
    return RestResponseUtil.createResponse400();
  }
  if (isV4) {
    if (numMask > maskHighV4 || numMask < maskLow) {
      return RestResponseUtil.createResponse400();
    }
    ipVersion=IpVersion.V4;
  }
 else   if (isV6) {
    if (numMask > maskHighV6 || numMask < maskLow) {
      return RestResponseUtil.createResponse400();
    }
    ipVersion=IpVersion.V6;
  }
  StringUtils.lowerCase(strIp);
  QueryParam queryParam=queryParser.parseIpQueryParam(strIp,numMask,ipVersion);
  Network ip=queryService.queryIp(queryParam);
  if (null != ip) {
    if (!accessControlManager.hasPermission(ip)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ip);
    return RestResponseUtil.createResponse200(ip);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryIp(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(originQueryParam,SERVICE_URI_IP_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  LOGGER.info(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}",0.8893539105414596
37456,"/** 
 * query redirect domain or nameserver.
 * @param queryParam queryParam.
 * @return ResponseEntity.
 */
private ResponseEntity queryRedirectDomainOrNs(QueryParam queryParam){
  LOGGER.info(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryDomain(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    LOGGER.info(""String_Node_Str"",redirect.getUrl());
    return RestResponseUtil.createResponse301(redirect.getUrl());
  }
  LOGGER.info(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}","/** 
 * query redirect domain or nameserver.
 * @param queryParam queryParam.
 * @return ResponseEntity.
 */
private ResponseEntity queryRedirectDomainOrNs(QueryParam queryParam,String paramName){
  LOGGER.info(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryDomain(queryParam);
  String servicePartUri=SERVICE_URI_DOMAIN_Q;
  if (queryParam instanceof NameserverQueryParam) {
    servicePartUri=SERVICE_URI_NS_Q;
  }
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(paramName,servicePartUri,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  LOGGER.info(""String_Node_Str"",queryParam);
  return RestResponseUtil.createResponse404();
}",0.6734992679355783
37457,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam);
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  QueryParam queryParam=queryParser.parseNameserverQueryParam(decodeNS,punyNSName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryNsInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,nameserverName);
}",0.9940641076375148
37458,"/** 
 * query autnum.
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.info(""String_Node_Str"" + autnum);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    LOGGER.info(""String_Node_Str"",redirect.getUrl());
    return RestResponseUtil.createResponse301(redirect.getUrl());
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query autnum.
 * @param autnum an AS Plain autonomous system number [RFC5396].
 * @param request HttpServletRequest.
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  LOGGER.info(""String_Node_Str"" + autnum);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  QueryParam queryParam=queryParser.parseQueryParam(autnum);
  Autnum result=queryService.queryAutnum(queryParam);
  if (null != result) {
    if (!accessControlManager.hasPermission(result)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  LOGGER.debug(""String_Node_Str"",queryParam);
  RedirectResponse redirect=redirectService.queryAutnum(queryParam);
  if (null != redirect && StringUtils.isNotBlank(redirect.getUrl())) {
    String redirectUrl=StringUtil.generateEncodedRedirectURL(autnum,SERVICE_URI_AS_Q,redirect.getUrl());
    return RestResponseUtil.createResponse301(redirectUrl);
  }
  return RestResponseUtil.createResponse404();
}",0.9590003904724717
37459,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam);
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  QueryParam queryParam=queryParser.parseDomainQueryParam(decodeDomain,punyDomainName);
  if (queryService.tldInThisRegistry(queryParam)) {
    return queryDomainInThisRegistry(queryParam);
  }
  return queryRedirectDomainOrNs(queryParam,domainName);
}",0.9956122856003192
37460,"/** 
 * write 429 error.
 * @param response response.
 * @throws IOException IOException.
 */
private void writeError429Response(HttpServletResponse response) throws IOException {
  ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse401();
  FilterHelper.writeResponse(responseEntity,response);
}","/** 
 * write 429 error.
 * @param response response.
 * @throws IOException IOException.
 */
private void writeError429Response(HttpServletResponse response) throws IOException {
  ResponseEntity<ErrorMessage> responseEntity=RestResponseUtil.createResponse429();
  FilterHelper.writeResponse(responseEntity,response);
}",0.99375
37461,"/** 
 * test executeSqlScript.
 */
@Test public void testExecuteSqlScript(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitContext initContext=(InitContext)ctx.getBean(""String_Node_Str"");
  JdbcTemplate jdbcTemplate=(JdbcTemplate)ctx.getBean(""String_Node_Str"");
  initContext.executeSqlScript(jdbcTemplate,""String_Node_Str"",""String_Node_Str"",true);
}","/** 
 * test executeSqlScript.
 */
public void testExecuteSqlScript(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitContext initContext=(InitContext)ctx.getBean(""String_Node_Str"");
  JdbcTemplate jdbcTemplate=(JdbcTemplate)ctx.getBean(""String_Node_Str"");
  initContext.executeSqlScript(jdbcTemplate,""String_Node_Str"",""String_Node_Str"",true);
}",0.992248062015504
37462,"@Test public void testMain(){
  Init.main(null);
}","public void testMain(){
  Init.main(null);
}",0.9361702127659576
37463,"/** 
 * test initSchema and initData.
 */
@Test public void testInitSchemaAndData(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
}","/** 
 * test initSchema and initData.
 */
public void testInitSchemaAndData(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
}",0.9888059701492538
37464,"/** 
 * test executeSqlScript.
 */
@Test public void testExecuteSqlScript(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitContext initContext=(InitContext)ctx.getBean(""String_Node_Str"");
  JdbcTemplate jdbcTemplate=(JdbcTemplate)ctx.getBean(""String_Node_Str"");
  initContext.executeSqlScript(jdbcTemplate,""String_Node_Str"",""String_Node_Str"",true);
}","/** 
 * test executeSqlScript.
 */
public void testExecuteSqlScript(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitContext initContext=(InitContext)ctx.getBean(""String_Node_Str"");
  JdbcTemplate jdbcTemplate=(JdbcTemplate)ctx.getBean(""String_Node_Str"");
  initContext.executeSqlScript(jdbcTemplate,""String_Node_Str"",""String_Node_Str"",true);
}",0.992248062015504
37465,"@Test public void testMain(){
  Init.main(null);
}","public void testMain(){
  Init.main(null);
}",0.9361702127659576
37466,"/** 
 * test initSchema and initData.
 */
@Test public void testInitSchemaAndData(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
}","/** 
 * test initSchema and initData.
 */
public void testInitSchemaAndData(){
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
}",0.9888059701492538
37467,"/** 
 * get parameter from request,get first if has more than one param.
 * @param request HttpServletRequest.
 * @param strParamOrg the final String array for url params.
 * @return first right url param.
 */
public String getFirstParameter(HttpServletRequest request,final String[] strParamOrg){
  String strQuery=request.getQueryString();
  int pos=strQuery.indexOf(""String_Node_Str"");
  if (-1 != pos) {
    try {
      strQuery=strQuery.substring(0,pos);
    }
 catch (    Exception e) {
      return null;
    }
  }
  final String strSplit=""String_Node_Str"";
  String[] strParam=strQuery.split(strSplit);
  final String strEqual=""String_Node_Str"";
  for (int k=0; k < strParam.length; ++k) {
    String[] strParamName=strParam[k].split(strEqual);
    if (strParamName != null) {
      for (int j=0; j < strParamOrg.length; ++j) {
        if (strParamName[0].compareTo(strParamOrg[j]) == 0) {
          return strParamName[0];
        }
      }
    }
  }
  return null;
}","/** 
 * get parameter from request,get first if has more than one param.
 * @param request HttpServletRequest.
 * @param strParamOrg the final String array for url params.
 * @return first right url param.
 */
public String getFirstParameter(HttpServletRequest request,final String[] strParamOrg){
  String strQuery=request.getQueryString();
  if (StringUtils.isBlank(strQuery)) {
    return null;
  }
  int pos=strQuery.indexOf(""String_Node_Str"");
  if (-1 != pos) {
    try {
      strQuery=strQuery.substring(0,pos);
    }
 catch (    Exception e) {
      return null;
    }
  }
  final String strSplit=""String_Node_Str"";
  String[] strParam=strQuery.split(strSplit);
  final String strEqual=""String_Node_Str"";
  for (int k=0; k < strParam.length; ++k) {
    String[] strParamName=strParam[k].split(strEqual);
    if (strParamName != null) {
      for (int j=0; j < strParamOrg.length; ++j) {
        if (strParamName[0].compareTo(strParamOrg[j]) == 0) {
          return strParamName[0];
        }
      }
    }
  }
  return null;
}",0.9701789264413518
37468,"/** 
 * query network for arpa.
 * @param outerObjectId object related to network
 * @param outerModelType object type related to network                     
 * @return network list.
 */
@Override public List<Network> queryAsInnerObjects(Long outerObjectId,ModelType outerModelType){
  if (!ModelType.ENTITY.equals(outerModelType)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  List<Network> networks=queryWithoutInnerObjectsForEntity(outerObjectId);
  queryAndSetInnerObjects(networks);
  return networks;
}","/** 
 * query network for arpa.
 * @param outerObjectId object related to network
 * @param outerModelType object type related to network
 * @return network list.
 */
@Override public List<Network> queryAsInnerObjects(Long outerObjectId,ModelType outerModelType){
  if (!ModelType.ENTITY.equals(outerModelType)) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  List<Network> networks=queryWithoutInnerObjectsForEntity(outerObjectId);
  queryAndSetInnerObjects(networks);
  return networks;
}",0.9799809342230696
37469,"/** 
 * set ip version,and start/end address.
 * @param rs ResultSet.
 * @param objIp Ip.
 * @throws SQLException SQLException.
 */
private void setIpVersionAndStartEndAddress(ResultSet rs,Network objIp) throws SQLException {
  String ipVersionStr=rs.getString(""String_Node_Str"");
  String startHighAddress=rs.getString(""String_Node_Str"");
  String startLowAddress=rs.getString(""String_Node_Str"");
  String endHighAddress=rs.getString(""String_Node_Str"");
  String endLowAddress=rs.getString(""String_Node_Str"");
  String startAddress=""String_Node_Str"";
  String endAddress=""String_Node_Str"";
  if (IpVersion.isV6(ipVersionStr)) {
    objIp.setIpVersion(IpVersion.V6);
    startAddress=IpUtil.longToIpV6(StringUtil.parseUnsignedLong(startHighAddress),StringUtil.parseUnsignedLong(startLowAddress));
    endAddress=IpUtil.longToIpV6(StringUtil.parseUnsignedLong(endHighAddress),StringUtil.parseUnsignedLong(endLowAddress));
  }
 else   if (IpVersion.isV4(ipVersionStr)) {
    objIp.setIpVersion(IpVersion.V4);
    startAddress=IpUtil.longToIpV4(StringUtil.parseUnsignedLong(startLowAddress));
    endAddress=IpUtil.longToIpV4(StringUtil.parseUnsignedLong(endLowAddress));
  }
  objIp.setStartAddress(startAddress);
  objIp.setEndAddress(endAddress);
}","/** 
 * set ip version,and start/end address.
 * @param rs ResultSet.
 * @param objIp Ip.
 * @throws SQLException SQLException.
 */
private void setIpVersionAndStartEndAddress(ResultSet rs,Network objIp) throws SQLException {
  String ipVersionStr=rs.getString(""String_Node_Str"");
  String startHighAddress=rs.getString(""String_Node_Str"");
  String startLowAddress=rs.getString(""String_Node_Str"");
  String endHighAddress=rs.getString(""String_Node_Str"");
  String endLowAddress=rs.getString(""String_Node_Str"");
  String startAddress=""String_Node_Str"";
  String endAddress=""String_Node_Str"";
  if (IpVersion.isV6(ipVersionStr)) {
    objIp.setIpVersion(IpVersion.V6);
    long longHighStart=StringUtil.parseUnsignedLong(startHighAddress);
    long longLowStart=StringUtil.parseUnsignedLong(startLowAddress);
    startAddress=IpUtil.longToIpV6(longHighStart,longLowStart);
    long longHighEnd=StringUtil.parseUnsignedLong(endHighAddress);
    long longLowEnd=StringUtil.parseUnsignedLong(endLowAddress);
    endAddress=IpUtil.longToIpV6(longHighEnd,longLowEnd);
  }
 else   if (IpVersion.isV4(ipVersionStr)) {
    objIp.setIpVersion(IpVersion.V4);
    startAddress=IpUtil.longToIpV4(StringUtil.parseUnsignedLong(startLowAddress));
    endAddress=IpUtil.longToIpV4(StringUtil.parseUnsignedLong(endLowAddress));
  }
  objIp.setStartAddress(startAddress);
  objIp.setEndAddress(endAddress);
}",0.8224582701062215
37470,"/** 
 * search entity by handle or name.
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.info(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.info(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search entity by handle or name.
 * @param fn fn.
 * @param handle handle.
 * @param request request.
 * @return ResponseEntity.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity searchEntity(@RequestParam(required=false) String fn,@RequestParam(required=false) String handle,HttpServletRequest request){
  LOGGER.info(""String_Node_Str"",fn,handle);
  final String fnParamName=""String_Node_Str"";
  final String handleParamName=""String_Node_Str"";
  String paramName=queryParser.getFirstParameter(request,new String[]{fnParamName,handleParamName});
  if (StringUtils.isBlank(paramName)) {
    return RestResponseUtil.createResponse400();
  }
  String paramValue=queryParser.getParameter(request,paramName);
  paramValue=DomainUtil.iso8859Decode(paramValue);
  paramValue=StringUtils.trim(paramValue);
  if (!StringUtil.isValidEntityHandleOrName(paramValue)) {
    return RestResponseUtil.createResponse400();
  }
  if (!StringUtil.checkIsValidSearchPattern(paramValue)) {
    return RestResponseUtil.createResponse422();
  }
  QueryParam queryParam=queryParser.parseEntityQueryParam(paramValue,paramName);
  LOGGER.info(""String_Node_Str"",queryParam);
  EntitySearch result=searchService.searchEntity(queryParam);
  if (null != result) {
    if (result.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9831849653808112
37471,"/** 
 * test query exist.
 * @throws Exception Exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExist() throws Exception {
  String entityHandle=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + entityHandle).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(entityHandle)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * test query exist.
 * @throws Exception Exception.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExist() throws Exception {
  String entityHandle=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + entityHandle).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.7753589624826308
37472,"/** 
 * test search nameserver.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testSearchNameserver(){
  String nsName=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  long sizeHigh=3L;
  long sizeLow=2L;
  long sizeLimit=6L;
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeHigh);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeHigh,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLow,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeHigh);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLow,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLimit);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLimit,nsSearch.getNameserverSearchResults().size());
  assertNull(nsSearch.getResultsTruncated());
}","/** 
 * test search nameserver.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchNameserver(){
  String nsName=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  long sizeHigh=3L;
  long sizeLow=2L;
  long sizeLimit=6L;
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeHigh);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeHigh,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLow,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeHigh);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLow,nsSearch.getNameserverSearchResults().size());
  assertTrue(nsSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLimit);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",sizeLow);
  nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(nsName,nsName));
  assertNotNull(nsSearch);
  assertNotNull(nsSearch.getNameserverSearchResults());
  assertEquals(sizeLimit,nsSearch.getNameserverSearchResults().size());
  assertNull(nsSearch.getResultsTruncated());
}",0.9908754623921086
37473,"/** 
 * test search domain.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryDomain(){
  String domainName=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3L);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",6L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",6L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(6L,domainSearch.getDomainSearchResults().size());
  assertNull(domainSearch.getResultsTruncated());
}","/** 
 * test search domain.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryDomain(){
  String domainName=""String_Node_Str"";
  RdapProperties prop=new RdapProperties();
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3L);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",5L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",6L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(5L,domainSearch.getDomainSearchResults().size());
  assertTrue(domainSearch.getResultsTruncated());
  ReflectionTestUtils.setField(prop,""String_Node_Str"",6L);
  ReflectionTestUtils.setField(prop,""String_Node_Str"",3L);
  domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domainSearch);
  assertNotNull(domainSearch.getDomainSearchResults());
  assertEquals(6L,domainSearch.getDomainSearchResults().size());
  assertNull(domainSearch.getResultsTruncated());
}",0.9904614591389532
37474,"/** 
 * add addresses to vcard.
 * @param vcard vcard.
 * @param entity entity.
 */
private static void addAddressToVcard(VCard vcard,Entity entity){
  List<EntityAddress> addressList=entity.getAddresses();
  if (null == addressList) {
    return;
  }
  for (  EntityAddress entityAddress : addressList) {
    Address address=new Address();
    address.setPoBox(entityAddress.getPoBox());
    address.setExtendedAddress(entityAddress.getExtendedAddress());
    address.setStreetAddress(entityAddress.getStreetAddress());
    address.setLocality(entityAddress.getLocality());
    address.setRegion(entityAddress.getRegion());
    address.setPostalCode(entityAddress.getPostalCode());
    address.setCountry(entityAddress.getCountry());
    addAddressTypes(entityAddress.getTypes(),address);
    vcard.addAddress(address);
  }
}","/** 
 * add addresses to vcard.
 * @param vcard vcard.
 * @param entity entity.
 */
private static void addAddressToVcard(VCard vcard,Entity entity){
  List<EntityAddress> addressList=entity.getAddresses();
  if (null == addressList) {
    return;
  }
  for (  EntityAddress entityAddress : addressList) {
    Address address=new Address();
    address.setPoBox(entityAddress.getPoBox());
    address.setExtendedAddress(entityAddress.getExtendedAddress());
    address.setStreetAddress(entityAddress.getStreetAddress());
    address.setLocality(entityAddress.getLocality());
    address.setRegion(entityAddress.getRegion());
    address.setPostalCode(entityAddress.getPostalCode());
    address.setCountry(entityAddress.getCountry());
    addAddressTypes(entityAddress.getTypes(),address);
    setAddressPref(entityAddress,address);
    vcard.addAddress(address);
  }
}",0.9746312684365782
37475,"/** 
 * main method.
 * @param args
 */
public static void main(String[] args){
  LOGGER.info(""String_Node_Str"");
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
  LOGGER.info(""String_Node_Str"");
}","/** 
 * main method.
 * @param args args.
 */
public static void main(String[] args){
  LOGGER.info(""String_Node_Str"");
  ApplicationContext ctx=new ClassPathXmlApplicationContext(""String_Node_Str"");
  InitDao initDao=(InitDao)ctx.getBean(""String_Node_Str"");
  initDao.initSchema();
  initDao.initData();
  LOGGER.info(""String_Node_Str"");
}",0.9910979228486648
37476,"/** 
 * Execute the given SQL script. <p> The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p> <b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from
 * @param continueOnError whether or not to continue without throwing an exception in the event of an error
 * @throws DataAccessException if there is an error executing a statement and {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 */
private static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,String databaseName,boolean continueOnError) throws DataAccessException {
  long startTime=System.currentTimeMillis();
  List<String> statements=new LinkedList<String>();
  LineNumberReader reader=null;
  try {
    reader=new LineNumberReader(resource.getReader());
    String script=readScript(reader);
    char delimiter=DEFAULT_STATEMENT_SEPARATOR;
    if (!containsSqlScriptDelimiters(script,delimiter)) {
      delimiter='\n';
    }
    splitSqlScript(script,delimiter,statements);
    int lineNumber=0;
    for (    String statement : statements) {
      lineNumber++;
      try {
        jdbcTemplate.update(""String_Node_Str"" + databaseName + ""String_Node_Str"");
      }
 catch (      DataAccessException ex) {
        LOGGER.debug(""String_Node_Str"");
      }
      try {
        int rowsAffected=jdbcTemplate.update(statement);
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug(rowsAffected + ""String_Node_Str"" + statement);
        }
      }
 catch (      DataAccessException ex) {
        if (continueOnError) {
          if (LOGGER.isWarnEnabled()) {
            LOGGER.warn(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ resource+ ""String_Node_Str""+ statement,ex);
          }
        }
 else {
          throw ex;
        }
      }
    }
    long elapsedTime=System.currentTimeMillis() - startTime;
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(String.format(""String_Node_Str"",resource,elapsedTime));
    }
  }
 catch (  IOException ex) {
    throw new DataAccessResourceFailureException(""String_Node_Str"" + resource,ex);
  }
 finally {
    try {
      if (reader != null) {
        reader.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}","/** 
 * Execute the given SQL script. <p> The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p> <b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from
 * @param continueOnError whether or not to continue without throwing an exception in the event of an error
 * @throws DataAccessException if there is an error executing a statement and {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 */
private static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,String databaseName,boolean continueOnError) throws DataAccessException {
  long startTime=System.currentTimeMillis();
  List<String> statements=new LinkedList<String>();
  LineNumberReader reader=null;
  try {
    reader=new LineNumberReader(resource.getReader());
    String script=readScript(reader);
    char delimiter=DEFAULT_STATEMENT_SEPARATOR;
    if (!containsSqlScriptDelimiters(script,delimiter)) {
      delimiter='\n';
    }
    splitSqlScript(script,delimiter,statements);
    int lineNumber=0;
    for (    String statement : statements) {
      lineNumber++;
      try {
        jdbcTemplate.update(""String_Node_Str"" + databaseName + ""String_Node_Str"");
      }
 catch (      DataAccessException ex) {
        LOGGER.error(""String_Node_Str"",databaseName,ex.getMessage());
      }
      try {
        int rowsAffected=jdbcTemplate.update(statement);
        LOGGER.info(rowsAffected + ""String_Node_Str"" + statement);
      }
 catch (      DataAccessException ex) {
        if (continueOnError) {
          LOGGER.error(""String_Node_Str"" + lineNumber + ""String_Node_Str""+ resource+ ""String_Node_Str""+ statement,ex);
        }
 else {
          throw ex;
        }
      }
    }
    long elapsedTime=System.currentTimeMillis() - startTime;
    LOGGER.info(String.format(""String_Node_Str"",resource,elapsedTime));
  }
 catch (  IOException ex) {
    throw new DataAccessResourceFailureException(""String_Node_Str"" + resource,ex);
  }
 finally {
    try {
      if (reader != null) {
        reader.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}",0.8187422934648582
37477,"/** 
 * initData.
 */
public void initData(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + SQL_RESOURCE_DATA_PATH);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_DATA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}","/** 
 * initData.
 */
public void initData(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",SQL_RESOURCE_DATA_PATH,databaseName);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_DATA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}",0.9682242990654204
37478,"public void setDatabaseName(String databaseName){
  this.databaseName=databaseName;
}","/** 
 * set databaseName.
 * @param databaseName databaseName.
 */
public void setDatabaseName(String databaseName){
  this.databaseName=databaseName;
}",0.7172995780590717
37479,"/** 
 * initSchema.
 */
public void initSchema(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + SQL_RESOURCE_SCHEMA_PATH);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_SCHEMA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}","/** 
 * init schema.
 */
public void initSchema(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",SQL_RESOURCE_SCHEMA_PATH,databaseName);
  initContext.executeSqlScript(jdbcTemplate,SQL_RESOURCE_SCHEMA_PATH,databaseName,false);
  LOGGER.info(""String_Node_Str"");
}",0.9637681159420288
37480,"public void setInitContext(InitContext initContext){
  this.initContext=initContext;
}","/** 
 * set initContext.
 * @param initContext initContext.
 */
public void setInitContext(InitContext initContext){
  this.initContext=initContext;
}",0.7288135593220338
37481,"public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
  this.jdbcTemplate=jdbcTemplate;
}","/** 
 * set jdbcTemplate.
 * @param jdbcTemplate jdbcTemplate
 */
public void setJdbcTemplate(JdbcTemplate jdbcTemplate){
  this.jdbcTemplate=jdbcTemplate;
}",0.7338709677419355
37482,"/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setStartAddressForIp6(byte[] sections){
  byte[] byteStart={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  System.arraycopy(sections,0,byteStart,0,sections.length);
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  System.arraycopy(byteStart,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=highSecs[i << 1] << HIGH_BYTE + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.startHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteStart,lowSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.startLowAddress=new BigInteger(1,lowBytes);
}","/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setStartAddressForIp6(byte[] sections){
  byte[] byteStart={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  System.arraycopy(sections,0,byteStart,0,sections.length);
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  System.arraycopy(byteStart,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=(highSecs[i << 1] << HIGH_BYTE) + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.startHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteStart,lowSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.startLowAddress=new BigInteger(1,lowBytes);
}",0.9990680335507922
37483,"/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setEndAddressForIp6(byte[] sections){
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] byteEnd={MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F};
  System.arraycopy(sections,0,byteEnd,0,sections.length);
  System.arraycopy(byteEnd,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=highSecs[i << 1] << HIGH_BYTE + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.endHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteEnd,highSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.endLowAddress=new BigInteger(1,lowBytes);
}","/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setEndAddressForIp6(byte[] sections){
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] byteEnd={MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F};
  System.arraycopy(sections,0,byteEnd,0,sections.length);
  System.arraycopy(byteEnd,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=(highSecs[i << 1] << HIGH_BYTE) + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.endHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteEnd,highSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.endLowAddress=new BigInteger(1,lowBytes);
}",0.9992012779552716
37484,"/** 
 * query and set roles.
 * @param models model list.
 */
private void queryAndSetRoles(List<Entity> models){
  List<Long> entityIds=getModelIds(models);
  List<ModelStatus> statusList=queryStatus(entityIds);
  for (  ModelStatus status : statusList) {
    BaseModel obj=BaseModel.findObjectFromListById(models,status.getId());
    if (null == obj) {
      continue;
    }
    Entity entity=(Entity)obj;
    entity.addStatus(status.getStatus());
  }
}","/** 
 * query and set roles.
 * @param models model list.
 */
private void queryAndSetRoles(List<Entity> models){
  List<Long> entityIds=getModelIds(models);
  List<EntityRole> roleList=queryRoles(entityIds);
  for (  EntityRole role : roleList) {
    BaseModel obj=BaseModel.findObjectFromListById(models,role.getId());
    if (null == obj) {
      continue;
    }
    Entity entity=(Entity)obj;
    entity.addRole(role.getRole());
  }
}",0.8600223964165733
37485,"@Override public Nameserver query(QueryParam queryParam){
  Nameserver nameserver=queryWithoutInnerObjects(queryParam);
  queryAndSetInnerObjectsWithoutNotice(nameserver);
  queryAndSetInnerNotice(nameserver);
  return nameserver;
}","@Override public Nameserver query(QueryParam queryParam){
  Nameserver nameserver=queryWithoutInnerObjects(queryParam);
  queryAndSetInnerObjects(nameserver);
  queryAndSetEntities(nameserver);
  return nameserver;
}",0.9285714285714286
37486,"@Override public List<Nameserver> search(QueryParam queryParam){
  List<Nameserver> listNS=searchWithoutInnerObjects(queryParam);
  queryAndSetNameserverStatus(listNS);
  queryAndSetInnerObjectsWithoutNotice(listNS);
  return listNS;
}","@Override public List<Nameserver> search(QueryParam queryParam){
  List<Nameserver> nameservers=searchWithoutInnerObjects(queryParam);
  queryAndSetNameserverStatus(nameservers);
  queryAndSetInnerObjects(nameservers);
  queryAndSetEntities(nameservers);
  return nameservers;
}",0.7212475633528265
37487,"/** 
 * query inner objects of nameserver,and set object value to them.
 * @param ns nameserver which inner objects value will be filled.
 */
private void queryAndSetInnerObjects(Nameserver ns){
  if (null == ns) {
    return;
  }
  Long nsID=ns.getId();
  List<IPAddress> listIPAddress=ipAddressQueryDao.queryAsInnerObjects(nsID,ModelType.NAMESERVER);
  if (listIPAddress.size() > 0) {
    IPAddress objIPAddress=listIPAddress.get(0);
    ns.setIpAddresses(objIPAddress);
  }
  List<Remark> remarks=remarkQueryDao.queryAsInnerObjects(nsID,ModelType.NAMESERVER);
  ns.setRemarks(remarks);
  List<Link> links=linkQueryDao.queryAsInnerObjects(nsID,ModelType.NAMESERVER);
  ns.setLinks(links);
  List<Event> events=eventQueryDao.queryAsInnerObjects(nsID,ModelType.NAMESERVER);
  ns.setEvents(events);
  List<Entity> entities=entityQueryDao.queryAsInnerObjects(nsID,ModelType.NAMESERVER);
  ns.setEntities(entities);
}","/** 
 * query inner objects of nameserver,and set fill them to nameserver.
 * @param nameservers nameservers list.
 */
private void queryAndSetInnerObjects(List<Nameserver> nameservers){
  if (null == nameservers) {
    return;
  }
  for (  Nameserver nameserver : nameservers) {
    queryAndSetInnerObjects(nameserver);
  }
}",0.3112903225806451
37488,"/** 
 * get parameter from request,get first if has more than one value.
 * @param request request.
 * @param name parameter name.
 * @return parameter value.
 */
public String getParameter(HttpServletRequest request,String name){
  String[] values=request.getParameterValues(name);
  if (null == values || values.length < 1) {
    return null;
  }
  String strQuery=values[0];
  int pos=strQuery.indexOf(""String_Node_Str"");
  if (-1 != pos) {
    try {
      strQuery=strQuery.substring(0,pos);
    }
 catch (    Exception e) {
      return null;
    }
  }
  return strQuery;
}","/** 
 * get parameter from request,get first if has more than one value.
 * @param request request.
 * @param name parameter name.
 * @return parameter value.
 */
public String getParameter(HttpServletRequest request,String name){
  String[] values=request.getParameterValues(name);
  if (null == values || values.length < 1) {
    return null;
  }
  return values[0];
}",0.7658227848101266
37489,"/** 
 * query networks for arpa ,then fill them to domain.
 * @param domain networks will be filled.
 */
private void queryAndSetInnerNetwork(Domain domain){
  if (null == domain) {
    return;
  }
  ModelType type=domain.getDomainType();
  if (ModelType.ARPA == type && StringUtils.isNotEmpty(domain.getLdhName())) {
    final Arpa arpa=Arpa.decodeArpa(domain.getLdhName());
    Network network=networkQueryDao.query(arpa.toNetworkQueryParam());
    domain.setNetwork(network);
  }
}","/** 
 * query networks for arpa ,then fill them to domain.
 * @param domain networks will be filled.
 */
private void queryAndSetInnerNetwork(Domain domain){
  if (null == domain) {
    return;
  }
  ModelType type=domain.getDomainType();
  if (ModelType.ARPA == type && StringUtils.isNotEmpty(domain.getLdhName())) {
    List<Network> networks=networkQueryDao.queryAsInnerObjects(domain.getId(),ModelType.ARPA);
    if (null != networks && networks.size() > 0) {
      Network network=networks.get(0);
      domain.setNetwork(network);
    }
  }
}",0.6550387596899225
37490,"/** 
 * search entity, without inner objects.
 * @param params query parameter.
 * @return entity list.
 */
private List<Entity> searchWithoutInnerObjects(final QueryParam params){
  EntityQueryParam entityQueryParam=(EntityQueryParam)params;
  final String q=entityQueryParam.getQ();
  final String paramName=entityQueryParam.getSearchParamName();
  final String qLikeClause=super.generateLikeClause(q);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + paramName + ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=params.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  List<Entity> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,qLikeClause);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,new EntityWithRoleResultSetExtractor());
  return result;
}","/** 
 * search entity, without inner objects.
 * @param params query parameter.
 * @return entity list.
 */
private List<Entity> searchWithoutInnerObjects(final QueryParam params){
  EntityQueryParam entityQueryParam=(EntityQueryParam)params;
  final String q=entityQueryParam.getQ();
  final String paramName=entityQueryParam.getSearchParamName();
  final String qLikeClause=super.generateLikeClause(q);
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + paramName + ""String_Node_Str""+ ""String_Node_Str"";
  final PageBean page=params.getPageBean();
  int startPage=page.getCurrentPage() - 1;
  startPage=startPage >= 0 ? startPage : 0;
  final long startRow=startPage * page.getMaxRecords();
  List<Entity> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,qLikeClause);
      ps.setLong(2,startRow);
      ps.setLong(3,page.getMaxRecords());
      return ps;
    }
  }
,new EntityResultSetExtractor());
  return result;
}",0.9796800691742326
37491,"@Override public List<Entity> search(QueryParam queryParam){
  List<Entity> entities=searchWithoutInnerObjects(queryParam);
  queryAndSetInnerObjectsWithoutEntities(entities);
  queryAndSetNetworksAndAs(entities);
  queryAndSetInnerEntities(entities);
  return entities;
}","@Override public List<Entity> search(QueryParam queryParam){
  List<Entity> entities=searchWithoutInnerObjects(queryParam);
  queryAndSetInnerObjectsWithoutEntities(entities);
  queryAndSetRoles(entities);
  queryAndSetNetworksAndAs(entities);
  queryAndSetInnerEntities(entities);
  return entities;
}",0.9477351916376306
37492,"@Override public ModelStatus mapRow(ResultSet rs,int rowNum) throws SQLException {
  return new ModelStatus(rs.getLong(""String_Node_Str""),rs.getString(""String_Node_Str""));
}","@Override public EntityRole mapRow(ResultSet rs,int rowNum) throws SQLException {
  return new EntityRole(rs.getLong(""String_Node_Str""),rs.getString(""String_Node_Str""));
}",0.9011627906976744
37493,"@Override public List<Network> extractData(ResultSet rs) throws SQLException {
  List<Network> result=new ArrayList<Network>();
  while (rs.next()) {
    Long networkId=rs.getLong(""String_Node_Str"");
    Network network=new Network();
    network.setId(networkId);
    network.setHandle(rs.getString(""String_Node_Str""));
    setIpVersionAndStartEndAddress(rs,network);
    network.setName(rs.getString(""String_Node_Str""));
    network.setType(rs.getString(""String_Node_Str""));
    network.setCountry(rs.getString(""String_Node_Str""));
    network.setParentHandle(rs.getString(""String_Node_Str""));
    network.setLang(rs.getString(""String_Node_Str""));
    network.setPort43(rs.getString(""String_Node_Str""));
    result.add(network);
  }
  return result;
}","@Override public List<Network> extractData(ResultSet rs) throws SQLException {
  List<Network> result=new ArrayList<Network>();
  while (rs.next()) {
    Long networkId=rs.getLong(""String_Node_Str"");
    Network network=extractNetworkFromRs(rs,networkId);
    result.add(network);
  }
  return result;
}",0.4867424242424242
37494,"/** 
 * query network, without inner objects.Only support ENTITY!
 * @param outerObjectId entityId.
 * @return network.
 */
private List<Network> queryWithoutInnerObjectsForEntity(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<Network> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      ps.setString(2,ModelType.IP.getName());
      return ps;
    }
  }
,new NetworkResultSetExtractor());
  return result;
}","/** 
 * query network, without inner objects.Only support ENTITY!
 * @param outerObjectId entityId.
 * @return network.
 */
private List<Network> queryWithoutInnerObjectsForEntity(final Long outerObjectId){
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<Network> result=jdbcTemplate.query(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,outerObjectId);
      ps.setString(2,ModelType.IP.getName());
      return ps;
    }
  }
,new NetworkWithStatusResultSetExtractor());
  return result;
}",0.9936948297604036
37495,"/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setStartAddressForIp6(byte[] sections){
  byte[] byteStart={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  System.arraycopy(sections,0,byteStart,0,sections.length);
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  System.arraycopy(byteStart,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=highSecs[i << 1] << HIGH_BYTE + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.startHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteStart,lowSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.startLowAddress=new BigInteger(1,lowBytes);
}","/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setStartAddressForIp6(byte[] sections){
  byte[] byteStart={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  System.arraycopy(sections,0,byteStart,0,sections.length);
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  System.arraycopy(byteStart,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=(highSecs[i << 1] << HIGH_BYTE) + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.startHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteStart,lowSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.startLowAddress=new BigInteger(1,lowBytes);
}",0.9990680335507922
37496,"/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setEndAddressForIp6(byte[] sections){
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] byteEnd={MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F};
  System.arraycopy(sections,0,byteEnd,0,sections.length);
  System.arraycopy(byteEnd,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=highSecs[i << 1] << HIGH_BYTE + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.endHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteEnd,highSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.endLowAddress=new BigInteger(1,lowBytes);
}","/** 
 * decode a byte array from in-addr.arpa to an Arpa.
 * @param sections a byte array from an arpa string.
 */
private void setEndAddressForIp6(byte[] sections){
  byte[] highSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] lowSecs=new byte[LENGTH_OF_V6_SECTIONS / 2];
  byte[] highBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] lowBytes=new byte[LENGTH_OF_V6_BYTES / 2];
  byte[] byteEnd={MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F,MASK_0F};
  System.arraycopy(sections,0,byteEnd,0,sections.length);
  System.arraycopy(byteEnd,0,highSecs,0,highSecs.length);
  for (int i=0; i < highBytes.length; i++) {
    int hb=(highSecs[i << 1] << HIGH_BYTE) + highSecs[(i << 1) + 1];
    highBytes[i]=(byte)(MASK_FF & hb);
  }
  this.endHighAddress=new BigInteger(1,highBytes);
  System.arraycopy(byteEnd,highSecs.length,lowSecs,0,lowSecs.length);
  for (int i=0; i < lowBytes.length; i++) {
    int lb=(lowSecs[i << 1] << HIGH_BYTE) + lowSecs[(i << 1) + 1];
    lowBytes[i]=(byte)(MASK_FF & lb);
  }
  this.endLowAddress=new BigInteger(1,lowBytes);
}",0.9992012779552716
37497,"/** 
 * test findObjectFromListById.
 */
@Test public void testArpa(){
  Arpa arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
}","/** 
 * test findObjectFromListById.
 */
@Test public void testArpa(){
  Arpa arpa=null;
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  arpa=Arpa.decodeArpa(""String_Node_Str"");
  assertNotNull(arpa);
  assertEquals(arpa.getIpVersion().getName(),""String_Node_Str"");
  assertEquals(arpa.getStartLowAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getStartHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndHighAddress().toString(),""String_Node_Str"");
  assertEquals(arpa.getEndLowAddress().toString(),""String_Node_Str"");
}",0.9962888952326576
37498,"/** 
 * test query exist domain.
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryArpa(){
  String domainName=""String_Node_Str"";
  Domain domain=domainQueryDao.query(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domain);
}","/** 
 * test query exist domain.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryArpa(){
  String domainName=""String_Node_Str"";
  Domain domain=domainQueryDao.query(queryParser.parseDomainQueryParam(domainName,domainName));
  assertNotNull(domain);
}",0.935201401050788
37499,"@SuppressWarnings(""String_Node_Str"") @Override public Autnum query(QueryParam queryParam){
  Autnum autnum=queryWithoutInnerObjects(queryParam);
  queryAndSetInnerObjects(autnum);
  List<Entity> entities=entityQueryDao.queryAsInnerObjects(autnum.getId(),ModelType.AUTNUM);
  autnum.setEntities(entities);
  return autnum;
}","@SuppressWarnings(""String_Node_Str"") @Override public Autnum query(QueryParam queryParam){
  Autnum autnum=queryWithoutInnerObjects(queryParam);
  queryAndSetInnerObjects(autnum);
  queryAndSetEntities(autnum);
  return autnum;
}",0.7536231884057971
37500,"/** 
 * parseQueryIpV4Mask. use the numMask bits to get a ip range.
 * @param strQuery query ip v4 string.
 */
private void parseQueryIpV4Mask(String strQuery){
  final long numBase=2;
  final long numBytes=32;
  BigDecimal[] ipV4=IpUtil.ipV4ToDecimal(strQuery);
  long maskRangeBytes=numBytes - numMask;
  if (maskRangeBytes > 0 && maskRangeBytes <= numBytes) {
    final long maskV4High=(long)(Math.pow(numBase,maskRangeBytes) - 1L);
    final long maskV4Low=(long)Math.pow(numBase,numBytes) - maskV4High - 1L;
    long[] longIpV4=IpUtil.ipToLong(strQuery);
    long ipStart=longIpV4[1] & maskV4Low;
    long ipEnd=longIpV4[1] | maskV4High;
    ipQueryEndLow=BigDecimal.valueOf(ipEnd);
    ipQueryStartLow=BigDecimal.valueOf(ipStart);
  }
 else {
    ipQueryEndLow=ipV4[1];
    ipQueryStartLow=ipV4[1];
  }
}","/** 
 * parseQueryIpV4Mask. use the numMask bits to get a ip range.
 * @param strQuery query ip v4 string.
 */
private void parseQueryIpV4Mask(String strQuery){
  final long numBase=2;
  final long numBytes=32;
  BigDecimal[] ipV4=IpUtil.ipV4ToDecimal(strQuery);
  long maskRangeBytes=0;
  if (numMask > 0) {
    maskRangeBytes=numBytes - numMask;
  }
  if (maskRangeBytes > 0 && maskRangeBytes <= numBytes) {
    final long maskV4High=(long)(Math.pow(numBase,maskRangeBytes) - 1L);
    final long maskV4Low=(long)Math.pow(numBase,numBytes) - maskV4High - 1L;
    long[] longIpV4=IpUtil.ipToLong(strQuery);
    long ipStart=longIpV4[1] & maskV4Low;
    long ipEnd=longIpV4[1] | maskV4High;
    ipQueryEndLow=BigDecimal.valueOf(ipEnd);
    ipQueryStartLow=BigDecimal.valueOf(ipStart);
  }
 else {
    ipQueryEndLow=ipV4[1];
    ipQueryStartLow=ipV4[1];
  }
}",0.9718056388722256
37501,"/** 
 * parseQueryIpV6Mask.
 * @param strQuery for ip string v6
 * @param ipV6 for ip BigDecimal style
 */
private void parseQueryIpV6Mask(String strQuery,BigDecimal[] ipV6){
  final int lowLimitShift=64;
  int lowShift=lowLimitShift * 2 - (int)numMask;
  BigDecimal powDecimalBase=BigDecimal.valueOf(2L);
  BigDecimal endSubDecimalBase=BigDecimal.valueOf(1L);
  ipQueryStartHigh=ipV6[0];
  ipQueryEndHigh=ipV6[0];
  if (numMask > lowLimitShift) {
    int highShift=(int)numMask - lowLimitShift;
    BigDecimal powDecimalhigh=powDecimalBase.pow(highShift);
    BigDecimal modDecimalHigh=ipV6[0].remainder(powDecimalhigh);
    ipQueryStartHigh=ipV6[0].subtract(modDecimalHigh);
    lowShift=lowLimitShift;
    BigDecimal highEndPlusDecimal=powDecimalhigh.subtract(endSubDecimalBase);
    ipQueryEndHigh=ipQueryStartHigh.add(highEndPlusDecimal);
  }
  BigDecimal powDecimalLow=powDecimalBase.pow(lowShift);
  BigDecimal modDecimalLow=ipV6[1].remainder(powDecimalLow);
  ipQueryStartLow=ipV6[1].subtract(modDecimalLow);
  BigDecimal lowEndPlusDecimal=powDecimalLow.subtract(endSubDecimalBase);
  ipQueryEndLow=ipQueryStartLow.add(lowEndPlusDecimal);
}","/** 
 * parseQueryIpV6Mask.
 * @param strQuery for ip string v6
 * @param ipV6 for ip BigDecimal style
 */
private void parseQueryIpV6Mask(String strQuery,BigDecimal[] ipV6){
  final int lowLimitShift=64;
  long maskRangeBytes=0;
  if (numMask > 0) {
    maskRangeBytes=lowLimitShift * 2 - numMask;
  }
  int lowShift=(int)maskRangeBytes;
  BigDecimal powDecimalBase=BigDecimal.valueOf(2L);
  BigDecimal endSubDecimalBase=BigDecimal.valueOf(1L);
  ipQueryStartHigh=ipV6[0];
  ipQueryEndHigh=ipV6[0];
  if (maskRangeBytes > lowLimitShift) {
    int highShift=(int)maskRangeBytes - lowLimitShift;
    BigDecimal powDecimalhigh=powDecimalBase.pow(highShift);
    BigDecimal modDecimalHigh=ipV6[0].remainder(powDecimalhigh);
    ipQueryStartHigh=ipV6[0].subtract(modDecimalHigh);
    lowShift=lowLimitShift;
    BigDecimal highEndPlusDecimal=powDecimalhigh.subtract(endSubDecimalBase);
    ipQueryEndHigh=ipQueryStartHigh.add(highEndPlusDecimal);
  }
  BigDecimal powDecimalLow=powDecimalBase.pow(lowShift);
  BigDecimal modDecimalLow=ipV6[1].remainder(powDecimalLow);
  ipQueryStartLow=ipV6[1].subtract(modDecimalLow);
  BigDecimal lowEndPlusDecimal=powDecimalLow.subtract(endSubDecimalBase);
  ipQueryEndLow=ipQueryStartLow.add(lowEndPlusDecimal);
}",0.9377870563674322
37502,"/** 
 * check if IP v6 string is valid.
 * @param str IP string.
 * @return true if valid, false if not.
 */
public static boolean isIpV6StrValid(String str){
  final String regexV6=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Pattern pattern=Pattern.compile(regexV6);
  boolean isRegular=pattern.matcher(str).matches();
  return isRegular;
}","/** 
 * check if IP v6 string is valid.
 * @param str IP string.
 * @return true if valid, false if not.
 */
public static boolean isIpV6StrValid(String str){
  final String regexV6=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Pattern pattern=Pattern.compile(regexV6);
  boolean isRegular=pattern.matcher(str).matches();
  return isRegular;
}",0.9675767918088736
37503,"@Test public void testMain(){
  Init.main(null);
}","public void testMain(){
  Init.main(null);
}",0.9361702127659576
37504,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  Principal principal=Principal.getAnonymousPrincipal();
  if (tempPass != null) {
    tempPass=tempPass.substring(6,tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    userReqId=tempPassdeCode.substring(0,tempPassdeCode.indexOf(""String_Node_Str""));
    userReqPwd=tempPassdeCode.substring(tempPassdeCode.indexOf(""String_Node_Str"") + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return;
    }
 else {
      principal=new Principal(user.getUserId());
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  Principal principal=Principal.getAnonymousPrincipal();
  if (StringUtils.isNotBlank(tempPass)) {
    String AUTH_BASIC_PREFIX=""String_Node_Str"";
    if (!StringUtils.startsWith(tempPass,AUTH_BASIC_PREFIX)) {
      writeError401Response(response);
      return;
    }
    tempPass=tempPass.substring(AUTH_BASIC_PREFIX.length(),tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      writeError401Response(response);
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    int indexOfSeparator=tempPassdeCode.indexOf(""String_Node_Str"");
    if (-1 == indexOfSeparator) {
      writeError401Response(response);
      return;
    }
    userReqId=tempPassdeCode.substring(0,indexOfSeparator);
    userReqPwd=tempPassdeCode.substring(indexOfSeparator + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return;
    }
 else {
      principal=new Principal(user.getUserId());
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}",0.8120534327430879
37505,"@Override public User IdentityCheckService(String userId,String userPwd){
  if (StringUtils.isEmpty(userId) || StringUtils.isEmpty(userPwd)) {
    return null;
  }
  User user=idcDao.checkUserId(userId);
  if (MD5Encryption.encryption(userPwd).equalsIgnoreCase(user.getUserPwd())) {
    user.setUserType(User.UserType.Cerfications);
    return user;
  }
  return null;
}","@Override public User IdentityCheckService(String userId,String userPwd){
  if (StringUtils.isEmpty(userId) || StringUtils.isEmpty(userPwd)) {
    return null;
  }
  User user=idcDao.checkUserId(userId);
  if (null == user) {
    return null;
  }
  if (MD5Encryption.encryption(userPwd).equalsIgnoreCase(user.getUserPwd())) {
    user.setUserType(User.UserType.Cerfications);
    return user;
  }
  return null;
}",0.9450830140485312
37506,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9818840579710144
37507,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  try {
    decodeNameserver=DomainUtil.iso8859Decode(name);
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  name=queryParser.getParameter(request,""String_Node_Str"");
  String decodeNameserver=name;
  try {
    decodeNameserver=DomainUtil.iso8859Decode(name);
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9831460674157304
37508,"@Override public void init(FilterConfig arg0) throws ServletException {
  idcService=new IdentityCheckServiceImpl();
}","@Override public void init(FilterConfig arg0) throws ServletException {
}",0.7643979057591623
37509,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  if (tempPass != null) {
    tempPass=tempPass.substring(6,tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    userReqId=tempPassdeCode.substring(0,tempPassdeCode.indexOf(""String_Node_Str""));
    userReqPwd=tempPassdeCode.substring(tempPassdeCode.indexOf(""String_Node_Str"") + 1);
    User user=null;
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (user.getUserType().equals(User.UserType.Anonymous)) {
      writeError401Response(response);
      chain.doFilter(request,response);
      return;
    }
 else {
      request.getSession().setAttribute(""String_Node_Str"",user.getUserId());
    }
  }
  HttpSession session=request.getSession();
  Principal principal=Principal.getAnonymousPrincipal();
  if (null != session) {
    Object userId=session.getAttribute(""String_Node_Str"");
    if (null != userId) {
      principal=new Principal((Long)userId);
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  if (tempPass != null) {
    tempPass=tempPass.substring(6,tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    userReqId=tempPassdeCode.substring(0,tempPassdeCode.indexOf(""String_Node_Str""));
    userReqPwd=tempPassdeCode.substring(tempPassdeCode.indexOf(""String_Node_Str"") + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return;
    }
 else {
      request.getSession().setAttribute(""String_Node_Str"",user.getUserId());
    }
  }
  HttpSession session=request.getSession();
  Principal principal=Principal.getAnonymousPrincipal();
  if (null != session) {
    Object userId=session.getAttribute(""String_Node_Str"");
    if (null != userId) {
      principal=new Principal((Long)userId);
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}",0.916156670746634
37510,"public User mapRow(ResultSet rs,int rowNum) throws SQLException {
  user.setUserId(rs.getLong(""String_Node_Str""));
  user.setUserPwd(rs.getString(""String_Node_Str""));
  return user;
}","public User mapRow(ResultSet rs,int rowNum) throws SQLException {
  User user=new User();
  user.setUserId(rs.getLong(""String_Node_Str""));
  user.setUserPwd(rs.getString(""String_Node_Str""));
  return user;
}",0.9384615384615383
37511,"public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql);
  ps.setLong(1,Long.parseLong(userId));
  return ps;
}","public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql);
  ps.setString(1,userId);
  return ps;
}",0.9444444444444444
37512,"@Override public User checkUserId(final String userId){
  List<User> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setLong(1,Long.parseLong(userId));
      return ps;
    }
  }
,new RowMapper<User>(){
    public User mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      user.setUserId(rs.getLong(""String_Node_Str""));
      user.setUserPwd(rs.getString(""String_Node_Str""));
      return user;
    }
  }
);
  return user;
}","@Override public User checkUserId(final String userId){
  List<User> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,userId);
      return ps;
    }
  }
,new RowMapper<User>(){
    public User mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      User user=new User();
      user.setUserId(rs.getLong(""String_Node_Str""));
      user.setUserPwd(rs.getString(""String_Node_Str""));
      return user;
    }
  }
);
  if (null != result && result.size() > 0) {
    return result.get(0);
  }
  return null;
}",0.8863807373965388
37513,"@Override public User IdentityCheckService(String userId,String userPwd){
  user=idcDao.checkUserId(userId);
  if (userPwd.isEmpty()) {
    user.setUserType(User.UserType.Anonymous);
    return user;
  }
  if (MD5Encryption.encryption(userPwd).equalsIgnoreCase(user.getUserPwd())) {
    user.setUserType(User.UserType.Cerfications);
  }
 else {
    user.setUserType(User.UserType.Anonymous);
  }
  return user;
}","@Override public User IdentityCheckService(String userId,String userPwd){
  if (StringUtils.isEmpty(userId) || StringUtils.isEmpty(userPwd)) {
    return null;
  }
  User user=idcDao.checkUserId(userId);
  if (MD5Encryption.encryption(userPwd).equalsIgnoreCase(user.getUserPwd())) {
    user.setUserType(User.UserType.Cerfications);
    return user;
  }
  return null;
}",0.6240409207161125
37514,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  if (tempPass != null) {
    tempPass=tempPass.substring(6,tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    userReqId=tempPassdeCode.substring(0,tempPassdeCode.indexOf(""String_Node_Str""));
    userReqPwd=tempPassdeCode.substring(tempPassdeCode.indexOf(""String_Node_Str"") + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return;
    }
 else {
      request.getSession().setAttribute(""String_Node_Str"",user.getUserId());
    }
  }
  HttpSession session=request.getSession();
  Principal principal=Principal.getAnonymousPrincipal();
  if (null != session) {
    Object userId=session.getAttribute(""String_Node_Str"");
    if (null != userId) {
      principal=new Principal((Long)userId);
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  String tempPass=null;
  tempPass=request.getHeader(""String_Node_Str"");
  Principal principal=Principal.getAnonymousPrincipal();
  if (tempPass != null) {
    tempPass=tempPass.substring(6,tempPass.length());
    String tempPassdeCode=""String_Node_Str"";
    BASE64Decoder decoder=new BASE64Decoder();
    try {
      byte[] b=decoder.decodeBuffer(tempPass);
      tempPassdeCode=new String(b);
    }
 catch (    Exception e) {
      return;
    }
    String userReqId=""String_Node_Str"";
    String userReqPwd=""String_Node_Str"";
    userReqId=tempPassdeCode.substring(0,tempPassdeCode.indexOf(""String_Node_Str""));
    userReqPwd=tempPassdeCode.substring(tempPassdeCode.indexOf(""String_Node_Str"") + 1);
    User user=null;
    IdentityCheckService idcService=ServiceBeanUtil.getIdentityCheckService();
    user=idcService.IdentityCheckService(userReqId,userReqPwd);
    if (null == user) {
      request.getSession().removeAttribute(""String_Node_Str"");
      writeError401Response(response);
      return;
    }
 else {
      principal=new Principal(user.getUserId());
    }
  }
  PrincipalHolder.setPrincipal(principal);
  chain.doFilter(request,response);
  PrincipalHolder.remove();
}",0.7883683360258481
37515,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  Nameserver ns=queryService.queryNameserver(queryParser.parseNameserverQueryParam(decodeNS,punyNSName));
  if (null != ns) {
    if (!accessControlManager.hasPermission(ns)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ns);
    return RestResponseUtil.createResponse200(ns);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=decodeNS;
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  Nameserver ns=queryService.queryNameserver(queryParser.parseNameserverQueryParam(decodeNS,punyNSName));
  if (null != ns) {
    if (!accessControlManager.hasPermission(ns)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ns);
    return RestResponseUtil.createResponse200(ns);
  }
  return RestResponseUtil.createResponse404();
}",0.9830752610731004
37516,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
    punyDomainName=decodeDomain;
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9834087481146304
37517,"/** 
 * convert ipV4 Long format to String.
 * @param longIp ipV4 long value.
 * @return ipv4 string.
 */
public static String longToIpV4(long longIp){
  if (longIp > 0xffffffff) {
    return ""String_Node_Str"";
  }
  final int threeByteSize=24;
  final int threeByteMask=0x00ffffff;
  final int twoByteSize=16;
  final int twoByteMask=0x0000ffff;
  final int oneByteSize=8;
  final int oneByteMask=0x000000ff;
  return String.format(""String_Node_Str"",longIp >>> threeByteSize,(longIp & threeByteMask) >>> twoByteSize,(longIp & twoByteMask) >>> oneByteSize,longIp & oneByteMask);
}","/** 
 * convert ipV4 Long format to String.
 * @param longIp ipV4 long value.
 * @return ipv4 string.
 */
public static String longToIpV4(long longIp){
  final long posShift=32;
  long tmp=longIp;
  tmp>>>=posShift;
  if (tmp > 0) {
    return ""String_Node_Str"";
  }
  final int threeByteSize=24;
  final int threeByteMask=0x00ffffff;
  final int twoByteSize=16;
  final int twoByteMask=0x0000ffff;
  final int oneByteSize=8;
  final int oneByteMask=0x000000ff;
  return String.format(""String_Node_Str"",longIp >>> threeByteSize,(longIp & threeByteMask) >>> twoByteSize,(longIp & twoByteMask) >>> oneByteSize,longIp & oneByteMask);
}",0.9257425742574258
37518,"/** 
 * convert ipV6 Long format to String.
 * @param highBits high 64 bits long value.
 * @param lowBits low 64 bits long value.
 * @return ipv6 string.
 */
public static String longToIpV6(long highBits,long lowBits){
  final long numBeyond=2 ^ 64 - 1;
  if (highBits > numBeyond || lowBits > numBeyond) {
    return ""String_Node_Str"";
  }
  final int oneByteSize=8;
  final int v6MaxSegment=8;
  final int twoByteSize=16;
  final int fourByteMask=0xFFFF;
  short[] shorts=new short[v6MaxSegment];
  String[] strings=new String[shorts.length];
  for (int i=0; i < v6MaxSegment; i++) {
    if (i >= 0 && i < v6MaxSegment / 2) {
      strings[i]=String.format(""String_Node_Str"",(short)(((highBits << i * twoByteSize) >>> twoByteSize * (oneByteSize - 1)) & fourByteMask));
    }
 else {
      strings[i]=String.format(""String_Node_Str"",(short)(((lowBits << i * twoByteSize) >>> twoByteSize * (oneByteSize - 1)) & fourByteMask));
    }
  }
  StringBuilder result=new StringBuilder();
  for (int i=0; i < strings.length; i++) {
    result.append(strings[i]);
    if (i < strings.length - 1) {
      result.append(""String_Node_Str"");
    }
  }
  return result.toString();
}","/** 
 * convert ipV6 Long format to String.
 * @param highBits high 64 bits long value.
 * @param lowBits low 64 bits long value.
 * @return ipv6 string.
 */
public static String longToIpV6(long highBits,long lowBits){
  final int oneByteSize=8;
  final int v6MaxSegment=8;
  final int twoByteSize=16;
  final int fourByteMask=0xFFFF;
  short[] shorts=new short[v6MaxSegment];
  String[] strings=new String[shorts.length];
  for (int i=0; i < v6MaxSegment; i++) {
    if (i >= 0 && i < v6MaxSegment / 2) {
      strings[i]=String.format(""String_Node_Str"",(short)(((highBits << i * twoByteSize) >>> twoByteSize * (oneByteSize - 1)) & fourByteMask));
    }
 else {
      strings[i]=String.format(""String_Node_Str"",(short)(((lowBits << i * twoByteSize) >>> twoByteSize * (oneByteSize - 1)) & fourByteMask));
    }
  }
  StringBuilder result=new StringBuilder();
  for (int i=0; i < strings.length; i++) {
    result.append(strings[i]);
    if (i < strings.length - 1) {
      result.append(""String_Node_Str"");
    }
  }
  return result.toString();
}",0.9448961156278228
37519,"/** 
 * test longToIpV4.
 */
@Test public void testLongToIpV4(){
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(16777216));
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(33554431));
}","/** 
 * test longToIpV4.
 */
@Test public void testLongToIpV4(){
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(16777216));
}",0.8037383177570093
37520,"/** 
 * convert ipV4 Long format to String.
 * @param longIp ipV4 long value.
 * @return ipv4 string.
 */
public static String longToIpV4(long longIp){
  final long posShift=32;
  long tmp=longIp;
  tmp>>>=posShift;
  if (tmp > 0) {
    return ""String_Node_Str"";
  }
  final int threeByteSize=24;
  final int threeByteMask=0x00ffffff;
  final int twoByteSize=16;
  final int twoByteMask=0x0000ffff;
  final int oneByteSize=8;
  final int oneByteMask=0x000000ff;
  return String.format(""String_Node_Str"",longIp >>> threeByteSize,(longIp & threeByteMask) >>> twoByteSize,(longIp & twoByteMask) >>> oneByteSize,longIp & oneByteMask);
}","/** 
 * convert ipV4 Long format to String.
 * @param longIp ipV4 long value.
 * @return ipv4 string.
 */
public static String longToIpV4(long longIp){
  final int threeByteSize=24;
  final int threeByteMask=0x00ffffff;
  final int twoByteSize=16;
  final int twoByteMask=0x0000ffff;
  final int oneByteSize=8;
  final int oneByteMask=0x000000ff;
  return String.format(""String_Node_Str"",(longIp >>> threeByteSize) & oneByteMask,(longIp & threeByteMask) >>> twoByteSize,(longIp & twoByteMask) >>> oneByteSize,longIp & oneByteMask);
}",0.8875536480686695
37521,"/** 
 * test longToIpV4.
 */
@Test public void testLongToIpV4(){
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(16777216));
}","/** 
 * test longToIpV4.
 */
@Test public void testLongToIpV4(){
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(16777216));
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(33554431));
  final long num=(0xffffffff);
  assertEquals(""String_Node_Str"",IpUtil.longToIpV4(num));
}",0.6292682926829268
37522,"/** 
 * encoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
private static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}","/** 
 * decoded url use UTF-8.
 * @param str string.
 * @return String decoded string.
 */
private static String urlDecode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    result=URLDecoder.decode(str,StringUtil.CHAR_SET_UTF8);
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.error(e.getMessage());
  }
  return result;
}",0.9947780678851176
37523,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9801526717557252
37524,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  String punyNameserver=decodeNameserver;
  try {
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,punyNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  String punyNameserver=decodeNameserver;
  try {
    decodeNameserver=DomainUtil.iso8859Decode(name);
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,punyNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9792318634423898
37525,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  try {
    decodeDomain=DomainUtil.iso8859Decode(name);
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,decodeDomain));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9805589307411908
37526,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  String punyNameserver=decodeNameserver;
  try {
    decodeNameserver=DomainUtil.iso8859Decode(name);
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,punyNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  try {
    decodeNameserver=DomainUtil.iso8859Decode(name);
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,decodeNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9853107344632768
37527,"/** 
 * test query exist autnum,with rdap+json type
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryExistAutnumWithRdapAndJson() throws Exception {
  String autnumStr=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + autnumStr).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * test query exist autnum,with rdap+json type
 * @throws Exception
 */
@Test @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistAutnumWithRdapAndJson() throws Exception {
  String autnumStr=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + autnumStr).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.9702333065164924
37528,"/** 
 * test query exist autnum,with json type
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryExistAutnum() throws Exception {
  String autnumStr=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + autnumStr).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * test query exist autnum,with json type
 * @throws Exception
 */
@Test @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistAutnum() throws Exception {
  String autnumStr=""String_Node_Str"";
  mockMvc.perform(get(""String_Node_Str"" + autnumStr).accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.969243557772236
37529,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchTruncatedDomain() throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").value(true)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize(5))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testSearchTruncatedDomain() throws Exception {
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").value(true)).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",hasSize(5))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str""))));
}",0.9763880025526483
37530,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testSearchNonExistDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").doesNotExist()).andExpect(jsonPath(""String_Node_Str"").doesNotExist());
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testSearchNonExistDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isNotFound()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(404)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").doesNotExist()).andExpect(jsonPath(""String_Node_Str"").doesNotExist());
}",0.9795240730492528
37531,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testSearchExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testSearchExistDomain() throws Exception {
  String domainName=""String_Node_Str"";
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isOk()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItem(""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasKey(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"",Matchers.hasItem(Matchers.hasValue(""String_Node_Str"")))).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(domainName)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").isArray()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").exists()).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""))).andExpect(jsonPath(""String_Node_Str"").exists());
}",0.99200691294016
37532,"/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistSecureDnsId=10000L;
  List<DsData> dsDataList=dsDataQueryDaoImpl.queryAsInnerObjects(nonExistSecureDnsId,ModelType.SECUREDNS);
  assertNotNull(dsDataList);
  assertEquals(dsDataList.size(),0);
}","/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistSecureDnsId=10000L;
  List<DsData> dsDataList=dsDataQueryDaoImpl.queryAsInnerObjects(nonExistSecureDnsId,ModelType.SECUREDNS);
  assertNotNull(dsDataList);
  assertEquals(dsDataList.size(),0);
}",0.9515072083879424
37533,"/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistLink(){
  Long secureDnsId=1L;
  List<DsData> dsDataList=dsDataQueryDaoImpl.queryAsInnerObjects(secureDnsId,ModelType.SECUREDNS);
  assertNotNull(dsDataList);
  assertEquals(dsDataList.size(),1);
  DsData dsData=dsDataList.get(0);
  assertNotNull(dsData);
  assertEquals(dsData.getAlgorithm().intValue(),1);
  assertEquals(dsData.getDigest(),""String_Node_Str"");
  assertEquals(dsData.getDigestType(),1);
  assertEquals(dsData.getKeyTag().intValue(),1);
  List<Link> links=dsData.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}","/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistLink(){
  Long secureDnsId=1L;
  List<DsData> dsDataList=dsDataQueryDaoImpl.queryAsInnerObjects(secureDnsId,ModelType.SECUREDNS);
  assertNotNull(dsDataList);
  assertEquals(dsDataList.size(),1);
  DsData dsData=dsDataList.get(0);
  assertNotNull(dsData);
  assertEquals(dsData.getAlgorithm().intValue(),1);
  assertEquals(dsData.getDigest(),""String_Node_Str"");
  assertEquals(dsData.getDigestType(),1);
  assertEquals(dsData.getKeyTag().intValue(),1);
  List<Link> links=dsData.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}",0.9770043505282784
37534,"/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistSecureDnsId=10000L;
  List<KeyData> keyDataList=keyDataQueryDaoImpl.queryAsInnerObjects(nonExistSecureDnsId,ModelType.SECUREDNS);
  assertNotNull(keyDataList);
  assertEquals(keyDataList.size(),0);
}","/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistSecureDnsId=10000L;
  List<KeyData> keyDataList=keyDataQueryDaoImpl.queryAsInnerObjects(nonExistSecureDnsId,ModelType.SECUREDNS);
  assertNotNull(keyDataList);
  assertEquals(keyDataList.size(),0);
}",0.9521345407503234
37535,"/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistLink(){
  Long secureDnsId=1L;
  List<KeyData> keyDataList=keyDataQueryDaoImpl.queryAsInnerObjects(secureDnsId,ModelType.SECUREDNS);
  assertNotNull(keyDataList);
  assertEquals(keyDataList.size(),1);
  KeyData keyData=keyDataList.get(0);
  assertNotNull(keyData);
  assertEquals(keyData.getAlgorithm().intValue(),1);
  assertEquals(keyData.getPublicKey(),""String_Node_Str"");
  assertEquals(keyData.getProtocol().intValue(),1);
  assertEquals(keyData.getFlags().intValue(),1);
  List<Link> links=keyData.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}","/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistLink(){
  Long secureDnsId=1L;
  List<KeyData> keyDataList=keyDataQueryDaoImpl.queryAsInnerObjects(secureDnsId,ModelType.SECUREDNS);
  assertNotNull(keyDataList);
  assertTrue(keyDataList.size() >= 1);
  KeyData keyData=keyDataList.get(0);
  assertNotNull(keyData);
  assertEquals(keyData.getAlgorithm().intValue(),1);
  assertEquals(keyData.getPublicKey(),""String_Node_Str"");
  assertEquals(keyData.getProtocol().intValue(),1);
  assertEquals(keyData.getFlags().intValue(),1);
  List<Link> links=keyData.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}",0.7506024096385542
37536,"/** 
 * test query exist v6 network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistV6Network(){
  Long domainId=1L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertEquals(1,networks.size());
  Network network=networks.get(0);
  assertEquals(""String_Node_Str"",network.getHandle());
  assertEquals(""String_Node_Str"",network.getStartAddress());
  assertEquals(""String_Node_Str"",network.getEndAddress());
  assertEquals(IpVersion.V6,network.getIpVersion());
  assertEquals(""String_Node_Str"",network.getName());
  assertEquals(""String_Node_Str"",network.getType());
  assertEquals(""String_Node_Str"",network.getCountry());
  assertEquals(""String_Node_Str"",network.getParentHandle());
  assertEquals(""String_Node_Str"",network.getPort43());
  assertEquals(""String_Node_Str"",network.getLang());
  List<String> statusList=network.getStatus();
  assertThat(statusList,CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Event> events=network.getEvents();
  assertNotNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  assertNotNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  assertEquals(dateFormat.format(event.getEventDate()),""String_Node_Str"");
  List<Link> networkLinks=network.getLinks();
  assertNotNull(networkLinks);
  assertEquals(1,networkLinks.size());
  Link networkLink=networkLinks.get(0);
  assertNotNull(networkLink);
  assertEquals(""String_Node_Str"",networkLink.getValue());
  assertEquals(""String_Node_Str"",networkLink.getHref());
  List<Remark> remarks=network.getRemarks();
  assertNotNull(remarks);
  assertTrue(remarks.size() > 0);
  Remark remark=remarks.get(0);
  assertNotNull(remark);
  assertEquals(""String_Node_Str"",remark.getTitle());
  assertThat(remark.getDescription(),CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Link> links=remark.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}","/** 
 * test query exist v6 network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistV6Network(){
  Long domainId=1L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertEquals(1,networks.size());
  Network network=networks.get(0);
  assertEquals(""String_Node_Str"",network.getHandle());
  assertEquals(""String_Node_Str"",network.getStartAddress());
  assertEquals(""String_Node_Str"",network.getEndAddress());
  assertEquals(IpVersion.V6,network.getIpVersion());
  assertEquals(""String_Node_Str"",network.getName());
  assertEquals(""String_Node_Str"",network.getType());
  assertEquals(""String_Node_Str"",network.getCountry());
  assertEquals(""String_Node_Str"",network.getParentHandle());
  assertEquals(""String_Node_Str"",network.getPort43());
  assertEquals(""String_Node_Str"",network.getLang());
  List<String> statusList=network.getStatus();
  assertThat(statusList,CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Event> events=network.getEvents();
  assertNotNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  assertNotNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  assertEquals(event.getEventDate(),""String_Node_Str"");
  List<Link> networkLinks=network.getLinks();
  assertNotNull(networkLinks);
  assertEquals(1,networkLinks.size());
  Link networkLink=networkLinks.get(0);
  assertNotNull(networkLink);
  assertEquals(""String_Node_Str"",networkLink.getValue());
  assertEquals(""String_Node_Str"",networkLink.getHref());
  List<Remark> remarks=network.getRemarks();
  assertNotNull(remarks);
  assertTrue(remarks.size() > 0);
  Remark remark=remarks.get(0);
  assertNotNull(remark);
  assertEquals(""String_Node_Str"",remark.getTitle());
  assertThat(remark.getDescription(),CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Link> links=remark.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}",0.9606229143492768
37537,"/** 
 * test query exist v4 network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistV4Network(){
  Long domainId=1L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertEquals(1,networks.size());
  Network network=networks.get(0);
  assertEquals(""String_Node_Str"",network.getHandle());
  assertEquals(""String_Node_Str"",network.getStartAddress());
  assertEquals(""String_Node_Str"",network.getEndAddress());
  assertEquals(IpVersion.V4,network.getIpVersion());
  assertEquals(""String_Node_Str"",network.getName());
  assertEquals(""String_Node_Str"",network.getType());
  assertEquals(""String_Node_Str"",network.getCountry());
  assertEquals(""String_Node_Str"",network.getParentHandle());
  assertEquals(""String_Node_Str"",network.getPort43());
  assertEquals(""String_Node_Str"",network.getLang());
  List<String> statusList=network.getStatus();
  assertThat(statusList,CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Event> events=network.getEvents();
  assertNotNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  assertNotNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  assertEquals(dateFormat.format(event.getEventDate()),""String_Node_Str"");
  List<Link> networkLinks=network.getLinks();
  assertNotNull(networkLinks);
  assertEquals(1,networkLinks.size());
  Link networkLink=networkLinks.get(0);
  assertNotNull(networkLink);
  assertEquals(""String_Node_Str"",networkLink.getValue());
  assertEquals(""String_Node_Str"",networkLink.getHref());
  List<Remark> remarks=network.getRemarks();
  assertNotNull(remarks);
  assertTrue(remarks.size() > 0);
  Remark remark=remarks.get(0);
  assertNotNull(remark);
  assertEquals(""String_Node_Str"",remark.getTitle());
  assertThat(remark.getDescription(),CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Link> links=remark.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}","/** 
 * test query exist v4 network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistV4Network(){
  Long domainId=1L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertEquals(1,networks.size());
  Network network=networks.get(0);
  assertEquals(""String_Node_Str"",network.getHandle());
  assertEquals(""String_Node_Str"",network.getStartAddress());
  assertEquals(""String_Node_Str"",network.getEndAddress());
  assertEquals(IpVersion.V4,network.getIpVersion());
  assertEquals(""String_Node_Str"",network.getName());
  assertEquals(""String_Node_Str"",network.getType());
  assertEquals(""String_Node_Str"",network.getCountry());
  assertEquals(""String_Node_Str"",network.getParentHandle());
  assertEquals(""String_Node_Str"",network.getPort43());
  assertEquals(""String_Node_Str"",network.getLang());
  List<String> statusList=network.getStatus();
  assertThat(statusList,CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Event> events=network.getEvents();
  assertNotNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  assertNotNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  assertEquals(event.getEventDate(),""String_Node_Str"");
  List<Link> networkLinks=network.getLinks();
  assertNotNull(networkLinks);
  assertEquals(1,networkLinks.size());
  Link networkLink=networkLinks.get(0);
  assertNotNull(networkLink);
  assertEquals(""String_Node_Str"",networkLink.getValue());
  assertEquals(""String_Node_Str"",networkLink.getHref());
  List<Remark> remarks=network.getRemarks();
  assertNotNull(remarks);
  assertTrue(remarks.size() > 0);
  Remark remark=remarks.get(0);
  assertNotNull(remark);
  assertEquals(""String_Node_Str"",remark.getTitle());
  assertThat(remark.getDescription(),CoreMatchers.hasItems(""String_Node_Str"",""String_Node_Str""));
  List<Link> links=remark.getLinks();
  assertNotNull(links);
  assertEquals(1,links.size());
  Link link=links.get(0);
  assertNotNull(link);
  assertEquals(""String_Node_Str"",link.getValue());
}",0.9606229143492768
37538,"/** 
 * test query ont exist network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNotExistNetwork(){
  Long nonExistDomainId=1000L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertTrue(networks.size() == 0);
}","/** 
 * test query ont exist network.
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryNotExistNetwork(){
  Long nonExistDomainId=1000L;
  List<Network> networks=networkQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(networks);
  assertTrue(networks.size() == 0);
}",0.9499323410013532
37539,"/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistDomainId=10000L;
  List<PublicId> publicIdsList=publicIdQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(publicIdsList);
  assertEquals(publicIdsList.size(),0);
}","/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistDomainId=10000L;
  List<PublicId> publicIdsList=publicIdQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(publicIdsList);
  assertEquals(publicIdsList.size(),0);
}",0.9515072083879424
37540,"/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<PublicId> publicIdsList=publicIdQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(publicIdsList);
  assertEquals(publicIdsList.size(),1);
  PublicId publicId=publicIdsList.get(0);
  assertNotNull(publicId);
  assertEquals(""String_Node_Str"",publicId.getIdentifier());
  assertEquals(""String_Node_Str"",publicId.getType());
}","/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<PublicId> publicIdsList=publicIdQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(publicIdsList);
  assertTrue(publicIdsList.size() >= 1);
  PublicId publicId=publicIdsList.get(0);
  assertNotNull(publicId);
  assertEquals(""String_Node_Str"",publicId.getIdentifier());
  assertEquals(""String_Node_Str"",publicId.getType());
}",0.6852886405959032
37541,"/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistDomainId=10000L;
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(secureDnsList);
  assertEquals(0,secureDnsList.size());
}","/** 
 * test query non exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryNonExistEvent(){
  Long nonExistDomainId=10000L;
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(nonExistDomainId,ModelType.DOMAIN);
  assertNotNull(secureDnsList);
  assertEquals(0,secureDnsList.size());
}",0.9517601043024772
37542,"/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(secureDnsList);
  assertEquals(1,secureDnsList.size());
  SecureDns secureDns=secureDnsList.get(0);
  assertNotNull(secureDns);
  assertEquals(1,secureDns.getMaxSigLife().intValue());
  assertEquals(true,secureDns.isDelegationSigned());
  assertEquals(true,secureDns.isZoneSigned());
  List<DsData> dsDataList=secureDns.getDsData();
  assertNotNull(dsDataList);
  assertEquals(1,dsDataList.size());
  DsData dsData=dsDataList.get(0);
  assertNotNull(dsData);
  assertEquals(dsData.getAlgorithm().intValue(),1);
  assertEquals(""String_Node_Str"",dsData.getDigest());
  assertEquals(1,dsData.getDigestType());
  assertEquals(1,dsData.getKeyTag().intValue());
  List<KeyData> keyDataList=secureDns.getKeyData();
  assertNotNull(keyDataList);
  assertEquals(1,keyDataList.size());
  KeyData keyData=keyDataList.get(0);
  assertNotNull(keyData);
  assertEquals(1,keyData.getAlgorithm().intValue());
  assertEquals(""String_Node_Str"",keyData.getPublicKey());
  assertEquals(1,keyData.getProtocol().intValue());
  assertEquals(1,keyData.getFlags().intValue());
}","/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<SecureDns> secureDnsList=secureDnsQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(secureDnsList);
  assertEquals(1,secureDnsList.size());
  SecureDns secureDns=secureDnsList.get(0);
  assertNotNull(secureDns);
  assertEquals(1,secureDns.getMaxSigLife().intValue());
  assertEquals(true,secureDns.isDelegationSigned());
  assertEquals(true,secureDns.isZoneSigned());
  List<DsData> dsDataList=secureDns.getDsData();
  assertNotNull(dsDataList);
  assertEquals(1,dsDataList.size());
  DsData dsData=dsDataList.get(0);
  assertNotNull(dsData);
  assertEquals(dsData.getAlgorithm().intValue(),1);
  assertEquals(""String_Node_Str"",dsData.getDigest());
  assertEquals(1,dsData.getDigestType());
  assertEquals(1,dsData.getKeyTag().intValue());
  List<KeyData> keyDataList=secureDns.getKeyData();
  assertNotNull(keyDataList);
  assertEquals(1,keyDataList.size());
  KeyData keyData=keyDataList.get(0);
  assertNotNull(keyData);
  assertEquals(1,keyData.getAlgorithm().intValue());
  assertEquals(""String_Node_Str"",keyData.getPublicKey());
  assertEquals(1,keyData.getProtocol().intValue());
  assertEquals(1,keyData.getFlags().intValue());
}",0.9863115057343692
37543,"/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<Variants> variantsList=variantsQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(variantsList);
  assertEquals(variantsList.size(),1);
  Variants variants=variantsList.get(0);
  assertNotNull(variants);
  List<Variant> variantList=variants.getVariantNames();
  assertNotNull(variantList);
  assertEquals(variantList.size(),1);
  Variant variant=variantList.get(0);
  assertNotNull(variant);
  assertEquals(variant.getLdhName(),""String_Node_Str"");
  assertEquals(variant.getUnicodeName(),""String_Node_Str"");
}","/** 
 * test query exist event
 */
@Test @DatabaseTearDown(""String_Node_Str"") @DatabaseSetup(type=DatabaseOperation.REFRESH,value=""String_Node_Str"") public void testQueryExistLink(){
  Long domainId=1L;
  List<Variants> variantsList=variantsQueryDao.queryAsInnerObjects(domainId,ModelType.DOMAIN);
  assertNotNull(variantsList);
  assertEquals(variantsList.size(),1);
  Variants variants=variantsList.get(0);
  assertNotNull(variants);
  List<Variant> variantList=variants.getVariantNames();
  assertNotNull(variantList);
  assertEquals(variantList.size(),1);
  Variant variant=variantList.get(0);
  assertNotNull(variant);
  assertEquals(variant.getLdhName(),""String_Node_Str"");
  assertEquals(variant.getUnicodeName(),""String_Node_Str"");
}",0.97439446366782
37544,"/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=decodeNS;
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  Nameserver ns=queryService.queryNameserver(queryParser.parseNameserverQueryParam(decodeNS,punyNSName));
  if (null != ns) {
    if (!accessControlManager.hasPermission(ns)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ns);
    return RestResponseUtil.createResponse200(ns);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query nameserver by nameserver name.
 * @param nameserverName represents information regarding DNS name servers used in both forward and reverse DNS. RIRs and some DNRs register or expose nameserver information as an attribute of a domain name, while other DNRs model nameservers as ""first class objects"".
 * @return JSON formatted result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryNameserver(@PathVariable String nameserverName){
  String decodeNS=nameserverName;
  String punyNSName=decodeNS;
  try {
    decodeNS=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(nameserverName);
    punyNSName=DomainUtil.geneDomainPunyName(decodeNS);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeNS)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNS=DomainUtil.deleteLastPoint(decodeNS);
  decodeNS=StringUtils.lowerCase(decodeNS);
  Nameserver ns=queryService.queryNameserver(queryParser.parseNameserverQueryParam(decodeNS,punyNSName));
  if (null != ns) {
    if (!accessControlManager.hasPermission(ns)) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(ns);
    return RestResponseUtil.createResponse200(ns);
  }
  return RestResponseUtil.createResponse404();
}",0.9830752610731004
37545,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
    punyDomainName=decodeDomain;
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchDomain(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeDomain=name;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=StringUtil.getNormalization(decodeDomain);
  if (StringUtil.ASTERISK.equals(decodeDomain) || decodeDomain.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  DomainSearch domainSearch=searchService.searchDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domainSearch) {
    if (domainSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(domainSearch);
    return RestResponseUtil.createResponse200(domainSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9898492771454936
37546,"/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  String punyNameserver=decodeNameserver;
  try {
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
    punyNameserver=DomainUtil.geneDomainPunyName(decodeNameserver);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,punyNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * search nameserver by name.
 * @param name is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @param request HttpServletRequest
 * @param response HttpServletResponse
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity searchNameserver(@RequestParam(required=false) String name,HttpServletRequest request,HttpServletResponse response){
  String decodeNameserver=name;
  String punyNameserver=decodeNameserver;
  try {
    decodeNameserver=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(name);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (StringUtils.isBlank(decodeNameserver)) {
    return RestResponseUtil.createResponse400();
  }
  decodeNameserver=StringUtil.getNormalization(decodeNameserver);
  if (StringUtil.ASTERISK.equals(decodeNameserver) || decodeNameserver.startsWith(StringUtil.ASTERISK)) {
    return RestResponseUtil.createResponse422();
  }
  decodeNameserver=DomainUtil.deleteLastPoint(decodeNameserver);
  decodeNameserver=StringUtils.lowerCase(decodeNameserver);
  NameserverSearch nsSearch=searchService.searchNameserver(queryParser.parseNameserverQueryParam(decodeNameserver,punyNameserver));
  if (null != nsSearch) {
    if (nsSearch.getHasNoAuthForAllObjects()) {
      return RestResponseUtil.createResponse403();
    }
    responseDecorator.decorateResponse(nsSearch);
    return RestResponseUtil.createResponse200(nsSearch);
  }
  return RestResponseUtil.createResponse404();
}",0.9806708357021034
37547,"/** 
 * generate DomainQueryParam.
 * @param domainName domain name.
 * @param punyDomainName domain puny name.
 * @return QueryParam.
 */
public QueryParam parseDomainQueryParam(String domainName,String punyDomainName){
  String punyName=DomainUtil.geneDomainPunyName(domainName);
  return new DomainQueryParam(domainName,punyName);
}","/** 
 * generate DomainQueryParam.
 * @param domainName domain name.
 * @param punyDomainName domain puny name.
 * @return QueryParam.
 */
public QueryParam parseDomainQueryParam(String domainName,String punyDomainName){
  return new DomainQueryParam(domainName,punyDomainName);
}",0.7739837398373983
37548,"/** 
 * generate NameserverQueryParam.
 * @param nsName nameserver name.
 * @param punyNSName nameserver puny name.
 * @return QueryParam.
 */
public QueryParam parseNameserverQueryParam(String nsName,String punyNSName){
  String punyName=DomainUtil.geneDomainPunyName(nsName);
  return new NameserverQueryParam(nsName,punyName);
}","/** 
 * generate NameserverQueryParam.
 * @param nsName nameserver name.
 * @param punyNSName nameserver puny name.
 * @return QueryParam.
 */
public QueryParam parseNameserverQueryParam(String nsName,String punyNSName){
  return new NameserverQueryParam(nsName,punyNSName);
}",0.771004942339374
37549,"@Override public List<Nameserver> queryAsInnerObjects(Long outerObjectId,ModelType outerModelType){
  List<Nameserver> listNameserver=queryNameserverWithDomainID(outerObjectId,outerModelType);
  final int sizeNameserver=listNameserver.size();
  for (int i=0; i < sizeNameserver; ++i) {
    queryAndSetInnerObjects(listNameserver.get(i));
  }
  return listNameserver;
}","@Override public List<Nameserver> queryAsInnerObjects(Long outerObjectId,ModelType outerModelType){
  List<Nameserver> listNameserver=queryNameserverWithDomainID(outerObjectId,outerModelType);
  if (listNameserver == null)   return null;
  final int sizeNameserver=listNameserver.size();
  for (int i=0; i < sizeNameserver; ++i) {
    queryAndSetInnerObjects(listNameserver.get(i));
  }
  return listNameserver;
}",0.942381562099872
37550,"/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String domainWithoutLastPoint=deleteLastPoint(punyDomainName);
  String[] splits=StringUtils.split(domainWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName)) {
    if (isLdh(domainName)) {
      return true;
    }
 else {
      return false;
    }
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}","/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint)) {
    if (isLdh(domainName)) {
      return true;
    }
 else {
      return false;
    }
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}",0.7710261569416499
37551,"/** 
 * query domain, without inner objects.
 * @param queryParam query parameter
 * @return autnum
 */
private Domain queryWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String domainName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      ps.setString(2,domainName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}","/** 
 * query domain, without inner objects.
 * @param queryParam query parameter
 * @return autnum
 */
private Domain queryWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}",0.9506101104009296
37552,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testSearchInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isBadRequest()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(400)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testSearchInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  mockMvc.perform(get(DOMAIN_SEARCH_URI + ""String_Node_Str"").accept(MediaType.parseMediaType(""String_Node_Str""))).andExpect(status().isUnprocessableEntity()).andExpect(content().contentType(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(422)).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str"")).andExpect(jsonPath(""String_Node_Str"").value(""String_Node_Str""));
}",0.974398758727696
37553,"/** 
 * test query exist event
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryExistEvent(){
  Long autnumId=1L;
  List<Event> events=eventQueryDao.queryAsInnerObjects(autnumId,ModelType.AUTNUM);
  Assert.notNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  Assert.notNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  assertEquals(dateFormat.format(event.getEventDate()),""String_Node_Str"");
}","/** 
 * test query exist event
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryExistEvent(){
  Long autnumId=1L;
  List<Event> events=eventQueryDao.queryAsInnerObjects(autnumId,ModelType.AUTNUM);
  Assert.notNull(events);
  assertEquals(events.size(),1);
  Event event=events.get(0);
  Assert.notNull(event);
  assertEquals(event.getEventAction(),""String_Node_Str"");
  assertEquals(event.getEventActor(),""String_Node_Str"");
  assertEquals(event.getEventDate(),""String_Node_Str"");
}",0.8703703703703703
37554,"/** 
 * get maxSigLife.
 * @return maxSigLife.
 */
public int getMaxSigLife(){
  return maxSigLife;
}","/** 
 * get maxSigLife.
 * @return maxSigLife.
 */
public Integer getMaxSigLife(){
  return maxSigLife;
}",0.970873786407767
37555,"/** 
 * set maxSigLife.
 * @param maxSigLife maxSigLife.
 */
public void setMaxSigLife(int maxSigLife){
  this.maxSigLife=maxSigLife;
}","/** 
 * set maxSigLife.
 * @param maxSigLife maxSigLife.
 */
public void setMaxSigLife(Integer maxSigLife){
  this.maxSigLife=maxSigLife;
}",0.978102189781022
37556,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
  String punyDomainName=decodeDomain;
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  Domain domain=queryService.queryDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domain) {
    responseDecorator.decorateResponse(domain);
    return RestResponseUtil.createResponse200(domain);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=domainName;
  String punyDomainName=decodeDomain;
  try {
    decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  Domain domain=queryService.queryDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domain) {
    responseDecorator.decorateResponse(domain);
    return RestResponseUtil.createResponse200(domain);
  }
  return RestResponseUtil.createResponse404();
}",0.952641878669276
37557,"/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String domainWithoutLastPoint=deleteLastPoint(punyDomainName);
  String[] splits=StringUtils.split(domainWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName)) {
    if (isLdh(domainName)) {
      return true;
    }
 else {
      return false;
    }
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}","/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  String punyDomainName=domainName;
  try {
    punyDomainName=geneDomainPunyName(domainName);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
  String punyWithoutLastPoint=deleteLastPoint(punyDomainName);
  if (!validateDomainLength(punyWithoutLastPoint)) {
    return false;
  }
  String domainNameWithoutLastPoint=deleteLastPoint(domainName);
  String[] splits=StringUtils.split(punyWithoutLastPoint,""String_Node_Str"");
  if (splits.length > MAX_DOMAIN_LABEL) {
    return false;
  }
  if (domainName.equals(punyDomainName) || domainNameWithoutLastPoint.equals(punyWithoutLastPoint)) {
    if (isLdh(domainName)) {
      return true;
    }
 else {
      return false;
    }
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}",0.7710261569416499
37558,"@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  if (StringUtils.isBlank(path)) {
    writeError400Response(response);
    return;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return;
  }
  try {
    decodeUri=urlDecode(uri);
    if (decodeUri.contains(""String_Node_Str"")) {
      writeError400Response(response);
      return;
    }
  }
 catch (  Exception e) {
    writeError400Response(response);
    return;
  }
  if (decodeUri.contains(""String_Node_Str"") || decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX)) {
      writeError400Response(response);
      return;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return;
    }
  }
  chain.doFilter(request,response);
}","@Override public void doFilter(ServletRequest arg0,ServletResponse arg1,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)arg0;
  HttpServletResponse response=(HttpServletResponse)arg1;
  decodeServletPathForSpringUrlMapping(request);
  String path=request.getRequestURI();
  if (StringUtils.isBlank(path)) {
    writeError400Response(response);
    return;
  }
  String decodeUri=StringUtils.EMPTY;
  String uri=path.substring(request.getContextPath().length());
  if (StringUtils.isBlank(uri)) {
    writeError400Response(response);
    return;
  }
  try {
    decodeUri=urlDecode(uri);
    if (decodeUri.contains(""String_Node_Str"")) {
      writeError400Response(response);
      return;
    }
  }
 catch (  Exception e) {
    writeError400Response(response);
    return;
  }
  if (decodeUri.contains(""String_Node_Str"") || decodeUri.contains(""String_Node_Str"")) {
    writeError400Response(response);
    return;
  }
  if (!""String_Node_Str"".equals(decodeUri)) {
    String uriWithoutPrefixSlash=decodeUri.substring(1,decodeUri.length());
    if (!uriWithoutPrefixSlash.startsWith(RDAP_URL_PREFIX)) {
      writeError400Response(response);
      return;
    }
 else     if (!uriWithoutPrefixSlash.equals(RDAP_URL_PREFIX + ""String_Node_Str"") && decodeUri.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return;
    }
 else     if (uriWithoutPrefixSlash.endsWith(""String_Node_Str"")) {
      writeError400Response(response);
      return;
    }
  }
  chain.doFilter(request,response);
}",0.9582228116710876
37559,"/** 
 * query domain, without inner objects.
 * @param queryParam query parameter
 * @return autnum
 */
private Domain queryWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String domainName=domainQueryParam.getQ();
  final String punyName=domainQueryParam.getPunyName();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      ps.setString(2,domainName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}","/** 
 * query domain, without inner objects.
 * @param queryParam query parameter
 * @return autnum
 */
private Domain queryWithoutInnerObjects(QueryParam queryParam){
  DomainQueryParam domainQueryParam=(DomainQueryParam)queryParam;
  final String punyName=domainQueryParam.getPunyName();
  final String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  List<Domain> result=jdbcTemplate.query(new PreparedStatementCreator(){
    public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql);
      ps.setString(1,punyName);
      return ps;
    }
  }
,new DomainWithStatusResultSetExtractor());
  if (null == result || result.size() == 0) {
    return null;
  }
  return result.get(0);
}",0.9506101104009296
37560,"/** 
 * check if domainName is valid ip v4 arpa domain.
 * @param domainName domain name.
 * @return true if is, false if not.
 */
private static boolean isIpV4ArpaTldAndLabelIsValid(String domainName){
  if (StringUtils.isBlank(domainName)) {
    return false;
  }
  if (!domainName.endsWith(IPV4_ARPA_SUFFIX)) {
    return false;
  }
  domainName=StringUtils.removeEndIgnoreCase(domainName,IPV4_ARPA_SUFFIX);
  String ipV4ArpaReg=""String_Node_Str"";
  if (domainName.matches(ipV4ArpaReg)) {
    return true;
  }
  return false;
}","/** 
 * check if domainName is valid ip v4 arpa domain.
 * @param domainName domain name.
 * @return true if domain is ipv4 arpa and label is valid; return false ifnot.
 */
private static boolean isIpV4ArpaTldAndLabelIsValid(String domainName){
  if (StringUtils.isBlank(domainName)) {
    return false;
  }
  if (!domainName.endsWith(IPV4_ARPA_SUFFIX)) {
    return false;
  }
  domainName=StringUtils.removeEndIgnoreCase(domainName,IPV4_ARPA_SUFFIX);
  String ipV4ArpaReg=""String_Node_Str"";
  if (domainName.matches(ipV4ArpaReg)) {
    return true;
  }
  return false;
}",0.9382940108892922
37561,"/** 
 * check if domainName is valid ip v6 arpa domain.
 * @param domainName domain name.
 * @return true if is, false if not.
 */
private static boolean isIpV6ArpaTldAndLabelIsValid(String domainName){
  if (StringUtils.isBlank(domainName)) {
    return false;
  }
  if (!domainName.endsWith(IPV6_ARPA_SUFFIX)) {
    return false;
  }
  domainName=StringUtils.removeEndIgnoreCase(domainName,IPV6_ARPA_SUFFIX);
  String ipV6ArpaReg=""String_Node_Str"";
  if (domainName.matches(ipV6ArpaReg)) {
    return true;
  }
  return false;
}","/** 
 * check if domainName is valid ip v6 arpa domain.
 * @param domainName domain name.
 * @return true if domain is ipv6 arpa and label is valid; return false ifnot.
 */
private static boolean isIpV6ArpaTldAndLabelIsValid(String domainName){
  if (StringUtils.isBlank(domainName)) {
    return false;
  }
  if (!domainName.endsWith(IPV6_ARPA_SUFFIX)) {
    return false;
  }
  domainName=StringUtils.removeEndIgnoreCase(domainName,IPV6_ARPA_SUFFIX);
  String ipV6ArpaReg=""String_Node_Str"";
  if (domainName.matches(ipV6ArpaReg)) {
    return true;
  }
  return false;
}",0.9382940108892922
37562,"/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  if (!domainName.startsWith(ACE_PREFIX) && isLdh(domainName)) {
    return true;
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!validateDomainLength(domainName)) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}","/** 
 * validate domain puny name is valid idna.
 * @param domainName domain name,ASCII char MUST in lower case.
 * @return true if is valid idna,false if not.
 */
public static boolean validateDomainNameIsValidIdna(String domainName){
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!isArpaTldAndLabelIsValid(domainName)) {
    return false;
  }
  if (isLdh(domainName)) {
    return true;
  }
  domainName=deleteLastPoint(domainName);
  if (StringUtils.isBlank(domainName) || !domainName.contains(""String_Node_Str"")) {
    return false;
  }
  if (!validateDomainLength(domainName)) {
    return false;
  }
  return IdnaUtil.isValidIdn(domainName);
}",0.952712100139082
37563,"/** 
 * check domain is valid ldh.
 * @param domain domain name.
 * @return true if is,false if not.
 */
private static boolean isLdh(String domain){
  if (StringUtils.isBlank(domain)) {
    return false;
  }
  if (domain.indexOf(""String_Node_Str"") == XN_PREFIX.length()) {
    return false;
  }
  String domainWithoutLastPoint=deleteLastPoint(domain);
  if (!validateDomainLength(domainWithoutLastPoint)) {
    return false;
  }
  String ldhReg=""String_Node_Str"" + ""String_Node_Str"";
  if (domainWithoutLastPoint.matches(ldhReg)) {
    return true;
  }
  return false;
}","/** 
 * check domain is valid ldh.
 * @param domain domain name.
 * @return true if is,false if not.
 */
private static boolean isLdh(String domain){
  if (StringUtils.isBlank(domain)) {
    return false;
  }
  String domainWithoutLastPoint=deleteLastPoint(domain);
  if (!validateDomainLength(domainWithoutLastPoint)) {
    return false;
  }
  String ldhReg=""String_Node_Str"" + ""String_Node_Str"";
  if (domainWithoutLastPoint.matches(ldhReg)) {
    return true;
  }
  return false;
}",0.6312796208530805
37564,"/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=DomainUtil.decodeAndTrim(domainName);
  String punyDomainName=decodeDomain;
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=DomainUtil.getLowerCaseByLabel(decodeDomain);
  Domain domain=queryService.queryDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domain) {
    responseDecorator.decorateResponse(domain);
    return RestResponseUtil.createResponse200(domain);
  }
  return RestResponseUtil.createResponse404();
}","/** 
 * query domain by domain name.
 * @param domainName is a fully-qualified (relative to the root) domain name [RFC1594] in either the in-addr.arpa or ip6.arpa zones (for RIRs) or a fully-qualified domain name in a zone administered by the server operator (for DNRs).
 * @return JSON formated result,with HTTP code.
 */
@RequestMapping(value={""String_Node_Str""},method=RequestMethod.GET) @ResponseBody public ResponseEntity queryDomain(@PathVariable String domainName){
  String decodeDomain=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(domainName);
  String punyDomainName=decodeDomain;
  try {
    punyDomainName=DomainUtil.geneDomainPunyName(decodeDomain);
  }
 catch (  Exception e) {
    return RestResponseUtil.createResponse400();
  }
  if (!DomainUtil.validateDomainNameIsValidIdna(decodeDomain)) {
    return RestResponseUtil.createResponse400();
  }
  decodeDomain=DomainUtil.deleteLastPoint(decodeDomain);
  decodeDomain=StringUtils.lowerCase(decodeDomain);
  Domain domain=queryService.queryDomain(queryParser.parseDomainQueryParam(decodeDomain,punyDomainName));
  if (null != domain) {
    responseDecorator.decorateResponse(domain);
    return RestResponseUtil.createResponse200(domain);
  }
  return RestResponseUtil.createResponse404();
}",0.9788760462335592
37565,"/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(DomainUtil.validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(DomainUtil.validateDomainNameIsValidIdna(domain));
  }
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(null));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrim(""String_Node_Str"")));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrim(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrim(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrim(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
}","/** 
 * test validateDomainNameIsValidIdna.
 */
@Test public void testValidateDomainNameIsValidIdna(){
  for (  String domain : validArpaDomain) {
    assertTrue(DomainUtil.validateDomainNameIsValidIdna(domain));
  }
  for (  String domain : inValidArpaDomain) {
    assertFalse(DomainUtil.validateDomainNameIsValidIdna(domain));
  }
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(null));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"")));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"")));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertTrue(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"")));
  assertFalse(DomainUtil.validateDomainNameIsValidIdna(""String_Node_Str""));
}",0.8845909955611921
37566,"/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrimDecodedStr(){
  String result=DomainUtil.decodeAndTrim(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
}","/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrimDecodedStr(){
  String result=DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
}",0.9343434343434344
37567,"/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrim(){
  String result=DomainUtil.decodeAndTrim(""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
}","/** 
 * test decodeAndTrim.
 */
@Test public void testDecodeAndTrim(){
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DomainUtil.decodeAndTrimAndReplaceAsciiToLowercase(""String_Node_Str""));
}",0.3268365817091454
37568,"/** 
 * init ErrorMessages list
 */
private static void initErrorMessages(){
  errorMessageMap=errorMessageService.getAllErrorMessageMap();
}","/** 
 * init ErrorMessages list
 */
public static void initErrorMessages(){
  errorMessageMap=errorMessageService.getAllErrorMessageMap();
}",0.9679715302491104
37569,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test public void testQueryInvalidDomain() throws Exception {
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryInvalidDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
  commonQueryInvalidDomain(""String_Node_Str"");
}",0.968959731543624
37570,"/** 
 * test query exist domain.
 * @throws Exception
 */
@Test public void testQueryNonExistDomain() throws Exception {
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
}","/** 
 * test query exist domain.
 * @throws Exception
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testQueryNonExistDomain() throws Exception {
  RestResponseUtil.initErrorMessages();
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
  commonQueryNonExistDomain(""String_Node_Str"");
}",0.9072681704260652
37571,"/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    String decodedURL=URLDecoder.decode(str,CHAR_SET_UTF8);
    URI uri=new URI(decodedURL);
    result=uri.toASCIIString();
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
  }
  return result;
}","/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    String decodedURL=URLDecoder.decode(str,CHAR_SET_UTF8);
    decodedURL=decodedURL.replaceAll(""String_Node_Str"",URLEncoder.encode(""String_Node_Str"",CHAR_SET_UTF8));
    URI uri=new URI(decodedURL);
    result=uri.toASCIIString();
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
  }
  return result;
}",0.8998144712430427
37572,"/** 
 * create response with HTTP status code 405
 * @param response model object
 * @return ResponseEntity
 */
public static ResponseEntity<ErrorMessage> createResponse405(){
  return createCommonErrorResponse(HttpStatus.METHOD_NOT_ALLOWED);
}","/** 
 * create response with HTTP status code 405
 * @param response model object
 * @return ResponseEntity
 */
public static ResponseEntity<ErrorMessage> createResponse405(){
  HttpHeaders headers=new HttpHeaders();
  Set<HttpMethod> allowMethods=new HashSet<HttpMethod>();
  allowMethods.add(HttpMethod.GET);
  headers.setAllow(allowMethods);
  ResponseEntity<ErrorMessage> response=createErrorResponseWithHeaders(HttpStatus.METHOD_NOT_ALLOWED,headers);
  return response;
}",0.6083333333333333
37573,"/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    String decodedURL=URLDecoder.decode(str,""String_Node_Str"");
    URL url=new URL(decodedURL);
    URI uri=new URI(url.getProtocol(),url.getUserInfo(),url.getHost(),url.getPort(),url.getPath(),url.getQuery(),url.getRef());
    result=uri.toASCIIString();
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
  }
  return result;
}","/** 
 * encoded url with UTF-8 encoding. This will escape protocol(eg:'http://') and '/'.
 * @param str string
 * @return String encoded string
 */
public static String urlEncode(String str){
  if (StringUtils.isBlank(str)) {
    return str;
  }
  String result=str;
  try {
    String decodedURL=URLDecoder.decode(str,CHAR_SET_UTF8);
    URI uri=new URI(decodedURL);
    result=uri.toASCIIString();
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
  }
  return result;
}",0.8058076225045372
37574,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  Autnum result=queryService.queryAutnum(queryParser.parseQueryParam(autnum));
  if (null != result) {
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ResponseEntity queryAs(@PathVariable String autnum,HttpServletRequest request,HttpServletResponse response){
  logger.info(""String_Node_Str"" + autnum);
  if (!AutnumValidator.isValidAutnum(autnum)) {
    return RestResponseUtil.createResponse400();
  }
  Autnum result=queryService.queryAutnum(queryParser.parseQueryParam(autnum));
  if (null != result) {
    responseDecorator.decorateResponse(result);
    return RestResponseUtil.createResponse200(result);
  }
  return RestResponseUtil.createResponse404();
}",0.9617777777777776
37575,"/** 
 * write response.
 * @param responseEntity
 * @param response
 * @throws IOException
 */
public static void writeResponse(ResponseEntity<ErrorMessage> responseEntity,HttpServletResponse response) throws IOException {
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setCharacterEncoding(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  response.setStatus(responseEntity.getStatusCode().value());
  String jsonStr=beanToJSON(responseEntity.getBody());
  writer.print(jsonStr);
}","/** 
 * write response.
 * @param responseEntity
 * @param response
 * @throws IOException
 */
public static void writeResponse(ResponseEntity<ErrorMessage> responseEntity,HttpServletResponse response) throws IOException {
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  HttpHeaders headers=responseEntity.getHeaders();
  Set<String> headerKeys=headers.keySet();
  for (  String headerKey : headerKeys) {
    List<String> headerValues=headers.get(headerKey);
    for (    String headerValue : headerValues) {
      response.setHeader(headerKey,headerValue);
    }
  }
  response.setCharacterEncoding(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  response.setStatus(responseEntity.getStatusCode().value());
  String jsonStr=beanToJSON(responseEntity.getBody());
  writer.print(jsonStr);
}",0.7766990291262136
37576,"/** 
 * test create ResponseEntity with HTTP code 405
 */
@Test public void testCreateResponse405(){
  ResponseEntity result=RestResponseUtil.createResponse405();
  Assert.notNull(result);
  assertEquals(result.getStatusCode(),HttpStatus.METHOD_NOT_ALLOWED);
}","/** 
 * test create ResponseEntity with HTTP code 405
 */
@Test public void testCreateResponse405(){
  ResponseEntity result=RestResponseUtil.createResponse405();
  Assert.notNull(result);
  assertEquals(result.getStatusCode(),HttpStatus.METHOD_NOT_ALLOWED);
  assertTrue(result.getHeaders().containsKey(""String_Node_Str""));
  assertThat(result.getHeaders().get(""String_Node_Str""),CoreMatchers.hasItems(HttpMethod.GET.toString()));
}",0.7503607503607503
37577,"/** 
 * create error response
 * @param errorStatus HttpStatus of error message
 * @return ResponseEntity
 */
private static ResponseEntity<ErrorMessage> createCommonErrorResponse(HttpStatus errorStatus){
  ErrorMessage errorMessage=getErrorMessageByErrorCode(errorStatus.toString());
  return new ResponseEntity<ErrorMessage>(errorMessage,errorStatus);
}","/** 
 * create error response
 * @param errorStatus HttpStatus of error message
 * @return ResponseEntity
 */
private static ResponseEntity<ErrorMessage> createCommonErrorResponse(HttpStatus errorStatus){
  ErrorMessage errorMessage=getErrorMessageByErrorCode(errorStatus.toString());
  RestResponseUtil.rdapConformanceService.setRdapConformance(errorMessage);
  return new ResponseEntity<ErrorMessage>(errorMessage,errorStatus);
}",0.9033078880407124
37578,"public ErrorMessage mapRow(ResultSet rs,int rowNum) throws SQLException {
  ErrorMessage errorMessage=new ErrorMessage();
  errorMessage.setErrorCode(rs.getLong(""String_Node_Str""));
  errorMessage.setTitle(rs.getString(""String_Node_Str""));
  errorMessage.addDescription(rs.getString(""String_Node_Str""));
  return errorMessage;
}","public ErrorMessage mapRow(ResultSet rs,int rowNum) throws SQLException {
  ErrorMessage errorMessage=new ErrorMessage();
  errorMessage.setErrorCode(rs.getLong(""String_Node_Str""));
  errorMessage.setTitle(rs.getString(""String_Node_Str""));
  errorMessage.addDescription(rs.getString(""String_Node_Str""));
  errorMessage.setLang(rs.getString(""String_Node_Str""));
  return errorMessage;
}",0.9200561009817672
37579,"/** 
 * get all erroMessage
 */
@Override public List<ErrorMessage> getAllErrorMessages(){
  final String sql=""String_Node_Str"";
  List<ErrorMessage> result=jdbcTemplate.query(sql,new RowMapper<ErrorMessage>(){
    public ErrorMessage mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      ErrorMessage errorMessage=new ErrorMessage();
      errorMessage.setErrorCode(rs.getLong(""String_Node_Str""));
      errorMessage.setTitle(rs.getString(""String_Node_Str""));
      errorMessage.addDescription(rs.getString(""String_Node_Str""));
      return errorMessage;
    }
  }
);
  return result;
}","/** 
 * get all erroMessage
 */
@Override public List<ErrorMessage> getAllErrorMessages(){
  final String sql=""String_Node_Str"";
  List<ErrorMessage> result=jdbcTemplate.query(sql,new RowMapper<ErrorMessage>(){
    public ErrorMessage mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      ErrorMessage errorMessage=new ErrorMessage();
      errorMessage.setErrorCode(rs.getLong(""String_Node_Str""));
      errorMessage.setTitle(rs.getString(""String_Node_Str""));
      errorMessage.addDescription(rs.getString(""String_Node_Str""));
      errorMessage.setLang(rs.getString(""String_Node_Str""));
      return errorMessage;
    }
  }
);
  return result;
}",0.9517022961203484
37580,"public Drawable getIcon(Context context){
  if (mIcon == null) {
    if (mApkFile.exists()) {
      mIcon=mInfo.loadIcon(context.getPackageManager());
      return mIcon;
    }
 else {
      mMounted=false;
    }
  }
 else   if (!mMounted) {
    if (mApkFile.exists()) {
      mMounted=true;
      mIcon=mInfo.loadIcon(context.getPackageManager());
      return mIcon;
    }
  }
 else {
    return mIcon;
  }
  Drawable drawable;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    drawable=context.getDrawable(android.R.drawable.sym_def_app_icon);
  }
 else {
    drawable=context.getResources().getDrawable(android.R.drawable.sym_def_app_icon);
  }
  return drawable;
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public Drawable getIcon(Context context){
  if (mIcon == null) {
    if (mApkFile.exists()) {
      mIcon=mInfo.loadIcon(context.getPackageManager());
      return mIcon;
    }
 else {
      mMounted=false;
    }
  }
 else   if (!mMounted) {
    if (mApkFile.exists()) {
      mMounted=true;
      mIcon=mInfo.loadIcon(context.getPackageManager());
      return mIcon;
    }
  }
 else {
    return mIcon;
  }
  Drawable drawable;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    drawable=context.getDrawable(android.R.drawable.sym_def_app_icon);
  }
 else {
    drawable=context.getResources().getDrawable(android.R.drawable.sym_def_app_icon);
  }
  return drawable;
}",0.9709837225760792
37581,"public void onTalkUpdated(final Talk talk){
  final int index=mFilteredData.indexOf(talk);
  if (index > 0) {
    notifyItemChanged(index);
  }
}","public void onTalkUpdated(@NonNull final Talk talk){
  for (int i=0; i < mFilteredData.size(); i++) {
    if (mFilteredData.get(i).getObjectId().equals(talk.getObjectId())) {
      notifyItemChanged(i);
      break;
    }
  }
}",0.510752688172043
37582,"/** 
 * Populates the set of favorites from its JSON representation, as returned from toJSON.
 */
private void setJSON(JSONObject json){
  JSONArray favorites=json.optJSONArray(""String_Node_Str"");
  if (favorites == null) {
    favorites=new JSONArray();
  }
  ArrayList<Talk> toRemove=new ArrayList<Talk>();
  for (  String objectId : talkIds) {
    Talk pointer=Talk.createWithoutData(Talk.class,objectId);
    toRemove.add(pointer);
  }
  for (  Talk talk : toRemove) {
    remove(talk);
  }
  for (int i=0; i < favorites.length(); ++i) {
    String objectId=favorites.optString(i);
    Talk pointer=Talk.createWithoutData(Talk.class,objectId);
    add(pointer);
  }
}","/** 
 * Populates the set of favorites from its JSON representation, as returned from toJSON.
 */
private void setJSON(JSONObject json){
  JSONArray favorites=json.optJSONArray(""String_Node_Str"");
  if (favorites == null) {
    favorites=new JSONArray();
  }
  ArrayList<Talk> toRemove=new ArrayList<>();
  for (  String objectId : talkIds) {
    Talk pointer=Talk.createWithoutData(Talk.class,objectId);
    toRemove.add(pointer);
  }
  for (  Talk talk : toRemove) {
    remove(talk);
  }
  for (int i=0; i < favorites.length(); ++i) {
    String objectId=favorites.optString(i);
    Talk pointer=Talk.createWithoutData(Talk.class,objectId);
    add(pointer);
  }
}",0.9970104633781764
37583,"/** 
 * Saves the current set of favorites to Parse, so that we can push to people based on what talks they have favorited, and also to measure which talks were the most favorited.
 */
private void saveToParse(){
  ArrayList<String> ids=new ArrayList<String>(talkIds);
  ParseInstallation.getCurrentInstallation().put(""String_Node_Str"",ids);
  ParseInstallation.getCurrentInstallation().saveEventually();
}","/** 
 * Saves the current set of favorites to Parse, so that we can push to people based on what talks they have favorited, and also to measure which talks were the most favorited.
 */
private void saveToParse(){
  ArrayList<String> ids=new ArrayList<>(talkIds);
  ParseInstallation.getCurrentInstallation().put(""String_Node_Str"",ids);
  ParseInstallation.getCurrentInstallation().saveEventually();
}",0.9925558312655088
37584,"/** 
 * Saves the current set of favorites to a SharedPreferences file. This method returns quickly, while the saving runs asynchronously.
 */
private void saveLocally(final Context context){
  final JSONObject json=toJSON();
  new AsyncTask<Void,Void,Exception>(){
    @Override protected Exception doInBackground(    Void... unused){
      try {
        String jsonString=json.toString();
        SharedPreferences prefs=context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
        prefs.edit().putString(""String_Node_Str"",jsonString).commit();
      }
 catch (      Exception e) {
        return e;
      }
      return null;
    }
    @Override protected void onPostExecute(    Exception error){
      if (error != null) {
        Toast toast=Toast.makeText(context,error.getMessage(),Toast.LENGTH_LONG);
        toast.show();
      }
    }
  }
.execute();
}","/** 
 * Saves the current set of favorites to a SharedPreferences file. This method returns quickly, while the saving runs asynchronously.
 */
private void saveLocally(final Context context){
  final JSONObject json=toJSON();
  new AsyncTask<Void,Void,Exception>(){
    @Override protected Exception doInBackground(    Void... unused){
      try {
        String jsonString=json.toString();
        SharedPreferences prefs=context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
        prefs.edit().putString(""String_Node_Str"",jsonString).apply();
      }
 catch (      Exception e) {
        return e;
      }
      return null;
    }
    @Override protected void onPostExecute(    Exception error){
      if (error != null) {
        Toast toast=Toast.makeText(context,error.getMessage(),Toast.LENGTH_LONG);
        toast.show();
      }
    }
  }
.execute();
}",0.993739328400683
37585,"public static Favorites get(){
  return instance;
}","public static Favorites get(){
  return INSTANCE;
}",0.8431372549019608
37586,"private void initParse(){
  ParseObject.registerSubclass(Room.class);
  ParseObject.registerSubclass(Slot.class);
  ParseObject.registerSubclass(Speaker.class);
  ParseObject.registerSubclass(Talk.class);
  ParseObject.registerSubclass(Event.class);
  ParseObject.registerSubclass(Location.class);
  ParseCrashReporting.enable(this);
  Parse.initialize(this,getParseApplicationId(),getParseClientKey());
  PushService.setDefaultPushCallback(this,MainActivity.class);
  Favorites.get().addListener(new FavoritesNotificationScheduler(this));
  Favorites.get().findLocally(this);
}","private void initParse(){
  ParseObject.registerSubclass(Room.class);
  ParseObject.registerSubclass(Slot.class);
  ParseObject.registerSubclass(Speaker.class);
  ParseObject.registerSubclass(Talk.class);
  ParseObject.registerSubclass(Event.class);
  ParseObject.registerSubclass(Location.class);
  ParseCrashReporting.enable(this);
  Parse.initialize(this,getParseApplicationId(),getParseClientKey());
  Favorites.get().addListener(new FavoritesNotificationScheduler(this));
  Favorites.get().findLocally(this);
}",0.9423604757548032
37587,"private void navigate(final int position){
switch (position) {
case NAV_ITEM_SCHEDULE:
    Fragment sched=TalkListFragment.newInstance(((BaseEventScheduleApp)getApplicationContext()).getParseEventId(),false);
  getSupportFragmentManager().beginTransaction().replace(R.id.content_frame,sched,""String_Node_Str"").commit();
break;
case NAV_ITEM_FAVORITES:
Fragment favs=TalkListFragment.newInstance(((BaseEventScheduleApp)getApplicationContext()).getParseEventId(),true);
getSupportFragmentManager().beginTransaction().replace(R.id.content_frame,favs,""String_Node_Str"").commit();
break;
case NAV_ITEM_EVENT_DETAILS:
startActivity(new Intent(this,EventDetailsActivity.class));
break;
case NAV_ITEM_LEGAL:
startActivity(new Intent(this,LegalActivity.class));
break;
default :
}
mNavPosition=position;
}","private void navigate(final int position){
switch (position) {
case NAV_ITEM_SCHEDULE:
    Fragment sched=TalkListFragment.newInstance(((BaseEventScheduleApp)getApplicationContext()).getParseEventId(),false);
  getSupportFragmentManager().beginTransaction().replace(R.id.content_frame,sched,""String_Node_Str"").commit();
mNavPosition=position;
break;
case NAV_ITEM_FAVORITES:
Fragment favs=TalkListFragment.newInstance(((BaseEventScheduleApp)getApplicationContext()).getParseEventId(),true);
getSupportFragmentManager().beginTransaction().replace(R.id.content_frame,favs,""String_Node_Str"").commit();
mNavPosition=position;
break;
case NAV_ITEM_EVENT_DETAILS:
startActivity(new Intent(this,EventDetailsActivity.class));
break;
case NAV_ITEM_LEGAL:
startActivity(new Intent(this,LegalActivity.class));
break;
default :
}
}",0.9572755417956657
37588,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_talk);
  final TalkDetailsFragment detailsFragment=TalkDetailsFragment.newInstance();
  getSupportFragmentManager().beginTransaction().add(R.id.container,detailsFragment).commit();
  String talkId=Talk.getTalkId(getIntent().getData());
  Talk.getInBackground(talkId,new GetCallback<Talk>(){
    @Override public void done(    final Talk talk,    ParseException e){
      if (e != null) {
        Toast.makeText(TalkActivity.this,e.getMessage(),Toast.LENGTH_LONG).show();
        return;
      }
      if (talk == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      detailsFragment.setTalk(talk);
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_talk);
  String talkId=Talk.getTalkId(getIntent().getData());
  Talk.getInBackground(talkId,new GetCallback<Talk>(){
    @Override public void done(    final Talk talk,    ParseException e){
      if (e != null) {
        Toast.makeText(TalkActivity.this,e.getMessage(),Toast.LENGTH_LONG).show();
        return;
      }
      if (talk == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      TalkDetailsFragment fragment=(TalkDetailsFragment)getSupportFragmentManager().findFragmentById(R.id.talk_details);
      fragment.setTalk(talk);
    }
  }
);
}",0.8040540540540541
37589,"@Override public void done(final Talk talk,ParseException e){
  if (e != null) {
    Toast.makeText(TalkActivity.this,e.getMessage(),Toast.LENGTH_LONG).show();
    return;
  }
  if (talk == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  detailsFragment.setTalk(talk);
}","@Override public void done(final Talk talk,ParseException e){
  if (e != null) {
    Toast.makeText(TalkActivity.this,e.getMessage(),Toast.LENGTH_LONG).show();
    return;
  }
  if (talk == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  TalkDetailsFragment fragment=(TalkDetailsFragment)getSupportFragmentManager().findFragmentById(R.id.talk_details);
  fragment.setTalk(talk);
}",0.8362573099415205
37590,"@Test public void clearingFields() throws InterruptedException {
  OfflineHelper.deleteDatabase(syncano.getAndroidContext(),SomeV2.class);
  createClass(SomeV2.class);
  SomeV2 obj=SomeV2.generateObject();
  assertTrue(obj.save().isSuccess());
  obj.clearField(SomeV2.FIELD_DATE).save();
  assertNull(obj.someDate);
  obj=SomeV2.generateObject();
  assertTrue(obj.saveDownloadedDataToStorage(true).save().isSuccess());
  obj.clearField(SomeV2.FIELD_DATE).mode(OfflineMode.LOCAL).save();
  assertNull(obj.someDate);
}","@Test public void clearingFields() throws InterruptedException {
  OfflineHelper.deleteDatabase(syncano.getAndroidContext(),SomeV2.class);
  createClass(SomeV2.class);
  SomeV2 obj=SomeV2.generateObject();
  assertTrue(obj.save().isSuccess());
  obj.clearField(SomeV2.FIELD_DATE).save();
  assertNull(obj.someDate);
  assertFalse(obj.hasAnyFieldsToClear());
  obj=SomeV2.generateObject();
  assertTrue(obj.saveDownloadedDataToStorage(true).save().isSuccess());
  obj.clearField(SomeV2.FIELD_DATE).mode(OfflineMode.LOCAL).save();
  assertNull(obj.someDate);
  assertFalse(obj.hasAnyFieldsToClear());
  obj=SomeV2.generateObject();
  assertTrue(obj.saveDownloadedDataToStorage(true).save().isSuccess());
  final CountDownLatch latch=new CountDownLatch(1);
  obj.clearField(SomeV2.FIELD_DATE).mode(OfflineMode.LOCAL_ONLINE_IN_BACKGROUND).backgroundCallback(new SyncanoCallback<SomeV2>(){
    @Override public void success(    Response<SomeV2> response,    SomeV2 result){
      assertNull(result.someDate);
      assertFalse(result.hasAnyFieldsToClear());
      latch.countDown();
    }
    @Override public void failure(    Response<SomeV2> response){
      fail();
    }
  }
).save();
  assertNull(obj.someDate);
  latch.await(10,TimeUnit.SECONDS);
  assertEquals(0,latch.getCount());
  obj=SomeV2.generateObject();
  assertTrue(obj.saveDownloadedDataToStorage(true).save().isSuccess());
  Response<SomeV2> resp=obj.clearField(SomeV2.FIELD_DATE).mode(OfflineMode.LOCAL_WHEN_ONLINE_FAILED).save();
  assertNull(obj.someDate);
  assertFalse(obj.hasAnyFieldsToClear());
  assertFalse(resp.isDataFromLocalStorage());
  obj=SomeV2.generateObject();
  assertTrue(obj.saveDownloadedDataToStorage(true).save().isSuccess());
  new SyncanoBuilder().instanceName(""String_Node_Str"").apiKey(""String_Node_Str"").androidContext(getContext()).setAsGlobalInstance(true).build();
  resp=obj.clearField(SomeV2.FIELD_DATE).mode(OfflineMode.LOCAL_WHEN_ONLINE_FAILED).save();
  assertNull(obj.someDate);
  assertFalse(obj.hasAnyFieldsToClear());
  assertTrue(resp.isDataFromLocalStorage());
}",0.3993808049535604
37591,"@Override public void success(ResponseGetList<SomeV2> response,List<SomeV2> result){
  assertEquals(number,result.size());
}","@Override public void success(Response<SomeV2> response,SomeV2 result){
  assertNull(result.someDate);
  assertFalse(result.hasAnyFieldsToClear());
  latch.countDown();
}",0.673469387755102
37592,"@Override public void failure(ResponseGetList<SomeV2> response){
  fail();
}","@Override public void failure(Response<SomeV2> response){
  fail();
}",0.9517241379310344
37593,"private InputStream getStringFieldsInputStream() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  JsonObject json=gson.toJsonTree(data).getAsJsonObject();
  ((SyncanoObject)data).getIncrementBuilder().build(json);
  for (  Map.Entry<String,JsonElement> entry : json.entrySet()) {
    baos.write((twoHyphens + boundary + lineEnd).getBytes(UTF8));
    baos.write((""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ lineEnd).getBytes(UTF8));
    baos.write((""String_Node_Str"" + lineEnd).getBytes(UTF8));
    baos.write(lineEnd.getBytes(UTF8));
    baos.write((GsonParser.getJsonElementAsString(entry.getValue())).getBytes(UTF8));
    baos.write(lineEnd.getBytes(UTF8));
  }
  ((SyncanoObject)data).resetRequestBuildingFields();
  return new ByteArrayInputStream(baos.toByteArray());
}","private InputStream getStringFieldsInputStream() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  JsonObject json=gson.toJsonTree(data).getAsJsonObject();
  ((SyncanoObject)data).getIncrementBuilder().build(json);
  for (  Map.Entry<String,JsonElement> entry : json.entrySet()) {
    baos.write((twoHyphens + boundary + lineEnd).getBytes(UTF8));
    baos.write((""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ lineEnd).getBytes(UTF8));
    baos.write((""String_Node_Str"" + lineEnd).getBytes(UTF8));
    baos.write(lineEnd.getBytes(UTF8));
    baos.write((GsonParser.getJsonElementAsString(entry.getValue())).getBytes(UTF8));
    baos.write(lineEnd.getBytes(UTF8));
  }
  return new ByteArrayInputStream(baos.toByteArray());
}",0.965865992414665
37594,"protected SendRequest(Class<T> resultType,String url,Syncano syncano,Object data){
  super(resultType,url,syncano);
  updateGivenObject(false);
  this.data=data;
  if (data != null) {
    gson=GsonParser.createGson(data);
  }
 else {
    gson=GsonParser.createGson(resultType);
  }
}","protected SendRequest(Class<T> resultType,String url,Syncano syncano,Object data){
  super(resultType,url,syncano);
  updateGivenObject(false);
  this.data=data;
  if (data != null) {
    gson=GsonParser.createGson(data);
  }
 else {
    gson=GsonParser.createGson(resultType);
  }
  super.setRunAfter(clearFieldsRunAfter);
}",0.930921052631579
37595,"@Override public Response<T> send(){
  return doOnlineRequest(onlineRequest,cleanStorageOnSuccessDownload,saveDownloadedDataToStorage);
}","@Override public Response<T> send(){
  Response<T> response=doOnlineRequest(onlineRequest,cleanStorageOnSuccessDownload,saveDownloadedDataToStorage);
  afterRequests(onlineRequest);
  return response;
}",0.7669616519174042
37596,"@Override public Response<T> doLocalRequest(ResultRequest<T> request){
  SyncanoObject data=request.getResultObject();
  if (data == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (data.getIncrementBuilder().hasAdditionFields()) {
    Log.e(OfflineSaveRequest.class.getSimpleName(),""String_Node_Str"");
  }
  if (data.getId() == null || data.getId() == 0) {
    data.setId(null);
  }
  Context ctx=getSyncano().getAndroidContext();
  OfflineHelper.writeObjects(ctx,Collections.singletonList(data),request.getResultType());
  Response<T> response=new Response<>();
  response.setData((T)data).setDataFromLocalStorage(true).setResultCode(Response.CODE_SUCCESS);
  return response;
}","@Override public Response<T> doLocalRequest(ResultRequest<T> request){
  SyncanoObject data=request.getResultObject();
  if (data == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (data.getIncrementBuilder().hasAdditionFields()) {
    Log.e(OfflineSaveRequest.class.getSimpleName(),""String_Node_Str"");
  }
  Collection<Field> fields=SyncanoClassHelper.findAllSyncanoFields(data.getClass());
  for (  Field f : fields) {
    if (data.isOnClearList(SyncanoClassHelper.getFieldName(f))) {
      f.setAccessible(true);
      try {
        f.set(data,null);
      }
 catch (      IllegalAccessException e) {
        e.printStackTrace();
      }
    }
  }
  if (data.getId() == null || data.getId() == 0) {
    data.setId(null);
  }
  Context ctx=getSyncano().getAndroidContext();
  OfflineHelper.writeObjects(ctx,Collections.singletonList(data),request.getResultType());
  Response<T> response=new Response<>();
  response.setData((T)data).setDataFromLocalStorage(true).setResultCode(Response.CODE_SUCCESS);
  return response;
}",0.8027522935779816
37597,"@Test public void testClearing() throws InterruptedException {
  createClass(Author.class);
  createClass(AllTypesObject.class);
  AllTypesObject obj=new AllTypesObject();
  assertTrue(obj.save().isSuccess());
  AllTypesObject.generateObject(obj);
  assertTrue(obj.someReference.save().isSuccess());
  obj.reference=obj;
  assertTrue(obj.save().isSuccess());
  obj.clearAll();
  assertTrue(obj.save().isSuccess());
  obj.checkEquals(new AllTypesObject(),false);
}","@Test public void testClearing() throws InterruptedException {
  createClass(Author.class);
  createClass(AllTypesObject.class);
  AllTypesObject obj=new AllTypesObject();
  assertTrue(obj.save().isSuccess());
  AllTypesObject.generateObject(obj);
  assertTrue(obj.someReference.save().isSuccess());
  obj.reference=obj;
  assertTrue(obj.save().isSuccess());
  obj.clearAll();
  assertTrue(obj.save().isSuccess());
  obj.checkEquals(new AllTypesObject(),false);
  assertFalse(obj.hasAnyFieldsToClear());
}",0.956611570247934
37598,"public static void saveUserToStorage(Syncano syncano,AbstractUser user){
  if (syncano.getAndroidContext() == null || !(PlatformType.get() instanceof PlatformType.AndroidPlatform)) {
    return;
  }
  SharedPreferences prefs=syncano.getAndroidContext().getSharedPreferences(Syncano.class.getSimpleName(),Context.MODE_PRIVATE);
  SharedPreferences.Editor editor=prefs.edit();
  if (user == null) {
    editor.remove(dataKey(syncano));
    editor.remove(typeKey(syncano));
  }
 else {
    GsonParser.GsonParseConfig config=new GsonParser.GsonParseConfig();
    config.serializeReadOnlyFields=true;
    Gson gson=GsonParser.createGson(config);
    editor.putString(dataKey(syncano),gson.toJson(user));
    editor.putString(typeKey(syncano),user.getClass().getName());
  }
  editor.apply();
}","public static void saveUserToStorage(Syncano syncano,AbstractUser user){
  if (syncano.getAndroidContext() == null || !(PlatformType.get() instanceof PlatformType.AndroidPlatform)) {
    return;
  }
  SharedPreferences prefs=syncano.getAndroidContext().getSharedPreferences(Syncano.class.getSimpleName(),Context.MODE_PRIVATE);
  SharedPreferences.Editor editor=prefs.edit();
  if (user == null) {
    editor.remove(dataKey(syncano));
    editor.remove(typeKey(syncano));
  }
 else {
    GsonParser.GsonParseConfig config=new GsonParser.GsonParseConfig();
    config.serializeReadOnlyFields=true;
    Gson gson=GsonParser.createGson(user.getClass(),config);
    editor.putString(dataKey(syncano),gson.toJson(user));
    editor.putString(typeKey(syncano),user.getClass().getName());
  }
  editor.apply();
}",0.9899497487437184
37599,"public static <T>Gson createGson(final T object,GsonParseConfig config){
  GsonBuilder gsonBuilder=new GsonBuilder();
  gsonBuilder.registerTypeAdapter(NanosDate.class,new DateSerializer());
  gsonBuilder.registerTypeAdapter(NanosDate.class,new DateDeserializer());
  gsonBuilder.registerTypeAdapter(Date.class,new DateSerializer());
  gsonBuilder.registerTypeAdapter(Date.class,new DateDeserializer());
  gsonBuilder.registerTypeAdapter(SyncanoHashSet.class,new SyncanoHashSetDeserializer());
  gsonBuilder.registerTypeAdapter(SyncanoHashSet.class,new SyncanoHashSetSerializer());
  gsonBuilder.registerTypeAdapter(SyncanoFile.class,new FileDeserializer());
  gsonBuilder.setFieldNamingStrategy(new SyncanoFieldNamingStrategy());
  gsonBuilder.registerTypeHierarchyAdapter(SyncanoObject.class,new SyncanoObjectDeserializer(object));
  gsonBuilder.registerTypeHierarchyAdapter(SyncanoObject.class,new SyncanoObjectSerializer());
  if (object != null && !(object instanceof SyncanoObject)) {
    gsonBuilder.registerTypeAdapter(object.getClass(),new InstanceCreator<T>(){
      @Override public T createInstance(      Type type){
        return object;
      }
    }
);
  }
  return gsonBuilder.create();
}","public static <T>Gson createGson(final T object,GsonParseConfig config){
  GsonBuilder gsonBuilder=new GsonBuilder();
  gsonBuilder.registerTypeAdapter(NanosDate.class,new DateSerializer());
  gsonBuilder.registerTypeAdapter(NanosDate.class,new DateDeserializer());
  gsonBuilder.registerTypeAdapter(Date.class,new DateSerializer());
  gsonBuilder.registerTypeAdapter(Date.class,new DateDeserializer());
  gsonBuilder.registerTypeAdapter(SyncanoHashSet.class,new SyncanoHashSetDeserializer());
  gsonBuilder.registerTypeAdapter(SyncanoHashSet.class,new SyncanoHashSetSerializer());
  gsonBuilder.registerTypeAdapter(SyncanoFile.class,new FileDeserializer());
  gsonBuilder.setFieldNamingStrategy(new SyncanoFieldNamingStrategy());
  gsonBuilder.registerTypeHierarchyAdapter(SyncanoObject.class,new SyncanoObjectDeserializer(object));
  gsonBuilder.registerTypeHierarchyAdapter(SyncanoObject.class,new SyncanoObjectSerializer(config.serializeReadOnlyFields));
  if (object != null && !(object instanceof SyncanoObject)) {
    gsonBuilder.registerTypeAdapter(object.getClass(),new InstanceCreator<T>(){
      @Override public T createInstance(      Type type){
        return object;
      }
    }
);
  }
  return gsonBuilder.create();
}",0.9877049180327868
37600,"private SyncanoObject createSyncanoObject(Class<? extends SyncanoObject> clazz){
  try {
    Constructor<? extends SyncanoObject> defaultConstructor=clazz.getConstructor();
    return defaultConstructor.newInstance();
  }
 catch (  Exception e) {
    return new Gson().fromJson(""String_Node_Str"",clazz);
  }
}","private SyncanoObject createSyncanoObject(Class<? extends SyncanoObject> clazz){
  try {
    Constructor<? extends SyncanoObject> defaultConstructor=clazz.getConstructor();
    defaultConstructor.setAccessible(true);
    return defaultConstructor.newInstance();
  }
 catch (  Exception e) {
    Gson gson=new GsonBuilder().setFieldNamingStrategy(new SyncanoFieldNamingStrategy()).create();
    return gson.fromJson(""String_Node_Str"",clazz);
  }
}",0.7947019867549668
37601,"public JsonElement serialize(SyncanoObject localObject,Type type,JsonSerializationContext jsc){
  JsonObject jsonObject=new JsonObject();
  Collection<Field> fields=SyncanoClassHelper.findAllSyncanoFields(localObject.getClass());
  for (  Field field : fields) {
    field.setAccessible(true);
    try {
      String keyName=SyncanoClassHelper.getFieldName(field);
      JsonElement jsonElement=toJsonObject(localObject,field,jsc);
      jsonObject.add(keyName,jsonElement);
    }
 catch (    IllegalAccessException e) {
      e.printStackTrace();
    }
  }
  return jsonObject;
}","public JsonElement serialize(SyncanoObject localObject,Type type,JsonSerializationContext jsc){
  JsonObject jsonObject=new JsonObject();
  Collection<Field> fields=SyncanoClassHelper.findAllSyncanoFields(localObject.getClass());
  for (  Field field : fields) {
    field.setAccessible(true);
    if (shouldSkipField(field))     continue;
    try {
      String keyName=SyncanoClassHelper.getFieldName(field);
      JsonElement jsonElement=toJsonObject(localObject,field,jsc);
      jsonObject.add(keyName,jsonElement);
    }
 catch (    IllegalAccessException e) {
      e.printStackTrace();
    }
  }
  return jsonObject;
}",0.9618573797678276
37602,"public static void saveUserToStorage(Syncano syncano,AbstractUser user){
  if (syncano.getAndroidContext() == null || !(PlatformType.get() instanceof PlatformType.AndroidPlatform)) {
    return;
  }
  SharedPreferences prefs=syncano.getAndroidContext().getSharedPreferences(Syncano.class.getSimpleName(),Context.MODE_PRIVATE);
  SharedPreferences.Editor editor=prefs.edit();
  if (user == null) {
    editor.remove(dataKey(syncano));
    editor.remove(typeKey(syncano));
  }
 else {
    GsonParser.GsonParseConfig config=new GsonParser.GsonParseConfig();
    config.readOnlyNotImportant=true;
    Gson gson=GsonParser.createGson(config);
    editor.putString(dataKey(syncano),gson.toJson(user));
    editor.putString(typeKey(syncano),user.getClass().getName());
  }
  editor.apply();
}","public static void saveUserToStorage(Syncano syncano,AbstractUser user){
  if (syncano.getAndroidContext() == null || !(PlatformType.get() instanceof PlatformType.AndroidPlatform)) {
    return;
  }
  SharedPreferences prefs=syncano.getAndroidContext().getSharedPreferences(Syncano.class.getSimpleName(),Context.MODE_PRIVATE);
  SharedPreferences.Editor editor=prefs.edit();
  if (user == null) {
    editor.remove(dataKey(syncano));
    editor.remove(typeKey(syncano));
  }
 else {
    GsonParser.GsonParseConfig config=new GsonParser.GsonParseConfig();
    config.serializeReadOnlyFields=true;
    Gson gson=GsonParser.createGson(config);
    editor.putString(dataKey(syncano),gson.toJson(user));
    editor.putString(typeKey(syncano),user.getClass().getName());
  }
  editor.apply();
}",0.7679593134138589
37603,"@Test public void testChangeReferenceToPlainObject(){
  Book book=createPlainBook();
  Author author=createPlainAuthor();
  book.author=author;
  Response authorSave=author.save();
  assertTrue(authorSave.isSuccess());
  Response bookSaveResponse=book.save();
  assertTrue(bookSaveResponse.isSuccess());
  assertNotNull(book.author);
  Author otherAuthor=new Author();
  otherAuthor.name=""String_Node_Str"";
  book.author=otherAuthor;
  book.fetch();
  assertTrue(book.author.isDirty());
}","@Test public void testChangeReferenceToPlainObject(){
  Book book=createPlainBook();
  Author author=createPlainAuthor();
  book.author=author;
  Response authorSave=author.save();
  assertTrue(authorSave.isSuccess());
  Response bookSaveResponse=book.save();
  assertTrue(bookSaveResponse.isSuccess());
  assertNotNull(book.author);
  Author otherAuthor=new Author();
  otherAuthor.name=""String_Node_Str"";
  book.author=otherAuthor;
  book.fetch();
  assertTrue(book.author.isDirty());
  assertTrue(book.author != otherAuthor);
}",0.9587426326129664
37604,"@Test public void testDataTypes(){
  syncano.deleteSyncanoClass(MultiTypesObject.class).send();
  Response<SyncanoClass> respClass=syncano.createSyncanoClass(MultiTypesObject.class).send();
  assertTrue(respClass.isSuccess());
  MultiTypesObject obj1=generateMultiTypesObject();
  Response<MultiTypesObject> resp1=syncano.createObject(obj1).send();
  assertTrue(resp1.isSuccess());
  assertTrue(obj1.reference.save().isSuccess());
  MultiTypesObject serverObj1=resp1.getData();
  assertNotNull(serverObj1);
  assertEquals(obj1.intVal,serverObj1.intVal);
  assertEquals(obj1.byteVal,serverObj1.byteVal);
  assertEquals(obj1.shortVal,serverObj1.shortVal);
  assertEquals(obj1.date,serverObj1.date);
  assertEquals(obj1.nanosDate,serverObj1.nanosDate);
  assertEquals(obj1.stringVal.length(),serverObj1.stringVal.length());
  assertEquals(obj1.stringVal,serverObj1.stringVal);
  assertEquals(obj1.text.length(),serverObj1.text.length());
  assertEquals(obj1.text,serverObj1.text);
  assertNotNull(obj1.reference.getId());
  assertEquals(obj1.reference.getId(),serverObj1.reference.getId());
  assertEquals(obj1.yesOrNo,serverObj1.yesOrNo);
}","@Test public void testDataTypes(){
  syncano.deleteSyncanoClass(MultiTypesObject.class).send();
  Response<SyncanoClass> respClass=syncano.createSyncanoClass(MultiTypesObject.class).send();
  assertTrue(respClass.isSuccess());
  MultiTypesObject obj1=generateMultiTypesObject();
  MultiTypesObject obj2=generateMultiTypesObject();
  assertTrue(obj2.save().isSuccess());
  obj1.reference=obj2;
  Response<MultiTypesObject> resp1=syncano.createObject(obj1).send();
  assertTrue(resp1.isSuccess());
  assertTrue(obj1.reference.save().isSuccess());
  MultiTypesObject serverObj1=resp1.getData();
  assertNotNull(serverObj1);
  assertEquals(obj1.intVal,serverObj1.intVal);
  assertEquals(obj1.byteVal,serverObj1.byteVal);
  assertEquals(obj1.shortVal,serverObj1.shortVal);
  assertEquals(obj1.date,serverObj1.date);
  assertEquals(obj1.nanosDate,serverObj1.nanosDate);
  assertEquals(obj1.stringVal.length(),serverObj1.stringVal.length());
  assertEquals(obj1.stringVal,serverObj1.stringVal);
  assertEquals(obj1.text.length(),serverObj1.text.length());
  assertEquals(obj1.text,serverObj1.text);
  assertNotNull(obj1.reference.getId());
  assertEquals(obj1.reference.getId(),serverObj1.reference.getId());
  assertEquals(obj1.yesOrNo,serverObj1.yesOrNo);
}",0.9523012552301257
37605,"@Test public void testSyncanoGetView(){
  ResponseGetList<Warrior> warriorsFromView=syncano.getViewObjects(Warrior.class,tableName).send();
  assertTrue(warriorsFromView.isSuccess());
  ResponseGetList<Warrior> warriors=syncano.getObjects(Warrior.class).send();
  assertTrue(warriors.isSuccess());
  assertFalse(warriorsFromView.getData().isEmpty());
  Warrior warrior=warriorsFromView.getData().get(0);
  assertNotNull(warrior.inventory);
  assertNotNull(warrior.inventory.getId());
  warrior.fetch();
  assertNotNull(warrior.inventory.getId());
  assertNull(warrior.inventory.armor);
  warrior.inventory.fetch();
  assertNotNull(warrior.inventory.armor);
}","@Test public void testSyncanoGetView(){
  ResponseGetList<Warrior> warriorsFromView=syncano.getViewObjects(Warrior.class,tableName).send();
  assertTrue(warriorsFromView.isSuccess());
  ResponseGetList<Warrior> warriors=syncano.getObjects(Warrior.class).send();
  assertTrue(warriors.isSuccess());
  assertFalse(warriorsFromView.getData().isEmpty());
  Warrior warrior=warriorsFromView.getData().get(0);
  assertNotNull(warrior.inventory);
  assertNotNull(warrior.inventory.getId());
  warrior.fetch();
  assertNotNull(warrior.inventory.getId());
  warrior.inventory.fetch();
  assertNotNull(warrior.inventory.armor);
}",0.9021143304620204
37606,"public static void main(String[] args){
  Request r=null;
  final RequestPromise<Collection<Book>> listRequestPromise=r.get(Book.class,List.class);
  listRequestPromise.done(new DoneCallback<Collection<Book>>(){
    @Override public void onDone(    Collection<Book> result){
      List<Book> list=(List<Book>)result;
    }
  }
);
  listRequestPromise.always(new AlwaysCallback<Collection<Book>,Throwable,ResponseContext>(){
    @Override public void onAlways(    ResponseContext context,    Collection<Book> resolved,    Throwable rejected){
    }
  }
);
}","public static void main(String[] args){
  RequestDispatcher r=null;
  final RequestPromise<Collection<Book>> listRequestPromise=r.get(Book.class,List.class);
  listRequestPromise.done(new DoneCallback<Collection<Book>>(){
    @Override public void onDone(    Collection<Book> result){
      List<Book> list=(List<Book>)result;
    }
  }
);
  listRequestPromise.always(new AlwaysCallback<Collection<Book>,Throwable,ResponseContext>(){
    @Override public void onAlways(    ResponseContext context,    Collection<Book> resolved,    Throwable rejected){
    }
  }
);
}",0.9910873440285204
37607,"/** 
 * 与えられたソースについて、一連の実行を行う。
 * @param src Reader型で表されたソース
 * @param unitName ファイル名。インラインコードのキャッシュはこの名前ベースで管理される。
 */
private static void run(Reader src,String unitName){
  if (Env.preProcess0) {
    src=preProcess0(src);
  }
  try {
    Env.clearErrors();
    compile.structure.Membrane m=null;
    try {
      LMNParser lp=new LMNParser(src);
      m=lp.parse();
    }
 catch (    ParseException e) {
      Env.p(""String_Node_Str"");
      Env.e(e.getMessage());
      System.exit(1);
    }
    if (Env.fType) {
      if (!analyseTypes(m)) {
        System.exit(1);
      }
    }
    Ruleset rs=RulesetCompiler.compileMembrane(m,unitName);
    if (Env.getErrorCount() > 0) {
      Env.e(""String_Node_Str"");
      System.exit(1);
    }
    if (Env.compileRule) {
      try {
        List<Ruleset> rulesets=m.rulesets;
        InterpretedRuleset r=(InterpretedRuleset)rulesets.get(0);
        r.rules.get(0).showDetail();
      }
 catch (      Exception e) {
        Env.e(""String_Node_Str"");
        System.exit(1);
      }
    }
 else {
      showIL((InterpretedRuleset)rs,m);
    }
    if (Env.compileonly) {
      for (      String libName : Module.loaded) {
        compile.structure.Membrane mem=(compile.structure.Membrane)Module.memNameTable.get(libName);
        for (        Ruleset r : mem.rulesets) {
          ((InterpretedRuleset)r).showDetail();
        }
      }
      Module.showModuleList();
      Inline.initInline();
      Inline.showInlineList();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}","/** 
 * 与えられたソースについて、一連の実行を行う。
 * @param src Reader型で表されたソース
 * @param unitName ファイル名。インラインコードのキャッシュはこの名前ベースで管理される。
 */
private static void run(Reader src,String unitName){
  if (Env.preProcess0) {
    src=preProcess0(src);
  }
  try {
    Env.clearErrors();
    compile.structure.Membrane m=null;
    try {
      LMNParser lp=new LMNParser(src);
      m=lp.parse();
    }
 catch (    ParseException e) {
      Env.p(""String_Node_Str"");
      Env.e(e.getMessage());
      System.exit(1);
    }
    if (Env.fType) {
      if (!analyseTypes(m)) {
        System.exit(1);
      }
    }
    Ruleset rs=RulesetCompiler.compileMembrane(m,unitName);
    if (Env.getErrorCount() > 0) {
      Env.e(""String_Node_Str"");
      System.exit(1);
    }
    if (Env.compileRule) {
      try {
        List<Ruleset> rulesets=m.rulesets;
        InterpretedRuleset r=(InterpretedRuleset)rulesets.get(0);
        r.rules.get(0).showDetail();
      }
 catch (      Exception e) {
        Env.e(""String_Node_Str"");
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      showIL((InterpretedRuleset)rs,m);
    }
    if (Env.compileonly) {
      for (      String libName : Module.loaded) {
        compile.structure.Membrane mem=(compile.structure.Membrane)Module.memNameTable.get(libName);
        for (        Ruleset r : mem.rulesets) {
          ((InterpretedRuleset)r).showDetail();
        }
      }
      Module.showModuleList();
      Inline.initInline();
      Inline.showInlineList();
      System.exit(0);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
}",0.9860406091370558
37608,"/** 
 * Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.
 * @return      the next token
 * @exception IOException  if any I/O-Error occurs
 */
public java_cup.runtime.Symbol next_token() throws java.io.IOException {
  int yy_input;
  int yy_action;
  int yy_currentPos_l;
  int yy_markedPos_l;
  int yy_endRead_l=yy_endRead;
  char[] yy_buffer_l=yy_buffer;
  char[] yycmap_l=yycmap;
  int[] yytrans_l=yytrans;
  int[] yy_rowMap_l=yy_rowMap;
  int[] yy_attr_l=YY_ATTRIBUTE;
  while (true) {
    yy_markedPos_l=yy_markedPos;
    boolean yy_r=false;
    for (yy_currentPos_l=yy_startRead; yy_currentPos_l < yy_markedPos_l; yy_currentPos_l++) {
switch (yy_buffer_l[yy_currentPos_l]) {
case '\u000B':
case '\u000C':
case '\u0085':
case '\u2028':
case '\u2029':
        yyline++;
      yycolumn=0;
    yy_r=false;
  break;
case '\r':
yyline++;
yycolumn=0;
yy_r=true;
break;
case '\n':
if (yy_r) yy_r=false;
 else {
yyline++;
yycolumn=0;
}
break;
default :
yy_r=false;
yycolumn++;
}
}
if (yy_r) {
boolean yy_peek;
if (yy_markedPos_l < yy_endRead_l) yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
 else if (yy_atEOF) yy_peek=false;
 else {
boolean eof=yy_refill();
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
if (eof) yy_peek=false;
 else yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
}
if (yy_peek) yyline--;
}
yy_action=-1;
yy_currentPos_l=yy_currentPos=yy_startRead=yy_markedPos_l;
yy_state=yy_lexical_state;
yy_forAction: {
while (true) {
if (yy_currentPos_l < yy_endRead_l) yy_input=yy_buffer_l[yy_currentPos_l++];
 else if (yy_atEOF) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_currentPos=yy_currentPos_l;
yy_markedPos=yy_markedPos_l;
boolean eof=yy_refill();
yy_currentPos_l=yy_currentPos;
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
yy_endRead_l=yy_endRead;
if (eof) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_input=yy_buffer_l[yy_currentPos_l++];
}
}
int yy_next=yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
if (yy_next == -1) break yy_forAction;
yy_state=yy_next;
int yy_attributes=yy_attr_l[yy_state];
if ((yy_attributes & 1) == 1) {
yy_action=yy_state;
yy_markedPos_l=yy_currentPos_l;
if ((yy_attributes & 8) == 8) break yy_forAction;
}
}
}
yy_markedPos=yy_markedPos_l;
switch (yy_action < 0 ? yy_action : YY_ACTION[yy_action]) {
case 22:
{
return symbol(sym.GUARD);
}
case 62:
break;
case 60:
{
return symbol(sym.CHAR_CODE_LITERAL,yytext());
}
case 63:
break;
case 34:
{
return symbol(sym.MINUS_DOT);
}
case 64:
break;
case 48:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.SYMBOL_NAME,string.toString(),token.toString(),startline,startcol);
}
case 65:
break;
case 45:
{
return symbol(sym.RBRACE_UNDERBAR);
}
case 66:
break;
case 18:
{
return symbol(sym.RPAREN);
}
case 67:
break;
case 52:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 68:
break;
case 41:
{
return symbol(sym.PLUS_DOT);
}
case 69:
break;
case 35:
{
return symbol(sym.NEGATIVE);
}
case 70:
break;
case 10:
{
return symbol(sym.BACKSLASH);
}
case 71:
break;
case 23:
{
return symbol(sym.HAT);
}
case 72:
break;
case 19:
{
return symbol(sym.LBRACE);
}
case 73:
break;
case 47:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(QUOTED);
}
case 74:
break;
case 26:
{
return symbol(sym.LBRACKET);
}
case 75:
break;
case 56:
{
return symbol(sym.RBRACE_SLASH_AT);
}
case 76:
break;
case 25:
{
return symbol(sym.PROCVAR);
}
case 77:
break;
case 8:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(STRING);
}
case 78:
break;
case 44:
{
return symbol(sym.RBRACE_AT);
}
case 79:
break;
case 55:
{
return symbol(sym.SYMBOL_NAME,yytext());
}
case 80:
break;
case 13:
{
return symbol(sym.SLASH);
}
case 81:
break;
case 21:
{
return symbol(sym.RULEVAR);
}
case 82:
break;
case 32:
{
yybegin(YYINITIAL);
}
case 83:
break;
case 15:
{
return symbol(sym.PLUS);
}
case 84:
break;
case 59:
{
return symbol(sym.MOD);
}
case 85:
break;
case 6:
{
return symbol(sym.PERIOD);
}
case 86:
break;
case 42:
{
return symbol(sym.RBRACE_SLASH);
}
case 87:
break;
case 61:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH_AT);
}
case 88:
break;
case 14:
{
return symbol(sym.ASTERISK);
}
case 89:
break;
case 54:
{
return symbol(sym.PATHED_ATOM_NAME,yytext());
}
case 90:
break;
case 31:
{
yybegin(COMMENT);
}
case 91:
break;
case 4:
{
return symbol(sym.LINK_NAME,yytext(),yytext(),yyline,yycolumn);
}
case 92:
break;
case 27:
{
return symbol(sym.RBRACKET);
}
case 93:
break;
case 12:
{
return symbol(sym.COLON);
}
case 94:
break;
case 50:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 95:
break;
case 39:
{
return symbol(sym.ASTERISK_DOT);
}
case 96:
break;
case 40:
{
return symbol(sym.ASTERISK_ASTERISK);
}
case 97:
break;
case 38:
{
return symbol(sym.SLASH_DOT);
}
case 98:
break;
case 43:
{
return symbol(sym.RBRACE_ASTERISK);
}
case 99:
break;
case 17:
{
return symbol(sym.LPAREN);
}
case 100:
break;
case 30:
{
yybegin(COMMENT_INNER);
}
case 101:
break;
case 20:
{
return symbol(sym.RBRACE);
}
case 102:
break;
case 33:
{
return symbol(sym.NUMBER_NAME,yytext());
}
case 103:
break;
case 51:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 104:
break;
case 9:
{
return symbol(sym.RELOP,yytext());
}
case 105:
break;
case 3:
{
}
case 106:
break;
case 49:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 107:
break;
case 57:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH);
}
case 108:
break;
case 7:
{
return symbol(sym.MINUS);
}
case 109:
break;
case 28:
{
token.append(yytext());
string.append(yytext());
}
case 110:
break;
case 53:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 111:
break;
case 36:
{
return symbol(sym.RULE,new Integer(yyline + 1));
}
case 112:
break;
case 2:
{
throw new Error(""String_Node_Str"" + yytext() + ""String_Node_Str""+ (yyline + 1));
}
case 113:
break;
case 29:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.STRING,string.toString(),token.toString(),startline,startcol);
}
case 114:
break;
case 46:
{
return symbol(sym.RULENAMESEP);
}
case 115:
break;
case 58:
{
return symbol(sym.RBRACE_UNDERBAR_AT);
}
case 116:
break;
case 11:
{
return symbol(sym.EXCLA);
}
case 117:
break;
case 5:
{
return symbol(sym.ATOM_NAME,yytext());
}
case 118:
break;
case 16:
{
return symbol(sym.COMMA);
}
case 119:
break;
case 24:
{
return symbol(sym.TILDE);
}
case 120:
break;
case 37:
{
return symbol(sym.HL,yytext());
}
case 121:
break;
case 1:
{
}
case 122:
break;
default :
if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
yy_atEOF=true;
yy_do_eof();
switch (yy_lexical_state) {
case STRING:
{
throw new Error(""String_Node_Str"");
}
case 101:
break;
case QUOTED:
{
throw new Error(""String_Node_Str"");
}
case 102:
break;
case COMMENT:
{
throw new Error(""String_Node_Str"");
}
case 103:
break;
case COMMENT_INNER:
{
throw new Error(""String_Node_Str"");
}
case 104:
break;
default :
{
return new java_cup.runtime.Symbol(sym.EOF);
}
}
}
 else {
yy_ScanError(YY_NO_MATCH);
}
}
}
}","/** 
 * Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.
 * @return      the next token
 * @exception IOException  if any I/O-Error occurs
 */
public java_cup.runtime.Symbol next_token() throws java.io.IOException {
  int yy_input;
  int yy_action;
  int yy_currentPos_l;
  int yy_markedPos_l;
  int yy_endRead_l=yy_endRead;
  char[] yy_buffer_l=yy_buffer;
  char[] yycmap_l=yycmap;
  int[] yytrans_l=yytrans;
  int[] yy_rowMap_l=yy_rowMap;
  int[] yy_attr_l=YY_ATTRIBUTE;
  while (true) {
    yy_markedPos_l=yy_markedPos;
    boolean yy_r=false;
    for (yy_currentPos_l=yy_startRead; yy_currentPos_l < yy_markedPos_l; yy_currentPos_l++) {
switch (yy_buffer_l[yy_currentPos_l]) {
case '\u000B':
case '\u000C':
case '\u0085':
case '\u2028':
case '\u2029':
        yyline++;
      yycolumn=0;
    yy_r=false;
  break;
case '\r':
yyline++;
yycolumn=0;
yy_r=true;
break;
case '\n':
if (yy_r) yy_r=false;
 else {
yyline++;
yycolumn=0;
}
break;
default :
yy_r=false;
yycolumn++;
}
}
if (yy_r) {
boolean yy_peek;
if (yy_markedPos_l < yy_endRead_l) yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
 else if (yy_atEOF) yy_peek=false;
 else {
boolean eof=yy_refill();
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
if (eof) yy_peek=false;
 else yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
}
if (yy_peek) yyline--;
}
yy_action=-1;
yy_currentPos_l=yy_currentPos=yy_startRead=yy_markedPos_l;
yy_state=yy_lexical_state;
yy_forAction: {
while (true) {
if (yy_currentPos_l < yy_endRead_l) yy_input=yy_buffer_l[yy_currentPos_l++];
 else if (yy_atEOF) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_currentPos=yy_currentPos_l;
yy_markedPos=yy_markedPos_l;
boolean eof=yy_refill();
yy_currentPos_l=yy_currentPos;
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
yy_endRead_l=yy_endRead;
if (eof) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_input=yy_buffer_l[yy_currentPos_l++];
}
}
int yy_next=yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
if (yy_next == -1) break yy_forAction;
yy_state=yy_next;
int yy_attributes=yy_attr_l[yy_state];
if ((yy_attributes & 1) == 1) {
yy_action=yy_state;
yy_markedPos_l=yy_currentPos_l;
if ((yy_attributes & 8) == 8) break yy_forAction;
}
}
}
yy_markedPos=yy_markedPos_l;
switch (yy_action < 0 ? yy_action : YY_ACTION[yy_action]) {
case 22:
{
return symbol(sym.GUARD);
}
case 63:
break;
case 61:
{
return symbol(sym.CHAR_CODE_LITERAL,yytext());
}
case 64:
break;
case 34:
{
return symbol(sym.MINUS_DOT);
}
case 65:
break;
case 48:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.SYMBOL_NAME,string.toString(),token.toString(),startline,startcol);
}
case 66:
break;
case 45:
{
return symbol(sym.RBRACE_UNDERBAR);
}
case 67:
break;
case 18:
{
return symbol(sym.RPAREN);
}
case 68:
break;
case 53:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 69:
break;
case 41:
{
return symbol(sym.PLUS_DOT);
}
case 70:
break;
case 35:
{
return symbol(sym.NEGATIVE);
}
case 71:
break;
case 10:
{
return symbol(sym.BACKSLASH);
}
case 72:
break;
case 23:
{
return symbol(sym.HAT);
}
case 73:
break;
case 19:
{
return symbol(sym.LBRACE);
}
case 74:
break;
case 47:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(QUOTED);
}
case 75:
break;
case 26:
{
return symbol(sym.LBRACKET);
}
case 76:
break;
case 57:
{
return symbol(sym.RBRACE_SLASH_AT);
}
case 77:
break;
case 25:
{
return symbol(sym.PROCVAR);
}
case 78:
break;
case 8:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(STRING);
}
case 79:
break;
case 44:
{
return symbol(sym.RBRACE_AT);
}
case 80:
break;
case 56:
{
return symbol(sym.SYMBOL_NAME,yytext());
}
case 81:
break;
case 13:
{
return symbol(sym.SLASH);
}
case 82:
break;
case 21:
{
return symbol(sym.RULEVAR);
}
case 83:
break;
case 32:
{
yybegin(YYINITIAL);
}
case 84:
break;
case 15:
{
return symbol(sym.PLUS);
}
case 85:
break;
case 60:
{
return symbol(sym.MOD);
}
case 86:
break;
case 6:
{
return symbol(sym.PERIOD);
}
case 87:
break;
case 42:
{
return symbol(sym.RBRACE_SLASH);
}
case 88:
break;
case 62:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH_AT);
}
case 89:
break;
case 14:
{
return symbol(sym.ASTERISK);
}
case 90:
break;
case 55:
{
return symbol(sym.PATHED_ATOM_NAME,yytext());
}
case 91:
break;
case 31:
{
yybegin(COMMENT);
}
case 92:
break;
case 4:
{
return symbol(sym.LINK_NAME,yytext(),yytext(),yyline,yycolumn);
}
case 93:
break;
case 27:
{
return symbol(sym.RBRACKET);
}
case 94:
break;
case 12:
{
return symbol(sym.COLON);
}
case 95:
break;
case 50:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 96:
break;
case 39:
{
return symbol(sym.ASTERISK_DOT);
}
case 97:
break;
case 40:
{
return symbol(sym.ASTERISK_ASTERISK);
}
case 98:
break;
case 38:
{
return symbol(sym.SLASH_DOT);
}
case 99:
break;
case 43:
{
return symbol(sym.RBRACE_ASTERISK);
}
case 100:
break;
case 17:
{
return symbol(sym.LPAREN);
}
case 101:
break;
case 30:
{
yybegin(COMMENT_INNER);
}
case 102:
break;
case 20:
{
return symbol(sym.RBRACE);
}
case 103:
break;
case 33:
{
return symbol(sym.NUMBER_NAME,yytext());
}
case 104:
break;
case 52:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 105:
break;
case 9:
{
return symbol(sym.RELOP,yytext());
}
case 106:
break;
case 3:
{
}
case 107:
break;
case 49:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 108:
break;
case 58:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH);
}
case 109:
break;
case 7:
{
return symbol(sym.MINUS);
}
case 110:
break;
case 28:
{
token.append(yytext());
string.append(yytext());
}
case 111:
break;
case 54:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 112:
break;
case 36:
{
return symbol(sym.RULE,new Integer(yyline + 1));
}
case 113:
break;
case 2:
{
throw new Error(""String_Node_Str"" + yytext() + ""String_Node_Str""+ (yyline + 1));
}
case 114:
break;
case 29:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.STRING,string.toString(),token.toString(),startline,startcol);
}
case 115:
break;
case 46:
{
return symbol(sym.RULENAMESEP);
}
case 116:
break;
case 59:
{
return symbol(sym.RBRACE_UNDERBAR_AT);
}
case 117:
break;
case 51:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 118:
break;
case 11:
{
return symbol(sym.EXCLA);
}
case 119:
break;
case 5:
{
return symbol(sym.ATOM_NAME,yytext());
}
case 120:
break;
case 16:
{
return symbol(sym.COMMA);
}
case 121:
break;
case 24:
{
return symbol(sym.TILDE);
}
case 122:
break;
case 37:
{
return symbol(sym.HL,yytext());
}
case 123:
break;
case 1:
{
}
case 124:
break;
default :
if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
yy_atEOF=true;
yy_do_eof();
switch (yy_lexical_state) {
case STRING:
{
throw new Error(""String_Node_Str"");
}
case 102:
break;
case QUOTED:
{
throw new Error(""String_Node_Str"");
}
case 103:
break;
case COMMENT:
{
throw new Error(""String_Node_Str"");
}
case 104:
break;
case COMMENT_INNER:
{
throw new Error(""String_Node_Str"");
}
case 105:
break;
default :
{
return new java_cup.runtime.Symbol(sym.EOF);
}
}
}
 else {
yy_ScanError(YY_NO_MATCH);
}
}
}
}",0.9527079100399356
37609,"/** 
 * 右辺の型付きプロセス文脈を構築する 
 */
private void buildRHSTypedProcesses(){
  for (  ContextDef def : rs.typedProcessContexts.values()) {
    Iterator it2=def.rhsOccs.iterator();
    while (it2.hasNext()) {
      ProcessContext pc=(ProcessContext)it2.next();
      if (gc.typedCxtTypes.get(def) == GuardCompiler.UNARY_ATOM_TYPE) {
        int atompath=varcount++;
        body.add(new Instruction(Instruction.COPYATOM,atompath,rhsmemToPath(pc.mem),typedcxtToSrcPath(pc.def)));
        rhstypedcxtpaths.put(pc,atompath);
      }
 else       if (gc.typedCxtTypes.get(def) == GuardCompiler.GROUND_LINK_TYPE) {
        int retlistpath=varcount++;
        body.add(new Instruction(Instruction.COPYGROUND,retlistpath,groundToSrcPath(pc.def),rhsmemToPath(pc.mem)));
        int groundpath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,groundpath,retlistpath,0));
        int mappath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,mappath,retlistpath,1));
        rhsgroundpaths.put(pc,groundpath);
        rhsmappaths.put(pc,mappath);
      }
 else       if (gc.typedCxtTypes.get(def) == GuardCompiler.HLGROUND_LINK_TYPE) {
        int retlistpath=varcount++;
        Atom[] atoms=this.gc.hlgroundAttrs.get(def);
        List<Functor> attrs=this.gc.getHlgroundAttrs(atoms);
        body.add(new Instruction(Instruction.COPYHLGROUND,retlistpath,groundToSrcPath(pc.def),rhsmemToPath(pc.mem),attrs));
        int groundpath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,groundpath,retlistpath,0));
        int mappath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,mappath,retlistpath,1));
        rhsgroundpaths.put(pc,groundpath);
        rhsmappaths.put(pc,mappath);
      }
    }
  }
}","/** 
 * 右辺の型付きプロセス文脈を構築する 
 */
private void buildRHSTypedProcesses(){
  for (  ContextDef def : rs.typedProcessContexts.values()) {
    Iterator it2=def.rhsOccs.iterator();
    while (it2.hasNext()) {
      ProcessContext pc=(ProcessContext)it2.next();
      if (gc.typedCxtTypes.get(def) == GuardCompiler.UNARY_ATOM_TYPE) {
        int atompath=varcount++;
        body.add(new Instruction(Instruction.COPYATOM,atompath,rhsmemToPath(pc.mem),typedcxtToSrcPath(pc.def)));
        rhstypedcxtpaths.put(pc,atompath);
        rhsmappaths.put(pc,atompath);
      }
 else       if (gc.typedCxtTypes.get(def) == GuardCompiler.GROUND_LINK_TYPE) {
        int retlistpath=varcount++;
        body.add(new Instruction(Instruction.COPYGROUND,retlistpath,groundToSrcPath(pc.def),rhsmemToPath(pc.mem)));
        int groundpath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,groundpath,retlistpath,0));
        int mappath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,mappath,retlistpath,1));
        rhsgroundpaths.put(pc,groundpath);
        rhsmappaths.put(pc,mappath);
      }
 else       if (gc.typedCxtTypes.get(def) == GuardCompiler.HLGROUND_LINK_TYPE) {
        int retlistpath=varcount++;
        Atom[] atoms=this.gc.hlgroundAttrs.get(def);
        List<Functor> attrs=this.gc.getHlgroundAttrs(atoms);
        body.add(new Instruction(Instruction.COPYHLGROUND,retlistpath,groundToSrcPath(pc.def),rhsmemToPath(pc.mem),attrs));
        int groundpath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,groundpath,retlistpath,0));
        int mappath=varcount++;
        body.add(new Instruction(Instruction.GETFROMLIST,mappath,retlistpath,1));
        rhsgroundpaths.put(pc,groundpath);
        rhsmappaths.put(pc,mappath);
      }
    }
  }
}",0.989337822671156
37610,"/** 
 * ���դ��ץ���ʸ̮��ɽ���ץ������դ˷��ꤹ�롣
 */
void fixTypedProcesses() throws CompileException {
  identifiedCxtdefs=new HashSet<ContextDef>();
  for (  ContextDef def : typedProcessContexts.values()) {
    if (def.lhsOcc != null) {
      identifiedCxtdefs.add(def);
      for (int i=0; i < def.lhsOcc.args.length; i++) {
        if (!atomPaths.containsKey(def.lhsOcc.args[i].buddy.atom)) {
          error(""String_Node_Str"" + def.getName());
        }
      }
    }
 else     if (def.lhsMem != null) {
      if (def.lhsMem.pragmaAtHost.def == def) {
        identifiedCxtdefs.add(def);
        int atomid=varCount++;
        match.add(new Instruction(Instruction.GETRUNTIME,atomid,memToPath(def.lhsMem)));
        typedCxtSrcs.put(def,new Integer(atomid));
        typedCxtDefs.add(def);
        typedCxtTypes.put(def,UNARY_ATOM_TYPE);
        typedCxtDataTypes.put(def,new Integer(ISSTRING));
      }
    }
  }
  LinkedList<Atom> cstrs=new LinkedList<Atom>(typeConstraints);
{
    LinkedList<Atom> tmpFirst=new LinkedList<Atom>();
    LinkedList<Atom> tmpLast=new LinkedList<Atom>();
    for (Iterator<Atom> it=cstrs.iterator(); it.hasNext(); ) {
      Atom a=it.next();
      if (a.functor.getName().endsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpFirst.add(a);
        it.remove();
      }
      if (a.functor.getName().startsWith(""String_Node_Str"")) {
        tmpLast.add(a);
        it.remove();
      }
    }
    tmpFirst.addAll(cstrs);
    tmpFirst.addAll(tmpLast);
    cstrs=tmpFirst;
  }
  boolean changed;
  do {
    changed=false;
    FixType:     for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
      Atom cstr=lit.next();
      Functor func=cstr.functor;
      ContextDef def1=null;
      ContextDef def2=null;
      ContextDef def3=null;
      if (func.getArity() > 0)       def1=((ProcessContext)cstr.args[0].buddy.atom).def;
      if (func.getArity() > 1)       def2=((ProcessContext)cstr.args[1].buddy.atom).def;
      if (func.getArity() > 2)       def3=((ProcessContext)cstr.args[2].buddy.atom).def;
      if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        checkGroundLink(def1);
      }
 else       if (func.getName().startsWith(""String_Node_Str"")) {
        boolean hasError=false;
        if (func.getName().length() < 7 + func.getArity() + 1)         hasError=true;
        boolean[] isIn=new boolean[func.getArity()];
        if (func.getName().charAt(7 + isIn.length) != '_')         hasError=true;
        for (int i=0; i < isIn.length; i++) {
          char ch=func.getName().charAt(7 + i);
          if (ch != 'i' && ch != 'o')           hasError=true;
          isIn[i]=ch == 'i';
        }
        if (hasError) {
          String mo=""String_Node_Str"";
          for (int i=0; i < isIn.length; i++)           mo+=""String_Node_Str"";
          error(""String_Node_Str"" + func.getName() + ""String_Node_Str""+ mo+ ""String_Node_Str"");
        }
        String guardID=func.getName().substring(7 + func.getArity() + 1);
        ArrayList<Integer> vars=new ArrayList<Integer>();
        ArrayList<Integer> out=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (isIn[k] && !identifiedCxtdefs.contains(defK)) {
            continue FixType;
          }
          int aid;
          if (identifiedCxtdefs.contains(defK)) {
            aid=typedcxtToSrcPath(defK);
            if (aid == UNBOUND) {
              checkGroundLink(defK);
              aid=groundToSrcPath(defK);
            }
          }
 else {
            int atomid=varCount++;
            bindToUnaryAtom(defK,atomid);
            typedCxtDataTypes.put(def3,new Integer(ISINT));
            aid=typedcxtToSrcPath(defK);
            out.add(new Integer(aid));
          }
          vars.add(new Integer(aid));
        }
        match.add(new Instruction(Instruction.GUARD_INLINE,guardID,vars,out));
      }
 else       if (func.getName().equals(""String_Node_Str"") || func.getName().equals(""String_Node_Str"")) {
        ArrayList<Integer> uniqVars=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (!identifiedCxtdefs.contains(defK))           continue FixType;
          int srcPath;
          checkGroundLink(defK);
          srcPath=groundToSrcPath(defK);
          if (srcPath == UNBOUND)           continue FixType;
          uniqVars.add(new Integer(srcPath));
        }
        if (func.getName().equals(""String_Node_Str"")) {
          match.add(new Instruction(Instruction.UNIQ,uniqVars));
        }
 else {
          match.add(new Instruction(Instruction.NOT_UNIQ,uniqVars));
        }
        rc.theRule.hasUniq=true;
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        if (!GROUND_ALLOWED || typedCxtTypes.get(def1) == UNARY_ATOM_TYPE || typedCxtTypes.get(def2) == UNARY_ATOM_TYPE) {
          int atomid1=loadUnaryAtom(def1);
          int atomid2=loadUnaryAtom(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          match.add(new Instruction(Instruction.ISUNARY,atomid1));
          match.add(new Instruction(Instruction.ISUNARY,atomid2));
          int funcid1=varCount++;
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid1,atomid1));
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid2));
          match.add(new Instruction(Instruction.NEQFUNC,funcid1,funcid2));
        }
 else {
          checkGroundLink(def1);
          checkGroundLink(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          int linkid1=loadGroundLink(def1);
          int linkid2=loadGroundLink(def2);
          match.add(new Instruction(Instruction.NEQGROUND,linkid1,linkid2));
        }
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (!new Integer(ISSTRING).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(ISSTRING,atomid2));
          typedCxtDataTypes.put(def2,new Integer(ISSTRING));
        }
        int classnameAtomid=varCount++;
        match.add(new Instruction(Instruction.GETCLASS,classnameAtomid,atomid1));
        match.add(new Instruction(Instruction.SUBCLASS,classnameAtomid,atomid2));
      }
 else       if (func instanceof runtime.IntegerFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISINT));
      }
 else       if (func instanceof runtime.FloatingFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISFLOAT));
      }
 else       if (func instanceof runtime.StringFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISSTRING));
      }
 else       if (cstr.isSelfEvaluated && func.getArity() == 1) {
        bindToFunctor(def1,func);
      }
 else       if (func.equals(Functor.UNIFY)) {
        if (!identifiedCxtdefs.contains(def2)) {
          ContextDef swaptmp=def1;
          def1=def2;
          def2=swaptmp;
          if (!identifiedCxtdefs.contains(def2))           continue;
        }
        if (GROUND_ALLOWED && typedCxtTypes.get(def2) != UNARY_ATOM_TYPE) {
          if (!identifiedCxtdefs.contains(def1))           continue;
        }
        processEquivalenceConstraint(def1,def2);
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
        int atomid2=loadUnaryAtom(def2);
        match.add(new Instruction(Instruction.ISUNARY,atomid2));
        match.add(new Instruction(Instruction.SAMEFUNC,atomid1,atomid2));
      }
 else       if (guardLibrary0.containsKey(func)) {
        int[] desc=guardLibrary0.get(func);
        int atomid=varCount++;
        match.add(new Instruction(desc[0],atomid));
        bindToUnaryAtom(def1,atomid);
        typedCxtDataTypes.put(def1,new Integer(desc[1]));
        if (identifiedCxtdefs.contains(def1)) {
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid));
          int atomid1=varCount++;
          match.add(new Instruction(Instruction.ALLOCATOMINDIRECT,atomid1,funcid2));
          typedCxtSrcs.put(def1,new Integer(atomid1));
          typedCxtDefs.add(def1);
          identifiedCxtdefs.add(def1);
          typedCxtTypes.put(def1,UNARY_ATOM_TYPE);
        }
      }
 else       if (guardLibrary1.containsKey(func)) {
        int[] desc=guardLibrary1.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (func.getArity() == 1) {
          if (desc.length > 1)           match.add(new Instruction(desc[1],atomid1));
        }
 else {
          int atomid2;
          if (desc[1] == -1) {
            atomid2=atomid1;
          }
 else {
            atomid2=varCount++;
            match.add(new Instruction(desc[1],atomid2,atomid1));
          }
          bindToUnaryAtom(def2,atomid2);
          typedCxtDataTypes.put(def2,new Integer(desc[2]));
        }
      }
 else       if (guardLibrary2.containsKey(func)) {
        int[] desc=guardLibrary2.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (desc[1] != 0 && !new Integer(desc[1]).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(desc[1],atomid2));
          typedCxtDataTypes.put(def2,new Integer(desc[1]));
        }
        if (func.getArity() == 2) {
          match.add(new Instruction(desc[2],atomid1,atomid2));
        }
 else {
          int atomid3=varCount++;
          match.add(new Instruction(desc[2],atomid3,atomid1,atomid2));
          bindToUnaryAtom(def3,atomid3);
          typedCxtDataTypes.put(def3,new Integer(desc[3]));
        }
      }
 else {
        error(""String_Node_Str"" + cstr);
        discardTypeConstraint(cstr);
      }
      lit.remove();
      changed=true;
    }
    if (cstrs.isEmpty())     return;
  }
 while (changed);
  String text=""String_Node_Str"";
  for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
    Atom cstr=lit.next();
    discardTypeConstraint(cstr);
    if (text.length() > 0)     text+=""String_Node_Str"";
    text+=cstr.toStringAsTypeConstraint();
  }
  error(""String_Node_Str"" + text);
}","/** 
 * ���դ��ץ���ʸ̮��ɽ���ץ������դ˷��ꤹ�롣
 */
void fixTypedProcesses() throws CompileException {
  identifiedCxtdefs=new HashSet<ContextDef>();
  for (  ContextDef def : typedProcessContexts.values()) {
    if (def.lhsOcc != null) {
      identifiedCxtdefs.add(def);
      for (int i=0; i < def.lhsOcc.args.length; i++) {
        if (!atomPaths.containsKey(def.lhsOcc.args[i].buddy.atom)) {
          error(""String_Node_Str"" + def.getName());
        }
      }
    }
 else     if (def.lhsMem != null) {
      if (def.lhsMem.pragmaAtHost.def == def) {
        identifiedCxtdefs.add(def);
        int atomid=varCount++;
        match.add(new Instruction(Instruction.GETRUNTIME,atomid,memToPath(def.lhsMem)));
        typedCxtSrcs.put(def,new Integer(atomid));
        typedCxtDefs.add(def);
        typedCxtTypes.put(def,UNARY_ATOM_TYPE);
        typedCxtDataTypes.put(def,new Integer(ISSTRING));
      }
    }
  }
  LinkedList<Atom> cstrs=new LinkedList<Atom>(typeConstraints);
{
    LinkedList<Atom> tmpFirst=new LinkedList<Atom>();
    LinkedList<Atom> tmpLast=new LinkedList<Atom>();
    for (Iterator<Atom> it=cstrs.iterator(); it.hasNext(); ) {
      Atom a=it.next();
      if (a.functor.getName().endsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpFirst.add(a);
        it.remove();
      }
      if (a.functor.getName().startsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpLast.add(a);
        it.remove();
      }
    }
    tmpFirst.addAll(cstrs);
    tmpFirst.addAll(tmpLast);
    cstrs=tmpFirst;
  }
  boolean changed;
  do {
    changed=false;
    FixType:     for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
      Atom cstr=lit.next();
      Functor func=cstr.functor;
      ContextDef def1=null;
      ContextDef def2=null;
      ContextDef def3=null;
      if (func.getArity() > 0)       def1=((ProcessContext)cstr.args[0].buddy.atom).def;
      if (func.getArity() > 1)       def2=((ProcessContext)cstr.args[1].buddy.atom).def;
      if (func.getArity() > 2)       def3=((ProcessContext)cstr.args[2].buddy.atom).def;
      if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        checkGroundLink(def1);
      }
 else       if (func.getName().startsWith(""String_Node_Str"")) {
        boolean hasError=false;
        if (func.getName().length() < 7 + func.getArity() + 1)         hasError=true;
        boolean[] isIn=new boolean[func.getArity()];
        if (func.getName().charAt(7 + isIn.length) != '_')         hasError=true;
        for (int i=0; i < isIn.length; i++) {
          char ch=func.getName().charAt(7 + i);
          if (ch != 'i' && ch != 'o')           hasError=true;
          isIn[i]=ch == 'i';
        }
        if (hasError) {
          String mo=""String_Node_Str"";
          for (int i=0; i < isIn.length; i++)           mo+=""String_Node_Str"";
          error(""String_Node_Str"" + func.getName() + ""String_Node_Str""+ mo+ ""String_Node_Str"");
        }
        String guardID=func.getName().substring(7 + func.getArity() + 1);
        ArrayList<Integer> vars=new ArrayList<Integer>();
        ArrayList<Integer> out=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (isIn[k] && !identifiedCxtdefs.contains(defK)) {
            continue FixType;
          }
          int aid;
          if (identifiedCxtdefs.contains(defK)) {
            aid=typedcxtToSrcPath(defK);
            if (aid == UNBOUND) {
              checkGroundLink(defK);
              aid=groundToSrcPath(defK);
            }
          }
 else {
            int atomid=varCount++;
            bindToUnaryAtom(defK,atomid);
            typedCxtDataTypes.put(def3,new Integer(ISINT));
            aid=typedcxtToSrcPath(defK);
            out.add(new Integer(aid));
          }
          vars.add(new Integer(aid));
        }
        match.add(new Instruction(Instruction.GUARD_INLINE,guardID,vars,out));
      }
 else       if (func.getName().equals(""String_Node_Str"") || func.getName().equals(""String_Node_Str"")) {
        ArrayList<Integer> uniqVars=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (!identifiedCxtdefs.contains(defK))           continue FixType;
          int srcPath;
          checkGroundLink(defK);
          srcPath=groundToSrcPath(defK);
          if (srcPath == UNBOUND)           continue FixType;
          uniqVars.add(new Integer(srcPath));
        }
        if (func.getName().equals(""String_Node_Str"")) {
          match.add(new Instruction(Instruction.UNIQ,uniqVars));
        }
 else {
          match.add(new Instruction(Instruction.NOT_UNIQ,uniqVars));
        }
        rc.theRule.hasUniq=true;
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        if (!GROUND_ALLOWED || typedCxtTypes.get(def1) == UNARY_ATOM_TYPE || typedCxtTypes.get(def2) == UNARY_ATOM_TYPE) {
          int atomid1=loadUnaryAtom(def1);
          int atomid2=loadUnaryAtom(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          match.add(new Instruction(Instruction.ISUNARY,atomid1));
          match.add(new Instruction(Instruction.ISUNARY,atomid2));
          int funcid1=varCount++;
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid1,atomid1));
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid2));
          match.add(new Instruction(Instruction.NEQFUNC,funcid1,funcid2));
        }
 else {
          checkGroundLink(def1);
          checkGroundLink(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          int linkid1=loadGroundLink(def1);
          int linkid2=loadGroundLink(def2);
          match.add(new Instruction(Instruction.NEQGROUND,linkid1,linkid2));
        }
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (!new Integer(ISSTRING).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(ISSTRING,atomid2));
          typedCxtDataTypes.put(def2,new Integer(ISSTRING));
        }
        int classnameAtomid=varCount++;
        match.add(new Instruction(Instruction.GETCLASS,classnameAtomid,atomid1));
        match.add(new Instruction(Instruction.SUBCLASS,classnameAtomid,atomid2));
      }
 else       if (func instanceof runtime.IntegerFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISINT));
      }
 else       if (func instanceof runtime.FloatingFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISFLOAT));
      }
 else       if (func instanceof runtime.StringFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISSTRING));
      }
 else       if (cstr.isSelfEvaluated && func.getArity() == 1) {
        bindToFunctor(def1,func);
      }
 else       if (func.equals(Functor.UNIFY)) {
        if (!identifiedCxtdefs.contains(def2)) {
          ContextDef swaptmp=def1;
          def1=def2;
          def2=swaptmp;
          if (!identifiedCxtdefs.contains(def2))           continue;
        }
        if (GROUND_ALLOWED && typedCxtTypes.get(def2) != UNARY_ATOM_TYPE) {
          if (!identifiedCxtdefs.contains(def1))           continue;
        }
        processEquivalenceConstraint(def1,def2);
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
        int atomid2=loadUnaryAtom(def2);
        match.add(new Instruction(Instruction.ISUNARY,atomid2));
        match.add(new Instruction(Instruction.SAMEFUNC,atomid1,atomid2));
      }
 else       if (guardLibrary0.containsKey(func)) {
        int[] desc=guardLibrary0.get(func);
        int atomid=varCount++;
        match.add(new Instruction(desc[0],atomid));
        bindToUnaryAtom(def1,atomid);
        typedCxtDataTypes.put(def1,new Integer(desc[1]));
        if (identifiedCxtdefs.contains(def1)) {
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid));
          int atomid1=varCount++;
          match.add(new Instruction(Instruction.ALLOCATOMINDIRECT,atomid1,funcid2));
          typedCxtSrcs.put(def1,new Integer(atomid1));
          typedCxtDefs.add(def1);
          identifiedCxtdefs.add(def1);
          typedCxtTypes.put(def1,UNARY_ATOM_TYPE);
        }
      }
 else       if (guardLibrary1.containsKey(func)) {
        int[] desc=guardLibrary1.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (func.getArity() == 1) {
          if (desc.length > 1)           match.add(new Instruction(desc[1],atomid1));
        }
 else {
          int atomid2;
          if (desc[1] == -1) {
            atomid2=atomid1;
          }
 else {
            atomid2=varCount++;
            match.add(new Instruction(desc[1],atomid2,atomid1));
          }
          bindToUnaryAtom(def2,atomid2);
          typedCxtDataTypes.put(def2,new Integer(desc[2]));
        }
      }
 else       if (guardLibrary2.containsKey(func)) {
        int[] desc=guardLibrary2.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (desc[1] != 0 && !new Integer(desc[1]).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(desc[1],atomid2));
          typedCxtDataTypes.put(def2,new Integer(desc[1]));
        }
        if (func.getArity() == 2) {
          match.add(new Instruction(desc[2],atomid1,atomid2));
        }
 else {
          int atomid3=varCount++;
          match.add(new Instruction(desc[2],atomid3,atomid1,atomid2));
          bindToUnaryAtom(def3,atomid3);
          typedCxtDataTypes.put(def3,new Integer(desc[3]));
        }
      }
 else {
        error(""String_Node_Str"" + cstr);
        discardTypeConstraint(cstr);
      }
      lit.remove();
      changed=true;
    }
    if (cstrs.isEmpty())     return;
  }
 while (changed);
  String text=""String_Node_Str"";
  for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
    Atom cstr=lit.next();
    discardTypeConstraint(cstr);
    if (text.length() > 0)     text+=""String_Node_Str"";
    text+=cstr.toStringAsTypeConstraint();
  }
  error(""String_Node_Str"" + text);
}",0.9980169169128658
37611,"/** 
 * ���դ��ץ���ʸ̮��ɽ���ץ������դ˷��ꤹ�롣
 */
void fixTypedProcesses() throws CompileException {
  identifiedCxtdefs=new HashSet<ContextDef>();
  for (  ContextDef def : typedProcessContexts.values()) {
    if (def.lhsOcc != null) {
      identifiedCxtdefs.add(def);
      for (int i=0; i < def.lhsOcc.args.length; i++) {
        if (!atomPaths.containsKey(def.lhsOcc.args[i].buddy.atom)) {
          error(""String_Node_Str"" + def.getName());
        }
      }
    }
 else     if (def.lhsMem != null) {
      if (def.lhsMem.pragmaAtHost.def == def) {
        identifiedCxtdefs.add(def);
        int atomid=varCount++;
        match.add(new Instruction(Instruction.GETRUNTIME,atomid,memToPath(def.lhsMem)));
        typedCxtSrcs.put(def,new Integer(atomid));
        typedCxtDefs.add(def);
        typedCxtTypes.put(def,UNARY_ATOM_TYPE);
        typedCxtDataTypes.put(def,new Integer(ISSTRING));
      }
    }
  }
  LinkedList<Atom> cstrs=new LinkedList<Atom>(typeConstraints);
{
    LinkedList<Atom> tmpFirst=new LinkedList<Atom>();
    LinkedList<Atom> tmpLast=new LinkedList<Atom>();
    for (Iterator<Atom> it=cstrs.iterator(); it.hasNext(); ) {
      Atom a=it.next();
      if (a.functor.getName().endsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpFirst.add(a);
        it.remove();
      }
      if (a.functor.getName().startsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpLast.add(a);
        it.remove();
      }
    }
    tmpFirst.addAll(cstrs);
    tmpFirst.addAll(tmpLast);
    cstrs=tmpFirst;
  }
  boolean changed;
  do {
    changed=false;
    FixType:     for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
      Atom cstr=lit.next();
      Functor func=cstr.functor;
      ContextDef def1=null;
      ContextDef def2=null;
      ContextDef def3=null;
      if (func.getArity() > 0)       def1=((ProcessContext)cstr.args[0].buddy.atom).def;
      if (func.getArity() > 1)       def2=((ProcessContext)cstr.args[1].buddy.atom).def;
      if (func.getArity() > 2)       def3=((ProcessContext)cstr.args[2].buddy.atom).def;
      if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        checkGroundLink(def1);
      }
 else       if (func.getName().startsWith(""String_Node_Str"")) {
        boolean hasError=false;
        if (func.getName().length() < 7 + func.getArity() + 1)         hasError=true;
        boolean[] isIn=new boolean[func.getArity()];
        if (func.getName().charAt(7 + isIn.length) != '_')         hasError=true;
        for (int i=0; i < isIn.length; i++) {
          char ch=func.getName().charAt(7 + i);
          if (ch != 'i' && ch != 'o')           hasError=true;
          isIn[i]=ch == 'i';
        }
        if (hasError) {
          String mo=""String_Node_Str"";
          for (int i=0; i < isIn.length; i++)           mo+=""String_Node_Str"";
          error(""String_Node_Str"" + func.getName() + ""String_Node_Str""+ mo+ ""String_Node_Str"");
        }
        String guardID=func.getName().substring(7 + func.getArity() + 1);
        ArrayList<Integer> vars=new ArrayList<Integer>();
        ArrayList<Integer> out=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (isIn[k] && !identifiedCxtdefs.contains(defK)) {
            continue FixType;
          }
          int aid;
          if (identifiedCxtdefs.contains(defK)) {
            aid=typedcxtToSrcPath(defK);
            if (aid == UNBOUND) {
              checkGroundLink(defK);
              aid=groundToSrcPath(defK);
            }
          }
 else {
            int atomid=varCount++;
            bindToUnaryAtom(defK,atomid);
            typedCxtDataTypes.put(def3,new Integer(ISINT));
            aid=typedcxtToSrcPath(defK);
            out.add(new Integer(aid));
          }
          vars.add(new Integer(aid));
        }
        match.add(new Instruction(Instruction.GUARD_INLINE,guardID,vars,out));
      }
 else       if (func.getName().equals(""String_Node_Str"") || func.getName().equals(""String_Node_Str"")) {
        ArrayList<Integer> uniqVars=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (!identifiedCxtdefs.contains(defK))           continue FixType;
          int srcPath;
          checkGroundLink(defK);
          srcPath=groundToSrcPath(defK);
          if (srcPath == UNBOUND)           continue FixType;
          uniqVars.add(new Integer(srcPath));
        }
        if (func.getName().equals(""String_Node_Str"")) {
          match.add(new Instruction(Instruction.UNIQ,uniqVars));
        }
 else {
          match.add(new Instruction(Instruction.NOT_UNIQ,uniqVars));
        }
        rc.theRule.hasUniq=true;
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        if (!GROUND_ALLOWED || typedCxtTypes.get(def1) == UNARY_ATOM_TYPE || typedCxtTypes.get(def2) == UNARY_ATOM_TYPE) {
          int atomid1=loadUnaryAtom(def1);
          int atomid2=loadUnaryAtom(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          match.add(new Instruction(Instruction.ISUNARY,atomid1));
          match.add(new Instruction(Instruction.ISUNARY,atomid2));
          int funcid1=varCount++;
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid1,atomid1));
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid2));
          match.add(new Instruction(Instruction.NEQFUNC,funcid1,funcid2));
        }
 else {
          checkGroundLink(def1);
          checkGroundLink(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          int linkid1=loadGroundLink(def1);
          int linkid2=loadGroundLink(def2);
          match.add(new Instruction(Instruction.NEQGROUND,linkid1,linkid2));
        }
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (!new Integer(ISSTRING).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(ISSTRING,atomid2));
          typedCxtDataTypes.put(def2,new Integer(ISSTRING));
        }
        int classnameAtomid=varCount++;
        match.add(new Instruction(Instruction.GETCLASS,classnameAtomid,atomid1));
        match.add(new Instruction(Instruction.SUBCLASS,classnameAtomid,atomid2));
      }
 else       if (func instanceof runtime.IntegerFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISINT));
      }
 else       if (func instanceof runtime.FloatingFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISFLOAT));
      }
 else       if (func instanceof runtime.StringFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISSTRING));
      }
 else       if (cstr.isSelfEvaluated && func.getArity() == 1) {
        bindToFunctor(def1,func);
      }
 else       if (func.equals(Functor.UNIFY)) {
        if (!identifiedCxtdefs.contains(def2)) {
          ContextDef swaptmp=def1;
          def1=def2;
          def2=swaptmp;
          if (!identifiedCxtdefs.contains(def2))           continue;
        }
        if (GROUND_ALLOWED && typedCxtTypes.get(def2) != UNARY_ATOM_TYPE) {
          if (!identifiedCxtdefs.contains(def1))           continue;
        }
        processEquivalenceConstraint(def1,def2);
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
        int atomid2=loadUnaryAtom(def2);
        match.add(new Instruction(Instruction.ISUNARY,atomid2));
        match.add(new Instruction(Instruction.SAMEFUNC,atomid1,atomid2));
      }
 else       if (guardLibrary0.containsKey(func)) {
        int[] desc=guardLibrary0.get(func);
        int atomid=varCount++;
        match.add(new Instruction(desc[0],atomid));
        bindToUnaryAtom(def1,atomid);
        typedCxtDataTypes.put(def1,new Integer(desc[1]));
        if (identifiedCxtdefs.contains(def1)) {
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid));
          int atomid1=varCount++;
          match.add(new Instruction(Instruction.ALLOCATOMINDIRECT,atomid1,funcid2));
          typedCxtSrcs.put(def1,new Integer(atomid1));
          typedCxtDefs.add(def1);
          identifiedCxtdefs.add(def1);
          typedCxtTypes.put(def1,UNARY_ATOM_TYPE);
        }
      }
 else       if (guardLibrary1.containsKey(func)) {
        int[] desc=guardLibrary1.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (func.getArity() == 1) {
          if (desc.length > 1)           match.add(new Instruction(desc[1],atomid1));
        }
 else {
          int atomid2;
          if (desc[1] == -1) {
            atomid2=atomid1;
          }
 else {
            atomid2=varCount++;
            match.add(new Instruction(desc[1],atomid2,atomid1));
          }
          bindToUnaryAtom(def2,atomid2);
          typedCxtDataTypes.put(def2,new Integer(desc[2]));
        }
      }
 else       if (guardLibrary2.containsKey(func)) {
        int[] desc=guardLibrary2.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (desc[1] != 0 && !new Integer(desc[1]).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(desc[1],atomid2));
          typedCxtDataTypes.put(def2,new Integer(desc[1]));
        }
        if (func.getArity() == 2) {
          match.add(new Instruction(desc[2],atomid1,atomid2));
        }
 else {
          int atomid3=varCount++;
          match.add(new Instruction(desc[2],atomid3,atomid1,atomid2));
          bindToUnaryAtom(def3,atomid3);
          typedCxtDataTypes.put(def3,new Integer(desc[3]));
        }
      }
 else {
        error(""String_Node_Str"" + cstr);
        discardTypeConstraint(cstr);
      }
      lit.remove();
      changed=true;
    }
    if (cstrs.isEmpty())     return;
  }
 while (changed);
  String text=""String_Node_Str"";
  for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
    Atom cstr=lit.next();
    discardTypeConstraint(cstr);
    if (text.length() > 0)     text+=""String_Node_Str"";
    text+=cstr.toStringAsTypeConstraint();
  }
  error(""String_Node_Str"" + text);
}","/** 
 * ���դ��ץ���ʸ̮��ɽ���ץ������դ˷��ꤹ�롣
 */
void fixTypedProcesses() throws CompileException {
  identifiedCxtdefs=new HashSet<ContextDef>();
  for (  ContextDef def : typedProcessContexts.values()) {
    if (def.lhsOcc != null) {
      identifiedCxtdefs.add(def);
      for (int i=0; i < def.lhsOcc.args.length; i++) {
        if (!atomPaths.containsKey(def.lhsOcc.args[i].buddy.atom)) {
          error(""String_Node_Str"" + def.getName());
        }
      }
    }
 else     if (def.lhsMem != null) {
      if (def.lhsMem.pragmaAtHost.def == def) {
        identifiedCxtdefs.add(def);
        int atomid=varCount++;
        match.add(new Instruction(Instruction.GETRUNTIME,atomid,memToPath(def.lhsMem)));
        typedCxtSrcs.put(def,new Integer(atomid));
        typedCxtDefs.add(def);
        typedCxtTypes.put(def,UNARY_ATOM_TYPE);
        typedCxtDataTypes.put(def,new Integer(ISSTRING));
      }
    }
  }
  LinkedList<Atom> cstrs=new LinkedList<Atom>(typeConstraints);
{
    LinkedList<Atom> tmpFirst=new LinkedList<Atom>();
    LinkedList<Atom> tmpLast=new LinkedList<Atom>();
    for (Iterator<Atom> it=cstrs.iterator(); it.hasNext(); ) {
      Atom a=it.next();
      if (a.functor.getName().endsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpFirst.add(a);
        it.remove();
      }
      if (a.functor.getName().startsWith(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"") || a.functor.getName().equals(""String_Node_Str"")) {
        tmpLast.add(a);
        it.remove();
      }
    }
    tmpFirst.addAll(cstrs);
    tmpFirst.addAll(tmpLast);
    cstrs=tmpFirst;
  }
  boolean changed;
  do {
    changed=false;
    FixType:     for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
      Atom cstr=lit.next();
      Functor func=cstr.functor;
      ContextDef def1=null;
      ContextDef def2=null;
      ContextDef def3=null;
      if (func.getArity() > 0)       def1=((ProcessContext)cstr.args[0].buddy.atom).def;
      if (func.getArity() > 1)       def2=((ProcessContext)cstr.args[1].buddy.atom).def;
      if (func.getArity() > 2)       def3=((ProcessContext)cstr.args[2].buddy.atom).def;
      if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",1))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        checkGroundLink(def1);
      }
 else       if (func.getName().startsWith(""String_Node_Str"")) {
        boolean hasError=false;
        if (func.getName().length() < 7 + func.getArity() + 1)         hasError=true;
        boolean[] isIn=new boolean[func.getArity()];
        if (func.getName().charAt(7 + isIn.length) != '_')         hasError=true;
        for (int i=0; i < isIn.length; i++) {
          char ch=func.getName().charAt(7 + i);
          if (ch != 'i' && ch != 'o')           hasError=true;
          isIn[i]=ch == 'i';
        }
        if (hasError) {
          String mo=""String_Node_Str"";
          for (int i=0; i < isIn.length; i++)           mo+=""String_Node_Str"";
          error(""String_Node_Str"" + func.getName() + ""String_Node_Str""+ mo+ ""String_Node_Str"");
        }
        String guardID=func.getName().substring(7 + func.getArity() + 1);
        ArrayList<Integer> vars=new ArrayList<Integer>();
        ArrayList<Integer> out=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (isIn[k] && !identifiedCxtdefs.contains(defK)) {
            continue FixType;
          }
          int aid;
          if (identifiedCxtdefs.contains(defK)) {
            aid=typedcxtToSrcPath(defK);
            if (aid == UNBOUND) {
              checkGroundLink(defK);
              aid=groundToSrcPath(defK);
            }
          }
 else {
            int atomid=varCount++;
            bindToUnaryAtom(defK,atomid);
            typedCxtDataTypes.put(def3,new Integer(ISINT));
            aid=typedcxtToSrcPath(defK);
            out.add(new Integer(aid));
          }
          vars.add(new Integer(aid));
        }
        match.add(new Instruction(Instruction.GUARD_INLINE,guardID,vars,out));
      }
 else       if (func.getName().equals(""String_Node_Str"") || func.getName().equals(""String_Node_Str"")) {
        ArrayList<Integer> uniqVars=new ArrayList<Integer>();
        for (int k=0; k < cstr.args.length; k++) {
          ContextDef defK=((ProcessContext)cstr.args[k].buddy.atom).def;
          if (!identifiedCxtdefs.contains(defK))           continue FixType;
          int srcPath;
          checkGroundLink(defK);
          srcPath=groundToSrcPath(defK);
          if (srcPath == UNBOUND)           continue FixType;
          uniqVars.add(new Integer(srcPath));
        }
        if (func.getName().equals(""String_Node_Str"")) {
          match.add(new Instruction(Instruction.UNIQ,uniqVars));
        }
 else {
          match.add(new Instruction(Instruction.NOT_UNIQ,uniqVars));
        }
        rc.theRule.hasUniq=true;
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        if (!GROUND_ALLOWED || typedCxtTypes.get(def1) == UNARY_ATOM_TYPE || typedCxtTypes.get(def2) == UNARY_ATOM_TYPE) {
          int atomid1=loadUnaryAtom(def1);
          int atomid2=loadUnaryAtom(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          match.add(new Instruction(Instruction.ISUNARY,atomid1));
          match.add(new Instruction(Instruction.ISUNARY,atomid2));
          int funcid1=varCount++;
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid1,atomid1));
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid2));
          match.add(new Instruction(Instruction.NEQFUNC,funcid1,funcid2));
        }
 else {
          checkGroundLink(def1);
          checkGroundLink(def2);
          if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)           connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
          int linkid1=loadGroundLink(def1);
          int linkid2=loadGroundLink(def2);
          match.add(new Instruction(Instruction.NEQGROUND,linkid1,linkid2));
        }
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (!new Integer(ISSTRING).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(ISSTRING,atomid2));
          typedCxtDataTypes.put(def2,new Integer(ISSTRING));
        }
        int classnameAtomid=varCount++;
        match.add(new Instruction(Instruction.GETCLASS,classnameAtomid,atomid1));
        match.add(new Instruction(Instruction.SUBCLASS,classnameAtomid,atomid2));
      }
 else       if (func instanceof runtime.IntegerFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISINT));
      }
 else       if (func instanceof runtime.FloatingFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISFLOAT));
      }
 else       if (func instanceof runtime.StringFunctor) {
        bindToFunctor(def1,func);
        typedCxtDataTypes.put(def1,new Integer(ISSTRING));
      }
 else       if (cstr.isSelfEvaluated && func.getArity() == 1) {
        bindToFunctor(def1,func);
      }
 else       if (func.equals(Functor.UNIFY)) {
        if (!identifiedCxtdefs.contains(def2)) {
          ContextDef swaptmp=def1;
          def1=def2;
          def2=swaptmp;
          if (!identifiedCxtdefs.contains(def2))           continue;
        }
        if (GROUND_ALLOWED && typedCxtTypes.get(def2) != UNARY_ATOM_TYPE) {
          if (!identifiedCxtdefs.contains(def1))           continue;
        }
        processEquivalenceConstraint(def1,def2);
      }
 else       if (func.equals(new SymbolFunctor(""String_Node_Str"",2))) {
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        match.add(new Instruction(Instruction.ISUNARY,atomid1));
        int atomid2=loadUnaryAtom(def2);
        match.add(new Instruction(Instruction.ISUNARY,atomid2));
        match.add(new Instruction(Instruction.SAMEFUNC,atomid1,atomid2));
      }
 else       if (guardLibrary0.containsKey(func)) {
        int[] desc=guardLibrary0.get(func);
        int atomid=varCount++;
        match.add(new Instruction(desc[0],atomid));
        bindToUnaryAtom(def1,atomid);
        typedCxtDataTypes.put(def1,new Integer(desc[1]));
        if (identifiedCxtdefs.contains(def1)) {
          int funcid2=varCount++;
          match.add(new Instruction(Instruction.GETFUNC,funcid2,atomid));
          int atomid1=varCount++;
          match.add(new Instruction(Instruction.ALLOCATOMINDIRECT,atomid1,funcid2));
          typedCxtSrcs.put(def1,new Integer(atomid1));
          typedCxtDefs.add(def1);
          identifiedCxtdefs.add(def1);
          typedCxtTypes.put(def1,UNARY_ATOM_TYPE);
        }
      }
 else       if (guardLibrary1.containsKey(func)) {
        int[] desc=guardLibrary1.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        int atomid1=loadUnaryAtom(def1);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (func.getArity() == 1) {
          if (desc.length > 1)           match.add(new Instruction(desc[1],atomid1));
        }
 else {
          int atomid2;
          if (desc[1] == -1) {
            atomid2=atomid1;
          }
 else {
            atomid2=varCount++;
            match.add(new Instruction(desc[1],atomid2,atomid1));
          }
          bindToUnaryAtom(def2,atomid2);
          typedCxtDataTypes.put(def2,new Integer(desc[2]));
        }
      }
 else       if (guardLibrary2.containsKey(func)) {
        int[] desc=guardLibrary2.get(func);
        if (!identifiedCxtdefs.contains(def1))         continue;
        if (!identifiedCxtdefs.contains(def2))         continue;
        int atomid1=loadUnaryAtom(def1);
        int atomid2=loadUnaryAtom(def2);
        if (Env.findatom2 && def1.lhsOcc != null && def2.lhsOcc != null)         connectAtoms(def1.lhsOcc.args[0].buddy.atom,def2.lhsOcc.args[0].buddy.atom);
        if (desc[0] != 0 && !new Integer(desc[0]).equals(typedCxtDataTypes.get(def1))) {
          match.add(new Instruction(desc[0],atomid1));
          typedCxtDataTypes.put(def1,new Integer(desc[0]));
        }
        if (desc[1] != 0 && !new Integer(desc[1]).equals(typedCxtDataTypes.get(def2))) {
          match.add(new Instruction(desc[1],atomid2));
          typedCxtDataTypes.put(def2,new Integer(desc[1]));
        }
        if (func.getArity() == 2) {
          match.add(new Instruction(desc[2],atomid1,atomid2));
        }
 else {
          int atomid3=varCount++;
          match.add(new Instruction(desc[2],atomid3,atomid1,atomid2));
          bindToUnaryAtom(def3,atomid3);
          typedCxtDataTypes.put(def3,new Integer(desc[3]));
        }
      }
 else {
        error(""String_Node_Str"" + cstr);
        discardTypeConstraint(cstr);
      }
      lit.remove();
      changed=true;
    }
    if (cstrs.isEmpty())     return;
  }
 while (changed);
  String text=""String_Node_Str"";
  for (ListIterator<Atom> lit=cstrs.listIterator(); lit.hasNext(); ) {
    Atom cstr=lit.next();
    discardTypeConstraint(cstr);
    if (text.length() > 0)     text+=""String_Node_Str"";
    text+=cstr.toStringAsTypeConstraint();
  }
  error(""String_Node_Str"" + text);
}",0.9980247510783248
37612,"/** 
 * uniq ̿����ĤˤޤȤ�ƥ�����̿����κǸ�˰�ư���롣 uniq ̿��ϡ����Ƥμ��Ԥ����륬����̿��Τ����Ǹ����ˤʤ��Ȥ����ʤ��� hara
 */
void fixUniqOrder(){
  boolean found=false;
  List vars=new ArrayList();
  Iterator<Instruction> it=guard.iterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.getKind() == Instruction.UNIQ) {
      found=true;
      vars.addAll((ArrayList)inst.getArg(0));
      it.remove();
    }
  }
  if (found)   guard.add(new Instruction(Instruction.UNIQ,vars));
}","/** 
 * uniq ̿����ĤˤޤȤ�ƥ�����̿����κǸ�˰�ư���롣 uniq ̿��ϡ����Ƥμ��Ԥ����륬����̿��Τ����Ǹ����ˤʤ��Ȥ����ʤ��� hara newhlink�ʤ�, ����ܥ륢�ȥ���������륬����̿����ɲä������ᡢ �ʲ��Τ褦�ˡ�""���Ƥμ��Ԥ����륬����̿��""�κǸ����Ǥ��ꡢ �ɥ���ܥ륢�ȥ�����̿��ɤ���������������� 2011/01/10 seiji .... [���Ƥμ��Ԥ����륬����̿����] [uniq] <-- �������������� [newhlink�ʤɤΥ���ܥ륢�ȥ�����̿����] ....
 */
void fixUniqOrder(){
  boolean found=false;
  List vars=new ArrayList();
  Iterator<Instruction> it=guard.iterator();
  while (it.hasNext()) {
    Instruction inst=it.next();
    if (inst.getKind() == Instruction.UNIQ) {
      found=true;
      vars.addAll((ArrayList)inst.getArg(0));
      it.remove();
    }
  }
  if (found) {
    boolean guardallocs=false;
    Iterator<Instruction> it2=guard.iterator();
    int i=0;
    while (it2.hasNext()) {
      Instruction inst2=it2.next();
      if (inst2.getKind() == Instruction.NEWHLINK || inst2.getKind() == Instruction.MAKEHLINK) {
        guardallocs=true;
        break;
      }
      i++;
    }
    if (guardallocs)     guard.add(i,new Instruction(Instruction.UNIQ,vars));
 else     guard.add(new Instruction(Instruction.UNIQ,vars));
  }
}",0.5937307928703135
37613,"void sameProcessContext(Membrane mem,InstructionList list,HashMap sameNameMap,HashMap linkNameToAtomMap){
  List<Instruction> insts=list.insts;
  String newname=null;
  for (  Atom newatom : mem.atoms) {
    for (int i=0; i < newatom.args.length; i++) {
      newname=newatom.args[i].name;
      if (sameNameMap.containsKey(newname)) {
        String oriname=(String)sameNameMap.get(newname);
        Atom oriatom=(Atom)linkNameToAtomMap.get(oriname);
        for (int j=0; j < oriatom.args.length; j++) {
          if (oriatom.args[j].name.equals(oriname)) {
            insts.add(new Instruction(Instruction.FINDPROCCXT,atomToPath(oriatom),oriatom.args.length,j,atomToPath(newatom),newatom.args.length,i));
          }
        }
      }
    }
  }
  for (  Membrane submem : mem.mems) {
    sameProcessContext(submem,list,sameNameMap,linkNameToAtomMap);
  }
}","void sameProcessContext(Membrane mem,InstructionList list,HashMap sameNameMap,HashMap linkNameToAtomMap){
  List<Instruction> insts=list.insts;
  String newname=null;
  for (  Atom newatom : mem.atoms) {
    for (int i=0; i < newatom.args.length; i++) {
      newname=newatom.args[i].name;
      if (sameNameMap.containsKey(newname)) {
        String oriname=(String)sameNameMap.get(newname);
        Atom oriatom=(Atom)linkNameToAtomMap.get(oriname);
        for (int j=0; j < oriatom.args.length; j++) {
          if (oriatom.args[j].name.equals(oriname)) {
            if (atomToPath(oriatom) <= atomToPath(newatom))             insts.add(new Instruction(Instruction.FINDPROCCXT,atomToPath(oriatom),oriatom.args.length,j,atomToPath(newatom),newatom.args.length,i));
 else             insts.add(new Instruction(Instruction.FINDPROCCXT,atomToPath(newatom),newatom.args.length,i,atomToPath(oriatom),oriatom.args.length,j));
          }
        }
      }
    }
  }
  for (  Membrane submem : mem.mems) {
    sameProcessContext(submem,list,sameNameMap,linkNameToAtomMap);
  }
}",0.8888888888888888
37614,"/** 
 * ��κ����Ѥ�Ԥ������ɤ��������롣<br> ̿������ˤϡ�1������removemem̿�᤬����Ƥ��ƤϤ����ʤ��� ̿����κǸ��proceed̿��Ǥʤ���Фʤ�ʤ���
 * @param head �إå�̿����
 * @param body �ܥǥ�̿����
 */
private static void reuseMem(List<Instruction> head,List<Instruction> body){
  Instruction spec=body.get(0);
  if (spec.getKind() != Instruction.SPEC) {
    return;
  }
  Instruction last=body.get(body.size() - 1);
  if (last.getKind() != Instruction.PROCEED) {
    return;
  }
  for (Iterator<Instruction> itb=body.iterator(); itb.hasNext(); ) {
    int itbKind=itb.next().getKind();
    if (itbKind == Instruction.COPYCELLS || itbKind == Instruction.DROPMEM)     return;
  }
  HashMap<Integer,Integer> reuseMap=new HashMap<Integer,Integer>();
  HashSet<Integer> reuseMems=new HashSet<Integer>();
  HashMap parent=new HashMap();
  HashMap<Integer,List<Integer>> removedChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> createdChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> pourMap=new HashMap<Integer,List<Integer>>();
  HashSet pourMems=new HashSet();
  HashMap<Integer,List<Integer>> copyRulesMap=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,String> headMemName=new HashMap<Integer,String>();
  HashMap<Integer,String> bodyMemName=new HashMap<Integer,String>();
  for (  Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
      parent.put(inst.getArg1(),inst.getArg2());
    addToMap(removedChildren,inst.getArg2(),inst.getArg1());
  break;
case Instruction.NEWMEM:
parent.put(inst.getArg1(),inst.getArg2());
addToMap(createdChildren,inst.getArg2(),inst.getArg1());
break;
case Instruction.MOVECELLS:
addToMap(pourMap,inst.getArg1(),inst.getArg2());
pourMems.add(inst.getArg2());
break;
case Instruction.COPYRULES:
addToMap(copyRulesMap,inst.getArg2(),inst.getArg1());
break;
}
}
for (Instruction inst : head) {
switch (inst.getKind()) {
case Instruction.LOCKMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg3());
break;
case Instruction.ANYMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
case Instruction.ANYMEM2:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg5());
break;
case Instruction.GETMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
}
}
for (Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.SETMEMNAME:
bodyMemName.put((Integer)inst.getArg1(),(String)inst.getArg2());
}
}
createReuseMap(reuseMap,reuseMems,parent,removedChildren,createdChildren,pourMap,pourMems,new Integer(0));
HashSet<Integer> set=new HashSet<Integer>();
for (Iterator<Integer> it=reuseMap.keySet().iterator(); it.hasNext(); ) {
Integer i1=it.next();
Integer i2=reuseMap.get(i1);
Integer p1=(Integer)parent.get(i1);
Integer p2=(Integer)parent.get(i2);
if (reuseMap.containsKey(p1)) {
p1=reuseMap.get(p1);
}
if (p1.equals(p2)) {
set.add(i1);
set.add(i2);
}
}
HashMap<Integer,Integer> ruleMem=new HashMap<Integer,Integer>();
HashMap<Integer,Integer> varInBody=new HashMap<Integer,Integer>();
Instruction react=head.get(head.size() - 1);
if (react.getKind() != Instruction.REACT && react.getKind() != Instruction.JUMP) {
return;
}
int i=0;
List args=(List)react.getArg2();
for (Iterator it=args.iterator(); it.hasNext(); ) {
varInBody.put((Integer)it.next(),new Integer(i++));
}
for (Iterator<Instruction> it=head.iterator(); it.hasNext(); ) {
Instruction inst=it.next();
if (inst.getKind() == Instruction.NORULES) {
varInBody.remove(inst.getArg1());
}
}
ArrayList<Instruction> tmpInsts=new ArrayList<Instruction>();
int nextArg=spec.getIntArg2();
for (Iterator<Integer> it=varInBody.keySet().iterator(); it.hasNext(); ) {
Integer memInHead=it.next();
Integer mem=varInBody.get(memInHead);
if (reuseMems.contains(mem)) {
List<Integer> copyRulesTo=copyRulesMap.get(mem);
boolean flg=false;
if (copyRulesTo == null) {
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
}
 else {
for (Integer dstmem : copyRulesTo) {
if (mem.equals(reuseMap.get(dstmem))) {
flg=true;
break;
}
}
if (!flg) {
ruleMem.put(mem,new Integer(nextArg));
tmpInsts.add(new Instruction(Instruction.ALLOCMEM,nextArg));
tmpInsts.add(new Instruction(Instruction.COPYRULES,nextArg,mem));
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
nextArg++;
}
}
}
}
body.addAll(1,tmpInsts);
ListIterator<Instruction> lit=body.listIterator();
while (lit.hasNext()) {
Instruction inst=lit.next();
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
if (set.contains(inst.getArg1())) {
lit.remove();
}
break;
case Instruction.NEWMEM:
Integer arg1=(Integer)inst.getArg1();
if (reuseMap.containsKey(arg1)) {
lit.remove();
int m=((Integer)reuseMap.get(arg1)).intValue();
if (!set.contains(arg1)) {
lit.add(new Instruction(Instruction.ADDMEM,inst.getIntArg2(),m));
}
lit.add(new Instruction(Instruction.ENQUEUEMEM,m));
if (bodyMemName.get(arg1) == null && headMemName.get(m) != null) {
lit.add(new Instruction(Instruction.SETMEMNAME,m,null));
}
}
break;
case Instruction.MOVECELLS:
if (reuseMems.contains(inst.getArg2())) {
lit.remove();
}
break;
case Instruction.COPYRULES:
Integer srcmem=(Integer)inst.getArg2();
Integer dstmem=(Integer)inst.getArg1();
if (ruleMem.containsKey(srcmem)) {
if (!ruleMem.get(srcmem).equals(dstmem)) {
lit.remove();
lit.add(new Instruction(Instruction.COPYRULES,dstmem.intValue(),((Integer)ruleMem.get(srcmem)).intValue()));
}
}
 else if (srcmem.equals(reuseMap.get(dstmem))) {
lit.remove();
}
break;
case Instruction.FREEMEM:
if (reuseMems.contains(inst.getArg1())) {
lit.remove();
}
break;
}
}
lit.previous();
addUnlockInst(lit,reuseMap,new Integer(0),createdChildren);
for (Iterator<Integer> it=ruleMem.values().iterator(); it.hasNext(); ) {
lit.add(new Instruction(Instruction.FREEMEM,it.next()));
}
spec.updateSpec(spec.getIntArg1(),nextArg);
Instruction.changeMemVar(body,reuseMap);
}","/** 
 * ��κ����Ѥ�Ԥ������ɤ��������롣<br> ̿������ˤϡ�1������removemem̿�᤬����Ƥ��ƤϤ����ʤ��� ̿����κǸ��proceed̿��Ǥʤ���Фʤ�ʤ���
 * @param head �إå�̿����
 * @param body �ܥǥ�̿����
 */
private static void reuseMem(List<Instruction> head,List<Instruction> body){
  Instruction spec=body.get(0);
  if (spec.getKind() != Instruction.SPEC) {
    return;
  }
  Instruction last=body.get(body.size() - 1);
  if (last.getKind() != Instruction.PROCEED) {
    return;
  }
  for (Iterator<Instruction> itb=body.iterator(); itb.hasNext(); ) {
    int itbKind=itb.next().getKind();
    if (itbKind == Instruction.COPYCELLS || itbKind == Instruction.DROPMEM)     return;
  }
  HashMap<Integer,Integer> reuseMap=new HashMap<Integer,Integer>();
  HashSet<Integer> reuseMems=new HashSet<Integer>();
  HashMap parent=new HashMap();
  HashMap<Integer,List<Integer>> removedChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> createdChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> pourMap=new HashMap<Integer,List<Integer>>();
  HashSet pourMems=new HashSet();
  HashMap<Integer,List<Integer>> copyRulesMap=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,String> headMemName=new HashMap<Integer,String>();
  HashMap<Integer,String> bodyMemName=new HashMap<Integer,String>();
  for (  Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
      parent.put(inst.getArg1(),inst.getArg2());
    addToMap(removedChildren,inst.getArg2(),inst.getArg1());
  break;
case Instruction.NEWMEM:
parent.put(inst.getArg1(),inst.getArg2());
addToMap(createdChildren,inst.getArg2(),inst.getArg1());
break;
case Instruction.MOVECELLS:
addToMap(pourMap,inst.getArg1(),inst.getArg2());
pourMems.add(inst.getArg2());
break;
case Instruction.COPYRULES:
addToMap(copyRulesMap,inst.getArg2(),inst.getArg1());
break;
}
}
for (Instruction inst : head) {
switch (inst.getKind()) {
case Instruction.LOCKMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg3());
break;
case Instruction.ANYMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
case Instruction.ANYMEM2:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg5());
break;
case Instruction.GETMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
}
}
for (Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.SETMEMNAME:
bodyMemName.put((Integer)inst.getArg1(),(String)inst.getArg2());
}
}
createReuseMap(reuseMap,reuseMems,parent,removedChildren,createdChildren,pourMap,pourMems,new Integer(0));
HashSet<Integer> set=new HashSet<Integer>();
for (Iterator<Integer> it=reuseMap.keySet().iterator(); it.hasNext(); ) {
Integer i1=it.next();
Integer i2=reuseMap.get(i1);
Integer p1=(Integer)parent.get(i1);
Integer p2=(Integer)parent.get(i2);
if (reuseMap.containsKey(p1)) {
p1=reuseMap.get(p1);
}
if (p1.equals(p2)) {
set.add(i1);
set.add(i2);
}
}
HashMap<Integer,Integer> ruleMem=new HashMap<Integer,Integer>();
HashMap<Integer,Integer> varInBody=new HashMap<Integer,Integer>();
Instruction react=head.get(head.size() - 1);
if (react.getKind() != Instruction.REACT && react.getKind() != Instruction.JUMP) {
return;
}
int i=0;
ArrayList args=(ArrayList)react.getArg2();
for (Iterator it=args.iterator(); it.hasNext(); ) {
varInBody.put((Integer)it.next(),new Integer(i++));
}
for (Iterator<Instruction> it=head.iterator(); it.hasNext(); ) {
Instruction inst=it.next();
if (inst.getKind() == Instruction.NORULES) {
varInBody.remove(inst.getArg1());
}
}
ArrayList<Instruction> tmpInsts=new ArrayList<Instruction>();
int nextArg=spec.getIntArg2();
for (Iterator<Integer> it=varInBody.keySet().iterator(); it.hasNext(); ) {
Integer memInHead=it.next();
Integer mem=varInBody.get(memInHead);
if (reuseMems.contains(mem)) {
List<Integer> copyRulesTo=copyRulesMap.get(mem);
boolean flg=false;
if (copyRulesTo == null) {
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
}
 else {
for (Integer dstmem : copyRulesTo) {
if (mem.equals(reuseMap.get(dstmem))) {
flg=true;
break;
}
}
if (!flg) {
ruleMem.put(mem,new Integer(nextArg));
tmpInsts.add(new Instruction(Instruction.ALLOCMEM,nextArg));
tmpInsts.add(new Instruction(Instruction.COPYRULES,nextArg,mem));
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
nextArg++;
}
}
}
}
body.addAll(1,tmpInsts);
ListIterator<Instruction> lit=body.listIterator();
while (lit.hasNext()) {
Instruction inst=lit.next();
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
if (set.contains(inst.getArg1())) {
lit.remove();
}
break;
case Instruction.NEWMEM:
Integer arg1=(Integer)inst.getArg1();
if (reuseMap.containsKey(arg1)) {
lit.remove();
int m=((Integer)reuseMap.get(arg1)).intValue();
if (!set.contains(arg1)) {
lit.add(new Instruction(Instruction.ADDMEM,inst.getIntArg2(),m));
}
lit.add(new Instruction(Instruction.ENQUEUEMEM,m));
if (bodyMemName.get(arg1) == null && headMemName.get(args.get(m)) != null) {
lit.add(new Instruction(Instruction.SETMEMNAME,m,null));
}
}
break;
case Instruction.MOVECELLS:
if (reuseMems.contains(inst.getArg2())) {
lit.remove();
}
break;
case Instruction.COPYRULES:
Integer srcmem=(Integer)inst.getArg2();
Integer dstmem=(Integer)inst.getArg1();
if (ruleMem.containsKey(srcmem)) {
if (!ruleMem.get(srcmem).equals(dstmem)) {
lit.remove();
lit.add(new Instruction(Instruction.COPYRULES,dstmem.intValue(),((Integer)ruleMem.get(srcmem)).intValue()));
}
}
 else if (srcmem.equals(reuseMap.get(dstmem))) {
lit.remove();
}
break;
case Instruction.FREEMEM:
if (reuseMems.contains(inst.getArg1())) {
lit.remove();
}
break;
}
}
lit.previous();
addUnlockInst(lit,reuseMap,new Integer(0),createdChildren);
for (Iterator<Integer> it=ruleMem.values().iterator(); it.hasNext(); ) {
lit.add(new Instruction(Instruction.FREEMEM,it.next()));
}
spec.updateSpec(spec.getIntArg1(),nextArg);
Instruction.changeMemVar(body,reuseMap);
}",0.998122866894198
37615,"/** 
 * Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.
 * @return      the next token
 * @exception IOException  if any I/O-Error occurs
 */
public java_cup.runtime.Symbol next_token() throws java.io.IOException {
  int yy_input;
  int yy_action;
  int yy_currentPos_l;
  int yy_markedPos_l;
  int yy_endRead_l=yy_endRead;
  char[] yy_buffer_l=yy_buffer;
  char[] yycmap_l=yycmap;
  int[] yytrans_l=yytrans;
  int[] yy_rowMap_l=yy_rowMap;
  int[] yy_attr_l=YY_ATTRIBUTE;
  while (true) {
    yy_markedPos_l=yy_markedPos;
    boolean yy_r=false;
    for (yy_currentPos_l=yy_startRead; yy_currentPos_l < yy_markedPos_l; yy_currentPos_l++) {
switch (yy_buffer_l[yy_currentPos_l]) {
case '\u000B':
case '\u000C':
case '\u0085':
case '\u2028':
case '\u2029':
        yyline++;
      yycolumn=0;
    yy_r=false;
  break;
case '\r':
yyline++;
yycolumn=0;
yy_r=true;
break;
case '\n':
if (yy_r) yy_r=false;
 else {
yyline++;
yycolumn=0;
}
break;
default :
yy_r=false;
yycolumn++;
}
}
if (yy_r) {
boolean yy_peek;
if (yy_markedPos_l < yy_endRead_l) yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
 else if (yy_atEOF) yy_peek=false;
 else {
boolean eof=yy_refill();
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
if (eof) yy_peek=false;
 else yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
}
if (yy_peek) yyline--;
}
yy_action=-1;
yy_currentPos_l=yy_currentPos=yy_startRead=yy_markedPos_l;
yy_state=yy_lexical_state;
yy_forAction: {
while (true) {
if (yy_currentPos_l < yy_endRead_l) yy_input=yy_buffer_l[yy_currentPos_l++];
 else if (yy_atEOF) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_currentPos=yy_currentPos_l;
yy_markedPos=yy_markedPos_l;
boolean eof=yy_refill();
yy_currentPos_l=yy_currentPos;
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
yy_endRead_l=yy_endRead;
if (eof) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_input=yy_buffer_l[yy_currentPos_l++];
}
}
int yy_next=yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
if (yy_next == -1) break yy_forAction;
yy_state=yy_next;
int yy_attributes=yy_attr_l[yy_state];
if ((yy_attributes & 1) == 1) {
yy_action=yy_state;
yy_markedPos_l=yy_currentPos_l;
if ((yy_attributes & 8) == 8) break yy_forAction;
}
}
}
yy_markedPos=yy_markedPos_l;
switch (yy_action < 0 ? yy_action : YY_ACTION[yy_action]) {
case 22:
{
return symbol(sym.GUARD);
}
case 63:
break;
case 61:
{
return symbol(sym.CHAR_CODE_LITERAL,yytext());
}
case 64:
break;
case 34:
{
return symbol(sym.MINUS_DOT);
}
case 65:
break;
case 48:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.SYMBOL_NAME,string.toString(),token.toString(),startline,startcol);
}
case 66:
break;
case 45:
{
return symbol(sym.RBRACE_UNDERBAR);
}
case 67:
break;
case 18:
{
return symbol(sym.RPAREN);
}
case 68:
break;
case 53:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 69:
break;
case 41:
{
return symbol(sym.PLUS_DOT);
}
case 70:
break;
case 35:
{
return symbol(sym.NEGATIVE);
}
case 71:
break;
case 11:
{
return symbol(sym.BACKSLASH);
}
case 72:
break;
case 23:
{
return symbol(sym.HAT);
}
case 73:
break;
case 19:
{
return symbol(sym.LBRACE);
}
case 74:
break;
case 47:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(QUOTED);
}
case 75:
break;
case 26:
{
return symbol(sym.LBRACKET);
}
case 76:
break;
case 57:
{
return symbol(sym.RBRACE_SLASH_AT);
}
case 77:
break;
case 25:
{
return symbol(sym.PROCVAR);
}
case 78:
break;
case 8:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(STRING);
}
case 79:
break;
case 44:
{
return symbol(sym.RBRACE_AT);
}
case 80:
break;
case 56:
{
return symbol(sym.SYMBOL_NAME,yytext());
}
case 81:
break;
case 13:
{
return symbol(sym.SLASH);
}
case 82:
break;
case 21:
{
return symbol(sym.RULEVAR);
}
case 83:
break;
case 32:
{
yybegin(YYINITIAL);
}
case 84:
break;
case 15:
{
return symbol(sym.PLUS);
}
case 85:
break;
case 60:
{
return symbol(sym.MOD);
}
case 86:
break;
case 6:
{
return symbol(sym.PERIOD);
}
case 87:
break;
case 42:
{
return symbol(sym.RBRACE_SLASH);
}
case 88:
break;
case 62:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH_AT);
}
case 89:
break;
case 14:
{
return symbol(sym.ASTERISK);
}
case 90:
break;
case 55:
{
return symbol(sym.PATHED_ATOM_NAME,yytext());
}
case 91:
break;
case 31:
{
yybegin(COMMENT);
}
case 92:
break;
case 4:
{
return symbol(sym.LINK_NAME,yytext(),yytext(),yyline,yycolumn);
}
case 93:
break;
case 27:
{
return symbol(sym.RBRACKET);
}
case 94:
break;
case 12:
{
return symbol(sym.COLON);
}
case 95:
break;
case 50:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 96:
break;
case 39:
{
return symbol(sym.ASTERISK_DOT);
}
case 97:
break;
case 40:
{
return symbol(sym.ASTERISK_ASTERISK);
}
case 98:
break;
case 38:
{
return symbol(sym.SLASH_DOT);
}
case 99:
break;
case 43:
{
return symbol(sym.RBRACE_ASTERISK);
}
case 100:
break;
case 17:
{
return symbol(sym.LPAREN);
}
case 101:
break;
case 30:
{
yybegin(COMMENT_INNER);
}
case 102:
break;
case 20:
{
return symbol(sym.RBRACE);
}
case 103:
break;
case 33:
{
return symbol(sym.NUMBER_NAME,yytext());
}
case 104:
break;
case 52:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 105:
break;
case 9:
{
return symbol(sym.RELOP,yytext());
}
case 106:
break;
case 3:
{
}
case 107:
break;
case 49:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 108:
break;
case 58:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH);
}
case 109:
break;
case 7:
{
return symbol(sym.MINUS);
}
case 110:
break;
case 28:
{
token.append(yytext());
string.append(yytext());
}
case 111:
break;
case 54:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 112:
break;
case 36:
{
return symbol(sym.RULE,new Integer(yyline + 1));
}
case 113:
break;
case 2:
{
throw new Error(""String_Node_Str"" + yytext() + ""String_Node_Str""+ (yyline + 1));
}
case 114:
break;
case 29:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.STRING,string.toString(),token.toString(),startline,startcol);
}
case 115:
break;
case 46:
{
return symbol(sym.RULENAMESEP);
}
case 116:
break;
case 59:
{
return symbol(sym.RBRACE_UNDERBAR_AT);
}
case 117:
break;
case 51:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 118:
break;
case 10:
{
return symbol(sym.EXCLA);
}
case 119:
break;
case 5:
{
return symbol(sym.ATOM_NAME,yytext());
}
case 120:
break;
case 16:
{
return symbol(sym.COMMA);
}
case 121:
break;
case 24:
{
return symbol(sym.TILDE);
}
case 122:
break;
case 37:
{
return symbol(sym.HL,yytext());
}
case 123:
break;
case 1:
{
}
case 124:
break;
default :
if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
yy_atEOF=true;
yy_do_eof();
switch (yy_lexical_state) {
case STRING:
{
throw new Error(""String_Node_Str"");
}
case 105:
break;
case QUOTED:
{
throw new Error(""String_Node_Str"");
}
case 106:
break;
case COMMENT:
{
throw new Error(""String_Node_Str"");
}
case 107:
break;
case COMMENT_INNER:
{
throw new Error(""String_Node_Str"");
}
case 108:
break;
default :
{
return new java_cup.runtime.Symbol(sym.EOF);
}
}
}
 else {
yy_ScanError(YY_NO_MATCH);
}
}
}
}","/** 
 * Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.
 * @return      the next token
 * @exception IOException  if any I/O-Error occurs
 */
public java_cup.runtime.Symbol next_token() throws java.io.IOException {
  int yy_input;
  int yy_action;
  int yy_currentPos_l;
  int yy_markedPos_l;
  int yy_endRead_l=yy_endRead;
  char[] yy_buffer_l=yy_buffer;
  char[] yycmap_l=yycmap;
  int[] yytrans_l=yytrans;
  int[] yy_rowMap_l=yy_rowMap;
  int[] yy_attr_l=YY_ATTRIBUTE;
  while (true) {
    yy_markedPos_l=yy_markedPos;
    boolean yy_r=false;
    for (yy_currentPos_l=yy_startRead; yy_currentPos_l < yy_markedPos_l; yy_currentPos_l++) {
switch (yy_buffer_l[yy_currentPos_l]) {
case '\u000B':
case '\u000C':
case '\u0085':
case '\u2028':
case '\u2029':
        yyline++;
      yycolumn=0;
    yy_r=false;
  break;
case '\r':
yyline++;
yycolumn=0;
yy_r=true;
break;
case '\n':
if (yy_r) yy_r=false;
 else {
yyline++;
yycolumn=0;
}
break;
default :
yy_r=false;
yycolumn++;
}
}
if (yy_r) {
boolean yy_peek;
if (yy_markedPos_l < yy_endRead_l) yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
 else if (yy_atEOF) yy_peek=false;
 else {
boolean eof=yy_refill();
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
if (eof) yy_peek=false;
 else yy_peek=yy_buffer_l[yy_markedPos_l] == '\n';
}
if (yy_peek) yyline--;
}
yy_action=-1;
yy_currentPos_l=yy_currentPos=yy_startRead=yy_markedPos_l;
yy_state=yy_lexical_state;
yy_forAction: {
while (true) {
if (yy_currentPos_l < yy_endRead_l) yy_input=yy_buffer_l[yy_currentPos_l++];
 else if (yy_atEOF) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_currentPos=yy_currentPos_l;
yy_markedPos=yy_markedPos_l;
boolean eof=yy_refill();
yy_currentPos_l=yy_currentPos;
yy_markedPos_l=yy_markedPos;
yy_buffer_l=yy_buffer;
yy_endRead_l=yy_endRead;
if (eof) {
yy_input=YYEOF;
break yy_forAction;
}
 else {
yy_input=yy_buffer_l[yy_currentPos_l++];
}
}
int yy_next=yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
if (yy_next == -1) break yy_forAction;
yy_state=yy_next;
int yy_attributes=yy_attr_l[yy_state];
if ((yy_attributes & 1) == 1) {
yy_action=yy_state;
yy_markedPos_l=yy_currentPos_l;
if ((yy_attributes & 8) == 8) break yy_forAction;
}
}
}
yy_markedPos=yy_markedPos_l;
switch (yy_action < 0 ? yy_action : YY_ACTION[yy_action]) {
case 22:
{
return symbol(sym.GUARD);
}
case 63:
break;
case 61:
{
return symbol(sym.CHAR_CODE_LITERAL,yytext());
}
case 64:
break;
case 34:
{
return symbol(sym.MINUS_DOT);
}
case 65:
break;
case 48:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.SYMBOL_NAME,string.toString(),token.toString(),startline,startcol);
}
case 66:
break;
case 45:
{
return symbol(sym.RBRACE_UNDERBAR);
}
case 67:
break;
case 18:
{
return symbol(sym.RPAREN);
}
case 68:
break;
case 53:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 69:
break;
case 41:
{
return symbol(sym.PLUS_DOT);
}
case 70:
break;
case 35:
{
return symbol(sym.NEGATIVE);
}
case 71:
break;
case 11:
{
return symbol(sym.BACKSLASH);
}
case 72:
break;
case 23:
{
return symbol(sym.HAT);
}
case 73:
break;
case 19:
{
return symbol(sym.LBRACE);
}
case 74:
break;
case 47:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(QUOTED);
}
case 75:
break;
case 26:
{
return symbol(sym.LBRACKET);
}
case 76:
break;
case 57:
{
return symbol(sym.RBRACE_SLASH_AT);
}
case 77:
break;
case 25:
{
return symbol(sym.PROCVAR);
}
case 78:
break;
case 8:
{
string.setLength(0);
token.setLength(0);
token.append(yytext());
startline=yyline;
startcol=yycolumn;
yybegin(STRING);
}
case 79:
break;
case 44:
{
return symbol(sym.RBRACE_AT);
}
case 80:
break;
case 56:
{
return symbol(sym.SYMBOL_NAME,yytext());
}
case 81:
break;
case 13:
{
return symbol(sym.SLASH);
}
case 82:
break;
case 21:
{
return symbol(sym.RULEVAR);
}
case 83:
break;
case 32:
{
yybegin(YYINITIAL);
}
case 84:
break;
case 15:
{
return symbol(sym.PLUS);
}
case 85:
break;
case 60:
{
return symbol(sym.MOD);
}
case 86:
break;
case 6:
{
return symbol(sym.PERIOD);
}
case 87:
break;
case 42:
{
return symbol(sym.RBRACE_SLASH);
}
case 88:
break;
case 62:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH_AT);
}
case 89:
break;
case 14:
{
return symbol(sym.ASTERISK);
}
case 90:
break;
case 55:
{
return symbol(sym.PATHED_ATOM_NAME,yytext());
}
case 91:
break;
case 31:
{
yybegin(COMMENT);
}
case 92:
break;
case 4:
{
return symbol(sym.LINK_NAME,yytext(),yytext(),yyline,yycolumn);
}
case 93:
break;
case 27:
{
return symbol(sym.RBRACKET);
}
case 94:
break;
case 12:
{
return symbol(sym.COLON);
}
case 95:
break;
case 50:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 96:
break;
case 39:
{
return symbol(sym.ASTERISK_DOT);
}
case 97:
break;
case 40:
{
return symbol(sym.ASTERISK_ASTERISK);
}
case 98:
break;
case 38:
{
return symbol(sym.SLASH_DOT);
}
case 99:
break;
case 43:
{
return symbol(sym.RBRACE_ASTERISK);
}
case 100:
break;
case 17:
{
return symbol(sym.LPAREN);
}
case 101:
break;
case 30:
{
yybegin(COMMENT_INNER);
}
case 102:
break;
case 20:
{
return symbol(sym.RBRACE);
}
case 103:
break;
case 33:
{
return symbol(sym.NUMBER_NAME,yytext());
}
case 104:
break;
case 52:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 105:
break;
case 9:
{
return symbol(sym.RELOP,yytext());
}
case 106:
break;
case 3:
{
}
case 107:
break;
case 49:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 108:
break;
case 58:
{
return symbol(sym.RBRACE_UNDERBAR_SLASH);
}
case 109:
break;
case 7:
{
return symbol(sym.MINUS);
}
case 110:
break;
case 28:
{
token.append(yytext());
string.append(yytext());
}
case 111:
break;
case 54:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 112:
break;
case 36:
{
return symbol(sym.RULE,new Integer(yyline + 1));
}
case 113:
break;
case 2:
{
throw new Error(""String_Node_Str"" + yytext() + ""String_Node_Str""+ (yyline + 1));
}
case 114:
break;
case 29:
{
token.append(yytext());
yybegin(YYINITIAL);
return symbol(sym.STRING,string.toString(),token.toString(),startline,startcol);
}
case 115:
break;
case 46:
{
return symbol(sym.RULENAMESEP);
}
case 116:
break;
case 59:
{
return symbol(sym.RBRACE_UNDERBAR_AT);
}
case 117:
break;
case 51:
{
token.append(yytext());
string.append(""String_Node_Str"");
}
case 118:
break;
case 10:
{
return symbol(sym.EXCLA);
}
case 119:
break;
case 5:
{
return symbol(sym.ATOM_NAME,yytext());
}
case 120:
break;
case 16:
{
return symbol(sym.COMMA);
}
case 121:
break;
case 24:
{
return symbol(sym.TILDE);
}
case 122:
break;
case 37:
{
return symbol(sym.HL,yytext());
}
case 123:
break;
case 1:
{
}
case 124:
break;
default :
if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
yy_atEOF=true;
yy_do_eof();
switch (yy_lexical_state) {
case STRING:
{
throw new Error(""String_Node_Str"");
}
case 101:
break;
case QUOTED:
{
throw new Error(""String_Node_Str"");
}
case 102:
break;
case COMMENT:
{
throw new Error(""String_Node_Str"");
}
case 103:
break;
case COMMENT_INNER:
{
throw new Error(""String_Node_Str"");
}
case 104:
break;
default :
{
return new java_cup.runtime.Symbol(sym.EOF);
}
}
}
 else {
yy_ScanError(YY_NO_MATCH);
}
}
}
}",0.999442974516084
37616,"/** 
 * ��κ����Ѥ�Ԥ������ɤ��������롣<br> ̿������ˤϡ�1������removemem̿�᤬����Ƥ��ƤϤ����ʤ��� ̿����κǸ��proceed̿��Ǥʤ���Фʤ�ʤ���
 * @param head �إå�̿����
 * @param body �ܥǥ�̿����
 */
private static void reuseMem(List<Instruction> head,List<Instruction> body){
  Instruction spec=body.get(0);
  if (spec.getKind() != Instruction.SPEC) {
    return;
  }
  Instruction last=body.get(body.size() - 1);
  if (last.getKind() != Instruction.PROCEED) {
    return;
  }
  for (Iterator<Instruction> itb=body.iterator(); itb.hasNext(); ) {
    int itbKind=itb.next().getKind();
    if (itbKind == Instruction.COPYCELLS || itbKind == Instruction.DROPMEM)     return;
  }
  HashMap<Integer,Integer> reuseMap=new HashMap<Integer,Integer>();
  HashSet<Integer> reuseMems=new HashSet<Integer>();
  HashMap parent=new HashMap();
  HashMap<Integer,List<Integer>> removedChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> createdChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> pourMap=new HashMap<Integer,List<Integer>>();
  HashSet pourMems=new HashSet();
  HashMap<Integer,List<Integer>> copyRulesMap=new HashMap<Integer,List<Integer>>();
  for (  Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
      parent.put(inst.getArg1(),inst.getArg2());
    addToMap(removedChildren,inst.getArg2(),inst.getArg1());
  break;
case Instruction.NEWMEM:
parent.put(inst.getArg1(),inst.getArg2());
addToMap(createdChildren,inst.getArg2(),inst.getArg1());
break;
case Instruction.MOVECELLS:
addToMap(pourMap,inst.getArg1(),inst.getArg2());
pourMems.add(inst.getArg2());
break;
case Instruction.COPYRULES:
addToMap(copyRulesMap,inst.getArg2(),inst.getArg1());
break;
}
}
createReuseMap(reuseMap,reuseMems,parent,removedChildren,createdChildren,pourMap,pourMems,new Integer(0));
HashSet<Integer> set=new HashSet<Integer>();
for (Iterator<Integer> it=reuseMap.keySet().iterator(); it.hasNext(); ) {
Integer i1=it.next();
Integer i2=reuseMap.get(i1);
Integer p1=(Integer)parent.get(i1);
Integer p2=(Integer)parent.get(i2);
if (reuseMap.containsKey(p1)) {
p1=reuseMap.get(p1);
}
if (p1.equals(p2)) {
set.add(i1);
set.add(i2);
}
}
HashMap<Integer,Integer> ruleMem=new HashMap<Integer,Integer>();
HashMap<Integer,Integer> varInBody=new HashMap<Integer,Integer>();
Instruction react=head.get(head.size() - 1);
if (react.getKind() != Instruction.REACT && react.getKind() != Instruction.JUMP) {
return;
}
int i=0;
List args=(List)react.getArg2();
for (Iterator it=args.iterator(); it.hasNext(); ) {
varInBody.put((Integer)it.next(),new Integer(i++));
}
for (Iterator<Instruction> it=head.iterator(); it.hasNext(); ) {
Instruction inst=it.next();
if (inst.getKind() == Instruction.NORULES) {
varInBody.remove(inst.getArg1());
}
}
ArrayList<Instruction> tmpInsts=new ArrayList<Instruction>();
int nextArg=spec.getIntArg2();
for (Iterator<Integer> it=varInBody.keySet().iterator(); it.hasNext(); ) {
Integer memInHead=it.next();
Integer mem=varInBody.get(memInHead);
if (reuseMems.contains(mem)) {
List<Integer> copyRulesTo=copyRulesMap.get(mem);
boolean flg=false;
if (copyRulesTo == null) {
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
}
 else {
for (Integer dstmem : copyRulesTo) {
if (mem.equals(reuseMap.get(dstmem))) {
flg=true;
break;
}
}
if (!flg) {
ruleMem.put(mem,new Integer(nextArg));
tmpInsts.add(new Instruction(Instruction.ALLOCMEM,nextArg));
tmpInsts.add(new Instruction(Instruction.COPYRULES,nextArg,mem));
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
nextArg++;
}
}
}
}
body.addAll(1,tmpInsts);
ListIterator<Instruction> lit=body.listIterator();
while (lit.hasNext()) {
Instruction inst=lit.next();
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
if (set.contains(inst.getArg1())) {
lit.remove();
}
break;
case Instruction.NEWMEM:
Integer arg1=(Integer)inst.getArg1();
if (reuseMap.containsKey(arg1)) {
lit.remove();
int m=((Integer)reuseMap.get(arg1)).intValue();
if (!set.contains(arg1)) {
lit.add(new Instruction(Instruction.ADDMEM,inst.getIntArg2(),m));
}
lit.add(new Instruction(Instruction.ENQUEUEMEM,m));
}
break;
case Instruction.MOVECELLS:
if (reuseMems.contains(inst.getArg2())) {
lit.remove();
}
break;
case Instruction.COPYRULES:
Integer srcmem=(Integer)inst.getArg2();
Integer dstmem=(Integer)inst.getArg1();
if (ruleMem.containsKey(srcmem)) {
if (!ruleMem.get(srcmem).equals(dstmem)) {
lit.remove();
lit.add(new Instruction(Instruction.COPYRULES,dstmem.intValue(),((Integer)ruleMem.get(srcmem)).intValue()));
}
}
 else if (srcmem.equals(reuseMap.get(dstmem))) {
lit.remove();
}
break;
case Instruction.FREEMEM:
if (reuseMems.contains(inst.getArg1())) {
lit.remove();
}
break;
}
}
lit.previous();
addUnlockInst(lit,reuseMap,new Integer(0),createdChildren);
for (Iterator<Integer> it=ruleMem.values().iterator(); it.hasNext(); ) {
lit.add(new Instruction(Instruction.FREEMEM,it.next()));
}
spec.updateSpec(spec.getIntArg1(),nextArg);
Instruction.changeMemVar(body,reuseMap);
}","/** 
 * ��κ����Ѥ�Ԥ������ɤ��������롣<br> ̿������ˤϡ�1������removemem̿�᤬����Ƥ��ƤϤ����ʤ��� ̿����κǸ��proceed̿��Ǥʤ���Фʤ�ʤ���
 * @param head �إå�̿����
 * @param body �ܥǥ�̿����
 */
private static void reuseMem(List<Instruction> head,List<Instruction> body){
  Instruction spec=body.get(0);
  if (spec.getKind() != Instruction.SPEC) {
    return;
  }
  Instruction last=body.get(body.size() - 1);
  if (last.getKind() != Instruction.PROCEED) {
    return;
  }
  for (Iterator<Instruction> itb=body.iterator(); itb.hasNext(); ) {
    int itbKind=itb.next().getKind();
    if (itbKind == Instruction.COPYCELLS || itbKind == Instruction.DROPMEM)     return;
  }
  HashMap<Integer,Integer> reuseMap=new HashMap<Integer,Integer>();
  HashSet<Integer> reuseMems=new HashSet<Integer>();
  HashMap parent=new HashMap();
  HashMap<Integer,List<Integer>> removedChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> createdChildren=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,List<Integer>> pourMap=new HashMap<Integer,List<Integer>>();
  HashSet pourMems=new HashSet();
  HashMap<Integer,List<Integer>> copyRulesMap=new HashMap<Integer,List<Integer>>();
  HashMap<Integer,String> headMemName=new HashMap<Integer,String>();
  HashMap<Integer,String> bodyMemName=new HashMap<Integer,String>();
  for (  Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
      parent.put(inst.getArg1(),inst.getArg2());
    addToMap(removedChildren,inst.getArg2(),inst.getArg1());
  break;
case Instruction.NEWMEM:
parent.put(inst.getArg1(),inst.getArg2());
addToMap(createdChildren,inst.getArg2(),inst.getArg1());
break;
case Instruction.MOVECELLS:
addToMap(pourMap,inst.getArg1(),inst.getArg2());
pourMems.add(inst.getArg2());
break;
case Instruction.COPYRULES:
addToMap(copyRulesMap,inst.getArg2(),inst.getArg1());
break;
}
}
for (Instruction inst : head) {
switch (inst.getKind()) {
case Instruction.LOCKMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg3());
break;
case Instruction.ANYMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
case Instruction.ANYMEM2:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg5());
break;
case Instruction.GETMEM:
headMemName.put((Integer)inst.getArg1(),(String)inst.getArg4());
break;
}
}
for (Instruction inst : body) {
switch (inst.getKind()) {
case Instruction.SETMEMNAME:
bodyMemName.put((Integer)inst.getArg1(),(String)inst.getArg2());
}
}
createReuseMap(reuseMap,reuseMems,parent,removedChildren,createdChildren,pourMap,pourMems,new Integer(0));
HashSet<Integer> set=new HashSet<Integer>();
for (Iterator<Integer> it=reuseMap.keySet().iterator(); it.hasNext(); ) {
Integer i1=it.next();
Integer i2=reuseMap.get(i1);
Integer p1=(Integer)parent.get(i1);
Integer p2=(Integer)parent.get(i2);
if (reuseMap.containsKey(p1)) {
p1=reuseMap.get(p1);
}
if (p1.equals(p2)) {
set.add(i1);
set.add(i2);
}
}
HashMap<Integer,Integer> ruleMem=new HashMap<Integer,Integer>();
HashMap<Integer,Integer> varInBody=new HashMap<Integer,Integer>();
Instruction react=head.get(head.size() - 1);
if (react.getKind() != Instruction.REACT && react.getKind() != Instruction.JUMP) {
return;
}
int i=0;
List args=(List)react.getArg2();
for (Iterator it=args.iterator(); it.hasNext(); ) {
varInBody.put((Integer)it.next(),new Integer(i++));
}
for (Iterator<Instruction> it=head.iterator(); it.hasNext(); ) {
Instruction inst=it.next();
if (inst.getKind() == Instruction.NORULES) {
varInBody.remove(inst.getArg1());
}
}
ArrayList<Instruction> tmpInsts=new ArrayList<Instruction>();
int nextArg=spec.getIntArg2();
for (Iterator<Integer> it=varInBody.keySet().iterator(); it.hasNext(); ) {
Integer memInHead=it.next();
Integer mem=varInBody.get(memInHead);
if (reuseMems.contains(mem)) {
List<Integer> copyRulesTo=copyRulesMap.get(mem);
boolean flg=false;
if (copyRulesTo == null) {
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
}
 else {
for (Integer dstmem : copyRulesTo) {
if (mem.equals(reuseMap.get(dstmem))) {
flg=true;
break;
}
}
if (!flg) {
ruleMem.put(mem,new Integer(nextArg));
tmpInsts.add(new Instruction(Instruction.ALLOCMEM,nextArg));
tmpInsts.add(new Instruction(Instruction.COPYRULES,nextArg,mem));
tmpInsts.add(new Instruction(Instruction.CLEARRULES,mem));
nextArg++;
}
}
}
}
body.addAll(1,tmpInsts);
ListIterator<Instruction> lit=body.listIterator();
while (lit.hasNext()) {
Instruction inst=lit.next();
switch (inst.getKind()) {
case Instruction.REMOVEMEM:
if (set.contains(inst.getArg1())) {
lit.remove();
}
break;
case Instruction.NEWMEM:
Integer arg1=(Integer)inst.getArg1();
if (reuseMap.containsKey(arg1)) {
lit.remove();
int m=((Integer)reuseMap.get(arg1)).intValue();
if (!set.contains(arg1)) {
lit.add(new Instruction(Instruction.ADDMEM,inst.getIntArg2(),m));
}
lit.add(new Instruction(Instruction.ENQUEUEMEM,m));
if (bodyMemName.get(arg1) == null && headMemName.get(m) != null) {
lit.add(new Instruction(Instruction.SETMEMNAME,m,null));
}
}
break;
case Instruction.MOVECELLS:
if (reuseMems.contains(inst.getArg2())) {
lit.remove();
}
break;
case Instruction.COPYRULES:
Integer srcmem=(Integer)inst.getArg2();
Integer dstmem=(Integer)inst.getArg1();
if (ruleMem.containsKey(srcmem)) {
if (!ruleMem.get(srcmem).equals(dstmem)) {
lit.remove();
lit.add(new Instruction(Instruction.COPYRULES,dstmem.intValue(),((Integer)ruleMem.get(srcmem)).intValue()));
}
}
 else if (srcmem.equals(reuseMap.get(dstmem))) {
lit.remove();
}
break;
case Instruction.FREEMEM:
if (reuseMems.contains(inst.getArg1())) {
lit.remove();
}
break;
}
}
lit.previous();
addUnlockInst(lit,reuseMap,new Integer(0),createdChildren);
for (Iterator<Integer> it=ruleMem.values().iterator(); it.hasNext(); ) {
lit.add(new Instruction(Instruction.FREEMEM,it.next()));
}
spec.updateSpec(spec.getIntArg1(),nextArg);
Instruction.changeMemVar(body,reuseMap);
}",0.9194680458071666
37617,"void addAll(FunctorAndArgument faa,Set<FunctorAndArgument> set){
  if (!faa.functor.isSymbol())   return;
  if (faa.functor.getName().equals(""String_Node_Str""))   return;
  map.addAll(faa,set);
}","void addAll(FunctorAndArgument faa,Set<FunctorAndArgument> set){
  if (!faa.functor.isSymbol())   return;
  if (faa.functor.getName().equals(""String_Node_Str""))   return;
  if (set == null) {
    set=new HashSet<FunctorAndArgument>();
  }
  map.addAll(faa,set);
}",0.851528384279476
37618,"/** 
 * LMNtal syntax �Ǥη������ɽ�� printAll �᥽�åɤ����������
 */
void printAllLMNSyntax(){
  Env.p(""String_Node_Str"");
  for (  String memname : sortedMemNames) {
    FixedCounts fcs=memnameToCounts.get(memname);
    String memNameLMN=memname.equals(""String_Node_Str"") ? ""String_Node_Str"" : memname;
    Env.p(memNameLMN + ""String_Node_Str"");
    for (    Functor f : sortedFunctors) {
      if (TypeEnv.outOfPassiveFunctor(f) != TypeEnv.ACTIVE)       continue;
      Map<Functor,TypeVarConstraint[]> functorToArgumentTypes=memnameToFunctorTypes.get(memname);
      boolean flagNoCount=false;
      if (fcs == null)       flagNoCount=true;
      IntervalCount fc=null;
      if (!flagNoCount) {
        fc=fcs.functorToCount.get(f);
        if (fc == null)         continue;
        if (fc.min.compare(new NumCount(0)) == 0 && fc.max.compare(new NumCount(0)) == 0) {
          continue;
        }
      }
      StringBuffer texp=new StringBuffer(""String_Node_Str"");
      texp.append(""String_Node_Str"");
      texp.append(f.getQuotedAtomName());
      texp.append(""String_Node_Str"");
      texp.append(f.getArity());
      texp.append(""String_Node_Str"");
      if (f.getArity() > 0) {
        if (functorToArgumentTypes != null && functorToArgumentTypes.containsKey(f)) {
          TypeVarConstraint[] argtypes=functorToArgumentTypes.get(f);
          for (int i=0; i < argtypes.length; i++) {
            if (i != 0)             texp.append(""String_Node_Str"");
            texp.append(argtypes[i].shortString());
          }
        }
 else {
          for (int i=0; i < f.getArity(); i++) {
            if (i != 0)             texp.append(""String_Node_Str"");
            texp.append(""String_Node_Str"");
          }
        }
      }
      texp.append(""String_Node_Str"");
      if (flagNoCount)       texp.append(""String_Node_Str"");
 else       texp.append(fc);
      texp.append(""String_Node_Str"");
      Env.p(texp);
    }
    if (fcs != null) {
      for (      String childname : sortedMemNames) {
        if (fcs.memnameToCount.containsKey(childname)) {
          IntervalCount fc=fcs.memnameToCount.get(childname);
          if (fc == null)           continue;
          String cname=childname.equals(""String_Node_Str"") ? ""String_Node_Str"" : childname;
          Env.p(""String_Node_Str"" + cname + ""String_Node_Str""+ fc+ ""String_Node_Str"");
        }
      }
    }
    Env.p(""String_Node_Str"");
  }
  Env.p(""String_Node_Str"");
}","/** 
 * LMNtal syntax �Ǥη������ɽ�� printAll �᥽�åɤ����������
 */
void printAllLMNSyntax(){
  Env.p(""String_Node_Str"");
  for (  String memname : sortedMemNames) {
    FixedCounts fcs=memnameToCounts.get(memname);
    String memNameLMN=memname.equals(""String_Node_Str"") ? ""String_Node_Str"" : memname;
    Env.p(memNameLMN + ""String_Node_Str"");
    for (    Functor f : sortedFunctors) {
      if (TypeEnv.outOfPassiveFunctor(f) != TypeEnv.ACTIVE)       continue;
      Map<Functor,TypeVarConstraint[]> functorToArgumentTypes=memnameToFunctorTypes.get(memname);
      boolean flagNoCount=false;
      if (fcs == null)       flagNoCount=true;
      IntervalCount fc=null;
      if (!flagNoCount) {
        fc=fcs.functorToCount.get(f);
        if (fc == null)         continue;
        if (fc.min.compare(new NumCount(0)) == 0 && fc.max.compare(new NumCount(0)) == 0) {
          continue;
        }
      }
      StringBuffer texp=new StringBuffer(""String_Node_Str"");
      texp.append(""String_Node_Str"");
      texp.append(f.getQuotedAtomName());
      texp.append(""String_Node_Str"");
      texp.append(f.getArity());
      texp.append(""String_Node_Str"");
      if (f.getArity() > 0) {
        if (functorToArgumentTypes != null && functorToArgumentTypes.containsKey(f)) {
          TypeVarConstraint[] argtypes=functorToArgumentTypes.get(f);
          for (int i=0; i < argtypes.length; i++) {
            if (i != 0)             texp.append(""String_Node_Str"");
            texp.append(argtypes[i].shortStringLMNSyntax());
          }
        }
 else {
          for (int i=0; i < f.getArity(); i++) {
            if (i != 0)             texp.append(""String_Node_Str"");
            texp.append(""String_Node_Str"");
          }
        }
      }
      texp.append(""String_Node_Str"");
      if (flagNoCount)       texp.append(""String_Node_Str"");
 else       texp.append(fc);
      texp.append(""String_Node_Str"");
      Env.p(texp);
    }
    if (fcs != null) {
      for (      String childname : sortedMemNames) {
        if (fcs.memnameToCount.containsKey(childname)) {
          IntervalCount fc=fcs.memnameToCount.get(childname);
          if (fc == null)           continue;
          String cname=childname.equals(""String_Node_Str"") ? ""String_Node_Str"" : childname;
          Env.p(""String_Node_Str"" + cname + ""String_Node_Str""+ fc+ ""String_Node_Str"");
        }
      }
    }
    Env.p(""String_Node_Str"");
  }
  Env.p(""String_Node_Str"");
}",0.9981538461538462
37619,"/** 
 * ��������˻��ꤵ�줿�롼�빽¤��롼�륪�֥������Ȥ˥���ѥ��뤹��
 */
Rule compile() throws CompileException {
  Env.c(""String_Node_Str"");
  if (debug2) {
    Util.println(""String_Node_Str"");
    Util.println(""String_Node_Str"" + rs);
    Util.println(rs.leftMem + ""String_Node_Str"" + rs.guardMem+ ""String_Node_Str""+ rs.rightMem+ ""String_Node_Str"");
  }
  liftupActiveAtoms(rs.leftMem);
  simplify();
  theRule=new Rule(rs.leftMem.getFirstAtomName(),rs.toString());
  theRule.name=rs.name;
  hc=new HeadCompiler();
  hc.enumFormals(rs.leftMem);
  hc2=new HeadCompiler();
  hc2.enumFormals(rs.leftMem);
  if (true) {
    theRule.guardLabel=new InstructionList();
    guard=theRule.guardLabel.insts;
  }
 else   guard=null;
  theRule.bodyLabel=new InstructionList();
  body=theRule.bodyLabel.insts;
  contLabel=(guard != null ? theRule.guardLabel : theRule.bodyLabel);
  compile_l();
  compile_g();
  if (debug2) {
    Util.println(""String_Node_Str"");
    Rule tmpRule=new Rule();
    tmpRule.memMatch=memMatch;
    tmpRule.tempMatch=tempMatch;
    tmpRule.atomMatch=atomMatch;
    tmpRule.guard=guard;
    tmpRule.body=body;
    tmpRule.showDetail();
  }
  hc=new HeadCompiler();
  hc.enumFormals(rs.leftMem);
  hc.firsttime=false;
  theRule.guardLabel=new InstructionList();
  guard=theRule.guardLabel.insts;
  contLabel=(guard != null ? theRule.guardLabel : theRule.bodyLabel);
  compile_l();
  compile_g();
  compile_r();
  theRule.memMatch=memMatch;
  theRule.tempMatch=tempMatch;
  theRule.atomMatch=atomMatch;
  theRule.guard=guard;
  theRule.body=body;
  theRule.body.add(1,Instruction.commit(theRule.name,theRule.lineno));
  if (debug2) {
    Util.println(""String_Node_Str"");
    theRule.showDetail();
    Util.println(""String_Node_Str"");
  }
  optimize();
  return theRule;
}","/** 
 * ��������˻��ꤵ�줿�롼�빽¤��롼�륪�֥������Ȥ˥���ѥ��뤹��
 */
Rule compile() throws CompileException {
  Env.c(""String_Node_Str"");
  if (debug2) {
    Util.println(""String_Node_Str"");
    Util.println(""String_Node_Str"" + rs);
    Util.println(rs.leftMem + ""String_Node_Str"" + rs.guardMem+ ""String_Node_Str""+ rs.rightMem+ ""String_Node_Str"");
  }
  liftupActiveAtoms(rs.leftMem);
  simplify();
  theRule=new Rule(rs.leftMem.getFirstAtomName(),rs.toString());
  theRule.name=rs.name;
  hc=new HeadCompiler();
  hc.enumFormals(rs.leftMem);
  hc2=new HeadCompiler();
  hc2.enumFormals(rs.leftMem);
  if (true) {
    theRule.guardLabel=new InstructionList();
    guard=theRule.guardLabel.insts;
  }
 else   guard=null;
  theRule.bodyLabel=new InstructionList();
  body=theRule.bodyLabel.insts;
  contLabel=(guard != null ? theRule.guardLabel : theRule.bodyLabel);
  compile_l();
  compile_g();
  if (debug2) {
    Util.println(""String_Node_Str"");
    Rule tmpRule=new Rule();
    tmpRule.memMatch=memMatch;
    tmpRule.tempMatch=tempMatch;
    tmpRule.atomMatch=atomMatch;
    tmpRule.guard=guard;
    tmpRule.body=body;
    tmpRule.showDetail();
  }
  hc=new HeadCompiler();
  hc.enumFormals(rs.leftMem);
  hc.firsttime=false;
  theRule.guardLabel=new InstructionList();
  guard=theRule.guardLabel.insts;
  contLabel=(guard != null ? theRule.guardLabel : theRule.bodyLabel);
  compile_l();
  compile_g();
  compile_r();
  theRule.memMatch=memMatch;
  theRule.tempMatch=tempMatch;
  theRule.atomMatch=atomMatch;
  theRule.guard=guard;
  theRule.body=body;
  if (theRule.name != null)   theRule.body.add(1,Instruction.commit(theRule.name,theRule.lineno));
 else   theRule.body.add(1,Instruction.commit(rs.toString(),theRule.lineno));
  if (debug2) {
    Util.println(""String_Node_Str"");
    theRule.showDetail();
    Util.println(""String_Node_Str"");
  }
  optimize();
  return theRule;
}",0.970895112575508
37620,"public void infer() throws TypeException {
  TypeEnv.initialize(root);
  boolean typeDefined=false;
  Membrane typedefmem=null;
  for (  Membrane topmem : root.mems)   if (topmem.name.equals(""String_Node_Str"")) {
    typedefmem=topmem;
    break;
  }
  TypeChecker tc=new TypeChecker();
  if (typedefmem != null) {
    typeDefined=tc.parseTypeDefinition(typedefmem);
    root.mems.remove(typedefmem);
  }
  QuantityInferer qi=new QuantityInferer(root);
  if (Env.flgQuantityInference) {
    qi.infer();
  }
  ArgumentInferer ai=new ArgumentInferer(root);
  if (Env.flgArgumentInference) {
    ai.infer();
  }
  if (typeDefined) {
    tc.check(ai,qi);
  }
  if (Env.flgShowConstraints) {
    TypePrinter tp;
    if (Env.flgArgumentInference && Env.flgQuantityInference) {
      tp=new TypePrinter(ai,qi);
      tp.printAll();
    }
  }
}","public void infer() throws TypeException {
  TypeEnv.initialize(root);
  boolean typeDefined=false;
  Membrane typedefmem=null;
  for (  Membrane topmem : root.mems)   if (TypeEnv.getMemName(topmem).equals(""String_Node_Str"")) {
    typedefmem=topmem;
    break;
  }
  TypeChecker tc=new TypeChecker();
  if (typedefmem != null) {
    typeDefined=tc.parseTypeDefinition(typedefmem);
    root.mems.remove(typedefmem);
  }
  QuantityInferer qi=new QuantityInferer(root);
  if (Env.flgQuantityInference) {
    qi.infer();
  }
  ArgumentInferer ai=new ArgumentInferer(root);
  if (Env.flgArgumentInference) {
    ai.infer();
  }
  if (typeDefined) {
    tc.check(ai,qi);
  }
  if (Env.flgShowConstraints) {
    TypePrinter tp;
    if (Env.flgArgumentInference && Env.flgQuantityInference) {
      tp=new TypePrinter(ai,qi);
      tp.printAll();
    }
  }
}",0.978067575577949
37621,"public void printAll(){
  Env.p(""String_Node_Str"");
  for (  String memname : sortedMemNames) {
    FixedCounts fcs=memnameToCounts.get(memname);
    Env.p(memname + ""String_Node_Str"");
    for (    Functor f : sortedFunctors) {
      if (TypeEnv.outOfPassiveFunctor(f) != TypeEnv.ACTIVE)       continue;
      Map<Functor,TypeVarConstraint[]> functorToArgumentTypes=memnameToFunctorTypes.get(memname);
      if (fcs.functorToCount.containsKey(f)) {
        StringBuffer texp=new StringBuffer(""String_Node_Str"");
        texp.append(""String_Node_Str"" + f.getQuotedAtomName() + ""String_Node_Str"");
        TypeVarConstraint[] argtypes=functorToArgumentTypes.get(f);
        for (int i=0; i < argtypes.length; i++) {
          if (i != 0)           texp.append(""String_Node_Str"");
          texp.append(argtypes[i].shortString());
        }
        texp.append(""String_Node_Str"");
        FixedCount fc=fcs.functorToCount.get(f);
        texp.append(""String_Node_Str"" + fc);
        Env.p(texp);
      }
    }
    for (    String childname : sortedMemNames) {
      if (fcs.memnameToCount.containsKey(childname)) {
        FixedCount fc=fcs.memnameToCount.get(childname);
        Env.p(""String_Node_Str"" + childname + ""String_Node_Str""+ fc);
      }
    }
    Env.p(""String_Node_Str"");
  }
}","public void printAll(){
  Env.p(""String_Node_Str"");
  for (  String memname : sortedMemNames) {
    FixedCounts fcs=memnameToCounts.get(memname);
    Env.p(memname + ""String_Node_Str"");
    for (    Functor f : sortedFunctors) {
      if (TypeEnv.outOfPassiveFunctor(f) != TypeEnv.ACTIVE)       continue;
      Map<Functor,TypeVarConstraint[]> functorToArgumentTypes=memnameToFunctorTypes.get(memname);
      if (fcs.functorToCount.containsKey(f)) {
        StringBuffer texp=new StringBuffer(""String_Node_Str"");
        texp.append(""String_Node_Str"" + f.getQuotedAtomName());
        if (f.getArity() > 0) {
          texp.append(""String_Node_Str"");
          TypeVarConstraint[] argtypes=functorToArgumentTypes.get(f);
          for (int i=0; i < argtypes.length; i++) {
            if (i != 0)             texp.append(""String_Node_Str"");
            texp.append(argtypes[i].shortString());
          }
          texp.append(""String_Node_Str"");
        }
        FixedCount fc=fcs.functorToCount.get(f);
        texp.append(""String_Node_Str"" + fc);
        Env.p(texp);
      }
    }
    for (    String childname : sortedMemNames) {
      if (fcs.memnameToCount.containsKey(childname)) {
        FixedCount fc=fcs.memnameToCount.get(childname);
        Env.p(""String_Node_Str"" + childname + ""String_Node_Str""+ fc);
      }
    }
    Env.p(""String_Node_Str"");
  }
}",0.9683734939759036
37622,"public static int renumberLocalsSub(List insts,int locals,int varcount){
  int max=0;
  for (int i=0; i < insts.size(); i++) {
    Instruction inst=(Instruction)insts.get(i);
    if (inst.getKind() == Instruction.NOT) {
      List subinsts=((InstructionList)inst.getArg1()).insts;
      int sub=renumberLocalsSub(subinsts,locals,varcount);
      if (sub > max)       max=sub;
    }
    if (inst.getKind() == Instruction.GUARD_INLINE) {
      ArrayList out=(ArrayList)inst.getArg3();
      for (int j=0; j < out.size(); j++) {
        renumberLocalsSub2(((Integer)out.get(j)).intValue(),locals,varcount,insts,i);
      }
    }
 else {
      if (inst.getOutputType() == -1)       continue;
      if (inst.getIntArg1() != locals) {
        renumberLocalsSub2(inst.getIntArg1(),locals,varcount,insts,i);
      }
    }
    locals++;
  }
  if (locals > max)   max=locals;
  return max;
}","public static int renumberLocalsSub(List insts,int locals,int varcount){
  int max=0;
  for (int i=0; i < insts.size(); i++) {
    Instruction inst=(Instruction)insts.get(i);
    if (inst.getKind() == Instruction.NOT) {
      List subinsts=((InstructionList)inst.getArg1()).insts;
      int sub=renumberLocalsSub(subinsts,locals,varcount);
      if (sub > max)       max=sub;
    }
    if (inst.getKind() == Instruction.GUARD_INLINE) {
      ArrayList out=(ArrayList)inst.getArg3();
      for (int j=0; j < out.size(); j++) {
        renumberLocalsSub2(((Integer)out.get(j)).intValue(),locals,varcount,insts,i);
        if (j < out.size() - 1)         locals++;
      }
    }
 else {
      if (inst.getOutputType() == -1)       continue;
      if (inst.getIntArg1() != locals) {
        renumberLocalsSub2(inst.getIntArg1(),locals,varcount,insts,i);
      }
    }
    locals++;
  }
  if (locals > max)   max=locals;
  return max;
}",0.9724061810154524
37623,"protected String quoteFunctorName(String text){
  if (Env.verbose > Env.VERBOSE_SIMPLELINK) {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
 else {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
  return text;
}","private String quoteFunctorName(String text){
  if (Env.verbose > Env.VERBOSE_SIMPLELINK) {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
 else {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
  if (getPath() != null)   text=getPath() + ""String_Node_Str"" + text;
  return text;
}",0.8481012658227848
37624,"protected String quoteAtomName(String text){
  if (!text.matches(""String_Node_Str"")) {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
  return text;
}","private String quoteAtomName(String text){
  if (!text.matches(""String_Node_Str"")) {
    if (!text.matches(""String_Node_Str"")) {
      text=quoteName(text);
    }
  }
  if (getPath() != null)   text=getPath() + ""String_Node_Str"" + text;
  return text;
}",0.7853881278538812
37625,"/** 
 * fqdn���LMNtalDaemon����³���롣
 * @param fqdn �ۥ���̾��Fully Qualified Domain Name�Ǥ������ 
 */
public static boolean makeRemoteConnection(String fqdn){
  Thread t1=new Thread(new MakeRemoteConnectionThread(),""String_Node_Str"");
  t1.start();
  if (Env.debugDaemon > 0)   System.out.println(""String_Node_Str"" + fqdn + ""String_Node_Str"");
  if (isHostRegistered(fqdn))   return true;
  Socket socket;
  try {
    socket=new Socket(fqdn,Env.daemonListenPort);
    LMNtalDaemonMessageProcessor node=new LMNtalDaemonMessageProcessor(socket);
    if (registerRemoteHostNode(node)) {
      Thread t=new Thread(node,""String_Node_Str"");
      t.start();
      return true;
    }
    node.close();
    return false;
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + fqdn + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Env.daemonListenPort);
    e.printStackTrace();
    return false;
  }
}","/** 
 * fqdn���LMNtalDaemon����³���롣
 * @param fqdn �ۥ���̾��Fully Qualified Domain Name�Ǥ������ 
 */
public static boolean makeRemoteConnection(String fqdn){
  if (Env.debugDaemon > 0)   System.out.println(""String_Node_Str"" + fqdn + ""String_Node_Str"");
  if (isHostRegistered(fqdn))   return true;
  Socket socket;
  try {
    socket=new Socket(fqdn,Env.daemonListenPort);
    LMNtalDaemonMessageProcessor node=new LMNtalDaemonMessageProcessor(socket);
    if (registerRemoteHostNode(node)) {
      Thread t=new Thread(node,""String_Node_Str"");
      t.start();
      return true;
    }
    node.close();
    return false;
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + fqdn + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Env.daemonListenPort);
    e.printStackTrace();
    return false;
  }
}",0.5636363636363636
37626,"/** 
 * �ǥХå���ɽ���᥽�åɡ� ̿���ʸ����(String)��Ϳ����ȡ���������̿���int���֤��Ƥ����
 * @author NAKAJIMA Motomu <nakajima@ueda.info.waseda.ac.jp>
 * @return String
 */
public static int getInstructionInteger(String instructionString){
  Hashtable table=new Hashtable();
  int answer=-1;
  Object tmp;
  table.put(""String_Node_Str"",new Integer(DEREF));
  table.put(""String_Node_Str"",new Integer(GETMEM));
  table.put(""String_Node_Str"",new Integer(GETPARENT));
  table.put(""String_Node_Str"",new Integer(ANYMEM));
  table.put(""String_Node_Str"",new Integer(FINDATOM));
  table.put(""String_Node_Str"",new Integer(FUNC));
  table.put(""String_Node_Str"",new Integer(NORULES));
  table.put(""String_Node_Str"",new Integer(NATOMS));
  table.put(""String_Node_Str"",new Integer(NFREELINKS));
  table.put(""String_Node_Str"",new Integer(EQ));
  table.put(""String_Node_Str"",new Integer(NEQ));
  table.put(""String_Node_Str"",new Integer(LOCK));
  table.put(""String_Node_Str"",new Integer(UNLOCK));
  table.put(""String_Node_Str"",new Integer(REMOVEATOM));
  table.put(""String_Node_Str"",new Integer(REMOVEMEM));
  table.put(""String_Node_Str"",new Integer(ADDPROXY));
  table.put(""String_Node_Str"",new Integer(REMOVEPROXY));
  table.put(""String_Node_Str"",new Integer(NEWATOM));
  table.put(""String_Node_Str"",new Integer(NEWMEM));
  table.put(""String_Node_Str"",new Integer(NEWLINK));
  table.put(""String_Node_Str"",new Integer(RELINK));
  table.put(""String_Node_Str"",new Integer(UNIFY));
  table.put(""String_Node_Str"",new Integer(DEQUEUEATOM));
  table.put(""String_Node_Str"",new Integer(DEQUEUEMEM));
  table.put(""String_Node_Str"",new Integer(MOVEMEM));
  table.put(""String_Node_Str"",new Integer(RECURSIVELOCK));
  table.put(""String_Node_Str"",new Integer(COPY));
  table.put(""String_Node_Str"",new Integer(NOT));
  table.put(""String_Node_Str"",new Integer(STOP));
  table.put(""String_Node_Str"",new Integer(REACT));
  try {
    answer=((Integer)table.get(instructionString.toUpperCase())).intValue();
  }
 catch (  NullPointerException e) {
    System.out.println(e);
    System.exit(1);
  }
  return answer;
}","/** 
 * �ǥХå���ɽ���᥽�åɡ� ̿���ʸ����(String)��Ϳ����ȡ���������̿���int���֤��Ƥ����
 * @author NAKAJIMA Motomu <nakajima@ueda.info.waseda.ac.jp>
 * @return int
 */
public static int getInstructionInteger(String instructionString){
  Hashtable table=new Hashtable();
  int answer=-1;
  Object tmp;
  table.put(""String_Node_Str"",new Integer(DEREF));
  table.put(""String_Node_Str"",new Integer(GETMEM));
  table.put(""String_Node_Str"",new Integer(GETPARENT));
  table.put(""String_Node_Str"",new Integer(ANYMEM));
  table.put(""String_Node_Str"",new Integer(FINDATOM));
  table.put(""String_Node_Str"",new Integer(FUNC));
  table.put(""String_Node_Str"",new Integer(NORULES));
  table.put(""String_Node_Str"",new Integer(NATOMS));
  table.put(""String_Node_Str"",new Integer(NFREELINKS));
  table.put(""String_Node_Str"",new Integer(EQ));
  table.put(""String_Node_Str"",new Integer(NEQ));
  table.put(""String_Node_Str"",new Integer(LOCK));
  table.put(""String_Node_Str"",new Integer(UNLOCK));
  table.put(""String_Node_Str"",new Integer(REMOVEATOM));
  table.put(""String_Node_Str"",new Integer(REMOVEMEM));
  table.put(""String_Node_Str"",new Integer(ADDPROXY));
  table.put(""String_Node_Str"",new Integer(REMOVEPROXY));
  table.put(""String_Node_Str"",new Integer(NEWATOM));
  table.put(""String_Node_Str"",new Integer(NEWMEM));
  table.put(""String_Node_Str"",new Integer(NEWLINK));
  table.put(""String_Node_Str"",new Integer(RELINK));
  table.put(""String_Node_Str"",new Integer(UNIFY));
  table.put(""String_Node_Str"",new Integer(DEQUEUEATOM));
  table.put(""String_Node_Str"",new Integer(DEQUEUEMEM));
  table.put(""String_Node_Str"",new Integer(MOVEMEM));
  table.put(""String_Node_Str"",new Integer(RECURSIVELOCK));
  table.put(""String_Node_Str"",new Integer(COPY));
  table.put(""String_Node_Str"",new Integer(NOT));
  table.put(""String_Node_Str"",new Integer(STOP));
  table.put(""String_Node_Str"",new Integer(REACT));
  try {
    answer=((Integer)table.get(instructionString.toUpperCase())).intValue();
  }
 catch (  NullPointerException e) {
    System.out.println(e);
    System.exit(1);
  }
  return answer;
}",0.997824510514866
37627,"/** 
 * 加载全局设定
 * @param settingPath 设定文件路径，相对Classpath
 */
synchronized public static void load(String settingPath){
  URL url=URLUtil.getURL(settingPath);
  if (url == null) {
    log.warn(""String_Node_Str"",settingPath);
    return;
  }
  Setting setting=new Setting(url,CharsetUtil.charset(DEFAULT_CHARSET),true);
  charset=setting.getStringWithDefault(""String_Node_Str"",DEFAULT_CHARSET);
  urlParamSeparator=setting.getStringWithDefault(""String_Node_Str"",DEFAULT_URL_PARAM_SEPERATOR);
  actionPackages=setting.getStringsWithDefault(""String_Node_Str"",new String[]{""String_Node_Str""});
  actionSuffix=setting.getStringWithDefault(""String_Node_Str"",DEFAULT_ACTION_SUFFIX);
  isDevMode=setting.getBool(""String_Node_Str"");
}","/** 
 * 加载全局设定
 * @param settingPath 设定文件路径，相对Classpath
 */
synchronized public static void load(String settingPath){
  URL url=URLUtil.getURL(settingPath);
  if (url == null) {
    log.warn(""String_Node_Str"",settingPath);
    return;
  }
  Setting setting=new Setting(url,CharsetUtil.charset(DEFAULT_CHARSET),true);
  charset=setting.getStr(""String_Node_Str"",DEFAULT_CHARSET);
  urlParamSeparator=setting.getStr(""String_Node_Str"",DEFAULT_URL_PARAM_SEPERATOR);
  actionPackages=setting.getStringsWithDefault(""String_Node_Str"",new String[]{""String_Node_Str""});
  actionSuffix=setting.getStr(""String_Node_Str"",DEFAULT_ACTION_SUFFIX);
  isDevMode=setting.getBool(""String_Node_Str"");
}",0.97008547008547
37628,"/** 
 * 将错误发送到容器
 * @param errorCode 错误代码
 * @param errorContent 错误信息
 */
public static void sendError(int errorCode,String errorContent){
  HttpServletResponse response=Response.getServletResponse();
  try {
    if (HuluSetting.isDevMode) {
      response.sendError(errorCode);
    }
 else {
      response.sendError(errorCode,errorContent);
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
}","/** 
 * 将错误发送到容器
 * @param errorCode 错误代码
 * @param errorContent 错误信息
 */
public static void sendError(int errorCode,String errorContent){
  HttpServletResponse response=Response.getServletResponse();
  try {
    if (HuluSetting.isDevMode) {
      response.sendError(errorCode);
    }
 else {
      response.sendError(errorCode,errorContent);
    }
  }
 catch (  IOException e) {
    log.error(e,""String_Node_Str"");
  }
}",0.995249406175772
37629,"/** 
 * 加载全局设定
 * @param settingPath 设定文件路径，相对Classpath
 */
synchronized public void load(String settingPath){
  URL url=URLUtil.getURL(settingPath);
  if (url == null) {
    log.info(""String_Node_Str"",settingPath);
    return;
  }
  Setting setting=new Setting(url,CharsetUtil.charset(HuluSetting.charset),true);
  maxFileSize=setting.getInt(""String_Node_Str"");
  memoryThreshold=setting.getInt(""String_Node_Str"");
  tmpUploadPath=setting.getString(""String_Node_Str"");
  fileExts=setting.getStrings(""String_Node_Str"");
  isAllowFileExts=setting.getBool(""String_Node_Str"");
}","/** 
 * 加载全局设定
 * @param settingPath 设定文件路径，相对Classpath
 */
synchronized public void load(String settingPath){
  URL url=URLUtil.getURL(settingPath);
  if (url == null) {
    log.info(""String_Node_Str"",settingPath);
    return;
  }
  Setting setting=new Setting(url,CharsetUtil.charset(HuluSetting.charset),true);
  maxFileSize=setting.getInt(""String_Node_Str"");
  memoryThreshold=setting.getInt(""String_Node_Str"");
  tmpUploadPath=setting.getStr(""String_Node_Str"");
  fileExts=setting.getStrings(""String_Node_Str"");
  isAllowFileExts=setting.getBool(""String_Node_Str"");
}",0.997384481255449
37630,"/** 
 * 处理请求
 * @param req ServletRequest
 * @param res ServletResponse
 * @param target 请求目标（请求路径）
 * @return 是否处理成功
 */
public final boolean handle(HttpServletRequest req,HttpServletResponse res,String target){
  if (HuluSetting.isDevMode) {
    log.debug(""String_Node_Str"",HttpUtil.getClientIP(req),req.getMethod(),target);
  }
  final ActionMethod actionMethod=actionMapping.getActionMethod(target);
  if (actionMethod == null || actionMethod.isHttpMethodMatch() == false) {
    return false;
  }
  fillReqAndRes(req,res);
  actionMethod.resetInterceptorPosition();
  try {
    actionMethod.invoke();
  }
 catch (  ActionException e) {
    Render.renderError500(e.getCause());
  }
 finally {
    clearReqAndRes();
  }
  return true;
}","/** 
 * 处理请求
 * @param req ServletRequest
 * @param res ServletResponse
 * @param target 请求目标（请求路径）
 * @return 是否处理成功
 */
public final boolean handle(HttpServletRequest req,HttpServletResponse res,String target){
  final String method=req.getMethod();
  if (HuluSetting.isDevMode) {
    log.debug(""String_Node_Str"",HttpUtil.getClientIP(req),method,target);
  }
  final ActionMethod actionMethod=actionMapping.getActionMethod(target);
  if (actionMethod == null || actionMethod.isHttpMethodMatch(method) == false) {
    return false;
  }
  fillReqAndRes(req,res);
  actionMethod.resetInterceptorPosition();
  try {
    actionMethod.invoke();
  }
 catch (  ActionException e) {
    Render.renderError500(e.getCause());
  }
 finally {
    clearReqAndRes();
  }
  return true;
}",0.9563492063492064
37631,"/** 
 * 指定用户请求的HTTP方法是否和定义的方法匹配<br> 用户只有在Route注解中定义方法后才会匹配有效性
 * @return 是否匹配
 */
protected boolean isHttpMethodMatch(){
  if (StrUtil.isNotBlank(httpMethod) && httpMethod.equalsIgnoreCase(Request.getServletRequest().getMethod()) == false) {
    if (HuluSetting.isDevMode) {
      StaticLog.warn(""String_Node_Str"",requestPath,Request.getServletRequest().getMethod(),httpMethod);
    }
    return false;
  }
  return true;
}","/** 
 * 指定用户请求的HTTP方法是否和定义的方法匹配<br> 用户只有在Route注解中定义方法后才会匹配有效性
 * @param method 客户端使用的Http方法
 * @return 是否匹配
 */
protected boolean isHttpMethodMatch(String method){
  if (StrUtil.isNotBlank(httpMethod) && httpMethod.equalsIgnoreCase(method) == false) {
    if (HuluSetting.isDevMode) {
      StaticLog.warn(""String_Node_Str"",requestPath,method,httpMethod);
    }
    return false;
  }
  return true;
}",0.8383961117861483
37632,"/** 
 * 忽略大小写获得请求header中的信息
 * @param headerKey 头信息的KEY
 * @return header值
 */
public final static String getHeaderIgnoreCase(String headerKey){
  Enumeration<String> headerNames=getServletRequest().getHeaderNames();
  String name=null;
  while (headerNames.hasMoreElements()) {
    name=headerNames.nextElement();
    if (name != null && name.equalsIgnoreCase(headerKey)) {
      return getHeader(headerKey);
    }
  }
  return null;
}","/** 
 * 忽略大小写获得请求header中的信息
 * @param headerKey 头信息的KEY
 * @return header值
 */
public final static String getHeaderIgnoreCase(String headerKey){
  Enumeration<String> headerNames=getServletRequest().getHeaderNames();
  String name=null;
  while (headerNames.hasMoreElements()) {
    name=headerNames.nextElement();
    if (name != null && name.equalsIgnoreCase(headerKey)) {
      return getHeader(name);
    }
  }
  return null;
}",0.9850057670126874
37633,"/** 
 * 从Request中获得Bean对象
 * @param clazz Bean类，必须包含默认造方法
 * @param isIgnoreError 是否忽略注入错误
 * @return value Object
 */
public static <T>T getBean(Class<T> clazz,final boolean isIgnoreError){
  final T bean=BeanUtil.requestParamToBean(getServletRequest(),clazz,isIgnoreError);
  final MultipartFormData multipart=getMultipart();
  if (null != multipart) {
    final String beanName=StrUtil.lowerFirst(bean.getClass().getSimpleName());
    BeanUtil.fillBean(bean,new ValueProvider<String>(){
      @Override public Object value(      String key,      Type valueType){
        String value=multipart.getParam(key);
        if (StrUtil.isEmpty(value)) {
          value=multipart.getParam(beanName + StrUtil.DOT + key);
          if (StrUtil.isEmpty(value)) {
            value=null;
          }
        }
        return value;
      }
      @Override public boolean containsKey(      String key){
        return null != multipart.getParam(key);
      }
    }
,CopyOptions.create().setIgnoreError(isIgnoreError));
  }
  return bean;
}","/** 
 * 从Request中获得Bean对象
 * @param clazz Bean类，必须包含默认造方法
 * @param isIgnoreError 是否忽略注入错误
 * @return value Object
 */
public static <T>T getBean(Class<T> clazz,final boolean isIgnoreError){
  final T bean=ServletUtil.toBean(getServletRequest(),clazz,isIgnoreError);
  final MultipartFormData multipart=getMultipart();
  if (null != multipart) {
    final String beanName=StrUtil.lowerFirst(bean.getClass().getSimpleName());
    BeanUtil.fillBean(bean,new ValueProvider<String>(){
      @Override public Object value(      String key,      Type valueType){
        String value=multipart.getParam(key);
        if (StrUtil.isEmpty(value)) {
          value=multipart.getParam(beanName + StrUtil.DOT + key);
          if (StrUtil.isEmpty(value)) {
            value=null;
          }
        }
        return value;
      }
      @Override public boolean containsKey(      String key){
        return null != multipart.getParam(key);
      }
    }
,CopyOptions.create().setIgnoreError(isIgnoreError));
  }
  return bean;
}",0.9878108239882984
37634,"/** 
 * 输出404信息
 * @param content 错误消息内容
 */
public static void render404Page(String pageContent){
  Response.setStatus(HttpServletResponse.SC_NOT_FOUND);
  Render.renderHtml(pageContent);
}","/** 
 * 输出404信息
 * @param pageContent 错误消息页面内容
 */
public static void render404Page(String pageContent){
  Response.setStatus(HttpServletResponse.SC_NOT_FOUND);
  Render.renderHtml(pageContent);
}",0.9792746113989638
37635,"/** 
 * 执行Action方法<br> 同时会执行过滤器方法<br> 此方法为递归调用，每次递归调用此方法，都会判断执行到了第几个拦截器，从而执行拦截器。<br> 当拦截器数量执行完毕后，执行本体方法
 * @param urlParam URL参数
 * @throws ActionException
 */
public void invoke() throws ActionException {
  Integer position=interceptorPosition.get();
  if (position == null) {
    position=0;
  }
  if (interceptors != null && position < interceptors.length) {
    interceptorPosition.set(position + 1);
    interceptors[position].invoke(this);
  }
 else {
    try {
      this.method.invoke(this.action);
    }
 catch (    InvocationTargetException te) {
      throw new ActionException(te);
    }
catch (    Exception e) {
      throw new ActionException(""String_Node_Str"",e);
    }
    resetInterceptorPosition();
  }
}","/** 
 * 执行Action方法<br> 同时会执行过滤器方法<br> 此方法为递归调用，每次递归调用此方法，都会判断执行到了第几个拦截器，从而执行拦截器。<br> 当拦截器数量执行完毕后，执行本体方法
 * @param urlParam URL参数
 * @throws ActionException
 */
public void invoke() throws ActionException {
  Integer position=interceptorPosition.get();
  if (position == null) {
    position=0;
  }
  if (interceptors != null && position < interceptors.length) {
    interceptorPosition.set(position + 1);
    interceptors[position].invoke(this);
  }
 else {
    try {
      this.method.invoke(this.action);
    }
 catch (    InvocationTargetException te) {
      throw new ActionException(te.getCause());
    }
catch (    Exception e) {
      throw new ActionException(""String_Node_Str"",e);
    }
    resetInterceptorPosition();
  }
}",0.9924502402196294
37636,"/** 
 * 输出404信息 TODO 404页面内容
 */
public static void render404(){
  render(HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"");
}","/** 
 * 输出404信息 TODO 404页面内容
 */
public static void render404(){
  sendError(HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"");
}",0.972972972972973
37637,"/** 
 * 在页面打印堆栈信息<br> TODO 500页面内容
 * @param e 异常
 */
public static void render500(Exception e){
  log.error(""String_Node_Str"",e);
  if (HuluSetting.isDevMode == false) {
    render(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"");
  }
  final ByteArrayOutputStream ostr=new ByteArrayOutputStream();
  try {
    e.printStackTrace(new PrintStream(ostr));
    render(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,ostr.toString(HuluSetting.charset).replace(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException e2) {
    log.error(""String_Node_Str"",e2);
  }
}","/** 
 * 在页面打印堆栈信息<br> TODO 500页面内容
 * @param e 异常
 */
public static void render500(Exception e){
  log.error(""String_Node_Str"",e);
  if (HuluSetting.isDevMode == false) {
    sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"");
    return;
  }
  final StringWriter writer=new StringWriter();
  e.printStackTrace(new PrintWriter(writer));
  render(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,writer.toString().replace(""String_Node_Str"",""String_Node_Str""));
}",0.7408105560791706
37638,"public static void render(int errorCode,String errorContent){
  HttpServletResponse response=ActionContext.getResponse();
  response.setStatus(errorCode);
  Render.render(errorContent,Render.CONTENT_TYPE_HTML,response);
}","/** 
 * 将错误发送到容器
 * @param errorCode 错误代码
 * @param errorContent 错误信息
 */
public static void render(int errorCode,String errorContent){
  HttpServletResponse response=ActionContext.getResponse();
  response.setStatus(errorCode);
  Render.render(errorContent,Render.CONTENT_TYPE_HTML,response);
}",0.8565891472868217
37639,"@Override int getData1(){
switch (type) {
case X:
case Both:
    return x;
}
return 0;
}","@Override int getData1(){
switch (type) {
case X:
case Both:
    return ax;
}
return 0;
}",0.9943502824858758
37640,"@Override int getData2(){
switch (type) {
case Y:
case Both:
    return y;
}
return 0;
}","@Override int getData2(){
switch (type) {
case Y:
case Both:
    return ay;
}
return 0;
}",0.9943502824858758
37641,"/** 
 * Sends a stop command out in the binary format.
 * @param out
 * @throws IOException 
 */
public static final void writeStopCommand(DataOutputStream out) throws IOException {
  final int elems=0;
  final int flags=HEADER_FLAG_STOP;
  final float accelX=0;
  final float accelY=0;
  final float accelZ=0;
  final float gyroX=0;
  final float gyroY=0;
  final float gyroZ=0;
  final float reservedX=0;
  final float reservedY=0;
  final float reservedZ=0;
  out.write(HEADER_BYTES);
  out.writeInt(elems);
  out.writeInt(flags);
  out.writeFloat(accelX);
  out.writeFloat(accelY);
  out.writeFloat(accelZ);
  out.writeFloat(gyroX);
  out.writeFloat(gyroY);
  out.writeFloat(gyroZ);
  out.writeFloat(reservedX);
  out.writeFloat(reservedY);
  out.writeFloat(reservedZ);
}","/** 
 * Sends a stop command out in the binary format.
 * @param out
 * @throws IOException 
 */
public static final void writeStopCommand(DataOutputStream out) throws IOException {
  final int elems=0;
  final int flags=HEADER_FLAG_STOP;
  final float accelX=0;
  final float accelY=0;
  final float accelZ=0;
  final float gyroX=0;
  final float gyroY=0;
  final float gyroZ=0;
  final float reservedX=0;
  final float reservedY=0;
  final float reservedZ=0;
  out.write(HEADER_BYTES);
  out.writeInt(elems);
  out.writeInt(flags);
  out.writeFloat(accelX);
  out.writeFloat(accelY);
  out.writeFloat(accelZ);
  out.writeFloat(gyroX);
  out.writeFloat(gyroY);
  out.writeFloat(gyroZ);
  out.writeFloat(reservedX);
  out.writeFloat(reservedY);
  out.writeFloat(reservedZ);
  out.flush();
}",0.9904153354632588
37642,"/** 
 * Executes request command
 * @param command REST request representation
 * @return Future wrapper of REST response
 * @throws RestEndpointIOException In case of error
 * @see Mono
 */
@Override public final <RQ,RS>Mono<Response<RS>> executeRequest(RestCommand<RQ,RS> command) throws RestEndpointIOException {
  URI uri=spliceUrl(command.getUri());
  HttpUriRequest rq;
  Serializer serializer;
switch (command.getHttpMethod()) {
case GET:
    rq=new HttpGet(uri);
  break;
case POST:
if (MultiPartRequest.class.equals(command.getRequest())) {
  MultiPartRequest rqData=(MultiPartRequest)command.getRequest();
  rq=buildMultipartRequest(uri,rqData);
}
 else {
  serializer=getSupportedSerializer(command.getRequest());
  rq=new HttpPost(uri);
  ((HttpPost)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
}
break;
case PUT:
serializer=getSupportedSerializer(command.getRequest());
rq=new HttpPut(uri);
((HttpPut)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
break;
case DELETE:
rq=new HttpDelete(uri);
break;
case PATCH:
serializer=getSupportedSerializer(command.getRequest());
rq=new HttpPatch(uri);
((HttpPatch)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + command.getHttpMethod() + ""String_Node_Str"");
}
return executeInternal(rq,new TypeConverterCallback<RS>(serializers,command.getResponseType()));
}","/** 
 * Executes request command
 * @param command REST request representation
 * @return Future wrapper of REST response
 * @throws RestEndpointIOException In case of error
 * @see Mono
 */
@Override public final <RQ,RS>Mono<Response<RS>> executeRequest(RestCommand<RQ,RS> command) throws RestEndpointIOException {
  URI uri=spliceUrl(command.getUri());
  HttpUriRequest rq;
  Serializer serializer;
switch (command.getHttpMethod()) {
case GET:
    rq=new HttpGet(uri);
  break;
case POST:
if (command.isMultipart()) {
  MultiPartRequest rqData=(MultiPartRequest)command.getRequest();
  rq=buildMultipartRequest(uri,rqData);
}
 else {
  serializer=getSupportedSerializer(command.getRequest());
  rq=new HttpPost(uri);
  ((HttpPost)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
}
break;
case PUT:
serializer=getSupportedSerializer(command.getRequest());
rq=new HttpPut(uri);
((HttpPut)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
break;
case DELETE:
rq=new HttpDelete(uri);
break;
case PATCH:
serializer=getSupportedSerializer(command.getRequest());
rq=new HttpPatch(uri);
((HttpPatch)rq).setEntity(new ByteArrayEntity(serializer.serialize(command.getRequest()),ContentType.create(serializer.getMimeType())));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + command.getHttpMethod() + ""String_Node_Str"");
}
return executeInternal(rq,new TypeConverterCallback<RS>(serializers,command.getResponseType()));
}",0.9812734082397004
37643,"/** 
 * Checks whether mime types is supported by this serializer implementation
 */
@Override public boolean canRead(@Nonnull MediaType mimeType,Type resultType){
  MediaType type=mimeType.withoutParameters();
  return type.is(MediaType.ANY_TEXT_TYPE) || MediaType.APPLICATION_XML_UTF_8.withoutParameters().is(type) || MediaType.JSON_UTF_8.withoutParameters().is(type) && String.class.equals(TypeToken.of(resultType).getRawType());
}","/** 
 * Checks whether mime types is supported by this serializer implementation
 */
@Override public boolean canRead(@Nonnull MediaType mimeType,Type resultType){
  MediaType type=mimeType.withoutParameters();
  return (type.is(MediaType.ANY_TEXT_TYPE) || MediaType.APPLICATION_XML_UTF_8.withoutParameters().is(type) || MediaType.JSON_UTF_8.withoutParameters().is(type)) && String.class.equals(TypeToken.of(resultType).getRawType());
}",0.9977011494252872
37644,"/** 
 * Default implementation. May be overridden in subclasses<br> Throws  {@link com.github.avarabyeu.restendpoint.http.exception.RestEndpointClientException}for client exceptions and  {@link com.github.avarabyeu.restendpoint.http.exception.RestEndpointServerException}for server exceptions<br> <p/> Throwed exceptions may be overridden in handle* methods
 */
@Override public void handle(HttpResponse rs) throws RestEndpointIOException {
  if (!hasError(rs)) {
    return;
  }
  StatusType statusType=StatusType.valueOf(rs.getStatusLine().getStatusCode());
  int statusCode=rs.getStatusLine().getStatusCode();
  String statusMessage=rs.getStatusLine().getReasonPhrase();
  byte[] errorBody=getErrorBody(rs);
switch (statusType) {
case CLIENT_ERROR:
    handleClientError(statusCode,statusMessage,errorBody);
  break;
case SERVER_ERROR:
handleServerError(statusCode,statusMessage,errorBody);
break;
default :
handleDefaultError(statusCode,statusMessage,errorBody);
break;
}
}","/** 
 * Default implementation. May be overridden in subclasses<br> Throws  {@link com.github.avarabyeu.restendpoint.http.exception.RestEndpointClientException}for client exceptions and  {@link com.github.avarabyeu.restendpoint.http.exception.RestEndpointServerException}for server exceptions<br> <p/> Throwed exceptions may be overridden in handle* methods
 */
@Override public void handle(HttpResponse rs) throws RestEndpointIOException {
  if (!hasError(rs)) {
    return;
  }
  StatusType statusType=StatusType.valueOf(rs.getStatusLine().getStatusCode());
  int statusCode=rs.getStatusLine().getStatusCode();
  String statusMessage=rs.getStatusLine().getReasonPhrase();
  byte[] errorBody=getErrorBody(rs);
switch (statusType) {
case CLIENT_ERROR:
    handleClientError(statusCode,statusMessage,errorBody);
case SERVER_ERROR:
  handleServerError(statusCode,statusMessage,errorBody);
default :
handleDefaultError(statusCode,statusMessage,errorBody);
}
}",0.8970512157268494
37645,"public Merger expand(Map<String,Object> pathParameters){
  Matcher m=PATH_VARIABLE_PATTERN.matcher(template);
  StringBuffer sb=new StringBuffer();
  while (m.find()) {
    Object replacement=pathParameters.get(m.group(1));
    if (null == replacement) {
      throw new RuntimeException(""String_Node_Str"" + m.group(1));
    }
    m.appendReplacement(sb,Matcher.quoteReplacement(replacement.toString()));
  }
  m.appendTail(sb);
  this.template=new StringBuilder(sb);
  return this;
}","public Merger expand(Map<String,Object> pathParameters){
  Matcher m=PATH_VARIABLE_PATTERN.matcher(template);
  StringBuffer sb=new StringBuffer();
  while (m.find()) {
    Object replacement=pathParameters.get(m.group(1));
    Preconditions.checkState(null != replacement,""String_Node_Str"",m.group(1));
    m.appendReplacement(sb,Matcher.quoteReplacement(replacement.toString()));
  }
  m.appendTail(sb);
  this.template=new StringBuilder(sb);
  return this;
}",0.8804232804232804
37646,"/** 
 * Default   {@link com.github.avarabyeu.restendpoint.http.RestEndpoint} binding
 * @param serializer
 * @return
 */
@Provides public RestEndpoint provideRestEndpoint(Serializer serializer){
  return new HttpClientRestEndpoint(HttpAsyncClients.createDefault(),Lists.<Serializer>newArrayList(new StringSerializer(),new ByteArraySerializer()),new DefaultErrorHandler(),""String_Node_Str"" + MOCK_PORT);
}","/** 
 * Default   {@link com.github.avarabyeu.restendpoint.http.RestEndpoint} binding
 * @return
 */
@Provides public RestEndpoint provideRestEndpoint(ErrorHandler<HttpResponse> errorHandler){
  return new HttpClientRestEndpoint(HttpAsyncClients.createDefault(),Lists.newArrayList(new StringSerializer(),new ByteArraySerializer()),errorHandler,""String_Node_Str"" + MOCK_PORT);
}",0.8388746803069054
37647,"@Override public void configure(Binder binder){
  binder.bind(new Key<ErrorHandler<HttpResponse>>(){
  }
).to(DefaultErrorHandler.class).in(Scopes.SINGLETON);
  binder.bind(MockWebServer.class).in(Scopes.NO_SCOPE);
  MockWebServer mockWebServer=new MockWebServer();
  mockWebServer.setDispatcher(new QueueDispatcher(){
    @Override public MockResponse dispatch(    RecordedRequest request) throws InterruptedException {
      Uninterruptibles.sleepUninterruptibly(5l,TimeUnit.SECONDS);
      return super.dispatch(request);
    }
  }
);
  binder.bind(MockWebServer.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(mockWebServer);
}","@Override public void configure(Binder binder){
  binder.bind(new Key<ErrorHandler<HttpResponse>>(){
  }
).to(DefaultErrorHandler.class).in(Scopes.SINGLETON);
  binder.bind(MockWebServer.class).in(Scopes.NO_SCOPE);
}",0.5005793742757821
37648,"public RestCommand(String uri,HttpMethod method,RQ request,Type responseType){
  this.httpMethod=method;
  this.request=request;
  this.uri=uri;
  this.responseType=responseType;
  validate();
}","public RestCommand(@Nonnull String uri,@Nonnull HttpMethod method,@Nullable RQ request,@Nonnull Type responseType){
  this.httpMethod=method;
  this.request=request;
  this.uri=uri;
  this.responseType=responseType;
  validate();
}",0.9129411764705884
37649,"private void validate(){
  if (HttpMethod.GET.equals(this.httpMethod) && null != this.request) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","private void validate(){
  if (!this.httpMethod.hasBody()) {
    Preconditions.checkState(null == this.request,""String_Node_Str"",this.httpMethod);
  }
}",0.6098360655737705
37650,"private static void writeFile(String path,String name,String content){
  try {
    File file=new File(path + separator + name);
    Writer output=new BufferedWriter(new FileWriter(file));
    output.write(content);
    output.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public static void writeFile(String path,String name,String content){
  try {
    File file=new File(path + separator + name);
    Writer output=new BufferedWriter(new FileWriter(file));
    output.write(content);
    output.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.9813874788494078
37651,"static void addRowToTape(String tapePath,String rowStr){
  try {
    RandomAccessFile file=new RandomAccessFile(new File(tapePath),""String_Node_Str"");
    int len=(int)file.length();
    byte[] buffer=new byte[len];
    file.readFully(buffer);
    int lineCount=0;
    for (int idx=0; idx < len; idx++) {
      if (buffer[idx] == '\n') {
        lineCount++;
      }
    }
    int curLine=0;
    int buffIdx=0;
    for (; buffIdx < len; buffIdx++) {
      if (buffer[buffIdx] == '\n') {
        if (++curLine == lineCount - 1) {
          file.seek(0);
          file.write(buffer,0,++buffIdx);
          break;
        }
      }
    }
    rowStr=rowStr.concat(""String_Node_Str"");
    file.writeBytes(rowStr);
    file.write(buffer,buffIdx,len - buffIdx);
    file.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","static void addRowToTape(String tapePath,String rowStr){
  File tmpFile=new File(tapePath);
  if (!tmpFile.exists() || tmpFile.isDirectory() || tmpFile.length() == 0) {
    return;
  }
  try {
    RandomAccessFile file=new RandomAccessFile(new File(tapePath),""String_Node_Str"");
    int len=(int)file.length();
    byte[] buffer=new byte[len];
    file.readFully(buffer);
    int lineCount=0;
    for (int idx=0; idx < len; idx++) {
      if (buffer[idx] == '\n') {
        lineCount++;
      }
    }
    int curLine=0;
    int buffIdx=0;
    for (; buffIdx < len; buffIdx++) {
      if (buffer[buffIdx] == '\n') {
        if (++curLine == lineCount - 1) {
          file.seek(0);
          file.write(buffer,0,++buffIdx);
          break;
        }
      }
    }
    rowStr=rowStr.concat(""String_Node_Str"");
    file.writeBytes(rowStr);
    file.write(buffer,buffIdx,len - buffIdx);
    file.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.92880978865406
37652,"static boolean assemble(){
  try {
    Simulator.kill();
    new File(AssemblerOptions.objectPath).delete();
    new File(AssemblerOptions.tapePath).delete();
    new File(AssemblerOptions.diagnosticPath).delete();
    new File(AssemblerOptions.listingPath).delete();
    new File(RopeUtils.removeExtension(AssemblerOptions.sourcePath) + ""String_Node_Str"").delete();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && !AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.deckEncodingChoice)) {
      buildTape();
      addRowToTape(AssemblerOptions.tapePath,""String_Node_Str"");
      buildDeck();
    }
 else {
      buildAssembly();
      addRowToTape(AssemblerOptions.tapePath,""String_Node_Str"");
    }
    process=null;
    return true;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
}","static boolean assemble(){
  try {
    Simulator.kill();
    File objFile=new File(AssemblerOptions.objectPath);
    File tapeFile=new File(AssemblerOptions.tapePath);
    File diagFile=new File(AssemblerOptions.diagnosticPath);
    File listFile=new File(AssemblerOptions.listingPath);
    File outFile=new File(RopeUtils.removeExtension(AssemblerOptions.sourcePath) + ""String_Node_Str"");
    objFile.delete();
    tapeFile.delete();
    diagFile.delete();
    listFile.delete();
    outFile.delete();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && !AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.deckEncodingChoice)) {
      buildTape();
      addRowToTape(AssemblerOptions.tapePath,""String_Node_Str"");
      buildDeck();
    }
 else {
      buildAssembly();
      addRowToTape(AssemblerOptions.tapePath,""String_Node_Str"");
    }
    if (objFile.exists() && objFile.length() == 0) {
      objFile.delete();
    }
    if (tapeFile.exists() && tapeFile.length() == 0) {
      tapeFile.delete();
    }
    if (diagFile.exists() && diagFile.length() == 0) {
      diagFile.delete();
    }
    if (listFile.exists() && listFile.length() == 0) {
      listFile.delete();
    }
    if (outFile.exists() && outFile.length() == 0) {
      outFile.delete();
    }
    process=null;
    return true;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
}",0.696969696969697
37653,"void initialize(){
  assemblerText.setText(AssemblerOptions.assemblerPath);
  listingText.setText(AssemblerOptions.listingPath);
  objectText.setText(AssemblerOptions.objectPath);
  macroText.setText(AssemblerOptions.macroPath);
  tapeText.setText(AssemblerOptions.tapePath);
  diagnosticText.setText(AssemblerOptions.diagnosticPath);
  pageText.setText(AssemblerOptions.pageLength);
  bootCheckBox.setSelected(AssemblerOptions.boot);
  deckEncodingCheckBox.setSelected(AssemblerOptions.deckEncoding);
  tapeEncodingCheckBox.setSelected(AssemblerOptions.tapeEncoding);
  listingCheckBox.setSelected(AssemblerOptions.listing);
  objectCheckBox.setSelected(AssemblerOptions.object);
  macroCheckBox.setSelected(AssemblerOptions.macro);
  tapeCheckBox.setSelected(AssemblerOptions.tape);
  diagnosticCheckBox.setSelected(AssemblerOptions.diagnostic);
  codeOkCheckBox.setSelected(AssemblerOptions.codeOk);
  interleaveCheckBox.setSelected(AssemblerOptions.interleave);
  storeCheckBox.setSelected(AssemblerOptions.store);
  dumpCheckBox.setSelected(AssemblerOptions.dump);
  convertTapeForTapeSimulatorBox.setSelected(AssemblerOptions.convertTapeForTapeSimulator);
  pageCheckBox.setSelected(AssemblerOptions.page);
  traceCheckBox.setSelected(AssemblerOptions.trace);
  traceLexerCheckBox.setSelected(AssemblerOptions.traceLexer);
  traceParserCheckBox.setSelected(AssemblerOptions.traceParser);
  traceProcessCheckBox.setSelected(AssemblerOptions.traceProcess);
  extrasCheckBox.setSelected(AssemblerOptions.extras);
  extrasExCheckBox.setSelected(AssemblerOptions.extrasEx);
  extrasEndCheckBox.setSelected(AssemblerOptions.extrasEnd);
  extrasQueueCheckBox.setSelected(AssemblerOptions.extrasQueue);
  extrasReloaderCheckBox.setSelected(AssemblerOptions.extrasReloader);
  bootNoneRadioButton.setSelected(false);
  bootIBMRadioButton.setSelected(false);
  bootVan1RadioButton.setSelected(false);
  bootVan2RadioButton.setSelected(false);
switch (AssemblerOptions.bootLoader) {
case AssemblerOptions.BOOT_NONE:
{
      bootNoneRadioButton.setSelected(true);
      break;
    }
case AssemblerOptions.BOOT_IBM:
{
    bootIBMRadioButton.setSelected(true);
    break;
  }
case AssemblerOptions.BOOT_VAN_1:
{
  bootVan1RadioButton.setSelected(true);
  break;
}
case AssemblerOptions.BOOT_VAN_2:
{
bootVan2RadioButton.setSelected(true);
break;
}
}
size1400RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_1400);
size2000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_2000);
size4000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_4000);
size8000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_8000);
size12000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_12000);
size16000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_16000);
deckEncodingSimhRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingARadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingHRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingPrintRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingSimhRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingARadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingHRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
enableBoot();
enableDeckEncoding();
enableTapeEncoding();
enablePage();
enableTrace();
enableExtras();
enableListing();
enableObject();
enableMacro();
enableTape();
enableDiagnostic();
enableTapeConversion();
}","void initialize(){
  assemblerText.setText(AssemblerOptions.assemblerPath);
  listingText.setText(AssemblerOptions.listingPath);
  objectText.setText(AssemblerOptions.objectPath);
  macroText.setText(AssemblerOptions.macroPath);
  tapeText.setText(AssemblerOptions.tapePath);
  diagnosticText.setText(AssemblerOptions.diagnosticPath);
  pageText.setText(AssemblerOptions.pageLength);
  bootCheckBox.setSelected(AssemblerOptions.boot);
  deckEncodingCheckBox.setSelected(AssemblerOptions.deckEncoding);
  tapeEncodingCheckBox.setSelected(AssemblerOptions.tapeEncoding);
  listingCheckBox.setSelected(AssemblerOptions.listing);
  objectCheckBox.setSelected(AssemblerOptions.object);
  macroCheckBox.setSelected(AssemblerOptions.macro);
  tapeCheckBox.setSelected(AssemblerOptions.tape);
  diagnosticCheckBox.setSelected(AssemblerOptions.diagnostic);
  codeOkCheckBox.setSelected(AssemblerOptions.codeOk);
  interleaveCheckBox.setSelected(AssemblerOptions.interleave);
  storeCheckBox.setSelected(AssemblerOptions.store);
  dumpCheckBox.setSelected(AssemblerOptions.dump);
  convertTapeForTapeSimulatorBox.setSelected(AssemblerOptions.convertTapeForTapeSimulator);
  pageCheckBox.setSelected(AssemblerOptions.page);
  traceCheckBox.setSelected(AssemblerOptions.trace);
  traceLexerCheckBox.setSelected(AssemblerOptions.traceLexer);
  traceParserCheckBox.setSelected(AssemblerOptions.traceParser);
  traceProcessCheckBox.setSelected(AssemblerOptions.traceProcess);
  extrasCheckBox.setSelected(AssemblerOptions.extras);
  extrasExCheckBox.setSelected(AssemblerOptions.extrasEx);
  extrasEndCheckBox.setSelected(AssemblerOptions.extrasEnd);
  extrasQueueCheckBox.setSelected(AssemblerOptions.extrasQueue);
  extrasReloaderCheckBox.setSelected(AssemblerOptions.extrasReloader);
  bootNoneRadioButton.setSelected(false);
  bootIBMRadioButton.setSelected(false);
  bootVan1RadioButton.setSelected(false);
  bootVan2RadioButton.setSelected(false);
switch (AssemblerOptions.bootLoader) {
case AssemblerOptions.BOOT_NONE:
{
      bootNoneRadioButton.setSelected(true);
      break;
    }
case AssemblerOptions.BOOT_IBM:
{
    bootIBMRadioButton.setSelected(true);
    break;
  }
case AssemblerOptions.BOOT_VAN_1:
{
  bootVan1RadioButton.setSelected(true);
  break;
}
case AssemblerOptions.BOOT_VAN_2:
{
bootVan2RadioButton.setSelected(true);
break;
}
}
size1400RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_1400);
size2000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_2000);
size4000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_4000);
size8000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_8000);
size12000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_12000);
size16000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_16000);
deckEncodingSimhRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingARadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_A));
deckEncodingHRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_H));
deckEncodingPrintRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_PRINT));
tapeEncodingSimhRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingARadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_A));
tapeEncodingHRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_H));
enableBoot();
enableDeckEncoding();
enableTapeEncoding();
enablePage();
enableTrace();
enableExtras();
enableListing();
enableObject();
enableMacro();
enableTape();
enableDiagnostic();
enableTapeConversion();
}",0.9970501474926252
37654,"private void assembleAction(){
  String line;
  messages=new ArrayList();
  removeAssemblerFiles(sourcePath);
  mainFrame.resetExecWindow();
  saveAction();
  assembleFailed=false;
  haveAssemblyErrors=false;
  if (Assembler.version()) {
    while ((line=Assembler.output()) != null) {
      messages.add(line);
    }
    Assembler.setPaths(baseName,sourcePath);
    if (Assembler.assemble()) {
      while ((line=Assembler.output()) != null) {
        System.out.println(line);
        messages.add(line);
        if (line.startsWith(""String_Node_Str"")) {
          haveAssemblyErrors=true;
        }
      }
      messageList.setListData(messages.toArray());
      messageList.ensureIndexIsVisible(0);
      mainFrame.showExecWindow(baseName);
    }
 else {
      assembleFailed=true;
    }
  }
 else {
    assembleFailed=true;
  }
  if (assembleFailed) {
    String message=String.format(""String_Node_Str"",AssemblerOptions.assemblerPath);
    System.out.println(message);
    JOptionPane.showMessageDialog(this,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","private void assembleAction(){
  String line;
  messages=new ArrayList();
  mainFrame.resetExecWindow();
  saveAction();
  assembleFailed=false;
  haveAssemblyErrors=false;
  if (Assembler.version()) {
    while ((line=Assembler.output()) != null) {
      messages.add(line);
    }
    Assembler.setPaths(baseName,sourcePath);
    if (Assembler.assemble()) {
      while ((line=Assembler.output()) != null) {
        System.out.println(line);
        messages.add(line);
        if (line.startsWith(""String_Node_Str"")) {
          haveAssemblyErrors=true;
        }
      }
      messageList.setListData(messages.toArray());
      messageList.ensureIndexIsVisible(0);
      mainFrame.showExecWindow(baseName);
    }
 else {
      assembleFailed=true;
    }
  }
 else {
    assembleFailed=true;
  }
  if (assembleFailed) {
    String message=String.format(""String_Node_Str"",AssemblerOptions.assemblerPath);
    System.out.println(message);
    JOptionPane.showMessageDialog(this,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.9829383886255924
37655,"void removeAssemblerFiles(String sourcePath){
  if (sourcePath == null || sourcePath.length() == 0) {
    return;
  }
  String basePath=""String_Node_Str"";
  int endIndex=sourcePath.lastIndexOf(""String_Node_Str"");
  if (endIndex != -1) {
    basePath=sourcePath.substring(0,endIndex);
  }
  System.out.println(basePath);
  try {
    File file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","void removeAssemblerFiles(String sourcePath){
  if (sourcePath == null || sourcePath.length() == 0) {
    return;
  }
  String basePath=""String_Node_Str"";
  int endIndex=sourcePath.lastIndexOf(""String_Node_Str"");
  if (endIndex != -1) {
    basePath=sourcePath.substring(0,endIndex);
  }
  System.out.println(basePath);
  try {
    File file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
    file=new File(basePath + ""String_Node_Str"");
    if (file.exists()) {
      file.delete();
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.8734335839598998
37656,"public static boolean renameAndDelete(File file){
  String filePath=pathComponent(file.getParent());
  String fileName=getFileName(file.getParent());
  String timeStr=""String_Node_Str"" + System.currentTimeMillis();
  String renamed=filePath + removeExtension(fileName) + ""String_Node_Str""+ timeStr+ ""String_Node_Str""+ getExtension(fileName);
  File renamedFile=new File(renamed);
  file.renameTo(renamedFile);
  renamedFile.delete();
  if (renamedFile.exists()) {
    renamedFile.setWritable(false);
    renamedFile.delete();
    if (renamedFile.exists()) {
      return false;
    }
  }
  return true;
}","public static boolean renameAndDelete(File file){
  String filePath=pathComponent(file.getPath());
  String fileName=getFileName(file.getPath());
  String timeStr=""String_Node_Str"" + System.currentTimeMillis();
  String renamed=filePath + removeExtension(fileName) + ""String_Node_Str""+ timeStr+ ""String_Node_Str""+ getExtension(fileName);
  File renamedFile=new File(renamed);
  file.renameTo(renamedFile);
  renamedFile.delete();
  if (renamedFile.exists()) {
    renamedFile.setWritable(false);
    renamedFile.delete();
    if (renamedFile.exists()) {
      return false;
    }
  }
  return true;
}",0.9900332225913622
37657,"public void saveAction(){
  BufferedWriter sourceFile=null;
  try {
    Boolean removedInvalidChars=false;
    String cleanText=cleanupSource(sourceArea.getText(),removedInvalidChars);
    int caretPos=sourceArea.getCaretPosition();
    sourceArea.setText(cleanText);
    sourceArea.setCaretPosition(caretPos);
    if (removedInvalidChars) {
      String message=String.format(""String_Node_Str"");
      JOptionPane.showMessageDialog(this,message,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    }
    sourceFile=new BufferedWriter(new FileWriter(sourcePath,false));
    sourceFile.write(cleanText);
    setSourceChanged(false);
    setupMenus();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    if (sourceFile != null) {
      try {
        sourceFile.close();
      }
 catch (      IOException ignore) {
      }
    }
  }
}","public void saveAction(){
  BufferedWriter sourceFile=null;
  try {
    BoolRef removedInvalidChars=new BoolRef(false);
    String cleanText=cleanupSource(sourceArea.getText(),removedInvalidChars);
    int caretPos=sourceArea.getCaretPosition();
    sourceArea.setText(cleanText);
    sourceArea.setCaretPosition(caretPos > cleanText.length() ? cleanText.length() : caretPos);
    if (removedInvalidChars.value) {
      String message=String.format(""String_Node_Str"");
      JOptionPane.showMessageDialog(this,message,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    }
    sourceFile=new BufferedWriter(new FileWriter(sourcePath,false));
    sourceFile.write(cleanText);
    setSourceChanged(false);
    setupMenus();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    if (sourceFile != null) {
      try {
        sourceFile.close();
      }
 catch (      IOException ignore) {
      }
    }
  }
}",0.9507278835386338
37658,"String cleanupSource(String source,Boolean removedInvalidChars) throws Exception {
  removedInvalidChars=false;
  if (source.isEmpty()) {
    return source.concat(""String_Node_Str"");
  }
  String timeID=getTimeID();
  int lastChIdx=source.length() - 1;
  if (source.charAt(lastChIdx) != '\n') {
    source=source.concat(""String_Node_Str"");
  }
 else {
    int removedNewlines=0;
    while (lastChIdx >= 1) {
      Character ch1=source.charAt(lastChIdx);
      if (ch1 == '\n' || Character.isWhitespace(ch1)) {
        source=source.substring(0,lastChIdx--);
        removedNewlines++;
      }
 else {
        break;
      }
    }
    removedInvalidChars=(removedNewlines > 1);
    source=source.concat(""String_Node_Str"");
  }
  boolean jobCardModified=false;
  List<String> lines=new ArrayList<>();
  try (BufferedReader reader=new BufferedReader(new StringReader(source))){
    String line;
    while ((line=reader.readLine()) != null) {
      if (line.length() >= 18 && line.substring(15,18).compareTo(""String_Node_Str"") == 0) {
        if (line.length() < 75) {
          line=String.format(""String_Node_Str"",line);
        }
 else         if (line.length() > 75) {
          line=line.substring(0,75);
        }
        line=line.concat(timeID);
        System.out.println(""String_Node_Str"" + timeID + ""String_Node_Str""+ baseName+ ""String_Node_Str""+ fileExt);
        jobCardModified=true;
      }
      lines.add(line);
    }
  }
   if (jobCardModified) {
    StringWriter writer=new StringWriter();
    for (    String line : lines) {
      writer.write(line + ""String_Node_Str"");
    }
    source=writer.toString();
  }
  return source;
}","String cleanupSource(String source,BoolRef removedInvalidChars) throws Exception {
  removedInvalidChars.value=false;
  if (source.isEmpty()) {
    return source.concat(""String_Node_Str"");
  }
  String timeID=getTimeID();
  int lastChIdx=source.length() - 1;
  if (source.charAt(lastChIdx) != '\n') {
    source=source.concat(""String_Node_Str"");
  }
 else {
    int removedNewlines=0;
    while (lastChIdx >= 1) {
      Character ch1=source.charAt(lastChIdx);
      if (ch1 == '\n' || Character.isWhitespace(ch1)) {
        source=source.substring(0,lastChIdx--);
        removedNewlines++;
      }
 else {
        break;
      }
    }
    removedInvalidChars.value=(removedNewlines > 1);
    source=source.concat(""String_Node_Str"");
  }
  boolean jobCardModified=false;
  List<String> lines=new ArrayList<>();
  try (BufferedReader reader=new BufferedReader(new StringReader(source))){
    String line;
    while ((line=reader.readLine()) != null) {
      if (line.length() >= 18 && line.substring(15,18).compareTo(""String_Node_Str"") == 0) {
        if (line.length() < 75) {
          line=String.format(""String_Node_Str"",line);
        }
 else         if (line.length() > 75) {
          line=line.substring(0,75);
        }
        line=line.concat(timeID);
        System.out.println(""String_Node_Str"" + timeID + ""String_Node_Str""+ baseName+ ""String_Node_Str""+ fileExt);
        jobCardModified=true;
      }
      lines.add(line);
    }
  }
   if (jobCardModified) {
    StringWriter writer=new StringWriter();
    for (    String line : lines) {
      writer.write(line + ""String_Node_Str"");
    }
    source=writer.toString();
  }
  return source;
}",0.994548758328286
37659,"void jbInit() throws Exception {
  titledBorder1=new TitledBorder(BorderFactory.createLineBorder(new Color(153,153,153),2),""String_Node_Str"");
  this.getContentPane().setLayout(borderLayout1);
  this.setIconifiable(true);
  this.setMaximizable(true);
  this.setResizable(true);
  this.setTitle(""String_Node_Str"");
  splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
  splitPane.setDividerLocation(470);
  sourceArea.setFont(new java.awt.Font(""String_Node_Str"",0,12));
  controlPanel.setLayout(gridBagLayout1);
  controlPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  positionPanel.setLayout(gridBagLayout2);
  fileLabel.setText(""String_Node_Str"");
  fileText.setEditable(false);
  browseButton.setSelected(false);
  browseButton.setText(""String_Node_Str"");
  assembleButton.setEnabled(false);
  assembleButton.setText(""String_Node_Str"");
  saveButton.setEnabled(false);
  saveButton.setText(""String_Node_Str"");
  saveMessagesButton.setEnabled(true);
  saveMessagesButton.setText(""String_Node_Str"");
  lineLabel.setText(""String_Node_Str"");
  lineText.setMinimumSize(new Dimension(50,20));
  lineText.setPreferredSize(new Dimension(50,20));
  lineText.setEditable(false);
  columnLabel.setText(""String_Node_Str"");
  columnText.setMinimumSize(new Dimension(41,20));
  columnText.setPreferredSize(new Dimension(41,20));
  columnText.setEditable(false);
  columnText.setText(""String_Node_Str"");
  messageScrollPane.setBorder(titledBorder1);
  messageScrollPane.setMinimumSize(new Dimension(33,61));
  messageScrollPane.setPreferredSize(new Dimension(60,90));
  optionsButton.setEnabled(false);
  optionsButton.setText(""String_Node_Str"");
  messageScrollPane.getViewport().add(messageList,null);
  messageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.getContentPane().add(splitPane,BorderLayout.CENTER);
  splitPane.add(textScrollPane,JSplitPane.TOP);
  splitPane.add(controlPanel,JSplitPane.BOTTOM);
  textScrollPane.getViewport().add(sourceArea,null);
  controlPanel.add(fileLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(fileText,new GridBagConstraints(1,0,3,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  controlPanel.add(browseButton,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  controlPanel.add(positionPanel,new GridBagConstraints(0,1,4,1,0.8,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  positionPanel.add(lineLabel,new GridBagConstraints(0,0,1,1,0.6,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  positionPanel.add(lineText,new GridBagConstraints(1,0,1,1,0.6,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,5,0,0),0,0));
  positionPanel.add(columnLabel,new GridBagConstraints(2,0,1,1,0.7,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,10,0,0),0,0));
  positionPanel.add(columnText,new GridBagConstraints(3,0,1,1,0.7,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,5,0,0),0,0));
  controlPanel.add(messageScrollPane,new GridBagConstraints(0,2,5,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  controlPanel.add(saveMessagesButton,new GridBagConstraints(1,1,1,1,0.1,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(optionsButton,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(assembleButton,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(saveButton,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
}","void jbInit() throws Exception {
  titledBorder1=new TitledBorder(BorderFactory.createLineBorder(new Color(153,153,153),2),""String_Node_Str"");
  this.getContentPane().setLayout(borderLayout1);
  this.setIconifiable(true);
  this.setMaximizable(true);
  this.setResizable(true);
  this.setTitle(""String_Node_Str"");
  splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
  splitPane.setDividerLocation(470);
  sourceArea.setFont(new java.awt.Font(""String_Node_Str"",0,12));
  controlPanel.setLayout(gridBagLayout1);
  controlPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  positionPanel.setLayout(gridBagLayout2);
  fileLabel.setText(""String_Node_Str"");
  fileText.setEditable(false);
  browseButton.setSelected(false);
  browseButton.setText(""String_Node_Str"");
  assembleButton.setEnabled(false);
  assembleButton.setText(""String_Node_Str"");
  saveButton.setEnabled(false);
  saveButton.setText(""String_Node_Str"");
  saveMessagesButton.setEnabled(true);
  saveMessagesButton.setText(""String_Node_Str"");
  lineLabel.setText(""String_Node_Str"");
  lineText.setMinimumSize(new Dimension(50,20));
  lineText.setPreferredSize(new Dimension(50,20));
  lineText.setEditable(false);
  columnLabel.setText(""String_Node_Str"");
  columnText.setMinimumSize(new Dimension(41,20));
  columnText.setPreferredSize(new Dimension(41,20));
  columnText.setEditable(false);
  columnText.setText(""String_Node_Str"");
  messageScrollPane.setBorder(titledBorder1);
  messageScrollPane.setMinimumSize(new Dimension(33,61));
  messageScrollPane.setPreferredSize(new Dimension(60,90));
  optionsButton.setEnabled(false);
  optionsButton.setText(""String_Node_Str"");
  messageScrollPane.getViewport().add(messageList,null);
  messageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.getContentPane().add(splitPane,BorderLayout.CENTER);
  splitPane.add(textScrollPane,JSplitPane.TOP);
  splitPane.add(controlPanel,JSplitPane.BOTTOM);
  textScrollPane.getViewport().add(sourceArea,null);
  saveMessagesButton.setVisible(false);
  controlPanel.add(fileLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(fileText,new GridBagConstraints(1,0,3,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  controlPanel.add(browseButton,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  controlPanel.add(positionPanel,new GridBagConstraints(0,1,4,1,0.8,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  positionPanel.add(lineLabel,new GridBagConstraints(0,0,1,1,0.6,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  positionPanel.add(lineText,new GridBagConstraints(1,0,1,1,0.6,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,5,0,0),0,0));
  positionPanel.add(columnLabel,new GridBagConstraints(2,0,1,1,0.7,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,10,0,0),0,0));
  positionPanel.add(columnText,new GridBagConstraints(3,0,1,1,0.7,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,5,0,0),0,0));
  controlPanel.add(messageScrollPane,new GridBagConstraints(0,2,5,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  controlPanel.add(saveMessagesButton,new GridBagConstraints(1,1,1,1,0.1,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(optionsButton,new GridBagConstraints(2,1,1,1,0.2,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(assembleButton,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  controlPanel.add(saveButton,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
}",0.9933774834437086
37660,"EditFrame(RopeFrame parent){
  super(parent);
  setLocation(0,0);
  setSize(670,668);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  sourceArea.addCaretListener(this);
  browseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  assembleButton.addActionListener(this);
  saveButton.addActionListener(this);
  saveMessagesButton.addActionListener(this);
  messageList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      highlightError(messageList.locationToIndex(event.getPoint()));
    }
  }
);
  undoMgr=new CompoundUndoManager(sourceArea);
  undoAction=undoMgr.getUndoAction();
  redoAction=undoMgr.getRedoAction();
  undoMgr.updateUndoAction=new UpdateUndoAction();
  undoMgr.updateRedoAction=new UpdateRedoAction();
  document=sourceArea.getDocument();
  ActionMap am=sourceArea.getActionMap();
  InputMap im=sourceArea.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
  String action=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),action);
  am.put(action,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int endLine=sourceArea.getLineEndOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos >= 39 && linePos < 79) {
          caretPos=startLine + linePos + 10 - ((linePos + 1) % 10);
        }
 else         if (linePos >= 20 && linePos <= 39) {
          caretPos=startLine + 39;
        }
 else         if (linePos >= 15 && linePos <= 19) {
          caretPos=startLine + 20;
        }
 else         if (linePos >= 5 && linePos <= 14) {
          caretPos=startLine + 15;
        }
 else {
          caretPos=startLine + 5;
        }
        if (caretPos > endLine) {
          StringBuilder str=new StringBuilder();
          int size=caretPos - endLine;
          while (size-- >= 0) {
            str.append(' ');
          }
          document.insertString(endLine - 1,str.toString(),null);
        }
        sourceArea.setCaretPosition(caretPos);
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  String actionKey=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),actionKey);
  am.put(actionKey,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int endLine=sourceArea.getLineEndOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos == 15) {
          int endPos=5;
          int charPos=linePos;
          for (; charPos > endPos; charPos--) {
            char ch=sourceArea.getText().charAt((startLine + charPos) - 1);
            if (!Character.isWhitespace(ch)) {
              break;
            }
          }
          sourceArea.setCaretPosition(startLine + charPos);
        }
 else {
          int startSel=sourceArea.getSelectionStart();
          int endSel=sourceArea.getSelectionEnd();
          if (startSel == endSel) {
            startSel=caretPos - 1;
            endSel=caretPos;
          }
          StringBuilder sb=new StringBuilder(sourceArea.getText());
          sb.replace(startSel,endSel,""String_Node_Str"");
          sourceArea.setText(sb.toString());
          sourceArea.setCaretPosition(startSel);
        }
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  action=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),action);
  am.put(action,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos >= 5) {
          document.insertString(caretPos,""String_Node_Str"",null);
        }
 else {
          document.insertString(caretPos,""String_Node_Str"",null);
        }
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  document.addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void removeUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void changedUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
  }
);
}","EditFrame(RopeFrame parent){
  super(parent);
  setLocation(0,0);
  setSize(670,668);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  sourceArea.addCaretListener(this);
  browseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  assembleButton.addActionListener(this);
  saveButton.addActionListener(this);
  saveMessagesButton.addActionListener(this);
  messageList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      highlightError(messageList.locationToIndex(event.getPoint()));
    }
  }
);
  undoMgr=new CompoundUndoManager(sourceArea);
  undoAction=undoMgr.getUndoAction();
  redoAction=undoMgr.getRedoAction();
  undoMgr.updateUndoAction=new UpdateUndoAction();
  undoMgr.updateRedoAction=new UpdateRedoAction();
  document=sourceArea.getDocument();
  ActionMap am=sourceArea.getActionMap();
  InputMap im=sourceArea.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
  String action=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),action);
  am.put(action,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int endLine=sourceArea.getLineEndOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos >= 39 && linePos < 79) {
          caretPos=startLine + linePos + 10 - ((linePos + 1) % 10);
        }
 else         if (linePos >= 20 && linePos <= 39) {
          caretPos=startLine + 39;
        }
 else         if (linePos >= 15 && linePos <= 19) {
          caretPos=startLine + 20;
        }
 else         if (linePos >= 5 && linePos <= 14) {
          caretPos=startLine + 15;
        }
 else {
          caretPos=startLine + 5;
        }
        if (caretPos > endLine) {
          StringBuilder str=new StringBuilder();
          int size=caretPos - endLine;
          while (size-- >= 0) {
            str.append(' ');
          }
          document.insertString(endLine - 1,str.toString(),null);
        }
        sourceArea.setCaretPosition(caretPos);
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  String actionKey=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),actionKey);
  am.put(actionKey,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int endLine=sourceArea.getLineEndOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos == 15) {
          int endPos=5;
          int charPos=linePos;
          for (; charPos > endPos; charPos--) {
            char ch=sourceArea.getText().charAt((startLine + charPos) - 1);
            if (!Character.isWhitespace(ch)) {
              break;
            }
          }
          sourceArea.setCaretPosition(startLine + charPos);
        }
 else {
          int startSel=sourceArea.getSelectionStart();
          int endSel=sourceArea.getSelectionEnd();
          if (startSel == endSel) {
            startSel=caretPos - 1;
            endSel=caretPos;
          }
          StringBuilder sb=new StringBuilder(sourceArea.getText());
          sb.replace(startSel,endSel,""String_Node_Str"");
          sourceArea.setText(sb.toString());
          sourceArea.setCaretPosition(startSel);
        }
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  action=""String_Node_Str"";
  im.put(KeyStroke.getKeyStroke(""String_Node_Str""),action);
  am.put(action,new AbstractAction(){
    private static final long serialVersionUID=1L;
    @Override public void actionPerformed(    ActionEvent e){
      try {
        int caretPos=sourceArea.getCaretPosition();
        int lineNum=sourceArea.getLineOfOffset(caretPos);
        int startLine=sourceArea.getLineStartOffset(lineNum);
        int linePos=caretPos - startLine;
        if (linePos >= 5) {
          document.insertString(caretPos,""String_Node_Str"",null);
        }
 else {
          document.insertString(caretPos,""String_Node_Str"",null);
        }
      }
 catch (      BadLocationException ex) {
        ex.printStackTrace();
      }
    }
  }
);
  document.addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void removeUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void changedUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
  }
);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      fileText.setText(sourcePath);
    }
  }
);
}",0.9853649986854788
37661,"private void startAction(){
  if (programRunning) {
synchronized (Simulator.class) {
      Simulator.execute(""String_Node_Str"");
      processOutput(true);
    }
  }
 else {
synchronized (Simulator.class) {
      Simulator.execute(""String_Node_Str"");
      processOutput(false);
    }
    dataButton.setEnabled(false);
    quitButton.setEnabled(true);
    singleStepButton.setEnabled(true);
    autoStepButton.setEnabled(true);
    programRunning=true;
  }
  mainFrame.updateCommandWindows();
  mainFrame.enableSenseSwitches();
  if (Simulator.isBusy()) {
    startButton.setText(""String_Node_Str"");
    quitButton.setEnabled(false);
    singleStepButton.setEnabled(false);
    autoStepButton.setEnabled(false);
  }
 else {
    startButton.setText(""String_Node_Str"");
  }
}","private void startAction(){
  if (programRunning) {
synchronized (Simulator.class) {
      Simulator.execute(""String_Node_Str"");
      processOutput(true);
    }
  }
 else {
synchronized (Simulator.class) {
      Simulator.execute(""String_Node_Str"");
      processOutput(false);
    }
    dataButton.setEnabled(false);
    quitButton.setEnabled(true);
    singleStepButton.setEnabled(true);
    autoStepButton.setEnabled(true);
    programRunning=true;
  }
  mainFrame.updateCommandWindows();
  mainFrame.enableSenseSwitches();
  if (Simulator.isBusy()) {
    startButton.setText(""String_Node_Str"");
    quitButton.setEnabled(false);
    singleStepButton.setEnabled(false);
    autoStepButton.setEnabled(false);
  }
 else {
    startButton.setText(""String_Node_Str"");
    quitButton.setEnabled(true);
    singleStepButton.setEnabled(true);
    autoStepButton.setEnabled(true);
  }
}",0.9341389728096676
37662,"@Override public void mouseReleased(MouseEvent event){
  if (settingBreakpoint && event.getX() <= 16) {
    flipBreakpoint(listing.locationToIndex(event.getPoint()));
  }
 else {
    Point mouseLoc=event.getPoint();
    int idx=listing.locationToIndex(mouseLoc);
    if (idx >= 0) {
      Rectangle bounds=listing.getCellBounds(idx,idx);
      if (bounds.contains(mouseLoc)) {
        if (listing.getSelectedIndex() != idx) {
          ListingLine line=(ListingLine)listing.getModel().getElementAt(idx);
          if (line.breakable) {
            listing.setSelectedIndex(idx);
          }
        }
      }
    }
  }
  repaint();
  settingBreakpoint=false;
}","@Override public void mouseReleased(MouseEvent event){
  if (settingBreakpoint && event.getX() <= 16) {
    flipBreakpoint(listing.locationToIndex(event.getPoint()));
  }
 else {
  }
  repaint();
  settingBreakpoint=false;
}",0.5067873303167421
37663,"public ExecFrame(RopeFrame parent){
  super(parent);
  setLocation(672,0);
  setSize(990,668);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  simulatorButton.addActionListener(this);
  optionsButton.addActionListener(this);
  dataButton.addActionListener(this);
  showAllCheckBox.addChangeListener(this);
  startButton.addActionListener(this);
  quitButton.addActionListener(this);
  singleStepButton.addActionListener(this);
  autoStepButton.addActionListener(this);
  slowerButton.addActionListener(this);
  fasterButton.addActionListener(this);
  showMemoryButton.addActionListener(this);
  showConsoleButton.addActionListener(this);
  showTimerButton.addActionListener(this);
  listingFont=new Font(""String_Node_Str"",Font.PLAIN,12);
  java.net.URL imgUrl=getClass().getResource(""String_Node_Str"");
  nobreakIcon=new ImageIcon(imgUrl);
  imgUrl=getClass().getResource(""String_Node_Str"");
  breakableIcon=new ImageIcon(imgUrl);
  imgUrl=getClass().getResource(""String_Node_Str"");
  breakPointIcon=new ImageIcon(imgUrl);
  listing.setCellRenderer(new ListingLineRenderer());
  listing.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent event){
      if (simulatorRunning && event.getX() <= 16) {
        settingBreakpoint=true;
      }
    }
    @Override public void mouseReleased(    MouseEvent event){
      if (settingBreakpoint && event.getX() <= 16) {
        flipBreakpoint(listing.locationToIndex(event.getPoint()));
      }
 else {
        Point mouseLoc=event.getPoint();
        int idx=listing.locationToIndex(mouseLoc);
        if (idx >= 0) {
          Rectangle bounds=listing.getCellBounds(idx,idx);
          if (bounds.contains(mouseLoc)) {
            if (listing.getSelectedIndex() != idx) {
              ListingLine line=(ListingLine)listing.getModel().getElementAt(idx);
              if (line.breakable) {
                listing.setSelectedIndex(idx);
              }
            }
          }
        }
      }
      repaint();
      settingBreakpoint=false;
    }
    @Override public void mouseClicked(    MouseEvent event){
    }
  }
);
  listing.addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseDragged(    MouseEvent event){
    }
  }
);
  InputMap im=listing.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
}","public ExecFrame(RopeFrame parent){
  super(parent);
  setLocation(672,0);
  setSize(990,668);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  simulatorButton.addActionListener(this);
  optionsButton.addActionListener(this);
  dataButton.addActionListener(this);
  showAllCheckBox.addChangeListener(this);
  startButton.addActionListener(this);
  quitButton.addActionListener(this);
  singleStepButton.addActionListener(this);
  autoStepButton.addActionListener(this);
  slowerButton.addActionListener(this);
  fasterButton.addActionListener(this);
  showMemoryButton.addActionListener(this);
  showConsoleButton.addActionListener(this);
  showTimerButton.addActionListener(this);
  listingFont=new Font(""String_Node_Str"",Font.PLAIN,12);
  java.net.URL imgUrl=getClass().getResource(""String_Node_Str"");
  nobreakIcon=new ImageIcon(imgUrl);
  imgUrl=getClass().getResource(""String_Node_Str"");
  breakableIcon=new ImageIcon(imgUrl);
  imgUrl=getClass().getResource(""String_Node_Str"");
  breakPointIcon=new ImageIcon(imgUrl);
  listing.setCellRenderer(new ListingLineRenderer());
  listing.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent event){
      if (simulatorRunning && event.getX() <= 16) {
        settingBreakpoint=true;
      }
    }
    @Override public void mouseReleased(    MouseEvent event){
      if (settingBreakpoint && event.getX() <= 16) {
        flipBreakpoint(listing.locationToIndex(event.getPoint()));
      }
 else {
      }
      repaint();
      settingBreakpoint=false;
    }
    @Override public void mouseClicked(    MouseEvent event){
    }
  }
);
  listing.addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseDragged(    MouseEvent event){
    }
  }
);
  InputMap im=listing.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
}",0.911465892597968
37664,"private void loadListing(){
  clearListing();
  ArrayList v=filterListing();
  if (v != null) {
    listing.setListData(v.toArray());
    if (currentMessage == null) {
      listing.ensureIndexIsVisible(0);
    }
 else {
      selectCurrentLine(currentMessage);
    }
    checkListContent();
  }
}","private void loadListing(){
  clearListing();
  if (filterListing() != null) {
    listing.setListData(filterListing().toArray());
    if (currentMessage == null) {
      listing.ensureIndexIsVisible(0);
    }
 else {
      selectCurrentLine(currentMessage);
    }
    checkListContent();
  }
}",0.8798646362098139
37665,"static void kill(){
  if (process != null) {
    process.destroy();
    System.out.println(""String_Node_Str"");
    isActive=false;
    isBusy=false;
  }
}","static void kill(){
  if (process != null) {
    process.destroy();
    System.out.println(""String_Node_Str"");
    isActive=false;
  }
}",0.9379310344827586
37666,"static String output(){
  try {
    String output=""String_Node_Str"";
    if (stdout.ready()) {
      output=stdout.readLine();
      isBusy=false;
    }
 else {
      isBusy=true;
    }
    simulatorElapsedTime+=System.currentTimeMillis() - simulatorStartTime;
    simulatorStartTime=System.currentTimeMillis();
    if (output.length() > 0) {
      System.out.println(output);
    }
    return output;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return null;
  }
}","static String output(){
  try {
    String output=""String_Node_Str"";
    if (stdout.ready()) {
      isBusy=true;
      output=stdout.readLine();
      isBusy=false;
    }
    simulatorElapsedTime+=System.currentTimeMillis() - simulatorStartTime;
    simulatorStartTime=System.currentTimeMillis();
    if (output.length() > 0) {
      System.out.println(output);
    }
    return output;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return null;
  }
}",0.9452631578947368
37667,"public void showMemory(){
  int from=0;
  int to=0;
  try {
    String toString=toText.getText().trim();
    from=Integer.parseInt(fromText.getText().trim());
    to=(toString.length() == 0) ? from : Integer.parseInt(toString);
    if ((from < 0) || (from > 15999) || (to < 0)|| (to > 15999)|| (from > to)) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    memoryArea.setText(""String_Node_Str"" + ex.getMessage());
    return;
  }
  setTitle(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  int offset=to - from;
  int last=offset - (offset % 50) + from;
  StringBuilder buffer=new StringBuilder(1024);
  if (Simulator.isActive()) {
synchronized (Simulator.class) {
      Simulator.output();
      Simulator.execute(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      for (; ; ) {
        String text=Simulator.output();
        if (TextIsValidForMemoryDump(text)) {
          int idx=text.indexOf(""String_Node_Str"");
          if (idx > 0 && idx <= 6) {
            StringBuilder strBuild=new StringBuilder(text);
            strBuild.setCharAt(idx,' ');
            text=strBuild.toString();
          }
          buffer.append(text).append('\n');
          if (idx >= 0 && idx <= 6) {
            try {
              String numberStr=text.substring(0,idx).replaceAll(""String_Node_Str"",""String_Node_Str"");
              int address=Integer.parseInt(numberStr);
              if (address == last) {
                break;
              }
            }
 catch (            Exception ex) {
              ex.printStackTrace();
            }
          }
        }
      }
      do {
        String text=Simulator.output();
        if ((text != null) && (text.length() > 0)) {
          buffer.append(text).append('\n');
        }
      }
 while (Simulator.hasOutput());
    }
  }
  memoryArea.setText(buffer.toString());
  memoryArea.setEnabled(true);
}","public void showMemory(){
  int from=0;
  int to=0;
  try {
    String toString=toText.getText().trim();
    from=Integer.parseInt(fromText.getText().trim());
    to=(toString.length() == 0) ? from : Integer.parseInt(toString);
    if ((from < 0) || (from > 15999) || (to < 0)|| (to > 15999)|| (from > to)) {
      throw new Exception(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    memoryArea.setText(""String_Node_Str"" + ex.getMessage());
    return;
  }
  setTitle(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  int offset=to - from;
  int last=offset - (offset % 50) + from;
  StringBuilder buffer=new StringBuilder(1024);
  if (Simulator.isActive()) {
synchronized (Simulator.class) {
      Simulator.output();
      Simulator.execute(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      Boolean nothingYet=true;
      while (true) {
        String text=Simulator.output();
        if (!nothingYet && text.length() == 0) {
          break;
        }
 else         if (nothingYet && text.length() > 0) {
          nothingYet=false;
        }
        if (TextIsValidForMemoryDump(text)) {
          int idx=text.indexOf(""String_Node_Str"");
          if (idx > 0 && idx <= 6) {
            StringBuilder strBuild=new StringBuilder(text);
            strBuild.setCharAt(idx,' ');
            text=strBuild.toString();
          }
          buffer.append(text).append('\n');
          if (idx >= 0 && idx <= 6) {
            try {
              String numberStr=text.substring(0,idx).replaceAll(""String_Node_Str"",""String_Node_Str"");
              int address=Integer.parseInt(numberStr);
              if (address == last) {
                break;
              }
            }
 catch (            Exception ex) {
              ex.printStackTrace();
            }
          }
        }
      }
      do {
        String text=Simulator.output();
        if ((text != null) && (text.length() > 0)) {
          buffer.append(text).append('\n');
        }
      }
 while (Simulator.hasOutput());
    }
  }
  memoryArea.setText(buffer.toString());
  memoryArea.setEnabled(true);
}",0.9453907815631264
37668,"public MemoryFrame(RopeFrame parent){
  super(parent);
  setLocation(930,690);
  setSize(510,395);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  this.addInternalFrameListener(new InternalFrameAdapter(){
    @Override public void internalFrameClosed(    InternalFrameEvent event){
      savePreferences();
      mainFrame.removeMemoryFrame();
    }
  }
);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentHidden(    ComponentEvent e){
      System.out.println(""String_Node_Str"");
    }
    @Override public void componentShown(    ComponentEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  showButton.addActionListener(this);
  barsCheckBox.addChangeListener(this);
  DefaultCaret caret=(DefaultCaret)memoryArea.getCaret();
  caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
  showMemory();
}","public MemoryFrame(RopeFrame parent){
  super(parent);
  setLocation(930,690);
  setSize(508,395);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  this.addInternalFrameListener(new InternalFrameAdapter(){
    @Override public void internalFrameClosed(    InternalFrameEvent event){
      savePreferences();
      mainFrame.removeMemoryFrame();
    }
  }
);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentHidden(    ComponentEvent e){
      System.out.println(""String_Node_Str"");
    }
    @Override public void componentShown(    ComponentEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  showButton.addActionListener(this);
  barsCheckBox.addChangeListener(this);
  DefaultCaret caret=(DefaultCaret)memoryArea.getCaret();
  caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
  showMemory();
}",0.9988738738738738
37669,"static boolean assemble(){
  try {
    Simulator.kill();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && !AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.deckEncodingChoice)) {
      String[] tapeArgs=buildCommand(false).toArray(new String[0]);
      process=Runtime.getRuntime().exec(tapeArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      try {
        process.waitFor();
      }
 catch (      Exception ex) {
      }
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        convertTape(AssemblerOptions.tapePath);
      }
      String[] deckArgs=buildCommand(true).toArray(new String[0]);
      process=Runtime.getRuntime().exec(deckArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    }
 else {
      String[] args=AssemblerOptions.command.toArray(new String[0]);
      args[0]=AssemblerOptions.assemblerPath;
      process=Runtime.getRuntime().exec(args);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        try {
          process.waitFor();
        }
 catch (        Exception ex) {
        }
        convertTape(AssemblerOptions.tapePath);
      }
    }
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}","static boolean assemble(){
  try {
    Simulator.kill();
    new File(AssemblerOptions.objectPath).delete();
    new File(AssemblerOptions.tapePath).delete();
    new File(AssemblerOptions.diagnosticPath).delete();
    new File(AssemblerOptions.listingPath).delete();
    new File(RopeUtils.removeExtension(AssemblerOptions.sourcePath) + ""String_Node_Str"").delete();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && !AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.deckEncodingChoice)) {
      String[] tapeArgs=buildCommand(false).toArray(new String[0]);
      process=Runtime.getRuntime().exec(tapeArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      try {
        process.waitFor();
      }
 catch (      Exception ex) {
      }
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        convertTape(AssemblerOptions.tapePath);
      }
      String[] deckArgs=buildCommand(true).toArray(new String[0]);
      process=Runtime.getRuntime().exec(deckArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    }
 else {
      String[] args=AssemblerOptions.command.toArray(new String[0]);
      args[0]=AssemblerOptions.assemblerPath;
      process=Runtime.getRuntime().exec(args);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        try {
          process.waitFor();
        }
 catch (        Exception ex) {
        }
        convertTape(AssemblerOptions.tapePath);
      }
    }
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}",0.9031855090568396
37670,"static boolean assemble(){
  try {
    Simulator.kill();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && AssemblerOptions.tapeEncodingChoice != AssemblerOptions.deckEncodingChoice) {
      String[] tapeArgs=buildCommand(false).toArray(new String[0]);
      process=Runtime.getRuntime().exec(tapeArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      String[] deckArgs=buildCommand(true).toArray(new String[0]);
      process=Runtime.getRuntime().exec(deckArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    }
 else {
      String[] args=AssemblerOptions.command.toArray(new String[0]);
      args[0]=AssemblerOptions.assemblerPath;
      process=Runtime.getRuntime().exec(args);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    }
    process=null;
    if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
      convertTape(AssemblerOptions.tapePath);
    }
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}","static boolean assemble(){
  try {
    Simulator.kill();
    if (AssemblerOptions.tape && AssemblerOptions.tapeEncoding && AssemblerOptions.tapeEncodingChoice != AssemblerOptions.deckEncodingChoice) {
      String[] tapeArgs=buildCommand(false).toArray(new String[0]);
      process=Runtime.getRuntime().exec(tapeArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      try {
        process.waitFor();
      }
 catch (      Exception ex) {
      }
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        convertTape(AssemblerOptions.tapePath);
      }
      String[] deckArgs=buildCommand(true).toArray(new String[0]);
      process=Runtime.getRuntime().exec(deckArgs);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    }
 else {
      String[] args=AssemblerOptions.command.toArray(new String[0]);
      args[0]=AssemblerOptions.assemblerPath;
      process=Runtime.getRuntime().exec(args);
      stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
      if (AssemblerOptions.tape && AssemblerOptions.convertTapeForTapeSimulator) {
        try {
          process.waitFor();
        }
 catch (        Exception ex) {
        }
        convertTape(AssemblerOptions.tapePath);
      }
    }
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}",0.8555772994129158
37671,"void initialize(){
  assemblerText.setText(AssemblerOptions.assemblerPath);
  listingText.setText(AssemblerOptions.listingPath);
  objectText.setText(AssemblerOptions.objectPath);
  macroText.setText(AssemblerOptions.macroPath);
  tapeText.setText(AssemblerOptions.tapePath);
  diagnosticText.setText(AssemblerOptions.diagnosticPath);
  pageText.setText(AssemblerOptions.pageLength);
  bootCheckBox.setSelected(AssemblerOptions.boot);
  deckEncodingCheckBox.setSelected(AssemblerOptions.deckEncoding);
  tapeEncodingCheckBox.setSelected(AssemblerOptions.tapeEncoding);
  listingCheckBox.setSelected(AssemblerOptions.listing);
  objectCheckBox.setSelected(AssemblerOptions.object);
  macroCheckBox.setSelected(AssemblerOptions.macro);
  tapeCheckBox.setSelected(AssemblerOptions.tape);
  diagnosticCheckBox.setSelected(AssemblerOptions.diagnostic);
  codeOkCheckBox.setSelected(AssemblerOptions.codeOk);
  interleaveCheckBox.setSelected(AssemblerOptions.interleave);
  storeCheckBox.setSelected(AssemblerOptions.store);
  dumpCheckBox.setSelected(AssemblerOptions.dump);
  convertTapeForTapeSimulatorBox.setSelected(AssemblerOptions.convertTapeForTapeSimulator);
  pageCheckBox.setSelected(AssemblerOptions.page);
  traceCheckBox.setSelected(AssemblerOptions.trace);
  traceLexerCheckBox.setSelected(AssemblerOptions.traceLexer);
  traceParserCheckBox.setSelected(AssemblerOptions.traceParser);
  traceProcessCheckBox.setSelected(AssemblerOptions.traceProcess);
  extrasCheckBox.setSelected(AssemblerOptions.extras);
  extrasExCheckBox.setSelected(AssemblerOptions.extrasEx);
  extrasEndCheckBox.setSelected(AssemblerOptions.extrasEnd);
  extrasQueueCheckBox.setSelected(AssemblerOptions.extrasQueue);
  extrasReloaderCheckBox.setSelected(AssemblerOptions.extrasReloader);
  bootNoneRadioButton.setSelected(false);
  bootIBMRadioButton.setSelected(false);
  bootVan1RadioButton.setSelected(false);
  bootVan2RadioButton.setSelected(false);
switch (AssemblerOptions.bootLoader) {
case AssemblerOptions.BOOT_NONE:
{
      bootNoneRadioButton.setSelected(true);
      break;
    }
case AssemblerOptions.BOOT_IBM:
{
    bootIBMRadioButton.setSelected(true);
    break;
  }
case AssemblerOptions.BOOT_VAN_1:
{
  bootVan1RadioButton.setSelected(true);
  break;
}
case AssemblerOptions.BOOT_VAN_2:
{
bootVan2RadioButton.setSelected(true);
break;
}
}
size1400RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_1400);
size2000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_2000);
size4000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_4000);
size8000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_8000);
size12000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_12000);
size16000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_16000);
deckEncodingSimhRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingARadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingHRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingPrintRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingSimhRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingARadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingHRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
enableBoot();
enableDeckEncoding();
enableTapeEncoding();
enablePage();
enableTrace();
enableExtras();
enableListing();
enableObject();
enableMacro();
enableTape();
enableDiagnostic();
}","void initialize(){
  assemblerText.setText(AssemblerOptions.assemblerPath);
  listingText.setText(AssemblerOptions.listingPath);
  objectText.setText(AssemblerOptions.objectPath);
  macroText.setText(AssemblerOptions.macroPath);
  tapeText.setText(AssemblerOptions.tapePath);
  diagnosticText.setText(AssemblerOptions.diagnosticPath);
  pageText.setText(AssemblerOptions.pageLength);
  bootCheckBox.setSelected(AssemblerOptions.boot);
  deckEncodingCheckBox.setSelected(AssemblerOptions.deckEncoding);
  tapeEncodingCheckBox.setSelected(AssemblerOptions.tapeEncoding);
  listingCheckBox.setSelected(AssemblerOptions.listing);
  objectCheckBox.setSelected(AssemblerOptions.object);
  macroCheckBox.setSelected(AssemblerOptions.macro);
  tapeCheckBox.setSelected(AssemblerOptions.tape);
  diagnosticCheckBox.setSelected(AssemblerOptions.diagnostic);
  codeOkCheckBox.setSelected(AssemblerOptions.codeOk);
  interleaveCheckBox.setSelected(AssemblerOptions.interleave);
  storeCheckBox.setSelected(AssemblerOptions.store);
  dumpCheckBox.setSelected(AssemblerOptions.dump);
  convertTapeForTapeSimulatorBox.setSelected(AssemblerOptions.convertTapeForTapeSimulator);
  pageCheckBox.setSelected(AssemblerOptions.page);
  traceCheckBox.setSelected(AssemblerOptions.trace);
  traceLexerCheckBox.setSelected(AssemblerOptions.traceLexer);
  traceParserCheckBox.setSelected(AssemblerOptions.traceParser);
  traceProcessCheckBox.setSelected(AssemblerOptions.traceProcess);
  extrasCheckBox.setSelected(AssemblerOptions.extras);
  extrasExCheckBox.setSelected(AssemblerOptions.extrasEx);
  extrasEndCheckBox.setSelected(AssemblerOptions.extrasEnd);
  extrasQueueCheckBox.setSelected(AssemblerOptions.extrasQueue);
  extrasReloaderCheckBox.setSelected(AssemblerOptions.extrasReloader);
  bootNoneRadioButton.setSelected(false);
  bootIBMRadioButton.setSelected(false);
  bootVan1RadioButton.setSelected(false);
  bootVan2RadioButton.setSelected(false);
switch (AssemblerOptions.bootLoader) {
case AssemblerOptions.BOOT_NONE:
{
      bootNoneRadioButton.setSelected(true);
      break;
    }
case AssemblerOptions.BOOT_IBM:
{
    bootIBMRadioButton.setSelected(true);
    break;
  }
case AssemblerOptions.BOOT_VAN_1:
{
  bootVan1RadioButton.setSelected(true);
  break;
}
case AssemblerOptions.BOOT_VAN_2:
{
bootVan2RadioButton.setSelected(true);
break;
}
}
size1400RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_1400);
size2000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_2000);
size4000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_4000);
size8000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_8000);
size12000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_12000);
size16000RadioButton.setSelected(AssemblerOptions.coreSize == AssemblerOptions.SIZE_16000);
deckEncodingSimhRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingARadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingHRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
deckEncodingPrintRadioButton.setSelected(AssemblerOptions.deckEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingSimhRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingARadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
tapeEncodingHRadioButton.setSelected(AssemblerOptions.tapeEncodingChoice.equals(AssemblerOptions.ENCODING_SIMH));
enableBoot();
enableDeckEncoding();
enableTapeEncoding();
enablePage();
enableTrace();
enableExtras();
enableListing();
enableObject();
enableMacro();
enableTape();
enableDiagnostic();
enableTapeConversion();
}",0.9969167523124358
37672,"@Override public void stateChanged(ChangeEvent event){
  Object source=event.getSource();
  if ((source == bootCheckBox) || (source == bootIBMRadioButton)) {
    enableBoot();
  }
 else   if ((source == listingCheckBox) || (source == objectCheckBox)) {
    enableListing();
    enableObject();
    enableInterleave();
  }
 else   if (source == pageCheckBox) {
    pageText.setEnabled(pageCheckBox.isSelected());
  }
 else   if (source == traceCheckBox) {
    enableTrace();
  }
 else   if (source == extrasCheckBox) {
    enableExtras();
  }
 else   if (source == macroCheckBox) {
    enableMacro();
  }
 else   if (source == tapeCheckBox) {
    enableTape();
  }
 else   if (source == diagnosticCheckBox) {
    enableDiagnostic();
  }
 else   if (source == deckEncodingCheckBox) {
    enableDeckEncoding();
  }
 else   if (source == tapeEncodingCheckBox) {
    enableTapeEncoding();
  }
  buildCommand();
}","@Override public void stateChanged(ChangeEvent event){
  Object source=event.getSource();
  if ((source == bootCheckBox) || (source == bootIBMRadioButton)) {
    enableBoot();
  }
 else   if ((source == listingCheckBox) || (source == objectCheckBox)) {
    enableListing();
    enableObject();
    enableInterleave();
  }
 else   if (source == pageCheckBox) {
    pageText.setEnabled(pageCheckBox.isSelected());
  }
 else   if (source == traceCheckBox) {
    enableTrace();
  }
 else   if (source == extrasCheckBox) {
    enableExtras();
  }
 else   if (source == macroCheckBox) {
    enableMacro();
  }
 else   if (source == tapeCheckBox) {
    enableTape();
  }
 else   if (source == diagnosticCheckBox) {
    enableDiagnostic();
  }
 else   if (source == deckEncodingCheckBox) {
    enableDeckEncoding();
  }
 else   if (source == tapeEncodingCheckBox) {
    enableTapeEncoding();
  }
 else   if (source == convertTapeForTapeSimulatorBox) {
    enableTapeConversion();
  }
  buildCommand();
}",0.953732912723449
37673,"private void okAction(){
  File file=new File(assemblerText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(listingText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",listingText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(objectText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",objectText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  for (  String path : macroText.getText().split(""String_Node_Str"")) {
    file=new File(path);
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",path);
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  file=new File(tapeText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",tapeText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(diagnosticText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",diagnosticText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  AssemblerOptions.assemblerPath=assemblerText.getText();
  AssemblerOptions.boot=bootCheckBox.isSelected();
  AssemblerOptions.bootLoader=bootIBMRadioButton.isSelected() ? AssemblerOptions.BOOT_IBM : bootVan1RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_1 : bootVan2RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_2 : AssemblerOptions.BOOT_NONE;
  AssemblerOptions.encoding=encodingCheckBox.isSelected();
  AssemblerOptions.encodingChoice=encodingSimhRadioButton.isSelected() ? AssemblerOptions.ENCODING_SIMH : encodingARadioButton.isSelected() ? AssemblerOptions.ENCODING_A : encodingHRadioButton.isSelected() ? AssemblerOptions.ENCODING_H : AssemblerOptions.ENCODING_PRINT;
  AssemblerOptions.listing=listingCheckBox.isSelected();
  AssemblerOptions.listingPath=listingText.getText();
  AssemblerOptions.object=objectCheckBox.isSelected();
  AssemblerOptions.objectPath=objectText.getText();
  AssemblerOptions.macro=macroCheckBox.isSelected();
  AssemblerOptions.macroPath=macroText.getText();
  AssemblerOptions.tape=tapeCheckBox.isSelected();
  AssemblerOptions.tapePath=tapeText.getText();
  AssemblerOptions.diagnostic=diagnosticCheckBox.isSelected();
  AssemblerOptions.diagnosticPath=diagnosticText.getText();
  AssemblerOptions.codeOk=codeOkCheckBox.isSelected();
  AssemblerOptions.interleave=interleaveCheckBox.isSelected();
  AssemblerOptions.store=storeCheckBox.isSelected();
  AssemblerOptions.dump=dumpCheckBox.isSelected();
  AssemblerOptions.page=pageCheckBox.isSelected();
  AssemblerOptions.pageLength=pageText.getText();
  AssemblerOptions.trace=traceCheckBox.isSelected();
  AssemblerOptions.traceLexer=traceLexerCheckBox.isSelected();
  AssemblerOptions.traceParser=traceParserCheckBox.isSelected();
  AssemblerOptions.traceProcess=traceProcessCheckBox.isSelected();
  AssemblerOptions.extras=extrasCheckBox.isSelected();
  AssemblerOptions.extrasEx=extrasExCheckBox.isSelected();
  AssemblerOptions.extrasEnd=extrasEndCheckBox.isSelected();
  AssemblerOptions.extrasQueue=extrasQueueCheckBox.isSelected();
  AssemblerOptions.extrasReloader=extrasReloaderCheckBox.isSelected();
  AssemblerOptions.command=buildCommand();
  this.setVisible(false);
}","private void okAction(){
  File file=new File(assemblerText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  if (listingCheckBox.isSelected()) {
    file=new File(listingText.getText());
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",listingText.getText());
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  if (objectCheckBox.isSelected()) {
    file=new File(objectText.getText());
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",objectText.getText());
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  if (macroCheckBox.isSelected()) {
    for (    String path : macroText.getText().split(""String_Node_Str"")) {
      file=new File(path);
      if (!file.exists() || !file.isDirectory()) {
        String message=String.format(""String_Node_Str"",path);
        if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
          return;
        }
      }
    }
  }
  if (tapeCheckBox.isSelected()) {
    file=new File(tapeText.getText());
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",tapeText.getText());
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  if (diagnosticCheckBox.isSelected()) {
    file=new File(diagnosticText.getText());
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",diagnosticText.getText());
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  AssemblerOptions.assemblerPath=assemblerText.getText();
  AssemblerOptions.boot=bootCheckBox.isSelected();
  AssemblerOptions.bootLoader=bootIBMRadioButton.isSelected() ? AssemblerOptions.BOOT_IBM : bootVan1RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_1 : bootVan2RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_2 : AssemblerOptions.BOOT_NONE;
  AssemblerOptions.encoding=encodingCheckBox.isSelected();
  AssemblerOptions.encodingChoice=encodingSimhRadioButton.isSelected() ? AssemblerOptions.ENCODING_SIMH : encodingARadioButton.isSelected() ? AssemblerOptions.ENCODING_A : encodingHRadioButton.isSelected() ? AssemblerOptions.ENCODING_H : AssemblerOptions.ENCODING_PRINT;
  AssemblerOptions.listing=listingCheckBox.isSelected();
  AssemblerOptions.listingPath=listingText.getText();
  AssemblerOptions.object=objectCheckBox.isSelected();
  AssemblerOptions.objectPath=objectText.getText();
  AssemblerOptions.macro=macroCheckBox.isSelected();
  AssemblerOptions.macroPath=macroText.getText();
  AssemblerOptions.tape=tapeCheckBox.isSelected();
  AssemblerOptions.tapePath=tapeText.getText();
  AssemblerOptions.diagnostic=diagnosticCheckBox.isSelected();
  AssemblerOptions.diagnosticPath=diagnosticText.getText();
  AssemblerOptions.codeOk=codeOkCheckBox.isSelected();
  AssemblerOptions.interleave=interleaveCheckBox.isSelected();
  AssemblerOptions.store=storeCheckBox.isSelected();
  AssemblerOptions.dump=dumpCheckBox.isSelected();
  AssemblerOptions.page=pageCheckBox.isSelected();
  AssemblerOptions.pageLength=pageText.getText();
  AssemblerOptions.trace=traceCheckBox.isSelected();
  AssemblerOptions.traceLexer=traceLexerCheckBox.isSelected();
  AssemblerOptions.traceParser=traceParserCheckBox.isSelected();
  AssemblerOptions.traceProcess=traceProcessCheckBox.isSelected();
  AssemblerOptions.extras=extrasCheckBox.isSelected();
  AssemblerOptions.extrasEx=extrasExCheckBox.isSelected();
  AssemblerOptions.extrasEnd=extrasEndCheckBox.isSelected();
  AssemblerOptions.extrasQueue=extrasQueueCheckBox.isSelected();
  AssemblerOptions.extrasReloader=extrasReloaderCheckBox.isSelected();
  AssemblerOptions.command=buildCommand();
  this.setVisible(false);
}",0.9641488162344984
37674,"Vector<String> buildCommand(){
  Vector<String> command=new Vector<String>();
  command.add(assemblerText.getText());
  if (bootCheckBox.isSelected() && !bootNoneRadioButton.isSelected()) {
    command.add(""String_Node_Str"");
    if (bootIBMRadioButton.isSelected()) {
      command.add(size1400RadioButton.isSelected() ? ""String_Node_Str"" : size2000RadioButton.isSelected() ? ""String_Node_Str"" : size4000RadioButton.isSelected() ? ""String_Node_Str"" : size8000RadioButton.isSelected() ? ""String_Node_Str"" : size12000RadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
 else {
      command.add(bootVan1RadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
  }
  if (encodingCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(encodingSimhRadioButton.isSelected() ? ""String_Node_Str"" : encodingARadioButton.isSelected() ? ""String_Node_Str"" : encodingHRadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (listingCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(listingText.getText());
  }
  if (objectCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(objectText.getText());
  }
  if (macroCheckBox.isSelected()) {
    for (    String macro : AssemblerOptions.macros.split(""String_Node_Str"")) {
      command.add(""String_Node_Str"");
      command.add(macro);
    }
    for (    String path : macroText.getText().split(""String_Node_Str"")) {
      command.add(""String_Node_Str"");
      command.add(path);
    }
  }
  if (tapeCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(tapeText.getText());
  }
  if (diagnosticCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(diagnosticText.getText());
  }
  if (codeOkCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (interleaveCheckBox.isEnabled() && interleaveCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (storeCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (dumpCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (pageCheckBox.isSelected()) {
    String pageLength=pageText.getText();
    if (pageLength.length() > 0) {
      command.add(""String_Node_Str"");
      command.add(pageLength);
    }
  }
  if (traceCheckBox.isSelected()) {
    StringBuffer letters=new StringBuffer(3);
    if (traceLexerCheckBox.isSelected()) {
      letters.append('l');
    }
    if (traceParserCheckBox.isSelected()) {
      letters.append('p');
    }
    if (traceProcessCheckBox.isSelected()) {
      letters.append('P');
    }
    if (letters.length() > 0) {
      command.add(""String_Node_Str"");
      command.add(letters.toString());
    }
  }
  if (extrasCheckBox.isSelected()) {
    int flag=0;
    if (extrasExCheckBox.isSelected()) {
      flag+=1;
    }
    if (extrasEndCheckBox.isSelected()) {
      flag+=2;
    }
    if (extrasQueueCheckBox.isSelected()) {
      flag+=4;
    }
    if (extrasReloaderCheckBox.isSelected()) {
      flag+=8;
    }
    if (flag > 0) {
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"" + flag);
    }
  }
  command.add(AssemblerOptions.sourcePath);
  String commandStr=""String_Node_Str"";
  for (int idx=0; idx < command.size(); idx++) {
    if (idx < command.size() - 1) {
      commandStr=commandStr.concat(command.get(idx) + ""String_Node_Str"");
    }
 else {
      commandStr=commandStr.concat(command.get(idx));
    }
  }
  commandArea.setText(commandStr);
  return command;
}","Vector<String> buildCommand(){
  Vector<String> command=new Vector<String>();
  command.add(assemblerText.getText());
  if (bootCheckBox.isSelected() && !bootNoneRadioButton.isSelected()) {
    command.add(""String_Node_Str"");
    if (bootIBMRadioButton.isSelected()) {
      command.add(size1400RadioButton.isSelected() ? ""String_Node_Str"" : size2000RadioButton.isSelected() ? ""String_Node_Str"" : size4000RadioButton.isSelected() ? ""String_Node_Str"" : size8000RadioButton.isSelected() ? ""String_Node_Str"" : size12000RadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
 else {
      command.add(bootVan1RadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
  }
  if (encodingCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(encodingSimhRadioButton.isSelected() ? ""String_Node_Str"" : encodingARadioButton.isSelected() ? ""String_Node_Str"" : encodingHRadioButton.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (listingCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(listingText.getText());
  }
  if (objectCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(objectText.getText());
  }
  if (macroCheckBox.isSelected()) {
    for (    String macro : AssemblerOptions.macros.split(""String_Node_Str"")) {
      command.add(""String_Node_Str"");
      command.add(macro);
    }
    for (    String path : macroText.getText().split(""String_Node_Str"")) {
      command.add(""String_Node_Str"");
      command.add(path);
    }
  }
  if (tapeCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(tapeText.getText());
  }
  if (diagnosticCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
    command.add(diagnosticText.getText());
  }
  if (codeOkCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (interleaveCheckBox.isEnabled() && interleaveCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (storeCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (dumpCheckBox.isSelected()) {
    command.add(""String_Node_Str"");
  }
  if (pageCheckBox.isSelected()) {
    String pageLength=pageText.getText();
    if (pageLength.length() > 0) {
      command.add(""String_Node_Str"");
      command.add(pageLength);
    }
  }
  if (traceCheckBox.isSelected()) {
    StringBuilder letters=new StringBuilder(3);
    if (traceLexerCheckBox.isSelected()) {
      letters.append('l');
    }
    if (traceParserCheckBox.isSelected()) {
      letters.append('p');
    }
    if (traceProcessCheckBox.isSelected()) {
      letters.append('P');
    }
    if (letters.length() > 0) {
      command.add(""String_Node_Str"");
      command.add(letters.toString());
    }
  }
  if (extrasCheckBox.isSelected()) {
    int flag=0;
    if (extrasExCheckBox.isSelected()) {
      flag+=1;
    }
    if (extrasEndCheckBox.isSelected()) {
      flag+=2;
    }
    if (extrasQueueCheckBox.isSelected()) {
      flag+=4;
    }
    if (extrasReloaderCheckBox.isSelected()) {
      flag+=8;
    }
    if (flag > 0) {
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"" + flag);
    }
  }
  command.add(AssemblerOptions.sourcePath);
  String commandStr=""String_Node_Str"";
  for (int idx=0; idx < command.size(); idx++) {
    if (idx < command.size() - 1) {
      commandStr=commandStr.concat(command.get(idx) + ""String_Node_Str"");
    }
 else {
      commandStr=commandStr.concat(command.get(idx));
    }
  }
  commandArea.setText(commandStr);
  return command;
}",0.9985935302391
37675,"EditFrame(RopeFrame parent){
  super(parent);
  setLocation(0,0);
  setSize(650,705);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  sourceArea.addCaretListener(this);
  browseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  assembleButton.addActionListener(this);
  saveButton.addActionListener(this);
  messageList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      highlightError(messageList.locationToIndex(event.getPoint()));
    }
  }
);
  undoMgr=new CompoundUndoManager(sourceArea);
  undoAction=undoMgr.getUndoAction();
  redoAction=undoMgr.getRedoAction();
  undoMgr.updateUndoAction=new UpdateUndoAction();
  undoMgr.updateRedoAction=new UpdateRedoAction();
  document=sourceArea.getDocument();
  InputMap im=sourceArea.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
  document.addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void removeUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void changedUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
  }
);
}","EditFrame(RopeFrame parent){
  super(parent);
  setLocation(0,0);
  setSize(670,705);
  try {
    jbInit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  sourceArea.addCaretListener(this);
  browseButton.addActionListener(this);
  optionsButton.addActionListener(this);
  assembleButton.addActionListener(this);
  saveButton.addActionListener(this);
  messageList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      highlightError(messageList.locationToIndex(event.getPoint()));
    }
  }
);
  undoMgr=new CompoundUndoManager(sourceArea);
  undoAction=undoMgr.getUndoAction();
  redoAction=undoMgr.getRedoAction();
  undoMgr.updateUndoAction=new UpdateUndoAction();
  undoMgr.updateRedoAction=new UpdateRedoAction();
  document=sourceArea.getDocument();
  InputMap im=sourceArea.getInputMap(JComponent.WHEN_FOCUSED);
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + InputEvent.SHIFT_MASK),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks),""String_Node_Str"");
  im.put(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks),""String_Node_Str"");
  document.addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void removeUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
    @Override public void changedUpdate(    DocumentEvent e){
      setSourceChanged(true);
    }
  }
);
}",0.9994742376445848
37676,"ChildFrame(RopeFrame ropeFrame){
  mainFrame=ropeFrame;
  addInternalFrameListener(this);
}","ChildFrame(RopeFrame ropeFrame){
  mainFrame=ropeFrame;
  addInternalFrameListener(this);
  addComponentListener(this);
}",0.8584905660377359
37677,"public void setupMenus(){
  mainFrame.undoItem.setEnabled(canUndo());
  mainFrame.redoItem.setEnabled(canRedo());
  mainFrame.cutItem.setEnabled(canCut());
  mainFrame.copyItem.setEnabled(canCopy());
  mainFrame.pasteItem.setEnabled(canPaste());
  mainFrame.deleteItem.setEnabled(canDelete());
  mainFrame.selectAllItem.setEnabled(canSelectAll());
  mainFrame.selectLineItem.setEnabled(canSelectLine());
}","public void setupMenus(){
  mainFrame.newItem.setEnabled(canNew());
  mainFrame.openItem.setEnabled(canOpen());
  mainFrame.saveItem.setEnabled(canSave());
  mainFrame.saveAsItem.setEnabled(canSaveAs());
  mainFrame.revertItem.setEnabled(canRevert());
  mainFrame.closeItem.setEnabled(canClose());
  mainFrame.printItem.setEnabled(canPrint());
  mainFrame.undoItem.setEnabled(canUndo());
  mainFrame.redoItem.setEnabled(canRedo());
  mainFrame.cutItem.setEnabled(canCut());
  mainFrame.copyItem.setEnabled(canCopy());
  mainFrame.pasteItem.setEnabled(canPaste());
  mainFrame.deleteItem.setEnabled(canDelete());
  mainFrame.selectAllItem.setEnabled(canSelectAll());
  mainFrame.selectLineItem.setEnabled(canSelectLine());
  if (RopeHelper.isMac) {
  }
 else {
    mainFrame.prefsItem.setEnabled(canPrefs());
    mainFrame.quitItem.setEnabled(canQuit());
    mainFrame.aboutItem.setEnabled(canAbout());
  }
}",0.6173780487804879
37678,"public Rope(){
  if (RopeHelper.isMac) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (mainFrame != null && !mainFrame.closed()) {
        mainFrame.savePreferences();
      }
      Assembler.kill();
      Simulator.kill();
    }
  }
);
  mainFrame=new RopeFrame();
}","public Rope(){
  if (RopeHelper.isMac) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    setQuitStrategy(QuitStrategy.SYSTEM_EXIT_0);
  }
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception ex) {
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (mainFrame != null && !mainFrame.closed()) {
        mainFrame.savePreferences();
      }
      Assembler.kill();
      Simulator.kill();
    }
  }
);
  mainFrame=new RopeFrame();
}",0.7276190476190476
37679,"@Override public void windowOpened(WindowEvent e){
  loadPreferences();
  if (reopenLastSource) {
    File file=new File(userPrefs.get(""String_Node_Str"",null));
    if (editFrame.loadSourceFile(file)) {
      String sourceName=file.getName();
      int idx=sourceName.lastIndexOf(""String_Node_Str"");
      String baseName=idx == -1 ? sourceName.substring(0) : sourceName.substring(0,idx);
      showExecWindow(baseName);
    }
  }
}","@Override public void windowOpened(WindowEvent e){
  loadPreferences();
  if (reopenLastSource) {
    File file=new File(userPrefs.get(""String_Node_Str"",null));
    if (editFrame.loadSourceFile(file)) {
      String sourceName=file.getName();
      int idx=sourceName.lastIndexOf(""String_Node_Str"");
      String baseName=idx == -1 ? sourceName.substring(0) : sourceName.substring(0,idx);
      showExecWindow(baseName);
    }
  }
  currentChildFrame=editFrame;
  desktop.getDesktopManager().activateFrame(editFrame);
}",0.9085173501577288
37680,"public RopeFrame(){
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  addWindowListener(this);
  addFocusListener(this);
  if (packFrame) {
    this.pack();
  }
 else {
    this.validate();
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  Dimension frameSize=new Dimension(screenSize.width - 10,screenSize.height - (RopeHelper.isMac ? 80 : 50));
  this.setSize(frameSize);
  this.setLocation((screenSize.width - frameSize.width) / 2,10);
  this.setTitle(MessageFormat.format(RopeResources.getString(""String_Node_Str""),RopeResources.getString(""String_Node_Str"")));
  JPanel contentPanel=(JPanel)this.getContentPane();
  contentPanel.add(desktop);
  desktop.setBackground(new Color(215,215,255));
  setupMenus();
  Dimension ropeFrameSize=getSize();
  editFrame=new EditFrame(this);
  Point editLocation=new Point(0,0);
  Dimension editSize=new Dimension(editFrame.getSize());
  Integer editSplitter=editFrame.splitPane.getDividerLocation();
  editLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",editLocation.toString()));
  editSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",editSize.toString()));
  editSplitter=userPrefs.getInt(""String_Node_Str"",editSplitter);
  verifyFrameLocation(editLocation);
  verifyFrameSize(editSize,editSplitter);
  editFrame.setLocation(editLocation);
  editFrame.setSize(editSize);
  editFrame.setMinimumSize(new Dimension(480,240));
  editFrame.splitPane.setDividerLocation(editSplitter);
  editFrame.setVisible(true);
  desktop.add(editFrame);
  execFrame=new ExecFrame(this);
  Point execLocation=new Point(ropeFrameSize.width / 2,0);
  Dimension execSize=new Dimension(execFrame.getSize());
  Integer execSplitter=execFrame.splitPane.getDividerLocation();
  execLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",execLocation.toString()));
  execSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",execSize.toString()));
  execSplitter=userPrefs.getInt(""String_Node_Str"",execSplitter);
  verifyFrameLocation(execLocation);
  verifyFrameSize(execSize,execSplitter);
  execFrame.setLocation(execLocation);
  execFrame.setSize(execSize);
  execFrame.setMinimumSize(new Dimension(480,240));
  execFrame.splitPane.setDividerLocation(execSplitter);
  execFrame.setVisible(false);
  desktop.add(execFrame);
  printoutFrame=new PrintoutFrame(this);
  Point printoutLocation=new Point(printoutFrame.getLocation());
  Dimension printoutSize=new Dimension(printoutFrame.getSize());
  printoutLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",printoutLocation.toString()));
  printoutSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",printoutSize.toString()));
  verifyFrameLocation(printoutLocation);
  verifyFrameSize(printoutSize,null);
  printoutFrame.setLocation(printoutLocation);
  printoutFrame.setSize(printoutSize);
  printoutFrame.setVisible(false);
  desktop.add(printoutFrame);
  currentChildFrame=editFrame;
  setVisible(true);
  clipboardListener=new ClipboardListener(this);
}","public RopeFrame(){
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  addWindowListener(this);
  addFocusListener(this);
  if (packFrame) {
    this.pack();
  }
 else {
    this.validate();
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  Dimension frameSize=new Dimension(screenSize.width - 10,screenSize.height - (RopeHelper.isMac ? 80 : 50));
  this.setSize(frameSize);
  this.setLocation((screenSize.width - frameSize.width) / 2,10);
  this.setTitle(MessageFormat.format(RopeResources.getString(""String_Node_Str""),RopeResources.getString(""String_Node_Str"")));
  JPanel contentPanel=(JPanel)this.getContentPane();
  contentPanel.add(desktop);
  desktop.setBackground(new Color(215,215,255));
  setupMenus();
  Dimension ropeFrameSize=getSize();
  editFrame=new EditFrame(this);
  Point editLocation=new Point(0,0);
  Dimension editSize=new Dimension(editFrame.getSize());
  Integer editSplitter=editFrame.splitPane.getDividerLocation();
  editLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",editLocation.toString()));
  editSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",editSize.toString()));
  editSplitter=userPrefs.getInt(""String_Node_Str"",editSplitter);
  verifyFrameLocation(editLocation);
  verifyFrameSize(editSize,editSplitter);
  editFrame.setLocation(editLocation);
  editFrame.setSize(editSize);
  editFrame.setMinimumSize(new Dimension(480,240));
  editFrame.splitPane.setDividerLocation(editSplitter);
  editFrame.setVisible(true);
  desktop.add(editFrame);
  execFrame=new ExecFrame(this);
  Point execLocation=new Point(ropeFrameSize.width / 2,0);
  Dimension execSize=new Dimension(execFrame.getSize());
  Integer execSplitter=execFrame.splitPane.getDividerLocation();
  execLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",execLocation.toString()));
  execSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",execSize.toString()));
  execSplitter=userPrefs.getInt(""String_Node_Str"",execSplitter);
  verifyFrameLocation(execLocation);
  verifyFrameSize(execSize,execSplitter);
  execFrame.setLocation(execLocation);
  execFrame.setSize(execSize);
  execFrame.setMinimumSize(new Dimension(480,240));
  execFrame.splitPane.setDividerLocation(execSplitter);
  execFrame.setVisible(false);
  desktop.add(execFrame);
  printoutFrame=new PrintoutFrame(this);
  Point printoutLocation=new Point(printoutFrame.getLocation());
  Dimension printoutSize=new Dimension(printoutFrame.getSize());
  printoutLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",printoutLocation.toString()));
  printoutSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",printoutSize.toString()));
  verifyFrameLocation(printoutLocation);
  verifyFrameSize(printoutSize,null);
  printoutFrame.setLocation(printoutLocation);
  printoutFrame.setSize(printoutSize);
  printoutFrame.setVisible(false);
  desktop.add(printoutFrame);
  setVisible(true);
  clipboardListener=new ClipboardListener(this);
}",0.9749626927541036
37681,"void verifyFrameLocation(Point frameLocation){
  Dimension ropeFrameSize=getSize();
  if (frameLocation.getX() < 0 || frameLocation.getY() < 0) {
    frameLocation.setLocation(0,0);
  }
 else   if (frameLocation.getX() > ropeFrameSize.getWidth() - 20 || frameLocation.getY() > ropeFrameSize.getHeight() - 20) {
    frameLocation.setLocation(ropeFrameSize.getWidth() - 20,ropeFrameSize.getHeight() - 20);
  }
}","void verifyFrameLocation(Point frameLocation){
  Dimension ropeFrameSize=getSize();
  if (frameLocation.y < -4) {
    frameLocation.y=-4;
  }
  if (frameLocation.x > ropeFrameSize.width - 20) {
    frameLocation.x=ropeFrameSize.width - 20;
  }
  if (frameLocation.y > ropeFrameSize.height - 20) {
    frameLocation.y=ropeFrameSize.height - 20;
  }
}",0.4907651715039577
37682,"private void setupMenus(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  newItem=new JMenuItem(""String_Node_Str"");
  newItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(newItem);
  openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(openItem);
  fileMenu.addSeparator();
  revertItem=new JMenuItem(""String_Node_Str"");
  revertItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(revertItem);
  fileMenu.addSeparator();
  saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(saveItem);
  saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(saveAsItem);
  fileMenu.addSeparator();
  closeItem=new JMenuItem(""String_Node_Str"");
  closeItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(closeItem);
  fileMenu.addSeparator();
  printItem=new JMenuItem(""String_Node_Str"");
  printItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      System.out.println(""String_Node_Str"");
    }
  }
);
  fileMenu.add(printItem);
  if (RopeHelper.isMac) {
    registerForMacOSXEvents();
  }
 else {
    fileMenu.addSeparator();
    prefsItem=new JMenuItem(""String_Node_Str"");
    prefsItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        doPreferences();
      }
    }
);
    fileMenu.add(prefsItem);
    fileMenu.addSeparator();
    quitItem=new JMenuItem(""String_Node_Str"");
    quitItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        WindowEvent event=new WindowEvent(RopeFrame.this,WindowEvent.WINDOW_CLOSING);
        Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(event);
      }
    }
);
    fileMenu.add(quitItem);
    helpMenu=new JMenu(""String_Node_Str"");
    aboutItem=new JMenuItem(""String_Node_Str"");
    aboutItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        aboutRope();
      }
    }
);
    helpMenu.add(aboutItem);
  }
  editMenu=new JMenu(""String_Node_Str"");
  undoItem=new JMenuItem(""String_Node_Str"");
  undoItem.setEnabled(false);
  undoItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks));
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(undoItem);
  redoItem=new JMenuItem(""String_Node_Str"");
  redoItem.setEnabled(false);
  redoItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + Event.SHIFT_MASK));
  redoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(redoItem);
  editMenu.addSeparator();
  cutItem=new JMenuItem(""String_Node_Str"");
  cutItem.setEnabled(false);
  cutItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks));
  cutItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(cutItem);
  copyItem=new JMenuItem(""String_Node_Str"");
  copyItem.setEnabled(false);
  copyItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks));
  copyItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(copyItem);
  pasteItem=new JMenuItem(""String_Node_Str"");
  pasteItem.setEnabled(false);
  pasteItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks));
  pasteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(pasteItem);
  editMenu.addSeparator();
  deleteItem=new JMenuItem(""String_Node_Str"");
  deleteItem.setEnabled(false);
  deleteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(deleteItem);
  editMenu.addSeparator();
  selectAllItem=new JMenuItem(""String_Node_Str"");
  selectAllItem.setEnabled(false);
  selectAllItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks));
  selectAllItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(selectAllItem);
  selectLineItem=new JMenuItem(""String_Node_Str"");
  selectLineItem.setEnabled(false);
  selectLineItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks));
  selectLineItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(selectLineItem);
  menuBar.add(fileMenu);
  menuBar.add(editMenu);
  if (helpMenu != null) {
    menuBar.add(helpMenu);
  }
  this.setJMenuBar(menuBar);
}","private void setupMenus(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  newItem=new JMenuItem(""String_Node_Str"");
  newItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(newItem);
  openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(openItem);
  fileMenu.addSeparator();
  revertItem=new JMenuItem(""String_Node_Str"");
  revertItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(revertItem);
  fileMenu.addSeparator();
  saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(saveItem);
  saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(saveAsItem);
  fileMenu.addSeparator();
  closeItem=new JMenuItem(""String_Node_Str"");
  closeItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(closeItem);
  fileMenu.addSeparator();
  printItem=new JMenuItem(""String_Node_Str"");
  printItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  fileMenu.add(printItem);
  if (RopeHelper.isMac) {
    registerForMacOSXEvents();
  }
 else {
    fileMenu.addSeparator();
    prefsItem=new JMenuItem(""String_Node_Str"");
    prefsItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        doPreferences();
      }
    }
);
    fileMenu.add(prefsItem);
    fileMenu.addSeparator();
    quitItem=new JMenuItem(""String_Node_Str"");
    quitItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        WindowEvent event=new WindowEvent(RopeFrame.this,WindowEvent.WINDOW_CLOSING);
        Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(event);
      }
    }
);
    fileMenu.add(quitItem);
    helpMenu=new JMenu(""String_Node_Str"");
    aboutItem=new JMenuItem(""String_Node_Str"");
    aboutItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        aboutRope();
      }
    }
);
    helpMenu.add(aboutItem);
  }
  editMenu=new JMenu(""String_Node_Str"");
  undoItem=new JMenuItem(""String_Node_Str"");
  undoItem.setEnabled(false);
  undoItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks));
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(undoItem);
  redoItem=new JMenuItem(""String_Node_Str"");
  redoItem.setEnabled(false);
  redoItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z,RopeHelper.modifierMaks + Event.SHIFT_MASK));
  redoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(redoItem);
  editMenu.addSeparator();
  cutItem=new JMenuItem(""String_Node_Str"");
  cutItem.setEnabled(false);
  cutItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,RopeHelper.modifierMaks));
  cutItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(cutItem);
  copyItem=new JMenuItem(""String_Node_Str"");
  copyItem.setEnabled(false);
  copyItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C,RopeHelper.modifierMaks));
  copyItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(copyItem);
  pasteItem=new JMenuItem(""String_Node_Str"");
  pasteItem.setEnabled(false);
  pasteItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V,RopeHelper.modifierMaks));
  pasteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(pasteItem);
  editMenu.addSeparator();
  deleteItem=new JMenuItem(""String_Node_Str"");
  deleteItem.setEnabled(false);
  deleteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(deleteItem);
  editMenu.addSeparator();
  selectAllItem=new JMenuItem(""String_Node_Str"");
  selectAllItem.setEnabled(false);
  selectAllItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A,RopeHelper.modifierMaks));
  selectAllItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(selectAllItem);
  selectLineItem=new JMenuItem(""String_Node_Str"");
  selectLineItem.setEnabled(false);
  selectLineItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_L,RopeHelper.modifierMaks));
  selectLineItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      callChildFrameMethod(""String_Node_Str"",e);
    }
  }
);
  editMenu.add(selectLineItem);
  menuBar.add(fileMenu);
  menuBar.add(editMenu);
  if (helpMenu != null) {
    menuBar.add(helpMenu);
  }
  this.setJMenuBar(menuBar);
}",0.9771428571428572
37683,"private void browseAction(){
  if (selectedPath == null) {
    selectedPath=System.getenv(""String_Node_Str"");
    if (selectedPath != null) {
      File dir=new File(selectedPath);
      if (!dir.exists() || !dir.isDirectory()) {
        String message=String.format(""String_Node_Str"",selectedPath);
        JOptionPane.showMessageDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
        selectedPath=null;
      }
 else {
        System.out.println(""String_Node_Str"" + selectedPath);
      }
    }
    if (selectedPath == null) {
      selectedPath=System.getProperty(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + selectedPath);
    }
  }
  Vector<RopeFileFilter> filters=new Vector<RopeFileFilter>();
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str""));
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str""));
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
  RopeFileChooser chooser=new RopeFileChooser(selectedPath,null,filters);
  chooser.setDialogTitle(""String_Node_Str"");
  chooser.setFileFilter(filters.firstElement());
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  File file=chooser.choose(fileText,this);
  if (file != null) {
    loadSourceFile(file);
  }
}","private void browseAction(){
  if (selectedPath == null) {
    selectedPath=System.getenv(""String_Node_Str"");
    if (selectedPath != null) {
      File dir=new File(selectedPath);
      if (!dir.exists() || !dir.isDirectory()) {
        String message=String.format(""String_Node_Str"",selectedPath);
        JOptionPane.showMessageDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
        selectedPath=null;
      }
 else {
        System.out.println(""String_Node_Str"" + selectedPath);
      }
    }
    if (selectedPath == null) {
      selectedPath=System.getProperty(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + selectedPath);
    }
  }
  Vector<RopeFileFilter> filters=new Vector<RopeFileFilter>();
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str""));
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str""));
  filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
  RopeFileChooser chooser=new RopeFileChooser(selectedPath,null,filters);
  chooser.setDialogTitle(""String_Node_Str"");
  chooser.setFileFilter(filters.firstElement());
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  File file=chooser.choose(fileText,this);
  if (file != null) {
    if (loadSourceFile(file)) {
      mainFrame.showExecWindow(baseName);
    }
  }
}",0.9797202797202798
37684,"private void clearBreakpoints(){
  ListModel model=listing.getModel();
  int size=model.getSize();
  for (int idx=0; idx < size; ++idx) {
    ListingLine line=(ListingLine)model.getElementAt(idx);
    line.breakpoint=false;
  }
  listing.repaint();
  listing.removeAll();
}","public void clearBreakpoints(){
  ListModel model=listing.getModel();
  int size=model.getSize();
  for (int idx=0; idx < size; ++idx) {
    ListingLine line=(ListingLine)model.getElementAt(idx);
    line.breakpoint=false;
  }
  listing.repaint();
  listing.removeAll();
}",0.979816513761468
37685,"private void loadListing(){
  Vector v=filterListing();
  if (v != null) {
    listing.clearSelection();
    listing.setListData(v);
    if (currentMessage == null) {
      listing.ensureIndexIsVisible(0);
    }
 else {
      selectCurrentLine(currentMessage);
    }
    checkListContent();
  }
}","private void loadListing(){
  clearListing();
  Vector v=filterListing();
  if (v != null) {
    listing.setListData(v);
    if (currentMessage == null) {
      listing.ensureIndexIsVisible(0);
    }
 else {
      selectCurrentLine(currentMessage);
    }
    checkListContent();
  }
}",0.9172413793103448
37686,"void showExecWindow(String baseName){
  desktop.getDesktopManager().deiconifyFrame(execFrame);
  execFrame.setTitle(""String_Node_Str"" + baseName);
  execFrame.setVisible(true);
  execFrame.initialize(AssemblerOptions.listingPath,DataOptions.outputPath);
  execFrame.toFront();
}","void showExecWindow(String baseName){
  File file=new File(AssemblerOptions.listingPath);
  if (file.exists()) {
    execFrame.setTitle(""String_Node_Str"" + baseName);
    execFrame.initialize(AssemblerOptions.listingPath,DataOptions.outputPath);
    if (!execFrame.isVisible()) {
      execFrame.setVisible(true);
      execFrame.toFront();
    }
  }
 else {
    if (execFrame.isVisible()) {
      execFrame.clearMessage();
      execFrame.clearListing();
      execFrame.clearBreakpoints();
      execFrame.setTitle(""String_Node_Str"");
      execFrame.setVisible(false);
    }
    if (printoutFrame.isVisible()) {
      printoutFrame.setTitle(""String_Node_Str"");
      printoutFrame.setVisible(false);
    }
  }
}",0.3588709677419355
37687,"void savePreferences(){
  if (!savePreferencesOnExit) {
    return;
  }
  try {
    if (editFrame != null && editFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",editFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",editFrame.getSize().toString());
      userPrefs.putInt(""String_Node_Str"",editFrame.splitPane.getDividerLocation());
      userPrefs.put(""String_Node_Str"",editFrame.sourcePath);
    }
    if (execFrame != null && execFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",execFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",execFrame.getSize().toString());
      userPrefs.putInt(""String_Node_Str"",execFrame.splitPane.getDividerLocation());
    }
    if (printoutFrame != null && printoutFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",printoutFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",printoutFrame.getSize().toString());
    }
    if (memoryFrame != null && memoryFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",memoryFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",memoryFrame.getSize().toString());
    }
    if (consoleFrame != null && consoleFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",consoleFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",consoleFrame.getSize().toString());
    }
    if (timerFrame != null && timerFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",timerFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",timerFrame.getSize().toString());
    }
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
}","void savePreferences(){
  if (!savePreferencesOnExit) {
    return;
  }
  try {
    if (editFrame != null && editFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",editFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",editFrame.getSize().toString());
      userPrefs.putInt(""String_Node_Str"",editFrame.splitPane.getDividerLocation());
      userPrefs.put(""String_Node_Str"",editFrame.sourcePath != null ? editFrame.sourcePath : ""String_Node_Str"");
    }
    if (execFrame != null && execFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",execFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",execFrame.getSize().toString());
      userPrefs.putInt(""String_Node_Str"",execFrame.splitPane.getDividerLocation());
    }
    if (printoutFrame != null && printoutFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",printoutFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",printoutFrame.getSize().toString());
    }
    if (memoryFrame != null && memoryFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",memoryFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",memoryFrame.getSize().toString());
    }
    if (consoleFrame != null && consoleFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",consoleFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",consoleFrame.getSize().toString());
    }
    if (timerFrame != null && timerFrame.isVisible()) {
      userPrefs.put(""String_Node_Str"",timerFrame.getLocation().toString());
      userPrefs.put(""String_Node_Str"",timerFrame.getSize().toString());
    }
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.9856540084388186
37688,"private void jbInit() throws Exception {
  messageText.setBackground(UIManager.getColor(""String_Node_Str""));
  messageText.setFont(new java.awt.Font(""String_Node_Str"",Font.BOLD,11));
  messageText.setMinimumSize(new Dimension(637,30));
  messageText.setPreferredSize(new Dimension(637,30));
  messageText.setEditable(false);
  messageText.setForeground(Color.blue);
  messageText.setText(DEFAULT_MESSAGE);
  messageText.setLineWrap(true);
  messageText.setWrapStyleWord(true);
  readerTextField.setBorder(border2);
  readerTextField.setEditable(false);
  readerCheckBox.setText(""String_Node_Str"");
  readerBrowseButton.setText(""String_Node_Str"");
  punchCheckBox.setText(""String_Node_Str"");
  punchBrowseButton.setText(""String_Node_Str"");
  tape1CheckBox.setText(""String_Node_Str"");
  tape1BrowseButton.setText(""String_Node_Str"");
  tape2CheckBox.setText(""String_Node_Str"");
  tape2BrowseButton.setText(""String_Node_Str"");
  tape3CheckBox.setText(""String_Node_Str"");
  tape3BrowseButton.setText(""String_Node_Str"");
  tape4CheckBox.setText(""String_Node_Str"");
  tape4BrowseButton.setText(""String_Node_Str"");
  tape5CheckBox.setText(""String_Node_Str"");
  tape5BrowseButton.setText(""String_Node_Str"");
  tape6CheckBox.setText(""String_Node_Str"");
  tape6BrowseButton.setText(""String_Node_Str"");
  okButton.setText(""String_Node_Str"");
  cancelButton.setText(""String_Node_Str"");
  getContentPane().add(optionsPanel);
  optionsPanel.setLayout(gridBagLayout1);
  optionsPanel.setPreferredSize(new Dimension(500,425));
  optionsPanel.add(messagePanel,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(15,15,0,15),0,0));
  optionsPanel.add(cardPanel,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,15,0,15),0,0));
  optionsPanel.add(tapePanel,new GridBagConstraints(0,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,15,0,15),0,0));
  optionsPanel.add(buttonPanel,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,0,15,0),0,0));
  messagePanel.setLayout(borderLayout1);
  messagePanel.add(messageText,java.awt.BorderLayout.CENTER);
  cardPanel.setBorder(border1);
  cardPanel.setLayout(gridBagLayout2);
  cardPanel.add(readerCheckBox,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  cardPanel.add(readerTextField,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  cardPanel.add(readerBrowseButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  cardPanel.add(punchCheckBox,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  cardPanel.add(punchTextField,new GridBagConstraints(1,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  cardPanel.add(punchBrowseButton,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.setBorder(border4);
  tapePanel.setLayout(gridBagLayout4);
  tapePanel.add(tape1CheckBox,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape1TextField,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape1BrowseButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape2CheckBox,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape2TextField,new GridBagConstraints(1,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape2BrowseButton,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape3CheckBox,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape3TextField,new GridBagConstraints(1,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape3BrowseButton,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape4CheckBox,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape4TextField,new GridBagConstraints(1,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape4BrowseButton,new GridBagConstraints(2,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape5CheckBox,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape5TextField,new GridBagConstraints(1,4,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape5BrowseButton,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  buttonPanel.setLayout(gridBagLayout3);
  buttonPanel.add(okButton,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  buttonPanel.add(cancelButton,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  tapePanel.add(tape6CheckBox,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,5,0),0,0));
  tapePanel.add(tape6TextField,new GridBagConstraints(1,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,0),0,0));
  tapePanel.add(tape6BrowseButton,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,5),0,0));
}","private void jbInit() throws Exception {
  messageText.setBackground(UIManager.getColor(""String_Node_Str""));
  messageText.setFont(new java.awt.Font(""String_Node_Str"",Font.BOLD,14));
  messageText.setMinimumSize(new Dimension(640,40));
  messageText.setPreferredSize(new Dimension(640,40));
  messageText.setEditable(false);
  messageText.setForeground(Color.blue);
  messageText.setText(DEFAULT_MESSAGE);
  messageText.setLineWrap(true);
  messageText.setWrapStyleWord(true);
  readerTextField.setBorder(border2);
  readerTextField.setEditable(false);
  readerCheckBox.setText(""String_Node_Str"");
  readerBrowseButton.setText(""String_Node_Str"");
  punchCheckBox.setText(""String_Node_Str"");
  punchBrowseButton.setText(""String_Node_Str"");
  tape1CheckBox.setText(""String_Node_Str"");
  tape1BrowseButton.setText(""String_Node_Str"");
  tape2CheckBox.setText(""String_Node_Str"");
  tape2BrowseButton.setText(""String_Node_Str"");
  tape3CheckBox.setText(""String_Node_Str"");
  tape3BrowseButton.setText(""String_Node_Str"");
  tape4CheckBox.setText(""String_Node_Str"");
  tape4BrowseButton.setText(""String_Node_Str"");
  tape5CheckBox.setText(""String_Node_Str"");
  tape5BrowseButton.setText(""String_Node_Str"");
  tape6CheckBox.setText(""String_Node_Str"");
  tape6BrowseButton.setText(""String_Node_Str"");
  okButton.setText(""String_Node_Str"");
  cancelButton.setText(""String_Node_Str"");
  getContentPane().add(optionsPanel);
  optionsPanel.setLayout(gridBagLayout1);
  optionsPanel.setPreferredSize(new Dimension(650,450));
  optionsPanel.add(messagePanel,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(15,15,0,15),0,0));
  optionsPanel.add(cardPanel,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,15,0,15),0,0));
  optionsPanel.add(tapePanel,new GridBagConstraints(0,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,15,0,15),0,0));
  optionsPanel.add(buttonPanel,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(15,0,15,0),0,0));
  messagePanel.setLayout(borderLayout1);
  messagePanel.add(messageText,java.awt.BorderLayout.CENTER);
  cardPanel.setBorder(border1);
  cardPanel.setLayout(gridBagLayout2);
  cardPanel.add(readerCheckBox,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  cardPanel.add(readerTextField,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  cardPanel.add(readerBrowseButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  cardPanel.add(punchCheckBox,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  cardPanel.add(punchTextField,new GridBagConstraints(1,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  cardPanel.add(punchBrowseButton,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.setBorder(border4);
  tapePanel.setLayout(gridBagLayout4);
  tapePanel.add(tape1CheckBox,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape1TextField,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape1BrowseButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape2CheckBox,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape2TextField,new GridBagConstraints(1,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape2BrowseButton,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape3CheckBox,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape3TextField,new GridBagConstraints(1,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape3BrowseButton,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape4CheckBox,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape4TextField,new GridBagConstraints(1,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape4BrowseButton,new GridBagConstraints(2,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  tapePanel.add(tape5CheckBox,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape5TextField,new GridBagConstraints(1,4,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,0),0,0));
  tapePanel.add(tape5BrowseButton,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,0,5),0,0));
  buttonPanel.setLayout(gridBagLayout3);
  buttonPanel.add(okButton,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,10,50),0,0));
  buttonPanel.add(cancelButton,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,10,0),0,0));
  tapePanel.add(tape6CheckBox,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,5,0),0,0));
  tapePanel.add(tape6TextField,new GridBagConstraints(1,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,0),0,0));
  tapePanel.add(tape6BrowseButton,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,5),0,0));
}",0.9973101265822784
37689,"private boolean handleUnit(String unitName,JCheckBox checkBox,JTextField filePath){
  if (checkBox.isSelected()) {
    String path=filePath.getText().trim();
    if (path.length() > 0) {
      DataOptions.unitCommands.add(""String_Node_Str"" + unitName + ""String_Node_Str""+ path);
      return true;
    }
 else {
      messageText.setForeground(ExecFrame.DARK_RED);
      messageText.setText(""String_Node_Str"" + unitName + ""String_Node_Str"");
      return false;
    }
  }
 else {
    DataOptions.unitCommands.add(""String_Node_Str"" + unitName);
    return true;
  }
}","@SuppressWarnings(""String_Node_Str"") private boolean handleUnit(String unitName,JCheckBox checkBox,JTextField filePath){
  if (checkBox.isSelected()) {
    String path=filePath.getText().trim();
    if (path.length() > 0) {
      DataOptions.unitCommands.add(""String_Node_Str"" + unitName + ""String_Node_Str""+ path);
      return true;
    }
 else {
      messageText.setForeground(ExecFrame.DARK_RED);
      messageText.setText(""String_Node_Str"" + unitName + ""String_Node_Str"");
      return false;
    }
  }
 else {
    return true;
  }
}",0.9085972850678732
37690,"private boolean OkAction(){
  DataOptions.inputPath=readerCheckBox.isSelected() ? loadCardData() : AssemblerOptions.objectPath;
  DataOptions.unitCommands=new ArrayList();
  return handleUnit(""String_Node_Str"",punchCheckBox,punchTextField) && handleUnit(""String_Node_Str"",tape1CheckBox,tape1TextField) && handleUnit(""String_Node_Str"",tape2CheckBox,tape2TextField)&& handleUnit(""String_Node_Str"",tape3CheckBox,tape3TextField)&& handleUnit(""String_Node_Str"",tape4CheckBox,tape4TextField)&& handleUnit(""String_Node_Str"",tape5CheckBox,tape5TextField)&& handleUnit(""String_Node_Str"",tape6CheckBox,tape6TextField);
}","private boolean OkAction(){
  if (readerCheckBox.isSelected() && DataOptions.readerPath == null) {
    messageText.setForeground(ExecFrame.DARK_RED);
    messageText.setText(""String_Node_Str"");
    return false;
  }
  DataOptions.inputPath=readerCheckBox.isSelected() ? loadCardData() : AssemblerOptions.objectPath;
  DataOptions.unitCommands=new ArrayList();
  return (handleUnit(""String_Node_Str"",punchCheckBox,punchTextField) && handleUnit(""String_Node_Str"",tape1CheckBox,tape1TextField) && handleUnit(""String_Node_Str"",tape2CheckBox,tape2TextField)&& handleUnit(""String_Node_Str"",tape3CheckBox,tape3TextField)&& handleUnit(""String_Node_Str"",tape4CheckBox,tape4TextField)&& handleUnit(""String_Node_Str"",tape5CheckBox,tape5TextField)&& handleUnit(""String_Node_Str"",tape6CheckBox,tape6TextField));
}",0.8652482269503546
37691,"private String loadCardData(){
  if (cardDeckFile == null) {
    if (DataOptions.readerPath.trim().length() > 0) {
      cardDeckFile=new File(DataOptions.readerPath);
    }
 else {
      return AssemblerOptions.objectPath;
    }
  }
  File objectFile=new File(AssemblerOptions.objectPath);
  String objectName=objectFile.getName();
  String cardDeckName=cardDeckFile.getName();
  String name1=new String(objectName);
  String name2=new String(cardDeckName);
  int index=name1.lastIndexOf(""String_Node_Str"");
  if (index != -1) {
    name1=name1.substring(0,index);
  }
  index=name2.lastIndexOf(""String_Node_Str"");
  if (index != -1) {
    name2=name2.substring(0,index);
  }
  String inputName=name1 + ""String_Node_Str"" + name2+ ""String_Node_Str"";
  File inputFile=new File(DataOptions.directoryPath,inputName);
  String inputPath=inputFile.getPath();
  try {
    BufferedReader objectReader=new BufferedReader(new FileReader(objectFile));
    BufferedReader cardDeckReader=new BufferedReader(new FileReader(cardDeckFile));
    PrintWriter inputWriter=new PrintWriter(new FileWriter(inputFile));
    String line;
    while ((line=objectReader.readLine()) != null) {
      inputWriter.println(line);
    }
    while ((line=cardDeckReader.readLine()) != null) {
      inputWriter.println(line);
    }
    objectReader.close();
    cardDeckReader.close();
    inputWriter.close();
  }
 catch (  Exception ex) {
    parent.writeMessage(ExecFrame.DARK_RED,""String_Node_Str"" + ex.getMessage());
  }
  return inputPath;
}","private String loadCardData(){
  if (cardDeckFile == null) {
    if (DataOptions.readerPath.trim().length() > 0) {
      cardDeckFile=new File(DataOptions.readerPath);
    }
 else {
      return AssemblerOptions.objectPath;
    }
  }
  File objectFile=new File(AssemblerOptions.objectPath);
  String objectName=objectFile.getName();
  String cardDeckName=cardDeckFile.getName();
  String name1=new String(objectName);
  String name2=new String(cardDeckName);
  int index=name1.lastIndexOf(""String_Node_Str"");
  if (index != -1) {
    name1=name1.substring(0,index);
  }
  index=name2.lastIndexOf(""String_Node_Str"");
  if (index != -1) {
    name2=name2.substring(0,index);
  }
  String inputName=name1 + ""String_Node_Str"" + name2+ ""String_Node_Str"";
  File inputFile=new File(DataOptions.directoryPath,inputName);
  String inputPath=inputFile.getPath();
  try {
    BufferedReader objectReader=new BufferedReader(new FileReader(objectFile));
    BufferedReader cardDeckReader=new BufferedReader(new FileReader(cardDeckFile));
    PrintWriter inputWriter=new PrintWriter(new FileWriter(inputFile));
    String line;
    while ((line=objectReader.readLine()) != null) {
      inputWriter.println(line);
    }
    while ((line=cardDeckReader.readLine()) != null) {
      inputWriter.println(line);
    }
    objectReader.close();
    cardDeckReader.close();
    inputWriter.close();
  }
 catch (  IOException ex) {
    parent.writeMessage(ExecFrame.DARK_RED,""String_Node_Str"" + ex.getMessage());
  }
  return inputPath;
}",0.999340804218853
37692,"public Rope(){
  if (RopeHelper.isMac) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    setQuitStrategy(QuitStrategy.SYSTEM_EXIT_0);
  }
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception ex) {
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (mainFrame != null && !mainFrame.closed()) {
        mainFrame.savePreferences();
      }
      Assembler.kill();
      Simulator.kill();
    }
  }
);
  mainFrame=new RopeFrame();
}","public Rope(){
  if (RopeHelper.isMac) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception ex) {
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (mainFrame != null && !mainFrame.closed()) {
        mainFrame.savePreferences();
      }
      Assembler.kill();
      Simulator.kill();
    }
  }
);
  mainFrame=new RopeFrame();
}",0.961926961926962
37693,"@Override public void windowOpened(WindowEvent e){
  loadPreferences();
  if (reopenLastSource) {
    File file=new File(userPrefs.get(""String_Node_Str"",null));
    if (editFrame.loadSourceFile(file)) {
      String sourceName=file.getName();
      int idx=sourceName.lastIndexOf(""String_Node_Str"");
      String baseName=idx == -1 ? sourceName.substring(0) : sourceName.substring(0,idx);
      showExecWindow(baseName);
    }
  }
  currentChildFrame=editFrame;
  desktop.getDesktopManager().activateFrame(editFrame);
}","@Override public void windowOpened(WindowEvent e){
  loadPreferences();
  if (reopenLastSource) {
    String filePath=userPrefs.get(""String_Node_Str"",null);
    if (filePath != null) {
      File file=new File(filePath);
      if (file.exists() && editFrame.loadSourceFile(file)) {
        String sourceName=file.getName();
        int idx=sourceName.lastIndexOf(""String_Node_Str"");
        String baseName=idx == -1 ? sourceName.substring(0) : sourceName.substring(0,idx);
        showExecWindow(baseName);
      }
    }
  }
  currentChildFrame=editFrame;
  desktop.getDesktopManager().activateFrame(editFrame);
}",0.7502206531332745
37694,"private void okAction(){
  File file=new File(assemblerText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(listingText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",listingText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(objectText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",objectText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  for (  String path : macroText.getText().split(""String_Node_Str"")) {
    file=new File(path);
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",path);
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  file=new File(tapeText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",tapeText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(diagnosticText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",diagnosticText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  AssemblerOptions.assemblerPath=assemblerText.getText();
  AssemblerOptions.boot=bootCheckBox.isSelected();
  AssemblerOptions.bootLoader=bootIBMRadioButton.isSelected() ? AssemblerOptions.BOOT_IBM : bootVan1RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_1 : bootVan2RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_2 : AssemblerOptions.BOOT_NONE;
  AssemblerOptions.encoding=encodingCheckBox.isSelected();
  AssemblerOptions.encodingChoice=encodingSimhRadioButton.isSelected() ? AssemblerOptions.ENCODING_SIMH : encodingARadioButton.isSelected() ? AssemblerOptions.ENCODING_A : encodingHRadioButton.isSelected() ? AssemblerOptions.ENCODING_H : AssemblerOptions.ENCODING_PRINT;
  AssemblerOptions.listing=listingCheckBox.isSelected();
  AssemblerOptions.listingPath=listingText.getText();
  AssemblerOptions.object=objectCheckBox.isSelected();
  AssemblerOptions.objectPath=objectText.getText();
  AssemblerOptions.macro=macroCheckBox.isSelected();
  AssemblerOptions.macroPath=macroText.getText();
  AssemblerOptions.tape=tapeCheckBox.isSelected();
  AssemblerOptions.tapePath=tapeText.getText();
  AssemblerOptions.diagnostic=diagnosticCheckBox.isSelected();
  AssemblerOptions.diagnosticPath=diagnosticText.getText();
  AssemblerOptions.codeOk=codeOkCheckBox.isSelected();
  AssemblerOptions.interleave=interleaveCheckBox.isSelected();
  AssemblerOptions.store=storeCheckBox.isSelected();
  AssemblerOptions.dump=dumpCheckBox.isSelected();
  AssemblerOptions.page=pageCheckBox.isSelected();
  AssemblerOptions.pageLength=pageText.getText();
  AssemblerOptions.trace=traceCheckBox.isSelected();
  AssemblerOptions.traceLexer=traceLexerCheckBox.isSelected();
  AssemblerOptions.traceParser=traceParserCheckBox.isSelected();
  AssemblerOptions.traceProcess=traceProcessCheckBox.isSelected();
  AssemblerOptions.extras=extrasCheckBox.isSelected();
  AssemblerOptions.extrasEx=extrasExCheckBox.isSelected();
  AssemblerOptions.extrasEnd=extrasEndCheckBox.isSelected();
  AssemblerOptions.extrasQueue=extrasQueueCheckBox.isSelected();
  AssemblerOptions.extrasReloader=extrasReloaderCheckBox.isSelected();
  AssemblerOptions.command=buildCommand();
  this.setVisible(false);
}","private void okAction(){
  File file=new File(assemblerText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(listingText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",listingText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(objectText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",objectText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  for (  String path : macroText.getText().split(""String_Node_Str"")) {
    file=new File(path);
    if (!file.exists() || file.isDirectory()) {
      String message=String.format(""String_Node_Str"",path);
      if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
  file=new File(tapeText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",tapeText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(diagnosticText.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",diagnosticText.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  AssemblerOptions.assemblerPath=assemblerText.getText();
  AssemblerOptions.boot=bootCheckBox.isSelected();
  AssemblerOptions.bootLoader=bootIBMRadioButton.isSelected() ? AssemblerOptions.BOOT_IBM : bootVan1RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_1 : bootVan2RadioButton.isSelected() ? AssemblerOptions.BOOT_VAN_2 : AssemblerOptions.BOOT_NONE;
  AssemblerOptions.encoding=encodingCheckBox.isSelected();
  AssemblerOptions.encodingChoice=encodingSimhRadioButton.isSelected() ? AssemblerOptions.ENCODING_SIMH : encodingARadioButton.isSelected() ? AssemblerOptions.ENCODING_A : encodingHRadioButton.isSelected() ? AssemblerOptions.ENCODING_H : AssemblerOptions.ENCODING_PRINT;
  AssemblerOptions.listing=listingCheckBox.isSelected();
  AssemblerOptions.listingPath=listingText.getText();
  AssemblerOptions.object=objectCheckBox.isSelected();
  AssemblerOptions.objectPath=objectText.getText();
  AssemblerOptions.macro=macroCheckBox.isSelected();
  AssemblerOptions.macroPath=macroText.getText();
  AssemblerOptions.tape=tapeCheckBox.isSelected();
  AssemblerOptions.tapePath=tapeText.getText();
  AssemblerOptions.diagnostic=diagnosticCheckBox.isSelected();
  AssemblerOptions.diagnosticPath=diagnosticText.getText();
  AssemblerOptions.codeOk=codeOkCheckBox.isSelected();
  AssemblerOptions.interleave=interleaveCheckBox.isSelected();
  AssemblerOptions.store=storeCheckBox.isSelected();
  AssemblerOptions.dump=dumpCheckBox.isSelected();
  AssemblerOptions.page=pageCheckBox.isSelected();
  AssemblerOptions.pageLength=pageText.getText();
  AssemblerOptions.trace=traceCheckBox.isSelected();
  AssemblerOptions.traceLexer=traceLexerCheckBox.isSelected();
  AssemblerOptions.traceParser=traceParserCheckBox.isSelected();
  AssemblerOptions.traceProcess=traceProcessCheckBox.isSelected();
  AssemblerOptions.extras=extrasCheckBox.isSelected();
  AssemblerOptions.extrasEx=extrasExCheckBox.isSelected();
  AssemblerOptions.extrasEnd=extrasEndCheckBox.isSelected();
  AssemblerOptions.extrasQueue=extrasQueueCheckBox.isSelected();
  AssemblerOptions.extrasReloader=extrasReloaderCheckBox.isSelected();
  AssemblerOptions.command=buildCommand();
  this.setVisible(false);
}",0.9636617749825296
37695,"private void resetAction(){
  try {
    String message=""String_Node_Str"";
    int result=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.WARNING_MESSAGE,JOptionPane.OK_CANCEL_OPTION);
    if (result == JOptionPane.OK_OPTION) {
      Preferences userPrefs=Preferences.userRoot();
      userPrefs.clear();
      userPrefs.sync();
      userPrefs.flush();
      Assembler.kill();
      Simulator.kill();
      System.exit(0);
    }
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
}","private void resetAction(){
  try {
    String message=""String_Node_Str"";
    int result=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.OK_CANCEL_OPTION,JOptionPane.WARNING_MESSAGE);
    if (result == JOptionPane.OK_OPTION) {
      Preferences userPrefs=Preferences.userRoot();
      userPrefs.clear();
      userPrefs.sync();
      userPrefs.flush();
      Assembler.kill();
      Simulator.kill();
      System.exit(0);
    }
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.3767361111111111
37696,"private void confirmAction(){
  File file=new File(assemblerPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(simulatorPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",simulatorPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE,JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  try {
    Preferences userPrefs=Preferences.userRoot();
    userPrefs.put(""String_Node_Str"",assemblerPath.getText());
    userPrefs.put(""String_Node_Str"",simulatorPath.getText());
    userPrefs.putBoolean(""String_Node_Str"",saveBeforeAssemblyChk.isSelected());
    userPrefs.putBoolean(""String_Node_Str"",useOldConversionChk.isSelected());
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
  AssemblerOptions.saveBeforeAssembly=saveBeforeAssemblyChk.isSelected();
  SimulatorOptions.useOldConversion=useOldConversionChk.isSelected();
  AssemblerOptions.assemblerPath=assemblerPath.getText();
  SimulatorOptions.simulatorPath=simulatorPath.getText();
  String var=System.getenv(""String_Node_Str"");
  if (var == null || var.isEmpty()) {
    AssemblerOptions.assemblerPath=assemblerPath.getText();
  }
  var=System.getenv(""String_Node_Str"");
  if (var == null || var.isEmpty()) {
    SimulatorOptions.simulatorPath=simulatorPath.getText();
  }
  dispose();
}","private void confirmAction(){
  File file=new File(assemblerPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(simulatorPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",simulatorPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  try {
    Preferences userPrefs=Preferences.userRoot();
    userPrefs.put(""String_Node_Str"",assemblerPath.getText());
    userPrefs.put(""String_Node_Str"",simulatorPath.getText());
    userPrefs.putBoolean(""String_Node_Str"",saveBeforeAssemblyChk.isSelected());
    userPrefs.putBoolean(""String_Node_Str"",useOldConversionChk.isSelected());
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
  AssemblerOptions.saveBeforeAssembly=saveBeforeAssemblyChk.isSelected();
  SimulatorOptions.useOldConversion=useOldConversionChk.isSelected();
  AssemblerOptions.assemblerPath=assemblerPath.getText();
  SimulatorOptions.simulatorPath=simulatorPath.getText();
  String var=System.getenv(""String_Node_Str"");
  if (var == null || var.isEmpty()) {
    AssemblerOptions.assemblerPath=assemblerPath.getText();
  }
  var=System.getenv(""String_Node_Str"");
  if (var == null || var.isEmpty()) {
    SimulatorOptions.simulatorPath=simulatorPath.getText();
  }
  dispose();
}",0.8245515695067265
37697,"public boolean quitRope(){
  if (editFrame.sourcePath != null && editFrame.sourceChanged) {
    int result=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,JOptionPane.YES_NO_CANCEL_OPTION);
    if (result == JOptionPane.CANCEL_OPTION) {
      return false;
    }
 else     if (result == JOptionPane.YES_OPTION) {
      editFrame.saveAction();
    }
  }
  if (askConfirmationToQuit) {
    int result=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,JOptionPane.YES_NO_OPTION);
    if (result == JOptionPane.NO_OPTION) {
      return false;
    }
  }
  savePreferences();
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  closed=true;
  return closed;
}","public boolean quitRope(){
  if (editFrame.sourcePath != null && editFrame.sourceChanged) {
    int result=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
    if (result == JOptionPane.CANCEL_OPTION) {
      return false;
    }
 else     if (result == JOptionPane.YES_OPTION) {
      editFrame.saveAction();
    }
  }
  if (askConfirmationToQuit) {
    int result=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE);
    if (result == JOptionPane.NO_OPTION) {
      return false;
    }
  }
  savePreferences();
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  closed=true;
  return closed;
}",0.9224704336399474
37698,"private void jbInit() throws Exception {
  assemblerPath=new JTextField();
  simulatorPath=new JTextField();
  saveBeforeAssemblyChk=new JCheckBox(""String_Node_Str"");
  useOldConversionChk=new JCheckBox(""String_Node_Str"");
  assemblerBrowseBtn=new JButton(""String_Node_Str"");
  simulatorBrowseBtn=new JButton(""String_Node_Str"");
  confirmBtn=new JButton(""String_Node_Str"");
  cancelBtn=new JButton(""String_Node_Str"");
  JPanel mainPanel=new JPanel();
  JPanel assemblerPanel=new JPanel();
  JPanel simulatorPanel=new JPanel();
  JPanel checkPanel=new JPanel();
  JPanel buttonsPanel=new JPanel();
  TitledBorder assemblerBorder=new TitledBorder(BorderFactory.createLineBorder(Color.white,1),""String_Node_Str"");
  TitledBorder simulatorBorder=new TitledBorder(BorderFactory.createLineBorder(Color.white,1),""String_Node_Str"");
  assemblerPanel.setBorder(assemblerBorder);
  assemblerPanel.setLayout(new GridBagLayout());
  assemblerPanel.add(assemblerPath,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,0),400,0));
  assemblerPanel.add(assemblerBrowseBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,5,5),0,0));
  simulatorPanel.setBorder(simulatorBorder);
  simulatorPanel.setLayout(new GridBagLayout());
  simulatorPanel.add(simulatorPath,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,0),400,0));
  simulatorPanel.add(simulatorBrowseBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,5,5),0,0));
  checkPanel.setLayout(new GridBagLayout());
  checkPanel.add(saveBeforeAssemblyChk,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,5),0,0));
  checkPanel.add(useOldConversionChk,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,5),0,0));
  buttonsPanel.setLayout(new GridBagLayout());
  buttonsPanel.add(confirmBtn,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,15,10),0,0));
  buttonsPanel.add(cancelBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,15,0),0,0));
  mainPanel.setLayout(new GridBagLayout());
  mainPanel.add(assemblerPanel,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(10,10,5,10),0,0));
  mainPanel.add(simulatorPanel,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,10,10,10),0,0));
  mainPanel.add(checkPanel,new GridBagConstraints(0,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,5),0,0));
  mainPanel.add(buttonsPanel,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(10,10,5,10),0,0));
  getContentPane().add(mainPanel);
}","private void jbInit() throws Exception {
  assemblerPath=new JTextField();
  simulatorPath=new JTextField();
  saveBeforeAssemblyChk=new JCheckBox(""String_Node_Str"");
  useOldConversionChk=new JCheckBox(""String_Node_Str"");
  assemblerBrowseBtn=new JButton(""String_Node_Str"");
  simulatorBrowseBtn=new JButton(""String_Node_Str"");
  confirmBtn=new JButton(""String_Node_Str"");
  cancelBtn=new JButton(""String_Node_Str"");
  resetBtn=new JButton(""String_Node_Str"");
  JPanel mainPanel=new JPanel();
  JPanel assemblerPanel=new JPanel();
  JPanel simulatorPanel=new JPanel();
  JPanel checkPanel=new JPanel();
  JPanel buttonsPanel=new JPanel();
  TitledBorder assemblerBorder=new TitledBorder(BorderFactory.createLineBorder(Color.white,1),""String_Node_Str"");
  TitledBorder simulatorBorder=new TitledBorder(BorderFactory.createLineBorder(Color.white,1),""String_Node_Str"");
  assemblerPanel.setBorder(assemblerBorder);
  assemblerPanel.setLayout(new GridBagLayout());
  assemblerPanel.add(assemblerPath,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,0),400,0));
  assemblerPanel.add(assemblerBrowseBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,5,5),0,0));
  simulatorPanel.setBorder(simulatorBorder);
  simulatorPanel.setLayout(new GridBagLayout());
  simulatorPanel.add(simulatorPath,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,0),400,0));
  simulatorPanel.add(simulatorBrowseBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,5,5),0,0));
  checkPanel.setLayout(new GridBagLayout());
  checkPanel.add(saveBeforeAssemblyChk,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,5,5,5),0,0));
  checkPanel.add(useOldConversionChk,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,5,5),0,0));
  buttonsPanel.setLayout(new GridBagLayout());
  buttonsPanel.add(confirmBtn,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,15,10),0,0));
  buttonsPanel.add(cancelBtn,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,15,0),0,0));
  buttonsPanel.add(resetBtn,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,100,15,0),0,0));
  mainPanel.setLayout(new GridBagLayout());
  mainPanel.add(assemblerPanel,new GridBagConstraints(0,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(10,10,5,10),0,0));
  mainPanel.add(simulatorPanel,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(5,10,10,10),0,0));
  mainPanel.add(checkPanel,new GridBagConstraints(0,2,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,5),0,0));
  mainPanel.add(buttonsPanel,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(10,10,5,10),0,0));
  getContentPane().add(mainPanel);
}",0.9697452229299364
37699,"@Override public void actionPerformed(ActionEvent event){
  Object source=event.getSource();
  if (source == assemblerBrowseBtn) {
    Vector<RopeFileFilter> filters=null;
    if (RopeHelper.isWindows) {
      filters=new Vector<RopeFileFilter>();
      filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
    }
    browseAction(""String_Node_Str"",AssemblerOptions.assemblerPath,assemblerPath,filters,false,false);
  }
 else   if (source == simulatorBrowseBtn) {
    Vector<RopeFileFilter> filters=null;
    if (RopeHelper.isWindows) {
      filters=new Vector<RopeFileFilter>();
      filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
    }
    browseAction(""String_Node_Str"",SimulatorOptions.simulatorPath,simulatorPath,filters,false,false);
  }
 else   if (source == confirmBtn) {
    confirmAction();
  }
 else   if (source == cancelBtn) {
    cancelAction();
  }
}","@Override public void actionPerformed(ActionEvent event){
  Object source=event.getSource();
  if (source == assemblerBrowseBtn) {
    Vector<RopeFileFilter> filters=null;
    if (RopeHelper.isWindows) {
      filters=new Vector<RopeFileFilter>();
      filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
    }
    browseAction(""String_Node_Str"",AssemblerOptions.assemblerPath,assemblerPath,filters,false,false);
  }
 else   if (source == simulatorBrowseBtn) {
    Vector<RopeFileFilter> filters=null;
    if (RopeHelper.isWindows) {
      filters=new Vector<RopeFileFilter>();
      filters.add(new RopeFileFilter(new String[]{""String_Node_Str""},""String_Node_Str""));
    }
    browseAction(""String_Node_Str"",SimulatorOptions.simulatorPath,simulatorPath,filters,false,false);
  }
 else   if (source == confirmBtn) {
    confirmAction();
  }
 else   if (source == cancelBtn) {
    cancelAction();
  }
 else   if (source == resetBtn) {
    resetAction();
  }
}",0.9703896103896104
37700,"PreferencesDialog(Frame owner,String title){
  super(owner,title,Dialog.ModalityType.DOCUMENT_MODAL);
  setMinimumSize(new Dimension(400,210));
  this.setResizable(false);
  try {
    jbInit();
    pack();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  assemblerBrowseBtn.addActionListener(this);
  simulatorBrowseBtn.addActionListener(this);
  confirmBtn.addActionListener(this);
  cancelBtn.addActionListener(this);
  assemblerPath.setText(AssemblerOptions.assemblerPath);
  simulatorPath.setText(SimulatorOptions.simulatorPath);
  saveBeforeAssemblyChk.setSelected(AssemblerOptions.saveBeforeAssembly);
  useOldConversionChk.setSelected(SimulatorOptions.useOldConversion);
}","PreferencesDialog(Frame owner,String title){
  super(owner,title,Dialog.ModalityType.DOCUMENT_MODAL);
  setMinimumSize(new Dimension(400,210));
  this.setResizable(false);
  try {
    jbInit();
    pack();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  assemblerBrowseBtn.addActionListener(this);
  simulatorBrowseBtn.addActionListener(this);
  confirmBtn.addActionListener(this);
  cancelBtn.addActionListener(this);
  resetBtn.addActionListener(this);
  assemblerPath.setText(AssemblerOptions.assemblerPath);
  simulatorPath.setText(SimulatorOptions.simulatorPath);
  saveBeforeAssemblyChk.setSelected(AssemblerOptions.saveBeforeAssembly);
  useOldConversionChk.setSelected(SimulatorOptions.useOldConversion);
}",0.9746478873239436
37701,"public RopeFrame(){
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  addWindowListener(this);
  addFocusListener(this);
  if (packFrame) {
    this.pack();
  }
 else {
    this.validate();
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  Dimension frameSize=new Dimension(screenSize.width - 10,screenSize.height - (RopeHelper.isMac ? 80 : 50));
  this.setSize(frameSize);
  this.setLocation((screenSize.width - frameSize.width) / 2,10);
  this.setTitle(MessageFormat.format(RopeResources.getString(""String_Node_Str""),RopeResources.getString(""String_Node_Str"")));
  JPanel contentPanel=(JPanel)this.getContentPane();
  contentPanel.add(desktop);
  desktop.setBackground(new Color(215,215,255));
  setupMenus();
  Dimension ropeFrameSize=this.getContentPane().getSize();
  editFrame=new EditFrame(this);
  Point frameLocation=new Point(0,0);
  frameSize=editFrame.getSize();
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",editFrame.getLocation().toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",editFrame.getSize().toString()));
  editFrame.setLocation(frameLocation);
  editFrame.setSize(frameSize);
  editFrame.setVisible(true);
  desktop.add(editFrame);
  execFrame=new ExecFrame(this);
  frameLocation.setLocation((ropeFrameSize.width / 2),0);
  frameSize=execFrame.getSize();
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",execFrame.getLocation().toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",execFrame.getSize().toString()));
  execFrame.setLocation(frameLocation);
  execFrame.setSize(frameSize);
  execFrame.setVisible(false);
  desktop.add(execFrame);
  printoutFrame=new PrintoutFrame(this);
  frameSize.setSize(printoutFrame.getWidth(),ropeFrameSize.height - editFrame.getHeight());
  frameLocation.setLocation(0,ropeFrameSize.height - frameSize.height);
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",frameLocation.toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",frameSize.toString()));
  printoutFrame.setLocation(frameLocation);
  printoutFrame.setSize(frameSize);
  printoutFrame.setVisible(false);
  desktop.add(printoutFrame);
  currentChildFrame=editFrame;
  setVisible(true);
  clipboardListener=new ClipboardListener(this);
}","public RopeFrame(){
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  addWindowListener(this);
  addFocusListener(this);
  if (packFrame) {
    this.pack();
  }
 else {
    this.validate();
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  Dimension frameSize=new Dimension(screenSize.width - 10,screenSize.height - (RopeHelper.isMac ? 80 : 50));
  this.setSize(frameSize);
  this.setLocation((screenSize.width - frameSize.width) / 2,10);
  this.setTitle(MessageFormat.format(RopeResources.getString(""String_Node_Str""),RopeResources.getString(""String_Node_Str"")));
  JPanel contentPanel=(JPanel)this.getContentPane();
  contentPanel.add(desktop);
  desktop.setBackground(new Color(215,215,255));
  setupMenus();
  Dimension ropeFrameSize=getSize();
  editFrame=new EditFrame(this);
  Point frameLocation=new Point(0,0);
  frameSize=editFrame.getSize();
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",editFrame.getLocation().toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",editFrame.getSize().toString()));
  verifyFrameLocation(frameLocation);
  verifyFrameSize(frameSize);
  editFrame.setLocation(frameLocation);
  editFrame.setSize(frameSize);
  editFrame.setVisible(true);
  desktop.add(editFrame);
  execFrame=new ExecFrame(this);
  frameLocation.setLocation(ropeFrameSize.width / 2,0);
  frameSize=execFrame.getSize();
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",execFrame.getLocation().toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",execFrame.getSize().toString()));
  verifyFrameLocation(frameLocation);
  verifyFrameSize(frameSize);
  execFrame.setLocation(frameLocation);
  execFrame.setSize(frameSize);
  execFrame.setVisible(false);
  desktop.add(execFrame);
  printoutFrame=new PrintoutFrame(this);
  frameLocation.setLocation(ropeFrameSize.width / 2,ropeFrameSize.height / 2);
  frameSize=printoutFrame.getSize();
  frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",frameLocation.toString()));
  frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",frameSize.toString()));
  verifyFrameLocation(frameLocation);
  verifyFrameSize(frameSize);
  printoutFrame.setLocation(frameLocation);
  printoutFrame.setSize(frameSize);
  printoutFrame.setVisible(false);
  desktop.add(printoutFrame);
  currentChildFrame=editFrame;
  setVisible(true);
  clipboardListener=new ClipboardListener(this);
}",0.9064303380049464
37702,"void showPrintoutWindow(String baseName){
  desktop.getDesktopManager().deiconifyFrame(printoutFrame);
  printoutFrame.setTitle(""String_Node_Str"" + baseName);
  printoutFrame.setVisible(true);
  printoutFrame.initialize();
  printoutFrame.toBack();
  commandWindows.addElement(printoutFrame);
  try {
    execFrame.setSelected(true);
  }
 catch (  PropertyVetoException ignore) {
  }
}","void showPrintoutWindow(String baseName){
  desktop.getDesktopManager().deiconifyFrame(printoutFrame);
  printoutFrame.setTitle(""String_Node_Str"" + baseName);
  printoutFrame.setVisible(true);
  printoutFrame.initialize();
  printoutFrame.toFront();
  commandWindows.addElement(printoutFrame);
  try {
    execFrame.toFront();
    execFrame.setSelected(true);
  }
 catch (  PropertyVetoException ignore) {
  }
}",0.957286432160804
37703,"void createMemoryFrame(){
  if (memoryFrame == null) {
    Dimension ropeFrameSize=this.getContentPane().getSize();
    memoryFrame=new MemoryFrame(this);
    Dimension frameSize=memoryFrame.getSize();
    Point frameLocation=new Point((int)(ropeFrameSize.getWidth() - frameSize.getWidth()) / 2,(int)(ropeFrameSize.getHeight() - frameSize.getHeight()) / 2);
    frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",frameLocation.toString()));
    frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",frameSize.toString()));
    memoryFrame.setLocation(frameLocation);
    memoryFrame.setSize(frameSize);
    memoryFrame.setVisible(true);
    desktop.add(memoryFrame);
    commandWindows.addElement(memoryFrame);
    try {
      memoryFrame.setSelected(true);
    }
 catch (    PropertyVetoException ignore) {
    }
  }
 else {
    desktop.getDesktopManager().deiconifyFrame(memoryFrame);
    desktop.getDesktopManager().activateFrame(memoryFrame);
  }
}","void createMemoryFrame(){
  if (memoryFrame == null) {
    Dimension ropeFrameSize=this.getContentPane().getSize();
    memoryFrame=new MemoryFrame(this);
    Dimension frameSize=memoryFrame.getSize();
    Point frameLocation=new Point((int)(ropeFrameSize.getWidth() - frameSize.getWidth()) / 2,(int)(ropeFrameSize.getHeight() - frameSize.getHeight()) / 2);
    frameLocation=RopeHelper.parsePoint(userPrefs.get(""String_Node_Str"",frameLocation.toString()));
    frameSize=RopeHelper.parseDimension(userPrefs.get(""String_Node_Str"",frameSize.toString()));
    verifyFrameLocation(frameLocation);
    verifyFrameSize(frameSize);
    memoryFrame.setLocation(frameLocation);
    memoryFrame.setSize(frameSize);
    memoryFrame.setVisible(true);
    desktop.add(memoryFrame);
    commandWindows.addElement(memoryFrame);
    try {
      memoryFrame.setSelected(true);
    }
 catch (    PropertyVetoException ignore) {
    }
  }
 else {
    desktop.getDesktopManager().deiconifyFrame(memoryFrame);
    desktop.getDesktopManager().activateFrame(memoryFrame);
  }
}",0.9646712463199216
37704,"void showExecWindow(String baseName){
  desktop.getDesktopManager().deiconifyFrame(execFrame);
  execFrame.setTitle(""String_Node_Str"" + baseName);
  execFrame.setVisible(true);
  execFrame.initialize(baseName,DataOptions.outputPath);
  if (haveAssemblyErrors()) {
    try {
      editFrame.setSelected(true);
    }
 catch (    PropertyVetoException ignore) {
    }
  }
}","void showExecWindow(String baseName){
  desktop.getDesktopManager().deiconifyFrame(execFrame);
  execFrame.setTitle(""String_Node_Str"" + baseName);
  execFrame.setVisible(true);
  execFrame.initialize(baseName,DataOptions.outputPath);
  execFrame.toFront();
}",0.7547770700636943
37705,"private void assembleAction(){
  String line;
  messages=new Vector();
  mainFrame.resetExecWindow();
  saveAction();
  assembleFailed=false;
  haveAssemblyErrors=false;
  if (Assembler.version()) {
    while ((line=Assembler.output()) != null) {
      messages.addElement(line);
    }
    Assembler.setPaths(baseName,sourcePath);
    if (Assembler.assemble()) {
      while ((line=Assembler.output()) != null) {
        messages.addElement(line);
        haveAssemblyErrors=true;
      }
      messageList.setListData(messages);
      messageList.ensureIndexIsVisible(0);
      mainFrame.showExecWindow(baseName);
    }
 else {
      assembleFailed=true;
    }
  }
 else {
    assembleFailed=true;
  }
  if (assembleFailed) {
    String message=String.format(""String_Node_Str"",AssemblerOptions.assemblerPath);
    System.out.println(message);
    JOptionPane.showMessageDialog(this,message);
  }
}","private void assembleAction(){
  String line;
  messages=new Vector();
  mainFrame.resetExecWindow();
  saveAction();
  assembleFailed=false;
  haveAssemblyErrors=false;
  if (Assembler.version()) {
    while ((line=Assembler.output()) != null) {
      messages.addElement(line);
    }
    Assembler.setPaths(baseName,sourcePath);
    if (Assembler.assemble()) {
      while ((line=Assembler.output()) != null) {
        System.out.println(line);
        messages.addElement(line);
        if (line.startsWith(""String_Node_Str"")) {
          haveAssemblyErrors=true;
        }
      }
      messageList.setListData(messages);
      messageList.ensureIndexIsVisible(0);
      mainFrame.showExecWindow(baseName);
    }
 else {
      assembleFailed=true;
    }
  }
 else {
    assembleFailed=true;
  }
  if (assembleFailed) {
    String message=String.format(""String_Node_Str"",AssemblerOptions.assemblerPath);
    System.out.println(message);
    JOptionPane.showMessageDialog(this,message);
  }
}",0.949260042283298
37706,"private void browseAction(String title,String filePath,JTextField textField,Vector<RopeFileFilter> filters,boolean directories,boolean multiple){
  RopeFileChooser chooser=new RopeFileChooser(DataOptions.directoryPath,filePath,filters,directories,multiple);
  chooser.setDialogTitle(title);
  chooser.setFileFilter(filters.firstElement());
  chooser.choose(textField,this,multiple);
}","private void browseAction(String title,String filePath,JTextField textField,Vector<RopeFileFilter> filters,boolean directories,boolean multiple){
  RopeFileChooser chooser=new RopeFileChooser(DataOptions.directoryPath,filePath,filters,directories,multiple);
  chooser.setDialogTitle(title);
  if (filters != null) {
    chooser.setFileFilter(filters.firstElement());
  }
  chooser.choose(textField,this,multiple);
}",0.9612015018773468
37707,"private void confirmAction(){
  AssemblerOptions.saveBeforeAssembly=saveBeforeAssemblyChk.isSelected();
  SimulatorOptions.useOldConversion=useOldConversionChk.isSelected();
  AssemblerOptions.assemblerPath=assemblerPath.getText();
  SimulatorOptions.simulatorPath=simulatorPath.getText();
  try {
    Preferences userPrefs=Preferences.userRoot();
    userPrefs.put(""String_Node_Str"",AssemblerOptions.assemblerPath);
    userPrefs.put(""String_Node_Str"",SimulatorOptions.simulatorPath);
    userPrefs.putBoolean(""String_Node_Str"",AssemblerOptions.saveBeforeAssembly);
    userPrefs.putBoolean(""String_Node_Str"",SimulatorOptions.useOldConversion);
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
  dispose();
}","private void confirmAction(){
  File file=new File(assemblerPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",assemblerPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  file=new File(simulatorPath.getText());
  if (!file.exists() || file.isDirectory()) {
    String message=String.format(""String_Node_Str"",simulatorPath.getText());
    if (JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
      return;
    }
  }
  AssemblerOptions.saveBeforeAssembly=saveBeforeAssemblyChk.isSelected();
  SimulatorOptions.useOldConversion=useOldConversionChk.isSelected();
  AssemblerOptions.assemblerPath=assemblerPath.getText();
  SimulatorOptions.simulatorPath=simulatorPath.getText();
  try {
    Preferences userPrefs=Preferences.userRoot();
    userPrefs.put(""String_Node_Str"",AssemblerOptions.assemblerPath);
    userPrefs.put(""String_Node_Str"",SimulatorOptions.simulatorPath);
    userPrefs.putBoolean(""String_Node_Str"",AssemblerOptions.saveBeforeAssembly);
    userPrefs.putBoolean(""String_Node_Str"",SimulatorOptions.useOldConversion);
    userPrefs.sync();
    userPrefs.flush();
  }
 catch (  BackingStoreException ex) {
    Logger.getLogger(RopeFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
  dispose();
}",0.7236092860271572
37708,"static boolean assemble(){
  try {
    Simulator.kill();
    process=Runtime.getRuntime().exec(AssemblerOptions.command);
    stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}","static boolean assemble(){
  try {
    Simulator.kill();
    String[] args=AssemblerOptions.command.toArray(new String[0]);
    process=Runtime.getRuntime().exec(args);
    stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}",0.8609077598828697
37709,"static boolean version(){
  String command=AssemblerOptions.assemblerPath + ""String_Node_Str"";
  try {
    process=Runtime.getRuntime().exec(command);
    stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}","static boolean version(){
  String[] args=new String[2];
  args[0]=AssemblerOptions.assemblerPath;
  args[1]=""String_Node_Str"";
  try {
    process=Runtime.getRuntime().exec(args);
    stdout=new BufferedReader(new InputStreamReader(process.getInputStream()));
    process=null;
    return true;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return false;
  }
}",0.9088397790055248
37710,"/** 
 * Get pet's owner from database-
 * @param petId Pet id
 * @return pet's owner
 */
private Owner findPetsOwner(Integer petId){
  Owner owner=null;
  DBCollection dbOwner=database.getCollection(OWNER_COLLECTION);
  DBCursor cursor=dbOwner.find();
  Owner tempOwner;
  while (cursor.hasNext() && (owner == null)) {
    tempOwner=mapToOwner(cursor.next());
    for (    Pet pet : tempOwner.getPets()) {
      if (pet.getId() == petId) {
        owner=tempOwner;
        break;
      }
    }
  }
  return owner;
}","/** 
 * Get pet's owner from database-
 * @param petId Pet id
 * @return pet's owner
 */
private Owner findPetsOwner(Integer petId){
  Owner owner=null;
  DBCollection dbOwner=database.getCollection(OWNER_COLLECTION);
  DBCursor cursor=dbOwner.find();
  Owner tempOwner;
  while (cursor.hasNext() && (owner == null)) {
    tempOwner=mapToOwner(cursor.next());
    for (    Pet pet : tempOwner.getPets()) {
      if (pet.getId().equals(petId)) {
        owner=tempOwner;
        break;
      }
    }
  }
  return owner;
}",0.98743961352657
37711,"/** 
 * Store pet information into database.
 * @param pet pet to be stored
 * @throws DataAccessException
 */
public void storePet(Pet pet) throws DataAccessException {
  DBCollection collOwner=database.getCollection(OWNER_COLLECTION);
  BasicDBObject ownerQuery=new BasicDBObject(_ID_FIELD,pet.getOwner().getId());
  Owner owner=mapToOwner(collOwner.findOne(ownerQuery));
  if (pet.getId() == null) {
    pet.setId(getNextIdValue(PET_SEQUENCE));
    owner.addPet(pet);
  }
 else {
    List<Pet> pets=owner.getPets();
    List<Pet> newPetsList=new ArrayList<Pet>();
    for (    Pet pet1 : pets) {
      if (pet1.getId() == pet.getId()) {
        newPetsList.add(pet);
      }
 else {
        newPetsList.add(pet1);
      }
    }
    owner.setPets(newPetsList);
  }
  DBObject newDbOwner=mapOwnerToDBObject(owner,owner.getId());
  collOwner.update(ownerQuery,newDbOwner);
}","/** 
 * Store pet information into database.
 * @param pet pet to be stored
 * @throws DataAccessException
 */
public void storePet(Pet pet) throws DataAccessException {
  DBCollection collOwner=database.getCollection(OWNER_COLLECTION);
  BasicDBObject ownerQuery=new BasicDBObject(_ID_FIELD,pet.getOwner().getId());
  Owner owner=mapToOwner(collOwner.findOne(ownerQuery));
  if (pet.getId() == null) {
    pet.setId(getNextIdValue(PET_SEQUENCE));
    owner.addPet(pet);
  }
 else {
    List<Pet> pets=owner.getPets();
    List<Pet> newPetsList=new ArrayList<Pet>();
    for (    Pet pet1 : pets) {
      if (pet1.getId().equals(pet.getId())) {
        newPetsList.add(pet);
      }
 else {
        newPetsList.add(pet1);
      }
    }
    owner.setPets(newPetsList);
  }
  DBObject newDbOwner=mapOwnerToDBObject(owner,owner.getId());
  collOwner.update(ownerQuery,newDbOwner);
}",0.9925841414717628
37712,"/** 
 * Get pet's owner from database-
 * @param petId Pet id
 * @return pet's owner
 */
private Owner findPetsOwner(Integer petId){
  Owner owner=null;
  DBCollection dbOwner=database.getCollection(OWNER_COLLECTION);
  DBCursor cursor=dbOwner.find();
  Owner tempOwner;
  while (cursor.hasNext() && (owner == null)) {
    tempOwner=mapToOwner(cursor.next());
    for (    Pet pet : tempOwner.getPets()) {
      if (pet.getId() == petId) {
        owner=tempOwner;
        break;
      }
    }
  }
  return owner;
}","/** 
 * Get pet's owner from database-
 * @param petId Pet id
 * @return pet's owner
 */
private Owner findPetsOwner(Integer petId){
  Owner owner=null;
  DBCollection dbOwner=database.getCollection(OWNER_COLLECTION);
  DBCursor cursor=dbOwner.find();
  Owner tempOwner;
  while (cursor.hasNext() && (owner == null)) {
    tempOwner=mapToOwner(cursor.next());
    for (    Pet pet : tempOwner.getPets()) {
      if (pet.getId().equals(petId)) {
        owner=tempOwner;
        break;
      }
    }
  }
  return owner;
}",0.98743961352657
37713,"public void validate(Owner owner,Errors errors){
  if (!StringUtils.hasLength(owner.getFirstName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getLastName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getAddress())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getCity())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  String telephone=owner.getTelephone();
  if (!StringUtils.hasLength(telephone)) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    for (int i=0; i < telephone.length(); ++i) {
      if (!Character.isDigit(telephone.charAt(i))) {
        errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        break;
      }
    }
  }
}","public void validate(Owner owner,Errors errors){
  if (!StringUtils.hasLength(owner.getFirstName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getLastName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getAddress())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getCity())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  String telephone=owner.getTelephone();
  if (StringUtils.hasLength(telephone)) {
    for (int i=0; i < telephone.length(); ++i) {
      if (!Character.isDigit(telephone.charAt(i))) {
        errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        break;
      }
    }
  }
 else {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}",0.9068702290076336
37714,"public void validate(Owner owner,Errors errors){
  if (!StringUtils.hasLength(owner.getFirstName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getLastName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getAddress())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getCity())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  String telephone=owner.getTelephone();
  if (!StringUtils.hasLength(telephone)) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    for (int i=0; i < telephone.length(); ++i) {
      if ((Character.isDigit(telephone.charAt(i))) == false) {
        errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        break;
      }
    }
  }
}","public void validate(Owner owner,Errors errors){
  if (!StringUtils.hasLength(owner.getFirstName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getLastName())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getAddress())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!StringUtils.hasLength(owner.getCity())) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  String telephone=owner.getTelephone();
  if (!StringUtils.hasLength(telephone)) {
    errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    for (int i=0; i < telephone.length(); ++i) {
      if (!Character.isDigit(telephone.charAt(i))) {
        errors.rejectValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        break;
      }
    }
  }
}",0.9939271255060728
37715,"public static void main(String[] args) throws IOException, JAXBException {
  JCommander jc=new JCommander();
  jc.setProgramName(""String_Node_Str"");
  AssembleCommand assemble=new AssembleCommand();
  SegmentCommand segment=new SegmentCommand();
  CompareCommand compare=new CompareCommand();
  DiffCommand diff=new DiffCommand();
  EnumerateCommand enumerate=new EnumerateCommand();
  HelpCommand help=new HelpCommand();
  jc.addCommand(""String_Node_Str"",assemble);
  jc.addCommand(""String_Node_Str"",segment);
  jc.addCommand(""String_Node_Str"",compare);
  jc.addCommand(""String_Node_Str"",enumerate);
  jc.addCommand(""String_Node_Str"",diff);
  jc.addCommand(""String_Node_Str"",help);
  try {
    jc.parse(args);
    if (jc.getParsedCommand() == null || jc.getParsedCommand().equals(""String_Node_Str"")) {
      jc.usage();
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateAssemble(assemble);
      File out_dir=assemble.dir;
      if (!out_dir.exists())       out_dir.mkdirs();
      File log_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ConfigurationIO.writeConfiguration(assemble,configuration_file);
{
        File bamFile=assemble.bam;
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        logger.info(""String_Node_Str"");
        BEDWriter sj_bw=new BEDWriter(IO.bufferedPrintstream(splice_junction_bed));
        FindSpliceJunctions.tabulateSpliceJunctions(sfr,strandedness,sj_bw);
        sj_bw.close();
        logger.info(""String_Node_Str"");
        GTFWriter counted_sj_gtf=new GTFWriter(IO.bufferedPrintstream(splice_count_gtf));
        FindSpliceJunctions.countJunctionSupportingReads(sfr,strandedness,counted_sj_gtf);
        counted_sj_gtf.close();
        logger.info(""String_Node_Str"");
        BEDWriter seg_bw=new BEDWriter(IO.bufferedPrintstream(segment_bed));
        SlidingWindow.identifyExpressed(sfr,strandedness,1,assemble.threshold,1,seg_bw);
        seg_bw.close();
        if (assemble.insert_size_quantile != null) {
          File matepair_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
          File scaffolded_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
          logger.info(""String_Node_Str"");
          int insert_size=ClusterExpressedSegments.estimateMateInsertSize(sfr,strandedness,segment_bed,assemble.insert_size_quantile);
          logger.info(""String_Node_Str"",assemble.insert_size_quantile,insert_size);
          BEDWriter matepair_bw=new BEDWriter(IO.bufferedPrintstream(matepair_bed));
          ClusterExpressedSegments.identifySpannableRegions(sfr,strandedness,matepair_bw,insert_size);
          matepair_bw.close();
          logger.info(""String_Node_Str"");
          BEDWriter scaffolded_bw=new BEDWriter(IO.bufferedPrintstream(scaffolded_bed));
          ClusterExpressedSegments.scaffoldSpannableRegions(segment_bed,matepair_bed,scaffolded_bw);
          scaffolded_bw.close();
        }
        sfr.close();
      }
{
        File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        File unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())         assembly_gtf.getParentFile().mkdirs();
        File bamFile=assemble.bam;
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File segment_bed=assemble.insert_size_quantile == null ? FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        double jnct_alpha=assemble.jnct_alpha;
        File merged_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File spliced_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File acc_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File rej_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File intronic_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        logger.info(""String_Node_Str"",assemble.merge_radius);
        BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
        File merge_regions=assemble.filled_gap_segments == null ? null : assemble.filled_gap_segments;
        ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,assemble.merge_radius);
        merged_segments.close();
        logger.info(""String_Node_Str"");
        GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
        GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
        FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
        passed_jnct_gw.close();
        failed_jnct_gw.close();
        if (strandedness == Strandedness.unstranded) {
          logger.info(""String_Node_Str"");
          BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
          ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
          inferred_strand_segment.close();
          merged_segment_bed=inferred_strand_segment_bed;
        }
        logger.info(""String_Node_Str"");
        GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
        ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
        spliced_exons.close();
        if (strandedness == Strandedness.unstranded) {
          logger.info(""String_Node_Str"");
          GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
          ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
          trimmed_exons.close();
          spliced_exon_gtf=trimmed_exon_gtf;
        }
        GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
        if (false) {
          System.out.println(""String_Node_Str"");
          ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
        }
        intronic_exon_writer.close();
        logger.info(""String_Node_Str"");
        double alpha_0=1.0;
        double beta_0=1.0;
        int nb_r=assemble.nb_r;
        int r=assemble.segment_r;
        double p=assemble.segment_p;
        int maxBins=20000;
        int binSize=assemble.w;
        int minCP=0;
        int minLength=binSize * 2;
        GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
        boolean internal=assemble.internal;
        double min_fold=assemble.min_fold;
        int min_terminal=-assemble.min_terminal;
        int confidence_interval=assemble.c;
        IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal,confidence_interval);
        changepoint_writer.close();
        logger.info(""String_Node_Str"");
        int sj_radius=binSize * 1;
        GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
        IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
        filtered_changepoint_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
        IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
        changepoint_exon_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
        ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
        assembly_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
        ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
        remainder_writer.close();
        if (assemble.coverage) {
          logger.info(""String_Node_Str"");
          File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
          File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
          GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
          IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
          coverage_gw.close();
          GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
          IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
          coverage_unspliced_gw.close();
        }
        sfr.close();
      }
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
{
        File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        File unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())         assembly_gtf.getParentFile().mkdirs();
        File bamFile=segment.bam;
        File out_dir=new File(segment.dir);
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File segment_bed=!FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"").exists() ? FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        double jnct_alpha=segment.jnct_alpha;
        File merged_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File spliced_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File acc_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File rej_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File intronic_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(segment.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        System.out.println(""String_Node_Str"");
        BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
        File merge_regions=segment.filled_gap_segments == null ? null : new File(segment.filled_gap_segments);
        ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,segment.merge_radius);
        merged_segments.close();
        System.out.println(""String_Node_Str"");
        GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
        GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
        FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
        passed_jnct_gw.close();
        failed_jnct_gw.close();
        if (strandedness == Strandedness.unstranded) {
          System.out.println(""String_Node_Str"");
          BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
          ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
          inferred_strand_segment.close();
          merged_segment_bed=inferred_strand_segment_bed;
        }
        System.out.println(""String_Node_Str"");
        GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
        ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
        spliced_exons.close();
        if (strandedness == Strandedness.unstranded) {
          System.out.println(""String_Node_Str"");
          GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
          ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
          trimmed_exons.close();
          spliced_exon_gtf=trimmed_exon_gtf;
        }
        GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
        if (false) {
          System.out.println(""String_Node_Str"");
          ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
        }
        intronic_exon_writer.close();
        System.out.println(""String_Node_Str"");
        double alpha_0=1.0;
        double beta_0=1.0;
        int nb_r=segment.nb_r;
        int r=segment.segment_r;
        double p=segment.segment_p;
        int maxBins=20000;
        int binSize=segment.w;
        int minCP=0;
        int minLength=binSize * 2;
        GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
        boolean internal=segment.internal;
        double min_fold=segment.min_fold;
        int min_terminal=-segment.min_terminal;
        int confidence_interval=0;
        IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal,confidence_interval);
        changepoint_writer.close();
        System.out.println(""String_Node_Str"");
        int sj_radius=binSize * 1;
        GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
        IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
        filtered_changepoint_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
        IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
        changepoint_exon_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
        ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
        assembly_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
        ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
        remainder_writer.close();
        if (segment.coverage) {
          System.out.println(""String_Node_Str"");
          File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
          File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
          GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
          IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
          coverage_gw.close();
          GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
          IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
          coverage_unspliced_gw.close();
        }
        sfr.close();
      }
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateEnumerate(enumerate);
      AssembleCommand assemblyConfiguration=ConfigurationIO.readAssemblyConfiguration(enumerate.assemblyXml);
      File out_dir=assemble.dir;
      File log_file=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_xml=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ConfigurationIO.writeConfiguration(enumerate,configuration_xml);
      PrintStream gtfFile=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
      PrintStream skipped=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemblyConfiguration.dir,assemblyConfiguration.base));
      GTFWriter gw=new GTFWriter(gtfFile);
      splicegraph.ExonSpliceGraph.iterateSpliceIsoforms(assembly_gtf,gw,skipped,enumerate.max_paths);
      gw.close();
      skipped.close();
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateCompare(compare);
      if (!compare.dir.exists())       compare.dir.mkdirs();
      File log_file=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_xml=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      ConfigurationIO.writeConfiguration(compare,configuration_xml);
      AssembleCommand assemblyConfiguration1=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml1);
      AssembleCommand assemblyConfiguration2=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml2);
      Strandedness s1=Strandedness.valueOf(assemblyConfiguration1.strandedness);
      Strandedness s2=Strandedness.valueOf(assemblyConfiguration2.strandedness);
      File spliced_exon_gtf1=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"" + (s1 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      File spliced_exon_gtf2=FileUtils.getFile(assemblyConfiguration2.dir,""String_Node_Str"",assemblyConfiguration2.base + ""String_Node_Str"" + (s2 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      File table=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      File gtf=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      int maxBins=20000;
      int binSize=assemblyConfiguration1.w;
      int minCP=0;
      double alpha_0=1;
      double beta_0=1;
      int nb_r=assemblyConfiguration1.nb_r;
      int r=assemblyConfiguration1.segment_r;
      double p=assemblyConfiguration1.segment_p;
      double min_fold=assemblyConfiguration1.min_fold;
      int confidence_interval=assemblyConfiguration1.c;
      JointSegmentation.performJointSegmentation(assemblyConfiguration1.base,assemblyConfiguration2.base,spliced_exon_gtf1,spliced_exon_gtf2,assemblyConfiguration1.bam,assemblyConfiguration2.bam,table,gtf,s1,s2,maxBins,binSize,minCP,alpha_0,beta_0,nb_r,r,p,min_fold,confidence_interval);
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      CompareCommand compareConfiguration=ConfigurationIO.readCompareConfiguration(diff.compareXml);
      File compareGtf=FileUtils.getFile(compareConfiguration.dir,Util.sprintf(""String_Node_Str"",compareConfiguration.base));
      processing.DiffReference.diff(diff.refGtf,compareGtf);
    }
  }
 catch (  ParameterException e) {
    e.printStackTrace(System.out);
    String command=jc.getParsedCommand();
    if (command != null) {
      jc.usage(command);
    }
 else {
      jc.usage();
    }
  }
}","public static void main(String[] args) throws IOException, JAXBException {
  JCommander jc=new JCommander();
  jc.setProgramName(""String_Node_Str"");
  AssembleCommand assemble=new AssembleCommand();
  SegmentCommand segment=new SegmentCommand();
  CompareCommand compare=new CompareCommand();
  DiffCommand diff=new DiffCommand();
  EnumerateCommand enumerate=new EnumerateCommand();
  HelpCommand help=new HelpCommand();
  jc.addCommand(""String_Node_Str"",assemble);
  jc.addCommand(""String_Node_Str"",segment);
  jc.addCommand(""String_Node_Str"",compare);
  jc.addCommand(""String_Node_Str"",enumerate);
  jc.addCommand(""String_Node_Str"",diff);
  jc.addCommand(""String_Node_Str"",help);
  try {
    jc.parse(args);
    if (jc.getParsedCommand() == null || jc.getParsedCommand().equals(""String_Node_Str"")) {
      jc.usage();
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateAssemble(assemble);
      File out_dir=assemble.dir;
      if (!out_dir.exists())       out_dir.mkdirs();
      File log_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ConfigurationIO.writeConfiguration(assemble,configuration_file);
{
        File bamFile=assemble.bam;
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        logger.info(""String_Node_Str"");
        BEDWriter sj_bw=new BEDWriter(IO.bufferedPrintstream(splice_junction_bed));
        FindSpliceJunctions.tabulateSpliceJunctions(sfr,strandedness,sj_bw);
        sj_bw.close();
        logger.info(""String_Node_Str"");
        GTFWriter counted_sj_gtf=new GTFWriter(IO.bufferedPrintstream(splice_count_gtf));
        FindSpliceJunctions.countJunctionSupportingReads(sfr,strandedness,counted_sj_gtf);
        counted_sj_gtf.close();
        logger.info(""String_Node_Str"");
        BEDWriter seg_bw=new BEDWriter(IO.bufferedPrintstream(segment_bed));
        SlidingWindow.identifyExpressed(sfr,strandedness,1,assemble.threshold,1,seg_bw);
        seg_bw.close();
        if (assemble.insert_size_quantile != null) {
          File matepair_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
          File scaffolded_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
          logger.info(""String_Node_Str"");
          int insert_size=ClusterExpressedSegments.estimateMateInsertSize(sfr,strandedness,segment_bed,assemble.insert_size_quantile);
          logger.info(""String_Node_Str"",assemble.insert_size_quantile,insert_size);
          BEDWriter matepair_bw=new BEDWriter(IO.bufferedPrintstream(matepair_bed));
          ClusterExpressedSegments.identifySpannableRegions(sfr,strandedness,matepair_bw,insert_size);
          matepair_bw.close();
          logger.info(""String_Node_Str"");
          BEDWriter scaffolded_bw=new BEDWriter(IO.bufferedPrintstream(scaffolded_bed));
          ClusterExpressedSegments.scaffoldSpannableRegions(segment_bed,matepair_bed,scaffolded_bw);
          scaffolded_bw.close();
        }
        sfr.close();
      }
{
        File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        File unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())         assembly_gtf.getParentFile().mkdirs();
        File bamFile=assemble.bam;
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File segment_bed=assemble.insert_size_quantile == null ? FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        double jnct_alpha=assemble.jnct_alpha;
        File merged_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File spliced_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File acc_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File rej_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File intronic_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        logger.info(""String_Node_Str"",assemble.merge_radius);
        BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
        File merge_regions=assemble.filled_gap_segments == null ? null : assemble.filled_gap_segments;
        ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,assemble.merge_radius);
        merged_segments.close();
        logger.info(""String_Node_Str"");
        GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
        GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
        FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
        passed_jnct_gw.close();
        failed_jnct_gw.close();
        if (strandedness == Strandedness.unstranded) {
          logger.info(""String_Node_Str"");
          BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
          ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
          inferred_strand_segment.close();
          merged_segment_bed=inferred_strand_segment_bed;
        }
        logger.info(""String_Node_Str"");
        GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
        ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
        spliced_exons.close();
        if (strandedness == Strandedness.unstranded) {
          logger.info(""String_Node_Str"");
          GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
          ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
          trimmed_exons.close();
          spliced_exon_gtf=trimmed_exon_gtf;
        }
        GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
        if (false) {
          System.out.println(""String_Node_Str"");
          ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
        }
        intronic_exon_writer.close();
        logger.info(""String_Node_Str"");
        double alpha_0=1.0;
        double beta_0=1.0;
        int nb_r=assemble.nb_r;
        int r=assemble.segment_r;
        double p=assemble.segment_p;
        int maxBins=20000;
        int binSize=assemble.w;
        int minCP=0;
        int minLength=binSize * 2;
        GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
        boolean internal=assemble.internal;
        double min_fold=assemble.min_fold;
        int min_terminal=-assemble.min_terminal;
        IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
        changepoint_writer.close();
        logger.info(""String_Node_Str"");
        int sj_radius=binSize * 1;
        GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
        IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
        filtered_changepoint_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
        IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
        changepoint_exon_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
        ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
        assembly_writer.close();
        logger.info(""String_Node_Str"");
        GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
        ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
        remainder_writer.close();
        if (assemble.coverage) {
          logger.info(""String_Node_Str"");
          File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
          File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
          GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
          IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
          coverage_gw.close();
          GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
          IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
          coverage_unspliced_gw.close();
        }
        sfr.close();
      }
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
{
        File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        File unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())         assembly_gtf.getParentFile().mkdirs();
        File bamFile=segment.bam;
        File out_dir=new File(segment.dir);
        File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
        if (!tmp_dir.exists())         tmp_dir.mkdirs();
        File splice_junction_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File splice_count_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File segment_bed=!FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"").exists() ? FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        double jnct_alpha=segment.jnct_alpha;
        File merged_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File spliced_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File acc_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File rej_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File intronic_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
        Strandedness strandedness=Strandedness.valueOf(segment.strandedness);
        SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
        SAMFileReader sfr=new SAMFileReader(bamFile);
        System.out.println(""String_Node_Str"");
        BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
        File merge_regions=segment.filled_gap_segments == null ? null : new File(segment.filled_gap_segments);
        ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,segment.merge_radius);
        merged_segments.close();
        System.out.println(""String_Node_Str"");
        GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
        GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
        FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
        passed_jnct_gw.close();
        failed_jnct_gw.close();
        if (strandedness == Strandedness.unstranded) {
          System.out.println(""String_Node_Str"");
          BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
          ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
          inferred_strand_segment.close();
          merged_segment_bed=inferred_strand_segment_bed;
        }
        System.out.println(""String_Node_Str"");
        GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
        ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
        spliced_exons.close();
        if (strandedness == Strandedness.unstranded) {
          System.out.println(""String_Node_Str"");
          GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
          ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
          trimmed_exons.close();
          spliced_exon_gtf=trimmed_exon_gtf;
        }
        GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
        if (false) {
          System.out.println(""String_Node_Str"");
          ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
        }
        intronic_exon_writer.close();
        System.out.println(""String_Node_Str"");
        double alpha_0=1.0;
        double beta_0=1.0;
        int nb_r=segment.nb_r;
        int r=segment.segment_r;
        double p=segment.segment_p;
        int maxBins=20000;
        int binSize=segment.w;
        int minCP=0;
        int minLength=binSize * 2;
        GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
        boolean internal=segment.internal;
        double min_fold=segment.min_fold;
        int min_terminal=-segment.min_terminal;
        int confidence_interval=0;
        IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
        changepoint_writer.close();
        System.out.println(""String_Node_Str"");
        int sj_radius=binSize * 1;
        GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
        IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
        filtered_changepoint_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
        IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
        changepoint_exon_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
        ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
        assembly_writer.close();
        System.out.println(""String_Node_Str"");
        GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
        ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
        remainder_writer.close();
        if (segment.coverage) {
          System.out.println(""String_Node_Str"");
          File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
          File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
          GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
          IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
          coverage_gw.close();
          GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
          IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
          coverage_unspliced_gw.close();
        }
        sfr.close();
      }
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateEnumerate(enumerate);
      AssembleCommand assemblyConfiguration=ConfigurationIO.readAssemblyConfiguration(enumerate.assemblyXml);
      File out_dir=assemble.dir;
      File log_file=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_xml=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
      ConfigurationIO.writeConfiguration(enumerate,configuration_xml);
      PrintStream gtfFile=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
      PrintStream skipped=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemblyConfiguration.dir,assemblyConfiguration.base));
      GTFWriter gw=new GTFWriter(gtfFile);
      splicegraph.ExonSpliceGraph.iterateSpliceIsoforms(assembly_gtf,gw,skipped,enumerate.max_paths);
      gw.close();
      skipped.close();
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      validateCompare(compare);
      if (!compare.dir.exists())       compare.dir.mkdirs();
      File log_file=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      ThreadContext.put(""String_Node_Str"",log_file.getAbsolutePath());
      logger.info(""String_Node_Str"");
      File configuration_xml=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      ConfigurationIO.writeConfiguration(compare,configuration_xml);
      AssembleCommand assemblyConfiguration1=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml1);
      AssembleCommand assemblyConfiguration2=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml2);
      Strandedness s1=Strandedness.valueOf(assemblyConfiguration1.strandedness);
      Strandedness s2=Strandedness.valueOf(assemblyConfiguration2.strandedness);
      File spliced_exon_gtf1=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"" + (s1 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      File spliced_exon_gtf2=FileUtils.getFile(assemblyConfiguration2.dir,""String_Node_Str"",assemblyConfiguration2.base + ""String_Node_Str"" + (s2 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      File table=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      File gtf=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
      int maxBins=20000;
      int binSize=assemblyConfiguration1.w;
      int minCP=0;
      double alpha_0=1;
      double beta_0=1;
      int nb_r=assemblyConfiguration1.nb_r;
      int r=assemblyConfiguration1.segment_r;
      double p=assemblyConfiguration1.segment_p;
      double min_fold=assemblyConfiguration1.min_fold;
      JointSegmentation.performJointSegmentation(assemblyConfiguration1.base,assemblyConfiguration2.base,spliced_exon_gtf1,spliced_exon_gtf2,assemblyConfiguration1.bam,assemblyConfiguration2.bam,table,gtf,s1,s2,maxBins,binSize,minCP,alpha_0,beta_0,nb_r,r,p,min_fold);
      logger.info(""String_Node_Str"");
    }
 else     if (jc.getParsedCommand().equals(""String_Node_Str"")) {
      CompareCommand compareConfiguration=ConfigurationIO.readCompareConfiguration(diff.compareXml);
      File compareGtf=FileUtils.getFile(compareConfiguration.dir,Util.sprintf(""String_Node_Str"",compareConfiguration.base));
      processing.DiffReference.diff(diff.refGtf,compareGtf);
    }
  }
 catch (  ParameterException e) {
    e.printStackTrace(System.out);
    String command=jc.getParsedCommand();
    if (command != null) {
      jc.usage(command);
    }
 else {
      jc.usage();
    }
  }
}",0.9923349579087284
37716,"public static void performJointSegmentation(String id1,String id2,File spliced_exons1,File spliced_exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold,int confidence_interval) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> exons1=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> exons2=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons2),true,true,true);
  logger.info(""String_Node_Str"");
  StrandedGenomicIntervalTree<Map<String,Object>> maxCommonExons=getMaxCommonExons(exons1,exons2,strandedness1,strandedness2);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=IntervalTools.buildTerminiTree(maxCommonExons,true,true,false);
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  logger.info(""String_Node_Str"");
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    AnnotatedRegion u=IntervalTools.BoundaryIntervals(maxCommonExons,region.chr,region.get5Prime(),region.strand,true).iterator().next();
    Map<String,Object> attributes=new HashMap<String,Object>();
    String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
    attributes.put(""String_Node_Str"",locus_ID);
    changepoint_id++;
    gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
    boolean constrained_decreasing=!u.isNegativeStrand();
    List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold,confidence_interval);
    for (    ChangePoint cp : changepoints) {
      AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
      changepoint.addAttribute(""String_Node_Str"",id1);
      changepoint.addAttribute(""String_Node_Str"",id2);
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cp.confidence));
      changepoint.addAttribute(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cp.log_odds));
      changepoint.addAttribute(""String_Node_Str"",locus_ID);
      gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
      double[] usage=new double[sfrs.length];
      for (int i=0; i < sfrs.length; i++) {
        usage[i]=1 - Math.min((cp.cov_downstream[i] / cp.cov_upstream[i]),1);
      }
      tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,Util.sprintf(""String_Node_Str"",cp.confidence),Util.sprintf(""String_Node_Str"",cp.log_odds),cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
    }
  }
  gw.close();
  tabular.close();
}","public static void performJointSegmentation(String id1,String id2,File spliced_exons1,File spliced_exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> exons1=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> exons2=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons2),true,true,true);
  logger.info(""String_Node_Str"");
  StrandedGenomicIntervalTree<Map<String,Object>> maxCommonExons=getMaxCommonExons(exons1,exons2,strandedness1,strandedness2);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=IntervalTools.buildTerminiTree(maxCommonExons,true,true,false);
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  logger.info(""String_Node_Str"");
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    AnnotatedRegion u=IntervalTools.BoundaryIntervals(maxCommonExons,region.chr,region.get5Prime(),region.strand,true).iterator().next();
    Map<String,Object> attributes=new HashMap<String,Object>();
    String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
    attributes.put(""String_Node_Str"",locus_ID);
    changepoint_id++;
    gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
    boolean constrained_decreasing=!u.isNegativeStrand();
    List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold);
    for (    ChangePoint cp : changepoints) {
      AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
      changepoint.addAttribute(""String_Node_Str"",id1);
      changepoint.addAttribute(""String_Node_Str"",id2);
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cp.confidence));
      changepoint.addAttribute(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cp.log_odds));
      changepoint.addAttribute(""String_Node_Str"",locus_ID);
      gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
      double[] usage=new double[sfrs.length];
      for (int i=0; i < sfrs.length; i++) {
        usage[i]=1 - Math.min((cp.cov_downstream[i] / cp.cov_upstream[i]),1);
      }
      tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,Util.sprintf(""String_Node_Str"",cp.confidence),Util.sprintf(""String_Node_Str"",cp.log_odds),cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
    }
  }
  gw.close();
  tabular.close();
}",0.994920341722466
37717,"/** 
 * @param start
 * @param end
 * @return confidence that observation at position start and end are on different segments (the confidence that there is a change point at some position between them)
 */
public ConfidenceResult calculateConfidence(int start,int end){
  double log_probility=Util.logSum(likelihoods.subList(start,end)) - log_q_suffix[0];
  double log_odds=Math.exp(0 - log_probility) - 1 <= 0 ? Double.POSITIVE_INFINITY : log_probility - Util.logSubtract(0,log_probility);
  return new ConfidenceResult(log_probility,log_odds);
}","public ConfidenceResult calculateConfidence(int p){
  double log_probility=likelihoods.get(p) - log_q_suffix[0];
  double log_odds=Math.exp(0 - log_probility) - 1 <= 0 ? Double.POSITIVE_INFINITY : log_probility - Util.logSubtract(0,log_probility);
  return new ConfidenceResult(log_probility,log_odds);
}",0.5898942420681551
37718,"public static List<ChangePoint> identifyConstrainedNegativeBinomialPoints(String[] ids,SAMFileReader[] sfrs,Strandedness[] strandednesses,String chr,int start,int end,int maxBins,int binSize,int minCP,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold,int confidence_interval){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    logger.info(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  List<ChangePoint> changePoints=new ArrayList<ChangePoint>();
  double[][] y=new double[sfrs.length][];
  for (int i=0; i < sfrs.length; i++) {
    int[] cov=BAMTools.binnedMaxEndCoverage(sfrs[i],chr,start,nBins,binSize,false,true,strandednesses[i],isNegativeStrand);
    y[i]=new double[nBins];
    for (int j=0; j < nBins; j++) {
      y[i][j]=cov[j];
    }
  }
  JointSegmentationResult segmentation=IdentifyConstrainedChangePoints.doubly_constrained_multi_segmentation(y,alpha_0,beta_0,nb_r,r,p,constrain_decreasing,min_fold);
  PrefixSuffixResult prefix_suffix=IdentifyConstrainedChangePoints.prefix_suffix(y,alpha_0,beta_0,nb_r,r,p);
  ConfidenceCalculator cc=new ConfidenceCalculator(prefix_suffix);
  if (segmentation.n_segments > 1) {
    double[][] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    List<Integer> positions=new ArrayList<Integer>(segmentation.n_segments);
    List<double[]> before_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<double[]> after_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<Double> confidences=new ArrayList<Double>();
    List<Double> l_odds=new ArrayList<Double>();
    StrandedGenomicIntervalTree<Map<String,Object>> segments=new StrandedGenomicIntervalTree<Map<String,Object>>();
    segments.add(chr,start,end,strand);
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position >= start && position <= end) {
          positions.add(position);
          before_mles.add(segment_mle[i]);
          after_mles.add(segment_mle[i + 1]);
          ConfidenceResult cr=cc.calculateConfidence(Math.max(changepoint_i - confidence_interval,0),Math.min(changepoint_i + 1 + confidence_interval,prefix_suffix.l - 2));
          confidences.add(Math.exp(cr.log_confidence));
          l_odds.add(cr.log_odds);
          SegmentFragmenter.fragment(segments,chr,position,strand,isNegativeStrand);
        }
      }
    }
    List<AnnotatedRegion> slist=new ArrayList<AnnotatedRegion>();
    for (    AnnotatedRegion s : segments) {
      slist.add(s);
    }
    for (int i=0; i < positions.size(); i++) {
      AnnotatedRegion before=slist.get(i);
      AnnotatedRegion after=slist.get(i + 1);
      AnnotatedRegion pos=new AnnotatedRegion(""String_Node_Str"",chr,positions.get(i),positions.get(i),strand);
      double[] before_mle=before_mles.get(i);
      double[] after_mle=after_mles.get(i);
      double confidence=confidences.get(i);
      double log_odds=l_odds.get(i);
      changePoints.add(new ChangePoint(pos,isNegativeStrand ? after : before,!isNegativeStrand ? after : before,ids,isNegativeStrand ? after_mle : before_mle,!isNegativeStrand ? after_mle : before_mle,confidence,log_odds));
    }
  }
  return changePoints;
}","public static List<ChangePoint> identifyConstrainedNegativeBinomialPoints(String[] ids,SAMFileReader[] sfrs,Strandedness[] strandednesses,String chr,int start,int end,int maxBins,int binSize,int minCP,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    logger.info(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  List<ChangePoint> changePoints=new ArrayList<ChangePoint>();
  double[][] y=new double[sfrs.length][];
  for (int i=0; i < sfrs.length; i++) {
    int[] cov=BAMTools.binnedMaxEndCoverage(sfrs[i],chr,start,nBins,binSize,false,true,strandednesses[i],isNegativeStrand);
    y[i]=new double[nBins];
    for (int j=0; j < nBins; j++) {
      y[i][j]=cov[j];
    }
  }
  JointSegmentationResult segmentation=IdentifyConstrainedChangePoints.doubly_constrained_multi_segmentation(y,alpha_0,beta_0,nb_r,r,p,constrain_decreasing,min_fold);
  PrefixSuffixResult prefix_suffix=IdentifyConstrainedChangePoints.prefix_suffix(y,alpha_0,beta_0,nb_r,r,p);
  ConfidenceCalculator cc=new ConfidenceCalculator(prefix_suffix);
  if (segmentation.n_segments > 1) {
    double[][] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    List<Integer> positions=new ArrayList<Integer>(segmentation.n_segments);
    List<double[]> before_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<double[]> after_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<Double> confidences=new ArrayList<Double>();
    List<Double> l_odds=new ArrayList<Double>();
    StrandedGenomicIntervalTree<Map<String,Object>> segments=new StrandedGenomicIntervalTree<Map<String,Object>>();
    segments.add(chr,start,end,strand);
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position >= start && position <= end) {
          positions.add(position);
          before_mles.add(segment_mle[i]);
          after_mles.add(segment_mle[i + 1]);
          ConfidenceResult cr=cc.calculateConfidence(changepoints[i]);
          confidences.add(Math.exp(cr.log_confidence));
          l_odds.add(cr.log_odds);
          SegmentFragmenter.fragment(segments,chr,position,strand,isNegativeStrand);
        }
      }
    }
    List<AnnotatedRegion> slist=new ArrayList<AnnotatedRegion>();
    for (    AnnotatedRegion s : segments) {
      slist.add(s);
    }
    for (int i=0; i < positions.size(); i++) {
      AnnotatedRegion before=slist.get(i);
      AnnotatedRegion after=slist.get(i + 1);
      AnnotatedRegion pos=new AnnotatedRegion(""String_Node_Str"",chr,positions.get(i),positions.get(i),strand);
      double[] before_mle=before_mles.get(i);
      double[] after_mle=after_mles.get(i);
      double confidence=confidences.get(i);
      double log_odds=l_odds.get(i);
      changePoints.add(new ChangePoint(pos,isNegativeStrand ? after : before,!isNegativeStrand ? after : before,ids,isNegativeStrand ? after_mle : before_mle,!isNegativeStrand ? after_mle : before_mle,confidence,log_odds));
    }
  }
  return changePoints;
}",0.9694023448670288
37719,"public static void identifyNegativeBinomialChangePointsInLongSegments(SAMFileReader sfr,File spliced_exon_gtf,File intronic_exon_gtf,GTFWriter changepointWriter,int minLength,int maxBins,int binSize,int minCP,Strandedness strandedness,double alpha_0,double beta_0,int nb_r,int r,double p,boolean internal,double min_fold,int min_terminal,int confidence_interval) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> continuousSegments=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exons=new StrandedGenomicIntervalTree<Map<String,Object>>();
  for (  File gtf : Util.list(spliced_exon_gtf,intronic_exon_gtf)) {
    TranscriptIterator ti=new TranscriptIterator(gtf);
    for (    AnnotatedRegion segment : ti) {
      SegmentFragmenter.add(continuousSegments,segment.chr,segment.start,segment.end,segment.strand);
      exons.add(segment.chr,segment.start,segment.end,segment.strand,segment.attributes);
    }
  }
  for (  AnnotatedRegion segment : continuousSegments) {
    if (segment.size - min_terminal >= minLength) {
      Set<String> annotations=new HashSet<String>();
      for (      AnnotatedRegion exon : exons.overlappingRegions(segment.chr,segment.start,segment.end,segment.strand)) {
        String type=(String)exon.getAttribute(""String_Node_Str"");
        if (type != null) {
          annotations.add(type);
        }
      }
      if (annotations.size() == 1) {
        String type=annotations.iterator().next();
        if (internal && ""String_Node_Str"".equals(type)) {
          identifyUnconstrainedNegativeBinomialPoints(sfr,segment.chr,segment.start,segment.end,maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,min_fold,confidence_interval,changepointWriter);
        }
 else         if (""String_Node_Str"".equals(type)) {
          boolean constrained_decreasing=segment.isNegativeStrand();
          int[] i=IntervalTools.offsetInterval(segment.start,segment.end,-min_terminal,0,segment.isNegativeStrand());
          identifyConstrainedNegativeBinomialPoints(sfr,segment.chr,i[0],i[1],maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold,confidence_interval,changepointWriter);
        }
 else         if (""String_Node_Str"".equals(type)) {
          boolean constrained_decreasing=!segment.isNegativeStrand();
          int[] i=IntervalTools.offsetInterval(segment.start,segment.end,0,-min_terminal,segment.isNegativeStrand());
          identifyConstrainedNegativeBinomialPoints(sfr,segment.chr,i[0],i[1],maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold,confidence_interval,changepointWriter);
        }
      }
    }
  }
}","public static void identifyNegativeBinomialChangePointsInLongSegments(SAMFileReader sfr,File spliced_exon_gtf,File intronic_exon_gtf,GTFWriter changepointWriter,int minLength,int maxBins,int binSize,int minCP,Strandedness strandedness,double alpha_0,double beta_0,int nb_r,int r,double p,boolean internal,double min_fold,int min_terminal) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> continuousSegments=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exons=new StrandedGenomicIntervalTree<Map<String,Object>>();
  for (  File gtf : Util.list(spliced_exon_gtf,intronic_exon_gtf)) {
    TranscriptIterator ti=new TranscriptIterator(gtf);
    for (    AnnotatedRegion segment : ti) {
      SegmentFragmenter.add(continuousSegments,segment.chr,segment.start,segment.end,segment.strand);
      exons.add(segment.chr,segment.start,segment.end,segment.strand,segment.attributes);
    }
  }
  for (  AnnotatedRegion segment : continuousSegments) {
    if (segment.size - min_terminal >= minLength) {
      Set<String> annotations=new HashSet<String>();
      for (      AnnotatedRegion exon : exons.overlappingRegions(segment.chr,segment.start,segment.end,segment.strand)) {
        String type=(String)exon.getAttribute(""String_Node_Str"");
        if (type != null) {
          annotations.add(type);
        }
      }
      if (annotations.size() == 1) {
        String type=annotations.iterator().next();
        if (internal && ""String_Node_Str"".equals(type)) {
          identifyUnconstrainedNegativeBinomialPoints(sfr,segment.chr,segment.start,segment.end,maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,min_fold,changepointWriter);
        }
 else         if (""String_Node_Str"".equals(type)) {
          boolean constrained_decreasing=segment.isNegativeStrand();
          int[] i=IntervalTools.offsetInterval(segment.start,segment.end,-min_terminal,0,segment.isNegativeStrand());
          identifyConstrainedNegativeBinomialPoints(sfr,segment.chr,i[0],i[1],maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold,changepointWriter);
        }
 else         if (""String_Node_Str"".equals(type)) {
          boolean constrained_decreasing=!segment.isNegativeStrand();
          int[] i=IntervalTools.offsetInterval(segment.start,segment.end,0,-min_terminal,segment.isNegativeStrand());
          identifyConstrainedNegativeBinomialPoints(sfr,segment.chr,i[0],i[1],maxBins,binSize,minCP,strandedness,segment.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold,changepointWriter);
        }
      }
    }
  }
}",0.9848046309696092
37720,"public static void identifyUnconstrainedNegativeBinomialPoints(SAMFileReader sfr,String chr,int start,int end,int maxBins,int binSize,int minCP,Strandedness strandedness,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold,int confidence_interval,GTFWriter gw){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  StrandedGenomicIntervalTree<Map<String,Object>> changePoints=new StrandedGenomicIntervalTree<Map<String,Object>>();
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    logger.info(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  int[] cov=BAMTools.binnedMaxEndCoverage(sfr,chr,start,nBins,binSize,false,true,strandedness,isNegativeStrand);
  double[] y=new double[nBins];
  for (int i=0; i < nBins; i++) {
    y[i]=cov[i];
  }
  SegmentationResult segmentation=IdentifyConstrainedChangePoints.fold_constrained_segmentation(y,alpha_0,beta_0,nb_r,r,p,min_fold);
  PrefixSuffixResult prefix_suffix=IdentifyConstrainedChangePoints.prefix_suffix(y,alpha_0,beta_0,nb_r,r,p);
  ConfidenceCalculator cc=new ConfidenceCalculator(prefix_suffix);
  if (segmentation.n_segments > 1) {
    double[] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (segment_mle[i] < segment_mle[i + 1]) {
        changepoint_i++;
      }
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position > start && position < end) {
          Map<String,Object> attributes=new HashMap<String,Object>();
          attributes.put(""String_Node_Str"",segment_mle[i]);
          attributes.put(""String_Node_Str"",segment_mle[i + 1]);
          attributes.put(""String_Node_Str"",""String_Node_Str"");
          ConfidenceResult cr=cc.calculateConfidence(Math.max(changepoint_i - confidence_interval,0),Math.min(changepoint_i + 1 + confidence_interval,prefix_suffix.l - 2));
          attributes.put(""String_Node_Str"",Util.sprintf(""String_Node_Str"",Math.exp(cr.log_confidence)));
          attributes.put(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cr.log_odds));
          changePoints.add(chr,position,position,strand,attributes);
          gw.write(""String_Node_Str"",chr,position,position,strand,AnnotatedRegion.GTFAttributeString(attributes));
        }
      }
    }
  }
}","public static void identifyUnconstrainedNegativeBinomialPoints(SAMFileReader sfr,String chr,int start,int end,int maxBins,int binSize,int minCP,Strandedness strandedness,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold,GTFWriter gw){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  StrandedGenomicIntervalTree<Map<String,Object>> changePoints=new StrandedGenomicIntervalTree<Map<String,Object>>();
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    logger.info(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  int[] cov=BAMTools.binnedMaxEndCoverage(sfr,chr,start,nBins,binSize,false,true,strandedness,isNegativeStrand);
  double[] y=new double[nBins];
  for (int i=0; i < nBins; i++) {
    y[i]=cov[i];
  }
  SegmentationResult segmentation=IdentifyConstrainedChangePoints.fold_constrained_segmentation(y,alpha_0,beta_0,nb_r,r,p,min_fold);
  PrefixSuffixResult prefix_suffix=IdentifyConstrainedChangePoints.prefix_suffix(y,alpha_0,beta_0,nb_r,r,p);
  ConfidenceCalculator cc=new ConfidenceCalculator(prefix_suffix);
  if (segmentation.n_segments > 1) {
    double[] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (segment_mle[i] < segment_mle[i + 1]) {
        changepoint_i++;
      }
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position > start && position < end) {
          Map<String,Object> attributes=new HashMap<String,Object>();
          attributes.put(""String_Node_Str"",segment_mle[i]);
          attributes.put(""String_Node_Str"",segment_mle[i + 1]);
          attributes.put(""String_Node_Str"",""String_Node_Str"");
          ConfidenceResult cr=cc.calculateConfidence(changepoints[i]);
          attributes.put(""String_Node_Str"",Util.sprintf(""String_Node_Str"",Math.exp(cr.log_confidence)));
          attributes.put(""String_Node_Str"",Util.sprintf(""String_Node_Str"",cr.log_odds));
          changePoints.add(chr,position,position,strand,attributes);
          gw.write(""String_Node_Str"",chr,position,position,strand,AnnotatedRegion.GTFAttributeString(attributes));
        }
      }
    }
  }
}",0.9685102947113444
37721,"public static void main(String[] args) throws IOException, JAXBException {
  JCommander jc=new JCommander();
  jc.setProgramName(""String_Node_Str"");
  AssembleCommand assemble=new AssembleCommand();
  SegmentCommand segment=new SegmentCommand();
  CompareCommand compare=new CompareCommand();
  EnumerateCommand enumerate=new EnumerateCommand();
  HelpCommand help=new HelpCommand();
  jc.addCommand(""String_Node_Str"",assemble);
  jc.addCommand(""String_Node_Str"",segment);
  jc.addCommand(""String_Node_Str"",compare);
  jc.addCommand(""String_Node_Str"",enumerate);
  jc.addCommand(""String_Node_Str"",help);
  jc.parse(args);
  if (jc.getParsedCommand() == null || jc.getParsedCommand().equals(""String_Node_Str"")) {
    jc.usage();
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    File out_dir=assemble.dir;
    if (!out_dir.exists())     out_dir.mkdirs();
    File configuration_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
    ConfigurationIO.writeConfiguration(assemble,configuration_file);
{
      File bamFile=assemble.bam;
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter sj_bw=new BEDWriter(IO.bufferedPrintstream(splice_junction_bed));
      FindSpliceJunctions.tabulateSpliceJunctions(sfr,sj_bw);
      sj_bw.close();
      System.out.println(""String_Node_Str"");
      GTFWriter counted_sj_gtf=new GTFWriter(IO.bufferedPrintstream(splice_count_gtf));
      FindSpliceJunctions.countJunctionSupportingReads(sfr,strandedness,splice_junction_bed,counted_sj_gtf);
      counted_sj_gtf.close();
      System.out.println(""String_Node_Str"");
      BEDWriter seg_bw=new BEDWriter(IO.bufferedPrintstream(segment_bed));
      SlidingWindow.identifyExpressed(sfr,strandedness,1,assemble.threshold,1,seg_bw);
      seg_bw.close();
      if (assemble.insert_size_quantile != null) {
        File matepair_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File scaffolded_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        int insert_size=ClusterExpressedSegments.estimateMateInsertSize(sfr,strandedness,segment_bed,assemble.insert_size_quantile);
        System.out.printf(""String_Node_Str"",assemble.insert_size_quantile,insert_size);
        System.out.println(""String_Node_Str"");
        BEDWriter matepair_bw=new BEDWriter(IO.bufferedPrintstream(matepair_bed));
        ClusterExpressedSegments.identifySpannableRegions(sfr,strandedness,matepair_bw,insert_size);
        matepair_bw.close();
        System.out.println(""String_Node_Str"");
        BEDWriter scaffolded_bw=new BEDWriter(IO.bufferedPrintstream(scaffolded_bed));
        ClusterExpressedSegments.scaffoldSpannableRegions(segment_bed,matepair_bed,scaffolded_bw);
        scaffolded_bw.close();
      }
      sfr.close();
    }
{
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
      File unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
      if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())       assembly_gtf.getParentFile().mkdirs();
      File bamFile=assemble.bam;
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File segment_bed=assemble.insert_size_quantile == null ? FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      double jnct_alpha=assemble.jnct_alpha;
      File merged_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File spliced_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File acc_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File rej_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File intronic_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
      File merge_regions=assemble.filled_gap_segments == null ? null : new File(assemble.filled_gap_segments);
      ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,assemble.merge_radius);
      merged_segments.close();
      System.out.println(""String_Node_Str"");
      GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
      GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
      FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
      passed_jnct_gw.close();
      failed_jnct_gw.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
        ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
        inferred_strand_segment.close();
        merged_segment_bed=inferred_strand_segment_bed;
      }
      System.out.println(""String_Node_Str"");
      GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
      ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
      spliced_exons.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
        ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
        trimmed_exons.close();
        spliced_exon_gtf=trimmed_exon_gtf;
      }
      GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
      if (false) {
        System.out.println(""String_Node_Str"");
        ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
      }
      intronic_exon_writer.close();
      System.out.println(""String_Node_Str"");
      double alpha_0=1.0;
      double beta_0=1.0;
      int nb_r=assemble.nb_r;
      int r=assemble.segment_r;
      double p=assemble.segment_p;
      int maxBins=20000;
      int binSize=assemble.w;
      int minCP=0;
      int minLength=binSize * 2;
      GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
      boolean internal=assemble.internal;
      double min_fold=assemble.min_fold;
      int min_terminal=-assemble.min_terminal;
      IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
      changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      int sj_radius=binSize * 1;
      GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
      IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
      filtered_changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
      IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
      changepoint_exon_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
      ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
      assembly_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
      ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
      remainder_writer.close();
      if (assemble.coverage) {
        System.out.println(""String_Node_Str"");
        File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
        IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
        coverage_gw.close();
        GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
        IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
        coverage_unspliced_gw.close();
      }
      sfr.close();
    }
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
{
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
      File unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
      if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())       assembly_gtf.getParentFile().mkdirs();
      File bamFile=segment.bam;
      File out_dir=new File(segment.dir);
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File segment_bed=!FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"").exists() ? FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      double jnct_alpha=segment.jnct_alpha;
      File merged_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File spliced_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File acc_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File rej_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File intronic_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(segment.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
      File merge_regions=segment.filled_gap_segments == null ? null : new File(segment.filled_gap_segments);
      ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,segment.merge_radius);
      merged_segments.close();
      System.out.println(""String_Node_Str"");
      GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
      GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
      FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
      passed_jnct_gw.close();
      failed_jnct_gw.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
        ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
        inferred_strand_segment.close();
        merged_segment_bed=inferred_strand_segment_bed;
      }
      System.out.println(""String_Node_Str"");
      GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
      ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
      spliced_exons.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
        ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
        trimmed_exons.close();
        spliced_exon_gtf=trimmed_exon_gtf;
      }
      GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
      if (false) {
        System.out.println(""String_Node_Str"");
        ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
      }
      intronic_exon_writer.close();
      System.out.println(""String_Node_Str"");
      double alpha_0=1.0;
      double beta_0=1.0;
      int nb_r=segment.nb_r;
      int r=segment.segment_r;
      double p=segment.segment_p;
      int maxBins=20000;
      int binSize=segment.w;
      int minCP=0;
      int minLength=binSize * 2;
      GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
      boolean internal=segment.internal;
      double min_fold=segment.min_fold;
      int min_terminal=-segment.min_terminal;
      IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
      changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      int sj_radius=binSize * 1;
      GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
      IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
      filtered_changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
      IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
      changepoint_exon_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
      ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
      assembly_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
      ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
      remainder_writer.close();
      if (segment.coverage) {
        System.out.println(""String_Node_Str"");
        File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
        IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
        coverage_gw.close();
        GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
        IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
        coverage_unspliced_gw.close();
      }
      sfr.close();
    }
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    AssembleCommand assemblyConfiguration=ConfigurationIO.readAssemblyConfiguration(enumerate.assemblyXml);
    File out_dir=assemble.dir;
    File configuration_xml=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
    ConfigurationIO.writeConfiguration(enumerate,configuration_xml);
    PrintStream gtfFile=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
    PrintStream skipped=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
    File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemblyConfiguration.dir,assemblyConfiguration.base));
    GTFWriter gw=new GTFWriter(gtfFile);
    splicegraph.ExonSpliceGraph.iterateSpliceIsoforms(assembly_gtf,gw,skipped,enumerate.max_paths);
    gw.close();
    skipped.close();
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    if (!compare.dir.exists())     compare.dir.mkdirs();
    File configuration_xml=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    ConfigurationIO.writeConfiguration(compare,configuration_xml);
    AssembleCommand assemblyConfiguration1=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml1);
    AssembleCommand assemblyConfiguration2=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml2);
    File spliced_exon_gtf1=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"");
    File spliced_exon_gtf2=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"");
    File table=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    File gtf=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    int maxBins=20000;
    int binSize=assemblyConfiguration1.w;
    int minCP=0;
    double alpha_0=1;
    double beta_0=1;
    int nb_r=assemblyConfiguration1.nb_r;
    int r=assemblyConfiguration1.segment_r;
    double p=assemblyConfiguration1.segment_p;
    double min_fold=assemblyConfiguration1.min_fold;
    JointSegmentation.performJointSegmentation(assemblyConfiguration1.base,assemblyConfiguration2.base,spliced_exon_gtf1,spliced_exon_gtf2,assemblyConfiguration1.bam,assemblyConfiguration2.bam,table,gtf,Strandedness.valueOf(assemblyConfiguration1.strandedness),Strandedness.valueOf(assemblyConfiguration2.strandedness),maxBins,binSize,minCP,alpha_0,beta_0,nb_r,r,p,min_fold);
  }
}","public static void main(String[] args) throws IOException, JAXBException {
  JCommander jc=new JCommander();
  jc.setProgramName(""String_Node_Str"");
  AssembleCommand assemble=new AssembleCommand();
  SegmentCommand segment=new SegmentCommand();
  CompareCommand compare=new CompareCommand();
  EnumerateCommand enumerate=new EnumerateCommand();
  HelpCommand help=new HelpCommand();
  jc.addCommand(""String_Node_Str"",assemble);
  jc.addCommand(""String_Node_Str"",segment);
  jc.addCommand(""String_Node_Str"",compare);
  jc.addCommand(""String_Node_Str"",enumerate);
  jc.addCommand(""String_Node_Str"",help);
  jc.parse(args);
  if (jc.getParsedCommand() == null || jc.getParsedCommand().equals(""String_Node_Str"")) {
    jc.usage();
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    File out_dir=assemble.dir;
    if (!out_dir.exists())     out_dir.mkdirs();
    File configuration_file=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
    ConfigurationIO.writeConfiguration(assemble,configuration_file);
{
      File bamFile=assemble.bam;
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter sj_bw=new BEDWriter(IO.bufferedPrintstream(splice_junction_bed));
      FindSpliceJunctions.tabulateSpliceJunctions(sfr,sj_bw);
      sj_bw.close();
      System.out.println(""String_Node_Str"");
      GTFWriter counted_sj_gtf=new GTFWriter(IO.bufferedPrintstream(splice_count_gtf));
      FindSpliceJunctions.countJunctionSupportingReads(sfr,strandedness,splice_junction_bed,counted_sj_gtf);
      counted_sj_gtf.close();
      System.out.println(""String_Node_Str"");
      BEDWriter seg_bw=new BEDWriter(IO.bufferedPrintstream(segment_bed));
      SlidingWindow.identifyExpressed(sfr,strandedness,1,assemble.threshold,1,seg_bw);
      seg_bw.close();
      if (assemble.insert_size_quantile != null) {
        File matepair_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        File scaffolded_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        int insert_size=ClusterExpressedSegments.estimateMateInsertSize(sfr,strandedness,segment_bed,assemble.insert_size_quantile);
        System.out.printf(""String_Node_Str"",assemble.insert_size_quantile,insert_size);
        System.out.println(""String_Node_Str"");
        BEDWriter matepair_bw=new BEDWriter(IO.bufferedPrintstream(matepair_bed));
        ClusterExpressedSegments.identifySpannableRegions(sfr,strandedness,matepair_bw,insert_size);
        matepair_bw.close();
        System.out.println(""String_Node_Str"");
        BEDWriter scaffolded_bw=new BEDWriter(IO.bufferedPrintstream(scaffolded_bed));
        ClusterExpressedSegments.scaffoldSpannableRegions(segment_bed,matepair_bed,scaffolded_bw);
        scaffolded_bw.close();
      }
      sfr.close();
    }
{
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
      File unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
      if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())       assembly_gtf.getParentFile().mkdirs();
      File bamFile=assemble.bam;
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File segment_bed=assemble.insert_size_quantile == null ? FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      double jnct_alpha=assemble.jnct_alpha;
      File merged_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File spliced_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File acc_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File rej_jnct_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File intronic_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,assemble.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(assemble.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
      File merge_regions=assemble.filled_gap_segments == null ? null : new File(assemble.filled_gap_segments);
      ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,assemble.merge_radius);
      merged_segments.close();
      System.out.println(""String_Node_Str"");
      GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
      GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
      FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
      passed_jnct_gw.close();
      failed_jnct_gw.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
        ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
        inferred_strand_segment.close();
        merged_segment_bed=inferred_strand_segment_bed;
      }
      System.out.println(""String_Node_Str"");
      GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
      ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
      spliced_exons.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
        ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
        trimmed_exons.close();
        spliced_exon_gtf=trimmed_exon_gtf;
      }
      GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
      if (false) {
        System.out.println(""String_Node_Str"");
        ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
      }
      intronic_exon_writer.close();
      System.out.println(""String_Node_Str"");
      double alpha_0=1.0;
      double beta_0=1.0;
      int nb_r=assemble.nb_r;
      int r=assemble.segment_r;
      double p=assemble.segment_p;
      int maxBins=20000;
      int binSize=assemble.w;
      int minCP=0;
      int minLength=binSize * 2;
      GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
      boolean internal=assemble.internal;
      double min_fold=assemble.min_fold;
      int min_terminal=-assemble.min_terminal;
      IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
      changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      int sj_radius=binSize * 1;
      GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
      IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
      filtered_changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
      IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
      changepoint_exon_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
      ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
      assembly_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
      ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
      remainder_writer.close();
      if (assemble.coverage) {
        System.out.println(""String_Node_Str"");
        File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",assemble.dir,assemble.base));
        GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
        IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
        coverage_gw.close();
        GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
        IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
        coverage_unspliced_gw.close();
      }
      sfr.close();
    }
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
{
      File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
      File unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
      if (assembly_gtf.getParentFile() != null && !assembly_gtf.getParentFile().exists())       assembly_gtf.getParentFile().mkdirs();
      File bamFile=segment.bam;
      File out_dir=new File(segment.dir);
      File tmp_dir=FileUtils.getFile(out_dir,""String_Node_Str"");
      if (!tmp_dir.exists())       tmp_dir.mkdirs();
      File splice_junction_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File splice_count_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File segment_bed=!FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"").exists() ? FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"") : FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      double jnct_alpha=segment.jnct_alpha;
      File merged_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File inferred_strand_segment_bed=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File spliced_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File acc_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File rej_jnct_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File trimmed_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File intronic_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File filtered_changepoint_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      File changepoint_exon_gtf=FileUtils.getFile(tmp_dir,segment.base + ""String_Node_Str"");
      Strandedness strandedness=Strandedness.valueOf(segment.strandedness);
      SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
      SAMFileReader sfr=new SAMFileReader(bamFile);
      System.out.println(""String_Node_Str"");
      BEDWriter merged_segments=new BEDWriter(IO.bufferedPrintstream(merged_segment_bed));
      File merge_regions=segment.filled_gap_segments == null ? null : new File(segment.filled_gap_segments);
      ClusterExpressedSegments.mergeSegments(segment_bed,merge_regions,merged_segments,segment.merge_radius);
      merged_segments.close();
      System.out.println(""String_Node_Str"");
      GTFWriter passed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(acc_jnct_gtf));
      GTFWriter failed_jnct_gw=new GTFWriter(IO.bufferedPrintstream(rej_jnct_gtf));
      FindSpliceJunctions.filterCountedJunctions(splice_junction_bed,splice_count_gtf,jnct_alpha,passed_jnct_gw,failed_jnct_gw);
      passed_jnct_gw.close();
      failed_jnct_gw.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        BEDWriter inferred_strand_segment=new BEDWriter(IO.bufferedPrintstream(inferred_strand_segment_bed));
        ClusterExpressedSegments.inferSegmentStrand(acc_jnct_gtf,merged_segment_bed,inferred_strand_segment);
        inferred_strand_segment.close();
        merged_segment_bed=inferred_strand_segment_bed;
      }
      System.out.println(""String_Node_Str"");
      GTFWriter spliced_exons=new GTFWriter(IO.bufferedPrintstream(spliced_exon_gtf));
      ClusterExpressedSegments.identifySplicedExons(acc_jnct_gtf,merged_segment_bed,spliced_exons);
      spliced_exons.close();
      if (strandedness == Strandedness.unstranded) {
        System.out.println(""String_Node_Str"");
        GTFWriter trimmed_exons=new GTFWriter(IO.bufferedPrintstream(trimmed_exon_gtf));
        ClusterExpressedSegments.trimInferredExons(spliced_exon_gtf,trimmed_exons);
        trimmed_exons.close();
        spliced_exon_gtf=trimmed_exon_gtf;
      }
      GTFWriter intronic_exon_writer=new GTFWriter(IO.bufferedPrintstream(intronic_exon_gtf));
      if (false) {
        System.out.println(""String_Node_Str"");
        ClusterExpressedSegments.identifyIntronicExons(merged_segment_bed,acc_jnct_gtf,spliced_exon_gtf,sfr,strandedness,intronic_exon_writer,10,.2);
      }
      intronic_exon_writer.close();
      System.out.println(""String_Node_Str"");
      double alpha_0=1.0;
      double beta_0=1.0;
      int nb_r=segment.nb_r;
      int r=segment.segment_r;
      double p=segment.segment_p;
      int maxBins=20000;
      int binSize=segment.w;
      int minCP=0;
      int minLength=binSize * 2;
      GTFWriter changepoint_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_gtf));
      boolean internal=segment.internal;
      double min_fold=segment.min_fold;
      int min_terminal=-segment.min_terminal;
      IdentifyChangePoints.identifyNegativeBinomialChangePointsInLongSegments(sfr,spliced_exon_gtf,intronic_exon_gtf,changepoint_writer,minLength,maxBins,binSize,minCP,strandedness,alpha_0,beta_0,nb_r,r,p,internal,min_fold,min_terminal);
      changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      int sj_radius=binSize * 1;
      GTFWriter filtered_changepoint_writer=new GTFWriter(IO.bufferedPrintstream(filtered_changepoint_gtf));
      IdentifyChangePoints.filterChangePoints(sfr,spliced_exon_gtf,intronic_exon_gtf,acc_jnct_gtf,changepoint_gtf,filtered_changepoint_writer,sj_radius);
      filtered_changepoint_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter changepoint_exon_writer=new GTFWriter(IO.bufferedPrintstream(changepoint_exon_gtf));
      IdentifyChangePoints.enumerateChangepointExons(spliced_exon_gtf,intronic_exon_gtf,filtered_changepoint_gtf,changepoint_exon_writer);
      changepoint_exon_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter assembly_writer=new GTFWriter(IO.bufferedPrintstream(assembly_gtf));
      ExonSpliceGraph.labelConnectedComponents(acc_jnct_gtf,spliced_exon_gtf,intronic_exon_gtf,changepoint_exon_gtf,assembly_writer);
      assembly_writer.close();
      System.out.println(""String_Node_Str"");
      GTFWriter remainder_writer=new GTFWriter(IO.bufferedPrintstream(unspliced));
      ClusterExpressedSegments.writeUnsplicedRemainder(merged_segment_bed,assembly_gtf,remainder_writer);
      remainder_writer.close();
      if (segment.coverage) {
        System.out.println(""String_Node_Str"");
        File coverage_gtf=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        File coverage_unspliced=new File(Util.sprintf(""String_Node_Str"",segment.dir,segment.base));
        GTFWriter coverage_gw=new GTFWriter(IO.bufferedPrintstream(coverage_gtf));
        IdentifyChangePoints.calculate_spliced_coverage(sfr,assembly_gtf,strandedness,coverage_gw);
        coverage_gw.close();
        GTFWriter coverage_unspliced_gw=new GTFWriter(IO.bufferedPrintstream(coverage_unspliced));
        IdentifyChangePoints.calculate_coverage(sfr,unspliced,strandedness,coverage_unspliced_gw);
        coverage_unspliced_gw.close();
      }
      sfr.close();
    }
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    AssembleCommand assemblyConfiguration=ConfigurationIO.readAssemblyConfiguration(enumerate.assemblyXml);
    File out_dir=assemble.dir;
    File configuration_xml=FileUtils.getFile(out_dir,Util.sprintf(""String_Node_Str"",assemble.base));
    ConfigurationIO.writeConfiguration(enumerate,configuration_xml);
    PrintStream gtfFile=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
    PrintStream skipped=IO.bufferedPrintstream(FileUtils.getFile(assemblyConfiguration.dir,Util.sprintf(""String_Node_Str"",assemblyConfiguration.base)));
    File assembly_gtf=new File(Util.sprintf(""String_Node_Str"",assemblyConfiguration.dir,assemblyConfiguration.base));
    GTFWriter gw=new GTFWriter(gtfFile);
    splicegraph.ExonSpliceGraph.iterateSpliceIsoforms(assembly_gtf,gw,skipped,enumerate.max_paths);
    gw.close();
    skipped.close();
  }
 else   if (jc.getParsedCommand().equals(""String_Node_Str"")) {
    if (!compare.dir.exists())     compare.dir.mkdirs();
    File configuration_xml=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    ConfigurationIO.writeConfiguration(compare,configuration_xml);
    AssembleCommand assemblyConfiguration1=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml1);
    AssembleCommand assemblyConfiguration2=ConfigurationIO.readAssemblyConfiguration(compare.assemblyXml2);
    Strandedness s1=Strandedness.valueOf(assemblyConfiguration1.strandedness);
    Strandedness s2=Strandedness.valueOf(assemblyConfiguration2.strandedness);
    File spliced_exon_gtf1=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"" + (s1 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    File spliced_exon_gtf2=FileUtils.getFile(assemblyConfiguration1.dir,""String_Node_Str"",assemblyConfiguration1.base + ""String_Node_Str"" + (s2 == Strandedness.unstranded ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    File table=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    File gtf=FileUtils.getFile(compare.dir,Util.sprintf(""String_Node_Str"",compare.base));
    int maxBins=20000;
    int binSize=assemblyConfiguration1.w;
    int minCP=0;
    double alpha_0=1;
    double beta_0=1;
    int nb_r=assemblyConfiguration1.nb_r;
    int r=assemblyConfiguration1.segment_r;
    double p=assemblyConfiguration1.segment_p;
    double min_fold=assemblyConfiguration1.min_fold;
    JointSegmentation.performJointSegmentation(assemblyConfiguration1.base,assemblyConfiguration2.base,spliced_exon_gtf1,spliced_exon_gtf2,assemblyConfiguration1.bam,assemblyConfiguration2.bam,table,gtf,s1,s2,maxBins,binSize,minCP,alpha_0,beta_0,nb_r,r,p,min_fold);
  }
}",0.9854944624130156
37722,"public static void performJointSegmentation(String id1,String id2,File exons1,File exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> isoscm1=IntervalTools.buildRegionsTree(new TranscriptIterator(exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> isoscm2=IntervalTools.buildRegionsTree(new TranscriptIterator(exons2),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  for (  StrandedGenomicIntervalTree<Map<String,Object>> isoscm : Util.list(isoscm1,isoscm2)) {
    for (    AnnotatedRegion exon : isoscm) {
      if (""String_Node_Str"".equals(exon.getAttribute(""String_Node_Str""))) {
        if (!t5p.contains(exon.chr,exon.get5Prime(),exon.get5Prime(),exon.strand))         t5p.add(exon.chr,exon.get5Prime(),exon.get5Prime(),exon.strand);
      }
    }
  }
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    List<AnnotatedRegion> iso_ends1=IntervalTools.BoundaryIntervals(isoscm1,region.chr,region.get5Prime(),region.strand,true);
    List<AnnotatedRegion> iso_ends2=IntervalTools.BoundaryIntervals(isoscm2,region.chr,region.get5Prime(),region.strand,true);
    for (    List<AnnotatedRegion> i : Util.list(iso_ends1,iso_ends2)) {
      Iterator<AnnotatedRegion> it=i.iterator();
      while (it.hasNext()) {
        AnnotatedRegion n=it.next();
        if (!""String_Node_Str"".equals(n.getAttribute(""String_Node_Str"")))         it.remove();
      }
    }
    if (iso_ends1.size() > 0 && iso_ends2.size() > 0) {
      StrandedGenomicIntervalSet union=IntervalTools.buildStrandedIntervalSet(iso_ends1);
      IntervalTools.addRegions(union,iso_ends2);
      for (      AnnotatedRegion u : union) {
        Map<String,Object> attributes=new HashMap<String,Object>();
        String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
        attributes.put(""String_Node_Str"",locus_ID);
        changepoint_id++;
        gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
        boolean constrained_decreasing=!u.isNegativeStrand();
        List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold);
        for (        ChangePoint cp : changepoints) {
          AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
          changepoint.addAttribute(""String_Node_Str"",id1);
          changepoint.addAttribute(""String_Node_Str"",id2);
          changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
          changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
          changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
          changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
          changepoint.addAttribute(""String_Node_Str"",locus_ID);
          gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
          double[] usage=new double[sfrs.length];
          for (int i=0; i < sfrs.length; i++) {
            usage[i]=1 - (cp.cov_downstream[i] / cp.cov_upstream[i]);
          }
          tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
        }
      }
    }
  }
  gw.close();
  tabular.close();
}","public static void performJointSegmentation(String id1,String id2,File spliced_exons1,File spliced_exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> exons1=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> exons2=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons2),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> maxCommonExons=getMaxCommonExons(exons1,exons2,strandedness1,strandedness2);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=IntervalTools.buildTerminiTree(maxCommonExons,true,true,false);
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    AnnotatedRegion u=IntervalTools.BoundaryIntervals(maxCommonExons,region.chr,region.get5Prime(),region.strand,true).iterator().next();
    Map<String,Object> attributes=new HashMap<String,Object>();
    String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
    attributes.put(""String_Node_Str"",locus_ID);
    changepoint_id++;
    gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
    boolean constrained_decreasing=!u.isNegativeStrand();
    List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold);
    for (    ChangePoint cp : changepoints) {
      AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
      changepoint.addAttribute(""String_Node_Str"",id1);
      changepoint.addAttribute(""String_Node_Str"",id2);
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",locus_ID);
      gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
      double[] usage=new double[sfrs.length];
      for (int i=0; i < sfrs.length; i++) {
        usage[i]=1 - (cp.cov_downstream[i] / cp.cov_upstream[i]);
      }
      tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
    }
  }
  gw.close();
  tabular.close();
}",0.8309123921924648
37723,"public static SegmentationResult viterbi_segmentation(double[][] y,double alpha_0,double beta_0,int nb_r,int r,double p,int m){
  @SuppressWarnings(""String_Node_Str"") ExtremeObjectTracker<Integer,Double>[][] map_j=new ExtremeObjectTracker[m + 1][y[0].length];
  SCMResult[] results=new SCMResult[y.length];
  for (int i=0; i < y.length; i++) {
    results[i]=calculate_segment_probabilities(y[i],alpha_0,beta_0,nb_r);
  }
  int n=y[0].length;
  double[][] log_q_j=new double[m + 1][n];
  double[] log_g=new double[n];
  double[] log_G=new double[n];
  double[] g0=new double[n];
  double[] G0=new double[n];
  log_G[0]=Double.NEGATIVE_INFINITY;
  for (int i=0; i < n; i++) {
    for (int j=0; j < m + 1; j++) {
      map_j[j][i]=new ExtremeObjectTracker<Integer,Double>(new Util.ComparableComparator<Double>());
    }
    log_g[i]=log_nb(i + 1,r,p);
    if (i > 0)     log_G[i]=log_G[i - 1];
    log_G[i]+=Util.logSum(Util.list(log_G[i],log_g[i]));
  }
{
    int j=m + 1 - 1;
    for (int t=n - 1; t > j - 1; t--) {
      int s=n - 1;
      double log_p_t_s=0;
      for (int i=0; i < results.length; i++) {
        log_p_t_s+=results[i].log_p[t][s];
      }
      log_q_j[j][t]=log_p_t_s + Math.log(1 - Math.exp(log_G[s - t + 1]));
      map_j[j][t].put(s + 1,log_p_t_s + Math.log(1 - Math.exp(log_G[s - t + 1])));
    }
  }
  for (int j=m + 1 - 2; j > -1; j--) {
    for (int t=n - m - 1 + j; t > j - 1; t--) {
      List<Double> log_probs=new LinkedList<Double>();
      for (int s=t; s < n - m - 1 + j + 1; s++) {
        double log_p_t_s=0;
        for (int i=0; i < results.length; i++) {
          log_p_t_s+=results[i].log_p[t][s];
        }
        log_probs.add(log_p_t_s + log_q_j[j + 1][s + 1] + log_g[s - t + 1]);
        map_j[j][t].put(s + 1,log_p_t_s + map_j[j + 1][s + 1].getExtremeValue() + log_g[s - t + 1]);
      }
      log_q_j[j][t]=Util.logSum(log_probs);
    }
  }
  MapList<String,Double[]> dat=new MapList<String,Double[]>();
  try {
    for (int i=0; i < n; i++) {
      int previousChangePoint=-1;
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[1][i + 1]+ log_g[i - previousChangePoint] - log_q_j[0][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    int previousChangePoint=68;
    for (int i=previousChangePoint; i < n; i++) {
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[2][i + 1]+ log_g[i - previousChangePoint] - log_q_j[1][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    int previousChangePoint=241;
    for (int i=previousChangePoint; i < n; i++) {
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[3][i + 1]+ log_g[i - previousChangePoint] - log_q_j[2][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  List<Integer> mapCPs=new LinkedList<Integer>();
  List<Double> mapMLEs=new LinkedList<Double>();
  List<Double> mapLs=new LinkedList<Double>();
  int first=0;
  int j=0;
  int last=map_j[j][0].getExtreme();
  j++;
  while (j < m + 1) {
    mapCPs.add(last - 1);
    first=last;
    last=map_j[j][last].getExtreme();
    j++;
  }
  SegmentationResult segmentation=new SegmentationResult(ArrayUtils.toPrimitive(mapCPs.toArray(new Integer[0])),ArrayUtils.toPrimitive(mapMLEs.toArray(new Double[0])),ArrayUtils.toPrimitive(mapLs.toArray(new Double[0])),n);
  return segmentation;
}","public static SegmentationResult viterbi_segmentation(double[][] y,double alpha_0,double beta_0,int nb_r,int r,double p,int m){
  @SuppressWarnings(""String_Node_Str"") ExtremeObjectTracker<Integer,Double>[][] map_j=new ExtremeObjectTracker[m + 1][y[0].length];
  SCMResult[] results=new SCMResult[y.length];
  for (int i=0; i < y.length; i++) {
    results[i]=calculate_segment_probabilities(y[i],alpha_0,beta_0,nb_r);
  }
  int n=y[0].length;
  double[][] log_q_j=new double[m + 1][n];
  double[] log_g=new double[n];
  double[] log_G=new double[n];
  double[] g0=new double[n];
  double[] G0=new double[n];
  log_G[0]=Double.NEGATIVE_INFINITY;
  for (int i=0; i < n; i++) {
    for (int j=0; j < m + 1; j++) {
      map_j[j][i]=new ExtremeObjectTracker<Integer,Double>(new Util.ComparableComparator<Double>());
    }
    log_g[i]=log_nb(i + 1,r,p);
    if (i > 0)     log_G[i]=log_G[i - 1];
    log_G[i]+=Util.logSum(Util.list(log_G[i],log_g[i]));
  }
{
    int j=m + 1 - 1;
    for (int t=n - 1; t > j - 1; t--) {
      int s=n - 1;
      double log_p_t_s=0;
      for (int i=0; i < results.length; i++) {
        log_p_t_s+=results[i].log_p[t][s];
      }
      log_q_j[j][t]=log_p_t_s + Math.log(1 - Math.exp(log_G[s - t + 1]));
      map_j[j][t].put(s + 1,log_p_t_s + Math.log(1 - Math.exp(log_G[s - t + 1])));
    }
  }
  for (int j=m + 1 - 2; j > -1; j--) {
    for (int t=n - m - 1 + j; t > j - 1; t--) {
      List<Double> log_probs=new ArrayList<Double>();
      for (int s=t; s < n - m - 1 + j + 1; s++) {
        double log_p_t_s=0;
        for (int i=0; i < results.length; i++) {
          log_p_t_s+=results[i].log_p[t][s];
        }
        log_probs.add(log_p_t_s + log_q_j[j + 1][s + 1] + log_g[s - t + 1]);
        map_j[j][t].put(s + 1,log_p_t_s + map_j[j + 1][s + 1].getExtremeValue() + log_g[s - t + 1]);
      }
      log_q_j[j][t]=Util.logSum(log_probs);
    }
  }
  MapList<String,Double[]> dat=new MapList<String,Double[]>();
  try {
    for (int i=0; i < n; i++) {
      int previousChangePoint=-1;
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[1][i + 1]+ log_g[i - previousChangePoint] - log_q_j[0][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    int previousChangePoint=68;
    for (int i=previousChangePoint; i < n; i++) {
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[2][i + 1]+ log_g[i - previousChangePoint] - log_q_j[1][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    int previousChangePoint=241;
    for (int i=previousChangePoint; i < n; i++) {
      double d=(results[0].log_p[previousChangePoint + 1][i] + results[1].log_p[previousChangePoint + 1][i] + results[2].log_p[previousChangePoint + 1][i]+ log_q_j[3][i + 1]+ log_g[i - previousChangePoint] - log_q_j[2][previousChangePoint + 1]);
      dat.put(""String_Node_Str"",new Double[]{i + 0.,d});
      System.out.println(d);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  List<Integer> mapCPs=new ArrayList<Integer>();
  List<Double> mapMLEs=new ArrayList<Double>();
  List<Double> mapLs=new ArrayList<Double>();
  int first=0;
  int j=0;
  int last=map_j[j][0].getExtreme();
  j++;
  while (j < m + 1) {
    mapCPs.add(last - 1);
    first=last;
    last=map_j[j][last].getExtreme();
    j++;
  }
  SegmentationResult segmentation=new SegmentationResult(ArrayUtils.toPrimitive(mapCPs.toArray(new Integer[0])),ArrayUtils.toPrimitive(mapMLEs.toArray(new Double[0])),ArrayUtils.toPrimitive(mapLs.toArray(new Double[0])),n);
  return segmentation;
}",0.9944626227032468
37724,"public static List<ChangePoint> identifyConstrainedNegativeBinomialPoints(String[] ids,SAMFileReader[] sfrs,Strandedness[] strandednesses,String chr,int start,int end,int maxBins,int binSize,int minCP,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    System.out.printf(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  List<ChangePoint> changePoints=new LinkedList<ChangePoint>();
  double[][] y=new double[sfrs.length][];
  for (int i=0; i < sfrs.length; i++) {
    int[] cov=BAMTools.binnedMaxEndCoverage(sfrs[i],chr,start,nBins,binSize,false,true,strandednesses[i],isNegativeStrand);
    y[i]=new double[nBins];
    for (int j=0; j < nBins; j++) {
      y[i][j]=cov[j];
    }
  }
  JointSegmentationResult segmentation=IdentifyConstrainedChangePoints.doubly_constrained_multi_segmentation(y,alpha_0,beta_0,nb_r,r,p,constrain_decreasing,min_fold);
  if (segmentation.n_segments > 1) {
    double[][] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    List<Integer> positions=new ArrayList<Integer>(segmentation.n_segments);
    List<double[]> before_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<double[]> after_mles=new ArrayList<double[]>(segmentation.n_segments);
    StrandedGenomicIntervalTree<Map<String,Object>> segments=new StrandedGenomicIntervalTree<Map<String,Object>>();
    segments.add(chr,start,end,strand);
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position >= start && position <= end) {
          positions.add(position);
          before_mles.add(segment_mle[i]);
          after_mles.add(segment_mle[i + 1]);
          SegmentFragmenter.fragment(segments,chr,position,strand,isNegativeStrand);
        }
      }
    }
    List<AnnotatedRegion> slist=new ArrayList<AnnotatedRegion>();
    for (    AnnotatedRegion s : segments) {
      slist.add(s);
    }
    for (int i=0; i < positions.size(); i++) {
      AnnotatedRegion before=slist.get(i);
      AnnotatedRegion after=slist.get(i + 1);
      AnnotatedRegion pos=new AnnotatedRegion(""String_Node_Str"",chr,positions.get(i),positions.get(i),strand);
      double[] before_mle=before_mles.get(i);
      double[] after_mle=after_mles.get(i);
      changePoints.add(new ChangePoint(pos,isNegativeStrand ? after : before,!isNegativeStrand ? after : before,ids,isNegativeStrand ? after_mle : before_mle,!isNegativeStrand ? after_mle : before_mle));
    }
  }
  return changePoints;
}","public static List<ChangePoint> identifyConstrainedNegativeBinomialPoints(String[] ids,SAMFileReader[] sfrs,Strandedness[] strandednesses,String chr,int start,int end,int maxBins,int binSize,int minCP,boolean isNegativeStrand,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold){
  int l=end - start + 1;
  int nBins=(l + binSize - 1) / binSize;
  char strand=isNegativeStrand ? '-' : '+';
  if (nBins > maxBins) {
    nBins=maxBins;
    binSize=(l + maxBins - 1) / maxBins;
    System.out.printf(""String_Node_Str"",chr,start,end,strand,binSize);
  }
  List<ChangePoint> changePoints=new ArrayList<ChangePoint>();
  double[][] y=new double[sfrs.length][];
  for (int i=0; i < sfrs.length; i++) {
    int[] cov=BAMTools.binnedMaxEndCoverage(sfrs[i],chr,start,nBins,binSize,false,true,strandednesses[i],isNegativeStrand);
    y[i]=new double[nBins];
    for (int j=0; j < nBins; j++) {
      y[i][j]=cov[j];
    }
  }
  JointSegmentationResult segmentation=IdentifyConstrainedChangePoints.doubly_constrained_multi_segmentation(y,alpha_0,beta_0,nb_r,r,p,constrain_decreasing,min_fold);
  if (segmentation.n_segments > 1) {
    double[][] segment_mle=segmentation.segment_mle;
    int[] changepoints=segmentation.change_point;
    List<Integer> positions=new ArrayList<Integer>(segmentation.n_segments);
    List<double[]> before_mles=new ArrayList<double[]>(segmentation.n_segments);
    List<double[]> after_mles=new ArrayList<double[]>(segmentation.n_segments);
    StrandedGenomicIntervalTree<Map<String,Object>> segments=new StrandedGenomicIntervalTree<Map<String,Object>>();
    segments.add(chr,start,end,strand);
    for (int i=0; i < changepoints.length; i++) {
      int changepoint_i=changepoints[i];
      if (changepoints[i] > minCP && changepoints[i] < nBins - minCP - 1) {
        int position=start + (changepoint_i * binSize) + (binSize / 2);
        if (position >= start && position <= end) {
          positions.add(position);
          before_mles.add(segment_mle[i]);
          after_mles.add(segment_mle[i + 1]);
          SegmentFragmenter.fragment(segments,chr,position,strand,isNegativeStrand);
        }
      }
    }
    List<AnnotatedRegion> slist=new ArrayList<AnnotatedRegion>();
    for (    AnnotatedRegion s : segments) {
      slist.add(s);
    }
    for (int i=0; i < positions.size(); i++) {
      AnnotatedRegion before=slist.get(i);
      AnnotatedRegion after=slist.get(i + 1);
      AnnotatedRegion pos=new AnnotatedRegion(""String_Node_Str"",chr,positions.get(i),positions.get(i),strand);
      double[] before_mle=before_mles.get(i);
      double[] after_mle=after_mles.get(i);
      changePoints.add(new ChangePoint(pos,isNegativeStrand ? after : before,!isNegativeStrand ? after : before,ids,isNegativeStrand ? after_mle : before_mle,!isNegativeStrand ? after_mle : before_mle));
    }
  }
  return changePoints;
}",0.9981024667931688
37725,"public static void filterChangePoints(SAMFileReader sfr,File spliced_exon_gtf,File intronic_exon_gtf,File acc_jnct_gtf,File changepoint_gtf,GTFWriter filtered_changepoint_writer,int sj_radius) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> continuousSegments=new StrandedGenomicIntervalTree<Map<String,Object>>();
  TranscriptIterator bi=new TranscriptIterator(acc_jnct_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> sj=IntervalTools.buildRegionsTree(bi,true,false);
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=IntervalTools.buildTerminiTree(sj,true,true,false);
  StrandedGenomicIntervalTree<Map<String,Object>> sj3p=IntervalTools.buildTerminiTree(sj,false,true,false);
  for (  File gtf : Util.list(spliced_exon_gtf,intronic_exon_gtf)) {
    TranscriptIterator ti=new TranscriptIterator(gtf);
    for (    AnnotatedRegion segment : ti) {
      SegmentFragmenter.add(continuousSegments,segment.chr,segment.start,segment.end,segment.strand);
    }
  }
  StrandedGenomicIntervalTree<Map<String,Object>> ends5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> ends3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  TranscriptIterator ti=new TranscriptIterator(changepoint_gtf);
  for (  AnnotatedRegion cp : ti) {
    double before_mle=Double.parseDouble((String)cp.getAttribute(""String_Node_Str""));
    double after_mle=Double.parseDouble((String)cp.getAttribute(""String_Node_Str""));
    boolean isEnd5p=before_mle < after_mle ^ cp.isNegativeStrand();
    if (isEnd5p && !ends5p.contains(cp.chr,cp.start,cp.end,cp.strand) && !sj3p.overlappingRegions(cp.chr,cp.start - sj_radius,cp.end + sj_radius,cp.strand).iterator().hasNext()) {
      ends5p.add(cp.chr,cp.start,cp.end,cp.strand,cp.attributes);
    }
    if (!isEnd5p && !ends3p.contains(cp.chr,cp.start,cp.end,cp.strand) && !sj5p.overlappingRegions(cp.chr,cp.start - sj_radius,cp.end + sj_radius,cp.strand).iterator().hasNext()) {
      ends3p.add(cp.chr,cp.start,cp.end,cp.strand,cp.attributes);
    }
  }
  Comparator<AnnotatedRegion> descending_order=new Comparator<AnnotatedRegion>(){
    public int compare(    AnnotatedRegion arg0,    AnnotatedRegion arg1){
      return arg0.start < arg1.start ? 1 : arg0.start > arg1.start ? -1 : 0;
    }
  }
;
  Comparator<AnnotatedRegion> ascending_order=new Comparator<AnnotatedRegion>(){
    public int compare(    AnnotatedRegion arg0,    AnnotatedRegion arg1){
      return arg0.start < arg1.start ? -1 : arg0.start > arg1.start ? 1 : 0;
    }
  }
;
  for (  AnnotatedRegion segment : continuousSegments) {
{
      Comparator<AnnotatedRegion> c=segment.isNegativeStrand() ? ascending_order : descending_order;
      String attribute=segment.isNegativeStrand() ? ""String_Node_Str"" : ""String_Node_Str"";
      List<AnnotatedRegion> to_delete=new LinkedList<AnnotatedRegion>();
      List<AnnotatedRegion> overlapping3p=IntervalTools.OverlappingIntervals(ends3p,segment.chr,segment.start,segment.end,segment.strand);
      Collections.sort(overlapping3p,c);
      double max_mle=0;
      for (      AnnotatedRegion end : overlapping3p) {
        double mle=Double.parseDouble((String)end.getAttribute(attribute));
        if (mle > max_mle) {
          max_mle=Math.max(mle,max_mle);
        }
 else {
          to_delete.add(end);
        }
      }
      for (      AnnotatedRegion end : to_delete) {
        ends3p.remove(end.chr,end.start,end.end,end.strand);
      }
    }
{
      Comparator<AnnotatedRegion> c=segment.isNegativeStrand() ? descending_order : ascending_order;
      String attribute=segment.isNegativeStrand() ? ""String_Node_Str"" : ""String_Node_Str"";
      List<AnnotatedRegion> to_delete=new LinkedList<AnnotatedRegion>();
      List<AnnotatedRegion> overlapping5p=IntervalTools.OverlappingIntervals(ends5p,segment.chr,segment.start,segment.end,segment.strand);
      Collections.sort(overlapping5p,c);
      double max_mle=0;
      for (      AnnotatedRegion end : overlapping5p) {
        double mle=Double.parseDouble((String)end.getAttribute(attribute));
        if (mle > max_mle) {
          max_mle=Math.max(mle,max_mle);
        }
 else {
          to_delete.add(end);
        }
      }
      for (      AnnotatedRegion end : to_delete) {
        ends5p.remove(end.chr,end.start,end.end,end.strand);
      }
    }
  }
  for (  AnnotatedRegion end : ends3p) {
    filtered_changepoint_writer.write(""String_Node_Str"",end.chr,end.start,end.start,end.strand,AnnotatedRegion.GTFAttributeString(end.attributes));
  }
  for (  AnnotatedRegion end : ends5p) {
    filtered_changepoint_writer.write(""String_Node_Str"",end.chr,end.start,end.start,end.strand,AnnotatedRegion.GTFAttributeString(end.attributes));
  }
}","public static void filterChangePoints(SAMFileReader sfr,File spliced_exon_gtf,File intronic_exon_gtf,File acc_jnct_gtf,File changepoint_gtf,GTFWriter filtered_changepoint_writer,int sj_radius) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> continuousSegments=new StrandedGenomicIntervalTree<Map<String,Object>>();
  TranscriptIterator bi=new TranscriptIterator(acc_jnct_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> sj=IntervalTools.buildRegionsTree(bi,true,false);
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=IntervalTools.buildTerminiTree(sj,true,true,false);
  StrandedGenomicIntervalTree<Map<String,Object>> sj3p=IntervalTools.buildTerminiTree(sj,false,true,false);
  for (  File gtf : Util.list(spliced_exon_gtf,intronic_exon_gtf)) {
    TranscriptIterator ti=new TranscriptIterator(gtf);
    for (    AnnotatedRegion segment : ti) {
      SegmentFragmenter.add(continuousSegments,segment.chr,segment.start,segment.end,segment.strand);
    }
  }
  StrandedGenomicIntervalTree<Map<String,Object>> ends5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> ends3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  TranscriptIterator ti=new TranscriptIterator(changepoint_gtf);
  for (  AnnotatedRegion cp : ti) {
    double before_mle=Double.parseDouble((String)cp.getAttribute(""String_Node_Str""));
    double after_mle=Double.parseDouble((String)cp.getAttribute(""String_Node_Str""));
    boolean isEnd5p=before_mle < after_mle ^ cp.isNegativeStrand();
    if (isEnd5p && !ends5p.contains(cp.chr,cp.start,cp.end,cp.strand) && !sj3p.overlappingRegions(cp.chr,cp.start - sj_radius,cp.end + sj_radius,cp.strand).iterator().hasNext()) {
      ends5p.add(cp.chr,cp.start,cp.end,cp.strand,cp.attributes);
    }
    if (!isEnd5p && !ends3p.contains(cp.chr,cp.start,cp.end,cp.strand) && !sj5p.overlappingRegions(cp.chr,cp.start - sj_radius,cp.end + sj_radius,cp.strand).iterator().hasNext()) {
      ends3p.add(cp.chr,cp.start,cp.end,cp.strand,cp.attributes);
    }
  }
  Comparator<AnnotatedRegion> descending_order=new Comparator<AnnotatedRegion>(){
    public int compare(    AnnotatedRegion arg0,    AnnotatedRegion arg1){
      return arg0.start < arg1.start ? 1 : arg0.start > arg1.start ? -1 : 0;
    }
  }
;
  Comparator<AnnotatedRegion> ascending_order=new Comparator<AnnotatedRegion>(){
    public int compare(    AnnotatedRegion arg0,    AnnotatedRegion arg1){
      return arg0.start < arg1.start ? -1 : arg0.start > arg1.start ? 1 : 0;
    }
  }
;
  for (  AnnotatedRegion segment : continuousSegments) {
{
      Comparator<AnnotatedRegion> c=segment.isNegativeStrand() ? ascending_order : descending_order;
      String attribute=segment.isNegativeStrand() ? ""String_Node_Str"" : ""String_Node_Str"";
      List<AnnotatedRegion> to_delete=new ArrayList<AnnotatedRegion>();
      List<AnnotatedRegion> overlapping3p=IntervalTools.OverlappingIntervals(ends3p,segment.chr,segment.start,segment.end,segment.strand);
      Collections.sort(overlapping3p,c);
      double max_mle=0;
      for (      AnnotatedRegion end : overlapping3p) {
        double mle=Double.parseDouble((String)end.getAttribute(attribute));
        if (mle > max_mle) {
          max_mle=Math.max(mle,max_mle);
        }
 else {
          to_delete.add(end);
        }
      }
      for (      AnnotatedRegion end : to_delete) {
        ends3p.remove(end.chr,end.start,end.end,end.strand);
      }
    }
{
      Comparator<AnnotatedRegion> c=segment.isNegativeStrand() ? descending_order : ascending_order;
      String attribute=segment.isNegativeStrand() ? ""String_Node_Str"" : ""String_Node_Str"";
      List<AnnotatedRegion> to_delete=new ArrayList<AnnotatedRegion>();
      List<AnnotatedRegion> overlapping5p=IntervalTools.OverlappingIntervals(ends5p,segment.chr,segment.start,segment.end,segment.strand);
      Collections.sort(overlapping5p,c);
      double max_mle=0;
      for (      AnnotatedRegion end : overlapping5p) {
        double mle=Double.parseDouble((String)end.getAttribute(attribute));
        if (mle > max_mle) {
          max_mle=Math.max(mle,max_mle);
        }
 else {
          to_delete.add(end);
        }
      }
      for (      AnnotatedRegion end : to_delete) {
        ends5p.remove(end.chr,end.start,end.end,end.strand);
      }
    }
  }
  for (  AnnotatedRegion end : ends3p) {
    filtered_changepoint_writer.write(""String_Node_Str"",end.chr,end.start,end.start,end.strand,AnnotatedRegion.GTFAttributeString(end.attributes));
  }
  for (  AnnotatedRegion end : ends5p) {
    filtered_changepoint_writer.write(""String_Node_Str"",end.chr,end.start,end.start,end.strand,AnnotatedRegion.GTFAttributeString(end.attributes));
  }
}",0.9976837228890292
37726,"public static void iterateSpliceIsoforms(File assembly_gtf,GTFWriter isoform_gtf,PrintStream skipped,Integer max_paths) throws FileNotFoundException {
  TranscriptIterator ti=new TranscriptIterator(assembly_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> exon_5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exon_3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  MapCounter<String> isoform_count=new MapCounter<String>();
  for (  AnnotatedRegion r : ti) {
    if (r.annotation.equals(""String_Node_Str"")) {
      if (r.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        exon_5p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
 else {
        exon_3p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
    }
    if (r.annotation.equals(""String_Node_Str"")) {
      Map<String,Object> attributes=r.attributes;
      attributes.put(""String_Node_Str"",r.get3Prime());
      sj5p.add(r.chr,r.get5Prime(),r.get5Prime(),r.strand,attributes);
    }
  }
  Set<String> skipped_ids=new HashSet<String>();
  for (  AnnotatedRegion r : exon_5p) {
    if (max_paths == null || countPaths(r,exon_3p,sj5p) < max_paths) {
      Stack<AnnotatedRegion> isoform_exons=new Stack<AnnotatedRegion>();
      iterateIsoforms(isoform_count,isoform_exons,r,exon_3p,sj5p,isoform_gtf);
    }
 else {
      String locus_id=(String)r.getAttribute(""String_Node_Str"");
      if (!skipped_ids.contains(locus_id)) {
        skipped.println(locus_id);
        skipped_ids.add(locus_id);
      }
    }
  }
}","public static void iterateSpliceIsoforms(File assembly_gtf,GTFWriter isoform_gtf,PrintStream skipped,Integer max_paths) throws FileNotFoundException {
  TranscriptIterator ti=new TranscriptIterator(assembly_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> exon_5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exon_3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  MapCounter<String> isoform_count=new MapCounter<String>();
  for (  AnnotatedRegion r : ti) {
    if (r.annotation.equals(""String_Node_Str"")) {
      if (r.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        exon_5p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
 else {
        exon_3p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
    }
    if (r.annotation.equals(""String_Node_Str"")) {
      Map<String,Object> attributes=r.attributes;
      attributes.put(""String_Node_Str"",r.get3Prime());
      sj5p.add(r.chr,r.get5Prime(),r.get5Prime(),r.strand,attributes);
    }
  }
  Set<String> skipped_ids=new HashSet<String>();
  for (  AnnotatedRegion r : exon_5p) {
    if (max_paths == null || countPaths(r,exon_3p,sj5p).compareTo(new BigInteger(String.format(""String_Node_Str"",max_paths))) < 0) {
      Stack<AnnotatedRegion> isoform_exons=new Stack<AnnotatedRegion>();
      iterateIsoforms(isoform_count,isoform_exons,r,exon_3p,sj5p,isoform_gtf);
    }
 else {
      String locus_id=(String)r.getAttribute(""String_Node_Str"");
      if (!skipped_ids.contains(locus_id)) {
        skipped.println(locus_id);
        skipped_ids.add(locus_id);
      }
    }
  }
}",0.980209545983702
37727,"public static void countSpliceIsoforms(File assembly_gtf) throws FileNotFoundException {
  TranscriptIterator ti=new TranscriptIterator(assembly_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> exon_5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exon_3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  for (  AnnotatedRegion r : ti) {
    if (r.annotation.equals(""String_Node_Str"")) {
      if (r.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        exon_5p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
 else {
        exon_3p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
    }
    if (r.annotation.equals(""String_Node_Str"")) {
      Map<String,Object> attributes=r.attributes;
      attributes.put(""String_Node_Str"",r.get3Prime());
      sj5p.add(r.chr,r.get5Prime(),r.get5Prime(),r.strand,attributes);
    }
  }
  for (  AnnotatedRegion r : exon_5p) {
    int n=countPaths(r,exon_3p,sj5p);
    System.out.printf(""String_Node_Str"",r,n);
  }
}","public static void countSpliceIsoforms(File assembly_gtf) throws FileNotFoundException {
  TranscriptIterator ti=new TranscriptIterator(assembly_gtf);
  StrandedGenomicIntervalTree<Map<String,Object>> exon_5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> exon_3p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  StrandedGenomicIntervalTree<Map<String,Object>> sj5p=new StrandedGenomicIntervalTree<Map<String,Object>>();
  for (  AnnotatedRegion r : ti) {
    if (r.annotation.equals(""String_Node_Str"")) {
      if (r.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
        exon_5p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
 else {
        exon_3p.add(r.chr,r.start,r.end,r.strand,r.attributes);
      }
    }
    if (r.annotation.equals(""String_Node_Str"")) {
      Map<String,Object> attributes=r.attributes;
      attributes.put(""String_Node_Str"",r.get3Prime());
      sj5p.add(r.chr,r.get5Prime(),r.get5Prime(),r.strand,attributes);
    }
  }
  for (  AnnotatedRegion r : exon_5p) {
    int n=countPaths(r,exon_3p,sj5p).intValue();
    System.out.printf(""String_Node_Str"",r,n);
  }
}",0.9953131657435024
37728,"public static Integer countPaths(AnnotatedRegion r,StrandedGenomicIntervalTree<Map<String,Object>> exon_3p,StrandedGenomicIntervalTree<Map<String,Object>> sj5p){
  String path_att=""String_Node_Str"";
  Integer nPaths=(Integer)r.getAttribute(path_att);
  if (nPaths == null) {
    List<AnnotatedRegion> children=listChildren(r,exon_3p,sj5p);
    if (children.size() == 0) {
      nPaths=1;
    }
 else {
      nPaths=0;
      for (      AnnotatedRegion c : children) {
        nPaths+=countPaths(c,exon_3p,sj5p);
      }
    }
    r.addAttribute(path_att,nPaths);
  }
  return nPaths;
}","public static BigInteger countPaths(AnnotatedRegion r,StrandedGenomicIntervalTree<Map<String,Object>> exon_3p,StrandedGenomicIntervalTree<Map<String,Object>> sj5p){
  String path_att=""String_Node_Str"";
  BigInteger nPaths=(BigInteger)r.getAttribute(path_att);
  if (nPaths == null) {
    List<AnnotatedRegion> children=listChildren(r,exon_3p,sj5p);
    if (children.size() == 0) {
      nPaths=new BigInteger(""String_Node_Str"");
    }
 else {
      nPaths=new BigInteger(""String_Node_Str"");
      for (      AnnotatedRegion c : children) {
        nPaths=nPaths.add(countPaths(c,exon_3p,sj5p));
      }
    }
    r.addAttribute(path_att,nPaths);
  }
  return nPaths;
}",0.926517571884984
37729,"public static void performJointSegmentation(String id1,String id2,File spliced_exons1,File spliced_exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> exons1=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> exons2=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons2),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> maxCommonExons=getMaxCommonExons(exons1,exons2,strandedness1,strandedness2);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=IntervalTools.buildTerminiTree(maxCommonExons,true,true,false);
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    AnnotatedRegion u=IntervalTools.BoundaryIntervals(maxCommonExons,region.chr,region.get5Prime(),region.strand,true).iterator().next();
    Map<String,Object> attributes=new HashMap<String,Object>();
    String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
    attributes.put(""String_Node_Str"",locus_ID);
    changepoint_id++;
    gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
    boolean constrained_decreasing=!u.isNegativeStrand();
    List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold);
    for (    ChangePoint cp : changepoints) {
      AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
      changepoint.addAttribute(""String_Node_Str"",id1);
      changepoint.addAttribute(""String_Node_Str"",id2);
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",locus_ID);
      gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
      double[] usage=new double[sfrs.length];
      for (int i=0; i < sfrs.length; i++) {
        usage[i]=1 - (cp.cov_downstream[i] / cp.cov_upstream[i]);
      }
      tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
    }
  }
  gw.close();
  tabular.close();
}","public static void performJointSegmentation(String id1,String id2,File spliced_exons1,File spliced_exons2,File bam1,File bam2,File table,File gtf,Strandedness strandedness1,Strandedness strandedness2,int maxBins,int binSize,int minCP,double alpha_0,double beta_0,int nb_r,int r,double p,double min_fold) throws FileNotFoundException {
  StrandedGenomicIntervalTree<Map<String,Object>> exons1=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons1),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> exons2=IntervalTools.buildRegionsTree(new TranscriptIterator(spliced_exons2),true,true,true);
  StrandedGenomicIntervalTree<Map<String,Object>> maxCommonExons=getMaxCommonExons(exons1,exons2,strandedness1,strandedness2);
  StrandedGenomicIntervalTree<Map<String,Object>> t5p=IntervalTools.buildTerminiTree(maxCommonExons,true,true,false);
  SAMFileReader.setDefaultValidationStringency(ValidationStringency.SILENT);
  String[] ids=new String[]{id1,id2};
  SAMFileReader[] sfrs=new SAMFileReader[]{new SAMFileReader(bam1),new SAMFileReader(bam2)};
  Strandedness[] strandednesses=new Strandedness[]{strandedness1,strandedness2};
  GTFWriter gw=new GTFWriter(IO.bufferedPrintstream(gtf));
  PrintStream tabular=IO.bufferedPrintstream(table);
  tabular.printf(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  int changepoint_id=0;
  for (  AnnotatedRegion region : t5p) {
    AnnotatedRegion u=IntervalTools.BoundaryIntervals(maxCommonExons,region.chr,region.get5Prime(),region.strand,true).iterator().next();
    Map<String,Object> attributes=new HashMap<String,Object>();
    String locus_ID=Util.sprintf(""String_Node_Str"",changepoint_id);
    attributes.put(""String_Node_Str"",locus_ID);
    changepoint_id++;
    gw.write(""String_Node_Str"",u.chr,u.start,u.end,u.strand,AnnotatedRegion.GTFAttributeString(attributes));
    boolean constrained_decreasing=!u.isNegativeStrand();
    List<ChangePoint> changepoints=IdentifyChangePoints.identifyConstrainedNegativeBinomialPoints(ids,sfrs,strandednesses,u.chr,u.start,u.end,maxBins,binSize,minCP,u.isNegativeStrand(),alpha_0,beta_0,nb_r,r,p,constrained_decreasing,min_fold);
    for (    ChangePoint cp : changepoints) {
      AnnotatedRegion changepoint=new AnnotatedRegion(""String_Node_Str"",cp.pos.chr,cp.pos.start,cp.pos.end,cp.pos.strand,new HashMap<String,Object>());
      changepoint.addAttribute(""String_Node_Str"",id1);
      changepoint.addAttribute(""String_Node_Str"",id2);
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(changepoint.getAttribute(""String_Node_Str"")),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""));
      changepoint.addAttribute(""String_Node_Str"",locus_ID);
      gw.write(""String_Node_Str"",u.chr,changepoint.start,changepoint.end,u.strand,AnnotatedRegion.GTFAttributeString(changepoint.attributes));
      double[] usage=new double[sfrs.length];
      for (int i=0; i < sfrs.length; i++) {
        usage[i]=1 - Math.min((cp.cov_downstream[i] / cp.cov_upstream[i]),1);
      }
      tabular.printf(""String_Node_Str"",StringUtils.join(ids,""String_Node_Str""),locus_ID,changepoint,cp.upstream_region,cp.downstream_region,u,cp.pos.strand,StringUtils.join(Util.list(cp.cov_upstream),""String_Node_Str""),StringUtils.join(Util.list(cp.cov_downstream),""String_Node_Str""),StringUtils.join(Util.list(usage),""String_Node_Str""),usage[0] - usage[1]);
    }
  }
  gw.close();
  tabular.close();
}",0.9984682154710236
37730,"public static JointSegmentationResult doubly_constrained_multi_segmentation(double[][] y,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold){
  int n=y[0].length;
  @SuppressWarnings(""String_Node_Str"") ExtremeObjectTracker<Integer,Double>[] map=new ExtremeObjectTracker[n];
  ExtremeObjectTracker<Double,Double>[][] map_mle=new ExtremeObjectTracker[y.length][n];
  ExtremeObjectTracker<Double,Double>[][] nxt_mle=new ExtremeObjectTracker[y.length][n];
  double[][][] log_p=new double[y.length][][];
  double[][][] segment_mle=new double[y.length][][];
  SCMResult[] results=new SCMResult[y.length];
  for (int i=0; i < y.length; i++) {
    results[i]=calculate_segment_probabilities(y[i],alpha_0,beta_0,nb_r);
    log_p[i]=results[i].log_p;
    segment_mle[i]=results[i].segment_mle;
  }
  double[] log_g=new double[n];
  double[] log_G=new double[n];
  log_G[0]=Double.NEGATIVE_INFINITY;
  for (int i=0; i < n; i++) {
    map[i]=new ExtremeObjectTracker<Integer,Double>(new Util.ComparableComparator<Double>());
    for (int j=0; j < y.length; j++) {
      map_mle[j][i]=new ExtremeObjectTracker<Double,Double>(new Util.ComparableComparator<Double>());
      nxt_mle[j][i]=new ExtremeObjectTracker<Double,Double>(new Util.ComparableComparator<Double>());
    }
    log_g[i]=log_nb(i,r,p);
    if (i > 0)     log_G[i]=log_G[i - 1];
    log_G[i]=Util.logSum(Util.list(log_G[i],log_g[i]));
  }
  for (int t=n - 1; t > -1; t--) {
    for (int s=t; s < n - 1; s++) {
      boolean any_satisfy_constraints=false;
      double log_p_t_s=0;
      double[] extremes=new double[y.length];
      for (int i=0; i < y.length; i++) {
        log_p_t_s+=log_p[i][t][s];
        double next_mle=nxt_mle[i][s + 1].getMaxObject();
        extremes[i]=constrain_decreasing ? Math.max(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]) : Math.min(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]);
        Boolean satisfies_decreasing=null;
        Boolean satisfies_fold=null;
        if (constrain_decreasing) {
          double fold=next_mle / segment_mle[i][t][s];
          satisfies_fold=fold <= min_fold;
          satisfies_decreasing=map_mle[i][s + 1].getMaxObject() < (segment_mle[i][t][s]);
        }
 else {
          double fold=segment_mle[i][t][s] / next_mle;
          satisfies_fold=fold <= min_fold;
          satisfies_decreasing=(segment_mle[i][t][s]) < map_mle[i][s + 1].getMaxObject();
        }
        any_satisfy_constraints|=(satisfies_fold && satisfies_decreasing);
      }
      if (!any_satisfy_constraints) {
        map[t].put(s + 1,Double.NEGATIVE_INFINITY);
        for (int i=0; i < y.length; i++) {
          map_mle[i][t].put(extremes[i],Double.NEGATIVE_INFINITY);
          nxt_mle[i][t].put(segment_mle[i][t][s],Double.NEGATIVE_INFINITY);
        }
      }
 else {
        double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
        map[t].put(s + 1,log_p_t_s + map[s + 1].getMax() + p_segment_length);
        for (int i=0; i < y.length; i++) {
          map_mle[i][t].put(extremes[i],log_p_t_s + map[s + 1].getMax() + p_segment_length);
          nxt_mle[i][t].put(segment_mle[i][t][s],log_p_t_s + map[s + 1].getMax() + p_segment_length);
        }
      }
      for (int i=0; i < y.length; i++) {
        double extreme=constrain_decreasing ? Math.max(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]) : Math.min(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]);
        if (!(any_satisfy_constraints)) {
          map_mle[i][t].put(extreme,Double.NEGATIVE_INFINITY);
          nxt_mle[i][t].put(segment_mle[i][t][s],Double.NEGATIVE_INFINITY);
        }
 else {
          double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
          map_mle[i][t].put(extreme,log_p_t_s + map[s + 1].getMax() + p_segment_length);
          nxt_mle[i][t].put(segment_mle[i][t][s],log_p_t_s + map[s + 1].getMax() + p_segment_length);
        }
      }
      if (!(any_satisfy_constraints)) {
        map[t].put(s + 1,Double.NEGATIVE_INFINITY);
      }
 else {
        double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
        map[t].put(s + 1,log_p_t_s + map[s + 1].getMax() + p_segment_length);
      }
    }
    double log_p_t_s=0;
    for (int i=0; i < y.length; i++) {
      log_p_t_s+=log_p[i][t][n - 1];
    }
    map[t].put(n,log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
    for (int i=0; i < y.length; i++) {
      map_mle[i][t].put(segment_mle[i][t][n - 1],log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
      nxt_mle[i][t].put(segment_mle[i][t][n - 1],log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
    }
  }
  List<Integer> mapCPs=new ArrayList<Integer>();
  List<Double[]> mapMLEs=new ArrayList<Double[]>();
  List<Double> mapLs=new ArrayList<Double>();
  int first=0;
  int last=map[0].getMaxObject();
  Double[] mle=new Double[y.length];
  for (int i=0; i < y.length; i++) {
    mle[i]=segment_mle[i][first][last - 1];
  }
  mapMLEs.add(mle);
  while (last < n) {
    mapCPs.add(last - 1);
    first=last;
    last=map[last].getMaxObject();
    mle=new Double[y.length];
    for (int i=0; i < y.length; i++) {
      mle[i]=segment_mle[i][first][last - 1];
    }
    mapMLEs.add(mle);
  }
  double[][] mles=new double[mapMLEs.size()][y.length];
  for (int i=0; i < mapMLEs.size(); i++) {
    for (int j=0; j < y.length; j++) {
      mles[i][j]=mapMLEs.get(i)[j];
    }
  }
  JointSegmentationResult segmentation=new JointSegmentationResult(ArrayUtils.toPrimitive(mapCPs.toArray(new Integer[0])),mles,ArrayUtils.toPrimitive(mapLs.toArray(new Double[0])),n);
  return segmentation;
}","public static JointSegmentationResult doubly_constrained_multi_segmentation(double[][] y,double alpha_0,double beta_0,int nb_r,int r,double p,boolean constrain_decreasing,double min_fold){
  int n=y[0].length;
  @SuppressWarnings(""String_Node_Str"") ExtremeObjectTracker<Integer,Double>[] map=new ExtremeObjectTracker[n];
  ExtremeObjectTracker<Double,Double>[][] map_mle=new ExtremeObjectTracker[y.length][n];
  ExtremeObjectTracker<Double,Double>[][] nxt_mle=new ExtremeObjectTracker[y.length][n];
  double[][][] log_p=new double[y.length][][];
  double[][][] segment_mle=new double[y.length][][];
  SCMResult[] results=new SCMResult[y.length];
  for (int i=0; i < y.length; i++) {
    results[i]=calculate_segment_probabilities(y[i],alpha_0,beta_0,nb_r);
    log_p[i]=results[i].log_p;
    segment_mle[i]=results[i].segment_mle;
  }
  double[] log_g=new double[n];
  double[] log_G=new double[n];
  log_G[0]=Double.NEGATIVE_INFINITY;
  for (int i=0; i < n; i++) {
    map[i]=new ExtremeObjectTracker<Integer,Double>(new Util.ComparableComparator<Double>());
    for (int j=0; j < y.length; j++) {
      map_mle[j][i]=new ExtremeObjectTracker<Double,Double>(new Util.ComparableComparator<Double>());
      nxt_mle[j][i]=new ExtremeObjectTracker<Double,Double>(new Util.ComparableComparator<Double>());
    }
    log_g[i]=log_nb(i,r,p);
    if (i > 0)     log_G[i]=log_G[i - 1];
    log_G[i]=Util.logSum(Util.list(log_G[i],log_g[i]));
  }
  for (int t=n - 1; t > -1; t--) {
    for (int s=t; s < n - 1; s++) {
      boolean any_satisfy_constraints=false;
      boolean all_positive_upstream=true;
      double log_p_t_s=0;
      double[] extremes=new double[y.length];
      for (int i=0; i < y.length; i++) {
        log_p_t_s+=log_p[i][t][s];
        double next_mle=nxt_mle[i][s + 1].getMaxObject();
        extremes[i]=constrain_decreasing ? Math.max(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]) : Math.min(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]);
        Boolean satisfies_decreasing=null;
        Boolean satisfies_fold=null;
        if (constrain_decreasing) {
          double fold=next_mle / segment_mle[i][t][s];
          satisfies_fold=fold <= min_fold;
          satisfies_decreasing=map_mle[i][s + 1].getMaxObject() < (segment_mle[i][t][s]);
          all_positive_upstream&=segment_mle[i][t][s] > 0;
        }
 else {
          double fold=segment_mle[i][t][s] / next_mle;
          satisfies_fold=fold <= min_fold;
          satisfies_decreasing=(segment_mle[i][t][s]) < map_mle[i][s + 1].getMaxObject();
          all_positive_upstream&=next_mle > 0;
        }
        any_satisfy_constraints|=(satisfies_fold && satisfies_decreasing);
      }
      if (!(any_satisfy_constraints && all_positive_upstream)) {
        map[t].put(s + 1,Double.NEGATIVE_INFINITY);
        for (int i=0; i < y.length; i++) {
          map_mle[i][t].put(extremes[i],Double.NEGATIVE_INFINITY);
          nxt_mle[i][t].put(segment_mle[i][t][s],Double.NEGATIVE_INFINITY);
        }
      }
 else {
        double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
        map[t].put(s + 1,log_p_t_s + map[s + 1].getMax() + p_segment_length);
        for (int i=0; i < y.length; i++) {
          map_mle[i][t].put(extremes[i],log_p_t_s + map[s + 1].getMax() + p_segment_length);
          nxt_mle[i][t].put(segment_mle[i][t][s],log_p_t_s + map[s + 1].getMax() + p_segment_length);
        }
      }
      for (int i=0; i < y.length; i++) {
        double extreme=constrain_decreasing ? Math.max(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]) : Math.min(map_mle[i][s + 1].getMaxObject(),segment_mle[i][t][s]);
        if (!(any_satisfy_constraints && all_positive_upstream)) {
          map_mle[i][t].put(extreme,Double.NEGATIVE_INFINITY);
          nxt_mle[i][t].put(segment_mle[i][t][s],Double.NEGATIVE_INFINITY);
        }
 else {
          double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
          map_mle[i][t].put(extreme,log_p_t_s + map[s + 1].getMax() + p_segment_length);
          nxt_mle[i][t].put(segment_mle[i][t][s],log_p_t_s + map[s + 1].getMax() + p_segment_length);
        }
      }
      if (!(any_satisfy_constraints && all_positive_upstream)) {
        map[t].put(s + 1,Double.NEGATIVE_INFINITY);
      }
 else {
        double p_segment_length=t == 0 ? Math.log(1 - Math.exp(log_G[s])) : log_g[s - t];
        map[t].put(s + 1,log_p_t_s + map[s + 1].getMax() + p_segment_length);
      }
    }
    double log_p_t_s=0;
    for (int i=0; i < y.length; i++) {
      log_p_t_s+=log_p[i][t][n - 1];
    }
    map[t].put(n,log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
    for (int i=0; i < y.length; i++) {
      map_mle[i][t].put(segment_mle[i][t][n - 1],log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
      nxt_mle[i][t].put(segment_mle[i][t][n - 1],log_p_t_s + Math.log(1 - Math.exp(log_G[n - t - 1])));
    }
  }
  List<Integer> mapCPs=new ArrayList<Integer>();
  List<Double[]> mapMLEs=new ArrayList<Double[]>();
  List<Double> mapLs=new ArrayList<Double>();
  int first=0;
  int last=map[0].getMaxObject();
  Double[] mle=new Double[y.length];
  for (int i=0; i < y.length; i++) {
    mle[i]=segment_mle[i][first][last - 1];
  }
  mapMLEs.add(mle);
  while (last < n) {
    mapCPs.add(last - 1);
    first=last;
    last=map[last].getMaxObject();
    mle=new Double[y.length];
    for (int i=0; i < y.length; i++) {
      mle[i]=segment_mle[i][first][last - 1];
    }
    mapMLEs.add(mle);
  }
  double[][] mles=new double[mapMLEs.size()][y.length];
  for (int i=0; i < mapMLEs.size(); i++) {
    for (int j=0; j < y.length; j++) {
      mles[i][j]=mapMLEs.get(i)[j];
    }
  }
  JointSegmentationResult segmentation=new JointSegmentationResult(ArrayUtils.toPrimitive(mapCPs.toArray(new Integer[0])),mles,ArrayUtils.toPrimitive(mapLs.toArray(new Double[0])),n);
  return segmentation;
}",0.980585037535594
37731,"public static void validateAssemble(AssembleCommand params){
  boolean fails_validation=false;
  StringBuilder msg=new StringBuilder();
  if (params.strandedness == null) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.bam.isDirectory()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.bam));
  }
  if (!params.bam.exists()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.bam));
  }
  if (params.merge_radius < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.w < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.threshold < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.nb_r < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.min_fold < 0 || params.min_fold > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.jnct_alpha < 0 || params.jnct_alpha > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.insert_size_quantile != null && (params.insert_size_quantile < 0 || params.insert_size_quantile > 1)) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.segment_p < 0 || params.segment_p > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.segment_r < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.filled_gap_segments != null && params.filled_gap_segments.isDirectory()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.filled_gap_segments));
  }
  if (params.filled_gap_segments != null && !params.filled_gap_segments.exists()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.filled_gap_segments));
  }
  if (fails_validation)   throw new IllegalArgumentException(msg.toString());
}","public static void validateAssemble(AssembleCommand params){
  boolean fails_validation=false;
  StringBuilder msg=new StringBuilder();
  if (params.strandedness == null) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.bam != null && params.bam.isDirectory()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.bam));
  }
  if (params.bam != null && !params.bam.exists()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.bam));
  }
  if (params.merge_radius < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.w < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.threshold < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.nb_r < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.min_fold < 0 || params.min_fold > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.jnct_alpha < 0 || params.jnct_alpha > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.insert_size_quantile != null && (params.insert_size_quantile < 0 || params.insert_size_quantile > 1)) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.segment_p < 0 || params.segment_p > 1) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.segment_r < 0) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str""));
  }
  if (params.filled_gap_segments != null && params.filled_gap_segments.isDirectory()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.filled_gap_segments));
  }
  if (params.filled_gap_segments != null && !params.filled_gap_segments.exists()) {
    fails_validation=true;
    msg.append(Util.sprintf(""String_Node_Str"",params.filled_gap_segments));
  }
  if (fails_validation)   throw new IllegalArgumentException(msg.toString());
}",0.9896470588235294
37732,"@Override public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {
  WeChat.handleLoadPackage(lpparam);
  QuickSettings.handleLoadPackage(lpparam);
  XSystemUI.handleLoadPackage(lpparam);
}","@Override public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {
  WeChat.handleLoadPackage(lpparam);
  QuickSettings.handleLoadPackage(lpparam);
  XPhoneStatusBar.handleLoadPackage(lpparam);
}",0.9571428571428572
37733,"@SuppressWarnings(""String_Node_Str"") @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preference);
  prefs=getPreferenceScreen().getSharedPreferences();
  updateX2oolsPrefs();
}","@SuppressWarnings(""String_Node_Str"") @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preference);
  prefs=getPreferenceScreen().getSharedPreferences();
  initX2oolsPrefs();
}",0.9809160305343512
37734,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (key.equals(KEY_WECHAT_SCAN)) {
    Intent intent=new Intent(ACTION_WECHAT_SCAN_CHANGED);
    intent.putExtra(KEY_WECHAT_SCAN,sharedPreferences.getBoolean(KEY_WECHAT_SCAN,false));
    sendBroadcast(intent);
  }
 else   if (key.equals(KEY_CONTEXT_SETTINGS)) {
    boolean enable=sharedPreferences.getBoolean(KEY_CONTEXT_SETTINGS,true);
    Intent intent=new Intent(ContextSettingsService.ACTION_CONTEXT_SETTINGS);
    intent.putExtra(ContextSettingsService.KEY_ENABLE,enable);
    sendBroadcast(intent);
    Log.d(TAG,""String_Node_Str"" + enable);
  }
 else   if (key.equals(KEY_STATUS_COLOR)) {
    int color=sharedPreferences.getInt(KEY_STATUS_COLOR,Color.TRANSPARENT);
    if (color == Color.TRANSPARENT) {
      color=getResources().getColor(R.color.default_dark_actionbar);
    }
    Intent statusbarIntent=new Intent(XSystemUI.ACTION_CHANGE_STATUS_BAR);
    statusbarIntent.putExtra(""String_Node_Str"",color);
    sendBroadcast(statusbarIntent);
  }
  updateX2oolsPrefs();
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (key.equals(KEY_WECHAT_SCAN)) {
    Intent intent=new Intent(ACTION_WECHAT_SCAN_CHANGED);
    intent.putExtra(KEY_WECHAT_SCAN,sharedPreferences.getBoolean(KEY_WECHAT_SCAN,false));
    sendBroadcast(intent);
  }
 else   if (key.equals(KEY_CONTEXT_SETTINGS)) {
    boolean enable=sharedPreferences.getBoolean(KEY_CONTEXT_SETTINGS,true);
    Intent intent=new Intent(ContextSettingsService.ACTION_CONTEXT_SETTINGS);
    intent.putExtra(ContextSettingsService.KEY_ENABLE,enable);
    sendBroadcast(intent);
    Log.d(TAG,""String_Node_Str"" + enable);
  }
 else   if (key.equals(KEY_STATUS_COLOR)) {
    int color=sharedPreferences.getInt(KEY_STATUS_COLOR,Color.TRANSPARENT);
    if (color == Color.TRANSPARENT) {
      color=getResources().getColor(R.color.default_dark_actionbar);
    }
    Intent statusbarIntent=new Intent(XPhoneStatusBar.ACTION_CHANGE_STATUS_BAR);
    statusbarIntent.putExtra(""String_Node_Str"",color);
    sendBroadcast(statusbarIntent);
  }
  updateX2oolsPrefs();
}",0.989833641404806
37735,"@Override public void onCreate(){
  Mocks.sModuleMap.put(""String_Node_Str"",ViewDebugMocker.class);
  startService(new Intent(this,ContextSettingsService.class));
  super.onCreate();
}","@Override public void onCreate(){
  initX2oolsDir();
  Mocks.sModuleMap.put(""String_Node_Str"",ViewDebugMocker.class);
  startService(new Intent(this,ContextSettingsService.class));
  super.onCreate();
}",0.9506493506493506
37736,"private void loadFromDiskLocked(){
  if (mLoaded) {
    return;
  }
  try {
    File jsonFile=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
    if (jsonFile.exists()) {
      InputStreamReader isr=new InputStreamReader(new FileInputStream(jsonFile));
      BufferedReader bufferedReader=new BufferedReader(isr);
      String receiveString=""String_Node_Str"";
      StringBuilder stringBuilder=new StringBuilder();
      while ((receiveString=bufferedReader.readLine()) != null) {
        stringBuilder.append(receiveString);
      }
      json=new JSONObject(stringBuilder.toString());
      bufferedReader.close();
    }
 else {
      json=new JSONObject();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSONException e) {
    e.printStackTrace();
  }
  mLoaded=true;
  notifyAll();
}","private void loadFromDiskLocked(){
  if (mLoaded) {
    return;
  }
  try {
    if (mFile.exists()) {
      InputStreamReader isr=new InputStreamReader(new FileInputStream(mFile));
      BufferedReader bufferedReader=new BufferedReader(isr);
      String receiveString=""String_Node_Str"";
      StringBuilder stringBuilder=new StringBuilder();
      while ((receiveString=bufferedReader.readLine()) != null) {
        stringBuilder.append(receiveString);
      }
      json=new JSONObject(stringBuilder.toString());
      bufferedReader.close();
    }
 else {
      json=new JSONObject();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSONException e) {
    e.printStackTrace();
  }
  mLoaded=true;
  notifyAll();
}",0.932406822488945
37737,"public X2oolsSharedPreferences(){
  mFile=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"" + ""String_Node_Str"");
  startLoadFromDisk();
}","public X2oolsSharedPreferences(){
  mFile=new File(X2oolsApplication.X2OOLS_PREFS);
  startLoadFromDisk();
}",0.6339622641509434
37738,"public static void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  if (!lpparam.packageName.equals(PACKAGE_NAME))   return;
  x2ools_prefs=new X2oolsSharedPreferences();
  Class<?> quickSettingsClass=XposedHelpers.findClass(CLASS_QUICK_SETTINGS,lpparam.classLoader);
  Class<?> phoneStatusBarClass=XposedHelpers.findClass(CLASS_PHONE_STATUSBAR,lpparam.classLoader);
  Class<?> panelBarClass=XposedHelpers.findClass(CLASS_PANEL_BAR,lpparam.classLoader);
  XposedBridge.hookAllConstructors(quickSettingsClass,quickSettingsConstructHook);
  XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",panelBarClass,quickSettingsSetBarHook);
  XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",phoneStatusBarClass,quickSettingsSetServiceHook);
  XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",ViewGroup.class,LayoutInflater.class,quickSettingsAddSystemTilesHook);
}","public static void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  if (!lpparam.packageName.equals(PACKAGE_NAME))   return;
  x2ools_prefs=new X2oolsSharedPreferences();
  Class<?> quickSettingsClass=null;
  Class<?> phoneStatusBarClass=null;
  Class<?> panelBarClass=null;
  try {
    quickSettingsClass=XposedHelpers.findClass(CLASS_QUICK_SETTINGS,lpparam.classLoader);
    phoneStatusBarClass=XposedHelpers.findClass(CLASS_PHONE_STATUSBAR,lpparam.classLoader);
    panelBarClass=XposedHelpers.findClass(CLASS_PANEL_BAR,lpparam.classLoader);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
  try {
    XposedBridge.hookAllConstructors(quickSettingsClass,quickSettingsConstructHook);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
  try {
    XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",panelBarClass,quickSettingsSetBarHook);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
  try {
    XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",phoneStatusBarClass,quickSettingsSetServiceHook);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
  try {
    XposedHelpers.findAndHookMethod(quickSettingsClass,""String_Node_Str"",ViewGroup.class,LayoutInflater.class,quickSettingsAddSystemTilesHook);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
}",0.8020969855832241
37739,"public static void initZygote(StartupParam startupParam) throws Throwable {
  Class<?> ActionBarContainerClass=XposedHelpers.findClass(""String_Node_Str"",null);
  XposedHelpers.findAndHookMethod(ActionBarContainerClass,""String_Node_Str"",Drawable.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      X2oolsSharedPreferences prefs=new X2oolsSharedPreferences();
      int tintColor=prefs.getInt(X2oolsActivity.KEY_STATUS_COLOR,Color.TRANSPARENT);
      if (tintColor == Color.TRANSPARENT) {
        Activity activity=(Activity)((View)param.thisObject).getContext();
        XSystemUI.changeColorAuto(activity,true);
      }
    }
  }
);
}","public static void initZygote(StartupParam startupParam) throws Throwable {
  Class<?> ActionBarContainerClass=XposedHelpers.findClass(""String_Node_Str"",null);
  try {
    XposedHelpers.findAndHookMethod(ActionBarContainerClass,""String_Node_Str"",Drawable.class,setPrimaryBackgroundHook);
  }
 catch (  Throwable t) {
    XposedBridge.log(t);
  }
}",0.4966824644549763
37740,"@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
  X2oolsSharedPreferences prefs=new X2oolsSharedPreferences();
  int tintColor=prefs.getInt(X2oolsActivity.KEY_STATUS_COLOR,Color.TRANSPARENT);
  if (tintColor == Color.TRANSPARENT) {
    Activity activity=(Activity)((View)param.thisObject).getContext();
    XSystemUI.changeColorAuto(activity,true);
  }
}","@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
  X2oolsSharedPreferences prefs=new X2oolsSharedPreferences();
  int tintColor=prefs.getInt(X2oolsActivity.KEY_STATUS_COLOR,Color.TRANSPARENT);
  if (tintColor == Color.TRANSPARENT) {
    Activity activity=(Activity)((View)param.thisObject).getContext();
    XPhoneStatusBar.changeColorAuto(activity,true);
  }
}",0.9720812182741116
37741,"@Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
  mContext=(Context)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
  X2oolsSharedPreferences prefs=new X2oolsSharedPreferences();
  boolean t9_search=prefs.getBoolean(X2oolsActivity.KEY_T9_SEARCH,true);
  if (t9_search) {
    Intent intent=new Intent();
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.setClassName(""String_Node_Str"",""String_Node_Str"");
    mContext.startActivity(intent);
  }
 else {
    XposedBridge.invokeOriginalMethod(param.method,param.thisObject,param.args);
  }
  return null;
}","@Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
  mContext=(Context)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
  X2oolsSharedPreferences prefs=new X2oolsSharedPreferences();
  boolean t9_search=prefs.getBoolean(X2oolsActivity.KEY_T9_SEARCH,true);
  if (t9_search) {
    ActivityManager am=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    if (am.getRunningTasks(1).get(0).topActivity.getClassName().equals(""String_Node_Str""))     return null;
    Intent intent=new Intent();
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.setClassName(""String_Node_Str"",""String_Node_Str"");
    mContext.startActivity(intent);
  }
 else {
    XposedBridge.invokeOriginalMethod(param.method,param.thisObject,param.args);
  }
  return null;
}",0.8675016479894528
37742,"public AppsGridView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mPackageManager=context.getPackageManager();
  mActivityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
  mLayoutInflater=LayoutInflater.from(context);
  setApplicationsData();
  new Thread(new Runnable(){
    @Override public void run(){
      sT9Search=new T9Search(mContext);
    }
  }
).start();
}","public AppsGridView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mPackageManager=context.getPackageManager();
  mActivityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
  mLayoutInflater=LayoutInflater.from(context);
  setApplicationsData();
  new Thread(new Runnable(){
    @Override public void run(){
      sT9Search=new T9Search(mContext);
      mHandler.sendEmptyMessage(MSG_SEARCH_INITED);
    }
  }
).start();
}",0.943355119825708
37743,"@Override public void run(){
  sT9Search=new T9Search(mContext);
}","@Override public void run(){
  sT9Search=new T9Search(mContext);
  mHandler.sendEmptyMessage(MSG_SEARCH_INITED);
}",0.7333333333333333
37744,"public void filter(String string){
  if (sT9Search == null)   return;
  if (TextUtils.isEmpty(string)) {
    apps=getRecentApps();
    mAppsAdapter=new AppsAdapter(apps);
    setAdapter(mAppsAdapter);
    mAppsAdapter.notifyDataSetChanged();
    return;
  }
  T9SearchResult result=sT9Search.search(string);
  if (result != null) {
    apps=sT9Search.search(string).getResults();
    mAppsAdapter=new AppsAdapter(apps);
    setAdapter(mAppsAdapter);
    mAppsAdapter.notifyDataSetChanged();
  }
}","public void filter(String string){
  mFilterStr=string;
  if (sT9Search == null)   return;
  if (TextUtils.isEmpty(string)) {
    apps=getRecentApps();
    mAppsAdapter=new AppsAdapter(apps);
    setAdapter(mAppsAdapter);
    mAppsAdapter.notifyDataSetChanged();
    return;
  }
  T9SearchResult result=sT9Search.search(string);
  if (result != null) {
    apps=sT9Search.search(string).getResults();
    mAppsAdapter=new AppsAdapter(apps);
    setAdapter(mAppsAdapter);
    mAppsAdapter.notifyDataSetChanged();
  }
}",0.979269496544916
37745,"public ArrayList<ApplicationItem> getRecentApps(){
  List<RecentTaskInfo> recentTasks=mActivityManager.getRecentTasks(9,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_WITH_EXCLUDED);
  ArrayList<ApplicationItem> recents=new ArrayList<ApplicationItem>();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + recentTasks);
  }
  if (recentTasks != null) {
    for (    RecentTaskInfo recentInfo : recentTasks) {
      try {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + recentInfo.baseIntent.getComponent().getPackageName());
        }
        ApplicationInfo info=mPackageManager.getApplicationInfo(recentInfo.baseIntent.getComponent().getPackageName(),0);
        boolean added=false;
        for (        ApplicationItem tmp : recents) {
          if (tmp.packageName.equals(info.packageName))           added=true;
        }
        if (!added) {
          ApplicationItem item=new ApplicationItem();
          item.name=info.loadLabel(mPackageManager).toString();
          item.packageName=info.packageName;
          item.drawable=info.loadIcon(mPackageManager);
          recents.add(item);
        }
      }
 catch (      NameNotFoundException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  return recents;
}","public ArrayList<ApplicationItem> getRecentApps(){
  List<RecentTaskInfo> recentTasks=mActivityManager.getRecentTasks(9,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_WITH_EXCLUDED);
  ArrayList<ApplicationItem> recents=new ArrayList<ApplicationItem>();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + recentTasks);
  }
  if (recentTasks != null) {
    for (    RecentTaskInfo recentInfo : recentTasks) {
      try {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + recentInfo.baseIntent.getComponent().getPackageName());
        }
        ApplicationInfo info=mPackageManager.getApplicationInfo(recentInfo.baseIntent.getComponent().getPackageName(),0);
        if (mPackageManager.getLaunchIntentForPackage(info.packageName) == null)         continue;
        boolean added=false;
        for (        ApplicationItem tmp : recents) {
          if (tmp.packageName.equals(info.packageName))           added=true;
        }
        if (!added) {
          ApplicationItem item=new ApplicationItem();
          item.name=info.loadLabel(mPackageManager).toString();
          item.packageName=info.packageName;
          item.drawable=info.loadIcon(mPackageManager);
          recents.add(item);
        }
      }
 catch (      NameNotFoundException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  return recents;
}",0.9623144271031596
37746,"public T9SearchResult search(String number){
  mNameResults.clear();
  number=removeNonDigits(number);
  int pos=0;
  boolean newQuery=mPrevInput == null || number.length() <= mPrevInput.length();
  for (  ApplicationItem item : (newQuery ? mApps : mAllResults)) {
    item.nameMatchId=-1;
    pos=item.pinyinNum.indexOf(number);
    if (pos != -1) {
      int last_space=item.pinyinNum.lastIndexOf(""String_Node_Str"",pos);
      if (last_space == -1) {
        last_space=0;
      }
      item.nameMatchId=pos - last_space;
      mNameResults.add(item);
    }
  }
  mAllResults.clear();
  mPrevInput=number;
  if (mNameResults.size() > 0) {
    mAllResults.addAll(mNameResults);
    return new T9SearchResult(new ArrayList<ApplicationItem>(mAllResults),mContext);
  }
  return null;
}","public T9SearchResult search(String number){
  mNameResults.clear();
  int pos=0;
  boolean newQuery=mPrevInput == null || number.length() <= mPrevInput.length();
  for (  ApplicationItem item : (newQuery ? mApps : mAllResults)) {
    pos=item.pinyinNum.indexOf(number);
    if (pos != -1) {
      mNameResults.add(item);
    }
    pos=item.fullpinyinNum.indexOf(number);
    if (pos != -1) {
      mNameResults.add(item);
    }
  }
  mAllResults.clear();
  mPrevInput=number;
  if (mNameResults.size() > 0) {
    mAllResults.addAll(mNameResults);
    return new T9SearchResult(new ArrayList<ApplicationItem>(mAllResults),mContext);
  }
  return null;
}",0.8225469728601252
37747,"private void getAll(){
  if (sT9Map == null)   initT9Map();
  mApplications=new ArrayList<ApplicationInfo>();
  mApplications.addAll(mPackageManager.getInstalledApplications(0));
  for (  ApplicationInfo appinfo : mApplications) {
    if (mPackageManager.getLaunchIntentForPackage(appinfo.packageName) == null)     continue;
    ApplicationItem appitem=new ApplicationItem();
    appitem.name=appinfo.loadLabel(mPackageManager).toString();
    appitem.pinyinNum=ToPinYinUtils.getPinyinNum(appitem.name);
    appitem.packageName=appinfo.packageName;
    appitem.drawable=appinfo.loadIcon(mPackageManager);
    mApps.add(appitem);
  }
}","private void getAll(){
  if (sT9Map == null)   initT9Map();
  mApplications=new ArrayList<ApplicationInfo>();
  mApplications.addAll(mPackageManager.getInstalledApplications(0));
  for (  ApplicationInfo appinfo : mApplications) {
    if (mPackageManager.getLaunchIntentForPackage(appinfo.packageName) == null)     continue;
    ApplicationItem appitem=new ApplicationItem();
    appitem.name=appinfo.loadLabel(mPackageManager).toString();
    appitem.pinyinNum=ToPinYinUtils.getPinyinNum(appitem.name,false);
    appitem.fullpinyinNum=ToPinYinUtils.getPinyinNum(appitem.name,true);
    appitem.packageName=appinfo.packageName;
    appitem.drawable=appinfo.loadIcon(mPackageManager);
    mApps.add(appitem);
  }
}",0.941351150705271
37748,"@SuppressLint(""String_Node_Str"") public static String getPinyinNum(String name){
  try {
    if (name != null && name.length() != 0) {
      int len=name.length();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < len; i++) {
        String tmp=name.substring(i);
        char c=tmp.charAt(0);
        if (c <= '9' && c >= '0') {
          sb.append(c);
        }
 else {
          sb.append(getOneNumFromAlpha(ToPinYinUtils.getPinYin(tmp).toLowerCase().charAt(0)));
        }
      }
      return sb.toString();
    }
  }
 catch (  BadHanyuPinyinOutputFormatCombination e) {
    e.printStackTrace();
  }
  return null;
}","@SuppressLint(""String_Node_Str"") public static String getPinyinNum(String name,boolean full){
  try {
    if (name != null && name.length() != 0) {
      int len=name.length();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < len; i++) {
        String tmp=name.substring(i);
        char c=tmp.charAt(0);
        if (c <= '9' && c >= '0') {
          sb.append(c);
        }
 else {
          if (full) {
            String pinyin=ToPinYinUtils.getPinYin(tmp).toLowerCase();
            for (int j=0; j < pinyin.length(); j++) {
              sb.append(getOneNumFromAlpha(pinyin.charAt(j)));
            }
          }
 else {
            sb.append(getOneNumFromAlpha(ToPinYinUtils.getPinYin(tmp).toLowerCase().charAt(0)));
          }
        }
      }
      return sb.toString();
    }
  }
 catch (  BadHanyuPinyinOutputFormatCombination e) {
    e.printStackTrace();
  }
  return null;
}",0.8255813953488372
37749,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preference);
  prefs=getPreferenceScreen().getSharedPreferences();
  updateJsonData();
}","@SuppressWarnings(""String_Node_Str"") @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preference);
  prefs=getPreferenceScreen().getSharedPreferences();
  updateX2oolsPrefs();
}",0.8847736625514403
37750,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (key.equals(KEY_WECHAT_SCAN)) {
    Intent intent=new Intent(ACTION_WECHAT_SCAN_CHANGED);
    intent.putExtra(KEY_WECHAT_SCAN,sharedPreferences.getBoolean(KEY_WECHAT_SCAN,false));
    sendBroadcast(intent);
  }
  updateJsonData();
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (key.equals(KEY_WECHAT_SCAN)) {
    Intent intent=new Intent(ACTION_WECHAT_SCAN_CHANGED);
    intent.putExtra(KEY_WECHAT_SCAN,sharedPreferences.getBoolean(KEY_WECHAT_SCAN,false));
    sendBroadcast(intent);
  }
  updateX2oolsPrefs();
}",0.9716840536512668
37751,"/** 
 * This is the main loop run by each Being of Middle-Earth who wants to gaze into a Palantir.
 */
public void run(){
  for (int i=0; i < mMaxPalantirSessions; ++i) {
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    mFairnessChecker.addNewThread(Thread.currentThread().getName());
    Palantir palantir=mPalantirManager.acquirePalantir();
    if (!mFairnessChecker.checkOrder(Thread.currentThread().getName()))     System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    long activeThreads=mActiveThreads.getAndIncrement();
    if (mMaxActiveThreads < activeThreads) {
      System.out.println(""String_Node_Str"" + activeThreads);
      throw new RuntimeException();
    }
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    palantir.gaze();
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    mPalantirManager.releasePalantir(palantir);
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    mActiveThreads.decrementAndGet();
  }
}","/** 
 * This is the main loop run by each Being of Middle-Earth who wants to gaze into a Palantir.
 */
public void run(){
  for (int i=0; i < mMaxPalantirSessions; ++i) {
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    mFairnessChecker.addNewThread(Thread.currentThread().getName());
    Palantir palantir=mPalantirManager.acquirePalantir();
    if (!mFairnessChecker.checkOrder(Thread.currentThread().getName()))     System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    long activeThreads=mActiveThreads.getAndIncrement();
    if (mMaxActiveThreads < activeThreads) {
      System.out.println(""String_Node_Str"" + activeThreads);
      throw new RuntimeException();
    }
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    palantir.gaze();
    mActiveThreads.decrementAndGet();
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
    mPalantirManager.releasePalantir(palantir);
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"");
  }
}",0.9647168059424328
37752,"/** 
 * @brief Atomically increments by one the current value
 * @returns the previous value
 */
public long getAndIncrement(){
  long value=0;
  return value;
}","/** 
 * @brief Atomically increments by one the current value
 * @returns the previous value
 */
public long getAndIncrement(){
  long value;
  return value;
}",0.99375
37753,"/** 
 * @brief Atomically increments by one the current value
 * @returns the updated value
 */
public long incrementAndGet(){
  long value=0;
  return value;
}","/** 
 * @brief Atomically increments by one the current value
 * @returns the updated value
 */
public long incrementAndGet(){
  long value;
  return value;
}",0.9937106918238994
37754,"/** 
 * Creates a new SimpleAtomicLong with the given initial value.
 */
public SimpleAtomicLong(long initialValue){
  long value=0;
}","/** 
 * Creates a new SimpleAtomicLong with the given initial value.
 */
public SimpleAtomicLong(long initialValue){
}",0.9365079365079364
37755,"/** 
 * @brief Gets the current value.
 * @returns The current value
 */
public long get(){
  long value=0;
  return value;
}","/** 
 * @brief Gets the current value.
 * @returns The current value
 */
public long get(){
  long value;
  return value;
}",0.9919354838709676
37756,"/** 
 * @brief Atomically decrements by one the current value
 * @returns the updated value
 */
public long decrementAndGet(){
  long value=0;
  return value;
}","/** 
 * @brief Atomically decrements by one the current value
 * @returns the updated value
 */
public long decrementAndGet(){
  long value;
  return value;
}",0.9937106918238994
37757,"/** 
 * @brief Atomically decrements by one the current value
 * @returns the previous value
 */
public long getAndDecrement(){
  long value=0;
  return value;
}","/** 
 * @brief Atomically decrements by one the current value
 * @returns the previous value
 */
public long getAndDecrement(){
  long value;
  return value;
}",0.99375
37758,"/** 
 * Returns the tuple descriptor (schema) of the specified table
 * @param tableid The id of the table, as specified by the DbFile.getId()function passed to addTable
 * @throws NoSuchElementException if the table doesn't exist
 */
public TupleDesc getTupleDesc(int tableid) throws NoSuchElementException {
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw NoSuchElementException;
  }
 else {
    DbFile file=match.getDbFile();
    return file.getTupleDesc();
  }
  return null;
}","/** 
 * Returns the tuple descriptor (schema) of the specified table
 * @param tableid The id of the table, as specified by the DbFile.getId()function passed to addTable
 * @throws NoSuchElementException if the table doesn't exist
 */
public TupleDesc getTupleDesc(int tableid) throws NoSuchElementException {
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw new NoSuchElementException();
  }
 else {
    DbFile file=match.getDbFile();
    return file.getTupleDesc();
  }
}",0.979062811565304
37759,"/** 
 * Constructor. Creates a new, empty catalog.
 */
public Catalog(){
  this.NameHash=new HashMap<String,Integer>();
  this.IdHash=new HashMap<String,Integer>();
}","/** 
 * Constructor. Creates a new, empty catalog.
 */
public Catalog(){
  this.NameHash=new HashMap<String,Table>();
  this.IdHash=new HashMap<Integer,Table>();
}",0.9300911854103344
37760,"/** 
 * Return the id of the table with a specified name,
 * @throws NoSuchElementException if the table doesn't exist
 */
public Integer getTableId(String name) throws NoSuchElementException {
  Table match=this.NameHash.get(name);
  if (match == null) {
    throw NoSuchElementException;
  }
 else {
    DbFile file=match.getDbFile();
    return Integer(file.getId());
  }
  return 0;
}","/** 
 * Return the id of the table with a specified name,
 * @throws NoSuchElementException if the table doesn't exist
 */
public Integer getTableId(String name) throws NoSuchElementException {
  Table match=this.NameHash.get(name);
  if (match == null) {
    throw new NoSuchElementException();
  }
 else {
    DbFile file=match.getDbFile();
    return file.getId();
  }
}",0.938239159001314
37761,"public String getPrimaryKey(int tableid){
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw NoSuchElementException;
  }
 else {
    return match.getPkeyField();
  }
  return null;
}","public String getPrimaryKey(int tableid){
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw new NoSuchElementException();
  }
 else {
    return match.getPkeyField();
  }
}",0.9473684210526316
37762,"/** 
 * Returns the DbFile that can be used to read the contents of the specified table.
 * @param tableid The id of the table, as specified by the DbFile.getId()function passed to addTable
 */
public DbFile getDatabaseFile(int tableid) throws NoSuchElementException {
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw NoSuchElementException;
  }
 else {
    return match.getDbFile();
  }
  return null;
}","/** 
 * Returns the DbFile that can be used to read the contents of the specified table.
 * @param tableid The id of the table, as specified by the DbFile.getId()function passed to addTable
 */
public DbFile getDatabaseFile(int tableid) throws NoSuchElementException {
  Table match=this.IdHash.get(tableid);
  if (match == null) {
    throw new NoSuchElementException();
  }
 else {
    return match.getDbFile();
  }
}",0.975206611570248
37763,"public Long saveCarInfo(Car car){
  Car savedCar=readCarInfo();
  if (savedCar != null) {
    savedCar=updateCar(car,savedCar);
  }
 else {
    Long wheelSavedId=saveWheel(savedCar.getWheel1());
    wheelSavedId=saveWheel(savedCar.getWheel2());
    wheelSavedId=saveWheel(savedCar.getWheel3());
    wheelSavedId=saveWheel(savedCar.getWheel4());
    savedCar=car;
  }
  return savedCar.save();
}","public Long saveCarInfo(Car car){
  Car savedCar=readCarInfo();
  if (savedCar != null) {
    savedCar=updateCar(car,savedCar);
  }
 else {
    savedCar=car;
    Long wheelSavedId=saveWheel(savedCar.getWheel1());
    wheelSavedId=saveWheel(savedCar.getWheel2());
    wheelSavedId=saveWheel(savedCar.getWheel3());
    wheelSavedId=saveWheel(savedCar.getWheel4());
  }
  return savedCar.save();
}",0.9543147208121828
37764,"public void cardReaded(Car car){
  wheel1.setText(Integer.toString(car.getWheel1().getRadius()));
  wheel2.setText(Integer.toString(car.getWheel2().getRadius()));
  wheel3.setText(Integer.toString(car.getWheel3().getRadius()));
  wheel4.setText(Integer.toString(car.getWheel4().getRadius()));
  description.setText(car.getDescription());
}","public void cardReaded(Car car){
  if (car != null) {
    wheel1.setText(Integer.toString(car.getWheel1().getRadius()));
    wheel2.setText(Integer.toString(car.getWheel2().getRadius()));
    wheel3.setText(Integer.toString(car.getWheel3().getRadius()));
    wheel4.setText(Integer.toString(car.getWheel4().getRadius()));
    description.setText(car.getDescription());
  }
}",0.9509116409537168
37765,"/** 
 * Determines if the cell satisfies the per species minimum interatomic distance constraints. Precondition: the perSpeciedMID option has been used
 */
public boolean satisfiesPerSpeciesMIDs(List<Triplet<Element,Element,Double>> mids){
  for (  Triplet<Element,Element,Double> mid : mids) {
    Element a=mid.getFirst();
    Element b=mid.getSecond();
    Double minid=mid.getThird();
    for (int i=0; i < getNumSites(); i++) {
      List<Site> sitesInSphere=getAtomsInSphereSorted(getSite(i).getCoords(),minid);
      if (sitesInSphere.size() == 1) {
        continue;
      }
 else {
        sitesInSphere.remove(0);
        for (        Site s : sitesInSphere) {
          Boolean passed=!(((getSite(i).getElement() == a) && (s.getElement() == b)) || ((getSite(i).getElement() == b) && (s.getElement() == a)));
          if (passed == false) {
            return false;
          }
        }
      }
    }
  }
  return true;
}","/** 
 * Determines if the cell satisfies the per species minimum interatomic distance constraints. Precondition: the perSpeciedMID option has been used
 */
public boolean satisfiesPerSpeciesMIDs(List<Triplet<Element,Element,Double>> mids){
  for (  Triplet<Element,Element,Double> mid : mids) {
    Element a=mid.getFirst();
    Element b=mid.getSecond();
    Double minid=mid.getThird();
    for (int i=0; i < getNumSites(); i++) {
      List<Site> sitesInSphere=getAtomsInSphereSorted(getSite(i).getCoords(),minid);
      if (sitesInSphere.size() <= 1) {
        continue;
      }
 else {
        sitesInSphere.remove(0);
        for (        Site s : sitesInSphere) {
          Boolean passed=!(((getSite(i).getElement() == a) && (s.getElement() == b)) || ((getSite(i).getElement() == b) && (s.getElement() == a)));
          if (passed == false) {
            return false;
          }
        }
      }
    }
  }
  return true;
}",0.9989293361884368
37766,"public boolean satisfiesPerSpeciesMIDs(List<Triplet<Element,Element,Double>> mids){
  for (  Triplet<Element,Element,Double> mid : mids) {
    Element a=mid.getFirst();
    Element b=mid.getSecond();
    Double minid=mid.getThird();
    for (int i=0; i < getNumSites(); i++) {
      List<Site> sitesInSphere=getAtomsInSphereSorted(getSite(i).getCoords(),minid);
      boolean sphereHasA=false;
      boolean sphereHasB=false;
      for (      Site s : sitesInSphere) {
        if (!sphereHasA && s.getElement().equals(a)) {
          sphereHasA=true;
          continue;
        }
        if (s.getElement().equals(b))         sphereHasB=true;
      }
      if (sphereHasA && sphereHasB)       return false;
    }
  }
  return true;
}","/** 
 * Determines if the cell satisfies the per species minimum interatomic distance constraints. Precondition: the perSpeciedMID option has been used
 */
public boolean satisfiesPerSpeciesMIDs(List<Triplet<Element,Element,Double>> mids){
  for (  Triplet<Element,Element,Double> mid : mids) {
    Element a=mid.getFirst();
    Element b=mid.getSecond();
    Double minid=mid.getThird();
    for (int i=0; i < getNumSites(); i++) {
      List<Site> sitesInSphere=getAtomsInSphereSorted(getSite(i).getCoords(),minid);
      if (sitesInSphere.size() == 1) {
        continue;
      }
 else {
        sitesInSphere.remove(0);
        for (        Site s : sitesInSphere) {
          Boolean passed=!(((getSite(i).getElement() == a) && (s.getElement() == b)) || ((getSite(i).getElement() == b) && (s.getElement() == a)));
          if (passed == false) {
            return false;
          }
        }
      }
    }
  }
  return true;
}",0.4796163069544364
37767,"public static void main(String args[]){
  List<Triplet<Element,Element,Double>> perSpeciesMIDs=new ArrayList<Triplet<Element,Element,Double>>();
  perSpeciesMIDs.add(new Triplet<Element,Element,Double>(Element.getElemFromSymbol(""String_Node_Str""),Element.getElemFromSymbol(""String_Node_Str""),0.02));
  Cell c=VaspOut.getPOSCAR(""String_Node_Str"");
  System.out.println(c.satisfiesPerSpeciesMIDs(perSpeciesMIDs));
}","public static void main(String args[]){
  List<Triplet<Element,Element,Double>> perSpeciesMIDs=new ArrayList<Triplet<Element,Element,Double>>();
  perSpeciesMIDs.add(new Triplet<Element,Element,Double>(Element.getElemFromSymbol(""String_Node_Str""),Element.getElemFromSymbol(""String_Node_Str""),1.13));
  perSpeciesMIDs.add(new Triplet<Element,Element,Double>(Element.getElemFromSymbol(""String_Node_Str""),Element.getElemFromSymbol(""String_Node_Str""),1.51));
  perSpeciesMIDs.add(new Triplet<Element,Element,Double>(Element.getElemFromSymbol(""String_Node_Str""),Element.getElemFromSymbol(""String_Node_Str""),1.84));
  Cell c=VaspOut.getPOSCAR(""String_Node_Str"");
  System.out.println(c.satisfiesPerSpeciesMIDs(perSpeciesMIDs));
}",0.7200704225352113
37768,"/** 
 * Rotates the cell into the principle directions and then removes vertical padding  from the cell without changing the relative positions of the atoms. The magnitude  of the vertical cell vector of the unpadded cell is equal to the vertical distance  between highest and lowest atoms in the cell plus the minimum interatomic distance  (mid). The atoms are arranged in the unpadded cell such that highest atom is mid/2  from the top of cell, and the lowest atom is mid/2 from the bottom of the cell.   
 */
private void unpadOrg(){
  Cell oldCell=org.getCell();
  if (oldCell == null)   return;
  oldCell=oldCell.getCellRotatedIntoPrincDirs();
  double mid;
  if (GAParameters.getParams().getMinInteratomicDistance() == -1) {
    mid=maxMID();
  }
 else {
    mid=GAParameters.getParams().getMinInteratomicDistance();
  }
  double minz=Double.MAX_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minz=Math.min(minz,cartComps.get(2));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(0.0,0.0,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}","/** 
 * Rotates the cell into the principle directions and then removes vertical padding  from the cell without changing the relative positions of the atoms. The magnitude  of the vertical cell vector of the unpadded cell is equal to the vertical distance  between highest and lowest atoms in the cell plus the minimum interatomic distance  (mid). The atoms are arranged in the unpadded cell such that the highest atom is  mid/2 from the top of cell, and the lowest atom is mid/2 from the bottom of the cell.   
 */
private void unpadOrg(){
  Cell oldCell=org.getCell();
  if (oldCell == null)   return;
  oldCell=oldCell.getCellRotatedIntoPrincDirs();
  double mid;
  if (GAParameters.getParams().getMinInteratomicDistance() == -1) {
    mid=maxMID();
  }
 else {
    mid=GAParameters.getParams().getMinInteratomicDistance();
  }
  double minz=Double.MAX_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minz=Math.min(minz,cartComps.get(2));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(0.0,0.0,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}",0.9887780548628428
37769,"public Boolean doDevelop(Generation gen,Organism o){
  StructureOrg s=(StructureOrg)o;
  Structures g=(Structures)gen;
  GAParameters params=GAParameters.getParams();
  double minid=params.getMinInteratomicDistance();
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  int maxatoms=params.getMaxNumAtoms();
  int minatoms=params.getMinNumAtoms();
  if (s.getCell() == null) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.knowsValue() && Double.isNaN(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.getCell().isMalformed()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.usingSubstrate()) {
    Cell oldCell=s.getCell();
    List<Vect> newBasis=params.getSubstrate().getLatticeVectors();
    List<Site> newSites=new ArrayList<Site>();
    for (    Site site : oldCell.getSites()) {
      site.getCoords().changeBasis(newBasis);
      newSites.add(site);
    }
    s.setCell(new Cell(newBasis,newSites,oldCell.getLabel()));
  }
  if (minid != -1) {
    if (!s.getCell().satisfiesMinInteratomicDistance(minid)) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (!s.getCell().satisfiesPerSpeciesMIDs(params.getPerSpeciesMIDs())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (useNiggliReducedCell) {
    s.standardize();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (use2DNiggliReducedCell) {
    s.standardize2D();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  Cell structure=s.getCell();
  if (minatoms != -1 && structure.getNumSites() < minatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (maxatoms != -1 && structure.getNumSites() > maxatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (structure.getComposition().getNumElements() < params.getMinNumSpecies() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ params.getMinNumSpecies()+ ""String_Node_Str""+ structure.getComposition().toString()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (Double.isInfinite(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getDoNonnegativityConstraint()) {
    if (s.knowsValue() && s.getValue() >= 0) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ s.getValue()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (params.getOptimizeDensity() && !s.knowsValue() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    double volume=GAParameters.getParams().getRecord().getBestDensityEstimate() * s.getCell().getNumSites();
    s.setCell(s.getCell().scaleTo(volume));
  }
  double[] lLengths=structure.getCellLengths();
  for (int i=0; i <= 2; i++) {
    if (minll != -1 && lLengths[i] < minll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxll != -1 && lLengths[i] > maxll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double[] lAngles=structure.getCellAnglesDegrees();
  for (int i=0; i <= 2; i++) {
    if (minla != -1 && lAngles[i] < minla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxla != -1 && lAngles[i] > maxla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (structure.getHeight() > GAParameters.getParams().getMaxCellHeight()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (!params.getCompSpace().contains(s.getCell().getComposition())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getMaxNearestNeighborLength() != 0) {
    List<Set<String>> excludedPairs=params.getNotNearestNeighbors();
    if (excludedPairs != null) {
      List<Site> sites=structure.getSites();
      for (int i=0; i < sites.size(); i++) {
        String symbol=sites.get(i).getElement().getSymbol();
        String otherSymb=null;
        for (        Set<String> pair : excludedPairs) {
          Iterator<String> k=pair.iterator();
          String first=k.next();
          String second=k.next();
          if (symbol == first)           otherSymb=second;
 else           if (symbol == second)           otherSymb=first;
 else           continue;
        }
        if (otherSymb == null)         continue;
        List<Site> atomsInSphere=structure.getAtomsInSphereSorted(sites.get(i).getCoords(),params.getMaxNearestNeighborLength());
        if (atomsInSphere.size() < 2)         continue;
        String nearestNeighbor=atomsInSphere.get(1).getElement().getSymbol();
        if (otherSymb.equalsIgnoreCase(nearestNeighbor)) {
          GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
          return false;
        }
      }
    }
  }
  if (usePerGenRG) {
    Integer orgID=g.getRedundancyGuard().checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      Organism org=g.getOrgByID(orgID);
      if (org != null && s.knowsValue() && s.getValue() < org.getValue()) {
        g.removeOrganism(org);
        g.addOrganism(s);
        GAOut.out().stdout(""String_Node_Str"" + orgID + ""String_Node_Str""+ s.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (useWholePopRG && !s.knowsValue()) {
    Integer orgID=rGuard.checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double dValue=params.getDValue();
  if (dValue != 0)   if (o.knowsValue()) {
    Organism[] orgs=g.getOrganismsOfValue(o.getValue(),dValue);
    if (orgs.length >= 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      if (o.getValue() < orgs[0].getValue()) {
        g.removeOrganism(orgs[0]);
        g.addOrganism(o);
        GAOut.out().stdout(""String_Node_Str"" + orgs[0].getID() + ""String_Node_Str""+ o.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (s.knowsValue() && params.usingSurrogateModel()) {
    surrogate.addEntry(s);
    if (surrogate.fails(s))     return false;
  }
  if (useWholePopRG)   rGuard.addStructureOrg(s);
  return true;
}","public Boolean doDevelop(Generation gen,Organism o){
  StructureOrg s=(StructureOrg)o;
  Structures g=(Structures)gen;
  GAParameters params=GAParameters.getParams();
  double minid=params.getMinInteratomicDistance();
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  int maxatoms=params.getMaxNumAtoms();
  int minatoms=params.getMinNumAtoms();
  if (s.getCell() == null) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.knowsValue() && Double.isNaN(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.getCell().isMalformed()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.usingSubstrate()) {
    Cell oldCell=s.getCell();
    Cell substrate=params.getSubstrate();
    List<Vect> newBasis=new ArrayList<Vect>();
    newBasis.add(substrate.getLatticeVectors().get(0));
    newBasis.add(substrate.getLatticeVectors().get(1));
    newBasis.add(oldCell.getLatticeVectors().get(2));
    List<Site> newSites=new ArrayList<Site>();
    for (    Site site : oldCell.getSites()) {
      Vect v=site.getCoords().changeBasis(newBasis);
      newSites.add(new Site(site.getElement(),v));
    }
    Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
    s.setCell(newCell);
  }
  if (minid != -1) {
    if (!s.getCell().satisfiesMinInteratomicDistance(minid)) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (!s.getCell().satisfiesPerSpeciesMIDs(params.getPerSpeciesMIDs())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (useNiggliReducedCell) {
    s.standardize();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (use2DNiggliReducedCell) {
    s.standardize2D();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  Cell structure=s.getCell();
  if (minatoms != -1 && structure.getNumSites() < minatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (maxatoms != -1 && structure.getNumSites() > maxatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (structure.getComposition().getNumElements() < params.getMinNumSpecies() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ params.getMinNumSpecies()+ ""String_Node_Str""+ structure.getComposition().toString()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (Double.isInfinite(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getDoNonnegativityConstraint()) {
    if (s.knowsValue() && s.getValue() >= 0) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ s.getValue()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (params.getOptimizeDensity() && !s.knowsValue() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    double volume=GAParameters.getParams().getRecord().getBestDensityEstimate() * s.getCell().getNumSites();
    s.setCell(s.getCell().scaleTo(volume));
  }
  double[] lLengths=structure.getCellLengths();
  for (int i=0; i <= 2; i++) {
    if (minll != -1 && lLengths[i] < minll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxll != -1 && lLengths[i] > maxll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double[] lAngles=structure.getCellAnglesDegrees();
  for (int i=0; i <= 2; i++) {
    if (minla != -1 && lAngles[i] < minla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxla != -1 && lAngles[i] > maxla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (structure.getHeight() > GAParameters.getParams().getMaxCellHeight()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (!params.getCompSpace().contains(s.getCell().getComposition())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getMaxNearestNeighborLength() != 0) {
    List<Set<String>> excludedPairs=params.getNotNearestNeighbors();
    if (excludedPairs != null) {
      List<Site> sites=structure.getSites();
      for (int i=0; i < sites.size(); i++) {
        String symbol=sites.get(i).getElement().getSymbol();
        String otherSymb=null;
        for (        Set<String> pair : excludedPairs) {
          Iterator<String> k=pair.iterator();
          String first=k.next();
          String second=k.next();
          if (symbol == first)           otherSymb=second;
 else           if (symbol == second)           otherSymb=first;
 else           continue;
        }
        if (otherSymb == null)         continue;
        List<Site> atomsInSphere=structure.getAtomsInSphereSorted(sites.get(i).getCoords(),params.getMaxNearestNeighborLength());
        if (atomsInSphere.size() < 2)         continue;
        String nearestNeighbor=atomsInSphere.get(1).getElement().getSymbol();
        if (otherSymb.equalsIgnoreCase(nearestNeighbor)) {
          GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
          return false;
        }
      }
    }
  }
  if (usePerGenRG) {
    Integer orgID=g.getRedundancyGuard().checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      Organism org=g.getOrgByID(orgID);
      if (org != null && s.knowsValue() && s.getValue() < org.getValue()) {
        g.removeOrganism(org);
        g.addOrganism(s);
        GAOut.out().stdout(""String_Node_Str"" + orgID + ""String_Node_Str""+ s.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (useWholePopRG && !s.knowsValue()) {
    Integer orgID=rGuard.checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double dValue=params.getDValue();
  if (dValue != 0)   if (o.knowsValue()) {
    Organism[] orgs=g.getOrganismsOfValue(o.getValue(),dValue);
    if (orgs.length >= 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      if (o.getValue() < orgs[0].getValue()) {
        g.removeOrganism(orgs[0]);
        g.addOrganism(o);
        GAOut.out().stdout(""String_Node_Str"" + orgs[0].getID() + ""String_Node_Str""+ o.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (s.knowsValue() && params.usingSurrogateModel()) {
    surrogate.addEntry(s);
    if (surrogate.fails(s))     return false;
  }
  if (useWholePopRG)   rGuard.addStructureOrg(s);
  return true;
}",0.9746331758269088
37770,"private Cell removeWhiteSpace(Cell oldCell){
  double[] bounds=super.getAtomBox(oldCell);
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  double c=bounds[1] - bounds[0];
  newBasis.add(new Vect(0.0,0.0,c));
  List<Site> newSites=new ArrayList<Site>();
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().plus(new Vect(0.0,0.0,bounds[0]))));
  return new Cell(newBasis,newSites,oldCell.getLabel());
}","public Cell removeWhiteSpace(Cell oldCell){
  double[] bounds=super.getAtomBox(oldCell);
  double zlen=bounds[1] - bounds[0];
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  double c=bounds[1] - bounds[0] + substrateDistance;
  newBasis.add(new Vect(0.0,0.0,c));
  List<Site> newSites=new ArrayList<Site>();
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(new Vect(0.0,0.0,bounds[0] - substrateDistance / 2))));
  return new Cell(newBasis,newSites,oldCell.getLabel());
}",0.5523156089193825
37771,"@Override public void padOrg(){
  Cell oldCell=org.getCell();
  oldCell.rotatedIntoPrincDirs();
  oldCell=removeWhiteSpace(oldCell);
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  double c=oldCell.getCellLengths()[2] + substrate.getCellLengths()[2] + substrateDistance;
  newBasis.add(new Vect(0.0,0.0,c));
  List<Site> newSites=new ArrayList<Site>();
  for (  Site s : substrate.getSites())   newSites.add(s);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().plus(new Vect(0.0,0.0,substrate.getCellLengths()[2] + substrateDistance))));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
  super.padOrg();
}","@Override public void padOrg(){
  Cell oldCell=org.getCell();
  oldCell.rotatedIntoPrincDirs();
  oldCell=removeWhiteSpace(oldCell);
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  double c=oldCell.getCellLengths()[2] + substrate.getCellLengths()[2];
  newBasis.add(new Vect(0.0,0.0,c));
  List<Site> newSites=new ArrayList<Site>();
  for (  Site s : substrate.getSites())   newSites.add(s);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(new Vect(0.0,0.0,substrate.getCellLengths()[2] + substrateDistance * 2))));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}",0.6833333333333333
37772,"public SubstrateObjFcn(List<String> subArray,Organism o){
  super(subArray,o);
  substrateDistance=Double.parseDouble(objFcnArgs.get(0));
  substrate=GAParameters.getParams().getSubstrate();
  substrate.rotatedIntoPrincDirs();
  substrate=removeWhiteSpace(substrate);
}","public SubstrateObjFcn(List<String> subArray,Organism o){
  super(subArray,o);
  substrateDistance=Double.parseDouble(objFcnArgs.get(0));
  substrate=VaspOut.getPOSCAR(""String_Node_Str"");
  substrate.rotatedIntoPrincDirs();
  substrate=removeWhiteSpace(substrate);
}",0.8672897196261682
37773,"public static void main(String[] args){
  Vect bob=new Vect(1.0,1.0,1.0);
  Vect e1=new Vect(3.0,0.0,0.0);
  Vect e2=new Vect(0.0,3.0,0.0);
  Vect e3=new Vect(0.0,0.0,3.0);
  List<Vect> basis=new ArrayList<Vect>();
  basis.add(e1);
  basis.add(e2);
  basis.add(e3);
  Vect shift=new Vect(-2.0,-1.0,-2.0);
  bob=bob.plusWRT(shift,basis);
  System.out.println(bob);
  List<Double> components=bob.getComponentsWRTBasis(basis);
  System.out.println(components.get(0) + ""String_Node_Str"" + components.get(1)+ ""String_Node_Str""+ components.get(2));
  System.out.println(e1.cross(e2));
  System.out.println(Vect.pointsAreCollinear(e1,e2,e3,0.0001));
}","public static void main(String[] args){
  Cell oldCell=VaspOut.getPOSCAR(""String_Node_Str"");
  Cell substrate=VaspOut.getPOSCAR(""String_Node_Str"");
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(substrate.getLatticeVectors().get(0));
  newBasis.add(substrate.getLatticeVectors().get(1));
  newBasis.add(oldCell.getLatticeVectors().get(2));
  List<Site> newSites=new ArrayList<Site>();
  for (  Site site : oldCell.getSites()) {
    Vect v=site.getCoords().changeBasis(newBasis);
    newSites.add(new Site(site.getElement(),v));
  }
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  VaspIn.writePoscar(newCell,""String_Node_Str"",true);
  VaspIn.writePoscar(oldCell,""String_Node_Str"",true);
}",0.2013225569434239
37774,"public void changeBasis(List<Vect> basis){
  this.basis=basis;
  frac=getComponentsWRTBasis(basis);
  setCartCoordToMatchFracCoord();
}","public Vect changeBasis(List<Vect> basis){
  return new Vect(this.frac,basis);
}",0.5488372093023256
37775,"private List<Double> getComponentsWRTBasis(List<Vect> basis){
  int dim=getDimension();
  if (basis.size() != dim)   throw new RuntimeException(""String_Node_Str"");
  List<Double> cartComps=getCartesianComponents();
  Matrix X=new Matrix(dim,1);
  for (int i=0; i < dim; i++)   X.set(i,0,cartComps.get(i));
  Matrix B=new Matrix(dim,dim);
  for (int i=0; i < dim; i++)   for (int j=0; j < dim; j++)   B.set(i,j,basis.get(j).getCartesianComponents().get(i));
  if (Math.abs(B.det()) < Constants.epsilon)   throw new IllegalArgumentException(""String_Node_Str"");
  Matrix A=B.inverse().times(X);
  List<Double> result=new ArrayList<Double>();
  for (int i=0; i < dim; i++)   result.add(A.get(i,0));
  return result;
}","public List<Double> getComponentsWRTBasis(List<Vect> basis){
  int dim=getDimension();
  if (basis.size() != dim)   throw new RuntimeException(""String_Node_Str"");
  List<Double> cartComps=getCartesianComponents();
  Matrix X=new Matrix(dim,1);
  for (int i=0; i < dim; i++)   X.set(i,0,cartComps.get(i));
  Matrix B=new Matrix(dim,dim);
  for (int i=0; i < dim; i++)   for (int j=0; j < dim; j++)   B.set(i,j,basis.get(j).getCartesianComponents().get(i));
  if (Math.abs(B.det()) < Constants.epsilon)   throw new IllegalArgumentException(""String_Node_Str"");
  Matrix A=B.inverse().times(X);
  List<Double> result=new ArrayList<Double>();
  for (int i=0; i < dim; i++)   result.add(A.get(i,0));
  return result;
}",0.992280701754386
37776,"public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  System.out.println(a.toString());
  for (int i=0; i < a.getNumSites(); i++) {
    System.out.println(a.getSite(i).toString());
    List<Site> sitesList=a.getAtomsInSphereSorted(a.getSite(i).getCoords(),.1);
    if (sitesList.size() > 1) {
      System.out.println(""String_Node_Str"" + sitesList.size());
    }
  }
}","public static void main(String args[]){
  Cell a=VaspOut.getPOSCAR(""String_Node_Str"");
  System.out.println(a.toString());
  System.out.println(a.getHeight());
}",0.4947368421052631
37777,"private void unpadOrg(){
  Cell oldCell=org.getCell();
  double mid=GAParameters.getParams().getMinInteratomicDistance();
  double minx=Double.MAX_VALUE;
  double miny=Double.MAX_VALUE;
  double minz=Double.MAX_VALUE;
  double maxx=Double.MIN_VALUE;
  double maxy=Double.MIN_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minx=Math.min(minx,cartComps.get(0));
    miny=Math.min(miny,cartComps.get(1));
    minz=Math.min(minz,cartComps.get(2));
    maxx=Math.max(maxx,cartComps.get(0));
    maxy=Math.max(maxy,cartComps.get(1));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double xlen=maxx - minx;
  double ylen=maxy - miny;
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(minx - mid / 2,miny - mid / 2,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(new Vect(xlen + mid,0.0,0.0));
  newBasis.add(new Vect(0.0,ylen + mid,0.0));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}","private void unpadOrg(){
  Cell oldCell=org.getCell();
  if (oldCell == null)   return;
  double mid=GAParameters.getParams().getMinInteratomicDistance();
  double minx=Double.MAX_VALUE;
  double miny=Double.MAX_VALUE;
  double minz=Double.MAX_VALUE;
  double maxx=Double.MIN_VALUE;
  double maxy=Double.MIN_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minx=Math.min(minx,cartComps.get(0));
    miny=Math.min(miny,cartComps.get(1));
    minz=Math.min(minz,cartComps.get(2));
    maxx=Math.max(maxx,cartComps.get(0));
    maxy=Math.max(maxy,cartComps.get(1));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double xlen=maxx - minx;
  double ylen=maxy - miny;
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(minx - mid / 2,miny - mid / 2,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(new Vect(xlen + mid,0.0,0.0));
  newBasis.add(new Vect(0.0,ylen + mid,0.0));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}",0.9870435806831568
37778,"public static void usage(String errorStr,Boolean die){
  System.out.println(""String_Node_Str"" + utility.BuildDate.buildDate);
  if (!errorStr.equals(""String_Node_Str"")) {
    System.out.println(errorStr);
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + GAParameters.getParams().getVerbosity() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (die)   System.exit(1);
}","public static void usage(String errorStr,Boolean die){
  System.out.println(""String_Node_Str"" + utility.BuildDate.buildDate);
  if (!errorStr.equals(""String_Node_Str"")) {
    System.out.println(errorStr);
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + GAParameters.getParams().getVerbosity() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (die)   System.exit(1);
}",0.993233206799802
37779,"public void setArgs(String[] args){
  ArgumentParser aParser;
  String inputFileName=null;
  for (int i=0; i < args.length - 1; i++) {
    if (args[i].equals(""String_Node_Str""))     inputFileName=args[i + 1];
  }
  if (inputFileName == null) {
    if (verbosity >= 3)     System.out.println(""String_Node_Str"");
    aParser=new ArgumentParser(args);
  }
 else {
    aParser=new ArgumentParser(args,inputFileName);
  }
  for (  Pair<String,List<String>> p : aParser.getOptions()) {
    String flag=p.getFirst();
    List<String> arguments=p.getSecond();
    if (flag.equals(""String_Node_Str""))     usage(""String_Node_Str"",true);
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     verbosity=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     runTitle=arguments.get(0);
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      outDirName=""String_Node_Str"";
      for (      String s : arguments)       outDirName+=s;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minInteratomicDistance=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxLatticeLength=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minLatticeLength=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxLatticeAngle=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minLatticeAngle=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxNumAtoms=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minNumAtoms=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minNumSpecies=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     doNonnegativityConstraint=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     dValue=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     endGameNumGens=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     useNiggliReducedCell=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     popSize=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     keepTempFiles=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     saveStateEachIter=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      redundancyGuardType=arguments.get(0);
      redundancyGuardArgs=Utility.subList(arguments,1);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      useSurrogate=true;
      surrogateArgs=arguments;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      optimizeDensity=true;
      if (optimizeDensity) {
        if (arguments.size() < 2)         usage(""String_Node_Str"",true);
        weightDenAdapt=Double.parseDouble(arguments.get(0));
        numDenAdapt=Integer.parseInt(arguments.get(1));
      }
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      maxNearestNeighborLength=Double.parseDouble(arguments.get(0));
      notNearestNeighbors=GAUtils.parsePairs(Utility.subList(arguments,1));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     dryRun=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      if (arguments.size() < 2)       usage(""String_Node_Str"",true);
      objFcnArgs=arguments;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      numCalcsInParallel=Integer.parseInt(arguments.get(0));
      minPopSize=Integer.parseInt(arguments.get(1));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       sel=new ProbDistSelection(Utility.subList(arguments,1));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       sel=null;
 else       usage(""String_Node_Str"" + arguments.get(0),true);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.size() < 3)       usage(""String_Node_Str"",true);
      String variation=arguments.get(2);
      initialVarProbs.add(Double.parseDouble(arguments.get(0)));
      endgameVarProbs.add(Double.parseDouble(arguments.get(1)));
      if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new Slicer(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new StructureMut(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new Permutation(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new NumStoichsMut(Utility.subList(arguments,3)));
 else       usage(""String_Node_Str"" + variation,true);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumFunctionEvalsCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumGensCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumGensWOImprCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new ValueAchievedCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new FoundStructureCC(Utility.subList(arguments,1)));
 else       usage(""String_Node_Str"" + arguments.get(0),true);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      pro=new Promotion(arguments);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.size() < 2)       this.usage(""String_Node_Str"",true);
      Integer numOrgs=new Integer(Integer.parseInt(arguments.get(0)));
      String creatorType=arguments.get(1);
      if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new RandomSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new ManualSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new GivenSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new UnitsSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else {
        usage(""String_Node_Str"" + creatorType,true);
      }
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      List<String> csArgs=new LinkedList<String>();
      for (      String s : p.getSecond())       csArgs.add(s);
      compSpace=new CompositionSpace(csArgs,false);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      writeHartkeFile=Boolean.parseBoolean(arguments.get(0));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      colorOutput=Boolean.parseBoolean(arguments.get(0));
    }
 else     if (!flag.equalsIgnoreCase(""String_Node_Str"") && verbosity >= 1)     System.out.println(""String_Node_Str"" + flag);
  }
  dev=new StructureDev();
  if (outDirName == null)   outDirName=new String(""String_Node_Str"" + runTitle);
  checkInputs();
}","public void setArgs(String[] args){
  ArgumentParser aParser;
  String inputFileName=null;
  for (int i=0; i < args.length - 1; i++) {
    if (args[i].equals(""String_Node_Str""))     inputFileName=args[i + 1];
  }
  if (inputFileName == null) {
    if (verbosity >= 3)     System.out.println(""String_Node_Str"");
    aParser=new ArgumentParser(args);
  }
 else {
    aParser=new ArgumentParser(args,inputFileName);
  }
  for (  Pair<String,List<String>> p : aParser.getOptions()) {
    String flag=p.getFirst();
    List<String> arguments=p.getSecond();
    if (flag.equals(""String_Node_Str""))     usage(""String_Node_Str"",true);
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     verbosity=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     runTitle=arguments.get(0);
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      outDirName=""String_Node_Str"";
      for (      String s : arguments)       outDirName+=s;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minInteratomicDistance=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxLatticeLength=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minLatticeLength=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxLatticeAngle=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minLatticeAngle=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxCellHeight=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     maxNumAtoms=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minNumAtoms=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     minNumSpecies=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     doNonnegativityConstraint=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     dValue=Double.parseDouble(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     endGameNumGens=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     useNiggliReducedCell=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     popSize=Integer.parseInt(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     keepTempFiles=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     saveStateEachIter=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      redundancyGuardType=arguments.get(0);
      redundancyGuardArgs=Utility.subList(arguments,1);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      useSurrogate=true;
      surrogateArgs=arguments;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      optimizeDensity=true;
      if (optimizeDensity) {
        if (arguments.size() < 2)         usage(""String_Node_Str"",true);
        weightDenAdapt=Double.parseDouble(arguments.get(0));
        numDenAdapt=Integer.parseInt(arguments.get(1));
      }
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      maxNearestNeighborLength=Double.parseDouble(arguments.get(0));
      notNearestNeighbors=GAUtils.parsePairs(Utility.subList(arguments,1));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str""))     dryRun=Boolean.parseBoolean(arguments.get(0));
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      if (arguments.size() < 2)       usage(""String_Node_Str"",true);
      objFcnArgs=arguments;
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      numCalcsInParallel=Integer.parseInt(arguments.get(0));
      minPopSize=Integer.parseInt(arguments.get(1));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       sel=new ProbDistSelection(Utility.subList(arguments,1));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       sel=null;
 else       usage(""String_Node_Str"" + arguments.get(0),true);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.size() < 3)       usage(""String_Node_Str"",true);
      String variation=arguments.get(2);
      initialVarProbs.add(Double.parseDouble(arguments.get(0)));
      endgameVarProbs.add(Double.parseDouble(arguments.get(1)));
      if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new Slicer(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new StructureMut(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new Permutation(Utility.subList(arguments,3)));
 else       if (variation.equalsIgnoreCase(""String_Node_Str""))       vars.add(new NumStoichsMut(Utility.subList(arguments,3)));
 else       usage(""String_Node_Str"" + variation,true);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumFunctionEvalsCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumGensCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new NumGensWOImprCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new ValueAchievedCC(Utility.subList(arguments,1)));
 else       if (arguments.get(0).equalsIgnoreCase(""String_Node_Str""))       ccs.add(new FoundStructureCC(Utility.subList(arguments,1)));
 else       usage(""String_Node_Str"" + arguments.get(0),true);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      pro=new Promotion(arguments);
    }
 else     if (flag.toLowerCase().startsWith(""String_Node_Str"")) {
      if (arguments.size() < 2)       this.usage(""String_Node_Str"",true);
      Integer numOrgs=new Integer(Integer.parseInt(arguments.get(0)));
      String creatorType=arguments.get(1);
      if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new RandomSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new ManualSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new GivenSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else       if (creatorType.equalsIgnoreCase(""String_Node_Str"")) {
        initialOrgCreators.add(new Pair<StructureOrgCreator,Integer>(new UnitsSOCreator(Utility.subList(arguments,2)),numOrgs));
      }
 else {
        usage(""String_Node_Str"" + creatorType,true);
      }
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      List<String> csArgs=new LinkedList<String>();
      for (      String s : p.getSecond())       csArgs.add(s);
      compSpace=new CompositionSpace(csArgs,false);
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      writeHartkeFile=Boolean.parseBoolean(arguments.get(0));
    }
 else     if (flag.equalsIgnoreCase(""String_Node_Str"")) {
      colorOutput=Boolean.parseBoolean(arguments.get(0));
    }
 else     if (!flag.equalsIgnoreCase(""String_Node_Str"") && verbosity >= 1)     System.out.println(""String_Node_Str"" + flag);
  }
  dev=new StructureDev();
  if (outDirName == null)   outDirName=new String(""String_Node_Str"" + runTitle);
  checkInputs();
}",0.9929833354216264
37780,"public static List<Vect> makeRandomLattice(){
  GAParameters params=GAParameters.getParams();
  if (params.getMaxLatticeAngleDegrees() == -1 || params.getMinLatticeAngleDegrees() == -1 || params.getMaxLatticeLength() == -1 || params.getMinLatticeLength() == -1)   GAParameters.usage(""String_Node_Str"",true);
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  Random rand=params.getRandom();
  double la=rand.nextDouble() * (maxll - minll) + minll;
  double lb=rand.nextDouble() * (maxll - minll) + minll;
  double lc=rand.nextDouble() * (maxll - minll) + minll;
  double adeg, bdeg, gdeg;
  do {
    adeg=(rand.nextDouble() * (maxla - minla) + minla);
    bdeg=(rand.nextDouble() * (maxla - minla) + minla);
    gdeg=(rand.nextDouble() * (maxla - minla) + minla);
  }
 while (!GAUtils.satisfiesTriangleInequality(adeg,bdeg,gdeg) || adeg + bdeg + gdeg >= 360);
  return (new Cell(la,lb,lc,adeg,bdeg,gdeg,null,null)).getLatticeVectors();
}","public static List<Vect> makeRandomLattice(){
  GAParameters params=GAParameters.getParams();
  if (params.getMaxLatticeAngleDegrees() == -1 || params.getMinLatticeAngleDegrees() == -1 || params.getMaxLatticeLength() == -1 || params.getMinLatticeLength() == -1)   GAParameters.usage(""String_Node_Str"",true);
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  double maxch=params.getMaxCellHeight();
  Random rand=params.getRandom();
  double adeg, bdeg, gdeg;
  do {
    adeg=(rand.nextDouble() * (maxla - minla) + minla);
    bdeg=(rand.nextDouble() * (maxla - minla) + minla);
    gdeg=(rand.nextDouble() * (maxla - minla) + minla);
  }
 while (!GAUtils.satisfiesTriangleInequality(adeg,bdeg,gdeg) || adeg + bdeg + gdeg >= 360);
  double la=rand.nextDouble() * (maxll - minll) + minll;
  double lb=rand.nextDouble() * (maxll - minll) + minll;
  double maxZll=Math.min(maxll,2 * maxch);
  double lc=rand.nextDouble() * (maxZll - minll) + minll;
  return (new Cell(la,lb,lc,adeg,bdeg,gdeg,null,null)).getLatticeVectors();
}",0.8094390026714159
37781,"public Boolean doDevelop(Generation gen,Organism o){
  StructureOrg s=(StructureOrg)o;
  Structures g=(Structures)gen;
  GAParameters params=GAParameters.getParams();
  double minid=params.getMinInteratomicDistance();
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  int maxatoms=params.getMaxNumAtoms();
  int minatoms=params.getMinNumAtoms();
  if (s.getCell() == null) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.knowsValue() && Double.isNaN(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.getCell().isMalformed()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (minid != -1)   for (int i=0; i < s.getCell().getNumSites(); i++) {
    List<Site> sitesInSphere=s.getCell().getAtomsInSphereSorted(s.getCell().getSite(i).getCoords(),minid);
    if (sitesInSphere.size() > 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (useNiggliReducedCell) {
    s.standardize();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  Cell structure=s.getCell();
  if (minatoms != -1 && structure.getNumSites() < minatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (maxatoms != -1 && structure.getNumSites() > maxatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (structure.getComposition().getNumElements() < params.getMinNumSpecies() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getComposition().toString()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (Double.isInfinite(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getDoNonnegativityConstraint()) {
    if (s.knowsValue() && s.getValue() >= 0) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ s.getValue()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (params.getOptimizeDensity() && !s.knowsValue() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    double volume=GAParameters.getParams().getRecord().getBestDensityEstimate() * s.getCell().getNumSites();
    s.setCell(s.getCell().scaleTo(volume));
  }
  double[] lLengths=structure.getCellLengths();
  for (int i=0; i <= 2; i++) {
    if (minll != -1 && lLengths[i] < minll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxll != -1 && lLengths[i] > maxll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double[] lAngles=structure.getCellAnglesDegrees();
  for (int i=0; i <= 2; i++) {
    if (minla != -1 && lAngles[i] < minla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxla != -1 && lAngles[i] > maxla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (!params.getCompSpace().contains(s.getCell().getComposition())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getMaxNearestNeighborLength() != 0) {
    List<Set<String>> excludedPairs=params.getNotNearestNeighbors();
    if (excludedPairs != null) {
      List<Site> sites=structure.getSites();
      for (int i=0; i < sites.size(); i++) {
        String symbol=sites.get(i).getElement().getSymbol();
        String otherSymb=null;
        for (        Set<String> pair : excludedPairs) {
          Iterator<String> k=pair.iterator();
          String first=k.next();
          String second=k.next();
          if (symbol == first)           otherSymb=second;
 else           if (symbol == second)           otherSymb=first;
 else           continue;
        }
        if (otherSymb == null)         continue;
        List<Site> atomsInSphere=structure.getAtomsInSphereSorted(sites.get(i).getCoords(),params.getMaxNearestNeighborLength());
        if (atomsInSphere.size() < 2)         continue;
        String nearestNeighbor=atomsInSphere.get(1).getElement().getSymbol();
        if (otherSymb.equalsIgnoreCase(nearestNeighbor)) {
          GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
          return false;
        }
      }
    }
  }
  if (usePerGenRG) {
    Integer orgID=g.getRedundancyGuard().checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      Organism org=g.getOrgByID(orgID);
      if (org != null && s.knowsValue() && s.getValue() < org.getValue()) {
        g.removeOrganism(org);
        g.addOrganism(s);
        GAOut.out().stdout(""String_Node_Str"" + orgID + ""String_Node_Str""+ s.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (useWholePopRG && !s.knowsValue()) {
    Integer orgID=rGuard.checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double dValue=params.getDValue();
  if (dValue != 0)   if (o.knowsValue()) {
    Organism[] orgs=g.getOrganismsOfValue(o.getValue(),dValue);
    if (orgs.length >= 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      if (o.getValue() < orgs[0].getValue()) {
        g.removeOrganism(orgs[0]);
        g.addOrganism(o);
        GAOut.out().stdout(""String_Node_Str"" + orgs[0].getID() + ""String_Node_Str""+ o.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (s.knowsValue() && params.usingSurrogateModel()) {
    surrogate.addEntry(s);
    if (surrogate.fails(s))     return false;
  }
  if (useWholePopRG)   rGuard.addStructureOrg(s);
  return true;
}","public Boolean doDevelop(Generation gen,Organism o){
  StructureOrg s=(StructureOrg)o;
  Structures g=(Structures)gen;
  GAParameters params=GAParameters.getParams();
  double minid=params.getMinInteratomicDistance();
  double maxll=params.getMaxLatticeLength();
  double minll=params.getMinLatticeLength();
  double maxla=params.getMaxLatticeAngleDegrees();
  double minla=params.getMinLatticeAngleDegrees();
  int maxatoms=params.getMaxNumAtoms();
  int minatoms=params.getMinNumAtoms();
  if (s.getCell() == null) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.knowsValue() && Double.isNaN(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (s.getCell().isMalformed()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (minid != -1)   for (int i=0; i < s.getCell().getNumSites(); i++) {
    List<Site> sitesInSphere=s.getCell().getAtomsInSphereSorted(s.getCell().getSite(i).getCoords(),minid);
    if (sitesInSphere.size() > 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (useNiggliReducedCell) {
    s.standardize();
    if (!s.isReduced()) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  Cell structure=s.getCell();
  if (minatoms != -1 && structure.getNumSites() < minatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (maxatoms != -1 && structure.getNumSites() > maxatoms) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getNumSites()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (structure.getComposition().getNumElements() < params.getMinNumSpecies() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ structure.getComposition().toString()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (Double.isInfinite(s.getEnergyPerAtom())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getDoNonnegativityConstraint()) {
    if (s.knowsValue() && s.getValue() >= 0) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ s.getValue()+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (params.getOptimizeDensity() && !s.knowsValue() && GAParameters.getParams().getRecord().getGenNum() != 0) {
    double volume=GAParameters.getParams().getRecord().getBestDensityEstimate() * s.getCell().getNumSites();
    s.setCell(s.getCell().scaleTo(volume));
  }
  double[] lLengths=structure.getCellLengths();
  for (int i=0; i <= 2; i++) {
    if (minll != -1 && lLengths[i] < minll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxll != -1 && lLengths[i] > maxll) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lLengths[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double[] lAngles=structure.getCellAnglesDegrees();
  for (int i=0; i <= 2; i++) {
    if (minla != -1 && lAngles[i] < minla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
    if (maxla != -1 && lAngles[i] > maxla) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ i+ ""String_Node_Str""+ lAngles[i]+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  if (structure.getHeight() > GAParameters.getParams().getMaxCellHeight()) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (!params.getCompSpace().contains(s.getCell().getComposition())) {
    GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
    return false;
  }
  if (params.getMaxNearestNeighborLength() != 0) {
    List<Set<String>> excludedPairs=params.getNotNearestNeighbors();
    if (excludedPairs != null) {
      List<Site> sites=structure.getSites();
      for (int i=0; i < sites.size(); i++) {
        String symbol=sites.get(i).getElement().getSymbol();
        String otherSymb=null;
        for (        Set<String> pair : excludedPairs) {
          Iterator<String> k=pair.iterator();
          String first=k.next();
          String second=k.next();
          if (symbol == first)           otherSymb=second;
 else           if (symbol == second)           otherSymb=first;
 else           continue;
        }
        if (otherSymb == null)         continue;
        List<Site> atomsInSphere=structure.getAtomsInSphereSorted(sites.get(i).getCoords(),params.getMaxNearestNeighborLength());
        if (atomsInSphere.size() < 2)         continue;
        String nearestNeighbor=atomsInSphere.get(1).getElement().getSymbol();
        if (otherSymb.equalsIgnoreCase(nearestNeighbor)) {
          GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
          return false;
        }
      }
    }
  }
  if (usePerGenRG) {
    Integer orgID=g.getRedundancyGuard().checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      Organism org=g.getOrgByID(orgID);
      if (org != null && s.knowsValue() && s.getValue() < org.getValue()) {
        g.removeOrganism(org);
        g.addOrganism(s);
        GAOut.out().stdout(""String_Node_Str"" + orgID + ""String_Node_Str""+ s.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (useWholePopRG && !s.knowsValue()) {
    Integer orgID=rGuard.checkStructureOrg(s);
    if (orgID != null) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str""+ orgID+ ""String_Node_Str"",GAOut.NOTICE,s.getID());
      return false;
    }
  }
  double dValue=params.getDValue();
  if (dValue != 0)   if (o.knowsValue()) {
    Organism[] orgs=g.getOrganismsOfValue(o.getValue(),dValue);
    if (orgs.length >= 1) {
      GAOut.out().stdout(""String_Node_Str"" + s.getID() + ""String_Node_Str"",GAOut.NOTICE,s.getID());
      if (o.getValue() < orgs[0].getValue()) {
        g.removeOrganism(orgs[0]);
        g.addOrganism(o);
        GAOut.out().stdout(""String_Node_Str"" + orgs[0].getID() + ""String_Node_Str""+ o.getID(),GAOut.INFO,s.getID());
      }
      return false;
    }
  }
  if (s.knowsValue() && params.usingSurrogateModel()) {
    surrogate.addEntry(s);
    if (surrogate.fails(s))     return false;
  }
  if (useWholePopRG)   rGuard.addStructureOrg(s);
  return true;
}",0.9779179810725552
37782,"private void unpadOrg(){
  Cell oldCell=org.getCell();
  double mid=GAParameters.getParams().getMinInteratomicDistance();
  double minz=Double.MAX_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minz=Math.min(minz,cartComps.get(2));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(0.0,0.0,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}","private void unpadOrg(){
  Cell oldCell=org.getCell();
  if (oldCell == null)   return;
  double mid=GAParameters.getParams().getMinInteratomicDistance();
  double minz=Double.MAX_VALUE;
  double maxz=Double.MIN_VALUE;
  for (  Site s : oldCell.getSites()) {
    List<Double> cartComps=s.getCoords().getCartesianComponents();
    minz=Math.min(minz,cartComps.get(2));
    maxz=Math.max(maxz,cartComps.get(2));
  }
  double zlen=maxz - minz;
  List<Site> newSites=new ArrayList<Site>();
  Vect minv=new Vect(0.0,0.0,minz - mid / 2);
  for (  Site s : oldCell.getSites())   newSites.add(new Site(s.getElement(),s.getCoords().subtract(minv)));
  List<Vect> newBasis=new ArrayList<Vect>();
  newBasis.add(oldCell.getLatticeVectors().get(0));
  newBasis.add(oldCell.getLatticeVectors().get(1));
  newBasis.add(new Vect(0.0,0.0,zlen + mid));
  Cell newCell=new Cell(newBasis,newSites,oldCell.getLabel());
  org.setCell(newCell,false);
}",0.9819376026272578
37783,"public static void runMopac(StructureOrg c){
  GAParameters params=GAParameters.getParams();
  String input=writeInput(c);
  String s=null;
  BufferedReader stdInput=null;
  BufferedReader stdError=null;
  try {
    Process p=Runtime.getRuntime().exec(execpath + ""String_Node_Str"" + input);
    stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));
    stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()));
    while ((s=stdInput.readLine()) != null) {
      GAOut.out().stdout(s,GAOut.DEBUG);
    }
    while ((s=stdError.readLine()) != null) {
      System.out.println(s);
    }
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-1);
  }
 finally {
    if (stdInput != null)     try {
      stdInput.close();
    }
 catch (    Exception x) {
    }
    if (stdError != null)     try {
      stdError.close();
    }
 catch (    Exception x) {
    }
  }
  if (parseStructure(c,params.getTempDirName() + ""String_Node_Str"" + c.getID()+ ""String_Node_Str"") == null) {
    GAOut.out().stdout(""String_Node_Str"",GAOut.WARNING,c.getID());
  }
 else {
    Cell p=parseStructure(c,params.getTempDirName() + ""String_Node_Str"" + c.getID()+ ""String_Node_Str"");
    c.setCell(p);
  }
}","public static void runMopac(StructureOrg c){
  GAParameters params=GAParameters.getParams();
  String input=writeInput(c);
  String s=null;
  BufferedReader stdInput=null;
  BufferedReader stdError=null;
  try {
    Process p=Runtime.getRuntime().exec(execpath + ""String_Node_Str"" + input);
    stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));
    stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()));
    while ((s=stdInput.readLine()) != null) {
      GAOut.out().stdout(s,GAOut.DEBUG);
    }
    while ((s=stdError.readLine()) != null) {
      System.out.println(s);
    }
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-1);
  }
 finally {
    if (stdInput != null)     try {
      stdInput.close();
    }
 catch (    Exception x) {
    }
    if (stdError != null)     try {
      stdError.close();
    }
 catch (    Exception x) {
    }
  }
  Cell p=parseStructure(c,params.getTempDirName() + ""String_Node_Str"" + c.getID()+ ""String_Node_Str"");
  c.setCell(p);
}",0.8939458995276943
37784,"public static Cell parseStructure(StructureOrg c,String output){
  GAParameters params=GAParameters.getParams();
  List<Site> sites=c.getCell().getSites();
  List<Vect> newVects=new LinkedList<Vect>();
  List<Site> newSites=new LinkedList<Site>();
  String line=null;
  Pattern goodPattern=Pattern.compile(""String_Node_Str"");
  Matcher goodMatcher=goodPattern.matcher(output);
  try {
    BufferedReader t=new BufferedReader(new FileReader(output));
    try {
      while ((line=t.readLine()) != null) {
        goodMatcher.reset(line);
        if (goodMatcher.find()) {
          System.out.println(""String_Node_Str"");
          return c.getCell();
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  line=null;
  Pattern coordsPattern=Pattern.compile(""String_Node_Str"");
  Matcher coordsMatcher=coordsPattern.matcher(output);
  try {
    BufferedReader r=new BufferedReader(new FileReader(output));
    try {
      while ((line=r.readLine()) != null) {
        coordsMatcher.reset(line);
        if (coordsMatcher.find()) {
          r.readLine();
          r.readLine();
          for (int e=0; e < (3 * sites.size() + 16); e++) {
            r.readLine();
          }
          line=r.readLine();
          coordsMatcher.reset(line);
          try {
            for (            Site s : sites) {
              StringTokenizer t=new StringTokenizer(line);
              t.nextToken();
              t.nextToken();
              Double x=Double.parseDouble(t.nextToken());
              t.nextToken();
              Double y=Double.parseDouble(t.nextToken());
              t.nextToken();
              Double z=Double.parseDouble(t.nextToken());
              Vect v=new Vect(x,y,z);
              newSites.add(new Site(s.getElement(),v));
              line=r.readLine();
            }
            for (int k=0; k < Constants.numDimensions; k++) {
              StringTokenizer m=new StringTokenizer(line);
              m.nextToken();
              m.nextToken();
              Double x=Double.parseDouble(m.nextToken());
              m.nextToken();
              Double y=Double.parseDouble(m.nextToken());
              m.nextToken();
              Double z=Double.parseDouble(m.nextToken());
              Vect v=new Vect(x,y,z);
              newVects.add(v);
              line=r.readLine();
            }
          }
 catch (          NumberFormatException x) {
            GAOut.out().stdout(""String_Node_Str"" + x.getMessage(),GAOut.NOTICE,c.getID());
            GAOut.out().stdout(""String_Node_Str"",GAOut.DEBUG,c.getID());
            GAOut.out().stdout(output,GAOut.DEBUG,c.getID());
          }
          break;
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  Cell p=new Cell(newVects,newSites);
  return p;
}","public static Cell parseStructure(StructureOrg c,String output){
  GAParameters params=GAParameters.getParams();
  List<Site> sites=c.getCell().getSites();
  List<Vect> newVects=new LinkedList<Vect>();
  List<Site> newSites=new LinkedList<Site>();
  String line=null;
  Pattern goodPattern=Pattern.compile(""String_Node_Str"");
  Matcher goodMatcher=goodPattern.matcher(output);
  try {
    BufferedReader t=new BufferedReader(new FileReader(output));
    try {
      while ((line=t.readLine()) != null) {
        goodMatcher.reset(line);
        if (goodMatcher.find()) {
          System.out.println(""String_Node_Str"");
          return c.getCell();
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  line=null;
  Pattern coordsPattern=Pattern.compile(""String_Node_Str"");
  Matcher coordsMatcher=coordsPattern.matcher(output);
  try {
    BufferedReader r=new BufferedReader(new FileReader(output));
    try {
      while ((line=r.readLine()) != null) {
        coordsMatcher.reset(line);
        if (coordsMatcher.find()) {
          r.readLine();
          r.readLine();
          for (int e=0; e < (3 * sites.size() + 16); e++) {
            r.readLine();
          }
          line=r.readLine();
          coordsMatcher.reset(line);
          try {
            for (            Site s : sites) {
              StringTokenizer t=new StringTokenizer(line);
              t.nextToken();
              t.nextToken();
              Double x=Double.parseDouble(t.nextToken());
              t.nextToken();
              Double y=Double.parseDouble(t.nextToken());
              t.nextToken();
              Double z=Double.parseDouble(t.nextToken());
              Vect v=new Vect(x,y,z);
              newSites.add(new Site(s.getElement(),v));
              line=r.readLine();
            }
            for (int k=0; k < Constants.numDimensions; k++) {
              StringTokenizer m=new StringTokenizer(line);
              m.nextToken();
              m.nextToken();
              Double x=Double.parseDouble(m.nextToken());
              m.nextToken();
              Double y=Double.parseDouble(m.nextToken());
              m.nextToken();
              Double z=Double.parseDouble(m.nextToken());
              Vect v=new Vect(x,y,z);
              newVects.add(v);
              line=r.readLine();
            }
          }
 catch (          NumberFormatException x) {
            GAOut.out().stdout(""String_Node_Str"" + x.getMessage(),GAOut.NOTICE,c.getID());
            GAOut.out().stdout(""String_Node_Str"",GAOut.DEBUG,c.getID());
            GAOut.out().stdout(output,GAOut.DEBUG,c.getID());
          }
          break;
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  Cell p;
  try {
    p=new Cell(newVects,newSites);
  }
 catch (  Exception x) {
    GAOut.out().stdout(""String_Node_Str"",GAOut.WARNING,0);
    GAOut.out().stdout(""String_Node_Str"" + output,GAOut.WARNING,0);
    x.printStackTrace();
    p=null;
  }
  return p;
}",0.9648425557933352
37785,"private static Organism makeFirstGenOrg(Generation offspring){
  GAParameters params=GAParameters.getParams();
  Development dev=params.getDevelopment();
  List<Pair<StructureOrgCreator,Integer>> initialOrgCreators=params.getInitialOrgCreators();
  StructureOrg newOrg=null;
  while (newOrg == null) {
    int socIndx=0;
    while (initialOrgCreators.size() > socIndx && initialOrgCreators.get(socIndx).getSecond() <= 0)     socIndx++;
    if (initialOrgCreators.size() <= socIndx)     return null;
    StructureOrgCreator soc=initialOrgCreators.get(socIndx).getFirst();
    do {
      newOrg=soc.makeOrganism(offspring);
    }
 while (newOrg != null && dev != null && !dev.doDevelop(offspring,newOrg));
    if (newOrg != null)     newOrg.setSOCreator(soc);
 else     initialOrgCreators.set(socIndx,new Pair<StructureOrgCreator,Integer>(soc,0));
    GAOut.out().stdout(""String_Node_Str"" + initialOrgCreators.get(socIndx).getSecond(),GAOut.NOTICE);
  }
  return newOrg;
}","private static Organism makeFirstGenOrg(Generation offspring){
  GAParameters params=GAParameters.getParams();
  Development dev=params.getDevelopment();
  List<Pair<StructureOrgCreator,Integer>> initialOrgCreators=params.getInitialOrgCreators();
  StructureOrg newOrg=null;
  while (newOrg == null) {
    int socIndx=0;
    while (initialOrgCreators.size() > socIndx && initialOrgCreators.get(socIndx).getSecond() <= 0)     socIndx++;
    if (initialOrgCreators.size() <= socIndx)     return null;
    StructureOrgCreator soc=initialOrgCreators.get(socIndx).getFirst();
    do {
      newOrg=soc.makeOrganism(offspring);
      System.out.println(newOrg);
    }
 while (newOrg != null && dev != null && !dev.doDevelop(offspring,newOrg));
    if (newOrg != null)     newOrg.setSOCreator(soc);
 else     initialOrgCreators.set(socIndx,new Pair<StructureOrgCreator,Integer>(soc,0));
    GAOut.out().stdout(""String_Node_Str"" + initialOrgCreators.get(socIndx).getSecond(),GAOut.NOTICE);
  }
  return newOrg;
}",0.982776089159068
37786,"public static Cell parseStructure(StructureOrg c,String output){
  GAParameters params=GAParameters.getParams();
  List<Site> sites=c.getCell().getSites();
  List<Vect> newVects=new LinkedList<Vect>();
  List<Site> newSites=new LinkedList<Site>();
  String line=null;
  Pattern goodPattern=Pattern.compile(""String_Node_Str"");
  Matcher goodMatcher=goodPattern.matcher(output);
  try {
    BufferedReader t=new BufferedReader(new FileReader(output));
    try {
      while ((line=t.readLine()) != null) {
        goodMatcher.reset(line);
        if (goodMatcher.find()) {
          System.out.println(""String_Node_Str"");
          return c.getCell();
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  line=null;
  Pattern coordsPattern=Pattern.compile(""String_Node_Str"");
  Matcher coordsMatcher=coordsPattern.matcher(output);
  try {
    BufferedReader r=new BufferedReader(new FileReader(output));
    try {
      while ((line=r.readLine()) != null) {
        coordsMatcher.reset(line);
        if (coordsMatcher.find()) {
          while ((line=r.readLine()) != null) {
            coordsMatcher.reset(line);
            if (coordsMatcher.find()) {
              r.readLine();
              r.readLine();
              line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
              coordsMatcher.reset(line);
              try {
                for (                Site s : sites) {
                  StringTokenizer t=new StringTokenizer(line);
                  t.nextToken();
                  t.nextToken();
                  Double x=Double.parseDouble(t.nextToken());
                  Double y=Double.parseDouble(t.nextToken());
                  Double z=Double.parseDouble(t.nextToken());
                  Vect v=new Vect(x,y,z);
                  newSites.add(new Site(s.getElement(),v));
                  line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
                }
                for (int k=0; k < Constants.numDimensions; k++) {
                  StringTokenizer m=new StringTokenizer(line);
                  m.nextToken();
                  m.nextToken();
                  Double x=Double.parseDouble(m.nextToken());
                  Double y=Double.parseDouble(m.nextToken());
                  Double z=Double.parseDouble(m.nextToken());
                  Vect v=new Vect(x,y,z);
                  newVects.add(v);
                  line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
                }
              }
 catch (              NumberFormatException x) {
                GAOut.out().stdout(""String_Node_Str"" + x.getMessage(),GAOut.NOTICE,c.getID());
                GAOut.out().stdout(""String_Node_Str"",GAOut.DEBUG,c.getID());
                GAOut.out().stdout(output,GAOut.DEBUG,c.getID());
              }
              break;
            }
          }
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  Cell p=new Cell(newVects,newSites);
  return p;
}","public static Cell parseStructure(StructureOrg c,String output){
  GAParameters params=GAParameters.getParams();
  List<Site> sites=c.getCell().getSites();
  List<Vect> newVects=new LinkedList<Vect>();
  List<Site> newSites=new LinkedList<Site>();
  String line=null;
  Pattern goodPattern=Pattern.compile(""String_Node_Str"");
  Matcher goodMatcher=goodPattern.matcher(output);
  try {
    BufferedReader t=new BufferedReader(new FileReader(output));
    try {
      while ((line=t.readLine()) != null) {
        goodMatcher.reset(line);
        if (goodMatcher.find()) {
          System.out.println(""String_Node_Str"");
          return c.getCell();
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  line=null;
  boolean finalGeometryFound=false;
  Pattern coordsPattern=Pattern.compile(""String_Node_Str"");
  Matcher coordsMatcher=coordsPattern.matcher(output);
  try {
    BufferedReader r=new BufferedReader(new FileReader(output));
    try {
      while ((line=r.readLine()) != null) {
        coordsMatcher.reset(line);
        if (coordsMatcher.find()) {
          while ((line=r.readLine()) != null) {
            coordsMatcher.reset(line);
            if (coordsMatcher.find()) {
              finalGeometryFound=true;
              r.readLine();
              r.readLine();
              line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
              coordsMatcher.reset(line);
              try {
                for (                Site s : sites) {
                  StringTokenizer t=new StringTokenizer(line);
                  t.nextToken();
                  t.nextToken();
                  Double x=Double.parseDouble(t.nextToken());
                  Double y=Double.parseDouble(t.nextToken());
                  Double z=Double.parseDouble(t.nextToken());
                  Vect v=new Vect(x,y,z);
                  newSites.add(new Site(s.getElement(),v));
                  line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
                }
                for (int k=0; k < Constants.numDimensions; k++) {
                  StringTokenizer m=new StringTokenizer(line);
                  m.nextToken();
                  m.nextToken();
                  Double x=Double.parseDouble(m.nextToken());
                  Double y=Double.parseDouble(m.nextToken());
                  Double z=Double.parseDouble(m.nextToken());
                  Vect v=new Vect(x,y,z);
                  newVects.add(v);
                  line=r.readLine().replace(""String_Node_Str"",""String_Node_Str"");
                }
              }
 catch (              NumberFormatException x) {
                GAOut.out().stdout(""String_Node_Str"" + x.getMessage(),GAOut.NOTICE,c.getID());
                GAOut.out().stdout(""String_Node_Str"",GAOut.DEBUG,c.getID());
                GAOut.out().stdout(output,GAOut.DEBUG,c.getID());
              }
              break;
            }
          }
        }
      }
    }
 catch (    IOException x) {
      GAOut.out().stdout(""String_Node_Str"" + x.getLocalizedMessage(),GAOut.CRITICAL,c.getID());
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    return c.getCell();
  }
  if (finalGeometryFound)   return new Cell(newVects,newSites);
 else   return null;
}",0.9793244030285382
37787,"public static void main(String args[]){
  Cell c=VaspOut.getPOSCAR(""String_Node_Str"");
  System.out.println(getWyckoffCell(c));
}","public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  Cell b=Cell.parseCif(new File(""String_Node_Str""));
  System.out.println(a.matchesCell(b,0.1,0.1,0.1));
  System.out.println(getFindsymOutput(b));
}",0.3018867924528302
37788,"public void finishGen(Generation g){
  GAParameters params=GAParameters.getParams();
  int verbosity=params.getVerbosity();
  GAUtils.writeStringToFile(""String_Node_Str"" + Integer.toString(currentGenNum) + ""String_Node_Str""+ g.getNumOrganisms()+ newline,outFile,true);
  for (  Organism o : g) {
    StructureOrg s=(StructureOrg)(o);
    s.getCell().writeCIF(makeCIFPath(s));
    File outFindSym=new File(makeFindSymPath(s));
    GAUtils.writeStringToFile(Isotropy.getFindsymOutput(s.getCell()),outFindSym,false);
  }
  List<Integer> energyList=new LinkedList<Integer>();
  for (int k=0; k < g.getNumOrganisms(); k++) {
    double lowest=Double.POSITIVE_INFINITY;
    int index=0;
    for (    Organism r : g) {
      double thisEnergy=r.getValue();
      if (thisEnergy < lowest && !energyList.contains(r.getID())) {
        index=r.getID();
        lowest=thisEnergy;
      }
    }
    energyList.add(k,index);
  }
  for (  Integer p : energyList) {
    Organism m=g.getOrgByID(p);
    StructureOrg s=(StructureOrg)(m);
    StringBuilder info=new StringBuilder();
    info.append(Integer.toString(s.getID()) + ""String_Node_Str"");
    info.append(Double.toString(s.getValue()) + ""String_Node_Str"");
    info.append(makeCIFPath(s) + newline);
    GAUtils.writeStringToFile(info.toString(),outFile,true);
  }
  int nAdapt=params.getNumDenAdapt();
  double weight=params.getWeightDenAdapt();
  double avgDen=0;
  for (int j=1; j <= nAdapt; j++) {
    Cell currentStruct=((StructureOrg)g.getNthBestOrganism(j)).getCell();
    avgDen+=currentStruct.getVolume() / currentStruct.getNumSites();
  }
  avgDen/=nAdapt;
  if (getRecord().getGenNum() == 0)   bestDenEstimate=avgDen;
 else {
    bestDenEstimate*=(1 - weight);
    bestDenEstimate+=weight * avgDen;
  }
  updateInEndgame(g);
  if (params.doingPDRun()) {
    String pdbuilder_out_fname=outDirName + ""String_Node_Str"" + currentGenNum+ ""String_Node_Str"";
    for (    Organism o : g.organisms)     if (!params.getPDBuilder().containsEntry((StructureOrg)o))     params.getPDBuilder().addEntry((StructureOrg)o);
    Utility.writeSerializable((params.getPDBuilder().getPDData()),pdbuilder_out_fname);
  }
  if (verbosity >= 1)   System.out.println(getGenSummary(g));
  currentGenNum++;
  currentGen=g;
  if (params.getSaveStateEachIter()) {
    GAParameters.getParams().getInitialOrgCreators().clear();
    String save_out_fname=outDirName + ""String_Node_Str"" + currentGenNum+ ""String_Node_Str"";
    Utility.writeSerializable(params,save_out_fname);
    if (verbosity >= 3)     System.out.println(""String_Node_Str"" + save_out_fname);
  }
}","public void finishGen(Generation g){
  GAParameters params=GAParameters.getParams();
  int verbosity=params.getVerbosity();
  GAUtils.writeStringToFile(""String_Node_Str"" + Integer.toString(currentGenNum) + ""String_Node_Str""+ g.getNumOrganisms()+ newline,outFile,true);
  for (  Organism o : g) {
    StructureOrg s=(StructureOrg)(o);
    s.getCell().writeCIF(makeCIFPath(s));
    File outFindSym=new File(makeFindSymPath(s));
    GAUtils.writeStringToFile(Isotropy.getFindsymOutput(s.getCell()),outFindSym,false);
  }
  for (  Organism o : g.getOrganismsSorted()) {
    StructureOrg s=(StructureOrg)o;
    StringBuilder info=new StringBuilder();
    info.append(Integer.toString(s.getID()) + ""String_Node_Str"");
    info.append(Double.toString(s.getValue()) + ""String_Node_Str"");
    info.append(makeCIFPath(s) + newline);
    GAUtils.writeStringToFile(info.toString(),outFile,true);
  }
  int nAdapt=params.getNumDenAdapt();
  double weight=params.getWeightDenAdapt();
  double avgDen=0;
  for (int j=1; j <= nAdapt; j++) {
    Cell currentStruct=((StructureOrg)g.getNthBestOrganism(j)).getCell();
    avgDen+=currentStruct.getVolume() / currentStruct.getNumSites();
  }
  avgDen/=nAdapt;
  if (getRecord().getGenNum() == 0)   bestDenEstimate=avgDen;
 else {
    bestDenEstimate*=(1 - weight);
    bestDenEstimate+=weight * avgDen;
  }
  updateInEndgame(g);
  if (params.doingPDRun()) {
    String pdbuilder_out_fname=outDirName + ""String_Node_Str"" + currentGenNum+ ""String_Node_Str"";
    for (    Organism o : g.organisms)     if (!params.getPDBuilder().containsEntry((StructureOrg)o))     params.getPDBuilder().addEntry((StructureOrg)o);
    Utility.writeSerializable((params.getPDBuilder().getPDData()),pdbuilder_out_fname);
  }
  if (verbosity >= 1)   System.out.println(getGenSummary(g));
  currentGenNum++;
  currentGen=g;
  if (params.getSaveStateEachIter()) {
    GAParameters.getParams().getInitialOrgCreators().clear();
    String save_out_fname=outDirName + ""String_Node_Str"" + currentGenNum+ ""String_Node_Str"";
    Utility.writeSerializable(params,save_out_fname);
    if (verbosity >= 3)     System.out.println(""String_Node_Str"" + save_out_fname);
  }
}",0.8885149347917544
37789,"public Organism getNthBestOrganism(int n){
  ArrayList<Double> fitnesses=new ArrayList<Double>();
  Iterator<Organism> i=organisms.iterator();
  while (i.hasNext()) {
    Organism c=i.next();
    fitnesses.add(new Double(c.getFitness()));
  }
  n=Math.min(n,fitnesses.size());
  double fn=GAUtils.doubleSelect(fitnesses,n);
  i=organisms.iterator();
  while (i.hasNext()) {
    Organism c=i.next();
    if (fn == c.getFitness())     return c;
  }
  return null;
}","public Organism getNthBestOrganism(int n){
  return getOrganismsSorted().get(n - 1);
}",0.2586520947176685
37790,"private static String getLammpsInputFile(StructureOrg c,String potlStr){
  StringBuilder ans=new StringBuilder();
  String newline=GAUtils.newline();
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + dataFileName + newline);
  ans.append(newline + potlStr + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + dumpFileName + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  return ans.toString();
}","private static String getLammpsInputFile(StructureOrg c,String potlStr){
  StringBuilder ans=new StringBuilder();
  String newline=GAUtils.newline();
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + dataFileName + newline);
  ans.append(newline + potlStr + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + dumpFileName + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  ans.append(""String_Node_Str"" + newline);
  return ans.toString();
}",0.8875816993464052
37791,"private Cell parseOutputStructure(Cell origCell,String outFile){
  if (!(new File(outFile)).exists()) {
    if (GAParameters.getParams().getVerbosity() >= 4)     System.out.println(""String_Node_Str"");
    return null;
  }
  String output=Utility.readStringFromFile(outFile);
  List<Vect> basis=new LinkedList<Vect>();
  List<Site> sites=new LinkedList<Site>();
  String lines[]=output.split(""String_Node_Str"");
  int numAtoms=Integer.parseInt(lines[3]);
  String xs[]=lines[5].split(""String_Node_Str"");
  double xlo=Double.parseDouble(xs[0]);
  double xhi=Double.parseDouble(xs[1]);
  double xy=Double.parseDouble(xs[2]);
  String ys[]=lines[6].split(""String_Node_Str"");
  double ylo=Double.parseDouble(ys[0]);
  double yhi=Double.parseDouble(ys[1]);
  double xz=Double.parseDouble(ys[2]);
  String zs[]=lines[7].split(""String_Node_Str"");
  double zlo=Double.parseDouble(zs[0]);
  double zhi=Double.parseDouble(zs[1]);
  double yz=Double.parseDouble(zs[2]);
  basis.add(new Vect(xhi - xlo,0.0,0.0));
  basis.add(new Vect(xy,yhi - ylo,0.0));
  basis.add(new Vect(xz,yz,zhi - zlo));
  for (int i=0; i < numAtoms; i++) {
    String as[]=lines[9 + i].split(""String_Node_Str"");
    int type=Integer.parseInt(as[1]) - 1;
    double x=Double.parseDouble(as[2]);
    double y=Double.parseDouble(as[3]);
    double z=Double.parseDouble(as[4]);
    sites.add(new Site(origCell.getComposition().getElements().get(type),new Vect(x - xlo,y - ylo,z - zlo)));
  }
  if (origCell.getBasisSize() != numAtoms) {
    System.out.println(""String_Node_Str"");
    System.out.println(outFile);
  }
  return new Cell(basis,sites,origCell.getLabel());
}","private Cell parseOutputStructure(Cell origCell,String outFile){
  if (!(new File(outFile)).exists()) {
    if (GAParameters.getParams().getVerbosity() >= 4)     System.out.println(""String_Node_Str"");
    return null;
  }
  String output=Utility.readStringFromFile(outFile);
  List<Vect> basis=new LinkedList<Vect>();
  List<Site> sites=new LinkedList<Site>();
  String lines[]=output.split(""String_Node_Str"");
  int numAtoms=Integer.parseInt(lines[3]);
  String xs[]=lines[5].split(""String_Node_Str"");
  double xlo_bound=Double.parseDouble(xs[0]);
  double xhi_bound=Double.parseDouble(xs[1]);
  double xy=Double.parseDouble(xs[2]);
  String ys[]=lines[6].split(""String_Node_Str"");
  double ylo_bound=Double.parseDouble(ys[0]);
  double yhi_bound=Double.parseDouble(ys[1]);
  double xz=Double.parseDouble(ys[2]);
  String zs[]=lines[7].split(""String_Node_Str"");
  double zlo_bound=Double.parseDouble(zs[0]);
  double zhi_bound=Double.parseDouble(zs[1]);
  double yz=Double.parseDouble(zs[2]);
  double xlo=xlo_bound - Math.min(Math.min(0.0,xy),Math.min(xz,xy + xz));
  double xhi=xhi_bound - Math.max(Math.max(0.0,xy),Math.max(xz,xy + xz));
  double ylo=ylo_bound - Math.min(0.0,yz);
  double yhi=yhi_bound - Math.max(0.0,yz);
  double zlo=zlo_bound;
  double zhi=zhi_bound;
  basis.add(new Vect(xhi - xlo,0.0,0.0));
  basis.add(new Vect(xy,yhi - ylo,0.0));
  basis.add(new Vect(xz,yz,zhi - zlo));
  for (int i=0; i < numAtoms; i++) {
    String as[]=lines[9 + i].split(""String_Node_Str"");
    int type=Integer.parseInt(as[1]) - 1;
    double x=Double.parseDouble(as[2]);
    double y=Double.parseDouble(as[3]);
    double z=Double.parseDouble(as[4]);
    sites.add(new Site(origCell.getComposition().getElements().get(type),new Vect(x - xlo,y - ylo,z - zlo)));
  }
  if (origCell.getBasisSize() != numAtoms) {
    System.out.println(""String_Node_Str"");
    System.out.println(outFile);
  }
  return new Cell(basis,sites,origCell.getLabel());
}",0.9109742441209406
37792,"public static Cell parseCif(File cifFile){
  String line=null;
  double la=0, lb=0, lc=0, a=0, b=0, g=0;
  List<Vect> latVects=null;
  List<Site> sites=new LinkedList<Site>();
  Boolean readingInAtoms=false;
  try {
    BufferedReader r=new BufferedReader(new FileReader(cifFile));
    while ((line=r.readLine()) != null) {
      StringTokenizer t=new StringTokenizer(line);
      if (!t.hasMoreTokens())       continue;
      if (readingInAtoms) {
        String siteStr=t.nextToken();
        String symbol=siteStr.substring(1,2).matches(""String_Node_Str"") ? siteStr.substring(0,2) : siteStr.substring(0,1);
        double x=Double.parseDouble(t.nextToken());
        double y=Double.parseDouble(t.nextToken());
        double z=Double.parseDouble(t.nextToken());
        sites.add(new Site(Element.getElemFromSymbol(symbol),new Vect(x,y,z,latVects)));
      }
 else {
        String firstWord=t.nextToken();
        if (firstWord.equals(""String_Node_Str""))         la=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         lb=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         lc=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         a=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str""))         b=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str""))         g=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str"")) {
          readingInAtoms=true;
          latVects=(new Cell(la,lb,lc,a,b,g,null,null)).getLatticeVectors();
        }
      }
    }
  }
 catch (  FileNotFoundException x) {
    System.out.println(""String_Node_Str"" + cifFile.getAbsolutePath());
    return null;
  }
catch (  IOException y) {
    System.out.println(""String_Node_Str"" + cifFile.getAbsolutePath());
  }
  if (sites.size() == 0)   return null;
  Cell answer=new Cell(latVects,sites);
  return answer;
}","public static Cell parseCif(File cifFile){
  String line=null;
  double la=0, lb=0, lc=0, a=0, b=0, g=0;
  List<Vect> latVects=null;
  List<Site> sites=new LinkedList<Site>();
  Boolean readingInAtoms=false;
  try {
    BufferedReader r=new BufferedReader(new FileReader(cifFile));
    while ((line=r.readLine()) != null) {
      StringTokenizer t=new StringTokenizer(line);
      if (!t.hasMoreTokens())       continue;
      if (readingInAtoms) {
        String siteStr=t.nextToken();
        String symbol=null;
        if (siteStr.length() < 2)         symbol=siteStr;
 else         symbol=siteStr.substring(1,2).matches(""String_Node_Str"") ? siteStr.substring(0,2) : siteStr.substring(0,1);
        double x=Double.parseDouble(t.nextToken());
        double y=Double.parseDouble(t.nextToken());
        double z=Double.parseDouble(t.nextToken());
        sites.add(new Site(Element.getElemFromSymbol(symbol),new Vect(x,y,z,latVects)));
      }
 else {
        String firstWord=t.nextToken();
        if (firstWord.equals(""String_Node_Str""))         la=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         lb=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         lc=Double.parseDouble(t.nextToken());
 else         if (firstWord.equals(""String_Node_Str""))         a=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str""))         b=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str""))         g=Math.toRadians(Double.parseDouble(t.nextToken()));
 else         if (firstWord.equals(""String_Node_Str"")) {
          readingInAtoms=true;
          latVects=(new Cell(la,lb,lc,a,b,g,null,null)).getLatticeVectors();
        }
      }
    }
  }
 catch (  FileNotFoundException x) {
    System.out.println(""String_Node_Str"" + cifFile.getAbsolutePath());
    return null;
  }
catch (  IOException y) {
    System.out.println(""String_Node_Str"" + cifFile.getAbsolutePath());
  }
  if (sites.size() == 0)   return null;
  Cell answer=new Cell(latVects,sites);
  return answer;
}",0.9799481009672092
37793,"public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  Cell b=Cell.parseCif(new File(""String_Node_Str""));
  Cell c=Cell.parseCif(new File(""String_Node_Str""));
  System.out.println(a.matchesCell(b,0.5,0.5,0.05));
  System.out.println(b.matchesCell(a,0.5,0.5,0.05));
  System.out.println(a.matchesCell(c,0.5,0.5,0.05));
  System.out.println(c.matchesCell(a,0.5,0.5,0.05));
  System.out.println(c.matchesCell(b,0.5,0.5,0.05));
  System.out.println(b.matchesCell(c,0.5,0.5,0.05));
  System.out.println(a.matchesCell(a,0.1,0.05,0.05));
  System.out.println(b.matchesCell(b,0.1,0.05,0.05));
  System.out.println(c.matchesCell(c,0.1,0.05,0.05));
}","public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  a.getNigliReducedCell();
  for (int i=0; i < a.getNumSites(); i++) {
    if (a.getAtomsInSphereSorted(a.getSite(i).getCoords(),.8).size() > 1) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.2459016393442623
37794,"public boolean matchesCell(Cell other,double atomicMisfit,double lengthMisfit,double angleMisfit){
  Cell n1=this.getNigliReducedCell().getWyckoffCell();
  Cell n2=null;
  if (other.getBasisSize() <= 0)   n2=other.getNigliReducedCell().getWyckoffCell();
 else   n2=other.getNigliReducedCell().getWyckoffCell().getCellWithSiteIShiftedToOrigin(0);
  if (n1 == null || n2 == null)   return false;
  if (n1.getBasisSize() != n2.getBasisSize())   return false;
  int numWSites=n1.getBasisSize();
  for (  Element e : n1.getComposition().getElements())   if (n2.getNumSitesWithElement(e) != n1.getNumSitesWithElement(e))   return false;
  for (  Cell n1rotated : n1.getCellWithAlternateAxesLabeling()) {
    List<Double> parms1=n1rotated.getLatticeParameters();
    List<Double> parms2=n2.getLatticeParameters();
    if (Math.abs(parms1.get(0) - parms2.get(0)) > lengthMisfit || Math.abs(parms1.get(1) - parms2.get(1)) > lengthMisfit || Math.abs(parms1.get(2) - parms2.get(2)) > lengthMisfit || Math.abs(parms1.get(3) - parms2.get(3)) > angleMisfit * Math.PI / 180 || Math.abs(parms1.get(4) - parms2.get(4)) > angleMisfit * Math.PI / 180 || Math.abs(parms1.get(5) - parms2.get(5)) > angleMisfit * Math.PI / 180)     continue;
    for (int i=0; i < numWSites; i++) {
      Cell n1shifted=n1rotated.getCellWithSiteIShiftedToOrigin(i);
      boolean allSitesLineUp=true;
      for (int j=0; j < numWSites; j++) {
        if (!sitesArrayContainsElement(n1shifted.getAtomsInSphereSorted(n2.getSite(j).getCoords(),atomicMisfit),n2.getSite(j).getElement())) {
          allSitesLineUp=false;
          break;
        }
      }
      if (allSitesLineUp)       return true;
    }
  }
  return false;
}","public boolean matchesCell(Cell other,double atomicMisfit,double lengthMisfit,double angleMisfit){
  Cell n1=this.getWyckoffCell();
  Cell n2=null;
  if (other.getBasisSize() <= 0)   n2=other.getWyckoffCell();
 else   n2=other.getWyckoffCell().getCellWithSiteIShiftedToOrigin(0);
  if (n1 == null || n2 == null)   return false;
  if (n1.getBasisSize() != n2.getBasisSize())   return false;
  int numWSites=n1.getBasisSize();
  for (  Element e : n1.getComposition().getElements())   if (n2.getNumSitesWithElement(e) != n1.getNumSitesWithElement(e))   return false;
  for (  Cell n1rotated : n1.getCellWithAlternateAxesLabeling()) {
    List<Double> parms1=n1rotated.getLatticeParameters();
    List<Double> parms2=n2.getLatticeParameters();
    if (Math.abs(parms1.get(0) - parms2.get(0)) > lengthMisfit || Math.abs(parms1.get(1) - parms2.get(1)) > lengthMisfit || Math.abs(parms1.get(2) - parms2.get(2)) > lengthMisfit || Math.abs(parms1.get(3) - parms2.get(3)) > angleMisfit * Math.PI / 180 || Math.abs(parms1.get(4) - parms2.get(4)) > angleMisfit * Math.PI / 180 || Math.abs(parms1.get(5) - parms2.get(5)) > angleMisfit * Math.PI / 180)     continue;
    for (int i=0; i < numWSites; i++) {
      Cell n1shifted=n1rotated.getCellWithSiteIShiftedToOrigin(i);
      boolean allSitesLineUp=true;
      for (int j=0; j < numWSites; j++) {
        if (!sitesArrayContainsElement(n1shifted.getAtomsInSphereSorted(n2.getSite(j).getCoords(),atomicMisfit),n2.getSite(j).getElement())) {
          allSitesLineUp=false;
          break;
        }
      }
      if (allSitesLineUp)       return true;
    }
  }
  return false;
}",0.9800362976406534
37795,"public List<Site> getAtomsInSphereSorted(final Vect center,double dist){
  List<Site> result=new ArrayList<Site>();
  List<Vect> recipL=this.getRecipLVects();
  List<Double> cFracCoords=center.getComponentsWRTBasis(this.getLatticeVectors());
  int maxx=(int)Math.ceil(cFracCoords.get(0) + dist * recipL.get(0).length() / (2 * Math.PI));
  int minx=(int)Math.floor(cFracCoords.get(0) - dist * recipL.get(0).length() / (2 * Math.PI));
  int maxy=(int)Math.ceil(cFracCoords.get(1) + dist * recipL.get(1).length() / (2 * Math.PI));
  int miny=(int)Math.floor(cFracCoords.get(1) - dist * recipL.get(1).length() / (2 * Math.PI));
  int maxz=(int)Math.ceil(cFracCoords.get(2) + dist * recipL.get(2).length() / (2 * Math.PI));
  int minz=(int)Math.floor(cFracCoords.get(2) - dist * recipL.get(2).length() / (2 * Math.PI));
  for (int i=minx; i <= maxx; i++) {
    for (int j=miny; j <= maxy; j++) {
      for (int k=minz; k <= maxz; k++) {
        for (        Site s : basis) {
          Vect trialCoords=s.getCoords().plus(latticeVectors.get(0).scalarMult((double)i)).plus(latticeVectors.get(1).scalarMult((double)j)).plus(latticeVectors.get(2).scalarMult((double)k));
          if (center.getCartDistanceTo(trialCoords) < dist)           result.add(new Site(s.getElement(),trialCoords));
        }
      }
    }
  }
  Comparator<Site> c=new Comparator<Site>(){
    public int compare(    Site s1,    Site s2){
      if (s1.getCoords().getCartDistanceTo(center) > s2.getCoords().getCartDistanceTo(center))       return 1;
 else       return -1;
    }
  }
;
  Collections.sort(result,c);
  return result;
}","public List<Site> getAtomsInSphereSorted(final Vect center,double dist){
  List<Site> result=new ArrayList<Site>();
  List<Vect> recipL=this.getRecipLVects();
  List<Double> cFracCoords=center.getComponentsWRTBasis(this.getLatticeVectors());
  int maxx=(int)Math.ceil(cFracCoords.get(0) + dist * recipL.get(0).length() / (2 * Math.PI));
  int minx=(int)Math.floor(cFracCoords.get(0) - dist * recipL.get(0).length() / (2 * Math.PI));
  int maxy=(int)Math.ceil(cFracCoords.get(1) + dist * recipL.get(1).length() / (2 * Math.PI));
  int miny=(int)Math.floor(cFracCoords.get(1) - dist * recipL.get(1).length() / (2 * Math.PI));
  int maxz=(int)Math.ceil(cFracCoords.get(2) + dist * recipL.get(2).length() / (2 * Math.PI));
  int minz=(int)Math.floor(cFracCoords.get(2) - dist * recipL.get(2).length() / (2 * Math.PI));
  for (int i=minx; i <= maxx; i++) {
    for (int j=miny; j <= maxy; j++) {
      for (int k=minz; k <= maxz; k++) {
        for (        Site s : basis) {
          Vect trialCoords=s.getCoords().plus(latticeVectors.get(0).scalarMult((double)i)).plus(latticeVectors.get(1).scalarMult((double)j)).plus(latticeVectors.get(2).scalarMult((double)k));
          if (center.getCartDistanceTo(trialCoords) < dist) {
            result.add(s);
            continue;
          }
        }
      }
    }
  }
  Comparator<Site> c=new Comparator<Site>(){
    public int compare(    Site s1,    Site s2){
      if (s1.getCoords().getCartDistanceTo(center) > s2.getCoords().getCartDistanceTo(center))       return 1;
 else       return -1;
    }
  }
;
  Collections.sort(result,c);
  return result;
}",0.9621993127147768
37796,"public Cell getNigliReducedCell(){
  if (niggliReducedCell != null)   return niggliReducedCell;
  double TOL=1e-8;
  double[][] m1=new double[3][3];
  m1[0][1]=1.0;
  m1[1][0]=1.0;
  m1[2][2]=-1.0;
  double[][] m2=new double[3][3];
  m2[0][0]=-1.0;
  m2[1][2]=1.0;
  m2[2][1]=1.0;
  double[][] m3=new double[3][3];
  double[][] m4=new double[3][3];
  double[][] m5=Matrix.identity(3,3).getArrayCopy();
  double[][] m6=Matrix.identity(3,3).getArrayCopy();
  double[][] m7=Matrix.identity(3,3).getArrayCopy();
  double[][] m8=Matrix.identity(3,3).getArrayCopy();
  m8[0][2]=1.0;
  m8[1][2]=1.0;
  double[] indat=new double[6];
  indat[0]=this.getCellLengths()[0];
  indat[1]=this.getCellLengths()[1];
  indat[2]=this.getCellLengths()[2];
  indat[3]=latticeVectors.get(1).angleToInRadians(latticeVectors.get(2));
  indat[4]=latticeVectors.get(0).angleToInRadians(latticeVectors.get(2));
  indat[5]=latticeVectors.get(0).angleToInRadians(latticeVectors.get(1));
  double a=indat[0] * indat[0];
  double b=indat[1] * indat[1];
  double c=indat[2] * indat[2];
  double ksi=2.0 * indat[1] * indat[2]* Math.cos(indat[3]);
  double eta=2.0 * indat[0] * indat[2]* Math.cos(indat[4]);
  double zeta=2.0 * indat[0] * indat[1]* Math.cos(indat[5]);
  double temp, temp1, temp2, temp3;
  double[][] P=Matrix.identity(3,3).getArrayCopy();
  while (true) {
    if (((a - b) > TOL) || ((Math.abs(a - b) < TOL) && (Math.abs(ksi) > Math.abs(eta)))) {
      temp=a;
      a=b;
      b=temp;
      temp=-ksi;
      ksi=-eta;
      eta=temp;
      P=(new Matrix(P)).times(new Matrix(m1)).getArray();
    }
    if (((b - c) > TOL) || ((Math.abs(b - c) < TOL) && (Math.abs(eta) > Math.abs(zeta)))) {
      temp=b;
      b=c;
      c=temp;
      temp=-eta;
      eta=-zeta;
      zeta=temp;
      P=(new Matrix(P)).times(new Matrix(m2)).getArray();
      continue;
    }
    if ((ksi * eta * zeta) > 0.0) {
      m3[0][0]=SignNoZero(ksi);
      m3[1][1]=SignNoZero(eta);
      m3[2][2]=SignNoZero(zeta);
      P=(new Matrix(P)).times(new Matrix(m3)).getArray();
      ksi=Math.abs(ksi);
      eta=Math.abs(eta);
      zeta=Math.abs(zeta);
    }
    if (ksi * eta * zeta <= 0) {
      m4[0][0]=-(SignNoZero(ksi));
      m4[1][1]=-(SignNoZero(eta));
      m4[2][2]=-(SignNoZero(zeta));
      if (Math.abs(ksi) < TOL)       m4[0][0]=m4[1][1] * m4[2][2];
      if (Math.abs(eta) < TOL)       m4[1][1]=m4[0][0] * m4[2][2];
      if (Math.abs(zeta) < TOL)       m4[2][2]=m4[0][0] * m4[1][1];
      P=(new Matrix(P)).times(new Matrix(m4)).getArray();
      ksi=-Math.abs(ksi);
      eta=-Math.abs(eta);
      zeta=-Math.abs(zeta);
    }
    if (((Math.abs(ksi) - b) >= TOL) || ((Math.abs(ksi - b) < TOL) && (2.0 * eta < zeta)) || ((Math.abs(ksi + b) < TOL) && (zeta < 0))) {
      m5[1][2]=-(SignNoZero(ksi));
      P=(new Matrix(P)).times(new Matrix(m5)).getArray();
      temp1=b + c - ksi * SignNoZero(ksi);
      temp2=eta - zeta * SignNoZero(ksi);
      temp3=ksi - 2.0 * b * SignNoZero(ksi);
      c=temp1;
      eta=temp2;
      ksi=temp3;
      continue;
    }
    if (((Math.abs(eta) - a) > TOL) || ((Math.abs(eta - a) < TOL) && (2.0 * ksi < zeta)) || ((Math.abs(eta + a) < TOL) && (zeta < 0))) {
      m6[0][2]=-SignNoZero(eta);
      P=(new Matrix(P)).times(new Matrix(m6)).getArray();
      temp1=a + c - eta * SignNoZero(eta);
      temp2=ksi - zeta * SignNoZero(eta);
      temp3=eta - 2.0 * a * SignNoZero(eta);
      c=temp1;
      ksi=temp2;
      eta=temp3;
    }
    if (((Math.abs(zeta) - a) > TOL) || ((Math.abs(zeta - a) < TOL) && (2.0 * ksi < eta)) || ((Math.abs(zeta + a) < TOL) && (eta < 0))) {
      m7[0][1]=-SignNoZero(zeta);
      P=(new Matrix(P)).times(new Matrix(m7)).getArray();
      temp1=a + b - zeta * SignNoZero(zeta);
      temp2=ksi - eta * SignNoZero(zeta);
      temp3=zeta - 2.0 * a * SignNoZero(zeta);
      b=temp1;
      ksi=temp2;
      zeta=temp3;
      continue;
    }
    if ((ksi + eta + zeta+ a+ b < 0) || ((ksi + eta + zeta+ a+ b < 0) && (2.0 * (a + eta) + zeta > 0))) {
      P=(new Matrix(P)).times(new Matrix(m8)).getArray();
      temp1=a + b + c+ ksi+ eta+ zeta;
      temp2=2.0 * b + ksi + zeta;
      temp3=2.0 * a + eta + zeta;
      c=temp1;
      ksi=temp2;
      eta=temp3;
      continue;
    }
    break;
  }
  double[] outdat=new double[6];
  outdat[0]=Math.sqrt(a);
  outdat[1]=Math.sqrt(b);
  outdat[2]=Math.sqrt(c);
  outdat[3]=Math.acos(ksi / 2.0 / outdat[1]/ outdat[2]);
  outdat[4]=Math.acos(eta / 2.0 / outdat[0]/ outdat[2]);
  outdat[5]=Math.acos(zeta / 2.0 / outdat[0]/ outdat[1]);
  List<List<Integer>> coefficients=new LinkedList<List<Integer>>();
  for (int i=0; i < Constants.numDimensions; i++) {
    List<Integer> col=new LinkedList<Integer>();
    for (int j=0; j < Constants.numDimensions; j++) {
      int entry=Math.round(Math.round((P[j][i])));
      if (entry != P[j][i])       System.out.println(""String_Node_Str"");
      col.add(entry);
    }
    coefficients.add(col);
  }
  Cell result=getSupercell(this,coefficients);
  double[] poutdat=new double[6];
  poutdat[0]=result.getCellLengths()[0];
  poutdat[1]=result.getCellLengths()[1];
  poutdat[2]=result.getCellLengths()[2];
  poutdat[3]=result.getCellAngles()[0];
  poutdat[4]=result.getCellAngles()[1];
  poutdat[5]=result.getCellAngles()[2];
  int flag=0;
  for (int i=0; i < 6; i++) {
    if (Math.abs(poutdat[i] - outdat[i]) > 2 * TOL) {
      flag=1;
    }
  }
  if (flag == 1) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    for (int j=0; j < 6; j++)     System.out.println(outdat[j]);
    System.out.println(""String_Node_Str"");
    for (int j=0; j < 6; j++)     System.out.println(poutdat[j]);
  }
  if (this.getBasisSize() != result.getBasisSize()) {
    System.out.println(""String_Node_Str"");
    System.out.println(this);
    System.out.println(result);
  }
  niggliReducedCell=result;
  return result;
}","public Cell getNigliReducedCell(){
  if (niggliReducedCell != null)   return niggliReducedCell;
  double TOL=1e-8;
  double[][] m1=new double[3][3];
  m1[0][1]=1.0;
  m1[1][0]=1.0;
  m1[2][2]=-1.0;
  double[][] m2=new double[3][3];
  m2[0][0]=-1.0;
  m2[1][2]=1.0;
  m2[2][1]=1.0;
  double[][] m3=new double[3][3];
  double[][] m4=new double[3][3];
  double[][] m5=Matrix.identity(3,3).getArrayCopy();
  double[][] m6=Matrix.identity(3,3).getArrayCopy();
  double[][] m7=Matrix.identity(3,3).getArrayCopy();
  double[][] m8=Matrix.identity(3,3).getArrayCopy();
  m8[0][2]=1.0;
  m8[1][2]=1.0;
  double[] indat=new double[6];
  indat[0]=this.getCellLengths()[0];
  indat[1]=this.getCellLengths()[1];
  indat[2]=this.getCellLengths()[2];
  indat[3]=latticeVectors.get(1).angleToInRadians(latticeVectors.get(2));
  indat[4]=latticeVectors.get(0).angleToInRadians(latticeVectors.get(2));
  indat[5]=latticeVectors.get(0).angleToInRadians(latticeVectors.get(1));
  double a=indat[0] * indat[0];
  double b=indat[1] * indat[1];
  double c=indat[2] * indat[2];
  double ksi=2.0 * indat[1] * indat[2]* Math.cos(indat[3]);
  double eta=2.0 * indat[0] * indat[2]* Math.cos(indat[4]);
  double zeta=2.0 * indat[0] * indat[1]* Math.cos(indat[5]);
  double temp, temp1, temp2, temp3;
  double[][] P=Matrix.identity(3,3).getArrayCopy();
  while (true) {
    if (((a - b) > TOL) || ((Math.abs(a - b) < TOL) && (Math.abs(ksi) > Math.abs(eta)))) {
      temp=a;
      a=b;
      b=temp;
      temp=-ksi;
      ksi=-eta;
      eta=temp;
      P=(new Matrix(P)).times(new Matrix(m1)).getArray();
    }
    if (((b - c) > TOL) || ((Math.abs(b - c) < TOL) && (Math.abs(eta) > Math.abs(zeta)))) {
      temp=b;
      b=c;
      c=temp;
      temp=-eta;
      eta=-zeta;
      zeta=temp;
      P=(new Matrix(P)).times(new Matrix(m2)).getArray();
      continue;
    }
    if ((ksi * eta * zeta) > 0.0) {
      m3[0][0]=SignNoZero(ksi);
      m3[1][1]=SignNoZero(eta);
      m3[2][2]=SignNoZero(zeta);
      P=(new Matrix(P)).times(new Matrix(m3)).getArray();
      ksi=Math.abs(ksi);
      eta=Math.abs(eta);
      zeta=Math.abs(zeta);
    }
    if (ksi * eta * zeta <= 0) {
      m4[0][0]=-(SignNoZero(ksi));
      m4[1][1]=-(SignNoZero(eta));
      m4[2][2]=-(SignNoZero(zeta));
      if (Math.abs(ksi) < TOL)       m4[0][0]=m4[1][1] * m4[2][2];
      if (Math.abs(eta) < TOL)       m4[1][1]=m4[0][0] * m4[2][2];
      if (Math.abs(zeta) < TOL)       m4[2][2]=m4[0][0] * m4[1][1];
      P=(new Matrix(P)).times(new Matrix(m4)).getArray();
      ksi=-Math.abs(ksi);
      eta=-Math.abs(eta);
      zeta=-Math.abs(zeta);
    }
    if (((Math.abs(ksi) - b) >= TOL) || ((Math.abs(ksi - b) < TOL) && (2.0 * eta < zeta)) || ((Math.abs(ksi + b) < TOL) && (zeta < 0))) {
      m5[1][2]=-(SignNoZero(ksi));
      P=(new Matrix(P)).times(new Matrix(m5)).getArray();
      temp1=b + c - ksi * SignNoZero(ksi);
      temp2=eta - zeta * SignNoZero(ksi);
      temp3=ksi - 2.0 * b * SignNoZero(ksi);
      c=temp1;
      eta=temp2;
      ksi=temp3;
      continue;
    }
    if (((Math.abs(eta) - a) > TOL) || ((Math.abs(eta - a) < TOL) && (2.0 * ksi < zeta)) || ((Math.abs(eta + a) < TOL) && (zeta < 0))) {
      m6[0][2]=-SignNoZero(eta);
      P=(new Matrix(P)).times(new Matrix(m6)).getArray();
      temp1=a + c - eta * SignNoZero(eta);
      temp2=ksi - zeta * SignNoZero(eta);
      temp3=eta - 2.0 * a * SignNoZero(eta);
      c=temp1;
      ksi=temp2;
      eta=temp3;
    }
    if (((Math.abs(zeta) - a) > TOL) || ((Math.abs(zeta - a) < TOL) && (2.0 * ksi < eta)) || ((Math.abs(zeta + a) < TOL) && (eta < 0))) {
      m7[0][1]=-SignNoZero(zeta);
      P=(new Matrix(P)).times(new Matrix(m7)).getArray();
      temp1=a + b - zeta * SignNoZero(zeta);
      temp2=ksi - eta * SignNoZero(zeta);
      temp3=zeta - 2.0 * a * SignNoZero(zeta);
      b=temp1;
      ksi=temp2;
      zeta=temp3;
      continue;
    }
    if ((ksi + eta + zeta+ a+ b < 0) || ((ksi + eta + zeta+ a+ b < 0) && (2.0 * (a + eta) + zeta > 0))) {
      P=(new Matrix(P)).times(new Matrix(m8)).getArray();
      temp1=a + b + c+ ksi+ eta+ zeta;
      temp2=2.0 * b + ksi + zeta;
      temp3=2.0 * a + eta + zeta;
      c=temp1;
      ksi=temp2;
      eta=temp3;
      continue;
    }
    break;
  }
  double[] outdat=new double[6];
  outdat[0]=Math.sqrt(a);
  outdat[1]=Math.sqrt(b);
  outdat[2]=Math.sqrt(c);
  outdat[3]=Math.acos(ksi / 2.0 / outdat[1]/ outdat[2]);
  outdat[4]=Math.acos(eta / 2.0 / outdat[0]/ outdat[2]);
  outdat[5]=Math.acos(zeta / 2.0 / outdat[0]/ outdat[1]);
  List<List<Integer>> coefficients=new LinkedList<List<Integer>>();
  for (int i=0; i < Constants.numDimensions; i++) {
    List<Integer> col=new LinkedList<Integer>();
    for (int j=0; j < Constants.numDimensions; j++) {
      int entry=Math.round(Math.round((P[j][i])));
      if (entry != P[j][i])       System.out.println(""String_Node_Str"");
      col.add(entry);
    }
    coefficients.add(col);
  }
  Cell result=getSupercell(this,coefficients);
  double[] poutdat=new double[6];
  poutdat[0]=result.getCellLengths()[0];
  poutdat[1]=result.getCellLengths()[1];
  poutdat[2]=result.getCellLengths()[2];
  poutdat[3]=result.getCellAngles()[0];
  poutdat[4]=result.getCellAngles()[1];
  poutdat[5]=result.getCellAngles()[2];
  int flag=0;
  for (int i=0; i < 6; i++) {
    if (Math.abs(poutdat[i] - outdat[i]) > 2 * TOL) {
      flag=1;
    }
  }
  if (flag == 1) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    for (int j=0; j < 6; j++)     System.out.println(outdat[j]);
    System.out.println(""String_Node_Str"");
    for (int j=0; j < 6; j++)     System.out.println(poutdat[j]);
  }
  if (this.getBasisSize() != result.getBasisSize()) {
    System.out.println(""String_Node_Str"");
    System.out.println(this);
    System.out.println(result);
    (new Exception()).printStackTrace();
  }
  niggliReducedCell=result;
  return result;
}",0.9965693247426992
37797,"public static Cell getSupercell(Cell c,List<List<Integer>> coefficients){
  Cell cell=c.getCellWithAllAtomsInCell();
  if (coefficients.size() != Constants.numDimensions)   throw new IllegalArgumentException(""String_Node_Str"" + coefficients.size());
  List<Vect> newVectors=new LinkedList<Vect>();
  for (int i=0; i < Constants.numDimensions; i++) {
    List<Integer> coefs=coefficients.get(i);
    if (coefs.size() != Constants.numDimensions)     throw new IllegalArgumentException(""String_Node_Str"" + coefs.size());
    Double x=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(0) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(0) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(0);
    Double y=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(1) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(1) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(1);
    Double z=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(2) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(2) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(2);
    newVectors.add(new Vect(x,y,z));
  }
  List<Site> newBasis=new LinkedList<Site>();
  int minx=0, maxx=0, miny=0, maxy=0, minz=0, maxz=0;
  for (int i=0; i <= 1; i++)   for (int j=0; j <= 1; j++)   for (int k=0; k <= 1; k++) {
    int combox=i * coefficients.get(0).get(0) + j * coefficients.get(1).get(0) + k * coefficients.get(2).get(0);
    minx=Math.min(minx,combox);
    maxx=Math.max(maxx,combox);
    int comboy=i * coefficients.get(0).get(1) + j * coefficients.get(1).get(1) + k * coefficients.get(2).get(1);
    miny=Math.min(miny,comboy);
    maxy=Math.max(maxy,comboy);
    int comboz=i * coefficients.get(0).get(2) + j * coefficients.get(1).get(2) + k * coefficients.get(2).get(2);
    minz=Math.min(minz,comboz);
    maxz=Math.max(maxz,comboz);
  }
  for (  Site s : cell.basis) {
    for (int i=minx; i <= maxx; i++) {
      for (int j=miny; j <= maxy; j++) {
        for (int k=minz; k <= maxz; k++) {
          Vect candidateSiteLoc=s.getCoords().plus(new Vect(new Double(i),new Double(j),new Double(k),cell.latticeVectors));
          List<Double> newFracCoords=candidateSiteLoc.getComponentsWRTBasis(newVectors);
          if (newFracCoords.get(0) > -Constants.epsilon && newFracCoords.get(0) <= 1 - Constants.epsilon && newFracCoords.get(1) > -Constants.epsilon && newFracCoords.get(1) <= 1 - Constants.epsilon && newFracCoords.get(2) > -Constants.epsilon && newFracCoords.get(2) <= 1 - Constants.epsilon)           newBasis.add(new Site(s.getElement(),candidateSiteLoc));
        }
      }
    }
  }
  return new Cell(newVectors,newBasis,cell.getLabel());
}","public static Cell getSupercell(Cell c,List<List<Integer>> coefficients){
  Cell cell=c.getCellWithAllAtomsInCell();
  if (coefficients.size() != Constants.numDimensions)   throw new IllegalArgumentException(""String_Node_Str"" + coefficients.size());
  List<Vect> newVectors=new LinkedList<Vect>();
  for (int i=0; i < Constants.numDimensions; i++) {
    List<Integer> coefs=coefficients.get(i);
    if (coefs.size() != Constants.numDimensions)     throw new IllegalArgumentException(""String_Node_Str"" + coefs.size());
    Double x=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(0) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(0) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(0);
    Double y=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(1) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(1) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(1);
    Double z=coefs.get(0) * (cell.latticeVectors.get(0)).getCartesianComponents().get(2) + coefs.get(1) * (cell.latticeVectors.get(1)).getCartesianComponents().get(2) + coefs.get(2) * (cell.latticeVectors.get(2)).getCartesianComponents().get(2);
    newVectors.add(new Vect(x,y,z));
  }
  int minx=0, maxx=0, miny=0, maxy=0, minz=0, maxz=0;
  for (int i=0; i <= 1; i++)   for (int j=0; j <= 1; j++)   for (int k=0; k <= 1; k++) {
    int combox=i * coefficients.get(0).get(0) + j * coefficients.get(1).get(0) + k * coefficients.get(2).get(0);
    minx=Math.min(minx,combox);
    maxx=Math.max(maxx,combox);
    int comboy=i * coefficients.get(0).get(1) + j * coefficients.get(1).get(1) + k * coefficients.get(2).get(1);
    miny=Math.min(miny,comboy);
    maxy=Math.max(maxy,comboy);
    int comboz=i * coefficients.get(0).get(2) + j * coefficients.get(1).get(2) + k * coefficients.get(2).get(2);
    minz=Math.min(minz,comboz);
    maxz=Math.max(maxz,comboz);
  }
  List<Site> newBasisCandidates=new LinkedList<Site>();
  for (  Site s : cell.basis) {
    for (int i=minx; i <= maxx; i++) {
      for (int j=miny; j <= maxy; j++) {
        for (int k=minz; k <= maxz; k++) {
          Vect candidateSiteLoc=s.getCoords().plus(new Vect(new Double(i),new Double(j),new Double(k),cell.latticeVectors));
          List<Double> newFracCoords=candidateSiteLoc.getComponentsWRTBasis(newVectors);
          newBasisCandidates.add((new Site(s.getElement(),candidateSiteLoc.getVectShiftedIntoBasis(newVectors))));
        }
      }
    }
  }
  for (int i=0; i < newBasisCandidates.size(); i++) {
    Cell cWithRedundantSites=new Cell(newVectors,newBasisCandidates,cell.getLabel());
    Site s=cWithRedundantSites.getSite(i);
    for (    Site r : cWithRedundantSites.getAtomsInSphereSorted(s.getCoords(),Constants.epsilon)) {
      if (r != s) {
        newBasisCandidates.remove(r);
      }
    }
  }
  return new Cell(newVectors,newBasisCandidates,cell.getLabel());
}",0.8411987599035481
37798,"public static String getFindsymOutput(Cell cell){
  String output=runFindsym(getFindsymInput(cell,accuracy1));
  if (output.contains(""String_Node_Str"")) {
    output=runFindsym(getFindsymInput(cell,accuracy2));
  }
  return output;
}","public static String getFindsymOutput(Cell cell){
  String output=null;
  int bestSG=0;
  String bestOutput=null;
  for (int i=0; i < accuracies.length; i++) {
    output=runFindsym(getFindsymInput(cell,accuracies[i]));
    if (output.contains(""String_Node_Str""))     continue;
    int sg=getSpaceGroupIntFromFSOutput(output);
    if (sg >= bestSG) {
      bestSG=sg;
      bestOutput=output;
    }
  }
  return bestOutput;
}",0.486322188449848
37799,"public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  Cell b=Cell.parseCif(new File(""String_Node_Str""));
  System.out.println(a.matchesCell(b,0.1,0.1,0.1));
  System.out.println(getFindsymOutput(b));
}","public static void main(String args[]){
  Cell a=Cell.parseCif(new File(""String_Node_Str""));
  Cell b=Cell.parseCif(new File(""String_Node_Str""));
  System.out.println(a.matchesCell(b,0.1,0.1,0.1));
  System.out.println(getFindsymOutput(b.getNigliReducedCell()));
}",0.9565217391304348
37800,"public static Cell getWyckoffCell(Cell cell){
  Cell answer=null;
  String output=getFindsymOutput(cell);
  try {
    answer=parseWyckoffCell(output,cell);
  }
 catch (  Exception x) {
    if (GAParameters.getParams().getVerbosity() >= 4) {
      System.out.println(x.getLocalizedMessage());
      System.out.println(""String_Node_Str"");
      System.out.println(cell);
      System.out.println(getFindsymInput(cell,accuracy2));
    }
    answer=cell;
  }
  return answer;
}","public static Cell getWyckoffCell(Cell cell){
  Cell answer=null;
  String output=getFindsymOutput(cell);
  try {
    answer=parseWyckoffCell(output,cell);
  }
 catch (  Exception x) {
    if (GAParameters.getParams().getVerbosity() >= 4) {
      System.out.println(x.getLocalizedMessage());
      System.out.println(""String_Node_Str"");
      System.out.println(cell);
      System.out.println(getFindsymInput(cell,accuracies[0]));
      (new Exception()).printStackTrace();
    }
    answer=cell;
  }
  return answer;
}",0.94662638469285
37801,"public List<Organism> getOrganismsSorted(){
class StructureEnergyComparator implements Comparator<Organism> {
    public int compare(    Organism a,    Organism b){
      return a.getFitness() > b.getFitness() ? -1 : 1;
    }
  }
  List<Organism> sortedOrgs=new ArrayList<Organism>(organisms);
  Collections.sort(organisms,new StructureEnergyComparator());
  return sortedOrgs;
}","public List<Organism> getOrganismsSorted(){
class StructureEnergyComparator implements Comparator<Organism> {
    public int compare(    Organism a,    Organism b){
      return a.getFitness() > b.getFitness() ? -1 : 1;
    }
  }
  List<Organism> sortedOrgs=new ArrayList<Organism>(organisms);
  Collections.sort(sortedOrgs,new StructureEnergyComparator());
  return sortedOrgs;
}",0.9776021080368906
37802,"private double parseFinalEnergy(String lammpsOutput){
  Double finalEnergy=Double.POSITIVE_INFINITY;
  int verbosity=GAParameters.getParams().getVerbosity();
  String lines[]=lammpsOutput.split(""String_Node_Str"");
  int i;
  for (i=0; i < lines.length; i++) {
    if (lines[i].matches(""String_Node_Str"")) {
      String energies[]=lines[i + 2].trim().split(""String_Node_Str"");
      finalEnergy=Double.parseDouble(energies[4]);
    }
  }
  return finalEnergy;
}","private double parseFinalEnergy(String lammpsOutput){
  Double finalEnergy=Double.POSITIVE_INFINITY;
  int verbosity=GAParameters.getParams().getVerbosity();
  String lines[]=lammpsOutput.split(""String_Node_Str"");
  int i;
  for (i=0; i < lines.length; i++) {
    if (lines[i].matches(""String_Node_Str"")) {
      String energies[]=lines[i + 2].trim().split(""String_Node_Str"");
      try {
        finalEnergy=Double.parseDouble(energies[4]);
      }
 catch (      NumberFormatException x) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  return finalEnergy;
}",0.8865384615384615
37803,"private Cell parseOutputStructure(Cell origCell,String outFile){
  if (!(new File(outFile)).exists()) {
    if (GAParameters.getParams().getVerbosity() >= 4)     System.out.println(""String_Node_Str"");
    return null;
  }
  String output=Utility.readStringFromFile(outFile);
  List<Vect> basis=new LinkedList<Vect>();
  List<Site> sites=new LinkedList<Site>();
  String lines[]=output.split(""String_Node_Str"");
  int numAtoms=Integer.parseInt(lines[3]);
  String xs[]=lines[5].split(""String_Node_Str"");
  double xlo_bound=Double.parseDouble(xs[0]);
  double xhi_bound=Double.parseDouble(xs[1]);
  double xy=Double.parseDouble(xs[2]);
  String ys[]=lines[6].split(""String_Node_Str"");
  double ylo_bound=Double.parseDouble(ys[0]);
  double yhi_bound=Double.parseDouble(ys[1]);
  double xz=Double.parseDouble(ys[2]);
  String zs[]=lines[7].split(""String_Node_Str"");
  double zlo_bound=Double.parseDouble(zs[0]);
  double zhi_bound=Double.parseDouble(zs[1]);
  double yz=Double.parseDouble(zs[2]);
  double xlo=xlo_bound - Math.min(Math.min(0.0,xy),Math.min(xz,xy + xz));
  double xhi=xhi_bound - Math.max(Math.max(0.0,xy),Math.max(xz,xy + xz));
  double ylo=ylo_bound - Math.min(0.0,yz);
  double yhi=yhi_bound - Math.max(0.0,yz);
  double zlo=zlo_bound;
  double zhi=zhi_bound;
  basis.add(new Vect(xhi - xlo,0.0,0.0));
  basis.add(new Vect(xy,yhi - ylo,0.0));
  basis.add(new Vect(xz,yz,zhi - zlo));
  for (int i=0; i < numAtoms; i++) {
    String as[]=lines[9 + i].split(""String_Node_Str"");
    int type=Integer.parseInt(as[1]) - 1;
    double x=Double.parseDouble(as[2]);
    double y=Double.parseDouble(as[3]);
    double z=Double.parseDouble(as[4]);
    sites.add(new Site(origCell.getComposition().getElements().get(type),new Vect(x - xlo,y - ylo,z - zlo)));
  }
  if (origCell.getBasisSize() != numAtoms) {
    System.out.println(""String_Node_Str"");
    System.out.println(outFile);
  }
  return new Cell(basis,sites,origCell.getLabel());
}","private Cell parseOutputStructure(Cell origCell,String outFile){
  if (!(new File(outFile)).exists() || Utility.readStringFromFile(outFile).isEmpty()) {
    if (GAParameters.getParams().getVerbosity() >= 4)     System.out.println(""String_Node_Str"");
    return null;
  }
  String output=Utility.readStringFromFile(outFile);
  List<Vect> basis=new LinkedList<Vect>();
  List<Site> sites=new LinkedList<Site>();
  String lines[]=output.split(""String_Node_Str"");
  int numAtoms=Integer.parseInt(lines[3]);
  String xs[]=lines[5].split(""String_Node_Str"");
  double xlo_bound=Double.parseDouble(xs[0]);
  double xhi_bound=Double.parseDouble(xs[1]);
  double xy=Double.parseDouble(xs[2]);
  String ys[]=lines[6].split(""String_Node_Str"");
  double ylo_bound=Double.parseDouble(ys[0]);
  double yhi_bound=Double.parseDouble(ys[1]);
  double xz=Double.parseDouble(ys[2]);
  String zs[]=lines[7].split(""String_Node_Str"");
  double zlo_bound=Double.parseDouble(zs[0]);
  double zhi_bound=Double.parseDouble(zs[1]);
  double yz=Double.parseDouble(zs[2]);
  double xlo=xlo_bound - Math.min(Math.min(0.0,xy),Math.min(xz,xy + xz));
  double xhi=xhi_bound - Math.max(Math.max(0.0,xy),Math.max(xz,xy + xz));
  double ylo=ylo_bound - Math.min(0.0,yz);
  double yhi=yhi_bound - Math.max(0.0,yz);
  double zlo=zlo_bound;
  double zhi=zhi_bound;
  basis.add(new Vect(xhi - xlo,0.0,0.0));
  basis.add(new Vect(xy,yhi - ylo,0.0));
  basis.add(new Vect(xz,yz,zhi - zlo));
  for (int i=0; i < numAtoms; i++) {
    String as[]=lines[9 + i].split(""String_Node_Str"");
    int type=Integer.parseInt(as[1]) - 1;
    double x=Double.parseDouble(as[2]);
    double y=Double.parseDouble(as[3]);
    double z=Double.parseDouble(as[4]);
    sites.add(new Site(GAParameters.getParams().getCompSpace().getElements().get(type),new Vect(x - xlo,y - ylo,z - zlo)));
  }
  if (origCell.getBasisSize() != numAtoms) {
    System.out.println(""String_Node_Str"");
    System.out.println(outFile);
  }
  return new Cell(basis,sites,origCell.getLabel());
}",0.8504932962307109
37804,"private double lammpsRun(StructureOrg c){
  GAParameters params=GAParameters.getParams();
  double finalEnergy=Double.POSITIVE_INFINITY;
  int verbosity=GAParameters.getParams().getVerbosity();
  String outDirPath=params.getTempDirName() + ""String_Node_Str"" + params.getRunTitle()+ ""String_Node_Str""+ c.getID();
  File outDir=new File(outDirPath);
  outDir.mkdir();
  c.getCell().writeCIF(outDirPath + ""String_Node_Str"" + c.getID()+ ""String_Node_Str"");
  utility.Utility.writeStringToFile(getLammpsInputFile(c,potlStr),outDirPath + ""String_Node_Str"" + inFileName);
  utility.Utility.writeStringToFile(getLammpsDataFile(c),outDirPath + ""String_Node_Str"" + dataFileName);
  if (verbosity >= 3)   System.out.println(""String_Node_Str"" + c.getID());
  String lammpsOutput=runLAMMPS(outDir.getAbsolutePath());
  Cell a=parseOutputStructure(c.getCell(),outDirPath + ""String_Node_Str"" + dumpFileName);
  if (a == null) {
    if (verbosity >= 3)     System.out.println(""String_Node_Str"");
  }
 else {
    c.setCell(a);
  }
  finalEnergy=parseFinalEnergy(lammpsOutput);
  if (verbosity >= 3)   System.out.println(""String_Node_Str"" + c.getID() + ""String_Node_Str""+ finalEnergy+ ""String_Node_Str"");
  return finalEnergy;
}","private double lammpsRun(StructureOrg c){
  GAParameters params=GAParameters.getParams();
  double finalEnergy=Double.POSITIVE_INFINITY;
  int verbosity=GAParameters.getParams().getVerbosity();
  String outDirPath=params.getTempDirName() + ""String_Node_Str"" + params.getRunTitle()+ ""String_Node_Str""+ c.getID();
  File outDir=new File(outDirPath);
  outDir.mkdir();
  c.getCell().writeCIF(outDirPath + ""String_Node_Str"" + c.getID()+ ""String_Node_Str"");
  utility.Utility.writeStringToFile(getLammpsInputFile(c,potlStr),outDirPath + ""String_Node_Str"" + inFileName);
  utility.Utility.writeStringToFile(getLammpsDataFile(c),outDirPath + ""String_Node_Str"" + dataFileName);
  if (verbosity >= 3)   System.out.println(""String_Node_Str"" + c.getID());
  String lammpsOutput=runLAMMPS(outDir.getAbsolutePath());
  Cell a=parseOutputStructure(c.getCell(),outDirPath + ""String_Node_Str"" + dumpFileName);
  if (a == null) {
    if (verbosity >= 3)     System.out.println(""String_Node_Str"");
  }
 else {
    c.setCell(a);
    finalEnergy=parseFinalEnergy(lammpsOutput);
  }
  if (verbosity >= 3)   System.out.println(""String_Node_Str"" + c.getID() + ""String_Node_Str""+ finalEnergy+ ""String_Node_Str"");
  return finalEnergy;
}",0.9611890999174236
37805,"private static String getLammpsDataFile(StructureOrg c){
  Cell cell=c.getCell().getCellRotatedIntoPrincDirs();
  StringBuilder result=new StringBuilder();
  String newline=GAUtils.newline();
  DecimalFormat df=new DecimalFormat();
  df.setMaximumFractionDigits(6);
  result.append(""String_Node_Str"" + newline + newline);
  result.append(cell.getBasisSize() + ""String_Node_Str"" + newline);
  result.append(cell.getComposition().getNumElements() + ""String_Node_Str"" + newline);
  double xlo=0, xhi=cell.getLatticeVectors().get(0).getCartesianComponents().get(0);
  double ylo=0, yhi=cell.getLatticeVectors().get(1).getCartesianComponents().get(1);
  double zlo=0, zhi=cell.getLatticeVectors().get(2).getCartesianComponents().get(2);
  double xy=cell.getLatticeVectors().get(1).getCartesianComponents().get(0);
  double xz=cell.getLatticeVectors().get(2).getCartesianComponents().get(0);
  double yz=cell.getLatticeVectors().get(2).getCartesianComponents().get(1);
  result.append(xlo + ""String_Node_Str"" + xhi+ ""String_Node_Str""+ newline);
  result.append(ylo + ""String_Node_Str"" + yhi+ ""String_Node_Str""+ newline);
  result.append(zlo + ""String_Node_Str"" + zhi+ ""String_Node_Str""+ newline);
  result.append(xy + ""String_Node_Str"" + xz+ ""String_Node_Str""+ yz+ ""String_Node_Str""+ newline+ newline);
  result.append(""String_Node_Str"" + newline + newline);
  List<Element> elems=cell.getComposition().getElements();
  for (int i=0; i < elems.size(); i++)   result.append(i + 1 + ""String_Node_Str""+ elems.get(i).getAtomicMass()+ newline);
  result.append(newline + ""String_Node_Str"" + newline+ newline);
  for (int i=0; i < cell.getSites().size(); i++) {
    Site s=cell.getSites().get(i);
    result.append(i + 1 + ""String_Node_Str""+ (1 + cell.getComposition().getElements().indexOf(cell.getSite(i).getElement()))+ ""String_Node_Str"");
    for (    double d : s.getCoords().getCartesianComponents())     result.append(df.format(d) + ""String_Node_Str"");
    result.append(newline);
  }
  return result.toString();
}","private static String getLammpsDataFile(StructureOrg c){
  Cell cell=c.getCell().getCellRotatedIntoPrincDirs();
  CompositionSpace compSpace=GAParameters.getParams().getCompSpace();
  StringBuilder result=new StringBuilder();
  String newline=GAUtils.newline();
  DecimalFormat df=new DecimalFormat();
  df.setMaximumFractionDigits(6);
  result.append(""String_Node_Str"" + newline + newline);
  result.append(cell.getBasisSize() + ""String_Node_Str"" + newline);
  result.append(compSpace.getElements().size() + ""String_Node_Str"" + newline);
  double xlo=0, xhi=cell.getLatticeVectors().get(0).getCartesianComponents().get(0);
  double ylo=0, yhi=cell.getLatticeVectors().get(1).getCartesianComponents().get(1);
  double zlo=0, zhi=cell.getLatticeVectors().get(2).getCartesianComponents().get(2);
  double xy=cell.getLatticeVectors().get(1).getCartesianComponents().get(0);
  double xz=cell.getLatticeVectors().get(2).getCartesianComponents().get(0);
  double yz=cell.getLatticeVectors().get(2).getCartesianComponents().get(1);
  result.append(xlo + ""String_Node_Str"" + xhi+ ""String_Node_Str""+ newline);
  result.append(ylo + ""String_Node_Str"" + yhi+ ""String_Node_Str""+ newline);
  result.append(zlo + ""String_Node_Str"" + zhi+ ""String_Node_Str""+ newline);
  result.append(xy + ""String_Node_Str"" + xz+ ""String_Node_Str""+ yz+ ""String_Node_Str""+ newline+ newline);
  result.append(""String_Node_Str"" + newline + newline);
  List<Element> elems=compSpace.getElements();
  for (int i=0; i < elems.size(); i++)   result.append(i + 1 + ""String_Node_Str""+ elems.get(i).getAtomicMass()+ newline);
  result.append(newline + ""String_Node_Str"" + newline+ newline);
  for (int i=0; i < cell.getSites().size(); i++) {
    Site s=cell.getSites().get(i);
    result.append((i + 1) + ""String_Node_Str"" + (1 + compSpace.getElements().indexOf(cell.getSite(i).getElement()))+ ""String_Node_Str"");
    for (    double d : s.getCoords().getCartesianComponents())     result.append(df.format(d) + ""String_Node_Str"");
    result.append(newline);
  }
  return result.toString();
}",0.9568859324956884
37806,"public Composition getRandomIntegerCompInSpace(int minNumAtoms,int maxNumAtoms){
  Map<Element,Double> m=new HashMap<Element,Double>();
  double sumAtoms=0.0;
  for (  Composition c : endpoints) {
    double fracOfThisComp=GAParameters.getParams().getRandom().nextDouble();
    for (    Element e : elements) {
      double numOfElem=c.getStoichiometricUnit().get(e) * fracOfThisComp;
      sumAtoms+=numOfElem;
      if (m.keySet().contains(e))       m.put(e,m.get(e) + numOfElem);
 else       m.put(e,numOfElem);
    }
  }
  int targetNumAtoms=RandomNumbers.getUniformIntBetween(minNumAtoms,maxNumAtoms);
  Map<Element,Integer> c=new HashMap<Element,Integer>();
  for (  Element e : m.keySet())   c.put(e,Math.round(Math.round(m.get(e) * targetNumAtoms / sumAtoms)));
  return new Composition(c,false);
}","public Composition getRandomIntegerCompInSpace(int minNumAtoms,int maxNumAtoms){
  Map<Element,Double> m=new HashMap<Element,Double>();
  double sumAtoms=0.0;
  for (  Composition c : endpoints) {
    double fracOfThisComp=GAParameters.getParams().getRandom().nextDouble();
    for (    Element e : elements) {
      double numOfElem=c.getStoichiometricUnit().get(e) * fracOfThisComp;
      sumAtoms+=numOfElem;
      if (m.keySet().contains(e))       m.put(e,m.get(e) + numOfElem);
 else       m.put(e,numOfElem);
    }
  }
  int targetNumAtoms=RandomNumbers.getUniformIntBetweenInclusive(minNumAtoms,maxNumAtoms);
  Map<Element,Integer> c=new HashMap<Element,Integer>();
  for (  Element e : m.keySet())   c.put(e,Math.round(Math.round(m.get(e) * targetNumAtoms / sumAtoms)));
  return new Composition(c,false);
}",0.9944478716841456
37807,"private static Boolean madeEnough(Generation offspring){
  GAParameters params=GAParameters.getParams();
  if (GAParameters.getParams().getRecord().getGenNum() == 0) {
    List<Pair<StructureOrgCreator,Integer>> initialOrgCreators=params.getInitialOrgCreators();
    for (    Pair<StructureOrgCreator,Integer> i : initialOrgCreators) {
      if (i.getSecond() > 0)       return false;
    }
    if (GAParameters.getParams().getVerbosity() >= 1)     System.out.println(""String_Node_Str"");
    return true;
  }
 else {
    if (params.getNumCalcsInParallel() != 1)     return offspring.getNumOrganisms() >= params.getMinPopSize();
 else     return offspring.getNumOrganisms() >= params.getPopSize();
  }
}","private static Boolean madeEnough(Generation offspring){
  GAParameters params=GAParameters.getParams();
  if (GAParameters.getParams().getRecord().getGenNum() == 0) {
    List<Pair<StructureOrgCreator,Integer>> initialOrgCreators=params.getInitialOrgCreators();
    for (    Pair<StructureOrgCreator,Integer> i : initialOrgCreators) {
      if (i.getSecond() > 0)       return false;
    }
    if (GAParameters.getParams().getVerbosity() >= 1)     System.out.println(""String_Node_Str"");
    return true;
  }
 else {
    if (params.getNumCalcsInParallel() != 1)     return offspring.getNumOrganisms() >= Math.min(params.getMinPopSize(),params.getPopSize());
 else     return offspring.getNumOrganisms() >= params.getPopSize();
  }
}",0.9651324965132496
37808,"private void removeAtoms(int numAtoms,List<Site> newSites){
  GAParameters params=GAParameters.getParams();
  Random rand=params.getRandom();
  for (int i=0; i < numAtoms; i++) {
    newSites.remove(RandomNumbers.getUniformIntBetween(0,newSites.size()));
  }
}","private void removeAtoms(int numAtoms,List<Site> newSites){
  GAParameters params=GAParameters.getParams();
  Random rand=params.getRandom();
  for (int i=0; i < numAtoms; i++) {
    newSites.remove(RandomNumbers.getUniformIntBetweenInclusive(0,newSites.size() - 1));
  }
}",0.975609756097561
37809,"public Permutation(String[] args){
  if (args.length < 3)   GAParameters.usage(""String_Node_Str"",true);
  meanExchanges=Double.parseDouble(args[0]);
  sigmaExchanges=Double.parseDouble(args[1]);
  pairStrings=GAUtils.subArray(args,2);
}","public Permutation(String[] args){
  if (args.length < 3)   GAParameters.usage(""String_Node_Str"",true);
  meanExchanges=Double.parseDouble(args[0]);
  sigmaExchanges=Double.parseDouble(args[1]);
  if (meanExchanges == 0 && sigmaExchanges == 0)   GAParameters.usage(""String_Node_Str"",true);
  pairStrings=GAUtils.subArray(args,2);
}",0.8324514991181657
37810,"public Organism doVariation(Generation parents,Generation offspring,Selection sel){
  GAParameters params=GAParameters.getParams();
  int verbosity=params.getVerbosity();
  Random rand=params.getRandom();
  if (pairs == null)   pairs=GAUtils.parsePairs(pairStrings);
  Cell pStruct=((StructureOrg)(sel.doSelection(parents,1)[0])).getCell();
  List<Site> newSites=new ArrayList<Site>();
  List<Vect> newVects=new ArrayList<Vect>(pStruct.getLatticeVectors());
  for (  Site s : pStruct.getSites())   newSites.add(s);
  int numExchanges;
  do {
    numExchanges=Math.round(Math.round(rand.nextGaussian() * sigmaExchanges + meanExchanges));
  }
 while (numExchanges == 0);
  for (int i=0; i < numExchanges; i++) {
    Set<String> pair=pairs.get(rand.nextInt(pairs.size()));
    Iterator<String> j=pair.iterator();
    String firstSymbol=j.next();
    String secondSymbol=j.next();
    int indexA, indexB;
    do {
      indexA=rand.nextInt(newSites.size());
    }
 while (!newSites.get(indexA).getElement().getSymbol().startsWith(firstSymbol));
    do {
      indexB=rand.nextInt(newSites.size());
    }
 while (!newSites.get(indexB).getElement().getSymbol().startsWith(secondSymbol));
    Element elemA=newSites.get(indexA).getElement();
    Element elemB=newSites.get(indexB).getElement();
    newSites.set(indexA,new Site(elemB,newSites.get(indexA).getCoords()));
    newSites.set(indexB,new Site(elemA,newSites.get(indexB).getCoords()));
    if (verbosity >= 4)     System.out.println(""String_Node_Str"" + newSites.get(indexA).getElement() + ""String_Node_Str""+ newSites.get(indexB).getElement());
  }
  return new StructureOrg(new Cell(newVects,newSites));
}","public Organism doVariation(Generation parents,Generation offspring,Selection sel){
  GAParameters params=GAParameters.getParams();
  int verbosity=params.getVerbosity();
  Random rand=params.getRandom();
  if (pairs == null)   pairs=GAUtils.parsePairs(pairStrings);
  Cell pStruct=((StructureOrg)(sel.doSelection(parents,1)[0])).getCell();
  List<Site> newSites=new ArrayList<Site>();
  List<Vect> newVects=new ArrayList<Vect>(pStruct.getLatticeVectors());
  for (  Site s : pStruct.getSites())   newSites.add(s);
  int numExchanges;
  do {
    numExchanges=Math.round(Math.round(rand.nextGaussian() * sigmaExchanges + meanExchanges));
  }
 while (numExchanges == 0);
  for (int i=0; i < numExchanges; i++) {
    Set<String> pair=pairs.get(rand.nextInt(pairs.size()));
    Iterator<String> j=pair.iterator();
    String firstSymbol=j.next();
    String secondSymbol=j.next();
    if (pStruct.getNumSitesWithElement(Element.getElemFromSymbol(firstSymbol)) == 0 || pStruct.getNumSitesWithElement(Element.getElemFromSymbol(secondSymbol)) == 0)     continue;
    int indexA, indexB;
    do {
      indexA=rand.nextInt(newSites.size());
    }
 while (!newSites.get(indexA).getElement().getSymbol().startsWith(firstSymbol));
    do {
      indexB=rand.nextInt(newSites.size());
    }
 while (!newSites.get(indexB).getElement().getSymbol().startsWith(secondSymbol));
    Element elemA=newSites.get(indexA).getElement();
    Element elemB=newSites.get(indexB).getElement();
    newSites.set(indexA,new Site(elemB,newSites.get(indexA).getCoords()));
    newSites.set(indexB,new Site(elemA,newSites.get(indexB).getCoords()));
    if (verbosity >= 4)     System.out.println(""String_Node_Str"" + newSites.get(indexA).getElement() + ""String_Node_Str""+ newSites.get(indexB).getElement());
  }
  return new StructureOrg(new Cell(newVects,newSites));
}",0.9487546521614658
37811,"protected StructureOrg makeUnitOrg(){
  GAParameters params=GAParameters.getParams();
  Random rand=params.getRandom();
  List<Vect> latVects=RandomSOCreator.makeRandomLattice();
  ArrayList<Site> sitesList=new ArrayList<Site>();
  final int maxFails=100;
  int failCount=0;
  int totNum=0;
  for (int r=0; r < difUnits; r++) {
    totNum=totNum + numUnits[r] * numAtoms[r];
  }
  if (totNum > params.getMaxNumAtoms()) {
    GAParameters.usage(""String_Node_Str"",true);
  }
  int targetAtoms=RandomNumbers.getUniformIntBetween(numSites,params.getMaxNumAtoms());
  int totAtoms=0;
  double[] fracValues=new double[difUnits];
  double fracTotal=0.0;
  int[] target=new int[difUnits];
  units=new int[difUnits];
  if (numUnits[0] != 0) {
    for (int t=0; t < difUnits; t++) {
      target[t]=numUnits[t];
      units[t]=target[t];
    }
  }
 else {
    for (int y=0; y < difUnits; y++) {
      fracValues[y]=RandomNumbers.getUniformDoubleBetween(0.0,1.0);
      fracTotal=fracTotal + fracValues[y];
    }
    for (int y=0; y < difUnits; y++) {
      fracValues[y]=fracValues[y] / fracTotal;
      target[y]=(int)Math.round(fracValues[y] * targetAtoms);
      target[y]=target[y] / numAtoms[y];
      units[y]=target[y];
      totAtoms=totAtoms + target[y] * numAtoms[y];
    }
  }
  refLoc=new LinkedList<Vect>();
  for (int i=0; i < difUnits; i++) {
    for (int k=0; k < target[i]; k++) {
      int currentSite=0;
      for (int m=0; m < i; m++) {
        currentSite=currentSite + numAtoms[m];
      }
      List<Vect> basis=new LinkedList<Vect>();
      for (int n=0; n < numAtoms[i]; n++) {
        Site s=sites.get(n + currentSite);
        basis.add(s.getCoords());
      }
      List<Vect> rotatedBasis=getRandomRotation3D(basis,i);
      List<Site> newSites=new LinkedList<Site>();
      for (int p=0; p < numAtoms[i]; p++) {
        Site s=sites.get(p + currentSite);
        newSites.add(new Site(s.getElement(),rotatedBasis.get(p)));
      }
      Vect potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
      if (refLoc.size() > 0) {
        boolean regen=true;
        while (regen) {
          regen=false;
          for (          Vect v : refLoc) {
            double dist=potentialLocation.subtract(v).length();
            if (dist < params.getMinInteratomicDistance()) {
              regen=true;
            }
            potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
          }
        }
      }
      if ((new Cell(latVects,sitesList)).getAtomsInSphereSorted(potentialLocation,params.getMinInteratomicDistance()).size() == 0) {
        for (        Site r : newSites) {
          Element e=r.getElement();
          Vect relativeLoc=r.getCoords();
          Vect v=potentialLocation.plus(relativeLoc);
          sitesList.add(new Site(e,v));
          refLoc.add(potentialLocation);
        }
      }
 else       if (failCount < maxFails) {
        failCount++;
        k--;
      }
    }
  }
  if (!unitsOnly) {
    Composition comp=params.getCompSpace().getRandomIntegerCompInSpace(params.getMinNumAtoms(),(params.getMaxNumAtoms() - totAtoms));
    for (    Element e : comp.getElements())     for (int k=0; k < comp.getOrigAmount(e); k++) {
      Vect potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
      if ((new Cell(latVects,sitesList)).getAtomsInSphereSorted(potentialLocation,params.getMinInteratomicDistance()).size() == 0)       sitesList.add(new Site(e,potentialLocation));
 else       if (failCount < maxFails) {
        failCount++;
        k--;
      }
    }
  }
  Cell newStructure=new Cell(latVects,sitesList);
  Cell optimizedStructure=optimizeDensity(newStructure);
  m++;
  return new StructureOrg(optimizedStructure);
}","protected StructureOrg makeUnitOrg(){
  GAParameters params=GAParameters.getParams();
  Random rand=params.getRandom();
  List<Vect> latVects=RandomSOCreator.makeRandomLattice();
  ArrayList<Site> sitesList=new ArrayList<Site>();
  final int maxFails=100;
  int failCount=0;
  int totNum=0;
  for (int r=0; r < difUnits; r++) {
    totNum=totNum + numUnits[r] * numAtoms[r];
  }
  if (totNum > params.getMaxNumAtoms()) {
    GAParameters.usage(""String_Node_Str"",true);
  }
  int targetAtoms=RandomNumbers.getUniformIntBetweenInclusive(numSites,params.getMaxNumAtoms());
  int totAtoms=0;
  double[] fracValues=new double[difUnits];
  double fracTotal=0.0;
  int[] target=new int[difUnits];
  units=new int[difUnits];
  if (numUnits[0] != 0) {
    for (int t=0; t < difUnits; t++) {
      target[t]=numUnits[t];
      units[t]=target[t];
    }
  }
 else {
    for (int y=0; y < difUnits; y++) {
      fracValues[y]=RandomNumbers.getUniformDoubleBetween(0.0,1.0);
      fracTotal=fracTotal + fracValues[y];
    }
    for (int y=0; y < difUnits; y++) {
      fracValues[y]=fracValues[y] / fracTotal;
      target[y]=(int)Math.round(fracValues[y] * targetAtoms);
      target[y]=target[y] / numAtoms[y];
      units[y]=target[y];
      totAtoms=totAtoms + target[y] * numAtoms[y];
    }
  }
  refLoc=new LinkedList<Vect>();
  for (int i=0; i < difUnits; i++) {
    for (int k=0; k < target[i]; k++) {
      int currentSite=0;
      for (int m=0; m < i; m++) {
        currentSite=currentSite + numAtoms[m];
      }
      List<Vect> basis=new LinkedList<Vect>();
      for (int n=0; n < numAtoms[i]; n++) {
        Site s=sites.get(n + currentSite);
        basis.add(s.getCoords());
      }
      List<Vect> rotatedBasis=getRandomRotation3D(basis,i);
      List<Site> newSites=new LinkedList<Site>();
      for (int p=0; p < numAtoms[i]; p++) {
        Site s=sites.get(p + currentSite);
        newSites.add(new Site(s.getElement(),rotatedBasis.get(p)));
      }
      Vect potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
      if (refLoc.size() > 0) {
        boolean regen=true;
        while (regen) {
          regen=false;
          for (          Vect v : refLoc) {
            double dist=potentialLocation.subtract(v).length();
            if (dist < params.getMinInteratomicDistance()) {
              regen=true;
            }
            potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
          }
        }
      }
      if ((new Cell(latVects,sitesList)).getAtomsInSphereSorted(potentialLocation,params.getMinInteratomicDistance()).size() == 0) {
        for (        Site r : newSites) {
          Element e=r.getElement();
          Vect relativeLoc=r.getCoords();
          Vect v=potentialLocation.plus(relativeLoc);
          sitesList.add(new Site(e,v));
          refLoc.add(potentialLocation);
        }
      }
 else       if (failCount < maxFails) {
        failCount++;
        k--;
      }
    }
  }
  if (!unitsOnly) {
    Composition comp=params.getCompSpace().getRandomIntegerCompInSpace(params.getMinNumAtoms(),(params.getMaxNumAtoms() - totAtoms));
    for (    Element e : comp.getElements())     for (int k=0; k < comp.getOrigAmount(e); k++) {
      Vect potentialLocation=new Vect(rand.nextDouble(),rand.nextDouble(),rand.nextDouble(),latVects);
      if ((new Cell(latVects,sitesList)).getAtomsInSphereSorted(potentialLocation,params.getMinInteratomicDistance()).size() == 0)       sitesList.add(new Site(e,potentialLocation));
 else       if (failCount < maxFails) {
        failCount++;
        k--;
      }
    }
  }
  Cell newStructure=new Cell(latVects,sitesList);
  Cell optimizedStructure=optimizeDensity(newStructure);
  m++;
  return new StructureOrg(optimizedStructure);
}",0.9988146977479258
37812,"@Override public void onStart(IContext context) throws JFException {
  this.engine=context.getEngine();
  this.history=context.getHistory();
  this.context=context;
  this.orderIsOpen=false;
  this.console=context.getConsole();
  this.totalProfit=0;
  this.totalCommission=0;
  this.orderLabel=""String_Node_Str"";
  console.getOut().println(""String_Node_Str"");
  subscribeInstruments();
  if (isBuyOrder ^ isSellOrder) {
    if (isBuyOrder)     orderCmd=IEngine.OrderCommand.BUYLIMIT;
 else     orderCmd=IEngine.OrderCommand.SELLLIMIT;
  }
 else {
    console.getErr().println(""String_Node_Str"");
    return;
  }
  double takeProfitPips=stopLossPips;
  if (rewardRiskRatio != 1) {
    takeProfitPips*=rewardRiskRatio;
    if ((takeProfitPips % 0.1) != 0) {
      takeProfitPips=(new BigDecimal(takeProfitPips)).setScale(1,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
  }
  String direction=orderCmd.isLong() ? ""String_Node_Str"" : ""String_Node_Str"";
  IOrder order=submitOrder(this.constantCurrencyRisk,orderCmd,stopLossPips,takeProfitPips);
  console.getInfo().println(""String_Node_Str"" + order.getLabel() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ order.getStopLossPrice()+ ""String_Node_Str""+ order.getTakeProfitPrice()+ ""String_Node_Str""+ order.getAmount());
  this.orderIsOpen=true;
}","@Override public void onStart(IContext context) throws JFException {
  this.engine=context.getEngine();
  this.history=context.getHistory();
  this.context=context;
  this.orderIsOpen=false;
  this.console=context.getConsole();
  this.totalProfit=0;
  this.totalCommission=0;
  this.orderLabel=""String_Node_Str"";
  console.getOut().println(""String_Node_Str"");
  subscribeInstruments();
  if (isBuyOrder ^ isSellOrder) {
    if (isBuyOrder)     orderCmd=IEngine.OrderCommand.BUY;
 else     orderCmd=IEngine.OrderCommand.SELL;
  }
 else {
    console.getErr().println(""String_Node_Str"");
    return;
  }
  double takeProfitPips=stopLossPips;
  if (rewardRiskRatio != 1) {
    takeProfitPips*=rewardRiskRatio;
    if ((takeProfitPips % 0.1) != 0) {
      takeProfitPips=(new BigDecimal(takeProfitPips)).setScale(1,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
  }
  String direction=orderCmd.isLong() ? ""String_Node_Str"" : ""String_Node_Str"";
  IOrder order=submitOrder(this.constantCurrencyRisk,orderCmd,stopLossPips,takeProfitPips);
  console.getInfo().println(""String_Node_Str"" + order.getLabel() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ order.getStopLossPrice()+ ""String_Node_Str""+ order.getTakeProfitPrice()+ ""String_Node_Str""+ order.getAmount());
  this.orderIsOpen=true;
}",0.9961270333075136
37813,"@Override public void onStart(IContext context) throws JFException {
  this.engine=context.getEngine();
  this.history=context.getHistory();
  this.context=context;
  this.orderIsOpen=false;
  this.console=context.getConsole();
  this.totalProfit=0;
  this.totalCommission=0;
  this.orderLabel=""String_Node_Str"";
  console.getOut().println(""String_Node_Str"");
  subscribeInstruments();
  if (isBuyOrder ^ isSellOrder) {
    if (isBuyOrder)     orderCmd=IEngine.OrderCommand.BUYLIMIT;
 else     orderCmd=IEngine.OrderCommand.SELLLIMIT;
  }
 else {
    console.getErr().println(""String_Node_Str"");
    return;
  }
  double takeProfitPips=stopLossPips;
  if (rewardRiskRatio != 1) {
    takeProfitPips*=rewardRiskRatio;
    if ((takeProfitPips % 0.1) != 0) {
      takeProfitPips=(new BigDecimal(takeProfitPips)).setScale(1,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
  }
  String direction=orderCmd.isLong() ? ""String_Node_Str"" : ""String_Node_Str"";
  IOrder order=submitOrder(this.constantCurrencyRisk,orderCmd,stopLossPips,takeProfitPips);
  console.getInfo().println(""String_Node_Str"" + order.getLabel() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ order.getStopLossPrice()+ ""String_Node_Str""+ order.getTakeProfitPrice()+ ""String_Node_Str""+ order.getAmount());
  this.orderIsOpen=true;
}","@Override public void onStart(IContext context) throws JFException {
  this.engine=context.getEngine();
  this.history=context.getHistory();
  this.context=context;
  this.orderIsOpen=false;
  this.console=context.getConsole();
  this.totalProfit=0;
  this.totalCommission=0;
  this.orderLabel=""String_Node_Str"";
  console.getOut().println(""String_Node_Str"");
  subscribeInstruments();
  if (isBuyOrder ^ isSellOrder) {
    if (isBuyOrder)     orderCmd=IEngine.OrderCommand.BUY;
 else     orderCmd=IEngine.OrderCommand.SELL;
  }
 else {
    console.getErr().println(""String_Node_Str"");
    return;
  }
  double takeProfitPips=stopLossPips;
  if (rewardRiskRatio != 1) {
    takeProfitPips*=rewardRiskRatio;
    if ((takeProfitPips % 0.1) != 0) {
      takeProfitPips=(new BigDecimal(takeProfitPips)).setScale(1,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
  }
  String direction=orderCmd.isLong() ? ""String_Node_Str"" : ""String_Node_Str"";
  IOrder order=submitOrder(this.constantCurrencyRisk,orderCmd,stopLossPips,takeProfitPips);
  console.getInfo().println(""String_Node_Str"" + order.getLabel() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ order.getStopLossPrice()+ ""String_Node_Str""+ order.getTakeProfitPrice()+ ""String_Node_Str""+ order.getAmount());
  this.orderIsOpen=true;
}",0.9961270333075136
37814,"@Override public void onBar(Instrument instrument,Period period,IBar askBar,IBar bidBar) throws JFException {
  if (instrument.equals(this.instrument) && period.equals(Period.ONE_MIN) && (orderIsOpen)) {
    checkSLMoveBE(askBar,bidBar);
  }
  if (instrument.equals(this.instrument) && period.equals(this.period) && (orderIsOpen)) {
    double[] haCandle=indicators.heikinAshi(instrument,period,OfferSide.BID,1);
    double haOpen=haCandle[0];
    double haClose=haCandle[1];
    console.getErr().println(""String_Node_Str"" + haOpen + ""String_Node_Str""+ haClose);
    boolean closeOrder=false;
    if (isBuyOrder) {
      if (haClose < haOpen) {
        closeOrder=true;
      }
    }
 else {
      if (haClose > haOpen) {
        closeOrder=true;
      }
    }
    if (closeOrder) {
      IOrder o=engine.getOrder(orderLabel);
      if (o != null) {
        o.close();
        this.orderIsOpen=false;
      }
 else {
        console.getErr().println(""String_Node_Str"" + orderLabel + ""String_Node_Str"");
      }
    }
  }
}","@Override public void onBar(Instrument instrument,Period period,IBar askBar,IBar bidBar) throws JFException {
  if (instrument.equals(this.instrument) && period.equals(Period.ONE_MIN) && (orderIsOpen)) {
    checkSLMoveBE(askBar,bidBar);
  }
  if (instrument.equals(this.instrument) && period.equals(this.period) && (orderIsOpen)) {
    double[] haCandle=indicators.heikinAshi(instrument,period,OfferSide.BID,1);
    double haOpen=haCandle[0];
    double haClose=haCandle[1];
    boolean closeOrder=false;
    if (isBuyOrder) {
      if (haClose < haOpen) {
        closeOrder=true;
      }
    }
 else {
      if (haClose > haOpen) {
        closeOrder=true;
      }
    }
    if (closeOrder) {
      IOrder o=engine.getOrder(orderLabel);
      if (o != null) {
        o.close();
        this.orderIsOpen=false;
      }
 else {
        console.getErr().println(""String_Node_Str"" + orderLabel + ""String_Node_Str"");
      }
    }
  }
}",0.5784363822176801
37815,"/** 
 * Load image request. Loads synchronously image specified by request. Adds loaded image to cache.
 * @param req image request
 * @param preview loading preview or not.
 * @return loaded image.
 */
public static Bitmap loadImage(final ImageManagerRequest req,final boolean preview){
  if (req == null) {
    return null;
  }
  if (logging) {
    Log.d(TAG,""String_Node_Str"" + (preview ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ req);
  }
  Bitmap bmp=null;
  final Options opts=new Options();
  opts.inSampleSize=preview ? 8 : req.subsample;
  if (req.filename != null) {
    final File file=new File(req.filename);
    if (!file.exists() || file.isDirectory()) {
      if (logging) {
        Log.e(TAG,""String_Node_Str"" + req + ""String_Node_Str"");
      }
      return null;
    }
    bmp=BitmapFactory.decodeFile(req.filename,opts);
    if (bmp == null && logging) {
      Log.e(TAG,""String_Node_Str"" + req.filename);
    }
  }
 else   if (req.resId >= 0) {
    bmp=BitmapFactory.decodeResource(application.getResources(),req.resId,opts);
    if (bmp == null && logging) {
      Log.e(TAG,""String_Node_Str"" + req.resId);
    }
  }
 else   if (req.uri != null) {
    try {
      final InputStream is=new URL(req.uri.toString()).openStream();
      bmp=BitmapFactory.decodeStream(is,null,opts);
      is.close();
      if (bmp == null && logging) {
        Log.e(TAG,""String_Node_Str"" + req.uri);
      }
    }
 catch (    final Exception e) {
      if (logging) {
        Log.e(TAG,""String_Node_Str"" + req.uri);
      }
    }
  }
  if (bmp == null) {
    return null;
  }
  if (!preview && (req.width > 0 && req.height > 0)) {
    final Bitmap sBmp=Bitmap.createScaledBitmap(bmp,req.width,req.height,true);
    if (sBmp != null) {
      bmp.recycle();
      bmp=sBmp;
    }
  }
  if (logging) {
    Log.d(TAG,(preview ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + req+ ""String_Node_Str"");
  }
  return bmp;
}","/** 
 * Load image request. Loads synchronously image specified by request. Adds loaded image to cache.
 * @param req image request
 * @param preview loading preview or not.
 * @return loaded image.
 */
public static Bitmap loadImage(final ImageManagerRequest req,final boolean preview){
  if (req == null) {
    return null;
  }
  if (logging) {
    Log.d(TAG,""String_Node_Str"" + (preview ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ req);
  }
  Bitmap bmp=null;
  final Options opts=new Options();
  opts.inSampleSize=(preview ? 8 : 1) * req.subsample;
  if (req.filename != null) {
    final File file=new File(req.filename);
    if (!file.exists() || file.isDirectory()) {
      if (logging) {
        Log.e(TAG,""String_Node_Str"" + req + ""String_Node_Str"");
      }
      return null;
    }
    bmp=BitmapFactory.decodeFile(req.filename,opts);
    if (bmp == null && logging) {
      Log.e(TAG,""String_Node_Str"" + req.filename);
    }
  }
 else   if (req.resId >= 0) {
    bmp=BitmapFactory.decodeResource(application.getResources(),req.resId,opts);
    if (bmp == null && logging) {
      Log.e(TAG,""String_Node_Str"" + req.resId);
    }
  }
 else   if (req.uri != null) {
    try {
      final InputStream is=new URL(req.uri.toString()).openStream();
      bmp=BitmapFactory.decodeStream(is,null,opts);
      is.close();
      if (bmp == null && logging) {
        Log.e(TAG,""String_Node_Str"" + req.uri);
      }
    }
 catch (    final Exception e) {
      if (logging) {
        Log.e(TAG,""String_Node_Str"" + req.uri);
      }
    }
  }
  if (bmp == null) {
    return null;
  }
  if (!preview && (req.width > 0 && req.height > 0)) {
    final Bitmap sBmp=Bitmap.createScaledBitmap(bmp,req.width,req.height,true);
    if (sBmp != bmp) {
      bmp.recycle();
      bmp=sBmp;
    }
  }
  if (logging) {
    Log.d(TAG,(preview ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + req+ ""String_Node_Str"");
  }
  return bmp;
}",0.9966709346991036
37816,"@Before public void setUp(){
  FakeApplication app=Helpers.fakeApplication();
  Helpers.start(app);
  Option<JPAPlugin> jpaPlugin=app.getWrappedApplication().plugin(JPAPlugin.class);
  em=jpaPlugin.get().em(""String_Node_Str"");
  JPA.bindForCurrentThread(em);
}","@Before public void setUp(){
  FakeApplication app=Helpers.fakeApplication();
  Helpers.start(app);
  Option<JPAPlugin> jpaPlugin=app.getWrappedApplication().plugin(JPAPlugin.class);
  em=jpaPlugin.get().em(""String_Node_Str"");
  JPA.bindForCurrentThread(em);
  em.getTransaction().begin();
}",0.943738656987296
37817,"@After public void tearDown(){
  JPA.bindForCurrentThread(null);
  em.close();
}","@After public void tearDown(){
  em.getTransaction().commit();
  JPA.bindForCurrentThread(null);
  em.close();
}",0.8333333333333334
37818,"public void doDelete(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  BufferedReader br=new BufferedReader(new InputStreamReader(request.getInputStream()));
  String json=""String_Node_Str"";
  if (br != null) {
    String nextLine=br.readLine();
    while (nextLine != null) {
      json+=nextLine;
      nextLine=br.readLine();
    }
    br.close();
  }
  System.out.println(json);
  ScheduleResponse jobData=this.mapper.readValue(json,ScheduleResponse.class);
  response.setContentType(""String_Node_Str"");
  ScheduleResponse responseContent=unschedule(jobData);
  mapper.writeValue(response.getOutputStream(),responseContent);
}","public void doDelete(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  String path=request.getRequestURI();
  String[] parts=path.split(""String_Node_Str"");
  String key=parts[parts.length - 1];
  response.setContentType(""String_Node_Str"");
  ScheduleResponse responseContent=unschedule(key);
  mapper.writeValue(response.getOutputStream(),responseContent);
}",0.559040590405904
37819,"private ScheduleResponse unschedule(ScheduleResponse jobDataCancel){
  String[] parts=jobDataCancel.getKey().split(""String_Node_Str"");
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(""String_Node_Str"");
  if (parts.length == 2) {
    try {
      scheduler.deleteJob(new JobKey(parts[1],parts[0]));
      response.setKey(""String_Node_Str"");
      return response;
    }
 catch (    SchedulerException e) {
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return response;
}","private ScheduleResponse unschedule(String key){
  String[] parts=key.split(""String_Node_Str"");
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(""String_Node_Str"");
  if (parts.length == 2) {
    try {
      scheduler.deleteJob(new JobKey(parts[1],parts[0]));
      response.setKey(""String_Node_Str"");
      return response;
    }
 catch (    SchedulerException e) {
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return response;
}",0.9381746810598626
37820,"private ScheduleResponse schedule(JobData jobData) throws SchedulerException {
  JobDetail job=newJob(HttpJob.class).withIdentity(UUID.randomUUID().toString(),""String_Node_Str"").usingJobData(""String_Node_Str"",jobData.getUrl()).usingJobData(""String_Node_Str"",jobData.getPayload()).build();
  Date startTime=new Date(jobData.getTimestamp());
  Trigger trigger=newTrigger().withIdentity(UUID.randomUUID().toString(),""String_Node_Str"").startAt(startTime).build();
  scheduler.scheduleJob(job,trigger);
  TriggerKey triggerKey=trigger.getKey();
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(triggerKey.getGroup() + ""String_Node_Str"" + triggerKey.getName());
  System.out.println(""String_Node_Str"" + startTime);
  return response;
}","private ScheduleResponse schedule(JobData jobData) throws SchedulerException {
  JobDetail job=newJob(HttpJob.class).withIdentity(UUID.randomUUID().toString(),""String_Node_Str"").usingJobData(""String_Node_Str"",jobData.getUrl()).usingJobData(""String_Node_Str"",jobData.getPayload()).build();
  Date startTime=new Date(jobData.getTimestamp());
  Trigger trigger=newTrigger().withIdentity(UUID.randomUUID().toString(),""String_Node_Str"").startAt(startTime).build();
  scheduler.scheduleJob(job,trigger);
  TriggerKey triggerKey=trigger.getKey();
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(triggerKey.getGroup() + JobDataId.groupDelimiter + triggerKey.getName()+ JobDataId.triggerJobDelimiter+ job.getKey().getName());
  System.out.println(""String_Node_Str"" + startTime);
  return response;
}",0.9295774647887324
37821,"public void doDelete(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  System.out.println(""String_Node_Str"");
  String path=request.getRequestURI();
  String[] parts=path.split(""String_Node_Str"");
  String key=parts[parts.length - 1];
  response.setContentType(""String_Node_Str"");
  ScheduleResponse responseContent=unschedule(key);
  mapper.writeValue(response.getOutputStream(),responseContent);
  System.out.println(""String_Node_Str"");
}","public void doDelete(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  System.out.println(""String_Node_Str"");
  String path=request.getRequestURI();
  String[] parts=path.split(""String_Node_Str"");
  String key=parts[parts.length - 1];
  System.out.println(""String_Node_Str"" + key);
  JobDataId jobDataId=new JobDataId();
  jobDataId.setJobId(key);
  response.setContentType(""String_Node_Str"");
  ScheduleResponse responseContent=unschedule(jobDataId);
  mapper.writeValue(response.getOutputStream(),responseContent);
  System.out.println(""String_Node_Str"");
}",0.7506849315068493
37822,"private ScheduleResponse update(JobData jobData,JobDataId jobDataId) throws SchedulerException {
  JobDetail job=newJob(HttpJob.class).withIdentity(jobDataId.getName(),jobDataId.getGroup()).usingJobData(""String_Node_Str"",jobData.getUrl()).usingJobData(""String_Node_Str"",jobData.getPayload()).build();
  scheduler.addJob(job,true,true);
  Date startTime=new Date(jobData.getTimestamp());
  Trigger oldTrigger=scheduler.getTrigger(TriggerKey.triggerKey(jobDataId.getName(),jobDataId.getGroup()));
  Trigger newTrigger=newTrigger().withIdentity(jobDataId.getName(),jobDataId.getGroup()).startAt(startTime).build();
  scheduler.rescheduleJob(oldTrigger.getKey(),newTrigger);
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(jobDataId.getJobId());
  System.out.println(""String_Node_Str"" + jobDataId.getJobId());
  return response;
}","private ScheduleResponse update(JobData jobData,JobDataId jobDataId) throws SchedulerException {
  System.out.println(jobData);
  JobDetail job=newJob(HttpJob.class).withIdentity(jobDataId.getJobName(),jobDataId.getGroup()).usingJobData(""String_Node_Str"",jobData.getUrl()).usingJobData(""String_Node_Str"",jobData.getPayload()).build();
  scheduler.addJob(job,true,true);
  Date startTime=new Date(jobData.getTimestamp());
  Trigger oldTrigger=scheduler.getTrigger(TriggerKey.triggerKey(jobDataId.getTriggerName(),jobDataId.getGroup()));
  Trigger newTrigger=newTrigger().withIdentity(jobDataId.getTriggerName(),jobDataId.getGroup()).startAt(startTime).build();
  scheduler.rescheduleJob(oldTrigger.getKey(),newTrigger);
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(jobDataId.getJobId());
  System.out.println(""String_Node_Str"" + jobDataId.getJobId());
  return response;
}",0.9724770642201837
37823,"private ScheduleResponse unschedule(String key){
  String[] parts=key.split(""String_Node_Str"");
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(""String_Node_Str"");
  if (parts.length == 2) {
    try {
      scheduler.deleteJob(new JobKey(parts[1],parts[0]));
      response.setKey(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + key);
      return response;
    }
 catch (    SchedulerException e) {
      System.out.println(""String_Node_Str"" + key);
      e.printStackTrace();
    }
  }
 else {
    System.out.println(""String_Node_Str"" + key);
  }
  return response;
}","private ScheduleResponse unschedule(JobDataId jobDataId){
  ScheduleResponse response=new ScheduleResponse();
  response.setKey(""String_Node_Str"");
  try {
    scheduler.deleteJob(new JobKey(jobDataId.getJobName(),jobDataId.getGroup()));
    response.setKey(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + jobDataId.getJobName());
    return response;
  }
 catch (  SchedulerException e) {
    System.out.println(""String_Node_Str"" + jobDataId.getJobName());
    e.printStackTrace();
  }
  return response;
}",0.3575221238938053
37824,"public String getName(){
  if (jobId == null) {
    return ""String_Node_Str"";
  }
  String[] parts=jobId.split(""String_Node_Str"");
  if (parts.length > 1) {
    return parts[1];
  }
  return ""String_Node_Str"";
}","private String getName(){
  if (jobId == null) {
    return ""String_Node_Str"";
  }
  String[] parts=jobId.split(groupDelimiter);
  if (parts.length > 1) {
    return parts[1];
  }
  return ""String_Node_Str"";
}",0.9
37825,"public String getGroup(){
  if (jobId == null) {
    return ""String_Node_Str"";
  }
  return jobId.split(""String_Node_Str"")[0];
}","public String getGroup(){
  if (jobId == null) {
    return ""String_Node_Str"";
  }
  return jobId.split(groupDelimiter)[0];
}",0.8932806324110671
37826,"private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
  s.defaultReadObject();
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + manList.size() + ""String_Node_Str""+ buildingsList.size());
  for (  Man man : manList) {
    Singleton.getInstance(Renderer.class).attachDrawScissor(man);
  }
  for (  Building building : buildingsList) {
    Singleton.getInstance(Renderer.class).attachDrawScissor(building);
    Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(building);
    if (building.getType() == BuildingType.FarmHouse)     for (    FarmLand land : ((FarmHouse)building).getFarmLands()) {
      Singleton.getInstance(Renderer.class).attachDrawScissor(land);
      Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(land);
    }
    if (building.getType() == BuildingType.Ranch)     for (    RanchLand land : ((Ranch)building).getRanchLands()) {
      Singleton.getInstance(Renderer.class).attachDrawScissor(land);
      Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(land);
    }
  }
}","private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
  s.defaultReadObject();
  Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + manList.size() + ""String_Node_Str""+ buildingsList.size());
  for (  Man man : manList) {
    Singleton.getInstance(Renderer.class).attachDrawScissor(man);
  }
  for (  Building building : buildingsList) {
    Singleton.getInstance(Renderer.class).attachDrawScissor(building);
    Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(building);
    if (building.getType() == BuildingType.FarmHouse)     for (    FarmLand land : ((FarmHouse)building).getFarmLands()) {
      Singleton.getInstance(Renderer.class).attachDrawScissor(land);
      Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(land);
    }
    if (building.getType() == BuildingType.Ranch)     for (    RanchLand land : ((Ranch)building).getRanchLands()) {
      Singleton.getInstance(Renderer.class).attachDrawScissor(land);
      Singleton.getInstance(CollisionDetector.class).attachCollisionDetection(land);
    }
  }
  for (  Man man : manList) {
    ManInfo minfo=man.getInfo();
    minfo.interpretBuildingHashCode(buildingsList);
  }
}",0.9484625378951927
37827,"public Building(String textureName,BuildingType type){
  super(textureName);
  this.buildingType=type;
  init();
  mSprite.getTexture().setFilter(TextureFilter.Linear,TextureFilter.Linear);
}","public Building(String textureName,BuildingType type){
  super(textureName);
  this.buildingType=type;
  init();
  mSprite.getTexture().setFilter(TextureFilter.Linear,TextureFilter.Linear);
  hashCode=hashCode();
}",0.94320987654321
37828,"void addBuilderButtons(){
  for (int i=0; i < numAllowed; i++) {
    FlipButton btn;
    btn=new FlipButton(allowedBuilderTexture,allowedBuilderTexture,null);
    builderButtons.add(btn);
    btn.setPosition(BUILDER_WIDTH * i,0);
    btn.setSize(BUILDER_WIDTH,BUILDER_WIDTH);
    final int indexOfClickedButton=i;
    btn.addListener(new EventListener(){
      @Override public boolean handle(      Event event){
        FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
        if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
          clickedButton.setImgUp(allowedBuilderTexture);
          numSelected=indexOfClickedButton + 1;
        }
 else {
          clickedButton.setImgUp(forbiddenBuilderTexture);
          numSelected=indexOfClickedButton;
        }
        window.builderLimitSelected(numSelected);
        for (int i=0; i < numAllowed; i++) {
          if (i == indexOfClickedButton)           continue;
          if (i < numSelected) {
            if (i < numBuilder) {
              builderButtons.get(i).setImgUp(builderTexture);
            }
 else {
              builderButtons.get(i).setImgUp(allowedBuilderTexture);
            }
          }
 else {
            builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
          }
        }
        return true;
      }
    }
);
    addActor(btn);
  }
}","void addBuilderButtons(){
  for (int i=0; i < numAllowed; i++) {
    FlipButton btn;
    btn=new FlipButton(allowedBuilderTexture,allowedBuilderTexture,null);
    builderButtons.add(btn);
    btn.setPosition(BUILDER_WIDTH * i,0);
    btn.setSize(BUILDER_WIDTH,BUILDER_WIDTH);
    final int indexOfClickedButton=i;
    btn.addListener(new InputListener(){
      @Override public boolean touchDown(      InputEvent event,      float x,      float y,      int pointer,      int button){
        FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
        if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
          clickedButton.setImgUp(allowedBuilderTexture);
          numSelected=indexOfClickedButton + 1;
        }
 else {
          clickedButton.setImgUp(forbiddenBuilderTexture);
          numSelected=indexOfClickedButton;
        }
        window.builderLimitSelected(numSelected);
        for (int i=0; i < numAllowed; i++) {
          if (i == indexOfClickedButton)           continue;
          if (i < numSelected) {
            if (i < numBuilder) {
              builderButtons.get(i).setImgUp(builderTexture);
            }
 else {
              builderButtons.get(i).setImgUp(allowedBuilderTexture);
            }
          }
 else {
            builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
          }
        }
        return true;
      }
    }
);
    addActor(btn);
  }
}",0.9629363080244692
37829,"public void doConstructionWork(int amount){
  finishedConstructionWork=Math.min(constructionWork,finishedConstructionWork + amount);
  constructionWindow.setProcess(getProcess());
}","public void doConstructionWork(int amount){
  finishedConstructionWork=Math.min(constructionWork,finishedConstructionWork + amount);
  if (constructionWindow != null)   constructionWindow.setProcess(getProcess());
}",0.914141414141414
37830,"void addBuilderButtons(){
  for (int i=0; i < numAllowed; i++) {
    FlipButton btn;
    btn=new FlipButton(allowedBuilderTexture,allowedBuilderTexture,null);
    builderButtons.add(btn);
    btn.setPosition(BUILDER_WIDTH * i,0);
    btn.setSize(BUILDER_WIDTH,BUILDER_WIDTH);
    final int indexOfClickedButton=i;
    btn.addListener(new EventListener(){
      @Override public boolean handle(      Event event){
        FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
        if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
          clickedButton.setImgUp(allowedBuilderTexture);
          numSelected++;
        }
 else {
          clickedButton.setImgUp(forbiddenBuilderTexture);
          numSelected--;
        }
        numSelected=indexOfClickedButton + 1;
        window.builderLimitSelected(numSelected);
        for (int i=0; i < numAllowed; i++) {
          if (i == indexOfClickedButton)           continue;
          if (i < numSelected) {
            if (i < numBuilder) {
              builderButtons.get(i).setImgUp(builderTexture);
            }
 else {
              builderButtons.get(i).setImgUp(allowedBuilderTexture);
            }
          }
 else {
            builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
          }
        }
        return true;
      }
    }
);
    addActor(btn);
  }
}","void addBuilderButtons(){
  for (int i=0; i < numAllowed; i++) {
    FlipButton btn;
    btn=new FlipButton(allowedBuilderTexture,allowedBuilderTexture,null);
    builderButtons.add(btn);
    btn.setPosition(BUILDER_WIDTH * i,0);
    btn.setSize(BUILDER_WIDTH,BUILDER_WIDTH);
    final int indexOfClickedButton=i;
    btn.addListener(new EventListener(){
      @Override public boolean handle(      Event event){
        FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
        if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
          clickedButton.setImgUp(allowedBuilderTexture);
          numSelected=indexOfClickedButton + 1;
        }
 else {
          clickedButton.setImgUp(forbiddenBuilderTexture);
          numSelected=indexOfClickedButton;
        }
        window.builderLimitSelected(numSelected);
        for (int i=0; i < numAllowed; i++) {
          if (i == indexOfClickedButton)           continue;
          if (i < numSelected) {
            if (i < numBuilder) {
              builderButtons.get(i).setImgUp(builderTexture);
            }
 else {
              builderButtons.get(i).setImgUp(allowedBuilderTexture);
            }
          }
 else {
            builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
          }
        }
        return true;
      }
    }
);
    addActor(btn);
  }
}",0.9727138643067846
37831,"@Override public boolean handle(Event event){
  FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
  if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
    clickedButton.setImgUp(allowedBuilderTexture);
    numSelected++;
  }
 else {
    clickedButton.setImgUp(forbiddenBuilderTexture);
    numSelected--;
  }
  numSelected=indexOfClickedButton + 1;
  window.builderLimitSelected(numSelected);
  for (int i=0; i < numAllowed; i++) {
    if (i == indexOfClickedButton)     continue;
    if (i < numSelected) {
      if (i < numBuilder) {
        builderButtons.get(i).setImgUp(builderTexture);
      }
 else {
        builderButtons.get(i).setImgUp(allowedBuilderTexture);
      }
    }
 else {
      builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
    }
  }
  return true;
}","@Override public boolean handle(Event event){
  FlipButton clickedButton=builderButtons.get(indexOfClickedButton);
  if (clickedButton.getImgUp() == forbiddenBuilderTexture) {
    clickedButton.setImgUp(allowedBuilderTexture);
    numSelected=indexOfClickedButton + 1;
  }
 else {
    clickedButton.setImgUp(forbiddenBuilderTexture);
    numSelected=indexOfClickedButton;
  }
  window.builderLimitSelected(numSelected);
  for (int i=0; i < numAllowed; i++) {
    if (i == indexOfClickedButton)     continue;
    if (i < numSelected) {
      if (i < numBuilder) {
        builderButtons.get(i).setImgUp(builderTexture);
      }
 else {
        builderButtons.get(i).setImgUp(allowedBuilderTexture);
      }
    }
 else {
      builderButtons.get(i).setImgUp(forbiddenBuilderTexture);
    }
  }
  return true;
}",0.5420792079207921
37832,"public void createTestWindow(){
}","public void createTestWindow(){
  LabelStyle labelStyle=new LabelStyle();
  labelStyle.font=ResourceManager.getInstance(ResourceManager.class).getFont((int)(Settings.UNIT * 0.3f));
  labelStyle.fontColor=Color.WHITE;
  Label label=new Label(""String_Node_Str"",labelStyle);
  label.setSize(60,40);
  label.setPosition(0,0);
  label.setAlignment(Align.center);
  Table table=new Table();
  table.add(label).spaceLeft(10f);
  table.setSize(200,200);
  table.setPosition(300,300);
  mStage.addActor(table);
}",0.1231343283582089
37833,"/** 
 * @param args
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
  Linear.resetRandom();
  String paths[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  float sampleRates[]={1,1,1,1,0.07f};
  Element elem=XMLConfigs.load(new FileReader(""String_Node_Str""));
  QuantityCatalog quantDict=new QuantityCatalog(elem);
  RuleBasedParser parser=new RuleBasedParser(elem,quantDict);
  ConceptClassifier classifier=null;
  if (args.length > 0 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    classifier=new ConceptClassifier(elem,quantDict,false,parser);
    classifier.makeClassifier(QuantityCatalog.QuantConfigDirPath + ConceptClassifier.ClassifierFile + ""String_Node_Str"");
  }
 else {
    classifier=new ConceptClassifier(elem,quantDict,parser,QuantityCatalog.QuantConfigDirPath + ConceptClassifier.ClassifierFile);
  }
  String conceptTests[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String hdr : conceptTests) {
    System.out.print(hdr);
    List<String> tokens=QuantityCatalog.getTokens(hdr);
    List<EntryWithScore<Quantity>> scores=classifier.getConceptScores(hdr);
    if (scores != null) {
      for (Iterator<EntryWithScore<Quantity>> iter=scores.iterator(); iter.hasNext(); ) {
        EntryWithScore<Quantity> entry=iter.next();
        System.out.print(""String_Node_Str"" + entry.getKey().getConcept() + ""String_Node_Str""+ entry.getScore());
      }
      System.out.println();
    }
  }
}","/** 
 * @param args
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
  Linear.resetRandom();
  String paths[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  float sampleRates[]={1,1,1,1,0.07f};
  Element elem=XMLConfigs.load(new FileReader(""String_Node_Str""));
  QuantityCatalog quantDict=new QuantityCatalog(elem);
  RuleBasedParser parser=new RuleBasedParser(elem,quantDict);
  ConceptClassifier classifier=null;
  if (args.length > 0 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    classifier=new ConceptClassifier(elem,quantDict,false,parser);
    classifier.makeClassifier(QuantityCatalog.QuantConfigDirPath + ConceptClassifier.ClassifierFile + ""String_Node_Str"");
  }
 else {
    classifier=new ConceptClassifier(quantDict);
  }
  String conceptTests[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String hdr : conceptTests) {
    System.out.print(hdr);
    List<String> tokens=QuantityCatalog.getTokens(hdr);
    List<EntryWithScore<Quantity>> scores=classifier.getConceptScores(hdr);
    if (scores != null) {
      for (Iterator<EntryWithScore<Quantity>> iter=scores.iterator(); iter.hasNext(); ) {
        EntryWithScore<Quantity> entry=iter.next();
        System.out.print(""String_Node_Str"" + entry.getKey().getConcept() + ""String_Node_Str""+ entry.getScore());
      }
      System.out.println();
    }
  }
}",0.976691301876066
37834,"public boolean sameConcept(Unit toUnit){
  if (this.getBaseName() != toUnit.getBaseName() && getParentQuantity() != toUnit.getParentQuantity() && !getParentQuantity().getConcept().equals(toUnit.getParentQuantity().getConcept())) {
    return false;
  }
  return true;
}","public boolean sameConcept(Unit toUnit){
  if (!this.getBaseName().equalsIgnoreCase(toUnit.getBaseName()) && getParentQuantity() != toUnit.getParentQuantity() && (getParentQuantity() == null || toUnit.getParentQuantity() == null || !getParentQuantity().getConcept().equalsIgnoreCase(toUnit.getParentQuantity().getConcept()))) {
    return false;
  }
  return true;
}",0.8346456692913385
37835,"private void doInsideChartCell(final int diff,final int start){
  final boolean lengthNormalization=op.testOptions.lengthNormalization;
  if (spillGuts) {
    tick(""String_Node_Str"" + diff + ""String_Node_Str""+ start+ ""String_Node_Str"");
  }
  int end=start + diff;
  final List<ParserConstraint> constraints=getConstraints();
  if (constraints != null) {
    for (    ParserConstraint c : constraints) {
      if ((start > c.start && start < c.end && end > c.end) || (end > c.start && end < c.end && start < c.start)) {
        return;
      }
    }
  }
  int[] narrowRExtent_start=narrowRExtent[start];
  int[] wideRExtent_start=wideRExtent[start];
  int[] narrowLExtent_end=narrowLExtent[end];
  int[] wideLExtent_end=wideLExtent[end];
  float[][] iScore_start=iScore[start];
  float[] iScore_start_end=iScore_start[end];
  for (int leftState=0; leftState < numStates; leftState++) {
    int narrowR=narrowRExtent_start[leftState];
    boolean iPossibleL=(narrowR < end);
    if (!iPossibleL) {
      continue;
    }
    BinaryRule[] leftRules=bg.splitRulesWithLC(leftState);
    for (    BinaryRule rule : leftRules) {
      int rightChild=rule.rightChild;
      int narrowL=narrowLExtent_end[rightChild];
      boolean iPossibleR=(narrowL >= narrowR);
      if (!iPossibleR) {
        continue;
      }
      int min2=wideLExtent_end[rightChild];
      int min=(narrowR > min2 ? narrowR : min2);
      int max1=wideRExtent_start[leftState];
      int max=(max1 < narrowL ? max1 : narrowL);
      if (min > max) {
        continue;
      }
      float pS=rule.score;
      int parentState=rule.parent;
      float oldIScore=iScore_start_end[parentState];
      float bestIScore=oldIScore;
      boolean foundBetter;
      if (!lengthNormalization) {
        for (int split=min; split <= max; split++) {
          if (constraints != null) {
            boolean skip=false;
            for (            ParserConstraint c : constraints) {
              if (((start < c.start && end >= c.end) || (start <= c.start && end > c.end)) && split > c.start && split < c.end) {
                skip=true;
                break;
              }
              if ((start == c.start && split == c.end)) {
                String tag=stateIndex.get(leftState);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
              if ((split == c.start && end == c.end)) {
                String tag=stateIndex.get(rightChild);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
            }
            if (skip) {
              continue;
            }
          }
          float lS=iScore_start[split][leftState];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightChild];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          if (spillGuts) {
            System.err.println(""String_Node_Str"" + rule + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ tot+ ""String_Node_Str""+ stateIndex.get(leftState)+ ""String_Node_Str""+ leftState+ ""String_Node_Str""+ lS+ ""String_Node_Str""+ stateIndex.get(rightChild)+ ""String_Node_Str""+ rightChild+ ""String_Node_Str""+ rS);
          }
          if (tot > bestIScore) {
            bestIScore=tot;
          }
        }
        foundBetter=bestIScore > oldIScore;
      }
 else {
        int bestWordsInSpan=wordsInSpan[start][end][parentState];
        float oldNormIScore=oldIScore / bestWordsInSpan;
        float bestNormIScore=oldNormIScore;
        for (int split=min; split <= max; split++) {
          float lS=iScore_start[split][leftState];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightChild];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS;
          int newWordsInSpan=wordsInSpan[start][split][leftState] + wordsInSpan[split][end][rightChild];
          float normTot=tot / newWordsInSpan;
          if (normTot > bestNormIScore) {
            bestIScore=tot;
            bestNormIScore=normTot;
            bestWordsInSpan=newWordsInSpan;
          }
        }
        foundBetter=bestNormIScore > oldNormIScore;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=bestWordsInSpan;
        }
      }
      if (foundBetter) {
        iScore_start_end[parentState]=bestIScore;
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ bestIScore);
        if (oldIScore == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
  for (int rightState=0; rightState < numStates; rightState++) {
    int narrowL=narrowLExtent_end[rightState];
    boolean iPossibleR=(narrowL > start);
    if (!iPossibleR) {
      continue;
    }
    BinaryRule[] rightRules=bg.splitRulesWithRC(rightState);
    for (    BinaryRule rule : rightRules) {
      int leftChild=rule.leftChild;
      int narrowR=narrowRExtent_start[leftChild];
      boolean iPossibleL=(narrowR <= narrowL);
      if (!iPossibleL) {
        continue;
      }
      int min2=wideLExtent_end[rightState];
      int min=(narrowR > min2 ? narrowR : min2);
      int max1=wideRExtent_start[leftChild];
      int max=(max1 < narrowL ? max1 : narrowL);
      if (min > max) {
        continue;
      }
      float pS=rule.score;
      int parentState=rule.parent;
      float oldIScore=iScore_start_end[parentState];
      float bestIScore=oldIScore;
      boolean foundBetter;
      if (!lengthNormalization) {
        for (int split=min; split <= max; split++) {
          if (constraints != null) {
            boolean skip=false;
            for (            ParserConstraint c : constraints) {
              if (((start < c.start && end >= c.end) || (start <= c.start && end > c.end)) && split > c.start && split < c.end) {
                skip=true;
                break;
              }
              if ((start == c.start && split == c.end)) {
                String tag=stateIndex.get(leftChild);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
              if ((split == c.start && end == c.end)) {
                String tag=stateIndex.get(rightState);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
            }
            if (skip) {
              continue;
            }
          }
          float lS=iScore_start[split][leftChild];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightState];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          if (tot > bestIScore) {
            bestIScore=tot;
          }
        }
        foundBetter=bestIScore > oldIScore;
      }
 else {
        int bestWordsInSpan=wordsInSpan[start][end][parentState];
        float oldNormIScore=oldIScore / bestWordsInSpan;
        float bestNormIScore=oldNormIScore;
        for (int split=min; split <= max; split++) {
          float lS=iScore_start[split][leftChild];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightState];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          int newWordsInSpan=wordsInSpan[start][split][leftChild] + wordsInSpan[split][end][rightState];
          float normTot=tot / newWordsInSpan;
          if (normTot > bestNormIScore) {
            bestIScore=tot;
            bestNormIScore=normTot;
            bestWordsInSpan=newWordsInSpan;
          }
        }
        foundBetter=bestNormIScore > oldNormIScore;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=bestWordsInSpan;
        }
      }
      if (foundBetter) {
        iScore_start_end[parentState]=bestIScore;
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ bestIScore);
        if (oldIScore == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
  if (spillGuts) {
    tick(""String_Node_Str"" + diff + ""String_Node_Str"");
  }
  for (int state=0; state < numStates; state++) {
    float iS=iScore_start_end[state];
    if (iS == Float.NEGATIVE_INFINITY) {
      continue;
    }
    UnaryRule[] unaries=ug.closedRulesByChild(state);
    for (    UnaryRule ur : unaries) {
      if (constraints != null) {
        boolean skip=false;
        for (        ParserConstraint c : constraints) {
          if ((start == c.start && end == c.end)) {
            String tag=stateIndex.get(ur.parent);
            Matcher m=c.state.matcher(tag);
            if (!m.matches()) {
              skip=true;
              break;
            }
          }
        }
        if (skip) {
          continue;
        }
      }
      int parentState=ur.parent;
      float pS=ur.score;
      float tot=iS + pS + lex.score(ur,start,end);
      float cur=iScore_start_end[parentState];
      boolean foundBetter;
      if (lengthNormalization) {
        int totWordsInSpan=wordsInSpan[start][end][state];
        float normTot=tot / totWordsInSpan;
        int curWordsInSpan=wordsInSpan[start][end][parentState];
        float normCur=cur / curWordsInSpan;
        foundBetter=normTot > normCur;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=wordsInSpan[start][end][state];
        }
      }
 else {
        foundBetter=(tot > cur);
      }
      if (foundBetter) {
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ tot);
        iScore_start_end[parentState]=tot;
        if (cur == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
}","private void doInsideChartCell(final int diff,final int start){
  final boolean lengthNormalization=op.testOptions.lengthNormalization;
  if (spillGuts) {
    tick(""String_Node_Str"" + diff + ""String_Node_Str""+ start+ ""String_Node_Str"");
  }
  int end=start + diff;
  final List<ParserConstraint> constraints=getConstraints();
  if (constraints != null) {
    for (    ParserConstraint c : constraints) {
      if ((start > c.start && start < c.end && end > c.end) || (end > c.start && end < c.end && start < c.start)) {
        return;
      }
    }
  }
  int[] narrowRExtent_start=narrowRExtent[start];
  int[] wideRExtent_start=wideRExtent[start];
  int[] narrowLExtent_end=narrowLExtent[end];
  int[] wideLExtent_end=wideLExtent[end];
  float[][] iScore_start=iScore[start];
  float[] iScore_start_end=iScore_start[end];
  for (int leftState=0; leftState < numStates; leftState++) {
    int narrowR=narrowRExtent_start[leftState];
    boolean iPossibleL=(narrowR < end);
    if (!iPossibleL) {
      continue;
    }
    BinaryRule[] leftRules=bg.splitRulesWithLC(leftState);
    for (    BinaryRule rule : leftRules) {
      int rightChild=rule.rightChild;
      int narrowL=narrowLExtent_end[rightChild];
      boolean iPossibleR=(narrowL >= narrowR);
      if (!iPossibleR) {
        continue;
      }
      int min2=wideLExtent_end[rightChild];
      int min=(narrowR > min2 ? narrowR : min2);
      int max1=wideRExtent_start[leftState];
      int max=(max1 < narrowL ? max1 : narrowL);
      if (min > max) {
        continue;
      }
      float pS=rule.score;
      int parentState=rule.parent;
      float oldIScore=iScore_start_end[parentState];
      float bestIScore=oldIScore;
      boolean foundBetter;
      if (!lengthNormalization) {
        for (int split=min; split <= max; split++) {
          if (constraints != null) {
            boolean skip=false;
            for (            ParserConstraint c : constraints) {
              if (((start < c.start && end >= c.end) || (start <= c.start && end > c.end)) && split > c.start && split < c.end) {
                skip=true;
                break;
              }
              if ((start == c.start && split == c.end)) {
                String tag=stateIndex.get(leftState);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
              if ((split == c.start && end == c.end)) {
                String tag=stateIndex.get(rightChild);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
            }
            if (skip) {
              continue;
            }
          }
          float lS=iScore_start[split][leftState];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightChild];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          if (spillGuts) {
            System.err.println(""String_Node_Str"" + rule + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ tot+ ""String_Node_Str""+ stateIndex.get(leftState)+ ""String_Node_Str""+ leftState+ ""String_Node_Str""+ lS+ ""String_Node_Str""+ stateIndex.get(rightChild)+ ""String_Node_Str""+ rightChild+ ""String_Node_Str""+ rS);
          }
          if (tot > bestIScore) {
            bestIScore=tot;
          }
        }
        foundBetter=bestIScore > oldIScore;
      }
 else {
        int bestWordsInSpan=wordsInSpan[start][end][parentState];
        float oldNormIScore=oldIScore / bestWordsInSpan;
        float bestNormIScore=oldNormIScore;
        for (int split=min; split <= max; split++) {
          float lS=iScore_start[split][leftState];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightChild];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          ;
          int newWordsInSpan=wordsInSpan[start][split][leftState] + wordsInSpan[split][end][rightChild];
          float normTot=tot / newWordsInSpan;
          if (normTot > bestNormIScore) {
            bestIScore=tot;
            bestNormIScore=normTot;
            bestWordsInSpan=newWordsInSpan;
          }
        }
        foundBetter=bestNormIScore > oldNormIScore;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=bestWordsInSpan;
        }
      }
      if (foundBetter) {
        iScore_start_end[parentState]=bestIScore;
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ bestIScore);
        if (oldIScore == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
  for (int rightState=0; rightState < numStates; rightState++) {
    int narrowL=narrowLExtent_end[rightState];
    boolean iPossibleR=(narrowL > start);
    if (!iPossibleR) {
      continue;
    }
    BinaryRule[] rightRules=bg.splitRulesWithRC(rightState);
    for (    BinaryRule rule : rightRules) {
      int leftChild=rule.leftChild;
      int narrowR=narrowRExtent_start[leftChild];
      boolean iPossibleL=(narrowR <= narrowL);
      if (!iPossibleL) {
        continue;
      }
      int min2=wideLExtent_end[rightState];
      int min=(narrowR > min2 ? narrowR : min2);
      int max1=wideRExtent_start[leftChild];
      int max=(max1 < narrowL ? max1 : narrowL);
      if (min > max) {
        continue;
      }
      float pS=rule.score;
      int parentState=rule.parent;
      float oldIScore=iScore_start_end[parentState];
      float bestIScore=oldIScore;
      boolean foundBetter;
      if (!lengthNormalization) {
        for (int split=min; split <= max; split++) {
          if (constraints != null) {
            boolean skip=false;
            for (            ParserConstraint c : constraints) {
              if (((start < c.start && end >= c.end) || (start <= c.start && end > c.end)) && split > c.start && split < c.end) {
                skip=true;
                break;
              }
              if ((start == c.start && split == c.end)) {
                String tag=stateIndex.get(leftChild);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
              if ((split == c.start && end == c.end)) {
                String tag=stateIndex.get(rightState);
                Matcher m=c.state.matcher(tag);
                if (!m.matches()) {
                  skip=true;
                  break;
                }
              }
            }
            if (skip) {
              continue;
            }
          }
          float lS=iScore_start[split][leftChild];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightState];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          if (tot > bestIScore) {
            bestIScore=tot;
          }
        }
        foundBetter=bestIScore > oldIScore;
      }
 else {
        int bestWordsInSpan=wordsInSpan[start][end][parentState];
        float oldNormIScore=oldIScore / bestWordsInSpan;
        float bestNormIScore=oldNormIScore;
        for (int split=min; split <= max; split++) {
          float lS=iScore_start[split][leftChild];
          if (lS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float rS=iScore[split][end][rightState];
          if (rS == Float.NEGATIVE_INFINITY) {
            continue;
          }
          float tot=pS + lS + rS+ lex.score(rule,start,end,split);
          int newWordsInSpan=wordsInSpan[start][split][leftChild] + wordsInSpan[split][end][rightState];
          float normTot=tot / newWordsInSpan;
          if (normTot > bestNormIScore) {
            bestIScore=tot;
            bestNormIScore=normTot;
            bestWordsInSpan=newWordsInSpan;
          }
        }
        foundBetter=bestNormIScore > oldNormIScore;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=bestWordsInSpan;
        }
      }
      if (foundBetter) {
        iScore_start_end[parentState]=bestIScore;
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ bestIScore);
        if (oldIScore == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
  if (spillGuts) {
    tick(""String_Node_Str"" + diff + ""String_Node_Str"");
  }
  for (int state=0; state < numStates; state++) {
    float iS=iScore_start_end[state];
    if (iS == Float.NEGATIVE_INFINITY) {
      continue;
    }
    UnaryRule[] unaries=ug.closedRulesByChild(state);
    for (    UnaryRule ur : unaries) {
      if (constraints != null) {
        boolean skip=false;
        for (        ParserConstraint c : constraints) {
          if ((start == c.start && end == c.end)) {
            String tag=stateIndex.get(ur.parent);
            Matcher m=c.state.matcher(tag);
            if (!m.matches()) {
              skip=true;
              break;
            }
          }
        }
        if (skip) {
          continue;
        }
      }
      int parentState=ur.parent;
      float pS=ur.score;
      float tot=iS + pS + lex.score(ur,start,end);
      float cur=iScore_start_end[parentState];
      boolean foundBetter;
      if (lengthNormalization) {
        int totWordsInSpan=wordsInSpan[start][end][state];
        float normTot=tot / totWordsInSpan;
        int curWordsInSpan=wordsInSpan[start][end][parentState];
        float normCur=cur / curWordsInSpan;
        foundBetter=normTot > normCur;
        if (foundBetter) {
          wordsInSpan[start][end][parentState]=wordsInSpan[start][end][state];
        }
      }
 else {
        foundBetter=(tot > cur);
      }
      if (foundBetter) {
        if (spillGuts)         System.err.println(""String_Node_Str"" + stateIndex.get(parentState) + ""String_Node_Str""+ start+ ""String_Node_Str""+ end+ ""String_Node_Str""+ tot);
        iScore_start_end[parentState]=tot;
        if (cur == Float.NEGATIVE_INFINITY) {
          if (start > narrowLExtent_end[parentState]) {
            narrowLExtent_end[parentState]=start;
            wideLExtent_end[parentState]=start;
          }
 else {
            if (start < wideLExtent_end[parentState]) {
              wideLExtent_end[parentState]=start;
            }
          }
          if (end < narrowRExtent_start[parentState]) {
            narrowRExtent_start[parentState]=end;
            wideRExtent_start[parentState]=end;
          }
 else {
            if (end > wideRExtent_start[parentState]) {
              wideRExtent_start[parentState]=end;
            }
          }
        }
      }
    }
  }
}",0.998181450798141
37836,"/** 
 * Get the exact k best parses for the sentence.
 * @param k The number of best parses to return
 * @return The exact k best parses for the sentence, witheach accompanied by its score (typically a negative log probability).
 */
public List<ScoredObject<Tree>> getKBestParses(int k){
  cand=new HashMap<Vertex,PriorityQueue<Derivation>>();
  dHat=new HashMap<Vertex,LinkedList<Derivation>>();
  int start=0;
  int end=length;
  int goal=stateIndex.indexOf(goalStr);
  Vertex v=new Vertex(goal,start,end);
  List<ScoredObject<Tree>> kBestTrees=new ArrayList<ScoredObject<Tree>>();
  for (int i=1; i <= k; i++) {
    Tree internalTree=getTree(v,i,k);
    if (internalTree == null) {
      break;
    }
    kBestTrees.add(new ScoredObject<Tree>(internalTree,dHat.get(v).get(i - 1).score));
  }
  return kBestTrees;
}","/** 
 * Get the exact k best parses for the sentence.
 * @param k The number of best parses to return
 * @return The exact k best parses for the sentence, witheach accompanied by its score (typically a negative log probability).
 */
public List<ScoredObject<Tree>> getKBestParses(int k){
  cand=new HashMap<Vertex,PriorityQueue<Derivation>>();
  dHat=new HashMap<Vertex,LinkedList<Derivation>>();
  int start=0;
  int end=length;
  int goal=stateIndex.indexOf(goalStr);
  Vertex v=new Vertex(goal,start,end);
  List<ScoredObject<Tree>> kBestTrees=new ArrayList<ScoredObject<Tree>>();
  for (int i=1; i <= k; i++) {
    Tree internalTree=getTree(v,i,k);
    if (internalTree == null) {
      break;
    }
    kBestTrees.add(new ScoredObject<Tree>(internalTree,dHat.get(v).get(i - 1).score));
    double score=scoreBinarizedTree(internalTree,0);
    assert(Math.abs(score - dHat.get(v).get(i - 1).score) < 1e-6);
  }
  return kBestTrees;
}",0.9315849486887116
37837,"private List<Arc> getBackwardsStar(Vertex v){
  List<Arc> bs=new ArrayList<Arc>();
  if (isTag[v.goal]) {
    List<Vertex> tails=new ArrayList<Vertex>();
    double score=iScore[v.start][v.end][v.goal];
    Arc arc=new Arc(tails,v,score);
    bs.add(arc);
  }
  for (int split=v.start + 1; split < v.end; split++) {
    for (    BinaryRule br : bg.ruleListByParent(v.goal)) {
      Vertex lChild=new Vertex(br.leftChild,v.start,split);
      Vertex rChild=new Vertex(br.rightChild,split,v.end);
      List<Vertex> tails=new ArrayList<Vertex>();
      tails.add(lChild);
      tails.add(rChild);
      Arc arc=new Arc(tails,v,br.score);
      bs.add(arc);
    }
  }
  for (  UnaryRule ur : ug.rulesByParent(v.goal)) {
    Vertex child=new Vertex(ur.child,v.start,v.end);
    List<Vertex> tails=new ArrayList<Vertex>();
    tails.add(child);
    Arc arc=new Arc(tails,v,ur.score);
    bs.add(arc);
  }
  return bs;
}","private List<Arc> getBackwardsStar(Vertex v){
  List<Arc> bs=new ArrayList<Arc>();
  if (isTag[v.goal] && v.start == v.end - 1) {
    List<Vertex> tails=new ArrayList<Vertex>();
    double score=iScore[v.start][v.end][v.goal];
    Arc arc=new Arc(tails,v,score);
    bs.add(arc);
  }
  for (int split=v.start + 1; split < v.end; split++) {
    for (    BinaryRule br : bg.ruleListByParent(v.goal)) {
      Vertex lChild=new Vertex(br.leftChild,v.start,split);
      Vertex rChild=new Vertex(br.rightChild,split,v.end);
      List<Vertex> tails=new ArrayList<Vertex>();
      tails.add(lChild);
      tails.add(rChild);
      Arc arc=new Arc(tails,v,br.score + lex.score(br,v.start,v.end,split));
      bs.add(arc);
    }
  }
  for (  UnaryRule ur : ug.rulesByParent(v.goal)) {
    Vertex child=new Vertex(ur.child,v.start,v.end);
    List<Vertex> tails=new ArrayList<Vertex>();
    tails.add(child);
    Arc arc=new Arc(tails,v,ur.score);
    bs.add(arc);
  }
  return bs;
}",0.9682203389830508
37838,"public List<? extends EntryWithScore<Unit>> parseHeader(String hdr,ParseState hdrMatches,ParseState context,int debugLvl,short[][] forcedTags,UnitSpan forcedUnit,int k,Vector<UnitFeatures> featureList){
  if (debugLvl > 0)   System.out.println(hdr);
  if (isURL(hdr))   return null;
  hdrMatches=getTokensWithSpan(hdr,forcedUnit,hdrMatches);
  if (hdrMatches.tokens.size() == 0)   return null;
  if (featureList != null)   featureList.clear();
  List<String> hdrToks=hdrMatches.tokens;
  List<? extends HasWord> sentence=tokenScorer.cacheScores(hdrMatches,forcedTags,debugLvl,featureList != null,forcedUnit,context);
  if (parser.parse(sentence)) {
    TObjectFloatHashMap<UnitFeatures> units=new TObjectFloatHashMap<UnitFeatures>();
    List<ScoredObject<Tree>> trees=parser.getBestParses();
    if (k > 1) {
      double bestScore=(trees.size() > 0 ? trees.get(0).score() : Double.POSITIVE_INFINITY) - Double.MIN_VALUE;
      List<ScoredObject<Tree>> treesK=parser.getKBestParses(k);
      for (int r=0; r < treesK.size(); r++) {
        if (treesK.get(r).score() < bestScore && trees.size() < k) {
          trees.add(treesK.get(r));
        }
      }
    }
    for (    ScoredObject<Tree> stree : trees) {
      Tree tree=stree.object();
      Vector<Tree> unitNodes=new Vector<Tree>();
      tree.setSpans();
      getTopUnitNodes(tree,unitNodes);
      float treeScore=(float)parser.scoreBinarizedTree(tree,0,debugLvl - 1);
      if (debugLvl > 0)       System.out.println(tree + ""String_Node_Str"" + tree.score()+ ""String_Node_Str""+ treeScore);
      FeatureVector treeFeatureVector=null;
      if (featureList != null) {
        treeFeatureVector=extractTreeFeatureVector(tree,0,tmpFVec.clear());
      }
      if (unitNodes.size() > 2)       throw new NotImplementedException();
      if (unitNodes.size() == 0)       continue;
      Tree unitTree=unitNodes.get(0);
      getUnit(unitTree,hdrToks,bestUnits,hdr);
      if (unitNodes.size() > 1)       getUnit(unitNodes.get(1),hdrToks,bestUnits2,hdr);
      int numUnits=unitNodes.size();
      if (bestUnits != null && bestUnits.size() > 0) {
        float baseScore=(float)bestUnits.get(0).getScore();
        for (int a=0; a < bestUnits.size(); a++) {
          Unit bestUnit=bestUnits.get(a).getKey();
          float val=(float)((float)bestUnits.get(a).getScore() + treeScore - baseScore);
          if (numUnits == 1 || bestUnits2.size() == 0) {
            units.adjustOrPutValue(bestUnits.get(a),val,val);
            if (treeFeatureVector != null)             addFeatureVector(featureList,bestUnits.get(a),null,treeFeatureVector,val,bestUnit);
          }
 else {
            float baseScore2=(float)bestUnits2.get(0).getScore();
            for (int a2=0; a2 < bestUnits2.size(); a2++) {
              Unit bestUnit2=bestUnits2.get(a2).getKey();
              float val2=(float)bestUnits2.get(a2).getScore() - baseScore2 + val;
              Unit newUnit=new UnitPair(bestUnit,bestUnit2,UnitPair.OpType.Alt,bestUnit.getParentQuantity());
              UnitFeatures newUnitF=addFeatureVector(featureList,bestUnits.get(a),bestUnits2.get(a2),treeFeatureVector,val2,newUnit);
              units.adjustOrPutValue(newUnitF,val2,val2);
            }
          }
        }
      }
    }
    if (units.size() > 0) {
      Vector<EntryWithScore<Unit>> possibleUnits=new Vector<EntryWithScore<Unit>>();
      double logNorm=0;
      for (TObjectFloatIterator<UnitFeatures> iter=units.iterator(); iter.hasNext(); ) {
        iter.advance();
        if (iter.value() > 0)         possibleUnits.add(new UnitSpan(iter.key().getKey(),iter.value(),iter.key().start(),iter.key().end()));
        logNorm=RobustMath.logSumExp(logNorm,iter.value());
      }
      Collections.sort(possibleUnits);
      if (possibleUnits.size() > k) {
        while (possibleUnits.size() > k) {
          possibleUnits.remove(possibleUnits.size() - 1);
        }
      }
      if (k > 1) {
      }
      if (featureList != null) {
        for (        UnitFeatures obj : featureList) {
          obj.checkCorrectness(params.weights);
        }
        Collections.sort(featureList);
        while (featureList.size() > k) {
          featureList.remove(featureList.size() - 1);
        }
        if (debugLvl > 0) {
          for (          UnitFeatures unitObj : featureList) {
            System.out.println(unitObj.getKey().getBaseName() + ""String_Node_Str"" + unitObj.getScore());
            unitObj.fvals.print(Params.FTypes.values());
          }
        }
      }
      return possibleUnits;
    }
  }
 else {
  }
  return null;
}","public List<? extends EntryWithScore<Unit>> parseHeader(String hdr,ParseState hdrMatches,ParseState context,int debugLvl,short[][] forcedTags,UnitSpan forcedUnit,int k,Vector<UnitFeatures> featureList){
  if (debugLvl > 0)   System.out.println(hdr);
  if (isURL(hdr))   return null;
  hdrMatches=getTokensWithSpan(hdr,forcedUnit,hdrMatches);
  if (hdrMatches.tokens.size() == 0)   return null;
  if (featureList != null)   featureList.clear();
  List<String> hdrToks=hdrMatches.tokens;
  List<? extends HasWord> sentence=tokenScorer.cacheScores(hdrMatches,forcedTags,debugLvl,featureList != null,forcedUnit,context);
  if (parser.parse(sentence)) {
    TObjectFloatHashMap<UnitFeatures> units=new TObjectFloatHashMap<UnitFeatures>();
    List<ScoredObject<Tree>> trees=parser.getBestParses();
    if (trees.size() < k) {
      double bestScore=(trees.size() > 0 ? trees.get(0).score() : Double.POSITIVE_INFINITY) - Double.MIN_VALUE;
      List<ScoredObject<Tree>> treesK=parser.getKBestParses(k);
      for (int r=0; r < treesK.size(); r++) {
        if (treesK.get(r).score() < bestScore && trees.size() < k) {
          trees.add(treesK.get(r));
        }
      }
    }
    for (    ScoredObject<Tree> stree : trees) {
      Tree tree=stree.object();
      Vector<Tree> unitNodes=new Vector<Tree>();
      tree.setSpans();
      getTopUnitNodes(tree,unitNodes);
      float treeScore=(float)parser.scoreBinarizedTree(tree,0,debugLvl - 1);
      if (debugLvl > 0)       System.out.println(tree + ""String_Node_Str"" + tree.score()+ ""String_Node_Str""+ treeScore);
      FeatureVector treeFeatureVector=null;
      if (featureList != null) {
        treeFeatureVector=extractTreeFeatureVector(tree,0,tmpFVec.clear());
      }
      if (unitNodes.size() > 2)       throw new NotImplementedException();
      if (unitNodes.size() == 0)       continue;
      Tree unitTree=unitNodes.get(0);
      getUnit(unitTree,hdrToks,bestUnits,hdr);
      if (unitNodes.size() > 1)       getUnit(unitNodes.get(1),hdrToks,bestUnits2,hdr);
      int numUnits=unitNodes.size();
      if (bestUnits != null && bestUnits.size() > 0) {
        float baseScore=(float)bestUnits.get(0).getScore();
        for (int a=0; a < bestUnits.size(); a++) {
          Unit bestUnit=bestUnits.get(a).getKey();
          float val=(float)((float)bestUnits.get(a).getScore() + treeScore - baseScore);
          if (numUnits == 1 || bestUnits2.size() == 0) {
            units.adjustOrPutValue(bestUnits.get(a),val,val);
            if (treeFeatureVector != null)             addFeatureVector(featureList,bestUnits.get(a),null,treeFeatureVector,val,bestUnit);
          }
 else {
            float baseScore2=(float)bestUnits2.get(0).getScore();
            for (int a2=0; a2 < bestUnits2.size(); a2++) {
              Unit bestUnit2=bestUnits2.get(a2).getKey();
              float val2=(float)bestUnits2.get(a2).getScore() - baseScore2 + val;
              Unit newUnit=new UnitPair(bestUnit,bestUnit2,UnitPair.OpType.Alt,bestUnit.getParentQuantity());
              UnitFeatures newUnitF=addFeatureVector(featureList,bestUnits.get(a),bestUnits2.get(a2),treeFeatureVector,val2,newUnit);
              units.adjustOrPutValue(newUnitF,val2,val2);
            }
          }
        }
      }
    }
    if (units.size() > 0) {
      Vector<EntryWithScore<Unit>> possibleUnits=new Vector<EntryWithScore<Unit>>();
      double logNorm=0;
      for (TObjectFloatIterator<UnitFeatures> iter=units.iterator(); iter.hasNext(); ) {
        iter.advance();
        if (iter.value() > 0)         possibleUnits.add(new UnitSpan(iter.key().getKey(),iter.value(),iter.key().start(),iter.key().end()));
        logNorm=RobustMath.logSumExp(logNorm,iter.value());
      }
      Collections.sort(possibleUnits);
      if (possibleUnits.size() > k) {
        while (possibleUnits.size() > k) {
          possibleUnits.remove(possibleUnits.size() - 1);
        }
      }
      if (k > 1) {
      }
      if (featureList != null) {
        for (        UnitFeatures obj : featureList) {
          obj.checkCorrectness(params.weights);
        }
        Collections.sort(featureList);
        while (featureList.size() > k) {
          featureList.remove(featureList.size() - 1);
        }
        if (debugLvl > 0) {
          for (          UnitFeatures unitObj : featureList) {
            System.out.println(unitObj.getKey().getBaseName() + ""String_Node_Str"" + unitObj.getScore());
            unitObj.fvals.print(Params.FTypes.values(),params.weights);
          }
        }
      }
      return possibleUnits;
    }
  }
 else {
  }
  return null;
}",0.9962890198646585
37839,"public void print(FTypes[] values){
  for (int i=0; i < fvals.length; i++) {
    if (fvals[i] > Float.MIN_VALUE) {
      System.out.println(values[i].name() + ""String_Node_Str"" + fvals[i]);
    }
  }
  return;
}","public void print(FTypes[] values,double[] weights){
  for (int i=0; i < fvals.length; i++) {
    if (fvals[i] > Float.MIN_VALUE) {
      System.out.println(values[i].name() + ""String_Node_Str"" + fvals[i]+ ""String_Node_Str""+ (weights[i] * fvals[i]));
    }
  }
  return;
}",0.8737060041407867
37840,"public public void onServiceStateChanged(ServiceState serviceState){
  if (serviceState.getState() == ServiceState.STATE_OUT_OF_SERVICE) {
    intent=new Intent(context,DarkService.class);
    intent.setAction(DarkService.ACTION_RADIO_LOST);
    context.startService(intent);
  }
}","public void onServiceStateChanged(ServiceState serviceState){
  if (serviceState.getState() == ServiceState.STATE_OUT_OF_SERVICE) {
    Intent intent=new Intent(RadioMonitor.this,DarkService.class);
    intent.setAction(DarkService.ACTION_RADIO_LOST);
    startService(intent);
  }
}",0.9184397163120568
37841,"public void init(){
  TelephonyManager telephony=Context.getSystemService(Context.TELEPHONY_SERVICE);
  telephony.listen(new PhoneListener(),PhoneStateListener.LISTEN_SERVICE_STATE);
}","public void init(){
  TelephonyManager telephony=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephony.listen(new PhoneListener(),PhoneStateListener.LISTEN_SERVICE_STATE);
}",0.9243243243243244
37842,"private void create(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_CREATE);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_SIZE,42);
  intent.putExtra(DarkService.EXTRA_PASS_1,""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_PASS_2,""String_Node_Str"");
  startService(intent);
}","private void create(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_CREATE);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,getFilesDir() + ""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_SIZE1,2048);
  intent.putExtra(DarkService.EXTRA_SIZE2,1024);
  intent.putExtra(DarkService.EXTRA_PASS_1,""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_PASS_2,""String_Node_Str"");
  startService(intent);
}",0.9168646080760094
37843,"private void close(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_CLOSE);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,""String_Node_Str"");
  startService(intent);
}","private void close(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_CLOSE);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,getFilesDir() + ""String_Node_Str"");
  startService(intent);
}",0.9638009049773756
37844,"private void delete(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_DELETE);
  intent.putExtra(DarkService.EXTRA_MOUNT_PATH,""String_Node_Str"");
  startService(intent);
}","private void delete(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_DELETE);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,getFilesDir() + ""String_Node_Str"");
  startService(intent);
}",0.9438202247191012
37845,"private void open(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_OPEN);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,""String_Node_Str"");
  startService(intent);
}","private void open(){
  Intent intent=new Intent(this,DarkService.class);
  intent.setAction(DarkService.ACTION_OPEN);
  intent.putExtra(DarkService.EXTRA_VOLUME_PATH,getFilesDir() + ""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_MOUNT_PATH,""String_Node_Str"");
  intent.putExtra(DarkService.EXTRA_PASS,""String_Node_Str"");
  startService(intent);
}",0.7243816254416962
37846,"@Override protected void onHandleIntent(Intent intent){
  String action=intent.getAction();
  Bundle extras=intent.getExtras();
  if (ACTION_CREATE.equals(action)) {
    startForeground();
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    int size=extras.getInt(EXTRA_SIZE);
    String pass1=extras.getString(EXTRA_PASS_1);
    String pass2=extras.getString(EXTRA_PASS_2);
    mStorage.create(volumePath,size,pass1,pass2);
  }
 else   if (ACTION_OPEN.equals(action)) {
    startForeground();
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    String mountPath=extras.getString(EXTRA_MOUNT_PATH);
    String passwd=extras.getString(EXTRA_PASS_1);
    mStorage.open(volumePath,mountPath,passwd);
    restartTimeout();
  }
 else   if (ACTION_CLOSE.equals(action)) {
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    mStorage.close(volumePath);
  }
 else   if (ACTION_DELETE.equals(action)) {
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    mStorage.delete(volumePath);
  }
 else   if (ACTION_REBOOTED.equals(action)) {
    mRatchet.increase();
  }
 else   if (ACTION_TIMEOUT.equals(action)) {
    mRatchet.increase();
  }
 else   if (ACTION_PASSWORD_FAIL.equals(action)) {
    mRatchet.increase();
    clearTimeout();
  }
 else   if (ACTION_PASSWORD_SUCCESS.equals(action)) {
    mRatchet.reset();
    restartTimeout();
  }
}","@Override protected void onHandleIntent(Intent intent){
  String action=intent.getAction();
  Bundle extras=intent.getExtras();
  if (ACTION_CREATE.equals(action)) {
    startForeground();
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    int size1=extras.getInt(EXTRA_SIZE1);
    int size2=extras.getInt(EXTRA_SIZE2);
    String pass1=extras.getString(EXTRA_PASS_1);
    String pass2=extras.getString(EXTRA_PASS_2);
    mStorage.create(this,volumePath,size1,size2,pass1,pass2);
  }
 else   if (ACTION_OPEN.equals(action)) {
    startForeground();
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    String mountPath=extras.getString(EXTRA_MOUNT_PATH);
    String passwd=extras.getString(EXTRA_PASS);
    mStorage.open(this,volumePath,mountPath,passwd);
    restartTimeout();
  }
 else   if (ACTION_CLOSE.equals(action)) {
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    mStorage.close(volumePath);
  }
 else   if (ACTION_DELETE.equals(action)) {
    String volumePath=extras.getString(EXTRA_VOLUME_PATH);
    mStorage.delete(this,volumePath);
  }
 else   if (ACTION_REBOOTED.equals(action)) {
    mRatchet.increase();
  }
 else   if (ACTION_TIMEOUT.equals(action)) {
    mRatchet.increase();
  }
 else   if (ACTION_PASSWORD_FAIL.equals(action)) {
    mRatchet.increase();
    clearTimeout();
  }
 else   if (ACTION_PASSWORD_SUCCESS.equals(action)) {
    mRatchet.reset();
    restartTimeout();
  }
}",0.9104477611940298
37847,"public void create(String volumePath,int size,String pass1,String pass2){
  proc=runProcess(""String_Node_Str"",volumePath,mountPath);
  proc.write(""String_Node_Str"",pass1);
  proc.write(""String_Node_Str"",pass2);
  if (proc.exit_value() != 0) {
    alert_user(""String_Node_Str"",volumePath);
  }
  SystemClock.sleep(5000);
  List<String> result=Shell.SH.run(""String_Node_Str"");
  result=Shell.SU.run(""String_Node_Str"");
}","/** 
 * @param context
 * @param volumePath full path from root
 * @param mountPath
 * @param size in megabytes
 * @param pass1
 * @param pass2
 */
public void create(Context context,String volumePath,int size1,int size2,String pass1,String pass2){
  List<String> result=suRun(""String_Node_Str"",volumePath,size1,size2,pass1,pass2);
  SystemClock.sleep(2000);
  if (result == null) {
    Application.toast(context,String.format(""String_Node_Str"",volumePath));
  }
}",0.3424036281179138
37848,"public void close(String volumePath){
  Shell.SH.run(""String_Node_Str"",volumePath);
}","public void close(String volumePath){
  List<String> result=suRun(""String_Node_Str"",volumePath);
}",0.8524590163934426
37849,"public void delete(String volumePath){
  Shell.SH.run(""String_Node_Str"",volumePath);
}","public void delete(Context context,String volumePath){
  List<String> result=suRun(""String_Node_Str"",volumePath);
  if (result == null) {
    Application.toast(context,String.format(""String_Node_Str"",volumePath));
  }
}",0.5049180327868853
37850,"public void open(String volumePath,String mountPath,string passwd){
  proc=runProcess(""String_Node_Str"",volumePath,mountPath);
  proc.write(""String_Node_Str"",string);
  if (proc.exit_value() != 0) {
    alert_user(""String_Node_Str"",volumePath);
  }
  SystemClock.sleep(5000);
}","public void open(Context context,String volumePath,String mountPath,String passwd){
  List<String> result=suRun(""String_Node_Str"",volumePath,mountPath,passwd);
  SystemClock.sleep(2000);
  if (result == null) {
    Application.toast(context,String.format(""String_Node_Str"",volumePath));
  }
}",0.3655536028119508
37851,"@Cacheable @CacheInvalidate({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @SQLSetter(table=Cluster.class,name=""String_Node_Str"",since=@SQLVersion({1,0,0})) public abstract void setCluster(Cluster cluster);","@Cacheable @CacheInvalidate({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @SQLSetter(table=Cluster.class,name=""String_Node_Str"",since=@SQLVersion({1,0,0})) public abstract void setCluster(Cluster cluster);",0.96
37852,"@Title(""String_Node_Str"") @Desc({""String_Node_Str""}) @Any(""String_Node_Str"") @JSON(notFoundIfNull=true) @WithDataAdapter(BergamotDB.class) public AlertMO falsePositiveAlert(BergamotDB db,@IsaObjectId() UUID id,@Param(""String_Node_Str"") @CheckStringLength(min=1,max=80,mandatory=true) String summary,@Param(""String_Node_Str"") @CheckStringLength(min=0,max=4096,mandatory=false) String comment){
  Alert alert=notNull(db.getAlert(id));
  require(permission(""String_Node_Str"",alert.getCheckId()));
  if ((!alert.isFalsePositive()) && alert.isAcknowledged()) {
    Contact contact=currentPrincipal();
    Comment ackCom=new Comment().author(contact).falsePositive(alert).summary(summary).message(comment);
    db.execute(() -> {
      db.setComment(ackCom);
      alert.setFalsePositive(true);
      alert.setFalsePositiveAt(new Timestamp(System.currentTimeMillis()));
      alert.setFalsePositiveById(contact.getId());
      alert.setFalsePositiveReasonId(ackCom.getId());
      db.setAlert(alert);
    }
);
    this.updateProducer.publish(new UpdateKey(UpdateType.ALERT,alert.getSiteId(),alert.getId()),new AlertUpdate(alert.toMO(currentPrincipal())));
  }
  return alert.toMO(currentPrincipal());
}","@Title(""String_Node_Str"") @Desc({""String_Node_Str""}) @Any(""String_Node_Str"") @JSON(notFoundIfNull=true) @WithDataAdapter(BergamotDB.class) public AlertMO falsePositiveAlert(BergamotDB db,@IsaObjectId() UUID id,@Param(""String_Node_Str"") @CheckStringLength(min=1,max=80,mandatory=true) String summary,@Param(""String_Node_Str"") @CheckStringLength(min=0,max=4096,mandatory=false) String comment){
  Alert alert=notNull(db.getAlert(id));
  require(permission(""String_Node_Str"",alert.getCheckId()));
  if ((!alert.isFalsePositive()) && (alert.isAcknowledged() || alert.isRecovered())) {
    Contact contact=currentPrincipal();
    Comment ackCom=new Comment().author(contact).falsePositive(alert).summary(summary).message(comment);
    db.execute(() -> {
      db.setComment(ackCom);
      alert.setFalsePositive(true);
      alert.setFalsePositiveAt(new Timestamp(System.currentTimeMillis()));
      alert.setFalsePositiveById(contact.getId());
      alert.setFalsePositiveReasonId(ackCom.getId());
      db.setAlert(alert);
    }
);
    this.updateProducer.publish(new UpdateKey(UpdateType.ALERT,alert.getSiteId(),alert.getId()),new AlertUpdate(alert.toMO(currentPrincipal())));
  }
  return alert.toMO(currentPrincipal());
}",0.9896565990897808
37853,"/** 
 * Construct a generic notification based of this alert. TODO: rebase the notification messages on this alert object
 * @param now when the alert is raise (ie: now)
 * @param type the notification type: alert, recovery, acknowledge
 * @param ctor the constructor for the notification type
 * @return the notification
 */
public <T extends CheckNotification>T createNotification(Calendar now,NotificationType type,Supplier<T> ctor,List<ContactMO> to){
  Check<?,?> check=this.getCheck();
  CheckState state=check.getState();
  if (!check.getNotifications().isEnabledAt(type,state.getStatus(),now))   return null;
  T notification=ctor.get();
  notification.setSite(check.getSite().toMOUnsafe());
  notification.setRaised(now.getTimeInMillis());
  notification.setAlertId(this.getId());
  notification.setCheck(check.toMOUnsafe());
  notification.setTo(to);
  return notification;
}","/** 
 * Construct a generic notification based of this alert. TODO: rebase the notification messages on this alert object
 * @param now when the alert is raise (ie: now)
 * @param type the notification type: alert, recovery, acknowledge
 * @param ctor the constructor for the notification type
 * @return the notification
 */
public <T extends AlertNotification>T createNotification(Calendar now,NotificationType type,Supplier<T> ctor,List<ContactMO> to){
  Check<?,?> check=this.getCheck();
  CheckState state=check.getState();
  if (!check.getNotifications().isEnabledAt(type,state.getStatus(),now))   return null;
  T notification=ctor.get();
  notification.setSite(check.getSite().toMOUnsafe());
  notification.setRaised(now.getTimeInMillis());
  notification.setAlertId(this.getId());
  notification.setCheck(check.toMOUnsafe());
  notification.setTo(to);
  return notification;
}",0.9943502824858758
37854,"protected Message buildCheckMessage(CheckNotification notification) throws Exception {
  Message message=new MimeMessage(this.session){
    @Override protected void updateMessageID() throws MessagingException {
    }
  }
;
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  message.setHeader(""String_Node_Str"",notification.getAlertId().toString());
  message.setHeader(""String_Node_Str"",this.checkMessageId(notification));
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getType());
  message.setHeader(""String_Node_Str"",notification.getCheck().getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getState().getStatus().toString());
  if (notification instanceof SendRecovery) {
    message.setHeader(""String_Node_Str"",this.checkMessageId(notification));
    message.setHeader(""String_Node_Str"",this.checkMessageId(notification));
  }
  message.setSentDate(new Date(notification.getRaised()));
  this.buildCheckMessageContent(message,notification);
  return message;
}","protected Message buildCheckMessage(CheckNotification notification) throws Exception {
  Message message=new MimeMessage(this.session){
    @Override protected void updateMessageID() throws MessagingException {
    }
  }
;
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  if (notification instanceof SendAlert) {
    UUID alertId=((SendAlert)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
  }
 else   if (notification instanceof SendRecovery) {
    UUID alertId=((SendAlert)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
    String alertMessageId=this.messageId(alertId,""String_Node_Str"");
    message.setHeader(""String_Node_Str"",alertMessageId);
    message.setHeader(""String_Node_Str"",alertMessageId);
  }
 else {
    message.setHeader(""String_Node_Str"",this.messageId(notification.getId(),notification.getNotificationType()));
  }
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getType());
  message.setHeader(""String_Node_Str"",notification.getCheck().getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getState().getStatus().toString());
  message.setSentDate(new Date(notification.getRaised()));
  this.buildCheckMessageContent(message,notification);
  return message;
}",0.5588885380486265
37855,"protected Message buildGenericMessage(GenericNotification notification) throws Exception {
  Message message=new MimeMessage(this.session);
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setSentDate(new Date(notification.getRaised()));
  this.buildGenericMessageContent(message,notification);
  return message;
}","protected Message buildGenericMessage(GenericNotification notification) throws Exception {
  Message message=new MimeMessage(this.session);
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  message.setHeader(""String_Node_Str"",this.messageId(notification.getId(),notification.getNotificationType()));
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setSentDate(new Date(notification.getRaised()));
  this.buildGenericMessageContent(message,notification);
  return message;
}",0.9193083573487032
37856,"protected Message buildCheckMessage(CheckNotification notification) throws Exception {
  Message message=new MimeMessage(this.session){
    @Override protected void updateMessageID() throws MessagingException {
    }
  }
;
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  if (notification instanceof SendAlert) {
    UUID alertId=((SendAlert)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
  }
 else   if (notification instanceof SendRecovery) {
    UUID alertId=((SendAlert)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
    String alertMessageId=this.messageId(alertId,""String_Node_Str"");
    message.setHeader(""String_Node_Str"",alertMessageId);
    message.setHeader(""String_Node_Str"",alertMessageId);
  }
 else {
    message.setHeader(""String_Node_Str"",this.messageId(notification.getId(),notification.getNotificationType()));
  }
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getType());
  message.setHeader(""String_Node_Str"",notification.getCheck().getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getState().getStatus().toString());
  message.setSentDate(new Date(notification.getRaised()));
  this.buildCheckMessageContent(message,notification);
  return message;
}","protected Message buildCheckMessage(CheckNotification notification) throws Exception {
  Message message=new MimeMessage(this.session){
    @Override protected void updateMessageID() throws MessagingException {
    }
  }
;
  message.setFrom(new InternetAddress(this.fromAddress));
  for (  ContactMO contact : notification.getTo()) {
    if ((!Util.isEmpty(contact.getEmail())) && contact.hasEngine(this.getName())) {
      message.addRecipient(RecipientType.TO,new InternetAddress(contact.getEmail()));
    }
  }
  if (notification instanceof SendAlert) {
    UUID alertId=((SendAlert)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
  }
 else   if (notification instanceof SendRecovery) {
    UUID alertId=((SendRecovery)notification).getAlertId();
    if (alertId != null)     message.setHeader(""String_Node_Str"",alertId.toString());
    message.setHeader(""String_Node_Str"",this.messageId(alertId,""String_Node_Str""));
    String alertMessageId=this.messageId(alertId,""String_Node_Str"");
    message.setHeader(""String_Node_Str"",alertMessageId);
    message.setHeader(""String_Node_Str"",alertMessageId);
  }
 else {
    message.setHeader(""String_Node_Str"",this.messageId(notification.getId(),notification.getNotificationType()));
  }
  message.setHeader(""String_Node_Str"",notification.getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getType());
  message.setHeader(""String_Node_Str"",notification.getCheck().getId().toString());
  message.setHeader(""String_Node_Str"",notification.getCheck().getState().getStatus().toString());
  message.setSentDate(new Date(notification.getRaised()));
  this.buildCheckMessageContent(message,notification);
  return message;
}",0.9964702688026066
37857,"public void run(){
  try {
    AgentMessage response=processAgentMessage(ctx,request);
    if (response != null) {
      ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(response)));
    }
  }
 catch (  Exception e) {
    ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(new GeneralError(""String_Node_Str""))));
  }
}","public void run(){
  try {
    AgentMessage response=processAgentMessage(ctx,request);
    if (response != null) {
      ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(response)));
    }
  }
 catch (  Exception e) {
    ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(new GeneralError(""String_Node_Str"" + e.getMessage()))));
  }
}",0.9776609724047306
37858,"@Override public void channelRead0(final ChannelHandlerContext ctx,Object msg){
  if (msg instanceof FullHttpResponse) {
    FullHttpResponse http=(FullHttpResponse)msg;
    if (!handshaker.isHandshakeComplete()) {
      handshaker.finishHandshake(ctx.channel(),http);
      this.channelHandshaked(ctx);
      return;
    }
  }
 else   if (msg instanceof WebSocketFrame) {
    WebSocketFrame frame=(WebSocketFrame)msg;
    if (frame instanceof TextWebSocketFrame) {
      String message=((TextWebSocketFrame)frame).text();
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + message);
      try {
        final AgentMessage request=this.transcoder.decodeFromString(message,AgentMessage.class);
        if (request instanceof AgentMessage) {
          ctx.executor().execute(new Runnable(){
            public void run(){
              try {
                AgentMessage response=processAgentMessage(ctx,request);
                if (response != null) {
                  ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(response)));
                }
              }
 catch (              Exception e) {
                ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(new GeneralError(""String_Node_Str""))));
              }
            }
          }
);
        }
 else {
          ctx.channel().writeAndFlush(new TextWebSocketFrame(this.transcoder.encodeAsString(new GeneralError(request,""String_Node_Str""))));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ctx.channel().writeAndFlush(new TextWebSocketFrame(this.transcoder.encodeAsString(new GeneralError(""String_Node_Str""))));
      }
    }
 else     if (frame instanceof PongWebSocketFrame) {
      logger.trace(""String_Node_Str"");
    }
 else     if (frame instanceof CloseWebSocketFrame) {
      logger.trace(""String_Node_Str"");
      ctx.close();
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + msg);
  }
}","@Override public void channelRead0(final ChannelHandlerContext ctx,Object msg){
  if (msg instanceof FullHttpResponse) {
    FullHttpResponse http=(FullHttpResponse)msg;
    if (!handshaker.isHandshakeComplete()) {
      handshaker.finishHandshake(ctx.channel(),http);
      this.channelHandshaked(ctx);
      return;
    }
  }
 else   if (msg instanceof WebSocketFrame) {
    WebSocketFrame frame=(WebSocketFrame)msg;
    if (frame instanceof TextWebSocketFrame) {
      String message=((TextWebSocketFrame)frame).text();
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + message);
      try {
        final AgentMessage request=this.transcoder.decodeFromString(message,AgentMessage.class);
        if (request instanceof AgentMessage) {
          ctx.executor().execute(new Runnable(){
            public void run(){
              try {
                AgentMessage response=processAgentMessage(ctx,request);
                if (response != null) {
                  ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(response)));
                }
              }
 catch (              Exception e) {
                ctx.channel().writeAndFlush(new TextWebSocketFrame(transcoder.encodeAsString(new GeneralError(""String_Node_Str"" + e.getMessage()))));
              }
            }
          }
);
        }
 else {
          ctx.channel().writeAndFlush(new TextWebSocketFrame(this.transcoder.encodeAsString(new GeneralError(request,""String_Node_Str""))));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ctx.channel().writeAndFlush(new TextWebSocketFrame(this.transcoder.encodeAsString(new GeneralError(""String_Node_Str""))));
      }
    }
 else     if (frame instanceof PongWebSocketFrame) {
      logger.trace(""String_Node_Str"");
    }
 else     if (frame instanceof CloseWebSocketFrame) {
      logger.trace(""String_Node_Str"");
      ctx.close();
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + msg);
  }
}",0.9958076448828608
37859,"@Override public AgentMessage handle(AgentMessage request){
  CheckMetrics metrics=(CheckMetrics)request;
  MetricsStat stat=new MetricsStat(request);
  Parcel readings=new Parcel();
  StatsDProcessor processor=this.getAgent().getStatsDProcessor();
  if (processor != null) {
    Pattern filter=Pattern.compile(metrics.getMetricsNameFilter().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str""));
    for (    Entry<String,Metric> metric : processor.getMetrics().getMetrics().entrySet()) {
      String key=metric.getKey();
      key=metrics.isStripSourceFromMetricName() ? key.substring(key.indexOf(""String_Node_Str"") + 1) : key;
      if (filter.matcher(key).matches()) {
        readings.addMetric(key,metric.getValue());
      }
    }
  }
  stat.setReadings(readings.getReadings());
  return stat;
}","@Override public AgentMessage handle(AgentMessage request){
  CheckMetrics metrics=(CheckMetrics)request;
  MetricsStat stat=new MetricsStat(request);
  Parcel readings=new Parcel();
  StatsDProcessor processor=this.getAgent().getStatsDProcessor();
  if (processor != null) {
    Pattern filter=Pattern.compile(metrics.getMetricsNameFilter());
    for (    Entry<String,Metric> metric : processor.getMetrics().getMetrics().entrySet()) {
      String key=metric.getKey();
      key=metrics.isStripSourceFromMetricName() ? key.substring(key.indexOf(""String_Node_Str"") + 1) : key;
      if (filter.matcher(key).matches()) {
        readings.addMetric(key,metric.getValue());
      }
    }
  }
  stat.setReadings(readings.getReadings());
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + stat.getReadings().size() + ""String_Node_Str"");
  return stat;
}",0.8771929824561403
37860,"/** 
 * Decode a StatsD message pull out all the metrics
 */
protected void decodeMetrics(SocketAddress from,ByteBuffer buffer){
  try {
    byte[] array=buffer.array();
    int startOfLine=buffer.arrayOffset();
    int endOfMetricName=0;
    int endOfValue=0;
    int startOfSample=0;
    int limit=startOfLine + buffer.limit();
    for (int i=startOfLine; i < limit; i++) {
switch (array[i]) {
case 0x3A:
        endOfMetricName=i;
      break;
case 0x7C:
    if (endOfValue == 0)     endOfValue=i;
  break;
case 0x40:
startOfSample=i;
break;
case 0xD:
break;
case 0xA:
this.parseMetric(from,array,startOfLine,endOfMetricName,endOfValue,startOfSample,i);
startOfLine=i + 1;
endOfMetricName=0;
endOfValue=0;
startOfSample=0;
}
}
if (startOfLine < limit) this.parseMetric(from,array,startOfLine,endOfMetricName,endOfValue,startOfSample,limit);
}
 catch (Exception e) {
logger.warn(""String_Node_Str"",e);
}
}","/** 
 * Decode a StatsD message pull out all the metrics
 */
protected void decodeMetrics(SocketAddress from,ByteBuffer buffer){
  if (logger.isTraceEnabled())   logger.trace(new String(buffer.array(),buffer.arrayOffset(),buffer.remaining()));
  try {
    byte[] array=buffer.array();
    int startOfLine=buffer.arrayOffset();
    int endOfMetricName=0;
    int endOfValue=0;
    int startOfSample=0;
    int limit=startOfLine + buffer.limit();
    for (int i=startOfLine; i < limit; i++) {
switch (array[i]) {
case 0x3A:
        endOfMetricName=i;
      break;
case 0x7C:
    if (endOfValue == 0)     endOfValue=i;
  break;
case 0x40:
startOfSample=i;
break;
case 0xD:
break;
case 0xA:
this.parseMetric(from,array,startOfLine,endOfMetricName,endOfValue,startOfSample,i);
startOfLine=i + 1;
endOfMetricName=0;
endOfValue=0;
startOfSample=0;
}
}
if (startOfLine < limit) this.parseMetric(from,array,startOfLine,endOfMetricName,endOfValue,startOfSample,limit);
}
 catch (Exception e) {
logger.warn(""String_Node_Str"",e);
}
}",0.9403217436429684
37861,"public void run(){
  try {
    this.channel.socket().bind(new InetSocketAddress(this.port));
    logger.info(""String_Node_Str"" + this.port);
    ByteBuffer buffer=ByteBuffer.allocate(8192);
    while (this.run) {
      try {
        buffer.rewind();
        SocketAddress from=this.channel.receive(buffer);
        buffer.flip();
        this.decodeMetrics(from,buffer);
      }
 catch (      Exception e) {
        if (this.run)         logger.warn(""String_Node_Str"",e);
      }
    }
    this.channel.close();
  }
 catch (  Exception e) {
    if (this.run)     logger.error(""String_Node_Str"",e);
  }
}","public void run(){
  try {
    this.channel.socket().bind(new InetSocketAddress(this.port));
    logger.info(""String_Node_Str"" + this.port);
    ByteBuffer buffer=ByteBuffer.allocate(8192);
    while (this.run) {
      try {
        buffer.clear();
        SocketAddress from=this.channel.receive(buffer);
        buffer.flip();
        this.decodeMetrics(from,buffer);
      }
 catch (      Exception e) {
        if (this.run)         logger.warn(""String_Node_Str"",e);
      }
    }
    this.channel.close();
  }
 catch (  Exception e) {
    if (this.run)     logger.error(""String_Node_Str"",e);
  }
}",0.9908713692946058
37862,"/** 
 * Find the resolved value of a check parameter
 * @return the check parameter
 */
public String resolveCheckParameter(String name){
  String value=this.getParameter(name);
  if (value == null) {
    Command command=this.getCommand();
    if (command != null) {
      value=command.getParameter(name);
    }
  }
  return value;
}","public String resolveCheckParameter(Command command,String name){
  String value=this.getParameter(name);
  if (value == null) {
    if (command != null) {
      value=command.getParameter(name);
    }
  }
  return value;
}",0.4703770197486535
37863,"/** 
 * Resolve the parameters between the command and this check definition
 * @return the check parameters
 */
public LinkedHashMap<String,Parameter> resolveCheckParameters(){
  LinkedHashMap<String,Parameter> r=new LinkedHashMap<String,Parameter>();
  Command command=this.getCommand();
  if (this.getParameters() != null) {
    r.putAll(this.getParameters());
  }
  if (command != null && command.getParameters() != null) {
    r.putAll(this.getParameters());
  }
  return r;
}","public LinkedHashMap<String,Parameter> resolveCheckParameters(Command command){
  LinkedHashMap<String,Parameter> r=new LinkedHashMap<String,Parameter>();
  if (command != null && command.getParameters() != null) {
    r.putAll(command.getParameters());
  }
  if (this.getParameters() != null) {
    r.putAll(this.getParameters());
  }
  return r;
}",0.5855421686746988
37864,"public <T extends TemplatedObjectCfg<T>>T lookup(Class<T> type,String name){
  try (Timer.Context tctx=lookupTimer.time()){
    T inherited=this.locator.lookup(type,name);
    logger.debug(""String_Node_Str"" + type.getSimpleName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ inherited);
    return inherited;
  }
 }","public <T extends TemplatedObjectCfg<T>>T lookup(Class<T> type,String name){
  try (Timer.Context tctx=lookupTimer.time()){
    name=this.stipSmartMergePrefix(name);
    T inherited=this.locator.lookup(type,name);
    logger.debug(""String_Node_Str"" + type.getSimpleName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ inherited);
    return inherited;
  }
 }",0.9050445103857568
37865,"private void checkGroupExists(String name,NamedObjectCfg<?> user,BergamotValidationReport report){
  if (name != null && name.length() > 0) {
    if (name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str"")) {
      name=name.substring(1);
    }
  }
  GroupCfg group=this.lookup(GroupCfg.class,name);
  if (group == null) {
    report.logError(""String_Node_Str"" + name + ""String_Node_Str""+ user);
  }
}","private void checkGroupExists(String name,NamedObjectCfg<?> user,BergamotValidationReport report){
  GroupCfg group=this.lookup(GroupCfg.class,name);
  if (group == null) {
    report.logError(""String_Node_Str"" + name + ""String_Node_Str""+ user);
  }
}",0.750373692077728
37866,"public static CertificatePair generateCertificate(String DN,SerialNum serial,int days,int keySize,KeyType type,PublicKey key,CertificatePair issuer) throws Exception {
  if ((KeyType.INTERMEDIATE == type || KeyType.CLIENT == type || KeyType.SERVER == type) && issuer == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (issuer == null && key != null)   throw new IllegalArgumentException(""String_Node_Str"");
  KeyPair pair=null;
  if (key == null) {
    pair=generateRSAKeyPair(keySize);
    key=pair.getPublic();
  }
  Calendar now=Calendar.getInstance();
  Calendar expiry=Calendar.getInstance();
  expiry.add(Calendar.DAY_OF_YEAR,days);
  X500Name subjectDN=new X500Name(DN);
  X500Name issuerDN=issuer == null ? subjectDN : new X500Name(issuer.getCertificate().getSubjectX500Principal().getName());
  JcaX509v3CertificateBuilder builder=new JcaX509v3CertificateBuilder(issuerDN,serial.toBigInt(),now.getTime(),expiry.getTime(),subjectDN,key);
  JcaX509ExtensionUtils utils=new JcaX509ExtensionUtils();
  builder.addExtension(Extension.subjectKeyIdentifier,false,utils.createSubjectKeyIdentifier(key));
  if (issuer == null) {
    builder.addExtension(Extension.authorityKeyIdentifier,false,utils.createAuthorityKeyIdentifier(key));
  }
 else {
    builder.addExtension(Extension.authorityKeyIdentifier,false,utils.createAuthorityKeyIdentifier(issuer.getCertificate()));
  }
  if (KeyType.CA == type || KeyType.INTERMEDIATE == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(true));
    builder.addExtension(Extension.keyUsage,true,new KeyUsage(KeyUsage.keyEncipherment | KeyUsage.cRLSign | KeyUsage.dataEncipherment| KeyUsage.digitalSignature| KeyUsage.keyCertSign));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.anyExtendedKeyUsage));
  }
 else   if (KeyType.SERVER == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(false));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.id_kp_serverAuth));
  }
 else   if (KeyType.CLIENT == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(false));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.id_kp_clientAuth));
  }
  ContentSigner signer=new JcaContentSignerBuilder(""String_Node_Str"").build(issuer == null ? pair.getPrivate() : issuer.getKey());
  X509CertificateHolder theCertHolder=builder.build(signer);
  X509Certificate theCert=new JcaX509CertificateConverter().getCertificate(theCertHolder);
  theCert.verify(issuer == null ? key : issuer.getCertificate().getPublicKey());
  return new CertificatePair(theCert,pair == null ? null : pair.getPrivate());
}","public static CertificatePair generateCertificate(String DN,SerialNum serial,int days,int keySize,KeyType type,PublicKey key,CertificatePair issuer) throws Exception {
  if ((KeyType.INTERMEDIATE == type || KeyType.CLIENT == type || KeyType.SERVER == type) && issuer == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (issuer == null && key != null)   throw new IllegalArgumentException(""String_Node_Str"");
  KeyPair pair=null;
  if (key == null) {
    pair=generateRSAKeyPair(keySize);
    key=pair.getPublic();
  }
  Calendar now=Calendar.getInstance();
  Calendar expiry=Calendar.getInstance();
  expiry.add(Calendar.DAY_OF_YEAR,days);
  X500Principal subjectDN=new X500Principal(DN);
  X500Principal issuerDN=issuer == null ? subjectDN : issuer.getCertificate().getSubjectX500Principal();
  JcaX509v3CertificateBuilder builder=new JcaX509v3CertificateBuilder(issuerDN,serial.toBigInt(),now.getTime(),expiry.getTime(),subjectDN,key);
  JcaX509ExtensionUtils utils=new JcaX509ExtensionUtils();
  builder.addExtension(Extension.subjectKeyIdentifier,false,utils.createSubjectKeyIdentifier(key));
  if (issuer == null) {
    builder.addExtension(Extension.authorityKeyIdentifier,false,utils.createAuthorityKeyIdentifier(key));
  }
 else {
    builder.addExtension(Extension.authorityKeyIdentifier,false,utils.createAuthorityKeyIdentifier(issuer.getCertificate()));
  }
  if (KeyType.CA == type || KeyType.INTERMEDIATE == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(true));
    builder.addExtension(Extension.keyUsage,true,new KeyUsage(KeyUsage.keyEncipherment | KeyUsage.cRLSign | KeyUsage.dataEncipherment| KeyUsage.digitalSignature| KeyUsage.keyCertSign));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.anyExtendedKeyUsage));
  }
 else   if (KeyType.SERVER == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(false));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.id_kp_serverAuth));
  }
 else   if (KeyType.CLIENT == type) {
    builder.addExtension(Extension.basicConstraints,true,new BasicConstraints(false));
    builder.addExtension(Extension.extendedKeyUsage,true,new ExtendedKeyUsage(KeyPurposeId.id_kp_clientAuth));
  }
  ContentSigner signer=new JcaContentSignerBuilder(""String_Node_Str"").build(issuer == null ? pair.getPrivate() : issuer.getKey());
  X509CertificateHolder theCertHolder=builder.build(signer);
  X509Certificate theCert=new JcaX509CertificateConverter().getCertificate(theCertHolder);
  theCert.verify(issuer == null ? key : issuer.getCertificate().getPublicKey());
  return new CertificatePair(theCert,pair == null ? null : pair.getPrivate());
}",0.956804626784746
37867,"public static void main(String[] args) throws Exception {
  JMXChecker checker=new JMXChecker();
  ScriptEngineManager factory=new RestrictedScriptEngineManager();
  ScriptEngine script=factory.getEngineByName(""String_Node_Str"");
  SimpleBindings bindings=new SimpleBindings();
  bindings.put(""String_Node_Str"",checker.createContext((t) -> {
    t.printStackTrace();
  }
));
  script.setBindings(bindings,ScriptContext.ENGINE_SCOPE);
  script.eval(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  JMXChecker checker=new JMXChecker();
  ScriptEngineManager factory=new RestrictedScriptEngineManager();
  ScriptEngine script=factory.getEngineByName(""String_Node_Str"");
  SimpleBindings bindings=new SimpleBindings();
  bindings.put(""String_Node_Str"",checker.createContext((t) -> {
    t.printStackTrace();
  }
));
  script.setBindings(bindings,ScriptContext.ENGINE_SCOPE);
  script.eval(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.960621761658031
37868,"public Certificate signServer(String commonName,PublicKey key){
  if (this.keyStore.hasServer(commonName)) {
    CertificatePair current=this.keyStore.loadServer(commonName);
    SerialNum currentSerial=SerialNum.fromBigInt(current.getCertificate().getSerialNumber());
    CertificatePair root=this.keyStore.loadRootCA();
    try {
      logger.info(""String_Node_Str"" + commonName + ""String_Node_Str""+ this.buildDN(commonName));
      CertificatePair server=RSAUtil.generateCertificate(this.buildDN(commonName),currentSerial.revision(),365 * 5,2048,KeyType.SERVER,key,root);
      this.keyStore.storeServer(commonName,server);
      return server.getCertificate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
 else {
    CertificatePair root=this.keyStore.loadRootCA();
    try {
      logger.info(""String_Node_Str"" + commonName + ""String_Node_Str""+ this.buildDN(commonName));
      CertificatePair server=RSAUtil.generateCertificate(this.buildDN(commonName),SerialNum.randomSerialNum(),365 * 5,2048,KeyType.SERVER,key,root);
      this.keyStore.storeServer(commonName,server);
      return server.getCertificate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","public Certificate signServer(String commonName,PublicKey key){
  if (this.keyStore.hasServer(commonName)) {
    CertificatePair current=this.keyStore.loadServer(commonName);
    SerialNum currentSerial=SerialNum.fromBigInt(current.getCertificate().getSerialNumber());
    CertificatePair root=this.keyStore.loadRootCA();
    try {
      logger.info(""String_Node_Str"" + commonName + ""String_Node_Str""+ this.buildDN(commonName));
      CertificatePair server=RSAUtil.generateCertificate(this.buildDN(commonName),currentSerial.revision(),365 * 5,2048,KeyType.SERVER,key,root);
      this.keyStore.storeServer(commonName,server);
      return server.getCertificate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
 else {
    CertificatePair root=this.keyStore.loadRootCA();
    try {
      logger.info(""String_Node_Str"" + commonName + ""String_Node_Str""+ this.buildDN(commonName));
      CertificatePair server=RSAUtil.generateCertificate(this.buildDN(commonName),SerialNum.fromName(commonName),365 * 5,2048,KeyType.SERVER,key,root);
      this.keyStore.storeServer(commonName,server);
      return server.getCertificate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.9862258953168044
37869,"@Override public void storeAgent(UUID siteId,UUID agentId,CertificatePair pair){
synchronized (this) {
    try {
      SerialNum serial=SerialNum.fromBigInt(pair.getCertificate().getSerialNumber());
      File crtFile=this.agentCrtFile(siteId,serial);
      crtFile.getParentFile().mkdirs();
      pair.saveCertificate(crtFile);
      Path crtLink=this.agentCrtFile(siteId,agentId).toPath();
      Files.delete(crtLink);
      Files.createSymbolicLink(crtLink,crtFile.toPath());
      if (pair.getKey() != null) {
        File keyFile=this.agentKeyFile(siteId,serial);
        keyFile.getParentFile().mkdirs();
        pair.saveKey(keyFile);
        Path keyLink=this.agentKeyFile(siteId,agentId).toPath();
        Files.delete(keyLink);
        Files.createSymbolicLink(keyLink,keyFile.toPath());
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + siteId + ""String_Node_Str""+ agentId,e);
    }
  }
}","@Override public void storeAgent(UUID siteId,UUID agentId,CertificatePair pair){
synchronized (this) {
    try {
      SerialNum serial=SerialNum.fromBigInt(pair.getCertificate().getSerialNumber());
      File crtFile=this.agentCrtFile(siteId,serial);
      crtFile.getParentFile().mkdirs();
      pair.saveCertificate(crtFile);
      Path crtLink=this.agentCrtFile(siteId,agentId).toPath();
      try {
        Files.delete(crtLink);
      }
 catch (      NoSuchFileException e) {
      }
      Files.createSymbolicLink(crtLink,crtFile.toPath());
      if (pair.getKey() != null) {
        File keyFile=this.agentKeyFile(siteId,serial);
        keyFile.getParentFile().mkdirs();
        pair.saveKey(keyFile);
        Path keyLink=this.agentKeyFile(siteId,agentId).toPath();
        try {
          Files.delete(keyLink);
        }
 catch (        NoSuchFileException e) {
        }
        Files.createSymbolicLink(keyLink,keyFile.toPath());
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + siteId + ""String_Node_Str""+ agentId,e);
    }
  }
}",0.9281496062992126
37870,"@Override public void storeServer(String commonName,CertificatePair pair){
synchronized (this) {
    try {
      SerialNum serial=SerialNum.fromBigInt(pair.getCertificate().getSerialNumber());
      File crtFile=this.serverCrtFile(serial);
      crtFile.getParentFile().mkdirs();
      pair.saveCertificate(crtFile);
      Path crtLink=this.serverCrtFile(commonName).toPath();
      Files.delete(crtLink);
      Files.createSymbolicLink(crtLink,crtFile.toPath());
      if (pair.getKey() != null) {
        File keyFile=this.serverKeyFile(serial);
        keyFile.getParentFile().mkdirs();
        pair.saveKey(keyFile);
        Path keyLink=this.serverKeyFile(commonName).toPath();
        Files.delete(keyLink);
        Files.createSymbolicLink(keyLink,keyFile.toPath());
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + commonName,e);
    }
  }
}","@Override public void storeServer(String commonName,CertificatePair pair){
synchronized (this) {
    try {
      SerialNum serial=SerialNum.fromBigInt(pair.getCertificate().getSerialNumber());
      File crtFile=this.serverCrtFile(serial);
      crtFile.getParentFile().mkdirs();
      pair.saveCertificate(crtFile);
      Path crtLink=this.serverCrtFile(commonName).toPath();
      try {
        Files.delete(crtLink);
      }
 catch (      NoSuchFileException e) {
      }
      Files.createSymbolicLink(crtLink,crtFile.toPath());
      if (pair.getKey() != null) {
        File keyFile=this.serverKeyFile(serial);
        keyFile.getParentFile().mkdirs();
        pair.saveKey(keyFile);
        Path keyLink=this.serverKeyFile(commonName).toPath();
        try {
          Files.delete(keyLink);
        }
 catch (        NoSuchFileException e) {
        }
        Files.createSymbolicLink(keyLink,keyFile.toPath());
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + commonName,e);
    }
  }
}",0.9245087900723888
37871,"@Override public CertificatePair loadAgent(UUID siteId,UUID agentId){
  try {
    if (this.agentKeyFile(siteId,agentId).exists()) {
      return new CertificatePair(this.agentCrtFile(siteId,agentId),this.agentKeyFile(siteId,agentId));
    }
 else {
      return new CertificatePair(this.agentCrtFile(siteId,agentId),null);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + siteId + ""String_Node_Str""+ agentId,e);
  }
}","@Override public CertificatePair loadAgent(UUID siteId,UUID agentId){
  try {
    if (this.agentKeyFile(siteId,agentId).exists()) {
      return new CertificatePair(this.agentCrtFile(siteId,agentId),this.agentKeyFile(siteId,agentId));
    }
 else {
      return new CertificatePair(this.agentCrtFile(siteId,agentId));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + siteId + ""String_Node_Str""+ agentId,e);
  }
}",0.9944629014396456
37872,"@Override public CertificatePair loadServer(String commonName){
  try {
    if (this.serverKeyFile(commonName).exists()) {
      return new CertificatePair(this.serverCrtFile(commonName),this.serverKeyFile(commonName));
    }
 else {
      return new CertificatePair(this.serverCrtFile(commonName),null);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + commonName,e);
  }
}","@Override public CertificatePair loadServer(String commonName){
  try {
    if (this.serverKeyFile(commonName).exists()) {
      return new CertificatePair(this.serverCrtFile(commonName),this.serverKeyFile(commonName));
    }
 else {
      return new CertificatePair(this.serverCrtFile(commonName));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + commonName,e);
  }
}",0.9938800489596084
37873,"protected Transition computeResultTransition(RealCheck<?,?> check,CheckState currentState,ResultMO resultMO){
  Status resultStatus=Status.parse(resultMO.getStatus());
  if (resultMO.isOk() != resultStatus.isOk()) {
    resultMO.setOk(resultStatus.isOk());
  }
  boolean hasDependencies=!check.getDependsIds().isEmpty();
  boolean dependenciesAreAllHard=true;
  boolean dependenciesAreAllOk=true;
  UUID encompassingAlertId=null;
  if (hasDependencies) {
    for (    Check<?,?> dependency : check.getDepends()) {
      CheckState dependencyState=dependency.getState();
      dependenciesAreAllHard&=dependencyState.isHard();
      dependenciesAreAllOk&=dependencyState.isHardOk();
      if (dependencyState.isHardNotOk() && encompassingAlertId == null)       encompassingAlertId=dependencyState.getCurrentAlertId();
    }
    logger.debug(""String_Node_Str"" + check.getId() + ""String_Node_Str""+ dependenciesAreAllHard+ ""String_Node_Str""+ dependenciesAreAllOk);
  }
  CheckState nextState=currentState.clone();
  nextState.setOk(resultMO.isOk());
  nextState.pushOkHistory(resultMO.isOk());
  nextState.setStatus(resultStatus);
  nextState.setOutput(resultMO.getOutput());
  nextState.setLastCheckTime(new Timestamp(resultMO.getExecuted()));
  nextState.setInDowntime(check.isInDowntime());
  nextState.setSuppressed(check.isSuppressed());
  if (currentState.getCurrentAlertId() != null) {
    Alert currentAlert=currentState.getCurrentAlert();
    currentState.setAcknowledged(currentAlert.isAcknowledged());
  }
  nextState.setEncompassed(dependenciesAreAllHard && (!dependenciesAreAllOk));
  if (currentState.isOk() ^ nextState.isOk()) {
    if (currentState.isHard()) {
      nextState.setLastHardOk(currentState.isOk());
      nextState.setLastHardStatus(currentState.getStatus());
      nextState.setLastHardOutput(currentState.getOutput());
    }
    nextState.setLastStateChange(new Timestamp(System.currentTimeMillis()));
    if (check.computeCurrentAttemptThreshold(nextState) <= 1 && ((!hasDependencies) || dependenciesAreAllHard)) {
      nextState.setHard(true);
      nextState.setTransitioning(false);
      nextState.setAttempt(check.computeCurrentAttemptThreshold(nextState));
      if (nextState.isAlert()) {
        nextState.setCurrentAlertId(encompassingAlertId == null ? Site.randomId(check.getSiteId()) : encompassingAlertId);
        nextState.setAcknowledged(false);
      }
      if (nextState.isRecovery()) {
        nextState.setCurrentAlertId(null);
        nextState.setAcknowledged(false);
      }
      return new Transition().previousState(currentState).nextState(nextState).stateChange(true).hardChange(true).alert(nextState.isAlert()).recovery(nextState.isRecovery());
    }
 else {
      nextState.setHard(false);
      nextState.setTransitioning(true);
      nextState.setAttempt(1);
      return new Transition().previousState(currentState).nextState(nextState).stateChange(true).hardChange(false).alert(false).recovery(false);
    }
  }
 else   if (currentState.isHard()) {
    return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(false).alert(false).recovery(false);
  }
 else {
    nextState.setAttempt(currentState.getAttempt() + 1);
    if (nextState.getAttempt() >= check.computeCurrentAttemptThreshold(nextState) && ((!hasDependencies) || dependenciesAreAllHard)) {
      nextState.setHard(true);
      nextState.setTransitioning(false);
      nextState.setAttempt(check.computeCurrentAttemptThreshold(nextState));
      if (nextState.isAlert()) {
        nextState.setCurrentAlertId(encompassingAlertId == null ? Site.randomId(check.getSiteId()) : encompassingAlertId);
        nextState.setAcknowledged(false);
      }
      if (nextState.isRecovery()) {
        nextState.setCurrentAlertId(null);
        nextState.setAcknowledged(false);
      }
      return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(true).alert(nextState.isAlert()).recovery(nextState.isRecovery());
    }
 else {
      return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(false).alert(false).recovery(false);
    }
  }
}","protected Transition computeResultTransition(RealCheck<?,?> check,CheckState currentState,ResultMO resultMO){
  Status resultStatus=Status.parse(resultMO.getStatus());
  if (resultMO.isOk() != resultStatus.isOk()) {
    resultMO.setOk(resultStatus.isOk());
  }
  boolean hasDependencies=check.hasDependencies();
  boolean dependenciesAreAllHard=true;
  boolean dependenciesAreAllOk=true;
  UUID encompassingAlertId=null;
  if (hasDependencies) {
    for (    Check<?,?> dependency : check.getDepends()) {
      CheckState dependencyState=dependency.getState();
      dependenciesAreAllHard&=dependencyState.isHard();
      dependenciesAreAllOk&=dependencyState.isHardOk();
      if (dependencyState.isHardNotOk() && encompassingAlertId == null)       encompassingAlertId=dependencyState.getCurrentAlertId();
    }
    logger.debug(""String_Node_Str"" + check.getId() + ""String_Node_Str""+ dependenciesAreAllHard+ ""String_Node_Str""+ dependenciesAreAllOk);
  }
  CheckState nextState=currentState.clone();
  nextState.setOk(resultMO.isOk());
  nextState.pushOkHistory(resultMO.isOk());
  nextState.setStatus(resultStatus);
  nextState.setOutput(resultMO.getOutput());
  nextState.setLastCheckTime(new Timestamp(resultMO.getExecuted()));
  nextState.setInDowntime(check.isInDowntime());
  nextState.setSuppressed(check.isSuppressed());
  if (currentState.getCurrentAlertId() != null) {
    Alert currentAlert=currentState.getCurrentAlert();
    currentState.setAcknowledged(currentAlert == null ? false : currentAlert.isAcknowledged());
  }
  nextState.setEncompassed(dependenciesAreAllHard && (!dependenciesAreAllOk));
  if (currentState.isOk() ^ nextState.isOk()) {
    if (currentState.isHard()) {
      nextState.setLastHardOk(currentState.isOk());
      nextState.setLastHardStatus(currentState.getStatus());
      nextState.setLastHardOutput(currentState.getOutput());
    }
    nextState.setLastStateChange(new Timestamp(System.currentTimeMillis()));
    if (check.computeCurrentAttemptThreshold(nextState) <= 1 && ((!hasDependencies) || dependenciesAreAllHard)) {
      nextState.setHard(true);
      nextState.setTransitioning(false);
      nextState.setAttempt(check.computeCurrentAttemptThreshold(nextState));
      if (nextState.isAlert()) {
        nextState.setCurrentAlertId(encompassingAlertId == null ? Site.randomId(check.getSiteId()) : encompassingAlertId);
        nextState.setAcknowledged(false);
      }
      if (nextState.isRecovery()) {
        nextState.setCurrentAlertId(null);
        nextState.setAcknowledged(false);
      }
      return new Transition().previousState(currentState).nextState(nextState).stateChange(true).hardChange(true).alert(nextState.isAlert()).recovery(nextState.isRecovery());
    }
 else {
      nextState.setHard(false);
      nextState.setTransitioning(true);
      nextState.setAttempt(1);
      return new Transition().previousState(currentState).nextState(nextState).stateChange(true).hardChange(false).alert(false).recovery(false);
    }
  }
 else   if (currentState.isHard()) {
    return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(false).alert(false).recovery(false);
  }
 else {
    nextState.setAttempt(currentState.getAttempt() + 1);
    if (nextState.getAttempt() >= check.computeCurrentAttemptThreshold(nextState) && ((!hasDependencies) || dependenciesAreAllHard)) {
      nextState.setHard(true);
      nextState.setTransitioning(false);
      nextState.setAttempt(check.computeCurrentAttemptThreshold(nextState));
      if (nextState.isAlert()) {
        nextState.setCurrentAlertId(encompassingAlertId == null ? Site.randomId(check.getSiteId()) : encompassingAlertId);
        nextState.setAcknowledged(false);
      }
      if (nextState.isRecovery()) {
        nextState.setCurrentAlertId(null);
        nextState.setAcknowledged(false);
      }
      return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(true).alert(nextState.isAlert()).recovery(nextState.isRecovery());
    }
 else {
      return new Transition().previousState(currentState).nextState(nextState).stateChange(false).hardChange(false).alert(false).recovery(false);
    }
  }
}",0.9930985245121372
37874,"public void buildRouteAPICall(StringBuilder sb,Set<String> imports){
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  for (  RouteParameter param : this.parameters) {
    imports.add(param.getType().getCanonicalName());
  }
  if (void.class != this.returnType)   imports.add(this.returnType.getCanonicalName());
  if (this.returnOfType != null)   imports.add(this.returnOfType.getCanonicalName());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(this.getBindingReturnType()).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  RouteParameter parameter : this.parameters) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(parameter.getType().getSimpleName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  RouteParameter parameter : this.parameters) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"").append(parameter.getType().getSimpleName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  String url=""String_Node_Str"" + this.getPath() + ""String_Node_Str"";
  for (  RouteParameter param : this.parameters) {
    if (param.isAs())     url=url.replace(""String_Node_Str"" + param.getName(),""String_Node_Str"" + param.getFieldName() + ""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.getBindingReturnType()).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  if (""String_Node_Str"".equalsIgnoreCase(this.method) || ""String_Node_Str"".equalsIgnoreCase(this.method)) {
    sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    boolean ns=false;
    for (    RouteParameter param : this.parameters) {
      if (!param.isAs()) {
        if (ns)         sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(param.getFieldName()).append(""String_Node_Str"");
        ns=true;
      }
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
 else {
    if (this.parameters.stream().anyMatch((p) -> !p.isAs())) {
      sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
      for (      RouteParameter param : this.parameters) {
        if (!param.isAs()) {
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(param.getFieldName()).append(""String_Node_Str"");
        }
      }
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  if (void.class == this.returnType) {
    sb.append(""String_Node_Str"");
  }
 else   if (List.class == this.returnType) {
    sb.append(""String_Node_Str"").append(this.returnOfType == null ? ""String_Node_Str"" : this.returnOfType.getSimpleName()).append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"").append(this.getReturnType().getSimpleName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(this.callName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
}","public void buildRouteAPICall(StringBuilder sb,Set<String> imports){
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  imports.add(""String_Node_Str"");
  for (  RouteParameter param : this.parameters) {
    imports.add(param.getType().getCanonicalName());
  }
  if (void.class != this.returnType)   imports.add(this.returnType.getCanonicalName());
  if (this.returnOfType != null)   imports.add(this.returnOfType.getCanonicalName());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(this.getBindingReturnType()).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  RouteParameter parameter : this.parameters) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(parameter.getType().getSimpleName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  RouteParameter parameter : this.parameters) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"").append(parameter.getType().getSimpleName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"").append(parameter.getFieldName()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  String url=""String_Node_Str"" + this.getPath() + ""String_Node_Str"";
  for (  RouteParameter param : this.parameters) {
    if (param.isAs())     url=url.replace(""String_Node_Str"" + param.getName(),""String_Node_Str"" + param.getFieldName() + ""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.getBindingReturnType()).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  if (""String_Node_Str"".equalsIgnoreCase(this.method) || ""String_Node_Str"".equalsIgnoreCase(this.method)) {
    sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    boolean ns=false;
    for (    RouteParameter param : this.parameters) {
      if (!param.isAs()) {
        if (ns)         sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(param.getFieldName()).append(""String_Node_Str"");
        ns=true;
      }
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
 else {
    if (this.parameters.stream().allMatch((p) -> p.isAs())) {
      sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"").append(url).append(""String_Node_Str"");
      for (      RouteParameter param : this.parameters) {
        if (!param.isAs()) {
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(param.getFieldName()).append(""String_Node_Str"");
        }
      }
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  if (void.class == this.returnType) {
    sb.append(""String_Node_Str"");
  }
 else   if (List.class == this.returnType) {
    sb.append(""String_Node_Str"").append(this.returnOfType == null ? ""String_Node_Str"" : this.returnOfType.getSimpleName()).append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"").append(this.getReturnType().getSimpleName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Util.ucFirst(this.callName)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
}",0.9748003733278026
37875,"@Any(""String_Node_Str"") public void generateJavaAPIBindings() throws Exception {
  StringBuilder bindings=new StringBuilder();
  Set<String> imports=new TreeSet<String>();
  for (  Router<?> router : app().getRouters()) {
    String prefix=router.getPrefix();
    if (prefix.startsWith(""String_Node_Str"")) {
      for (      Route route : Route.fromRouter(prefix,router)) {
        if ((!route.isFilter()) && (!route.isExceptionHandler())) {
          RouteInfo info=new RouteInfo(route);
          if (!info.isIgnoreBinding()) {
            info.buildRouteAPICall(bindings,imports);
          }
        }
      }
    }
  }
  BalsaWriter writer=response().ok().contentType(""String_Node_Str"").getViewWriter();
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  for (  String imported : imports) {
    writer.append(""String_Node_Str"").append(imported).append(""String_Node_Str"");
  }
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(bindings.toString());
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}","@Any(""String_Node_Str"") public void generateJavaAPIBindings() throws Exception {
  StringBuilder bindings=new StringBuilder();
  Set<String> imports=new TreeSet<String>();
  for (  Router<?> router : app().getRouters()) {
    String prefix=router.getPrefix();
    if (prefix.startsWith(""String_Node_Str"")) {
      for (      Route route : Route.fromRouter(prefix,router)) {
        if ((!route.isFilter()) && (!route.isExceptionHandler())) {
          RouteInfo info=new RouteInfo(route);
          if (!info.isIgnoreBinding()) {
            info.buildRouteAPICall(bindings,imports);
          }
        }
      }
    }
  }
  BalsaWriter writer=response().ok().contentType(""String_Node_Str"").header(""String_Node_Str"",""String_Node_Str"").getViewWriter();
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  for (  String imported : imports) {
    writer.append(""String_Node_Str"").append(imported).append(""String_Node_Str"");
  }
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(bindings.toString());
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}",0.988463555322496
37876,"@SQLPatch(name=""String_Node_Str"",index=1,type=ScriptType.BOTH,version=@SQLVersion({1,5,0})) protected static SQLScript createHelperFunctions(){
  return new SQLScript(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@SQLPatch(name=""String_Node_Str"",index=1,type=ScriptType.BOTH,version=@SQLVersion({1,0,0})) protected static SQLScript createHelperFunctions(){
  return new SQLScript(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.9955357142857144
37877,"@SQLPatch(name=""String_Node_Str"",index=1000,type=ScriptType.BOTH,version=@SQLVersion({1,5,0})) protected static SQLScript setFunctionOWner(){
  return new SQLScript(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@SQLPatch(name=""String_Node_Str"",index=1000,type=ScriptType.BOTH,version=@SQLVersion({1,0,0})) protected static SQLScript setFunctionOWner(){
  return new SQLScript(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.99822695035461
37878,"/** 
 * Compute the permissions model for the given site
 * @param siteId
 * @return the number of permissions computed
 */
public int buildPermissions(UUID siteId){
  int changed=this.useTimed(build_permissions,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,siteId);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getInt(1);
      }
     }
     return null;
  }
);
  this.getAdapterCache().removePrefix(""String_Node_Str"" + siteId);
  this.getAdapterCache().removePrefix(""String_Node_Str"" + siteId);
  this.getAdapterCache().removePrefix(""String_Node_Str"" + siteId);
  return changed;
}","/** 
 * Compute the permissions model for the given site
 * @param siteId
 * @return the number of permissions computed
 */
public int buildPermissions(UUID siteId){
  int changed=this.useTimed(build_permissions,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,siteId);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getInt(1);
      }
     }
     return null;
  }
);
  this.invalidatePermissionsCache(siteId);
  return changed;
}",0.7885245901639344
37879,"protected void linkSecurityDomains(SecuredObjectCfg<?> resolvedConfiguration,SecuredObject<?,?> object,BergamotDB db){
  db.removeSecurityDomainMembershipForCheck(object.getId());
  for (  String securityDomainName : resolvedConfiguration.getSecurityDomains()) {
    SecurityDomain domain=db.getSecurityDomainByName(this.site.getId(),securityDomainName);
    if (domain != null)     db.addCheckToSecurityDomain(domain.getId(),object.getId());
  }
}","protected void linkSecurityDomains(SecuredObjectCfg<?> resolvedConfiguration,SecuredObject<?,?> object,BergamotDB db){
  db.removeSecurityDomainMembershipForCheck(object.getId());
  for (  String securityDomainName : resolvedConfiguration.getSecurityDomains()) {
    SecurityDomain domain=db.getSecurityDomainByName(this.site.getId(),securityDomainName);
    if (domain != null)     db.addCheckToSecurityDomain(domain.getId(),object.getId());
  }
  this.clearPermissionsCache=true;
}",0.962406015037594
37880,"public BergamotImportReport importConfiguration(){
  if (this.report == null) {
    this.report=new BergamotImportReport(this.config.getSite());
    try {
      try (BergamotDB db=BergamotDB.connect()){
        db.execute(() -> {
          this.loadSite(db);
          this.computeCascade(db);
          this.loadSecurityDomains(db);
          this.loadTemplates(db);
          this.loadCommands(db);
          this.loadTimePeriods(db);
          this.loadTeams(db);
          this.loadContacts(db);
          this.loadLocations(db);
          this.loadGroups(db);
          this.loadHosts(db);
          this.loadClusters(db);
          if (this.rebuildPermissions) {
            this.report.info(""String_Node_Str"");
            db.buildPermissions(this.site.getId());
          }
        }
);
        if (this.online) {
          try (SchedulerQueue queue=SchedulerQueue.open()){
            try (RoutedProducer<SchedulerAction,SchedulerKey> producer=queue.publishSchedulerActions()){
              for (              DelayedSchedulerAction delayedAction : this.delayedSchedulerActions) {
                producer.publish(delayedAction.key,delayedAction.action);
              }
            }
           }
           try (NotificationQueue notificationQueue=NotificationQueue.open()){
            try (RoutedProducer<Notification,NotificationKey> notificationsProducer=notificationQueue.publishNotifications()){
              for (              Contact contact : this.delayedContactRegistrations) {
                try {
                  String url=this.registrationURLSupplier.apply(contact);
                  notificationsProducer.publish(new NotificationKey(contact.getSite().getId()),new RegisterContactNotification(contact.getSite().toMOUnsafe(),contact.toMOUnsafe().addEngine(""String_Node_Str""),url));
                }
 catch (                Exception e) {
                  Logger.getLogger(BergamotConfigImporter.class).error(""String_Node_Str"",e);
                  throw e;
                }
              }
            }
           }
         }
      }
     }
 catch (    Throwable e) {
      Logger.getLogger(BergamotConfigImporter.class).error(""String_Node_Str"",e);
      this.report.error(""String_Node_Str"" + e.getMessage());
      StringWriter sw=new StringWriter();
      e.printStackTrace(new PrintWriter(sw));
      this.report.error(sw.toString());
    }
  }
  return this.report;
}","public BergamotImportReport importConfiguration(){
  if (this.report == null) {
    this.report=new BergamotImportReport(this.config.getSite());
    try {
      try (BergamotDB db=BergamotDB.connect()){
        db.execute(() -> {
          this.loadSite(db);
          this.computeCascade(db);
          this.loadSecurityDomains(db);
          this.loadTemplates(db);
          this.loadCommands(db);
          this.loadTimePeriods(db);
          this.loadTeams(db);
          this.loadContacts(db);
          this.loadLocations(db);
          this.loadGroups(db);
          this.loadHosts(db);
          this.loadClusters(db);
          if (this.rebuildPermissions) {
            this.report.info(""String_Node_Str"");
            db.buildPermissions(this.site.getId());
          }
          if (this.clearPermissionsCache) {
            this.report.info(""String_Node_Str"");
            db.invalidatePermissionsCache(this.site.getId());
          }
        }
);
        if (this.online) {
          try (SchedulerQueue queue=SchedulerQueue.open()){
            try (RoutedProducer<SchedulerAction,SchedulerKey> producer=queue.publishSchedulerActions()){
              for (              DelayedSchedulerAction delayedAction : this.delayedSchedulerActions) {
                producer.publish(delayedAction.key,delayedAction.action);
              }
            }
           }
           try (NotificationQueue notificationQueue=NotificationQueue.open()){
            try (RoutedProducer<Notification,NotificationKey> notificationsProducer=notificationQueue.publishNotifications()){
              for (              Contact contact : this.delayedContactRegistrations) {
                try {
                  String url=this.registrationURLSupplier.apply(contact);
                  notificationsProducer.publish(new NotificationKey(contact.getSite().getId()),new RegisterContactNotification(contact.getSite().toMOUnsafe(),contact.toMOUnsafe().addEngine(""String_Node_Str""),url));
                }
 catch (                Exception e) {
                  Logger.getLogger(BergamotConfigImporter.class).error(""String_Node_Str"",e);
                  throw e;
                }
              }
            }
           }
         }
      }
     }
 catch (    Throwable e) {
      Logger.getLogger(BergamotConfigImporter.class).error(""String_Node_Str"",e);
      this.report.error(""String_Node_Str"" + e.getMessage());
      StringWriter sw=new StringWriter();
      e.printStackTrace(new PrintWriter(sw));
      this.report.error(sw.toString());
    }
  }
  return this.report;
}",0.966459128339024
37881,"/** 
 * Does the given contact have the given permission for the given security domain
 * @param contactId the contact
 * @param securityDomainId the security domain
 * @param permission the permission
 * @return true if the contact has permission
 */
public boolean hasPermissionForSecurityDomain(UUID contactId,UUID securityDomainId,String permission){
  return this.useTimedCached(has_permission_for_domain,cache_miss_has_permission_for_domain,""String_Node_Str"" + this.getSiteId(contactId) + ""String_Node_Str""+ contactId+ ""String_Node_Str""+ permission,null,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,contactId);
      stmt.setObject(2,securityDomainId);
      stmt.setString(3,permission);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getBoolean(1);
      }
     }
     return false;
  }
);
}","/** 
 * Does the given contact have the given permission for the given security domain
 * @param contactId the contact
 * @param securityDomainId the security domain
 * @param permission the permission
 * @return true if the contact has permission
 */
public boolean hasPermissionForSecurityDomain(UUID contactId,UUID securityDomainId,String permission){
  return this.useTimedCached(has_permission_for_domain,cache_miss_has_permission_for_domain,""String_Node_Str"" + this.getSiteId(contactId) + ""String_Node_Str""+ contactId+ ""String_Node_Str""+ securityDomainId+ ""String_Node_Str""+ permission,null,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,contactId);
      stmt.setObject(2,securityDomainId);
      stmt.setString(3,permission);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getBoolean(1);
      }
     }
     return false;
  }
);
}",0.9799457994579944
37882,"/** 
 * Does the given contact have the given permission for the given object
 * @param contactId the contact
 * @param objectId the object
 * @param permission the permission
 * @return true if the contact has permission
 */
public boolean hasPermissionForObject(UUID contactId,UUID objectId,String permission){
  return this.useTimedCached(has_permission_for_object,cache_miss_has_permission_for_object,""String_Node_Str"" + this.getSiteId(contactId) + ""String_Node_Str""+ contactId+ ""String_Node_Str""+ permission,null,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,contactId);
      stmt.setObject(2,objectId);
      stmt.setString(3,permission);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getBoolean(1);
      }
     }
     return false;
  }
);
}","/** 
 * Does the given contact have the given permission for the given object
 * @param contactId the contact
 * @param objectId the object
 * @param permission the permission
 * @return true if the contact has permission
 */
public boolean hasPermissionForObject(UUID contactId,UUID objectId,String permission){
  return this.useTimedCached(has_permission_for_object,cache_miss_has_permission_for_object,""String_Node_Str"" + this.getSiteId(contactId) + ""String_Node_Str""+ contactId+ ""String_Node_Str""+ objectId+ ""String_Node_Str""+ permission,null,(with) -> {
    try (PreparedStatement stmt=with.prepareStatement(""String_Node_Str"")){
      stmt.setObject(1,contactId);
      stmt.setObject(2,objectId);
      stmt.setString(3,permission);
      try (ResultSet rs=stmt.executeQuery()){
        if (rs.next())         return rs.getBoolean(1);
      }
     }
     return false;
  }
);
}",0.9833045480713876
37883,"@Override public int execute(BergamotCLI cli,List<String> args) throws Exception {
  if (args.size() != 1)   throw new BergamotCLIException(""String_Node_Str"");
  File confDir=new File(args.get(0));
  if (!confDir.isDirectory())   throw new BergamotCLIException(""String_Node_Str"" + confDir.getAbsolutePath() + ""String_Node_Str"");
  Collection<ValidatedBergamotConfiguration> bcfgs=new BergamotConfigReader().includeDir(new File(""String_Node_Str"")).build();
  for (  ValidatedBergamotConfiguration vbcfg : bcfgs) {
    System.out.println(vbcfg.getReport().toString());
  }
  return 0;
}","@Override public int execute(BergamotCLI cli,List<String> args) throws Exception {
  if (args.size() != 1)   throw new BergamotCLIException(""String_Node_Str"");
  File confDir=new File(args.get(0));
  if (!confDir.isDirectory())   throw new BergamotCLIException(""String_Node_Str"" + confDir.getAbsolutePath() + ""String_Node_Str"");
  Collection<ValidatedBergamotConfiguration> bcfgs=new BergamotConfigReader().includeDir(confDir).build();
  for (  ValidatedBergamotConfiguration vbcfg : bcfgs) {
    System.out.println(vbcfg.getReport().toString());
  }
  return 0;
}",0.970383275261324
37884,"@Cacheable @CacheInvalidate({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @SQLSetter(table=Alert.class,name=""String_Node_Str"",since=@SQLVersion({1,0,0})) public abstract void setAlert(Alert alert);","@Cacheable @CacheInvalidate({""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @SQLSetter(table=Alert.class,name=""String_Node_Str"",since=@SQLVersion({1,0,0})) public abstract void setAlert(Alert alert);",0.9617021276595744
37885,"public StoredDoubleGaugeReading(){
  super();
}","public StoredDoubleGaugeReading(UUID siteId,UUID readingId,Timestamp collectedAt,double value,double warning,double critical,double min,double max){
  super();
  this.siteId=siteId;
  this.readingId=readingId;
  this.collectedAt=collectedAt;
  this.value=value;
  this.warning=warning;
  this.critical=critical;
  this.min=min;
  this.max=max;
}",0.1836734693877551
37886,"public static String readValue(CharBuffer buffer) throws IOException {
  StringBuilder value=new StringBuilder();
  char c;
  while ((!Character.isWhitespace((c=buffer.get()))) && buffer.hasRemaining()) {
    value.append(c);
  }
  return value.toString();
}","public static String readValue(CharBuffer buffer) throws IOException {
  StringBuilder value=new StringBuilder();
  char c;
  while (buffer.hasRemaining()) {
    c=buffer.get();
    if (Character.isWhitespace(c))     break;
    value.append(c);
  }
  return value.toString();
}",0.7850467289719626
37887,"public static List<NagiosPerfData> parsePerfData(String perfData) throws IOException {
  List<NagiosPerfData> perfs=new LinkedList<NagiosPerfData>();
  CharBuffer buffer=CharBuffer.wrap(perfData.toCharArray());
  while (buffer.hasRemaining()) {
    skipWhitespace(buffer);
    String label=readLabel(buffer);
    String valueString=readValue(buffer);
    String[] values=valueString.split(""String_Node_Str"");
    String valueUOM=values.length > 1 ? values[0] : null;
    String warn=values.length > 2 ? values[1] : null;
    String crit=values.length > 3 ? values[2] : null;
    String min=values.length > 4 ? values[3] : null;
    String max=values.length > 5 ? values[4] : null;
    Matcher matcher=VALUE_UOM_PATTERN.matcher(valueUOM);
    if (matcher.matches()) {
      String value=matcher.group(1);
      String unit=matcher.group(2);
      perfs.add(new NagiosPerfData(label,value,unit,warn,crit,min,max));
    }
 else {
      throw new IOException(""String_Node_Str"" + valueUOM);
    }
  }
  return perfs;
}","public static List<NagiosPerfData> parsePerfData(String perfData) throws IOException {
  List<NagiosPerfData> perfs=new LinkedList<NagiosPerfData>();
  CharBuffer buffer=CharBuffer.wrap(perfData.toCharArray());
  while (buffer.hasRemaining()) {
    skipWhitespace(buffer);
    String label=readLabel(buffer);
    String valueString=readValue(buffer);
    String[] values=valueString.split(""String_Node_Str"");
    String valueUOM=values.length > 0 ? values[0] : null;
    String warn=values.length > 1 ? values[1] : null;
    String crit=values.length > 2 ? values[2] : null;
    String min=values.length > 3 ? values[3] : null;
    String max=values.length > 4 ? values[4] : null;
    Matcher matcher=VALUE_UOM_PATTERN.matcher(valueUOM);
    if (matcher.matches()) {
      String value=matcher.group(1);
      String unit=matcher.group(2);
      perfs.add(new NagiosPerfData(label,value,unit,warn,crit,min,max));
    }
 else {
      throw new IOException(""String_Node_Str"" + valueUOM);
    }
  }
  return perfs;
}",0.9950641658440276
37888,"/** 
 * Apply a warning / critical threshold to determine the result state, this will  result in either a ok, warning or critical state depending on the values and  thresholds. This applies a threshold check to a collection of values, with the worst status  being the status of this result.
 * @param values the values to check
 * @param warning the warning threshold
 * @param critical the critical threshold
 * @param message the check output
 */
@JsonIgnore public ResultMO applyThreshold(Iterable<Double> values,double warning,double critical,String message){
  int state=0;
  for (  double value : values) {
    if (value > critical) {
      state=Math.max(state,2);
    }
 else     if (value > warning) {
      state=Math.max(state,1);
    }
 else {
      state=Math.max(state,0);
    }
  }
switch (state) {
case 0:
    this.ok(message);
  break;
case 1:
this.warning(message);
case 2:
this.critical(message);
}
return this;
}","/** 
 * Apply a warning / critical threshold to determine the result state, this will  result in either a ok, warning or critical state depending on the values and  thresholds. This applies a threshold check to a collection of values, with the worst status  being the status of this result.
 * @param values the values to check
 * @param warning the warning threshold
 * @param critical the critical threshold
 * @param message the check output
 */
@JsonIgnore public ResultMO applyThreshold(Iterable<Double> values,double warning,double critical,String message){
  int state=0;
  for (  double value : values) {
    if (value > critical) {
      state=Math.max(state,2);
    }
 else     if (value > warning) {
      state=Math.max(state,1);
    }
 else {
      state=Math.max(state,0);
    }
  }
switch (state) {
case 0:
    this.ok(message);
  break;
case 1:
this.warning(message);
break;
case 2:
this.critical(message);
break;
}
return this;
}",0.992545260915868
37889,"/** 
 * Apply a warning / critical threshold to determine the result state, this will  result in either a ok, warning or critical state depending on the values and  thresholds. This applies a threshold check to a collection of values, with the worst status  being the status of this result.
 * @param values the values to check
 * @param warning the warning threshold
 * @param critical the critical threshold
 * @param message the check output
 */
@JsonIgnore public ResultMO applyLessThanThreshold(Iterable<Double> values,double warning,double critical,String message){
  int state=0;
  for (  double value : values) {
    if (value < critical) {
      state=Math.max(state,2);
    }
 else     if (value < warning) {
      state=Math.max(state,1);
    }
 else {
      state=Math.max(state,0);
    }
  }
switch (state) {
case 0:
    this.ok(message);
  break;
case 1:
this.warning(message);
case 2:
this.critical(message);
}
return this;
}","/** 
 * Apply a warning / critical threshold to determine the result state, this will  result in either a ok, warning or critical state depending on the values and  thresholds. This applies a threshold check to a collection of values, with the worst status  being the status of this result.
 * @param values the values to check
 * @param warning the warning threshold
 * @param critical the critical threshold
 * @param message the check output
 */
@JsonIgnore public ResultMO applyLessThanThreshold(Iterable<Double> values,double warning,double critical,String message){
  int state=0;
  for (  double value : values) {
    if (value < critical) {
      state=Math.max(state,2);
    }
 else     if (value < warning) {
      state=Math.max(state,1);
    }
 else {
      state=Math.max(state,0);
    }
  }
switch (state) {
case 0:
    this.ok(message);
  break;
case 1:
this.warning(message);
break;
case 2:
this.critical(message);
break;
}
return this;
}",0.9926082365364308
37890,"public void unregisterAgent(BergamotAgentServerHandler agent){
  logger.debug(""String_Node_Str"");
  AgentHello hello=agent.getHello();
  this.agents.remove(hello.getHostId());
}","public void unregisterAgent(BergamotAgentServerHandler agent){
  logger.debug(""String_Node_Str"");
  this.agents.remove(agent.getHello().getHostId());
  if (this.onAgentUnregister != null)   this.onAgentUnregister.accept(agent);
}",0.5517241379310345
37891,"public void run(){
  bossGroup=new NioEventLoopGroup(1);
  workerGroup=new NioEventLoopGroup();
  try {
    SSLEngine engine=createSSLEngine();
    ServerBootstrap b=new ServerBootstrap();
    b.group(bossGroup,workerGroup);
    b.channel(NioServerSocketChannel.class);
    b.childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new ReadTimeoutHandler(30));
        pipeline.addLast(""String_Node_Str"",new WriteTimeoutHandler(30));
        pipeline.addLast(""String_Node_Str"",new SslHandler(engine));
        pipeline.addLast(""String_Node_Str"",new HttpServerCodec());
        pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
        pipeline.addLast(""String_Node_Str"",new BergamotAgentServerHandler(BergamotAgentServer.this,engine));
      }
    }
);
    Channel ch=b.bind(this.configuration.getPort()).sync().channel();
    logger.info(""String_Node_Str"" + this.configuration.getPort() + '.');
    ch.closeFuture().sync();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
 finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
  }
}","public void run(){
  bossGroup=new NioEventLoopGroup(1);
  workerGroup=new NioEventLoopGroup();
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(bossGroup,workerGroup);
    b.channel(NioServerSocketChannel.class);
    b.childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        SSLEngine engine=createSSLEngine();
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new ReadTimeoutHandler(30));
        pipeline.addLast(""String_Node_Str"",new WriteTimeoutHandler(30));
        pipeline.addLast(""String_Node_Str"",new SslHandler(engine));
        pipeline.addLast(""String_Node_Str"",new HttpServerCodec());
        pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
        pipeline.addLast(""String_Node_Str"",new BergamotAgentServerHandler(BergamotAgentServer.this,engine));
      }
    }
);
    Channel ch=b.bind(this.configuration.getPort()).sync().channel();
    logger.info(""String_Node_Str"" + this.configuration.getPort() + '.');
    ch.closeFuture().sync();
    logger.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
 finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
  }
}",0.9537750385208013
37892,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new ReadTimeoutHandler(30));
  pipeline.addLast(""String_Node_Str"",new WriteTimeoutHandler(30));
  pipeline.addLast(""String_Node_Str"",new SslHandler(engine));
  pipeline.addLast(""String_Node_Str"",new HttpServerCodec());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new BergamotAgentServerHandler(BergamotAgentServer.this,engine));
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  SSLEngine engine=createSSLEngine();
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new ReadTimeoutHandler(30));
  pipeline.addLast(""String_Node_Str"",new WriteTimeoutHandler(30));
  pipeline.addLast(""String_Node_Str"",new SslHandler(engine));
  pipeline.addLast(""String_Node_Str"",new HttpServerCodec());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new BergamotAgentServerHandler(BergamotAgentServer.this,engine));
}",0.966252220248668
37893,"public void registerAgent(BergamotAgentServerHandler agent){
  AgentHello hello=agent.getHello();
  this.agents.put(hello.getHostId(),agent);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    for (    BergamotAgentServerHandler ag : this.agents.values()) {
      logger.info(""String_Node_Str"" + ag.getHello().getHostId() + ""String_Node_Str""+ ag.getHello().getHostName()+ ""String_Node_Str""+ ag.getHello().getServiceId()+ ""String_Node_Str""+ ag.getHello().getServiceName());
    }
  }
  if (this.onAgentRegister != null)   this.onAgentRegister.accept(agent);
}","public void registerAgent(BergamotAgentServerHandler agent){
  this.agents.put(agent.getHello().getHostId(),agent);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
    for (    BergamotAgentServerHandler ag : this.agents.values()) {
      logger.info(""String_Node_Str"" + ag.getHello().getHostId() + ""String_Node_Str""+ ag.getHello().getHostName()+ ""String_Node_Str""+ ag.getHello().getServiceId()+ ""String_Node_Str""+ ag.getHello().getServiceName());
    }
  }
  if (this.onAgentRegister != null)   this.onAgentRegister.accept(agent);
}",0.948943661971831
37894,"@Test public void testBadToOkTransition(){
  Transition transition;
  RealCheck<?,?> check=newCheck(4,4);
  CheckState state=newState(Status.CRITICAL,""String_Node_Str"",true,4,false);
  Result result=newResult(true,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
}","@Test public void testBadToOkTransition(){
  System.out.println(""String_Node_Str"");
  Transition transition;
  RealCheck<?,?> check=newCheck(4,4);
  CheckState state=newState(Status.CRITICAL,""String_Node_Str"",true,4,false);
  Result result=newResult(true,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  System.out.println(""String_Node_Str"");
}",0.9797230464886252
37895,"@Test public void testOkToBadTransition(){
  Transition transition;
  RealCheck<?,?> check=newCheck(4,4);
  CheckState state=newState(Status.OK,""String_Node_Str"",true,4,false);
  Result result=newResult(false,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
}","@Test public void testOkToBadTransition(){
  System.out.println(""String_Node_Str"");
  Transition transition;
  RealCheck<?,?> check=newCheck(4,4);
  CheckState state=newState(Status.OK,""String_Node_Str"",true,4,false);
  Result result=newResult(false,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  state=transition.nextState;
  System.out.println(""String_Node_Str"");
}",0.9796727813584531
37896,"@Test public void testSingleOkToBadTransition(){
  Transition transition;
  RealCheck<?,?> check=newCheck(1,1);
  CheckState state=newState(Status.PENDING,""String_Node_Str"",true,1,false);
  Result result=newResult(false,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
}","@Test public void testSingleOkToBadTransition(){
  System.out.println(""String_Node_Str"");
  Transition transition;
  RealCheck<?,?> check=newCheck(1,1);
  CheckState state=newState(Status.PENDING,""String_Node_Str"",true,1,false);
  Result result=newResult(false,""String_Node_Str"",""String_Node_Str"");
  transition=this.computeResultTransition(check,state,result);
  System.out.println(""String_Node_Str"" + transition.stateChange + ""String_Node_Str""+ transition.hardChange+ ""String_Node_Str""+ transition.previousState+ ""String_Node_Str""+ transition.nextState);
  System.out.println(""String_Node_Str"");
}",0.9265232974910396
37897,"private CheckState newState(Status status,String output,boolean hard,int attempt,boolean transitioning){
  CheckState state=new CheckState();
  state.setCheckId(UUID.randomUUID());
  state.setStatus(status);
  state.setOk(state.isOk());
  state.setOutput(output);
  state.setHard(hard);
  state.setAttempt(attempt);
  state.setTransitioning(transitioning);
  return state;
}","private CheckState newState(Status status,String output,boolean hard,int attempt,boolean transitioning){
  CheckState state=new CheckState();
  state.setCheckId(UUID.randomUUID());
  state.setStatus(status);
  state.setOk(status.isOk());
  state.setOutput(output);
  state.setHard(hard);
  state.setAttempt(attempt);
  state.setTransitioning(transitioning);
  return state;
}",0.9959946595460614
37898,"public void execute(){
  if (this.port == -1)   this.port=this.ssl ? 443 : 80;
  if (this.virtualHost == null)   this.virtualHost=this.address;
  FullHttpRequest request=new DefaultFullHttpRequest(this.version,this.method,this.path);
  request.headers().add(HttpHeaders.Names.CONNECTION,HttpHeaders.Values.CLOSE);
  if (this.port == 80)   request.headers().add(HttpHeaders.Names.HOST,this.virtualHost);
 else   request.headers().add(HttpHeaders.Names.HOST,this.virtualHost + ""String_Node_Str"" + this.port);
  request.headers().add(HttpHeaders.Names.USER_AGENT,""String_Node_Str"");
  for (  Entry<String,String> e : this.headers) {
    request.headers().add(e.getKey(),e.getValue());
  }
  this.submit(this.address,this.port,this.connectTimeout,this.requestTimeout,this.ssl,this.permitInvalidCerts,this.virtualHost,this.protocols,this.ciphers,request,this.responseHandler,this.errorHandler);
}","public void execute(){
  if (this.port == -1)   this.port=this.ssl ? 443 : 80;
  if (this.virtualHost == null)   this.virtualHost=this.address;
  FullHttpRequest request=new DefaultFullHttpRequest(this.version,this.method,this.path);
  request.headers().add(HttpHeaders.Names.CONNECTION,HttpHeaders.Values.CLOSE);
  if (this.port == 80 || this.port == 443)   request.headers().add(HttpHeaders.Names.HOST,this.virtualHost);
 else   request.headers().add(HttpHeaders.Names.HOST,this.virtualHost + ""String_Node_Str"" + this.port);
  request.headers().add(HttpHeaders.Names.USER_AGENT,""String_Node_Str"");
  for (  Entry<String,String> e : this.headers) {
    request.headers().add(e.getKey(),e.getValue());
  }
  this.submit(this.address,this.port,this.connectTimeout,this.requestTimeout,this.ssl,this.permitInvalidCerts,this.virtualHost,this.protocols,this.ciphers,request,this.responseHandler,this.errorHandler);
}",0.9889012208657048
37899,"@Override public void channelActive(ChannelHandlerContext ctx){
  logger.debug(""String_Node_Str"");
  this.start=System.currentTimeMillis();
  ctx.writeAndFlush(this.request);
}","@Override public void channelActive(ChannelHandlerContext ctx){
  logger.debug(""String_Node_Str"");
  this.start=System.currentTimeMillis();
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + this.request);
  ctx.writeAndFlush(this.request);
}",0.812933025404157
37900,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  FullHttpResponse response=(FullHttpResponse)msg;
  long runtime=System.currentTimeMillis() - this.start;
  logger.debug(""String_Node_Str"" + response.getStatus() + ""String_Node_Str""+ runtime+ ""String_Node_Str"");
  TLSInfo tlsInfo=null;
  if (this.sslEngine != null) {
    try {
      tlsInfo=new TLSInfo(this.sslEngine);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  this.responseHandler.accept(new HTTPCheckResponse(runtime,response,tlsInfo));
  if (ctx.channel().isActive())   ctx.close();
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  FullHttpResponse response=(FullHttpResponse)msg;
  long runtime=System.currentTimeMillis() - this.start;
  logger.debug(""String_Node_Str"" + response.getStatus() + ""String_Node_Str""+ runtime+ ""String_Node_Str"");
  if (logger.isTraceEnabled())   logger.trace(""String_Node_Str"" + response);
  TLSInfo tlsInfo=null;
  if (this.sslEngine != null) {
    try {
      tlsInfo=new TLSInfo(this.sslEngine);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  this.responseHandler.accept(new HTTPCheckResponse(runtime,response,tlsInfo));
  if (ctx.channel().isActive())   ctx.close();
}",0.9403563129357088
37901,"public void configure(C configuration){
  this.setId(configuration.getId());
  this.setSiteId(Site.getSiteId(this.getId()));
  for (  CfgParameter param : configuration.getParameters()) {
    this.parameters.clear();
    this.parameters.add(new Parameter(param.getName(),param.getValueOrText()));
  }
  this.setConfiguration(configuration);
}","public void configure(C configuration){
  this.setId(configuration.getId());
  this.setSiteId(Site.getSiteId(this.getId()));
  this.parameters.clear();
  for (  CfgParameter param : configuration.getParameters()) {
    this.parameters.add(new Parameter(param.getName(),param.getValueOrText()));
  }
  this.setConfiguration(configuration);
}",0.7859237536656891
37902,"protected void toMO(CheckMO mo,boolean stub){
  super.toMO(mo,stub);
  mo.setEnabled(this.isEnabled());
  mo.setState(this.getState().toMO());
  mo.setSuppressed(this.isSuppressed());
  if (!stub) {
    mo.setGroups(this.getGroups().stream().map(Group::toStubMO).collect(Collectors.toList()));
    mo.setContacts(this.getContacts().stream().map(Contact::toStubMO).collect(Collectors.toList()));
    mo.setTeams(this.getTeams().stream().map(Team::toStubMO).collect(Collectors.toList()));
    mo.setReferencedBy(this.getReferencedBy().stream().map(VirtualCheck::toStubMO).collect(Collectors.toList()));
    mo.setNotifications(this.getNotifications().toMO());
  }
}","protected void toMO(CheckMO mo,boolean stub){
  super.toMO(mo,stub);
  mo.setEnabled(this.isEnabled());
  mo.setState(this.getState().toMO());
  mo.setSuppressed(this.isSuppressed());
  if (!stub) {
    mo.setGroups(this.getGroups().stream().map(Group::toStubMO).collect(Collectors.toList()));
    mo.setContacts(this.getContacts().stream().map(Contact::toStubMO).collect(Collectors.toList()));
    mo.setTeams(this.getTeams().stream().map(Team::toStubMO).collect(Collectors.toList()));
    mo.setReferencedBy(this.getReferencedBy().stream().map((v) -> {
      return (VirtualCheckMO)v.toStubMO();
    }
).collect(Collectors.toList()));
    mo.setNotifications(this.getNotifications().toMO());
  }
}",0.9588839941262848
37903,"@Override public GroupMO toMO(boolean stub){
  GroupMO mo=new GroupMO();
  super.toMO(mo,stub);
  mo.setState(this.getState().toMO());
  if (!stub) {
    mo.setChecks(this.getChecks().stream().map(Check::toStubMO).collect(Collectors.toList()));
    mo.setGroups(this.getGroups().stream().map(Group::toStubMO).collect(Collectors.toList()));
    mo.setChildren(this.getChildren().stream().map(Group::toStubMO).collect(Collectors.toList()));
  }
  return mo;
}","@Override public GroupMO toMO(boolean stub){
  GroupMO mo=new GroupMO();
  super.toMO(mo,stub);
  mo.setState(this.getState().toMO());
  if (!stub) {
    mo.setChecks(this.getChecks().stream().map((c) -> {
      return (CheckMO)c.toStubMO();
    }
).collect(Collectors.toList()));
    mo.setGroups(this.getGroups().stream().map(Group::toStubMO).collect(Collectors.toList()));
    mo.setChildren(this.getChildren().stream().map(Group::toStubMO).collect(Collectors.toList()));
  }
  return mo;
}",0.728421052631579
37904,"@SubscribeEvent public void harvestBlock(HarvestDropsEvent event){
  if (replacements != null) {
    if (event.block != null) {
      ItemStack oreStack=new ItemStack(event.block,1,event.blockMetadata);
      if (oreStack.getItem() != null) {
        int[] oreIDs=OreDictionary.getOreIDs(oreStack);
        int oreID;
        if (oreIDs.length > 0) {
          for (int i=0; i < oreIDs.length; i++) {
            oreID=oreIDs[i];
            if (oreID > -1) {
              String oreName=OreDictionary.getOreName(oreID);
              if (oreName != null && replacements.containsKey(oreName)) {
                String replacementName=replacements.get(oreName).getString();
                List<String> exclusionNames=Arrays.asList(exclusions.get(oreName).getStringList());
                UniqueIdentifier ore=GameRegistry.findUniqueIdentifierFor(oreStack.getItem());
                if (ore == null) {
                  return;
                }
                if (exclusionNames.contains(ore.modId + ""String_Node_Str"" + ore.name)) {
                  return;
                }
                ItemStack replacementStack=null;
                for (                ItemStack i1 : OreDictionary.getOres(oreID)) {
                  UniqueIdentifier item=GameRegistry.findUniqueIdentifierFor(i1.getItem());
                  if (item != null && !exclusionNames.contains(item.modId + ""String_Node_Str"" + item.name) && item.modId.contains(replacementName)) {
                    replacementStack=i1.copy();
                    break;
                  }
                }
                if (replacementStack != null) {
                  for (int i1=0; i1 < event.drops.size(); i1++) {
                    if (event.drops.get(i1) != null && event.drops.get(i1).isItemEqual(oreStack)) {
                      event.drops.set(i1,replacementStack);
                    }
                  }
                }
              }
            }
          }
        }
      }
 else {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}","@SubscribeEvent public void harvestBlock(HarvestDropsEvent event){
  if (replacements != null) {
    if (event.block != null) {
      ItemStack oreStack=new ItemStack(event.block,1,event.blockMetadata);
      if (oreStack.getItem() != null) {
        int[] oreIDs=OreDictionary.getOreIDs(oreStack);
        int oreID;
        if (oreIDs.length > 0) {
          for (int i=0; i < oreIDs.length; i++) {
            oreID=oreIDs[i];
            if (oreID > -1) {
              String oreName=OreDictionary.getOreName(oreID);
              if (oreName != null && replacements.containsKey(oreName)) {
                String replacementName=replacements.get(oreName).getString();
                Property exclusionDirty=exclusions.get(oreName);
                List<String> exclusionNames=null;
                if (exclusionDirty != null) {
                  exclusionNames=Arrays.asList(exclusionDirty.getStringList());
                }
 else {
                  exclusionNames=new ArrayList<String>();
                }
                UniqueIdentifier ore=GameRegistry.findUniqueIdentifierFor(oreStack.getItem());
                if (ore == null) {
                  return;
                }
                if (exclusionNames.contains(ore.modId + ""String_Node_Str"" + ore.name)) {
                  return;
                }
                ItemStack replacementStack=null;
                for (                ItemStack i1 : OreDictionary.getOres(oreID)) {
                  UniqueIdentifier item=GameRegistry.findUniqueIdentifierFor(i1.getItem());
                  if (item != null && !exclusionNames.contains(item.modId + ""String_Node_Str"" + item.name) && item.modId.contains(replacementName)) {
                    replacementStack=i1.copy();
                    break;
                  }
                }
                if (replacementStack != null) {
                  for (int i1=0; i1 < event.drops.size(); i1++) {
                    if (event.drops.get(i1) != null && event.drops.get(i1).isItemEqual(oreStack)) {
                      event.drops.set(i1,replacementStack);
                    }
                  }
                }
              }
            }
          }
        }
      }
 else {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}",0.933302347199628
37905,"public void init(ITimeSeriesModel timeSeries,String seriesTitle,int lowerRangeBoundary,int upperRangeBoundary,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  getLegendWidget().setVisible(false);
  getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainLabelPaint().setColor(Color.BLACK);
  getGraphWidget().getRangeLabelPaint().setColor(Color.BLACK);
  getGraphWidget().setRangeLabelWidth(30.0f);
  getGraphWidget().setDomainLabelWidth(20.0f);
  getGraphWidget().getGridBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getDomainGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getRangeGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getDomainOriginLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeOriginLinePaint().setColor(Color.GRAY);
  setBorderStyle(Plot.BorderStyle.SQUARE,null,null);
  getBorderPaint().setStrokeWidth(1);
  getBorderPaint().setAntiAlias(true);
  getBorderPaint().setColor(Color.WHITE);
  Paint lineFill=new Paint();
  lineFill.setAlpha(80);
  lineFill.setShader(new LinearGradient(0,0,0,gradientEndCoordinateY,gradientColorStart,gradientColorEnd,Shader.TileMode.MIRROR));
  LineAndPointFormatter formatter=new LineAndPointFormatter(lineAndPointColor,lineAndPointColor,Color.WHITE,null);
  formatter.setFillPaint(lineFill);
  XYTimeSeries series=new XYTimeSeries(timeSeries,seriesTitle);
  addSeries(series,formatter);
  setRangeBoundaries(lowerRangeBoundary,upperRangeBoundary,BoundaryMode.FIXED);
  setDomainStep(XYStepMode.SUBDIVIDE,10);
  setRangeStep(XYStepMode.SUBDIVIDE,11);
  getGraphWidget().getDomainLabelPaint().setTextSize(20);
  getGraphWidget().getRangeLabelPaint().setTextSize(20);
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(2);
  setRangeValueFormat(nf);
  setDomainValueFormat(new Format(){
    private SimpleDateFormat formatDay=new SimpleDateFormat(""String_Node_Str"");
    private SimpleDateFormat formatHour=new SimpleDateFormat(""String_Node_Str"");
    public StringBuffer format(    Object obj,    StringBuffer toAppendTo,    FieldPosition pos){
      long timestamp=((Number)obj).longValue();
      Date date=new Date(timestamp);
      return formatHour.format(date,toAppendTo,pos);
    }
    public Object parseObject(    String source,    ParsePosition pos){
      return null;
    }
  }
);
}","public void init(ITimeSeriesModel timeSeries,String seriesTitle,int lowerRangeBoundary,int upperRangeBoundary,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  getLegendWidget().setVisible(false);
  getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainLabelPaint().setColor(Color.BLACK);
  getGraphWidget().getRangeLabelPaint().setColor(Color.BLACK);
  getGraphWidget().setRangeLabelWidth(45.0f);
  getGraphWidget().setDomainLabelWidth(20.0f);
  getGraphWidget().getGridBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getDomainGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getRangeGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getDomainOriginLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeOriginLinePaint().setColor(Color.GRAY);
  setBorderStyle(Plot.BorderStyle.SQUARE,null,null);
  getBorderPaint().setStrokeWidth(1);
  getBorderPaint().setAntiAlias(true);
  getBorderPaint().setColor(Color.WHITE);
  Paint lineFill=new Paint();
  lineFill.setAlpha(80);
  lineFill.setShader(new LinearGradient(0,0,0,gradientEndCoordinateY,gradientColorStart,gradientColorEnd,Shader.TileMode.MIRROR));
  LineAndPointFormatter formatter=new LineAndPointFormatter(lineAndPointColor,lineAndPointColor,Color.WHITE,null);
  formatter.setFillPaint(lineFill);
  XYTimeSeries series=new XYTimeSeries(timeSeries,seriesTitle);
  addSeries(series,formatter);
  setRangeBoundaries(lowerRangeBoundary,upperRangeBoundary,BoundaryMode.FIXED);
  setDomainStep(XYStepMode.SUBDIVIDE,10);
  setRangeStep(XYStepMode.SUBDIVIDE,11);
  getGraphWidget().getDomainLabelPaint().setTextSize(20);
  getGraphWidget().getRangeLabelPaint().setTextSize(20);
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(1);
  setRangeValueFormat(nf);
  setDomainValueFormat(new Format(){
    private SimpleDateFormat formatDay=new SimpleDateFormat(""String_Node_Str"");
    private SimpleDateFormat formatHour=new SimpleDateFormat(""String_Node_Str"");
    public StringBuffer format(    Object obj,    StringBuffer toAppendTo,    FieldPosition pos){
      long timestamp=((Number)obj).longValue();
      Date date=new Date(timestamp);
      return formatHour.format(date,toAppendTo,pos);
    }
    public Object parseObject(    String source,    ParsePosition pos){
      return null;
    }
  }
);
}",0.9988649262202044
37906,"/** 
 * Enable notifications for soil moisture.
 * @param enable  true to enable, false to disable
 */
public void notifySoilMoisture(boolean enable){
  if (timerTaskNotifySoilMoisture != null) {
    timerTaskNotifySoilMoisture.cancel();
    timerTaskNotifySoilMoisture=null;
    timer.purge();
  }
  if (enable) {
    timerTaskNotifySoilMoisture=new TimerTask(){
      public void run(){
        readSoilMoisture();
      }
    }
;
    timer.schedule(timerTaskNotifySoilMoisture,0,1000);
  }
}","/** 
 * Enable notifications for soil moisture.
 * @param enable  true to enable, false to disable
 */
public void notifySoilMoisture(boolean enable){
  if (timerTaskNotifySoilMoisture != null) {
    timerTaskNotifySoilMoisture.cancel();
    timerTaskNotifySoilMoisture=null;
    timer.purge();
  }
  if (enable && isConnected()) {
    timerTaskNotifySoilMoisture=new TimerTask(){
      public void run(){
        readSoilMoisture();
      }
    }
;
    timer.schedule(timerTaskNotifySoilMoisture,0,1000);
  }
}",0.983084577114428
37907,"/** 
 * Enable notifications for temperature.
 * @param enable  true to enable, false to disable
 */
public void notifyTemperature(boolean enable){
  queue.enqueueNotify(getFlowerPowerService().getCharacteristic(UUID.fromString(FlowerPowerConstants.CHARACTERISTIC_UUID_TEMPERATURE)),enable);
}","/** 
 * Enable notifications for temperature.
 * @param enable  true to enable, false to disable
 */
public void notifyTemperature(boolean enable){
  if (isConnected())   queue.enqueueNotify(getFlowerPowerService().getCharacteristic(UUID.fromString(FlowerPowerConstants.CHARACTERISTIC_UUID_TEMPERATURE)),enable);
}",0.9654036243822076
37908,"/** 
 * Enable notifications for battery level.
 * @param enable  true to enable, false to disable
 */
public void notifyBatteryLevel(boolean enable){
  if (timerTaskNotifyBatteryLevel != null) {
    timerTaskNotifyBatteryLevel.cancel();
    timerTaskNotifyBatteryLevel=null;
    timer.purge();
  }
  if (enable) {
    timerTaskNotifyBatteryLevel=new TimerTask(){
      public void run(){
        readBatteryLevel();
      }
    }
;
    timer.schedule(timerTaskNotifyBatteryLevel,0,1000);
  }
}","/** 
 * Enable notifications for battery level.
 * @param enable  true to enable, false to disable
 */
public void notifyBatteryLevel(boolean enable){
  if (timerTaskNotifyBatteryLevel != null) {
    timerTaskNotifyBatteryLevel.cancel();
    timerTaskNotifyBatteryLevel=null;
    timer.purge();
  }
  if (enable && isConnected()) {
    timerTaskNotifyBatteryLevel=new TimerTask(){
      public void run(){
        readBatteryLevel();
      }
    }
;
    timer.schedule(timerTaskNotifyBatteryLevel,0,1000);
  }
}",0.983084577114428
37909,"/** 
 * Enable notifications for sunlight.
 * @param enable  true to enable, false to disable
 */
public void notifySunlight(boolean enable){
  queue.enqueueNotify(getFlowerPowerService().getCharacteristic(UUID.fromString(FlowerPowerConstants.CHARACTERISTIC_UUID_SUNLIGHT)),enable);
}","/** 
 * Enable notifications for sunlight.
 * @param enable  true to enable, false to disable
 */
public void notifySunlight(boolean enable){
  if (isConnected())   queue.enqueueNotify(getFlowerPowerService().getCharacteristic(UUID.fromString(FlowerPowerConstants.CHARACTERISTIC_UUID_SUNLIGHT)),enable);
}",0.9643463497453312
37910,"public synchronized void empty(){
  timestamps.clear();
  values.clear();
  lowestValue=-1999;
  highestValue=1999;
}","public synchronized void empty(){
  timestamps.clear();
  values.clear();
  lowestValue=1999;
  highestValue=-1999;
}",0.9914529914529916
37911,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  setContentView(R.layout.flowerpower_main);
  Intent intent=getIntent();
  final String deviceName=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME);
  final String deviceAddress=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_ADDRESS);
  getActionBar().setTitle(deviceName);
  final ImageButton graphButton=(ImageButton)findViewById(R.id.btn_graph);
  graphButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Intent i=new Intent(FlowerPowerActivity.this,FlowerPowerPlotActivity.class);
      i.putExtra(FlowerPowerConstants.EXTRAS_DEVICE_ADDRESS,deviceAddress);
      i.putExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME,deviceName);
      startActivity(i);
    }
  }
);
  final CheckBox checkBox=(CheckBox)findViewById(R.id.checkbox_notifications);
  checkBox.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + (checkBox.isChecked() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ serviceManager.isConnected());
      device.notifyTemperature(checkBox.isChecked());
      device.notifySunlight(checkBox.isChecked());
      device.notifySoilMoisture(checkBox.isChecked());
      device.notifyBatteryLevel(checkBox.isChecked());
      serviceManager.enablePersistency(5000,1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"");
    }
  }
);
  serviceManager=FlowerPowerServiceManager.getInstance(deviceAddress,this);
  IFlowerPowerServiceListener serviceListener=new IFlowerPowerServiceListener(){
    public void deviceDiscovered(    BluetoothDeviceModel device){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + device);
    }
    public void deviceConnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      invalidateOptionsMenu();
      serviceManager.enableAutoConnect(1000 * 60 * 10);
    }
    public void deviceDisconnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      invalidateOptionsMenu();
      ((CheckBox)findViewById(R.id.checkbox_notifications)).setEnabled(false);
      FlowerPowerActivity.this.device=null;
    }
    public void deviceReady(    IFlowerPowerDevice device){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      ((CheckBox)findViewById(R.id.checkbox_notifications)).setEnabled(true);
      FlowerPowerActivity.this.device=device;
      device.readSystemId();
      device.readModelNr();
      device.readSerialNr();
      device.readFirmwareRevision();
      device.readHardwareRevision();
      device.readSoftwareRevision();
      device.readManufacturerName();
      device.readCertData();
      device.readPnpId();
      device.readFriendlyName();
      device.readColor();
      device.readBatteryLevel();
      device.readTemperature();
      device.readSunlight();
      device.readSoilMoisture();
    }
    public void dataAvailable(    FlowerPower fp){
      updateUI(fp);
    }
    public void serviceConnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
    }
    public void serviceDisconnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
    }
    public void serviceFailed(    RuntimeException exc){
      exc.printStackTrace();
      Log.e(FlowerPowerConstants.TAG,""String_Node_Str"");
      finish();
    }
  }
;
  serviceManager.addServiceListener(serviceListener);
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  serviceManager.bind();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  setContentView(R.layout.flowerpower_main);
  Intent intent=getIntent();
  final String deviceName=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME);
  final String deviceAddress=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_ADDRESS);
  getActionBar().setTitle(deviceName);
  final ImageButton graphButton=(ImageButton)findViewById(R.id.btn_graph);
  graphButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Intent i=new Intent(FlowerPowerActivity.this,FlowerPowerPlotActivity.class);
      i.putExtra(FlowerPowerConstants.EXTRAS_DEVICE_ADDRESS,deviceAddress);
      i.putExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME,deviceName);
      startActivity(i);
    }
  }
);
  final CheckBox checkBox=(CheckBox)findViewById(R.id.checkbox_notifications);
  checkBox.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + (checkBox.isChecked() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ serviceManager.isConnected());
      device.notifyTemperature(checkBox.isChecked());
      device.notifySunlight(checkBox.isChecked());
      device.notifySoilMoisture(checkBox.isChecked());
      device.notifyBatteryLevel(checkBox.isChecked());
      serviceManager.enablePersistency(5000,1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"");
      serviceManager.enableReconnect(60000);
    }
  }
);
  serviceManager=FlowerPowerServiceManager.getInstance(deviceAddress,this);
  IFlowerPowerServiceListener serviceListener=new IFlowerPowerServiceListener(){
    public void deviceDiscovered(    BluetoothDeviceModel device){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + device);
    }
    public void deviceConnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      invalidateOptionsMenu();
      serviceManager.enableReconnect(1000 * 60 * 10);
    }
    public void deviceDisconnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      invalidateOptionsMenu();
      ((CheckBox)findViewById(R.id.checkbox_notifications)).setEnabled(false);
      FlowerPowerActivity.this.device=null;
    }
    public void deviceReady(    IFlowerPowerDevice device){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
      ((CheckBox)findViewById(R.id.checkbox_notifications)).setEnabled(true);
      FlowerPowerActivity.this.device=device;
      device.readSystemId();
      device.readModelNr();
      device.readSerialNr();
      device.readFirmwareRevision();
      device.readHardwareRevision();
      device.readSoftwareRevision();
      device.readManufacturerName();
      device.readCertData();
      device.readPnpId();
      device.readFriendlyName();
      device.readColor();
      device.readBatteryLevel();
      device.readTemperature();
      device.readSunlight();
      device.readSoilMoisture();
    }
    public void dataAvailable(    FlowerPower fp){
      updateUI(fp);
    }
    public void serviceConnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
    }
    public void serviceDisconnected(){
      Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
    }
    public void serviceFailed(    RuntimeException exc){
      exc.printStackTrace();
      Log.e(FlowerPowerConstants.TAG,""String_Node_Str"");
      finish();
    }
  }
;
  serviceManager.addServiceListener(serviceListener);
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  serviceManager.bind();
}",0.9927227790745572
37912,"public void onClick(View v){
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + (checkBox.isChecked() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ serviceManager.isConnected());
  device.notifyTemperature(checkBox.isChecked());
  device.notifySunlight(checkBox.isChecked());
  device.notifySoilMoisture(checkBox.isChecked());
  device.notifyBatteryLevel(checkBox.isChecked());
  serviceManager.enablePersistency(5000,1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"");
}","public void onClick(View v){
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"" + (checkBox.isChecked() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ serviceManager.isConnected());
  device.notifyTemperature(checkBox.isChecked());
  device.notifySunlight(checkBox.isChecked());
  device.notifySoilMoisture(checkBox.isChecked());
  device.notifyBatteryLevel(checkBox.isChecked());
  serviceManager.enablePersistency(5000,1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"");
  serviceManager.enableReconnect(60000);
}",0.9621421975992612
37913,"public void deviceConnected(){
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  invalidateOptionsMenu();
  serviceManager.enableAutoConnect(1000 * 60 * 10);
}","public void deviceConnected(){
  Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
  invalidateOptionsMenu();
  serviceManager.enableReconnect(1000 * 60 * 10);
}",0.9754601226993864
37914,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.flowerpower_plot);
  Intent intent=getIntent();
  final String deviceName=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME);
  getActionBar().setTitle(deviceName);
  FlowerPowerPlotFragment fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_temperature);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_TEMPERATURE,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",-10,55,Color.RED,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
  fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_sunlight);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_SUNLIGHT,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",0,50,Color.YELLOW,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
  fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_soilmoisture);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_SOILMOISTURE,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",0,60,Color.GREEN,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.flowerpower_plot);
  Intent intent=getIntent();
  final String deviceName=intent.getStringExtra(FlowerPowerConstants.EXTRAS_DEVICE_NAME);
  getActionBar().setTitle(deviceName);
  FlowerPowerPlotFragment fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_temperature);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_TEMPERATURE,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",Color.RED,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
  fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_sunlight);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_SUNLIGHT,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",Color.YELLOW,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
  fragment=(FlowerPowerPlotFragment)getFragmentManager().findFragmentById(R.id.frag_soilmoisture);
  fragment.init(PersistencyManager.TIMESERIES_TYPE_SOILMOISTURE,""String_Node_Str"",1000,FlowerPowerConstants.PERSISTENCY_STORAGE_LOCATION_INTERNAL,""String_Node_Str"",Color.GREEN,Color.WHITE,200,Color.parseColor(""String_Node_Str""));
}",0.9935238095238096
37915,"/** 
 * Initialize this fragment with time series data and visualization options.
 * @param seriesType  The type of the time series as specified by the PersistencyManager (e.g. PersistencyManager.TIMESERIES_TYPE_TEMPERATURE)
 * @param seriesId  The individual Id of the time series to display
 * @param maxHistorySize  The max. history size (required for loading or creating a time series)
 * @param storageLocation  The location where the history is stored (required for loading a time series)
 * @param plotTitle  The title that shall be shown above the plot
 * @param plotLowerRangeBounday  The lower boundary of possible values
 * @param plotUpperRangeBoundary  The upper boundary of possible values
 * @param gradientColorStart  The start color of the gradient to fill the plot
 * @param gradientColorEnd  The end color of the gradient to fill the plot
 * @param gradientEndCoordinateY  The pixel y-index where the color gradient shall end (and be mirrored)
 * @param lineAndPointColor  The color of the line and all points
 */
public void init(String seriesType,String seriesId,int maxHistorySize,String storageLocation,String plotTitle,int plotLowerRangeBounday,int plotUpperRangeBoundary,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  this.seriesType=seriesType;
  this.seriesId=seriesId;
  this.maxHistorySize=maxHistorySize;
  this.storageLocation=storageLocation;
  PersistencyManager pm=PersistencyManager.getInstance(getActivity());
  try {
    timeSeries=pm.load(maxHistorySize,storageLocation,seriesType,seriesId);
  }
 catch (  Exception e) {
    timeSeries=pm.create(maxHistorySize,storageLocation,seriesType,seriesId);
    e.printStackTrace();
  }
  TextView title=(TextView)getView().findViewById(R.id.plot_title);
  title.setText(plotTitle);
  plot=(XYTimeSeriesPlot)getView().findViewById(R.id.plot);
  plot.init(timeSeries,plotTitle,plotLowerRangeBounday,plotUpperRangeBoundary,gradientColorStart,gradientColorEnd,gradientEndCoordinateY,lineAndPointColor);
}","/** 
 * Initialize this fragment with time series data and visualization options.
 * @param seriesType  The type of the time series as specified by the PersistencyManager (e.g. PersistencyManager.TIMESERIES_TYPE_TEMPERATURE)
 * @param seriesId  The individual Id of the time series to display
 * @param maxHistorySize  The max. history size (required for loading or creating a time series)
 * @param storageLocation  The location where the history is stored (required for loading a time series)
 * @param plotTitle  The title that shall be shown above the plot
 * @param gradientColorStart  The start color of the gradient to fill the plot
 * @param gradientColorEnd  The end color of the gradient to fill the plot
 * @param gradientEndCoordinateY  The pixel y-index where the color gradient shall end (and be mirrored)
 * @param lineAndPointColor  The color of the line and all points
 */
public void init(String seriesType,String seriesId,int maxHistorySize,String storageLocation,String plotTitle,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  this.seriesType=seriesType;
  this.seriesId=seriesId;
  this.maxHistorySize=maxHistorySize;
  this.storageLocation=storageLocation;
  PersistencyManager pm=PersistencyManager.getInstance(getActivity());
  try {
    timeSeries=pm.load(maxHistorySize,storageLocation,seriesType,seriesId);
  }
 catch (  Exception e) {
    timeSeries=pm.create(maxHistorySize,storageLocation,seriesType,seriesId);
    e.printStackTrace();
  }
  TextView title=(TextView)getView().findViewById(R.id.plot_title);
  title.setText(plotTitle);
  plot=(XYTimeSeriesPlot)getView().findViewById(R.id.plot);
  plot.init(timeSeries,plotTitle,(int)(timeSeries.getLowestValue() - (timeSeries.getLowestValue() / 10)),(int)(timeSeries.getHighestValue() + (timeSeries.getHighestValue() / 10)),gradientColorStart,gradientColorEnd,gradientEndCoordinateY,lineAndPointColor);
}",0.9064312736443884
37916,"public void dataAvailable(FlowerPower fp){
  try {
    if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_TEMPERATURE))     timeSeries.addMeasurement(fp.getTemperatureTimestamp(),(float)fp.getTemperature());
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_SUNLIGHT))     timeSeries.addMeasurement(fp.getSunlightTimestamp(),(float)fp.getSunlight());
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_SOILMOISTURE))     timeSeries.addMeasurement(fp.getSoilMoistureTimestamp(),(float)fp.getSoilMoisture());
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_BATTERY))     timeSeries.addMeasurement(fp.getBatteryLevelTimestamp(),(float)fp.getBatteryLevelTimestamp());
 else     Log.w(FlowerPowerConstants.TAG,""String_Node_Str"" + seriesType + ""String_Node_Str"");
    plot.redraw();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void dataAvailable(FlowerPower fp){
  float oldLowest=timeSeries.getLowestValue();
  float oldHighest=timeSeries.getHighestValue();
  try {
    if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_TEMPERATURE)) {
      if (fp.getTemperature() != -1)       timeSeries.addMeasurement(fp.getTemperatureTimestamp(),(float)fp.getTemperature());
    }
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_SUNLIGHT)) {
      if (fp.getSunlight() >= 0)       timeSeries.addMeasurement(fp.getSunlightTimestamp(),(float)fp.getSunlight());
    }
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_SOILMOISTURE)) {
      if (fp.getSoilMoisture() >= 0)       timeSeries.addMeasurement(fp.getSoilMoistureTimestamp(),(float)fp.getSoilMoisture());
    }
 else     if (seriesType.equals(PersistencyManager.TIMESERIES_TYPE_BATTERY)) {
      if (fp.getBatteryLevel() >= 0)       timeSeries.addMeasurement(fp.getBatteryLevelTimestamp(),(float)fp.getBatteryLevelTimestamp());
    }
 else     Log.w(FlowerPowerConstants.TAG,""String_Node_Str"" + seriesType + ""String_Node_Str"");
    if ((timeSeries.getLowestValue() != oldLowest) || (timeSeries.getHighestValue() != oldHighest))     plot.setRangeBoundaries(timeSeries.getLowestValue() - (timeSeries.getLowestValue() / 10),timeSeries.getHighestValue() + (timeSeries.getHighestValue() / 10),BoundaryMode.FIXED);
    plot.redraw();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.6956151553852703
37917,"public void init(ITimeSeriesModel timeSeries,String seriesTitle,int lowerRangeBoundary,int upperRangeBoundary,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  getLegendWidget().setVisible(false);
  getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainLabelPaint().setColor(Color.BLACK);
  getGraphWidget().getRangeLabelPaint().setColor(Color.BLACK);
  getGraphWidget().setRangeLabelWidth(30.0f);
  getGraphWidget().setDomainLabelWidth(20.0f);
  getGraphWidget().getGridBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getDomainGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getRangeGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getDomainOriginLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeOriginLinePaint().setColor(Color.GRAY);
  setBorderStyle(Plot.BorderStyle.SQUARE,null,null);
  getBorderPaint().setStrokeWidth(1);
  getBorderPaint().setAntiAlias(true);
  getBorderPaint().setColor(Color.WHITE);
  Paint lineFill=new Paint();
  lineFill.setAlpha(80);
  lineFill.setShader(new LinearGradient(0,0,0,gradientEndCoordinateY,gradientColorStart,gradientColorEnd,Shader.TileMode.MIRROR));
  LineAndPointFormatter formatter=new LineAndPointFormatter(lineAndPointColor,lineAndPointColor,Color.WHITE,null);
  formatter.setFillPaint(lineFill);
  XYTimeSeries series=new XYTimeSeries(timeSeries,seriesTitle);
  addSeries(series,formatter);
  setRangeBoundaries(lowerRangeBoundary,upperRangeBoundary,BoundaryMode.FIXED);
  setDomainStep(XYStepMode.SUBDIVIDE,10);
  setRangeStep(XYStepMode.SUBDIVIDE,11);
  getGraphWidget().getDomainLabelPaint().setTextSize(20);
  getGraphWidget().getRangeLabelPaint().setTextSize(20);
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(2);
  setRangeValueFormat(nf);
  setDomainValueFormat(new Format(){
    private SimpleDateFormat formatDay=new SimpleDateFormat(""String_Node_Str"");
    private SimpleDateFormat formatHour=new SimpleDateFormat(""String_Node_Str"");
    public StringBuffer format(    Object obj,    StringBuffer toAppendTo,    FieldPosition pos){
      long timestamp=((Number)obj).longValue();
      Date date=new Date(timestamp);
      return formatHour.format(date,toAppendTo,pos);
    }
    public Object parseObject(    String source,    ParsePosition pos){
      return null;
    }
  }
);
}","public void init(ITimeSeriesModel timeSeries,String seriesTitle,int lowerRangeBoundary,int upperRangeBoundary,int gradientColorStart,int gradientColorEnd,int gradientEndCoordinateY,int lineAndPointColor){
  getLegendWidget().setVisible(false);
  getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainLabelPaint().setColor(Color.BLACK);
  getGraphWidget().getRangeLabelPaint().setColor(Color.BLACK);
  getGraphWidget().setRangeLabelWidth(45.0f);
  getGraphWidget().setDomainLabelWidth(20.0f);
  getGraphWidget().getGridBackgroundPaint().setColor(Color.WHITE);
  getGraphWidget().getDomainGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeGridLinePaint().setColor(Color.GRAY);
  getGraphWidget().getDomainGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getRangeGridLinePaint().setPathEffect(new DashPathEffect(new float[]{1,1},1));
  getGraphWidget().getDomainOriginLinePaint().setColor(Color.GRAY);
  getGraphWidget().getRangeOriginLinePaint().setColor(Color.GRAY);
  setBorderStyle(Plot.BorderStyle.SQUARE,null,null);
  getBorderPaint().setStrokeWidth(1);
  getBorderPaint().setAntiAlias(true);
  getBorderPaint().setColor(Color.WHITE);
  Paint lineFill=new Paint();
  lineFill.setAlpha(80);
  lineFill.setShader(new LinearGradient(0,0,0,gradientEndCoordinateY,gradientColorStart,gradientColorEnd,Shader.TileMode.MIRROR));
  LineAndPointFormatter formatter=new LineAndPointFormatter(lineAndPointColor,lineAndPointColor,Color.WHITE,null);
  formatter.setFillPaint(lineFill);
  XYTimeSeries series=new XYTimeSeries(timeSeries,seriesTitle);
  addSeries(series,formatter);
  setRangeBoundaries(lowerRangeBoundary,upperRangeBoundary,BoundaryMode.FIXED);
  setDomainStep(XYStepMode.SUBDIVIDE,8);
  setRangeStep(XYStepMode.SUBDIVIDE,11);
  getGraphWidget().getDomainLabelPaint().setTextSize(20);
  getGraphWidget().getRangeLabelPaint().setTextSize(20);
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(1);
  setRangeValueFormat(nf);
  setDomainValueFormat(new Format(){
    private SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    public StringBuffer format(    Object obj,    StringBuffer toAppendTo,    FieldPosition pos){
      long timestamp=((Number)obj).longValue();
      Date date=new Date(timestamp);
      return format.format(date,toAppendTo,pos);
    }
    public Object parseObject(    String source,    ParsePosition pos){
      return null;
    }
  }
);
}",0.9813353857994996
37918,"public StringBuffer format(Object obj,StringBuffer toAppendTo,FieldPosition pos){
  long timestamp=((Number)obj).longValue();
  Date date=new Date(timestamp);
  return formatHour.format(date,toAppendTo,pos);
}","public StringBuffer format(Object obj,StringBuffer toAppendTo,FieldPosition pos){
  long timestamp=((Number)obj).longValue();
  Date date=new Date(timestamp);
  return format.format(date,toAppendTo,pos);
}",0.9903381642512076
37919,"public synchronized void addDataSet(FlowerPower fp,String seriesId) throws Exception {
  if ((fp.getBatteryLevelTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_BATTERY,seriesId)) {
    seriesToBePersisted.get(TIMESERIES_TYPE_BATTERY + ""String_Node_Str"" + seriesId).addMeasurement(fp.getBatteryLevelTimestamp(),(float)fp.getBatteryLevel());
  }
  if ((fp.getTemperatureTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_TEMPERATURE,seriesId)) {
    seriesToBePersisted.get(TIMESERIES_TYPE_TEMPERATURE + ""String_Node_Str"" + seriesId).addMeasurement(fp.getTemperatureTimestamp(),(float)fp.getTemperature());
  }
  if ((fp.getSunlightTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_SUNLIGHT,seriesId)) {
    seriesToBePersisted.get(TIMESERIES_TYPE_SUNLIGHT + ""String_Node_Str"" + seriesId).addMeasurement(fp.getSunlightTimestamp(),(float)fp.getSunlight());
  }
  if ((fp.getSoilMoistureTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_SOILMOISTURE,seriesId)) {
    seriesToBePersisted.get(TIMESERIES_TYPE_SOILMOISTURE + ""String_Node_Str"" + seriesId).addMeasurement(fp.getSoilMoistureTimestamp(),(float)fp.getSoilMoisture());
  }
}","public synchronized void addDataSet(FlowerPower fp,String seriesId) throws Exception {
  if ((fp.getBatteryLevelTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_BATTERY,seriesId)) {
    if (fp.getBatteryLevel() >= 0)     seriesToBePersisted.get(TIMESERIES_TYPE_BATTERY + ""String_Node_Str"" + seriesId).addMeasurement(fp.getBatteryLevelTimestamp(),(float)fp.getBatteryLevel());
  }
  if ((fp.getTemperatureTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_TEMPERATURE,seriesId)) {
    if (fp.getTemperature() != -1)     seriesToBePersisted.get(TIMESERIES_TYPE_TEMPERATURE + ""String_Node_Str"" + seriesId).addMeasurement(fp.getTemperatureTimestamp(),(float)fp.getTemperature());
  }
  if ((fp.getSunlightTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_SUNLIGHT,seriesId)) {
    if (fp.getSunlight() >= 0)     seriesToBePersisted.get(TIMESERIES_TYPE_SUNLIGHT + ""String_Node_Str"" + seriesId).addMeasurement(fp.getSunlightTimestamp(),(float)fp.getSunlight());
  }
  if ((fp.getSoilMoistureTimestamp() > 0) && isEnabled(TIMESERIES_TYPE_SOILMOISTURE,seriesId)) {
    if (fp.getSoilMoisture() >= 0)     seriesToBePersisted.get(TIMESERIES_TYPE_SOILMOISTURE + ""String_Node_Str"" + seriesId).addMeasurement(fp.getSoilMoistureTimestamp(),(float)fp.getSoilMoisture());
  }
}",0.9424216765453006
37920,"public void enableReconnect(long period){
  timerReconnect=new Timer();
  timerTaskReconnect=new TimerTask(){
    public void run(){
      if (!isConnected()) {
        Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
        connect(bluetoothDeviceAddress);
        timerReconnect.schedule(new TimerTask(){
          public void run(){
            Log.d(FlowerPowerConstants.TAG,""String_Node_Str"");
            if (notifyBatteryLevel)             notifyBatteryLevel(true);
            if (notifyTemperature)             notifyTemperature(true);
            if (notifySoilMoisture)             notifySoilMoisture(true);
            if (notifySunlight)             notifySunlight(true);
          }
        }
,10000);
      }
    }
  }
;
  timerReconnect.schedule(timerTaskReconnect,period,period);
}","/** 
 * Enables reconnect. If the bluetooth device is out of reach, then an automatic reconnect is tried periodically
 * @param period  Period in ms.
 */
public void enableReconnect(final long period){
  timerReconnect=new Timer();
  timerTaskReconnect=new TimerTask(){
    public void run(){
      if (!isConnected()) {
        Log.i(FlowerPowerConstants.TAG,""String_Node_Str"");
        connect(bluetoothDeviceAddress);
        timerReconnect.schedule(new TimerTask(){
          public void run(){
            Log.d(FlowerPowerConstants.TAG,""String_Node_Str"");
            if (notifyBatteryLevel)             notifyBatteryLevel(true);
            if (notifyTemperature)             notifyTemperature(true);
            if (notifySoilMoisture)             notifySoilMoisture(true);
            if (notifySunlight)             notifySunlight(true);
          }
        }
,period);
      }
    }
  }
;
  timerReconnect.schedule(timerTaskReconnect,period,period);
}",0.8893930799773114
37921,"public synchronized void enqueueNotify(BluetoothGattCharacteristic chara,boolean enable){
  QueueJob job=new QueueJob(chara,QueueJob.JOB_TYPE_NOTIFY,enable);
  if (!isContained(job))   queue.offer(job);
  if (queue.size() == 1)   service.notify(chara,enable);
}","public synchronized void enqueueNotify(BluetoothGattCharacteristic chara,boolean enable){
  Log.d(FlowerPowerConstants.TAG,""String_Node_Str"" + queue.size() + ""String_Node_Str""+ chara+ ""String_Node_Str"");
  QueueJob job=new QueueJob(chara,QueueJob.JOB_TYPE_NOTIFY,enable);
  if (!isContained(job))   queue.offer(job);
  if (queue.size() == 1)   service.notify(chara,enable);
}",0.8207547169811321
37922,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  QueueJob other=(QueueJob)obj;
  if (!getOuterType().equals(other.getOuterType()))   return false;
  if (chara == null) {
    if (other.chara != null)     return false;
  }
 else   if (!chara.equals(other.chara))   return false;
  if (enable != other.enable)   return false;
  if (jobType != other.jobType)   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  QueueJob other=(QueueJob)obj;
  if (!getOuterType().equals(other.getOuterType()))   return false;
  if (chara == null) {
    if (other.chara != null)     return false;
  }
 else   if (!chara.getUuid().equals(other.chara.getUuid()))   return false;
  if (enable != other.enable)   return false;
  if (jobType != other.jobType)   return false;
  return true;
}",0.9806201550387597
37923,"/** 
 * Get some content stored on the JSocialKademliaDHT
 * @param param The parameters used to search for the content
 * @return DHTContent The content
 * @throws java.io.IOException
 * @throws kademlia.exceptions.ContentNotFoundException
 */
@Override public JSocialKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException, ContentNotFoundException {
  if (this.dht.contains(param)) {
    JSocialKademliaStorageEntry e=this.dht.get(param);
    if (e.getContentMetadata().isKNode()) {
      return this.decompressStorageEntry(e);
    }
 else     if (e.getContentMetadata().isCached()) {
      GetParameterFUC gpf=new GetParameterFUC(e.getContentMetadata());
      try {
        return this.decompressStorageEntry(this.getUpdated(gpf));
      }
 catch (      UpToDateContentException ex) {
        return this.decompressStorageEntry(e);
      }
    }
 else {
      return this.decompressStorageEntry(e);
    }
  }
  long startTime=System.nanoTime();
  ContentLookupOperation clo=new ContentLookupOperation(server,this,param,this.config);
  clo.execute();
  long endTime=System.nanoTime();
  this.statistician.addContentLookup(endTime - startTime,clo.routeLength(),clo.isContentFound());
  return this.decompressStorageEntry(clo.getContentFound());
}","/** 
 * Get some content stored on the JSocialKademliaDHT
 * @param param The parameters used to search for the content
 * @return DHTContent The content
 * @throws java.io.IOException
 * @throws kademlia.exceptions.ContentNotFoundException
 */
@Override public JSocialKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException, ContentNotFoundException {
  if (this.dht.contains(param)) {
    JSocialKademliaStorageEntry e=this.dht.get(param);
    if (e.getContentMetadata().isCached()) {
      GetParameterFUC gpf=new GetParameterFUC(e.getContentMetadata());
      try {
        return this.decompressStorageEntry(this.getUpdated(gpf));
      }
 catch (      UpToDateContentException ex) {
        return this.decompressStorageEntry(e);
      }
    }
 else     if (e.getContentMetadata().isKNode()) {
      return this.decompressStorageEntry(e);
    }
 else {
      return this.decompressStorageEntry(e);
    }
  }
  long startTime=System.nanoTime();
  ContentLookupOperation clo=new ContentLookupOperation(server,this,param,this.config);
  clo.execute();
  long endTime=System.nanoTime();
  this.statistician.addContentLookup(endTime - startTime,clo.routeLength(),clo.isContentFound());
  return this.decompressStorageEntry(clo.getContentFound());
}",0.7548790007806401
37924,"@Override public void remove(SocialKademliaStorageEntryMetadata entry) throws ContentNotFoundException {
  if (this.contentManager.get(entry).isCached()) {
    this.contentManager.get(entry).setKNode(false);
    return;
  }
  String folder=this.getContentStorageFolderName(entry.getKey());
  File file=new File(folder + File.separator + entry.hashCode()+ ""String_Node_Str"");
  contentManager.remove(entry);
  if (file.exists()) {
    file.delete();
  }
 else {
    throw new ContentNotFoundException();
  }
}","@Override public void remove(SocialKademliaStorageEntryMetadata entry) throws ContentNotFoundException {
  if (this.contentManager.get(entry).isCached()) {
    this.contentManager.get(entry).setKNode(false);
    return;
  }
  this.absoluteRemove(entry);
}",0.6055045871559633
37925,"/** 
 * @return List A List of all Nodes in this RoutingTable
 */
@Override public final List getAllNodes(){
  List<Node> nodes=new ArrayList<>();
  for (  KadBucket b : this.buckets) {
    for (    Contact c : b.getContacts()) {
      nodes.add(c.getNode());
    }
  }
  return nodes;
}","/** 
 * @return List A List of all Nodes in this RoutingTable
 */
@Override public synchronized final List getAllNodes(){
  List<Node> nodes=new ArrayList<>();
  for (  KadBucket b : this.buckets) {
    for (    Contact c : b.getContacts()) {
      nodes.add(c.getNode());
    }
  }
  return nodes;
}",0.9778534923339012
37926,"/** 
 * Update a content; the operation is only done iff we already have a copy of the content here
 */
public void update(StorageEntry newContent){
  if (this.contentManager.contains(newContent.getContentMetadata())) {
    this.store(newContent);
  }
 else {
    throw new NoSuchElementException(""String_Node_Str"");
  }
}","/** 
 * Update a content; the operation is only done iff we already have a copy of the content here
 */
public void update(StorageEntry newContent) throws IOException {
  if (this.contentManager.contains(newContent.getContentMetadata())) {
    this.store(newContent);
  }
 else {
    throw new NoSuchElementException(""String_Node_Str"");
  }
}",0.9698795180722892
37927,"public static void main(String[] args){
  try {
    Kademlia kad1=new Kademlia(""String_Node_Str"",new NodeId(""String_Node_Str""),7574);
    Kademlia kad2=new Kademlia(""String_Node_Str"",new NodeId(""String_Node_Str""),7572);
    DHTContentImpl c1=new DHTContentImpl(kad2.getOwnerId(),""String_Node_Str"");
    DHTContentImpl c2=new DHTContentImpl(kad2.getOwnerId(),""String_Node_Str"");
    kad2.bootstrap(kad1.getNode());
    kad1.put(c1);
    kad1.put(c2);
    for (long i=0; i < 9999990000L; i++) {
    }
    System.out.println(""String_Node_Str"");
    long c2OldTs=c2.getLastUpdatedTimestamp();
    c2.setData(""String_Node_Str"");
    kad1.putLocally(c2);
    try {
      System.out.println(""String_Node_Str"");
      GetParameterFUC gp=new GetParameterFUC(c1.getKey(),DHTContentImpl.TYPE,c1.getOwnerId(),c1.getLastUpdatedTimestamp());
      List<StorageEntry> conte=kad2.getUpdated(gp,4);
      for (      StorageEntry cc : conte) {
        System.out.println(""String_Node_Str"" + new DHTContentImpl().fromBytes(cc.getContent().getBytes()));
        System.out.println(""String_Node_Str"" + cc.getContentMetadata());
      }
    }
 catch (    IOException|UpToDateContentException ex) {
      System.err.println(ex.getMessage());
    }
    try {
      System.out.println(""String_Node_Str"");
      GetParameterFUC gp=new GetParameterFUC(c2.getKey(),DHTContentImpl.TYPE,c2.getOwnerId(),c2OldTs);
      List<StorageEntry> conte=kad2.getUpdated(gp,4);
      for (      StorageEntry cc : conte) {
        System.out.println(""String_Node_Str"" + new DHTContentImpl().fromBytes(cc.getContent().getBytes()));
        System.out.println(""String_Node_Str"" + cc.getContentMetadata());
      }
    }
 catch (    IOException|UpToDateContentException ex) {
      System.err.println(ex.getMessage());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  try {
    Kademlia kad1=new Kademlia(""String_Node_Str"",new NodeId(""String_Node_Str""),7574);
    Kademlia kad2=new Kademlia(""String_Node_Str"",new NodeId(""String_Node_Str""),7572);
    DHTContentImpl c1=new DHTContentImpl(kad2.getOwnerId(),""String_Node_Str"");
    DHTContentImpl c2=new DHTContentImpl(kad2.getOwnerId(),""String_Node_Str"");
    kad2.bootstrap(kad1.getNode());
    kad1.put(c1);
    kad1.put(c2);
    for (long i=0; i < 9999990000L; i++) {
    }
    System.out.println(""String_Node_Str"");
    long c2OldTs=c2.getLastUpdatedTimestamp();
    c2.setData(""String_Node_Str"");
    kad1.putLocally(c2);
    try {
      System.out.println(""String_Node_Str"");
      GetParameterFUC gp=new GetParameterFUC(c1.getKey(),DHTContentImpl.TYPE,c1.getOwnerId(),c1.getLastUpdatedTimestamp());
      StorageEntry conte=kad2.getUpdated(gp,4);
      System.out.println(""String_Node_Str"" + new DHTContentImpl().fromBytes(conte.getContent().getBytes()));
      System.out.println(""String_Node_Str"" + conte.getContentMetadata());
    }
 catch (    IOException|UpToDateContentException ex) {
      System.err.println(ex.getMessage());
    }
    try {
      System.out.println(""String_Node_Str"");
      GetParameterFUC gp=new GetParameterFUC(c2.getKey(),DHTContentImpl.TYPE,c2.getOwnerId(),c2OldTs);
      StorageEntry conte=kad2.getUpdated(gp,4);
      System.out.println(""String_Node_Str"" + new DHTContentImpl().fromBytes(conte.getContent().getBytes()));
      System.out.println(""String_Node_Str"" + conte.getContentMetadata());
    }
 catch (    IOException|UpToDateContentException ex) {
      System.err.println(ex.getMessage());
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9596638655462184
37928,"private void call(final UDPCallback callback,final Object... args){
  loop.callbackHandler.handleUDPCallback(onRecv,args);
}","private void call(final UDPCallback callback,final Object... args){
  loop.callbackHandler.handleUDPCallback(callback,args);
}",0.952
37929,"public static void main(final String[] args) throws Exception {
  final CheckHandleTest test=new CheckHandleTest();
  test.testCheck();
}","public static void main(final String[] args) throws Exception {
  final IdleHandleTest test=new IdleHandleTest();
  test.testIdle();
}",0.922509225092251
37930,"/** 
 * Contains the main event loop that drives the game. This method will not  return until   {@link LanternaFrontend#shutdown} is called.
 */
final void doStartup(){
  Vec2i screenSize=getSize();
  System.out.print(""String_Node_Str"" + screenSize.y + ""String_Node_Str""+ screenSize.x+ ""String_Node_Str"");
  Screen screen=TerminalFacade.createScreen();
  screen.startScreen();
{
    TerminalSize size=screen.getTerminalSize();
    onResize(new Vec2i(size.getColumns(),size.getRows()));
  }
  long time=new Date().getTime();
  while (running) {
    try {
      if (screen.resizePending()) {
        screen.refresh();
        TerminalSize size=screen.getTerminalSize();
        onResize(new Vec2i(size.getColumns(),size.getRows()));
      }
      screen.clear();
      onDraw(new Section(screen,new Vec2i(0,0),screenSize));
      screen.refresh();
      Key key=screen.readInput();
      if (key != null)       onKeyPressed(key);
      long currentTime=new Date().getTime();
      onTick(currentTime - time);
      time=currentTime;
    }
 catch (    Exception e) {
    }
  }
  screen.stopScreen();
}","/** 
 * Contains the main event loop that drives the game. This method will not  return until   {@link LanternaFrontend#shutdown} is called.
 */
final void doStartup(){
  Vec2i screenSize=getSize();
  if (isTTY)   System.out.print(""String_Node_Str"" + screenSize.y + ""String_Node_Str""+ screenSize.x+ ""String_Node_Str"");
  Screen screen=TerminalFacade.createScreen();
  screen.startScreen();
{
    TerminalSize size=screen.getTerminalSize();
    onResize(new Vec2i(size.getColumns(),size.getRows()));
  }
  long time=new Date().getTime();
  while (running) {
    try {
      if (screen.resizePending()) {
        screen.refresh();
        TerminalSize size=screen.getTerminalSize();
        onResize(new Vec2i(size.getColumns(),size.getRows()));
      }
      screen.clear();
      onDraw(new Section(screen,new Vec2i(0,0),screenSize));
      screen.refresh();
      Key key=screen.readInput();
      if (key != null)       onKeyPressed(key);
      long currentTime=new Date().getTime();
      onTick(currentTime - time);
      time=currentTime;
    }
 catch (    NullPointerException e) {
    }
  }
  screen.stopScreen();
}",0.9891891891891892
37931,"@Override public Vec2i getSize(){
  return new Vec2i(80,30);
}","@Override public Vec2i getSize(){
  return new Vec2i(100,30);
}",0.976
37932,"public GUIApp(Arguments args){
  super(""String_Node_Str"");
  configDir=args.getConfig();
}","public GUIApp(Arguments args){
  super(""String_Node_Str"");
  configDir=args.getConfig();
  isTTY=args.getTty();
  if (isTTY)   System.setProperty(""String_Node_Str"",""String_Node_Str"");
}",0.6545454545454545
37933,"int getRandom(int min,int max){
  return min + getRandom(max - min + 1);
}","public int getRandom(int min,int max){
  return min + getRandom(max - min + 1);
}",0.9548387096774194
37934,"private Action getAction(){
  Level l=me.getLevel();
  List<EntityActionManager> players=l.getManager().getEntity(""String_Node_Str"");
  if (players.size() == 0) {
    return new Move(0,me,Direction.RIGHT);
  }
  EntityActionManager player=players.get(0);
  Tile myTile=me.getLocation();
  Tile playerTile=player.getEntity().getLocation();
  AStar<Tile> pathfinder=new AStar<Tile>();
  List<Tile> path=pathfinder.computePath(myTile,playerTile);
  if (path.size() <= 1)   return new Wait();
  Tile dest=path.get(1);
  Vec2i curLoc=myTile.getLocation();
  Vec2i destLoc=dest.getLocation();
  Direction dir;
  if (destLoc.x < curLoc.x)   dir=Direction.LEFT;
 else   if (destLoc.x > curLoc.x)   dir=Direction.RIGHT;
 else   if (destLoc.y < curLoc.y)   dir=Direction.UP;
 else   dir=Direction.DOWN;
  return new Move(moveCost,me,dir);
}","private Action getAction(){
  Level l=me.getLevel();
  List<EntityActionManager> players=l.getManager().getEntity(""String_Node_Str"");
  if (players.size() == 0) {
    return new Move(100,me,Direction.RIGHT);
  }
  EntityActionManager player=players.get(0);
  Tile myTile=me.getLocation();
  Tile playerTile=player.getEntity().getLocation();
  AStar<Tile> pathfinder=new AStar<Tile>();
  List<Tile> path=pathfinder.computePath(myTile,playerTile);
  if (path.size() <= 1)   return new Wait();
  Tile dest=path.get(1);
  Vec2i curLoc=myTile.getLocation();
  Vec2i destLoc=dest.getLocation();
  Direction dir;
  if (destLoc.x < curLoc.x)   dir=Direction.LEFT;
 else   if (destLoc.x > curLoc.x)   dir=Direction.RIGHT;
 else   if (destLoc.y < curLoc.y)   dir=Direction.UP;
 else   dir=Direction.DOWN;
  return new Move(moveCost,me,dir);
}",0.9987966305655837
37935,"@Override public boolean isReady(MonsterInput i){
  Level l=i.getLevel();
  EntityActionManager player=l.getManager().getEntity(""String_Node_Str"").get(0);
  Space mySpace=me.getLocation().getSpace();
  Space playerSpace=player.getEntity().getLocation().getSpace();
  return (mySpace.equals(playerSpace));
}","@Override public boolean isReady(MonsterInput i){
  Level l=i.getLevel();
  List<EntityActionManager> players=l.getManager().getEntity(""String_Node_Str"");
  if (players.size() == 0) {
    return false;
  }
  EntityActionManager player=players.get(0);
  Space mySpace=me.getLocation().getSpace();
  Space playerSpace=player.getEntity().getLocation().getSpace();
  return (mySpace.equals(playerSpace));
}",0.844632768361582
37936,"private void drawStats(ScreenWriter sw){
  Level currentLevel=game.getCurrentLevel();
  String divider=""String_Node_Str"";
  for (int i=0; i < size.x; i++) {
    divider+='_';
  }
  sw.drawString(0,ANNOUNCE_OFFSET + MAP_SIZE.y,divider);
  int statStart=ANNOUNCE_OFFSET + MAP_SIZE.y + 1;
  List<EntityActionManager> monsters=currentLevel.getManager().getEntity(""String_Node_Str"");
  List<EntityActionManager> main=currentLevel.getManager().getEntity(""String_Node_Str"");
  if (monsters.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
 else   if (main.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
  MainCharacter player=(MainCharacter)main.get(0).getEntity();
  String line1=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=player.getHP();
  line1+=""String_Node_Str"";
  line1+=player.getStartHP();
  line1+=""String_Node_Str"";
  line1+=player.getXP();
  line1+=""String_Node_Str"";
  line1+=player.getNextLevelXP();
  line1+=""String_Node_Str"";
  sw.drawString(0,statStart,line1);
  String depthString=""String_Node_Str"" + currentLevel.getDepth();
  sw.drawString(size.x - depthString.length() - 2,statStart,depthString);
  String line2=""String_Node_Str"";
  line2=""String_Node_Str"" + player.getPlayerLevel();
  line2+=""String_Node_Str"";
  line2+=player.getStats().getAttack();
  line2+=""String_Node_Str"";
  line2+=String.valueOf(player.getStats().getDefense());
  line2+=""String_Node_Str"";
  sw.drawString(0,statStart + 1,line2);
}","private void drawStats(ScreenWriter sw){
  Level currentLevel=game.getCurrentLevel();
  String divider=""String_Node_Str"";
  for (int i=0; i < size.x; i++) {
    divider+='_';
  }
  sw.drawString(0,ANNOUNCE_OFFSET + MAP_SIZE.y,divider);
  int statStart=ANNOUNCE_OFFSET + MAP_SIZE.y + 1;
  List<EntityActionManager> main=currentLevel.getManager().getEntity(""String_Node_Str"");
  if (main.size() == 0) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
  MainCharacter player=(MainCharacter)main.get(0).getEntity();
  String line1=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=player.getHP();
  line1+=""String_Node_Str"";
  line1+=player.getStartHP();
  line1+=""String_Node_Str"";
  line1+=player.getXP();
  line1+=""String_Node_Str"";
  line1+=player.getNextLevelXP();
  line1+=""String_Node_Str"";
  sw.drawString(0,statStart,line1);
  String depthString=""String_Node_Str"" + currentLevel.getDepth();
  sw.drawString(size.x - depthString.length() - 2,statStart,depthString);
  String line2=""String_Node_Str"";
  line2=""String_Node_Str"" + player.getPlayerLevel();
  line2+=""String_Node_Str"";
  line2+=player.getStats().getAttack();
  line2+=""String_Node_Str"";
  line2+=String.valueOf(player.getStats().getDefense());
  line2+=""String_Node_Str"";
  sw.drawString(0,statStart + 1,line2);
}",0.3056431826147914
37937,"/** 
 * Saves the current level, obliterating anything that was already there
 * @throws SaveLoadException
 */
public void saveLevel(Level l) throws SaveLoadException {
  try {
    FileOutputStream fos=new FileOutputStream(this.saveFile);
    ObjectOutputStream oos=new ObjectOutputStream(fos);
    oos.writeObject(l);
    oos.close();
  }
 catch (  Exception e) {
    throw new SaveLoadException(e);
  }
}","/** 
 * Saves the current level, obliterating anything that was already there
 * @throws SaveLoadException
 */
public void saveLevel(Level l) throws SaveLoadException {
  try {
    FileOutputStream fos=new FileOutputStream(this.saveFile);
    ObjectOutputStream oos=new ObjectOutputStream(fos);
    oos.writeObject(l);
    fos.close();
    oos.close();
  }
 catch (  Exception e) {
    throw new SaveLoadException(e);
  }
}",0.9794933655006032
37938,"@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=app.makeNewGame();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
break;
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 16:
app.getLayers().push(new HelpLayer(app,size));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}","@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    int a=action.getActionClassifier();
    if (managers.size() == 0) {
      if (a != 1 && a != 4) {
        return;
      }
    }
 else {
      mainManager=managers.get(0);
      c=mainManager.getEntity();
    }
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=app.makeNewGame();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
checkLose();
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
checkLose();
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
checkLose();
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
checkLose();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
break;
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 16:
app.getLayers().push(new HelpLayer(app,size));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}",0.9707024355806564
37939,"@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=new RogueGame();
      game.createInitalLevel(app.getLevelGenerator());
      currentLevel=game.getCurrentLevel();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}","@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=new RogueGame();
      game.createInitalLevel(app.getLevelGenerator());
      currentLevel=game.getCurrentLevel();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
break;
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 16:
app.getLayers().push(new HelpLayer(app,size));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}",0.9875842497339482
37940,"@Override public GameAction getActionForKey(Key k){
switch (k.getKind()) {
case NormalKey:
{
switch (k.getCharacter()) {
case 'N':
        return new GameAction(1,1);
case 'S':
      return new GameAction(1,2);
case 'Q':
    return new GameAction(1,4);
case 'h':
  return new GameAction(1,5);
case 'j':
return new GameAction(1,7);
case 'k':
return new GameAction(1,6);
case 'l':
return new GameAction(1,8);
case 'i':
return new GameAction(1,9);
case 'q':
return new GameAction(1,10);
case 'w':
return new GameAction(1,11);
case 'o':
return new GameAction(1,12);
case '<':
return new GameAction(1,13);
case '>':
return new GameAction(1,14);
case 'd':
return new GameAction(1,15);
default :
return new GameAction(1,0);
}
}
case ArrowLeft:
return new GameAction(1,5);
case ArrowUp:
return new GameAction(1,6);
case ArrowDown:
return new GameAction(1,7);
case ArrowRight:
return new GameAction(1,8);
default :
return new GameAction(1,0);
}
}","@Override public GameAction getActionForKey(Key k){
switch (k.getKind()) {
case NormalKey:
{
switch (k.getCharacter()) {
case 'N':
        return new GameAction(1,1);
case 'S':
      return new GameAction(1,2);
case 'Q':
    return new GameAction(1,4);
case 'h':
  return new GameAction(1,5);
case 'j':
return new GameAction(1,7);
case 'k':
return new GameAction(1,6);
case 'l':
return new GameAction(1,8);
case 'i':
return new GameAction(1,9);
case 'q':
return new GameAction(1,10);
case 'w':
return new GameAction(1,11);
case 'o':
return new GameAction(1,12);
case '<':
return new GameAction(1,13);
case '>':
return new GameAction(1,14);
case 'd':
return new GameAction(1,15);
case '?':
return new GameAction(1,16);
default :
return new GameAction(1,0);
}
}
case ArrowLeft:
return new GameAction(1,5);
case ArrowUp:
return new GameAction(1,6);
case ArrowDown:
return new GameAction(1,7);
case ArrowRight:
return new GameAction(1,8);
default :
return new GameAction(1,0);
}
}",0.9796131730266596
37941,"@Override protected boolean initialize(Vec2i screenSize){
  this.sm=new SaveManager(""String_Node_Str"");
  this.lg=new BSPLevelGenerator(configDir);
  RogueGame rg=null;
  try {
    Game g=sm.loadGame();
    if (g instanceof RogueGame)     rg=(RogueGame)g;
    tm=new CumulativeTurnManager(this,rg,POINTS_PER_TURN);
    this.layers.push(new MainLayer(this,rg,SCREEN_SIZE,""String_Node_Str""));
    return true;
  }
 catch (  Exception e) {
    this.newGame();
    return true;
  }
}","@Override protected boolean initialize(Vec2i screenSize){
  this.sm=new SaveManager(""String_Node_Str"");
  this.lg=new BSPLevelGenerator(configDir);
  RogueGame rg=null;
  try {
    Game g=sm.loadGame();
    if (g instanceof RogueGame)     rg=(RogueGame)g;
    tm=new CumulativeTurnManager(this,rg,POINTS_PER_TURN);
    this.layers.push(new MainLayer(this,rg,SCREEN_SIZE,""String_Node_Str""));
    return true;
  }
 catch (  Exception e) {
    rg=this.makeNewGame();
    this.layers.push(new MainLayer(this,rg,SCREEN_SIZE,""String_Node_Str""));
    return true;
  }
}",0.9087415946205571
37942,"@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=new RogueGame();
      game.createInitalLevel(app.getLevelGenerator());
      currentLevel=game.getCurrentLevel();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
break;
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 16:
app.getLayers().push(new HelpLayer(app,size));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}","@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=app.makeNewGame();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
break;
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 16:
app.getLayers().push(new HelpLayer(app,size));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}",0.9796863863150392
37943,"public MainCharacter(String name){
  this.name=name;
  this.color=Color.DEFAULT;
  this.character='@';
  this.HP=100;
  this.startHP=this.HP;
  this.stats=new Stats(10,4);
  baseStats=stats;
  this.team=1;
}","public MainCharacter(String name){
  this.name=name;
  this.color=Color.DEFAULT;
  this.character='@';
  this.HP=100;
  this.startHP=this.HP;
  this.stats=new Stats(10,4);
  baseStats=stats;
  this.team=1;
  this.XP=0;
  nextLevelXP=6;
  playerLevel=1;
}",0.8980477223427332
37944,"@Override protected void onKillEntity(Combatable combatable){
}","@Override protected void onKillEntity(Combatable combatable){
  Announcer.announce(""String_Node_Str"" + combatable.getDescription());
  Monster m=(Monster)combatable;
  this.XP+=m.tier;
  if (XP >= nextLevelXP) {
    XP-=nextLevelXP;
    levelUp();
    Announcer.announce(""String_Node_Str"" + playerLevel);
  }
}",0.3378016085790885
37945,"public Monster(MonsterTemplate mt,Level level){
  this.level=level;
  this.character=mt.character;
  this.color=mt.color;
  this.HP=mt.startHp;
  this.startHP=mt.startHp;
  this.stats=new Stats(mt.attack,mt.defense);
  baseStats=stats;
  this.team=0;
  this.name=mt.name;
  this.moveCost=mt.moveCost;
  buildBrainz();
}","public Monster(MonsterTemplate mt,Level level){
  this.level=level;
  this.character=mt.character;
  this.color=mt.color;
  this.HP=mt.startHp;
  this.startHP=mt.startHp;
  this.stats=new Stats(mt.attack,mt.defense);
  baseStats=stats;
  this.team=0;
  this.name=mt.name;
  this.moveCost=mt.moveCost;
  this.tier=mt.tier;
  buildBrainz();
}",0.9681335356600912
37946,"public Stats invert(){
  return new Stats(attack * 1,defense * 1);
}","public Stats invert(){
  return new Stats(attack * -1,defense * -1);
}",0.9855072463768116
37947,"private Action getAction(){
  Level l=me.getLevel();
  EntityActionManager player=l.getManager().getEntity(""String_Node_Str"").get(0);
  Tile myTile=me.getLocation();
  Tile playerTile=player.getEntity().getLocation();
  AStar<Tile> pathfinder=new AStar<Tile>();
  List<Tile> path=pathfinder.computePath(myTile,playerTile);
  if (path.size() <= 1)   return new Wait();
  Tile dest=path.get(1);
  Vec2i curLoc=myTile.getLocation();
  Vec2i destLoc=dest.getLocation();
  Direction dir;
  if (destLoc.x < curLoc.x)   dir=Direction.LEFT;
 else   if (destLoc.x > curLoc.x)   dir=Direction.RIGHT;
 else   if (destLoc.y < curLoc.y)   dir=Direction.UP;
 else   dir=Direction.DOWN;
  return new Move(moveCost,me,dir);
}","private Action getAction(){
  Level l=me.getLevel();
  List<EntityActionManager> players=l.getManager().getEntity(""String_Node_Str"");
  if (players.size() == 0) {
    return new Move(0,me,Direction.RIGHT);
  }
  EntityActionManager player=players.get(0);
  Tile myTile=me.getLocation();
  Tile playerTile=player.getEntity().getLocation();
  AStar<Tile> pathfinder=new AStar<Tile>();
  List<Tile> path=pathfinder.computePath(myTile,playerTile);
  if (path.size() <= 1)   return new Wait();
  Tile dest=path.get(1);
  Vec2i curLoc=myTile.getLocation();
  Vec2i destLoc=dest.getLocation();
  Direction dir;
  if (destLoc.x < curLoc.x)   dir=Direction.LEFT;
 else   if (destLoc.x > curLoc.x)   dir=Direction.RIGHT;
 else   if (destLoc.y < curLoc.y)   dir=Direction.UP;
 else   dir=Direction.DOWN;
  return new Move(moveCost,me,dir);
}",0.336582196231319
37948,"/** 
 * Initalizes the first level
 * @throws ConfigurationException 
 */
public void createInitalLevel(BSPLevelGenerator lg) throws ConfigurationException {
  this.currentLevel=lg.generateLevel(MAP_SIZE,1);
  levels.put(1,currentLevel);
  MainCharacter mc=new MainCharacter(""String_Node_Str"");
  currentLevel.getManager().register(mc);
  currentLevel.placeCharacter(mc,true);
}","/** 
 * Initalizes the first level
 * @throws ConfigurationException 
 */
public void createInitalLevel(BSPLevelGenerator lg) throws ConfigurationException {
  this.currentLevel=lg.generateLevel(MAP_SIZE,1);
  levels.put(1,currentLevel);
  MainCharacter mc=new MainCharacter(""String_Node_Str"");
  currentLevel.placeCharacter(mc,true);
}",0.896358543417367
37949,"private void drawStats(ScreenWriter sw){
  Level currentLevel=game.getCurrentLevel();
  String divider=""String_Node_Str"";
  for (int i=0; i < size.x; i++) {
    divider+='_';
  }
  sw.drawString(0,ANNOUNCE_OFFSET + MAP_SIZE.y,divider);
  int statStart=ANNOUNCE_OFFSET + MAP_SIZE.y + 1;
  List<EntityActionManager> monsters=currentLevel.getManager().getEntity(""String_Node_Str"");
  List<EntityActionManager> main=currentLevel.getManager().getEntity(""String_Node_Str"");
  if (monsters.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
 else   if (main.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
  Combatable player=main.get(0).getEntity();
  String line1=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=player.getHP();
  line1+=""String_Node_Str"";
  line1+=player.getStartHP();
  sw.drawString(0,statStart,line1);
  String depthString=""String_Node_Str"" + currentLevel.getDepth();
  sw.drawString(size.x - depthString.length() - 2,statStart,depthString);
  String line2=""String_Node_Str"";
  line2+=""String_Node_Str"";
  line2+=player.getStats().getAttack();
  line2+=""String_Node_Str"";
  line2+=String.valueOf(player.getStats().getDefense());
  sw.drawString(0,statStart + 1,line2);
}","private void drawStats(ScreenWriter sw){
  Level currentLevel=game.getCurrentLevel();
  String divider=""String_Node_Str"";
  for (int i=0; i < size.x; i++) {
    divider+='_';
  }
  sw.drawString(0,ANNOUNCE_OFFSET + MAP_SIZE.y,divider);
  int statStart=ANNOUNCE_OFFSET + MAP_SIZE.y + 1;
  List<EntityActionManager> monsters=currentLevel.getManager().getEntity(""String_Node_Str"");
  List<EntityActionManager> main=currentLevel.getManager().getEntity(""String_Node_Str"");
  if (monsters.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
 else   if (main.isEmpty()) {
    sw.drawString(0,statStart,""String_Node_Str"");
    return;
  }
  MainCharacter player=(MainCharacter)main.get(0).getEntity();
  String line1=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=""String_Node_Str"";
  line1+=player.getHP();
  line1+=""String_Node_Str"";
  line1+=player.getStartHP();
  line1+=""String_Node_Str"";
  line1+=player.getXP();
  line1+=""String_Node_Str"";
  line1+=player.getNextLevelXP();
  line1+=""String_Node_Str"";
  sw.drawString(0,statStart,line1);
  String depthString=""String_Node_Str"" + currentLevel.getDepth();
  sw.drawString(size.x - depthString.length() - 2,statStart,depthString);
  String line2=""String_Node_Str"";
  line2=""String_Node_Str"" + player.getPlayerLevel();
  line2+=""String_Node_Str"";
  line2+=player.getStats().getAttack();
  line2+=""String_Node_Str"";
  line2+=String.valueOf(player.getStats().getDefense());
  line2+=""String_Node_Str"";
  sw.drawString(0,statStart + 1,line2);
}",0.907209136331192
37950,"@Override protected void applyItemEffect(Stackable item,EntityActionManager target){
  if (item.getType() == ItemType.WEAPON) {
    Weapon w=(Weapon)item;
    Weapon oldWeap=(Weapon)target.getEntity().getEquipment().get(EquipType.WEAPON);
    if (oldWeap != null) {
      oldWeap.getUnwieldAction().apply(target);
      target.getEntity().getInventory().add(oldWeap);
    }
    Announcer.announce(""String_Node_Str"" + w.getDescription());
    tm.takeTurn(w.getWieldAction());
    target.getEntity().getEquipment().put(EquipType.WEAPON,w);
    target.getEntity().getInventory().remove(item);
  }
}","@Override protected void applyItemEffect(Stackable item,EntityActionManager target){
  if (item.getType() == ItemType.WEAPON) {
    Weapon w=(Weapon)item;
    Weapon oldWeap=(Weapon)target.getEntity().getEquipment().get(EquipType.WEAPON);
    if (oldWeap != null) {
      tm.takeTurn(oldWeap.getUnwieldAction());
      target.getEntity().getInventory().add(oldWeap);
    }
    Announcer.announce(""String_Node_Str"" + w.getDescription());
    target.getEntity().getEquipment().put(EquipType.WEAPON,w);
    tm.takeTurn(w.getWieldAction());
    target.getEntity().getEquipment().put(EquipType.WEAPON,w);
    target.getEntity().getInventory().remove(item);
  }
}",0.8706070287539937
37951,"@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=new RogueGame();
      game.createInitalLevel(app.getLevelGenerator());
      currentLevel=game.getCurrentLevel();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}","@Override public void propagateAction(GameAction action){
  Level currentLevel=game.getCurrentLevel();
  CumulativeTurnManager tm=app.getTurnManager();
  EntityActionManager mainManager=null;
  Move moveAction;
  Combatable c=null;
  List<EntityActionManager> managers=null;
  if (currentLevel != null) {
    managers=currentLevel.getManager().getEntity(""String_Node_Str"");
    if (managers.size() == 0) {
      return;
    }
    mainManager=managers.get(0);
    c=mainManager.getEntity();
  }
  if (managers == null)   managers=new ArrayList<EntityActionManager>();
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
{
      this.game=new RogueGame();
      game.createInitalLevel(app.getLevelGenerator());
      currentLevel=game.getCurrentLevel();
      app.getSaveManager().saveGame(game);
      checkReveal();
    }
  break;
case 2:
app.getSaveManager().saveGame(this.game);
break;
case 4:
app.getSaveManager().saveGame(game);
app.shutdown();
break;
case 5:
if (c != null) {
moveAction=new Move(10,c,Direction.LEFT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 6:
if (c != null) {
moveAction=new Move(10,c,Direction.UP);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 7:
if (c != null) {
moveAction=new Move(10,c,Direction.DOWN);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 8:
if (c != null) {
moveAction=new Move(10,c,Direction.RIGHT);
tm.takeTurn(moveAction);
}
checkReveal();
break;
case 9:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
break;
case 10:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new PotionLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 11:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new WeaponLayer<GUIApp>(tm,app,size,currentLevel));
break;
case 12:
app.getLayers().push(new LookLayer<GUIApp>(app,size,currentLevel));
break;
case 13:
if (c != null) {
if (c.getLocation().getType() == TileType.UP_STAIRS) {
if (currentLevel.getDepth() != 1) {
game.gotoLevel(currentLevel.getDepth() - 1,app.getLevelGenerator());
checkReveal();
}
}
}
break;
case 14:
if (c != null) {
if (c.getLocation().getType() == TileType.DOWN_STAIRS) {
game.gotoLevel(currentLevel.getDepth() + 1,app.getLevelGenerator());
checkReveal();
}
}
case 15:
app.getLayers().push(new InventoryLayer(app,size,currentLevel));
app.getLayers().push(new DropLayer<GUIApp>(tm,app,size,currentLevel));
break;
default :
throw new Error(""String_Node_Str"" + action.toString() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}",0.990572878897752
37952,"@Override public void doDraw(Section sw){
  sw.setForegroundColor(Color.YELLOW);
  sw.drawString(loc.getLocation().x,loc.getLocation().y + DefaultMainLayer.ANNOUNCE_OFFSET,""String_Node_Str"");
  int startX=size.x - OFFSET;
  int currentY=0;
  if (loc.getLocation().x > size.x - OFFSET) {
    startX=0;
  }
  sw.setForegroundColor(Color.DEFAULT);
  if (loc.getEntity() != null) {
    sw.drawString(startX,currentY,loc.getEntity().getDescription());
    currentY++;
  }
  for (  Stackable s : loc.getStackables()) {
    sw.drawString(startX,currentY,s.getDescription());
    currentY++;
  }
  if (loc.getType().getDescription() != null) {
    sw.drawString(startX,currentY,loc.getType().getDescription());
    currentY++;
  }
  if (currentY == 0) {
    sw.drawString(startX,currentY,""String_Node_Str"");
  }
}","@Override public void doDraw(Section sw){
  sw.setForegroundColor(Color.YELLOW);
  sw.drawString(loc.getLocation().x,loc.getLocation().y + DefaultMainLayer.ANNOUNCE_OFFSET,""String_Node_Str"");
  int startX=size.x - OFFSET;
  int currentY=0;
  if (loc.getLocation().x > size.x - OFFSET) {
    startX=0;
  }
  sw.setForegroundColor(Color.DEFAULT);
  if (loc.getEntity() != null) {
    sw.drawString(startX,currentY,loc.getEntity().getDescription());
    currentY++;
  }
  for (  Stackable s : loc.getStackables()) {
    sw.drawString(startX,currentY,s.getDescription());
    currentY++;
  }
  if (loc.getType().getDescription() != null && loc.getReveal()) {
    sw.drawString(startX,currentY,loc.getType().getDescription());
    currentY++;
  }
  if (currentY == 0) {
    sw.drawString(startX,currentY,""String_Node_Str"");
  }
}",0.9883364027010436
37953,"/** 
 * Generates a full level whose size is levelSize
 * @throws ConfigurationException 
 */
public Level generateLevel(Vec2i levelSize) throws ConfigurationException {
  rand=new RandomGen(System.nanoTime());
  tiles=new Tile[levelSize.x][levelSize.y];
  fillWithSolids(tiles);
  SubLevel fullLevel=new SubLevel(new Vec2i(0,0),levelSize,0);
  splitAndBuild(fullLevel);
  Level level=new Level(tiles,fullLevel.rooms,fullLevel.hallways);
  MonsterGenerator mg=new ProgressiveMonsterGenerator();
  mg.populateLevel(level);
  level.setDepth(3);
  return level;
}","/** 
 * Generates a full level whose size is levelSize
 * @throws ConfigurationException 
 */
public Level generateLevel(Vec2i levelSize) throws ConfigurationException {
  rand=new RandomGen(System.nanoTime());
  tiles=new Tile[levelSize.x][levelSize.y];
  fillWithSolids(tiles);
  SubLevel fullLevel=new SubLevel(new Vec2i(0,0),levelSize,0);
  splitAndBuild(fullLevel);
  Level level=new Level(tiles,fullLevel.rooms,fullLevel.hallways);
  level.setDepth(5);
  MonsterGenerator mg=new ProgressiveMonsterGenerator();
  mg.populateLevel(level);
  return level;
}",0.9625
37954,"/** 
 * Gets a random monster that is pplicable to the level: Roll Order: lower tier; higher tier; else base;
 * @return A random monster
 */
private Monster getRandomMonster(Level level){
  int tier=(int)(1 + Math.floor(level.depth / tierStepSize));
  int tierDiff=tierStepSize * tier - level.depth;
  if (Math.random() <= lowerChance / tierDiff)   tier-=1;
 else   if (Math.random() <= higherChance * tierDiff)   tier+=1;
  if (tier == 0) {
    tier=1;
  }
  if (tier > tiers.size()) {
    tier=tiers.size();
  }
  List<MonsterTemplate> tierList=tiers.get(tier);
  return (new Monster(tierList.get(rand.getRandom(tierList.size()))));
}","/** 
 * Gets a random monster that is pplicable to the level: Roll Order: lower tier; higher tier; else base;
 * @return A random monster
 */
private Monster getRandomMonster(Level level){
  int tier=(1 + (level.depth / tierStepSize));
  int tierDiff=tierStepSize * (tier - 1) - level.depth + 1;
  if (Math.random() <= lowerChance / tierDiff)   tier-=1;
 else   if (Math.random() <= higherChance * tierDiff)   tier+=1;
  if (tier == 0) {
    tier=1;
  }
  if (tier > tiers.size()) {
    tier=tiers.size();
  }
  List<MonsterTemplate> tierList=tiers.get(tier);
  return (new Monster(tierList.get(rand.getRandom(tierList.size()))));
}",0.9802994483845549
37955,"/** 
 * Generates a full level whose size is levelSize
 * @throws ConfigurationException 
 */
public Level generateLevel(Vec2i levelSize) throws ConfigurationException {
  rand=new RandomGen(System.nanoTime());
  tiles=new Tile[levelSize.x][levelSize.y];
  fillWithSolids(tiles);
  SubLevel fullLevel=new SubLevel(new Vec2i(0,0),levelSize,0);
  splitAndBuild(fullLevel);
  Level level=new Level(tiles,fullLevel.rooms,fullLevel.hallways);
  MonsterGenerator mg=new ProgressiveMonsterGenerator();
  mg.populateLevel(level);
  level.setDepth(3);
  return level;
}","/** 
 * Generates a full level whose size is levelSize
 * @throws ConfigurationException 
 */
public Level generateLevel(Vec2i levelSize) throws ConfigurationException {
  rand=new RandomGen(System.nanoTime());
  tiles=new Tile[levelSize.x][levelSize.y];
  fillWithSolids(tiles);
  SubLevel fullLevel=new SubLevel(new Vec2i(0,0),levelSize,0);
  splitAndBuild(fullLevel);
  Level level=new Level(tiles,fullLevel.rooms,fullLevel.hallways);
  level.setDepth(3);
  MonsterGenerator mg=new ProgressiveMonsterGenerator();
  mg.populateLevel(level);
  return level;
}",0.9625
37956,"/** 
 * Gets a random monster that is pplicable to the level: Roll Order: lower tier; higher tier; else base;
 * @return A random monster
 */
private Monster getRandomMonster(Level level){
  int tier=(int)(1 + Math.floor(level.depth / tierStepSize));
  int tierDiff=tierStepSize * tier - level.depth;
  if (Math.random() <= lowerChance / tierDiff)   tier-=1;
 else   if (Math.random() <= higherChance * tierDiff)   tier+=1;
  if (tier == 0) {
    tier=1;
  }
  if (tier > tiers.size()) {
    tier=tiers.size();
  }
  List<MonsterTemplate> tierList=tiers.get(tier);
  return (new Monster(tierList.get(rand.getRandom(tierList.size()))));
}","/** 
 * Gets a random monster that is pplicable to the level: Roll Order: lower tier; higher tier; else base;
 * @return A random monster
 */
private Monster getRandomMonster(Level level){
  int tier=(1 + (level.depth / tierStepSize));
  int tierDiff=level.depth + 1 - tierStepSize * (tier - 1);
  if (Math.random() <= lowerChance / tierDiff)   tier-=1;
 else   if (Math.random() <= higherChance * tierDiff)   tier+=1;
  if (tier == 0) {
    tier=1;
  }
  if (tier > tiers.size()) {
    tier=tiers.size();
  }
  List<MonsterTemplate> tierList=tiers.get(tier);
  return (new Monster(tierList.get(rand.getRandom(tierList.size()))));
}",0.9629629629629628
37957,"public MainCharacter(){
  this.character='@';
  this.color=Color.DEFAULT;
  this.HP=100;
  this.startHP=this.HP;
  this.stats=new Stats(.75f,6,2);
  this.team=1;
}","public MainCharacter(){
  this.character='@';
  this.color=Color.DEFAULT;
  this.HP=100;
  this.startHP=this.HP;
  this.stats=new Stats(.75f,10,4);
  this.team=1;
}",0.9847094801223242
37958,"public void apply(EntityActionManager queue){
  System.out.println(""String_Node_Str"");
  List<EntityActionManager> mains=this.manager.getEntity(""String_Node_Str"");
  if (mains.size() > 0) {
    Tile myLoc=queue.getLocation();
    Tile mainLoc=mains.get(0).getLocation();
    Direction dir=myLoc.dirTo(mainLoc);
    queue.sendMove(dir);
  }
}","public void apply(EntityActionManager queue){
  List<EntityActionManager> mains=this.manager.getEntity(""String_Node_Str"");
  if (mains.size() > 0) {
    Tile myLoc=queue.getLocation();
    Tile mainLoc=mains.get(0).getLocation();
    Direction dir=myLoc.dirTo(mainLoc);
    queue.sendMove(dir);
  }
}",0.7675507020280812
37959,"@Override public void doDraw(Section s){
  s=s.moveUpperLeft(new Vec2i(size.x - 30,0));
  Set<Stackable> inventory;
  inventory=currentLevel.getManager().getEntity(""String_Node_Str"").get(0).getEntity().getInventory();
  Iterator<Stackable> iter=inventory.iterator();
  int i;
  for (i=0; i < Math.min(size.y - 1,inventory.size()); i++) {
    String line=""String_Node_Str"";
    line+=""String_Node_Str"";
    line+=getLetter(i);
    line+=""String_Node_Str"";
    line+=iter.next().getDescription();
    s.drawString(0,i,line);
  }
  s.drawString(0,i,""String_Node_Str"");
}","@Override public void doDraw(Section s){
  s=s.moveUpperLeft(new Vec2i(size.x - 30,0));
  Set<Stackable> inventory;
  List<EntityActionManager> mains=currentLevel.getManager().getEntity(""String_Node_Str"");
  if (mains.size() > 0)   inventory=mains.get(0).getEntity().getInventory();
 else   inventory=new HashSet<Stackable>();
  Iterator<Stackable> iter=inventory.iterator();
  int i;
  for (i=0; i < Math.min(size.y - 1,inventory.size()); i++) {
    String line=""String_Node_Str"";
    line+=""String_Node_Str"";
    line+=getLetter(i);
    line+=""String_Node_Str"";
    line+=iter.next().getDescription();
    s.drawString(0,i,line);
  }
  s.drawString(0,i,""String_Node_Str"");
}",0.8897827835880934
37960,"@Override public void propagateAction(GameAction action){
}","@Override public void propagateAction(GameAction action){
  if (action.getContextClassifier() != 1)   throw new Error(""String_Node_Str"");
  try {
switch (action.getActionClassifier()) {
case 0:
      break;
case 1:
    currentLevel=rg.generateLevel(levelSize);
  RandomGen rand=new RandomGen(System.nanoTime());
Room r1=currentLevel.getRooms().get(0);
break;
case 2:
sm.saveLevel(currentLevel);
break;
case 3:
currentLevel=sm.loadLevel();
break;
case 4:
app.shutdown();
break;
default :
throw new Error(""String_Node_Str"" + action.getActionClassifier() + ""String_Node_Str"");
}
}
 catch (SaveLoadException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
catch (ConfigurationException e) {
statusMsg=e.getMessage();
currentLevel=null;
}
}",0.1478696741854636
37961,"/** 
 * Makes a room inside the sublevel
 * @param curr - the area to make the room in
 */
private void makeRoom(SubLevel curr){
  int maxWidth=curr.max.x - curr.min.x - 2 * minWallThickness;
  int maxHeight=curr.max.y - curr.min.y - 2 * minWallThickness;
  int minX=getRandom(minWallThickness,maxWidth - minRoomDim);
  int maxX=getRandom(minX + minRoomDim,maxWidth);
  int minY=getRandom(minWallThickness,maxHeight - minRoomDim);
  int maxY=getRandom(minY + minRoomDim,maxHeight);
  Vec2i min=curr.min.plus(minX,minY);
  Vec2i max=curr.min.plus(maxX,maxY);
  paintCellRectangle(min,max,true,TileType.FLOOR);
  Room r=new Room(min,max);
  curr.rooms.add(r);
  curr.intersectMin=min;
  curr.intersectMax=max;
}","/** 
 * Makes a room inside the sublevel
 * @param curr - the area to make the room in
 */
private void makeRoom(SubLevel curr){
  int maxWidth=curr.max.x - curr.min.x - 1 * minWallThickness;
  int maxHeight=curr.max.y - curr.min.y - 1 * minWallThickness;
  int minX=getRandom(minWallThickness,maxWidth - minRoomDim);
  int maxX=getRandom(minX + minRoomDim,maxWidth);
  int minY=getRandom(minWallThickness,maxHeight - minRoomDim);
  int maxY=getRandom(minY + minRoomDim,maxHeight);
  Vec2i min=curr.min.plus(minX,minY);
  Vec2i max=curr.min.plus(maxX,maxY);
  paintCellRectangle(min,max,true,TileType.FLOOR);
  Room r=new Room(min,max);
  curr.rooms.add(r);
  curr.intersectMin=min;
  curr.intersectMax=max;
}",0.997179125528914
37962,"/** 
 * Makes a room inside the sublevel
 * @param curr - the area to make the room in
 */
private void makeRoom(SubLevel curr){
  int maxWidth=curr.max.x - curr.min.x - 2 * minWallThickness;
  int maxHeight=curr.max.y - curr.min.y - 2 * minWallThickness;
  int minX=getRandom(minWallThickness,maxWidth - minRoomDim);
  int maxX=getRandom(minX + minRoomDim,maxWidth);
  int minY=getRandom(minWallThickness,maxHeight - minRoomDim);
  int maxY=getRandom(minY + minRoomDim,maxHeight);
  Vec2i min=curr.min.plus(minX,minY);
  Vec2i max=curr.min.plus(maxX,maxY);
  paintCellRectangle(min,max,true,TileType.FLOOR);
  Room r=new Room(min,max);
  curr.rooms.add(r);
  curr.intersectMin=min.plus(1,1);
  curr.intersectMax=max.plus(-1,-1);
}","/** 
 * Makes a room inside the sublevel
 * @param curr - the area to make the room in
 */
private void makeRoom(SubLevel curr){
  int maxWidth=curr.max.x - curr.min.x - 2 * minWallThickness;
  int maxHeight=curr.max.y - curr.min.y - 2 * minWallThickness;
  int minX=getRandom(minWallThickness,maxWidth - minRoomDim);
  int maxX=getRandom(minX + minRoomDim,maxWidth);
  int minY=getRandom(minWallThickness,maxHeight - minRoomDim);
  int maxY=getRandom(minY + minRoomDim,maxHeight);
  Vec2i min=curr.min.plus(minX,minY);
  Vec2i max=curr.min.plus(maxX,maxY);
  paintCellRectangle(min,max,true,TileType.FLOOR);
  Room r=new Room(min,max);
  curr.rooms.add(r);
  curr.intersectMin=min;
  curr.intersectMax=max;
}",0.9847222222222224
37963,"/** 
 * Splits the sublevel recursively until it builds rooms, then connects the rooms together In the end, curr is populated with the current hallways and rooms
 */
private void splitAndBuild(SubLevel curr){
  boolean makeRoom=false;
  int splitAttempts=0;
  if (curr.depth == depthMax) {
    makeRoom=true;
  }
  if (makeRoom) {
    makeRoom(curr);
  }
 else {
    Split s=(getRandom(2) == 0) ? Split.VER : Split.HOR;
    SubLevel s1, s2;
    if (s == Split.HOR) {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int maxVal=Math.round((width * (splitMax - splitMin)));
      int splitVal=Math.round(curr.min.x + width * splitMin + getRandom(maxVal));
      while (splitVal - curr.min.x < 2 * minWallThickness + minRoomDim || curr.max.x - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        maxVal=Math.round((width * (splitMax - splitMin)));
        splitVal=Math.round(curr.min.x + width * splitMin + getRandom(maxVal));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(splitVal,curr.max.y),curr.depth + 1);
      s2=new SubLevel(new Vec2i(splitVal + 1,curr.min.y),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
 else {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int splitVal=Math.round(curr.min.y + height * splitMin + getRandom(Math.round((height * (splitMax - splitMin)))));
      while (splitVal - curr.min.y < 2 * minWallThickness + minRoomDim || curr.max.y - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        splitVal=Math.round(curr.min.y + height * splitMin + getRandom(Math.round((height * (splitMax - splitMin)))));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(curr.max.x,splitVal),curr.depth + 1);
      s2=new SubLevel(new Vec2i(curr.min.x,splitVal + 1),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
    splitAndBuild(s1);
    splitAndBuild(s2);
    Range range=s1.overLap(s2,s);
    if (range != null) {
      int hpt;
      hpt=range.min + getRandom(range.max - range.min);
      HallwayPoint hp1=s1.getHallwayPoint(s,true,hpt);
      HallwayPoint hp2=s2.getHallwayPoint(s,false,hpt);
      Hallway new_hallway=new Hallway(hp1.point,hp2.point);
      paintHallway(hp1.point,hp2.point,true,TileType.FLOOR);
      hp1.space.connectToHallway(new_hallway);
      hp2.space.connectToHallway(new_hallway);
      curr.hallways.add(new_hallway);
    }
 else {
      if (s == Split.HOR) {
        int cy=s1.intersectMin.y + getRandom(s1.intersectMax.y - s1.intersectMin.y);
        int cx=s2.intersectMin.x + getRandom(s2.intersectMax.x - s2.intersectMin.x);
        Vec2i corner=new Vec2i(cx,cy);
        HallwayPoint hp1=s1.getHallwayPoint(Split.VER,true,cy);
        HallwayPoint hp2=s2.getHallwayPoint(Split.HOR,(s1.intersectMin.x > s2.intersectMax.x),cx);
        Hallway new_hallway1=new Hallway(hp1.point,corner);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2=new Hallway(hp2.point,corner);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
 else {
        int cx=s1.intersectMin.x + getRandom(s1.intersectMax.x - s1.intersectMin.x);
        int cy=s2.intersectMin.y + getRandom(s2.intersectMax.y - s2.intersectMin.y);
        Vec2i corner=new Vec2i(cx,cy);
        HallwayPoint hp1=s1.getHallwayPoint(Split.HOR,true,cx);
        HallwayPoint hp2=s2.getHallwayPoint(Split.VER,(s1.intersectMin.y > s2.intersectMax.y),cy);
        Hallway new_hallway1=new Hallway(hp1.point,corner);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2=new Hallway(hp2.point,corner);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
    }
    curr.rooms.addAll(s1.rooms);
    curr.rooms.addAll(s2.rooms);
    curr.hallways.addAll(s1.hallways);
    curr.hallways.addAll(s2.hallways);
    int maxIX=Math.max(s1.intersectMax.x,s2.intersectMax.x);
    int maxIY=Math.max(s1.intersectMax.y,s2.intersectMax.y);
    int minIX=Math.max(s1.intersectMin.x,s2.intersectMin.x);
    int minIY=Math.max(s1.intersectMax.y,s2.intersectMax.y);
    curr.intersectMax=new Vec2i(maxIX,maxIY);
    curr.intersectMin=new Vec2i(minIX,minIY);
  }
}","/** 
 * Splits the sublevel recursively until it builds rooms, then connects the rooms together In the end, curr is populated with the current hallways and rooms
 */
private void splitAndBuild(SubLevel curr){
  boolean makeRoom=false;
  int splitAttempts=0;
  if (curr.depth == depthMax) {
    makeRoom=true;
  }
  if (makeRoom) {
    makeRoom(curr);
  }
 else {
    Split s=(getRandom(2) == 0) ? Split.VER : Split.HOR;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.VER;
      }
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.HOR;
      }
    }
    SubLevel s1, s2;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int splitVal=Math.round(curr.min.y + height * splitMin + getRandom(Math.round((height * (splitMax - splitMin)))));
      while (splitVal - curr.min.y < 2 * minWallThickness + minRoomDim || curr.max.y - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        splitVal=Math.round(curr.min.y + height * splitMin + getRandom(Math.round((height * (splitMax - splitMin)))));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(curr.max.x,splitVal),curr.depth + 1);
      s2=new SubLevel(new Vec2i(curr.min.x,splitVal + 1),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int maxVal=Math.round((width * (splitMax - splitMin)));
      int splitVal=Math.round(curr.min.x + width * splitMin + getRandom(maxVal));
      while (splitVal - curr.min.x < 2 * minWallThickness + minRoomDim || curr.max.x - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        maxVal=Math.round((width * (splitMax - splitMin)));
        splitVal=Math.round(curr.min.x + width * splitMin + getRandom(maxVal));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(splitVal,curr.max.y),curr.depth + 1);
      s2=new SubLevel(new Vec2i(splitVal + 1,curr.min.y),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
    splitAndBuild(s1);
    splitAndBuild(s2);
    Range range=s1.overLap(s2,s);
    if (range != null) {
      int hpt;
      hpt=getRandom(range.min,range.max);
      HallwayPoint hp1=s1.getHallwayPoint(s,true,hpt);
      HallwayPoint hp2=s2.getHallwayPoint(s,false,hpt);
      Hallway new_hallway=new Hallway(hp1.point,hp2.point);
      paintHallway(hp1.point,hp2.point,true,TileType.FLOOR);
      hp1.space.connectToHallway(new_hallway);
      hp2.space.connectToHallway(new_hallway);
      curr.hallways.add(new_hallway);
    }
 else {
      if (s == Split.HOR) {
        int cx=getRandom(s1.intersectMin.x,s1.intersectMax.x);
        int cy=getRandom(s2.intersectMin.y,s2.intersectMax.y);
        Vec2i corner=new Vec2i(cx,cy);
        HallwayPoint hp1=s1.getHallwayPoint(Split.HOR,true,cx);
        HallwayPoint hp2=s2.getHallwayPoint(Split.VER,(s2.intersectMin.x < s1.intersectMax.x),cy);
        Hallway new_hallway1=new Hallway(hp1.point,corner);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2;
        if (s2.intersectMin.x > s1.intersectMax.x)         new_hallway2=new Hallway(hp2.point,corner);
 else         new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
 else {
        int cx=s1.intersectMin.x + getRandom(s1.intersectMax.x - s1.intersectMin.x);
        int cy=s2.intersectMin.y + getRandom(s2.intersectMax.y - s2.intersectMin.y);
        Vec2i corner=new Vec2i(cx,cy);
        HallwayPoint hp1=s1.getHallwayPoint(Split.HOR,(s1.intersectMin.y < s2.intersectMax.y),cx);
        HallwayPoint hp2=s2.getHallwayPoint(Split.VER,false,cy);
        Hallway new_hallway1;
        if (s1.intersectMin.y < s2.intersectMax.y)         new_hallway1=new Hallway(hp1.point,corner);
 else         new_hallway1=new Hallway(corner,hp1.point);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
    }
    curr.rooms.addAll(s1.rooms);
    curr.rooms.addAll(s2.rooms);
    curr.hallways.addAll(s1.hallways);
    curr.hallways.addAll(s2.hallways);
    int maxIX=Math.max(s1.intersectMax.x,s2.intersectMax.x);
    int maxIY=Math.max(s1.intersectMax.y,s2.intersectMax.y);
    int minIX=Math.min(s1.intersectMin.x,s2.intersectMin.x);
    int minIY=Math.min(s1.intersectMin.y,s2.intersectMin.y);
    curr.intersectMax=new Vec2i(maxIX,maxIY);
    curr.intersectMin=new Vec2i(minIX,minIY);
  }
}",0.7445310299502395
37964,"/** 
 * Splits the sublevel recursively until it builds rooms, then connects the rooms together In the end, curr is populated with the current hallways and rooms
 */
private void splitAndBuild(SubLevel curr){
  boolean makeRoom=false;
  int splitAttempts=0;
  if (curr.depth == depthMax) {
    makeRoom=true;
  }
  if (makeRoom) {
    makeRoom(curr);
  }
 else {
    Split s=(rand.getRandom(2) == 0) ? Split.VER : Split.HOR;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.VER;
      }
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.HOR;
      }
    }
    SubLevel s1, s2;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int splitVal=Math.round(curr.min.y + height * splitMin + rand.getRandom(Math.round((height * (splitMax - splitMin)))));
      while (splitVal - curr.min.y < 2 * minWallThickness + minRoomDim || curr.max.y - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        splitVal=Math.round(curr.min.y + height * splitMin + rand.getRandom(Math.round((height * (splitMax - splitMin)))));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(curr.max.x,splitVal),curr.depth + 1);
      s2=new SubLevel(new Vec2i(curr.min.x,splitVal + 1),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int maxVal=Math.round((width * (splitMax - splitMin)));
      int splitVal=Math.round(curr.min.x + width * splitMin + rand.getRandom(maxVal));
      while (splitVal - curr.min.x < 2 * minWallThickness + minRoomDim || curr.max.x - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        maxVal=Math.round((width * (splitMax - splitMin)));
        splitVal=Math.round(curr.min.x + width * splitMin + rand.getRandom(maxVal));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(splitVal,curr.max.y),curr.depth + 1);
      s2=new SubLevel(new Vec2i(splitVal + 1,curr.min.y),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
    splitAndBuild(s1);
    splitAndBuild(s2);
    Range range=s1.overLap(s2,s);
    if (range != null) {
      int hpt;
      HallwayPoint hp1;
      HallwayPoint hp2;
      do {
        hpt=rand.getRandom(range.min,range.max);
        hp1=s1.getHallwayPoint(s,true,hpt);
        hp2=s2.getHallwayPoint(s,false,hpt);
      }
 while (!testHallway(hp1.point,hp2.point));
      Hallway new_hallway=new Hallway(hp1.point,hp2.point);
      paintHallway(hp1.point,hp2.point,true,TileType.FLOOR);
      hp1.space.connectToHallway(new_hallway);
      hp2.space.connectToHallway(new_hallway);
      if (hp1.space.needDoor())       makeDoor(hp1.point,s,true);
      if (hp2.space.needDoor())       makeDoor(hp2.point,s,false);
      curr.hallways.add(new_hallway);
    }
 else {
      if (s == Split.HOR) {
        HallwayPoint hp1;
        HallwayPoint hp2;
        Vec2i corner;
        do {
          int cx=rand.getRandom(s1.intersectMin.x,s1.intersectMax.x);
          int cy=rand.getRandom(s2.intersectMin.y,s2.intersectMax.y);
          corner=new Vec2i(cx,cy);
          hp1=s1.getHallwayPoint(Split.HOR,true,cx);
          hp2=s2.getHallwayPoint(Split.VER,(s2.intersectMin.x < s1.intersectMax.x),cy);
        }
 while (!testHallway(hp1.point,corner) && !testHallway(hp2.point,corner));
        Hallway new_hallway1=new Hallway(hp1.point,corner);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2;
        if (s2.intersectMin.x > s1.intersectMax.x)         new_hallway2=new Hallway(hp2.point,corner);
 else         new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        if (hp1.space.needDoor())         makeDoor(hp1.point,s,true);
        if (hp2.space.needDoor())         makeDoor(hp2.point,s,false);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
 else {
        HallwayPoint hp1;
        HallwayPoint hp2;
        Vec2i corner;
        do {
          int cx=s1.intersectMin.x + rand.getRandom(s1.intersectMax.x - s1.intersectMin.x);
          int cy=s2.intersectMin.y + rand.getRandom(s2.intersectMax.y - s2.intersectMin.y);
          corner=new Vec2i(cx,cy);
          hp1=s1.getHallwayPoint(Split.HOR,(s1.intersectMin.y < s2.intersectMax.y),cx);
          hp2=s2.getHallwayPoint(Split.VER,false,cy);
        }
 while (!testHallway(hp1.point,corner) && !testHallway(hp2.point,corner));
        Hallway new_hallway1;
        if (s1.intersectMin.y < s2.intersectMax.y)         new_hallway1=new Hallway(hp1.point,corner);
 else         new_hallway1=new Hallway(corner,hp1.point);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
    }
    curr.rooms.addAll(s1.rooms);
    curr.rooms.addAll(s2.rooms);
    curr.hallways.addAll(s1.hallways);
    curr.hallways.addAll(s2.hallways);
    int maxIX=Math.max(s1.intersectMax.x,s2.intersectMax.x);
    int maxIY=Math.max(s1.intersectMax.y,s2.intersectMax.y);
    int minIX=Math.min(s1.intersectMin.x,s2.intersectMin.x);
    int minIY=Math.min(s1.intersectMin.y,s2.intersectMin.y);
    curr.intersectMax=new Vec2i(maxIX,maxIY);
    curr.intersectMin=new Vec2i(minIX,minIY);
  }
}","/** 
 * Splits the sublevel recursively until it builds rooms, then connects the rooms together In the end, curr is populated with the current hallways and rooms
 */
private void splitAndBuild(SubLevel curr){
  boolean makeRoom=false;
  int splitAttempts=0;
  if (curr.depth == depthMax) {
    makeRoom=true;
  }
  if (makeRoom) {
    makeRoom(curr);
  }
 else {
    Split s=(rand.getRandom(2) == 0) ? Split.VER : Split.HOR;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.VER;
      }
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        s=Split.HOR;
      }
    }
    SubLevel s1, s2;
    if (s == Split.HOR) {
      float height=(curr.max.y - curr.min.y);
      if (height < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int splitVal=Math.round(curr.min.y + height * splitMin + rand.getRandom(Math.round((height * (splitMax - splitMin)))));
      while (splitVal - curr.min.y < 2 * minWallThickness + minRoomDim || curr.max.y - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        splitVal=Math.round(curr.min.y + height * splitMin + rand.getRandom(Math.round((height * (splitMax - splitMin)))));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(curr.max.x,splitVal),curr.depth + 1);
      s2=new SubLevel(new Vec2i(curr.min.x,splitVal + 1),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
 else {
      float width=(curr.max.x - curr.min.x);
      if (width < 4 * minWallThickness + 2 * minRoomDim) {
        makeRoom(curr);
        return;
      }
      int maxVal=Math.round((width * (splitMax - splitMin)));
      int splitVal=Math.round(curr.min.x + width * splitMin + rand.getRandom(maxVal));
      while (splitVal - curr.min.x < 2 * minWallThickness + minRoomDim || curr.max.x - splitVal - 1 < 2 * minWallThickness + minRoomDim) {
        if (splitAttempts >= splitTries) {
          makeRoom(curr);
          return;
        }
        splitAttempts++;
        maxVal=Math.round((width * (splitMax - splitMin)));
        splitVal=Math.round(curr.min.x + width * splitMin + rand.getRandom(maxVal));
      }
      s1=new SubLevel(new Vec2i(curr.min.x,curr.min.y),new Vec2i(splitVal,curr.max.y),curr.depth + 1);
      s2=new SubLevel(new Vec2i(splitVal + 1,curr.min.y),new Vec2i(curr.max.x,curr.max.y),curr.depth + 1);
    }
    splitAndBuild(s1);
    splitAndBuild(s2);
    Range range=s1.overLap(s2,s);
    if (range != null) {
      int hpt;
      HallwayPoint hp1;
      HallwayPoint hp2;
      do {
        hpt=rand.getRandom(range.min,range.max);
        hp1=s1.getHallwayPoint(s,true,hpt);
        hp2=s2.getHallwayPoint(s,false,hpt);
      }
 while (!testHallway(hp1.point,hp2.point));
      Hallway new_hallway=new Hallway(hp1.point,hp2.point);
      paintHallway(hp1.point,hp2.point,true,TileType.FLOOR);
      hp1.space.connectToHallway(new_hallway);
      hp2.space.connectToHallway(new_hallway);
      if (hp1.space.needDoor())       makeDoor(hp1.point,s,true);
      if (hp2.space.needDoor())       makeDoor(hp2.point,s,false);
      curr.hallways.add(new_hallway);
    }
 else {
      if (s == Split.HOR) {
        HallwayPoint hp1;
        HallwayPoint hp2;
        Vec2i corner;
        do {
          int cx=rand.getRandom(s1.intersectMin.x,s1.intersectMax.x);
          int cy=rand.getRandom(s2.intersectMin.y,s2.intersectMax.y);
          corner=new Vec2i(cx,cy);
          hp1=s1.getHallwayPoint(Split.HOR,true,cx);
          hp2=s2.getHallwayPoint(Split.VER,(s2.intersectMin.x < s1.intersectMax.x),cy);
        }
 while (!testHallway(hp1.point,corner) && !testHallway(hp2.point,corner));
        Hallway new_hallway1=new Hallway(hp1.point,corner);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2;
        if (s2.intersectMin.x > s1.intersectMax.x)         new_hallway2=new Hallway(hp2.point,corner);
 else         new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        if (hp1.space.needDoor())         makeDoor(hp1.point,s,true);
        if (hp2.space.needDoor())         makeDoor(hp2.point,s,false);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
 else {
        HallwayPoint hp1;
        HallwayPoint hp2;
        Vec2i corner;
        do {
          int cx=s1.intersectMin.x + rand.getRandom(s1.intersectMax.x - s1.intersectMin.x);
          int cy=s2.intersectMin.y + rand.getRandom(s2.intersectMax.y - s2.intersectMin.y);
          corner=new Vec2i(cx,cy);
          hp1=s1.getHallwayPoint(Split.HOR,(s1.intersectMin.y < s2.intersectMax.y),cx);
          hp2=s2.getHallwayPoint(Split.VER,false,cy);
        }
 while (!testHallway(hp1.point,corner) && !testHallway(hp2.point,corner));
        Hallway new_hallway1;
        if (s1.intersectMin.y < s2.intersectMax.y)         new_hallway1=new Hallway(hp1.point,corner);
 else         new_hallway1=new Hallway(corner,hp1.point);
        hp1.space.connectToHallway(new_hallway1);
        Hallway new_hallway2=new Hallway(corner,hp2.point);
        hp2.space.connectToHallway(new_hallway2);
        new_hallway1.connectToHallway(new_hallway2);
        paintHallway(hp1.point,corner,true,TileType.FLOOR);
        paintHallway(hp2.point,corner,true,TileType.FLOOR);
        if (hp1.space.needDoor())         makeDoor(hp1.point,s,true);
        if (hp2.space.needDoor())         makeDoor(hp2.point,s,false);
        curr.hallways.add(new_hallway1);
        curr.hallways.add(new_hallway2);
      }
    }
    curr.rooms.addAll(s1.rooms);
    curr.rooms.addAll(s2.rooms);
    curr.hallways.addAll(s1.hallways);
    curr.hallways.addAll(s2.hallways);
    int maxIX=Math.max(s1.intersectMax.x,s2.intersectMax.x);
    int maxIY=Math.max(s1.intersectMax.y,s2.intersectMax.y);
    int minIX=Math.min(s1.intersectMin.x,s2.intersectMin.x);
    int minIY=Math.min(s1.intersectMin.y,s2.intersectMin.y);
    curr.intersectMax=new Vec2i(maxIX,maxIY);
    curr.intersectMin=new Vec2i(minIX,minIY);
  }
}",0.9889333647280432
37965,"/** 
 * Generated
 * @author liam
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((connectedRooms == null) ? 0 : connectedRooms.hashCode());
  result=prime * result + ((max == null) ? 0 : max.hashCode());
  result=prime * result + ((min == null) ? 0 : min.hashCode());
  return result;
}","/** 
 * BEGIN hashCode and equals 
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((connectedRooms == null) ? 0 : connectedRooms.hashCode());
  result=prime * result + (int)(id ^ (id >>> 32));
  result=prime * result + ((max == null) ? 0 : max.hashCode());
  result=prime * result + ((min == null) ? 0 : min.hashCode());
  return result;
}",0.8637602179836512
37966,"/** 
 * Generated
 * @author liam
 */
@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  Room other=(Room)obj;
  if (connectedRooms == null) {
    if (other.connectedRooms != null)     return false;
  }
 else   if (!connectedRooms.equals(other.connectedRooms))   return false;
  if (max == null) {
    if (other.max != null)     return false;
  }
 else   if (!max.equals(other.max))   return false;
  if (min == null) {
    if (other.min != null)     return false;
  }
 else   if (!min.equals(other.min))   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  Room other=(Room)obj;
  if (id == other.id) {
    return true;
  }
  if (max == null) {
    if (other.max != null)     return false;
  }
 else   if (!max.equals(other.max))   return false;
  if (min == null) {
    if (other.min != null)     return false;
  }
 else   if (!min.equals(other.min))   return false;
  if (connectedRooms == null) {
    if (other.connectedRooms != null)     return false;
  }
 else   if (!connectedRooms.equals(other.connectedRooms))   return false;
  return true;
}",0.5460076045627377
37967,"/** 
 * Round trip test succeeds
 * @author liam 
 * @throws IOException 
 * @throws ClassNotFoundException 
 */
@Test public void testRoundTripSerialization() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(r1);
  oos.close();
  byte[] raw=out.toByteArray();
  InputStream in=new ByteArrayInputStream(raw);
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  ois.close();
  assertTrue(o instanceof Room);
  Room r1_ds=(Room)o;
  assertEquals(r1_ds.getConnectedRooms(),r1.getConnectedRooms());
}","/** 
 * Round trip test succeeds
 * @author liam 
 * @throws IOException 
 * @throws ClassNotFoundException 
 */
@Test public void testRoundTripSerialization() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(r1);
  oos.close();
  byte[] raw=out.toByteArray();
  InputStream in=new ByteArrayInputStream(raw);
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  ois.close();
  assertTrue(o instanceof Room);
  Room r1_ds=(Room)o;
  assertEquals(r1_ds.getConnectedRooms(),r1.getConnectedRooms());
  assertEquals(r1_ds,r1);
}",0.980421686746988
37968,"public Hallway(Vec2i startTile,Vec2i endTile){
  this.startTile=endTile;
  this.endTile=endTile;
  rooms=new ArrayList<Room>();
}","public Hallway(Vec2i startTile,Vec2i endTile){
  this.startTile=startTile;
  this.endTile=endTile;
  rooms=new ArrayList<Room>();
}",0.9692307692307692
37969,"public Flip3DAnimation(final float fromDegrees,final float toDegrees,final float centerX,final float centerY){
  mFromDegrees=fromDegrees;
  mToDegrees=toDegrees;
  mCenterX=centerX;
  mCenterY=centerY;
}","public Flip3DAnimation(final float fromDegrees,final float toDegrees,final float centerX,final float centerY){
  super();
  mFromDegrees=fromDegrees;
  mToDegrees=toDegrees;
  mCenterX=centerX;
  mCenterY=centerY;
}",0.973747016706444
37970,"@Override public void onClick(final View view){
  if (isFirstView) {
    applyRotation(0,-90);
    isFirstView=!isFirstView;
  }
 else {
    applyRotation(0,90);
    isFirstView=!isFirstView;
  }
}","@Override public void onClick(final View view){
  if (isFirstView) {
    applyRotation(0,-90);
    isFirstView=false;
  }
 else {
    applyRotation(0,90);
    isFirstView=true;
  }
}",0.934036939313984
37971,"void parseAttributes(final Context context,final AttributeSet attrs){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.Flip3DView);
  try {
    final Drawable front=a.getDrawable(R.styleable.Flip3DView_src_front);
    if (front != null) {
      setImageFrontDrawable(front);
    }
    final Drawable back=a.getDrawable(R.styleable.Flip3DView_src_back);
    if (back != null) {
      setImageBackDrawable(back);
    }
  }
  finally {
    a.recycle();
  }
}","private void parseAttributes(final Context context,final AttributeSet attrs){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.Flip3DView);
  try {
    final Drawable front=a.getDrawable(R.styleable.Flip3DView_src_front);
    if (front != null) {
      setImageFrontDrawable(front);
    }
    final Drawable back=a.getDrawable(R.styleable.Flip3DView_src_back);
    if (back != null) {
      setImageBackDrawable(back);
    }
  }
  finally {
    a.recycle();
  }
}",0.9916666666666668
37972,"private void setImageParameters(final ImageView imageView,final Drawable drawable){
  LayoutParams layoutParams=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,Gravity.CENTER);
  if (drawable instanceof ColorDrawable) {
    layoutParams=new LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT,Gravity.CENTER);
  }
  imageView.setLayoutParams(layoutParams);
  imageView.setImageDrawable(drawable);
}","private final void setImageParameters(final ImageView imageView,final Drawable drawable){
  LayoutParams layoutParams=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,Gravity.CENTER);
  if (drawable instanceof ColorDrawable) {
    layoutParams=new LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT,Gravity.CENTER);
  }
  imageView.setLayoutParams(layoutParams);
  imageView.setImageDrawable(drawable);
}",0.9930715935334872
37973,"public Flip3DView(final Context context){
  super(context);
  initializeViews(context);
}","public Flip3DView(final Context context){
  super(context);
  initializeViews();
}",0.95906432748538
37974,"private void initializeViews(final Context context){
  setImageFrontDrawable(new ColorDrawable(Color.BLUE));
  setImageBackDrawable(new ColorDrawable(Color.RED));
}","private void initializeViews(){
  setImageFrontDrawable(new ColorDrawable(Color.BLUE));
  setImageBackDrawable(new ColorDrawable(Color.RED));
}",0.9315960912052116
37975,"/** 
 * Sets front view on the control.
 * @param viewFront front view
 */
public void setViewFront(final View viewFront){
  if (this.viewFront != null) {
    this.removeView(this.viewFront);
  }
  this.viewFront=viewFront;
  this.addView(viewFront);
}","/** 
 * Sets front view on the control.
 * @param viewFront front view
 */
public final void setViewFront(final View viewFront){
  if (this.viewFront != null) {
    this.removeView(this.viewFront);
  }
  this.viewFront=viewFront;
  this.addView(viewFront);
}",0.9882352941176472
37976,"/** 
 * Sets back view on the control.
 * @param viewBack back view
 */
public void setViewBack(final View viewBack){
  if (this.viewBack != null) {
    this.removeView(this.viewBack);
  }
  this.viewBack=viewBack;
  this.addView(viewBack);
}","/** 
 * Sets back view on the control.
 * @param viewBack back view
 */
public final void setViewBack(final View viewBack){
  if (this.viewBack != null) {
    this.removeView(this.viewBack);
  }
  this.viewBack=viewBack;
  this.addView(viewBack);
}",0.9877551020408164
37977,"private void incrementCommandTimeoutCount(){
  mCommandTimeoutCount++;
  if (mCommandTimeoutCount >= Config.kDeviceMaxTimeout) {
    Utils.log(TAG,""String_Node_Str"" + Config.kDeviceMaxTimeout + ""String_Node_Str"");
    stopDevice();
  }
 else {
    Utils.log(TAG,""String_Node_Str"" + mCommandTimeoutCount);
  }
}","private void incrementCommandTimeoutCount(){
  mCommandTimeoutCount++;
  if (mCommandTimeoutCount >= Config.kDeviceMaxTimeout) {
    Utils.log(TAG,""String_Node_Str"" + Config.kDeviceMaxTimeout + ""String_Node_Str"");
    mServer.removeDevice(this);
  }
 else {
    Utils.log(TAG,""String_Node_Str"" + mCommandTimeoutCount);
  }
}",0.946372239747634
37978,"@Override public void run(){
  try {
    String line;
    while (!mStopThread) {
      if (sockSafeHaveData() && (line=sockSafeReadln()) != null && line.length() > 0) {
        if (line.equals(Config.kDeviceKeepAlive)) {
          replyToKeepAlive();
        }
 else {
          manageCommandReply(line);
        }
        resetCommandTimeoutCount();
      }
      if (isKeepAliveTimeout()) {
        Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
        mStopThread=true;
        break;
      }
      sendUnsentCommands();
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException t) {
      }
    }
    Utils.log(TAG,""String_Node_Str"");
  }
 catch (  Exception eex) {
    Utils.log(TAG,""String_Node_Str"" + eex.getMessage());
  }
 finally {
    mServer.removeDevice(this);
  }
}","@Override public void run(){
  try {
    String line;
    while (!mStopThread) {
      if (sockSafeHaveData() && (line=sockSafeReadln()) != null && line.length() > 0) {
        if (line.equals(Config.kDeviceKeepAlive)) {
          replyToKeepAlive();
        }
 else {
          manageCommandReply(line);
        }
        resetCommandTimeoutCount();
      }
      if (isKeepAliveTimeout()) {
        Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
        mStopThread=true;
        break;
      }
      sendUnsentCommands();
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException t) {
      }
    }
    Utils.log(TAG,""String_Node_Str"");
  }
 catch (  Exception eex) {
    Utils.log(TAG,""String_Node_Str"" + eex.getMessage());
  }
}",0.9676190476190476
37979,"synchronized public void stopDevice(){
  mStopThread=true;
}","/** 
 * Do not use directly. Instead use MainServer.removeDevice(this).
 */
synchronized public void stopDevice(){
  mStopThread=true;
}",0.6122448979591837
37980,"@Override public void run(){
  try {
    Utils.log(TAG,""String_Node_Str"");
    try {
      String strJson=mNewDevice.sockReadln();
      Utils.log(TAG,""String_Node_Str"" + strJson);
      mNewDevice.readWelcomeJSON(strJson);
    }
 catch (    JSONException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
catch (    IOException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
    if (!authenticateDevice()) {
      abortDeviceConnection(""String_Node_Str"");
      return;
    }
    Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
    mServer.addDevice(mNewDevice);
  }
 catch (  Exception ex) {
    abortDeviceConnection(""String_Node_Str"" + ex.getMessage());
  }
}","@Override public void run(){
  try {
    Utils.log(TAG,""String_Node_Str"");
    try {
      String strJson=mNewDevice.sockReadln();
      Utils.log(TAG,""String_Node_Str"" + strJson);
      mNewDevice.parseWelcomeJSON(strJson);
    }
 catch (    JSONException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
catch (    IOException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
    if (!authenticateDevice()) {
      abortDeviceConnection(""String_Node_Str"");
      return;
    }
    Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
    mServer.addDevice(mNewDevice);
  }
 catch (  Exception ex) {
    abortDeviceConnection(""String_Node_Str"" + ex.getMessage());
  }
}",0.9937194696441032
37981,"public int getDevicesCount(){
synchronized (mDevices) {
    return mDevices.size();
  }
}","synchronized public int getDevicesCount(){
  return mDevices.size();
}",0.7169811320754716
37982,"@Override public void run(){
  try {
    Utils.log(TAG,""String_Node_Str"");
    try {
      mNewDevice.readWelcomeJSON();
    }
 catch (    JSONException ex) {
      abortDeviceConnection(ex.getMessage());
    }
catch (    IOException ex) {
      abortDeviceConnection(ex.getMessage());
    }
    if (!authenticateDevice()) {
      abortDeviceConnection(""String_Node_Str"");
    }
    Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
    mServer.addDevice(mNewDevice);
  }
 catch (  Exception ex) {
    abortDeviceConnection(""String_Node_Str"" + ex.getMessage());
  }
}","@Override public void run(){
  try {
    Utils.log(TAG,""String_Node_Str"");
    try {
      mNewDevice.readWelcomeJSON();
    }
 catch (    JSONException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
catch (    IOException ex) {
      abortDeviceConnection(ex.getMessage());
      return;
    }
    if (!authenticateDevice()) {
      abortDeviceConnection(""String_Node_Str"");
      return;
    }
    Utils.log(TAG,""String_Node_Str"" + ""String_Node_Str"");
    mServer.addDevice(mNewDevice);
  }
 catch (  Exception ex) {
    abortDeviceConnection(""String_Node_Str"" + ex.getMessage());
  }
}",0.964527027027027
37983,"private void testing(Context context,AttributeSet attrs){
  this.setBackground(getResources().getDrawable(R.drawable.background));
  if (attrs != null) {
    TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
    normalStatecolor=tA.getString(R.styleable.wingokuflatui_normalStateColor);
    pressedStateColor=tA.getString(R.styleable.wingokuflatui_pressedStateColor);
    tA.recycle();
  }
 else {
    normalStatecolor=pressedStateColor=""String_Node_Str"";
  }
  this.getBackground().setColorFilter(Color.parseColor(normalStatecolor),PorterDuff.Mode.DARKEN);
  this.setOnTouchListener(new OnTouchListener(){
    @Override public boolean onTouch(    View arg0,    MotionEvent event){
      final String color;
      if (event.getAction() == MotionEvent.ACTION_UP) {
        color=normalStatecolor;
      }
 else       color=pressedStateColor;
      new Handler().postDelayed(new Runnable(){
        @Override public void run(){
          WinGokuFlatButton.this.getBackground().setColorFilter(Color.parseColor(color),PorterDuff.Mode.DARKEN);
        }
      }
,30);
      return false;
    }
  }
);
}","private void testing(Context context,AttributeSet attrs){
  if (!isInEditMode()) {
    this.setBackground(getResources().getDrawable(R.drawable.background));
    if (attrs != null) {
      TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
      normalStatecolor=tA.getString(R.styleable.wingokuflatui_normalStateColor);
      pressedStateColor=tA.getString(R.styleable.wingokuflatui_pressedStateColor);
      tA.recycle();
    }
 else {
      normalStatecolor=pressedStateColor=""String_Node_Str"";
    }
    this.getBackground().setColorFilter(Color.parseColor(normalStatecolor),PorterDuff.Mode.DARKEN);
    this.setOnTouchListener(new OnTouchListener(){
      @Override public boolean onTouch(      View arg0,      MotionEvent event){
        final String color;
        if (event.getAction() == MotionEvent.ACTION_UP) {
          color=normalStatecolor;
        }
 else         color=pressedStateColor;
        new Handler().postDelayed(new Runnable(){
          @Override public void run(){
            WinGokuFlatButton.this.getBackground().setColorFilter(Color.parseColor(color),PorterDuff.Mode.DARKEN);
          }
        }
,30);
        return false;
      }
    }
);
  }
}",0.9644539614561028
37984,"private void initializeShit(Context context,AttributeSet attrs){
  setText(""String_Node_Str"");
  this.setBackground(getResources().getDrawable(R.drawable.checkbox_background));
  TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
  final String userColor=tA.getString(R.styleable.wingokuflatui_cbColor);
  tA.recycle();
  if (userColor == null || userColor.isEmpty()) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final GradientDrawable gDrawable=(GradientDrawable)this.getBackground();
  gDrawable.setStroke(width,Color.parseColor(userColor));
  gDrawable.setCornerRadius(cornerRadii);
  this.setBackground(gDrawable);
  setInsides(Color.TRANSPARENT);
  this.setOnTouchListener(new OnTouchListener(){
    @Override public boolean onTouch(    View arg0,    MotionEvent event){
      isCheckBoxEnabled();
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (!isChecked) {
          isChecked=true;
          setInsides(Color.parseColor(userColor));
          WinGokuFlatCheckBox.this.invalidate();
        }
 else {
          isChecked=false;
          setInsides(Color.TRANSPARENT);
          WinGokuFlatCheckBox.this.invalidate();
        }
      }
      return false;
    }
  }
);
}","private void initializeShit(Context context,AttributeSet attrs){
  if (!isInEditMode()) {
    setText(""String_Node_Str"");
    this.setBackground(getResources().getDrawable(R.drawable.checkbox_background));
    TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
    final String userColor=tA.getString(R.styleable.wingokuflatui_cbColor);
    tA.recycle();
    if (userColor == null || userColor.isEmpty()) {
      throw new NullPointerException(""String_Node_Str"");
    }
    final GradientDrawable gDrawable=(GradientDrawable)this.getBackground();
    gDrawable.setStroke(width,Color.parseColor(userColor));
    gDrawable.setCornerRadius(cornerRadii);
    this.setBackground(gDrawable);
    setInsides(Color.TRANSPARENT);
    this.setOnTouchListener(new OnTouchListener(){
      @Override public boolean onTouch(      View arg0,      MotionEvent event){
        isCheckBoxEnabled();
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
          if (!isChecked) {
            isChecked=true;
            setInsides(Color.parseColor(userColor));
            WinGokuFlatCheckBox.this.invalidate();
          }
 else {
            isChecked=false;
            setInsides(Color.TRANSPARENT);
            WinGokuFlatCheckBox.this.invalidate();
          }
        }
        return false;
      }
    }
);
  }
}",0.9640232108317216
37985,"private void initialize(Context context,AttributeSet attrs){
  this.setBackground(getResources().getDrawable(R.drawable.background));
  TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
  backgroundColor=tA.getString(R.styleable.wingokuflatui_backgroundColor);
  tA.recycle();
  this.getBackground().setColorFilter(Color.parseColor(backgroundColor),PorterDuff.Mode.DARKEN);
}","private void initialize(Context context,AttributeSet attrs){
  if (!isInEditMode()) {
    this.setBackground(getResources().getDrawable(R.drawable.background));
    TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
    backgroundColor=tA.getString(R.styleable.wingokuflatui_backgroundColor);
    tA.recycle();
    this.getBackground().setColorFilter(Color.parseColor(backgroundColor),PorterDuff.Mode.DARKEN);
  }
}",0.9539551357733176
37986,"private void initializeShit(Context context,AttributeSet attrs){
  if (!isInEditMode()) {
    setText(""String_Node_Str"");
    this.setBackground(getResources().getDrawable(R.drawable.checkbox_background));
    TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
    final String userColor=tA.getString(R.styleable.wingokuflatui_cbColor);
    tA.recycle();
    if (userColor == null || userColor.isEmpty()) {
      throw new NullPointerException(""String_Node_Str"");
    }
    final GradientDrawable gDrawable=(GradientDrawable)this.getBackground();
    gDrawable.setStroke(width,Color.parseColor(userColor));
    gDrawable.setCornerRadius(cornerRadii);
    this.setBackground(gDrawable);
    setInsides(Color.TRANSPARENT);
    this.setOnTouchListener(new OnTouchListener(){
      @Override public boolean onTouch(      View arg0,      MotionEvent event){
        isCheckBoxEnabled();
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
          if (!isChecked) {
            isChecked=true;
            setInsides(Color.parseColor(userColor));
            WinGokuFlatCheckBox.this.invalidate();
          }
 else {
            isChecked=false;
            setInsides(Color.TRANSPARENT);
            WinGokuFlatCheckBox.this.invalidate();
          }
        }
        return false;
      }
    }
);
  }
}","private void initializeShit(Context context,AttributeSet attrs){
  if (!isInEditMode()) {
    TypedArray tA=context.obtainStyledAttributes(attrs,R.styleable.wingokuflatui);
    final String userColor=tA.getString(R.styleable.wingokuflatui_cbColor);
    tA.recycle();
    if (userColor == null || userColor.isEmpty()) {
      throw new NullPointerException(""String_Node_Str"");
    }
    setDrawables(userColor);
  }
}",0.4592592592592592
37987,"private static void init(){
  long start=Calendar.getInstance().getTimeInMillis();
  StringBuilder bud=new StringBuilder();
  bud.append(""String_Node_Str"");
  bud.append(""String_Node_Str"").append(LicenseS.CONTROLLER_V);
  bud.append(""String_Node_Str"").append(LicenseS.PORT_V);
  bud.append(""String_Node_Str"").append(LicenseS.USERNAME_V);
  bud.append(""String_Node_Str"").append(LicenseS.SSL_V);
  bud.append(""String_Node_Str"").append(LicenseS.ACCOUNT_V);
  bud.append(""String_Node_Str"").append(LicenseS.FILENAME_V);
  bud.append(""String_Node_Str"").append(LicenseS.INTERVAL_V);
  bud.append(""String_Node_Str"").append(LicenseS.UPTIME_V);
  bud.append(""String_Node_Str"").append(LicenseS.GROUP_V);
  bud.append(""String_Node_Str"").append(LicenseS.DEBUG_V).append(""String_Node_Str"");
  if (s.debugLevel > 0)   logger.log(Level.INFO,bud.toString());
  RESTAccess access=new RESTAccess(LicenseS.CONTROLLER_V,LicenseS.PORT_V,LicenseS.SSL_V,LicenseS.USERNAME_V,LicenseS.PASSWD_V,LicenseS.ACCOUNT_V);
  Applications apps=access.getApplications();
  if (apps == null) {
    logger.log(Level.SEVERE,""String_Node_Str"");
    System.exit(1);
  }
  CustomerLicenseCount customer=new CustomerLicenseCount(LicenseS.ACCOUNT_V);
  logger.log(Level.INFO,""String_Node_Str"");
  for (  Application appD : apps.getApplications()) {
    if (!LicenseS.APPS_V.isEmpty()) {
      if (LicenseS.APPS_V.contains(appD.getName())) {
        ApplicationLicenseCount appCount=new ApplicationLicenseCount(appD.getName(),appD.getId());
        customer.addApplication(appCount);
      }
    }
 else {
      ApplicationLicenseCount appCount=new ApplicationLicenseCount(appD.getName(),appD.getId());
      customer.addApplication(appCount);
    }
  }
  if (customer.getApplications().size() == 0) {
    logger.log(Level.WARNING,new StringBuilder().append(""String_Node_Str"").toString());
    System.exit(0);
  }
  logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(customer.getApplications().size()).append(""String_Node_Str"").toString());
  customer.populateApplications(access,LicenseS.INTERVAL_V);
  customer.countTierLicenses();
  WriteExcelDoc excel=new WriteExcelDoc(customer);
  excel.init();
  long end=Calendar.getInstance().getTimeInMillis();
  long total=(end - start) / 1000;
  logger.log(Level.INFO,""String_Node_Str"" + total);
}","private static void init(){
  long start=Calendar.getInstance().getTimeInMillis();
  StringBuilder bud=new StringBuilder();
  bud.append(""String_Node_Str"");
  bud.append(""String_Node_Str"").append(LicenseS.CONTROLLER_V);
  bud.append(""String_Node_Str"").append(LicenseS.PORT_V);
  bud.append(""String_Node_Str"").append(LicenseS.USERNAME_V);
  bud.append(""String_Node_Str"").append(LicenseS.SSL_V);
  bud.append(""String_Node_Str"").append(LicenseS.ACCOUNT_V);
  bud.append(""String_Node_Str"").append(LicenseS.FILENAME_V);
  bud.append(""String_Node_Str"").append(LicenseS.INTERVAL_V);
  bud.append(""String_Node_Str"").append(LicenseS.UPTIME_V);
  bud.append(""String_Node_Str"").append(LicenseS.GROUP_V);
  bud.append(""String_Node_Str"").append(LicenseS.DEBUG_V).append(""String_Node_Str"");
  if (s.debugLevel > 0)   logger.log(Level.INFO,bud.toString());
  RESTAccess access=new RESTAccess(LicenseS.CONTROLLER_V,LicenseS.PORT_V,LicenseS.SSL_V,LicenseS.USERNAME_V,LicenseS.PASSWD_V,LicenseS.ACCOUNT_V);
  Applications apps=access.getApplications();
  if (apps == null) {
    logger.log(Level.SEVERE,""String_Node_Str"");
    System.exit(1);
  }
  CustomerLicenseCount customer=new CustomerLicenseCount(LicenseS.ACCOUNT_V);
  logger.log(Level.INFO,""String_Node_Str"");
  for (  Application appD : apps.getApplications()) {
    if (!LicenseS.APPS_V.isEmpty()) {
      if (LicenseS.APPS_V.contains(appD.getName())) {
        ApplicationLicenseCount appCount=new ApplicationLicenseCount(appD.getName(),appD.getId());
        customer.addApplication(appCount);
      }
    }
 else {
      ApplicationLicenseCount appCount=new ApplicationLicenseCount(appD.getName(),appD.getId());
      customer.addApplication(appCount);
    }
  }
  if (customer.getApplications().isEmpty()) {
    logger.log(Level.WARNING,new StringBuilder().append(""String_Node_Str"").toString());
    System.exit(0);
  }
  logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(customer.getApplications().size()).append(""String_Node_Str"").toString());
  customer.populateApplications(access,LicenseS.INTERVAL_V);
  customer.countTierLicenses();
  WriteExcelDoc excel=new WriteExcelDoc(customer);
  excel.init();
  long end=Calendar.getInstance().getTimeInMillis();
  long total=(end - start) / 1000;
  logger.log(Level.INFO,""String_Node_Str"" + total);
}",0.9956896551724138
37988,"@Override public void run(){
  MetricDatas mDatas=access.getRESTMetricQuery(nodeLic.getQueryType(),appName,nodeLic.getNode().getTierName(),nodeLic.getNode().getName(),totalTimeRange.getStart(),totalTimeRange.getEnd());
  nodeLic.getTotalRangeValue().setStart(totalTimeRange.getStart());
  nodeLic.getTotalRangeValue().setEnd(totalTimeRange.getEnd());
  nodeLic.getTotalRangeValue().setMetricValues(nodeLic.getMetricValues(mDatas));
  if (nodeLic.getType() == 5 && timeRanges.size() > 0) {
    if (nodeLic.checkIfNotJava(access,appName,timeRanges.get(0).getStart(),timeRanges.get(0).getEnd())) {
      if (s.debugLevel >= 2)       logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").toString());
      boolean fnd=false;
      if (nodeLic.checkIfPHP(tierAgentType)) {
        nodeLic.setType(2);
        fnd=true;
      }
      if (nodeLic.checkIfNodeJs(tierAgentType)) {
        nodeLic.setType(3);
        fnd=true;
      }
      if (nodeLic.checkIfDotNet(tierAgentType)) {
        nodeLic.setType(1);
        fnd=true;
      }
      if (!fnd)       nodeLic.setType(2);
    }
 else {
      nodeLic.setType(0);
    }
  }
  for (  TimeRange tRange : timeRanges) {
    NodeLicenseRange nodeR=new NodeLicenseRange();
    nodeR.setStart(tRange.getStart());
    nodeR.setEnd(tRange.getEnd());
    nodeR.setName(nodeR.createName());
    for (    MetricValue val : nodeLic.getTotalRangeValue().getMetricValues().getMetricValue()) {
      if (nodeR.withIn(val.getStartTimeInMillis()))       nodeR.getMetricValues().getMetricValue().add(val);
    }
    nodeLic.getRangeValues().add(nodeR);
  }
}","@Override public void run(){
  MetricDatas mDatas=access.getRESTMetricQuery(nodeLic.getQueryType(),appName,nodeLic.getNode().getTierName(),nodeLic.getNode().getName(),totalTimeRange.getStart(),totalTimeRange.getEnd());
  nodeLic.getTotalRangeValue().setStart(totalTimeRange.getStart());
  nodeLic.getTotalRangeValue().setEnd(totalTimeRange.getEnd());
  nodeLic.getTotalRangeValue().setMetricValues(nodeLic.getMetricValues(mDatas));
  if (nodeLic.getType() == 5 && timeRanges.size() > 0) {
    if (nodeLic.checkIfNotJava(access,appName,timeRanges.get(0).getStart(),timeRanges.get(0).getEnd())) {
      if (s.debugLevel >= 2)       logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(tierAgentType).toString());
      boolean fnd=false;
      if (nodeLic.checkIfWebServer(tierAgentType)) {
        nodeLic.setType(6);
        fnd=true;
      }
      if (!fnd && nodeLic.checkIfPHP(tierAgentType)) {
        nodeLic.setType(2);
        fnd=true;
      }
      if (!fnd && nodeLic.checkIfNodeJs(tierAgentType)) {
        nodeLic.setType(3);
        fnd=true;
      }
      if (!fnd && nodeLic.checkIfDotNet(tierAgentType)) {
        nodeLic.setType(1);
        fnd=true;
      }
      if (!fnd)       nodeLic.setType(2);
    }
 else {
      nodeLic.setType(0);
    }
  }
  for (  TimeRange tRange : timeRanges) {
    NodeLicenseRange nodeR=new NodeLicenseRange();
    nodeR.setStart(tRange.getStart());
    nodeR.setEnd(tRange.getEnd());
    nodeR.setName(nodeR.createName());
    for (    MetricValue val : nodeLic.getTotalRangeValue().getMetricValues().getMetricValue()) {
      if (nodeR.withIn(val.getStartTimeInMillis()))       nodeR.getMetricValues().getMetricValue().add(val);
    }
    nodeLic.getRangeValues().add(nodeR);
  }
}",0.9544235924932976
37989,"public void countTierLicenses(ArrayList<TimeRange> timeRanges){
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").toString());
  populateDotNetMap();
  for (  TierLicenseCount tCount : tierLicenses.values()) {
    tCount.countNodeLicenses(timeRanges,dotNetMap,dotNetKeys);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    ApplicationLicenseRange aRange=new ApplicationLicenseRange();
    aRange.setStart(timeRanges.get(i).getStart());
    aRange.setEnd(timeRanges.get(i).getEnd());
    aRange.setName(aRange.createName());
    for (    TierLicenseCount tCount : tierLicenses.values()) {
      TierLicenseRange tRange=tCount.getTierLicenseRange().get(i);
      aRange.iisCount+=tRange.getIisCount();
      aRange.javaCount+=tRange.getJavaCount();
      aRange.nodeJSCount+=tRange.getNodeJSCount();
      aRange.machineCount+=tRange.getMachineCount();
      aRange.phpCount+=tRange.getPhpCount();
      aRange.totalCount+=tRange.getTotalCount();
      aRange.iisInternalCount+=tRange.iisInternalCount;
    }
    appLicenseRange.add(aRange);
  }
  ArrayList<TimeRange> hourlyTimeRanges=TimeRangeHelper.getHourlyTimeRanges(totalRangeValue.getStart(),totalRangeValue.getEnd());
  for (int i=0; i < hourlyTimeRanges.size(); i++) {
    AppHourLicenseRange app=new AppHourLicenseRange(hourlyTimeRanges.get(i));
    for (    TierLicenseCount tCount : tierLicenses.values()) {
      for (      TierHourLicenseRange tRange : tCount.getTierHourLicenseRange()) {
        if (app.withIn(tRange)) {
          app.appAgent+=tRange.appAgent;
          app.machineAgent+=tRange.machineAgent;
        }
      }
    }
    appHourLicenseRange.add(app);
  }
  for (  ApplicationLicenseRange tRange : appLicenseRange) {
    totalRangeValue.iisCount+=tRange.iisCount;
    totalRangeValue.javaCount+=tRange.javaCount;
    totalRangeValue.phpCount+=tRange.phpCount;
    totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
    totalRangeValue.machineCount+=tRange.machineCount;
    totalRangeValue.totalCount+=tRange.totalCount;
    totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
  }
}","public void countTierLicenses(ArrayList<TimeRange> timeRanges){
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").toString());
  populateDotNetMap();
  for (  TierLicenseCount tCount : tierLicenses.values()) {
    tCount.countNodeLicenses(timeRanges,dotNetMap,dotNetKeys);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    ApplicationLicenseRange aRange=new ApplicationLicenseRange();
    aRange.setStart(timeRanges.get(i).getStart());
    aRange.setEnd(timeRanges.get(i).getEnd());
    aRange.setName(aRange.createName());
    for (    TierLicenseCount tCount : tierLicenses.values()) {
      TierLicenseRange tRange=tCount.getTierLicenseRange().get(i);
      aRange.iisCount+=tRange.getIisCount();
      aRange.javaCount+=tRange.getJavaCount();
      aRange.nodeJSCount+=tRange.getNodeJSCount();
      aRange.machineCount+=tRange.getMachineCount();
      aRange.phpCount+=tRange.getPhpCount();
      aRange.totalCount+=tRange.getTotalCount();
      aRange.iisInternalCount+=tRange.iisInternalCount;
      aRange.webserverCount+=tRange.webserverCount;
    }
    if (aRange.getNodeJSCount() > 0)     aRange.totalCount=(aRange.getTotalCount() - aRange.getNodeJSCount()) + licenseRound(aRange.getNodeJSCount() / 10);
    appLicenseRange.add(aRange);
  }
  ArrayList<TimeRange> hourlyTimeRanges=TimeRangeHelper.getHourlyTimeRanges(totalRangeValue.getStart(),totalRangeValue.getEnd());
  for (int i=0; i < hourlyTimeRanges.size(); i++) {
    AppHourLicenseRange app=new AppHourLicenseRange(hourlyTimeRanges.get(i));
    for (    TierLicenseCount tCount : tierLicenses.values()) {
      for (      TierHourLicenseRange tRange : tCount.getTierHourLicenseRange()) {
        if (app.withIn(tRange)) {
          app.appAgent+=tRange.appAgent;
          app.machineAgent+=tRange.machineAgent;
        }
      }
    }
    appHourLicenseRange.add(app);
  }
  for (  ApplicationLicenseRange tRange : appLicenseRange) {
    totalRangeValue.iisCount+=tRange.iisCount;
    totalRangeValue.javaCount+=tRange.javaCount;
    totalRangeValue.phpCount+=tRange.phpCount;
    totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
    totalRangeValue.machineCount+=tRange.machineCount;
    totalRangeValue.totalCount+=tRange.totalCount;
    totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
    totalRangeValue.webserverCount+=tRange.webserverCount;
  }
}",0.9406798489224616
37990,"public void countTierLicenses(){
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").toString());
  for (  ApplicationLicenseCount tCount : applications.values()) {
    tCount.countTierLicenses(timeRanges);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    CustomerLicenseRange aRange=new CustomerLicenseRange();
    aRange.setStart(timeRanges.get(i).getStart());
    aRange.setEnd(timeRanges.get(i).getEnd());
    aRange.setName(aRange.createName());
    for (    ApplicationLicenseCount tCount : applications.values()) {
      TierLicenseRange tRange=tCount.getAppLicenseRange().get(i);
      aRange.iisCount+=tRange.getIisCount();
      aRange.javaCount+=tRange.getJavaCount();
      aRange.nodeJSCount+=tRange.getNodeJSCount();
      aRange.machineCount+=tRange.getMachineCount();
      aRange.phpCount+=tRange.getPhpCount();
      aRange.totalCount+=tRange.getTotalCount();
      aRange.iisInternalCount+=tRange.getIisInternalCount();
    }
    aRange.iisCount=licenseRound(aRange.iisCount);
    aRange.totalCount=licenseRound(aRange.totalCount);
    customerRangeValues.add(aRange);
  }
  for (  CustomerLicenseRange tRange : customerRangeValues) {
    totalRangeValue.iisCount+=tRange.iisCount;
    totalRangeValue.javaCount+=tRange.javaCount;
    totalRangeValue.phpCount+=tRange.phpCount;
    totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
    totalRangeValue.machineCount+=tRange.machineCount;
    totalRangeValue.totalCount+=tRange.totalCount;
    totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
  }
}","public void countTierLicenses(){
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").toString());
  for (  ApplicationLicenseCount tCount : applications.values()) {
    tCount.countTierLicenses(timeRanges);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    CustomerLicenseRange aRange=new CustomerLicenseRange();
    aRange.setStart(timeRanges.get(i).getStart());
    aRange.setEnd(timeRanges.get(i).getEnd());
    aRange.setName(aRange.createName());
    for (    ApplicationLicenseCount tCount : applications.values()) {
      TierLicenseRange tRange=tCount.getAppLicenseRange().get(i);
      aRange.iisCount+=tRange.getIisCount();
      aRange.javaCount+=tRange.getJavaCount();
      aRange.nodeJSCount+=tRange.getNodeJSCount();
      aRange.machineCount+=tRange.getMachineCount();
      aRange.phpCount+=tRange.getPhpCount();
      aRange.totalCount+=tRange.getTotalCount();
      aRange.iisInternalCount+=tRange.getIisInternalCount();
      aRange.webserverCount+=tRange.getWebserverCount();
    }
    aRange.iisCount=licenseRound(aRange.iisCount);
    aRange.totalCount=licenseRound(aRange.totalCount);
    if (aRange.nodeJSCount > 0)     aRange.totalCount=licenseRound(aRange.iisCount) + licenseRound(aRange.getNodeJSCount() / 10) + aRange.phpCount+ aRange.getJavaCount()+ aRange.getMachineCount()+ aRange.getWebserverCount();
    customerRangeValues.add(aRange);
  }
  for (  CustomerLicenseRange tRange : customerRangeValues) {
    totalRangeValue.iisCount+=tRange.iisCount;
    totalRangeValue.javaCount+=tRange.javaCount;
    totalRangeValue.phpCount+=tRange.phpCount;
    totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
    totalRangeValue.machineCount+=tRange.machineCount;
    totalRangeValue.totalCount+=tRange.totalCount;
    totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
    totalRangeValue.webserverCount+=tRange.webserverCount;
  }
}",0.9021520803443328
37991,"public static int licenseRound(double licenseC){
  String numString=new Double(licenseC).toString();
  if (numString.contains(""String_Node_Str"")) {
    String decimalValue=numString.split(""String_Node_Str"")[1];
    String integerValue=numString.split(""String_Node_Str"")[0];
    try {
      Double decimalDouble=new Double(decimalValue);
      Integer value=new Integer(integerValue);
      if (decimalDouble > 0)       return (value + 1);
    }
 catch (    Exception e) {
    }
  }
  return new Double(licenseC).intValue();
}","public static int licenseRound(double licenseC){
  String numString=Double.toString(licenseC);
  if (numString.contains(""String_Node_Str"")) {
    String decimalValue=numString.split(""String_Node_Str"")[1];
    String integerValue=numString.split(""String_Node_Str"")[0];
    try {
      Double decimalDouble=new Double(decimalValue);
      Integer value=new Integer(integerValue);
      if (decimalDouble > 0)       return (value + 1);
    }
 catch (    Exception e) {
    }
  }
  return new Double(licenseC).intValue();
}",0.9770114942528736
37992,"public String getAgentName(int agentId){
  String val=s.AGENT_NAME_JAVA;
switch (agentId) {
case 1:
    val=s.AGENT_NAME_DOTNET;
  break;
case 2:
val=s.AGENT_NAME_PHP;
break;
case 3:
val=s.AGENT_NAME_NODEJS;
break;
case 4:
val=s.AGENT_NAME_MACHINE_AGENT;
break;
case 5:
val=LicenseS.AGENT_NAME_OTHER_AGENT;
break;
default :
break;
}
return val;
}","public String getAgentName(int agentId){
  String val=s.AGENT_NAME_JAVA;
switch (agentId) {
case 1:
    val=s.AGENT_NAME_DOTNET;
  break;
case 2:
val=s.AGENT_NAME_PHP;
break;
case 3:
val=s.AGENT_NAME_NODEJS;
break;
case 4:
val=s.AGENT_NAME_MACHINE_AGENT;
break;
case 5:
val=LicenseS.AGENT_NAME_OTHER_AGENT;
break;
case 6:
val=s.AGENT_NAME_WEB_SERVER;
default :
break;
}
return val;
}",0.9492455418381344
37993,"public boolean checkIfNotJava(RESTAccess access,String app,long start,long end){
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(node.getName()).append(""String_Node_Str"").append(node.getTierName()).toString());
  MetricDatas mds=access.getRESTMetricQuery(25,app,node.getTierName(),node.getName(),start,end);
  if (mds != null && mds.getMetric_data() != null && mds.getMetric_data().size() == 0)   return true;
  return false;
}","public boolean checkIfNotJava(RESTAccess access,String app,long start,long end){
  MetricDatas mds=access.getRESTMetricQuery(25,app,node.getTierName(),node.getName(),start,end);
  if (s.debugLevel >= 2)   logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(node.getName()).append(""String_Node_Str"").append(node.getTierName()).toString());
  if (mds != null && mds.getMetric_data() != null && mds.getMetric_data().size() == 0)   return true;
  return false;
}",0.7983367983367984
37994,"public void countNodeLicenses(ArrayList<TimeRange> timeRanges,HashMap<String,ArrayList<Node>> dotNetMap,ArrayList<String> dotNetKeys){
  logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(name).toString());
  for (  NodeLicenseCount nodeL : nodeLicenseCount) {
    nodeL.countNodeLicenseRange(s.percentageThreshold);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    TierLicenseRange tRange=new TierLicenseRange();
    tRange.setStart(timeRanges.get(i).getStart());
    tRange.setEnd(timeRanges.get(i).getEnd());
    tRange.setName(tRange.createName());
    HashMap<String,ArrayList<Node>> dotNetMapTemp=new HashMap<String,ArrayList<Node>>(dotNetMap);
    ArrayList<String> found=new ArrayList<String>();
    for (    NodeLicenseCount node : nodeLicenseCount) {
      if (node.getRangeValues().size() > i && node.getRangeValues().get(i).isCountAsLicense()) {
switch (node.getType()) {
case 1:
          StringBuilder bud=new StringBuilder();
        bud.append(""String_Node_Str"").append(node.getNode().getName()).append(""String_Node_Str"").append(tRange.iisCount);
      if (dotNetMapTemp.containsKey(node.getMachineName()) && !found.contains(node.getMachineName()) && !dotNetKeys.contains(getNodeKey(tRange,node.getMachineName()))) {
        tRange.iisCount++;
        tRange.totalCount++;
        found.add(node.getMachineName());
        dotNetKeys.add(getNodeKey(tRange,node.getMachineName()));
        bud.append(""String_Node_Str"").append(tRange.getStart()).append(""String_Node_Str"").append(tRange.getEnd());
        bud.append(""String_Node_Str"").append(node.getNode().getTierName());
      }
    bud.append(""String_Node_Str"").append(tRange.iisInternalCount);
  tRange.iisInternalCount++;
bud.append(""String_Node_Str"").append(tRange.iisCount).append(""String_Node_Str"").append(tRange.iisInternalCount);
break;
case 2:
tRange.phpCount++;
tRange.totalCount++;
break;
case 3:
tRange.nodeJSCount++;
tRange.totalCount++;
break;
case 4:
tRange.machineCount++;
tRange.totalCount++;
break;
default :
tRange.javaCount++;
tRange.totalCount++;
break;
}
}
}
tierLicenseRange.add(tRange);
}
for (TierLicenseRange tRange : tierLicenseRange) {
totalRangeValue.iisCount+=tRange.iisCount;
totalRangeValue.javaCount+=tRange.javaCount;
totalRangeValue.phpCount+=tRange.phpCount;
totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
totalRangeValue.machineCount+=tRange.machineCount;
totalRangeValue.totalCount+=tRange.totalCount;
totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
}
}","public void countNodeLicenses(ArrayList<TimeRange> timeRanges,HashMap<String,ArrayList<Node>> dotNetMap,ArrayList<String> dotNetKeys){
  logger.log(Level.INFO,new StringBuilder().append(""String_Node_Str"").append(name).toString());
  for (  NodeLicenseCount nodeL : nodeLicenseCount) {
    nodeL.countNodeLicenseRange(s.percentageThreshold);
  }
  for (int i=0; i < timeRanges.size(); i++) {
    TierLicenseRange tRange=new TierLicenseRange();
    tRange.setStart(timeRanges.get(i).getStart());
    tRange.setEnd(timeRanges.get(i).getEnd());
    tRange.setName(tRange.createName());
    HashMap<String,ArrayList<Node>> dotNetMapTemp=new HashMap<String,ArrayList<Node>>(dotNetMap);
    ArrayList<String> found=new ArrayList<String>();
    for (    NodeLicenseCount node : nodeLicenseCount) {
      if (node.getRangeValues().size() > i && node.getRangeValues().get(i).isCountAsLicense()) {
switch (node.getType()) {
case 1:
          StringBuilder bud=new StringBuilder();
        bud.append(""String_Node_Str"").append(node.getNode().getName()).append(""String_Node_Str"").append(tRange.iisCount);
      if (dotNetMapTemp.containsKey(node.getMachineName()) && !found.contains(node.getMachineName()) && !dotNetKeys.contains(getNodeKey(tRange,node.getMachineName()))) {
        tRange.iisCount++;
        tRange.totalCount++;
        found.add(node.getMachineName());
        dotNetKeys.add(getNodeKey(tRange,node.getMachineName()));
        bud.append(""String_Node_Str"").append(tRange.getStart()).append(""String_Node_Str"").append(tRange.getEnd());
        bud.append(""String_Node_Str"").append(node.getNode().getTierName());
      }
    bud.append(""String_Node_Str"").append(tRange.iisInternalCount);
  tRange.iisInternalCount++;
bud.append(""String_Node_Str"").append(tRange.iisCount).append(""String_Node_Str"").append(tRange.iisInternalCount);
break;
case 2:
tRange.phpCount++;
tRange.totalCount++;
break;
case 3:
tRange.nodeJSCount++;
tRange.totalCount++;
break;
case 4:
tRange.machineCount++;
tRange.totalCount++;
break;
case 6:
tRange.webserverCount++;
tRange.totalCount++;
default :
tRange.javaCount++;
tRange.totalCount++;
break;
}
}
}
tierLicenseRange.add(tRange);
}
for (TierLicenseRange tRange : tierLicenseRange) {
totalRangeValue.iisCount+=tRange.iisCount;
totalRangeValue.javaCount+=tRange.javaCount;
totalRangeValue.phpCount+=tRange.phpCount;
totalRangeValue.nodeJSCount+=tRange.nodeJSCount;
totalRangeValue.machineCount+=tRange.machineCount;
totalRangeValue.totalCount+=tRange.totalCount;
totalRangeValue.iisInternalCount+=tRange.iisInternalCount;
totalRangeValue.webserverCount+=tRange.webserverCount;
}
}",0.9786651008025052
37995,"public NodeLicenseCount addNodeRange(Node node){
  NodeLicenseCount nodeL=new NodeLicenseCount(node);
  nodeCount++;
  nodeLicenseCount.add(nodeL);
  return nodeL;
}","public NodeLicenseCount addNodeRange(Node node){
  NodeLicenseCount nodeL=null;
  try {
    nodeL=new NodeLicenseCount(node);
    nodeCount++;
    nodeLicenseCount.add(nodeL);
  }
 catch (  Exception e) {
    StringBuilder bud=new StringBuilder();
    bud.append(""String_Node_Str"").append(node.toString()).append(""String_Node_Str"");
    logger.log(Level.SEVERE,bud.toString());
  }
  return nodeL;
}",0.5354609929078015
37996,"public static Optional<UnsafeCodec> factory(CodecSupplier registry,FieldWrapper field){
  Class<?> arrayType=field.type();
  if (arrayType.isArray()) {
    Class<?> componentType=arrayType.getComponentType();
    FieldWrapper componentWrapper=FieldWrapper.clazz(componentType);
    UnsafeCodec componentCodec=registry.getCodec(componentWrapper).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + componentWrapper.name()));
    long baseOffset=UnsafeAccess.unsafe.arrayBaseOffset(arrayType);
    long indexScale=UnsafeAccess.unsafe.arrayIndexScale(arrayType);
    ArrayCodec codec=new ArrayCodec(componentType,componentCodec,baseOffset,indexScale);
    return Optional.of(new UnsafeByteCodec<>(codec));
  }
  return Optional.empty();
}","public static Optional<UnsafeCodec> factory(CodecSupplier registry,FieldWrapper field){
  Class<?> arrayType=field.type();
  if (arrayType.isArray()) {
    Class<?> componentType=arrayType.getComponentType();
    FieldWrapper componentWrapper=FieldWrapper.clazz(componentType);
    UnsafeCodec componentCodec=registry.getCodecOrThrow(componentWrapper);
    long baseOffset=UnsafeAccess.unsafe.arrayBaseOffset(arrayType);
    long indexScale=UnsafeAccess.unsafe.arrayIndexScale(arrayType);
    ArrayCodec codec=new ArrayCodec(componentType,componentCodec,baseOffset,indexScale);
    return Optional.of(new UnsafeByteCodec<>(codec));
  }
  return Optional.empty();
}",0.9260042283298098
37997,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override protected ByteCodec<C> createCodec(CodecSupplier registry,FieldWrapper field){
  FieldWrapper componentType=field.genericType(0).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + field.name()));
  ByteCodec componentCodec=registry.getCodec(componentType).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + componentType.name())).toByteCodec();
  return new ByteCodec<C>(){
    @Override public void encode(    ByteBuf target,    C message){
      target.writeInt(message.size());
      for (      Object o : message) {
        componentCodec.encode(target,o);
      }
    }
    @Override public C decode(    ByteBuf encoded){
      int size=encoded.readInt();
      Collection collection=factory.apply(size);
      for (int i=0; i < size; i++) {
        collection.add(componentCodec.decode(encoded));
      }
      return (C)collection;
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override protected ByteCodec<C> createCodec(CodecSupplier registry,FieldWrapper field){
  FieldWrapper componentType=field.genericTypeOrThrow(0);
  ByteCodec componentCodec=registry.getCodecOrThrow(componentType).toByteCodec();
  return new ByteCodec<C>(){
    @Override public void encode(    ByteBuf target,    C message){
      target.writeInt(message.size());
      for (      Object o : message) {
        componentCodec.encode(target,o);
      }
    }
    @Override public C decode(    ByteBuf encoded){
      int size=encoded.readInt();
      Collection collection=factory.apply(size);
      for (int i=0; i < size; i++) {
        collection.add(componentCodec.decode(encoded));
      }
      return (C)collection;
    }
  }
;
}",0.8460661345496009
37998,"@Override public void encode(ByteBuf target,T message){
  if (message.getClass() != type) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  for (  OffsetField field : this.fields) {
    field.codec.write(target,message,field.offset);
  }
}","@Override public void encode(ByteBuf target,T message){
  if (message.getClass() != type) {
    throw new UnsupportedOperationException(""String_Node_Str"" + message.getClass() + ""String_Node_Str""+ type);
  }
  for (  OffsetField field : this.fields) {
    field.codec.write(target,message,field.offset);
  }
}",0.9173989455184536
37999,"@Override protected ByteCodec<M> createCodec(CodecSupplier registry,FieldWrapper field){
  FieldWrapper keyType=field.genericType(0).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + field.name()));
  ByteCodec keyCodec=registry.getCodec(keyType).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + keyType.name())).toByteCodec();
  FieldWrapper valueType=field.genericType(0).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + field.name()));
  ByteCodec valueCodec=registry.getCodec(valueType).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + valueType.name())).toByteCodec();
  return new ByteCodec<M>(){
    @Override public void encode(    ByteBuf target,    M message){
      target.writeInt(message.size());
      for (      Map.Entry o : message.entrySet()) {
        keyCodec.encode(target,o.getKey());
        valueCodec.encode(target,o.getValue());
      }
    }
    @Override public M decode(    ByteBuf encoded){
      int size=encoded.readInt();
      Map map=factory.apply(size);
      for (int i=0; i < size; i++) {
        Object k=keyCodec.decode(encoded);
        Object v=valueCodec.decode(encoded);
        map.put(k,v);
      }
      return (M)map;
    }
  }
;
}","@Override protected ByteCodec<M> createCodec(CodecSupplier registry,FieldWrapper field){
  FieldWrapper keyType=field.genericTypeOrThrow(0);
  ByteCodec keyCodec=registry.getCodecOrThrow(keyType).toByteCodec();
  FieldWrapper valueType=field.genericTypeOrThrow(1);
  ByteCodec valueCodec=registry.getCodecOrThrow(valueType).toByteCodec();
  return new ByteCodec<M>(){
    @Override public void encode(    ByteBuf target,    M message){
      target.writeInt(message.size());
      for (      Map.Entry o : message.entrySet()) {
        keyCodec.encode(target,o.getKey());
        valueCodec.encode(target,o.getValue());
      }
    }
    @Override public M decode(    ByteBuf encoded){
      int size=encoded.readInt();
      Map map=factory.apply(size);
      for (int i=0; i < size; i++) {
        Object k=keyCodec.decode(encoded);
        Object v=valueCodec.decode(encoded);
        map.put(k,v);
      }
      return (M)map;
    }
  }
;
}",0.7696476964769647
38000,"@Override protected void write(Object message,ByteBuf target){
  codecs.getCodec(FieldWrapper.clazz(message.getClass()));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override protected void write(Object message,ByteBuf target){
  ((ByteCodec)codecs.getCodecOrThrow(FieldWrapper.clazz(message.getClass())).toByteCodec()).encode(target,message);
}",0.6
