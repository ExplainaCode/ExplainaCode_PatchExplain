record_number,buggy_code,fixed_code,code_similarity
61001,"/** 
 * @return the startKey 
 */
public byte[] getStartKey(){
  return startKey;
}","/** 
 * @return the startKey
 */
@Override public byte[] getStartKey(){
  return startKey;
}",0.9371428571428572
61002,"/** 
 * Returns the region replica id
 * @return returns region replica id
 */
public int getReplicaId(){
  return replicaId;
}","/** 
 * Returns the region replica id
 * @return returns region replica id
 */
@Override public int getReplicaId(){
  return replicaId;
}",0.9621212121212122
61003,"/** 
 * @return Region name as a String for use in logging, etc.
 */
public String getRegionNameAsString(){
  if (RegionInfo.hasEncodedName(this.regionName)) {
    return Bytes.toStringBinary(this.regionName);
  }
  return Bytes.toStringBinary(this.regionName) + ""String_Node_Str"" + this.getEncodedName();
}","/** 
 * @return Region name as a String for use in logging, etc.
 */
@Override public String getRegionNameAsString(){
  if (RegionInfo.hasEncodedName(this.regionName)) {
    return Bytes.toStringBinary(this.regionName);
  }
  return Bytes.toStringBinary(this.regionName) + ""String_Node_Str"" + this.getEncodedName();
}",0.9839743589743588
61004,"/** 
 * @return the regionName as an array of bytes.
 * @see #getRegionNameAsString()
 */
public byte[] getRegionName(){
  return regionName;
}","/** 
 * @return the regionName as an array of bytes.
 * @see #getRegionNameAsString()
 */
@Override public byte[] getRegionName(){
  return regionName;
}",0.9662162162162162
61005,"/** 
 * @return the regionId 
 */
public long getRegionId(){
  return regionId;
}","/** 
 * @return the regionId 
 */
@Override public long getRegionId(){
  return regionId;
}",0.9418604651162792
61006,"/** 
 * @return the endKey 
 */
public byte[] getEndKey(){
  return endKey;
}","/** 
 * @return the endKey
 */
@Override public byte[] getEndKey(){
  return endKey;
}",0.9325153374233128
61007,"/** 
 * Return true if the given row falls in this region.
 */
public boolean containsRow(byte[] row){
  return Bytes.compareTo(row,startKey) >= 0 && (Bytes.compareTo(row,endKey) < 0 || Bytes.equals(endKey,HConstants.EMPTY_BYTE_ARRAY));
}","/** 
 * @return true if the given row falls in this region.
 */
@Override public boolean containsRow(byte[] row){
  return Bytes.compareTo(row,startKey) >= 0 && (Bytes.compareTo(row,endKey) < 0 || Bytes.equals(endKey,HConstants.EMPTY_BYTE_ARRAY));
}",0.973305954825462
61008,"public synchronized byte[] getEncodedNameAsBytes(){
  if (this.encodedNameAsBytes == null) {
    this.encodedNameAsBytes=Bytes.toBytes(getEncodedName());
  }
  return this.encodedNameAsBytes;
}","@Override public synchronized byte[] getEncodedNameAsBytes(){
  if (this.encodedNameAsBytes == null) {
    this.encodedNameAsBytes=Bytes.toBytes(getEncodedName());
  }
  return this.encodedNameAsBytes;
}",0.9747474747474748
61009,"/** 
 * @return True if has been split and has daughters.
 */
public boolean isSplit(){
  return this.split;
}","/** 
 * @return true if has been split and has daughters.
 */
@Override public boolean isSplit(){
  return this.split;
}",0.9478260869565216
61010,"/** 
 * @return the encoded region name 
 */
public synchronized String getEncodedName(){
  if (this.encodedName == null) {
    this.encodedName=RegionInfo.encodeRegionName(this.regionName);
  }
  return this.encodedName;
}","/** 
 * @return the encoded region name
 */
@Override public synchronized String getEncodedName(){
  if (this.encodedName == null) {
    this.encodedName=RegionInfo.encodeRegionName(this.regionName);
  }
  return this.encodedName;
}",0.9758241758241758
61011,"/** 
 * Get current table name of the region
 * @return TableName
 */
public TableName getTable(){
  if (tableName == null || tableName.getName().length == 0) {
    tableName=getTable(getRegionName());
  }
  return this.tableName;
}","/** 
 * Get current table name of the region
 * @return TableName
 */
@Override public TableName getTable(){
  if (tableName == null || tableName.getName().length == 0) {
    tableName=getTable(getRegionName());
  }
  return this.tableName;
}",0.978902953586498
61012,"/** 
 * @return True if this is a split parent region.
 */
public boolean isSplitParent(){
  if (!isSplit())   return false;
  if (!isOffline()) {
    LOG.warn(""String_Node_Str"" + getRegionNameAsString());
  }
  return true;
}","/** 
 * @return true if this is a split parent region.
 */
@Override public boolean isSplitParent(){
  if (!isSplit())   return false;
  if (!isOffline()) {
    LOG.warn(""String_Node_Str"" + getRegionNameAsString());
  }
  return true;
}",0.974025974025974
61013,"/** 
 * @return True if this region is offline.
 */
public boolean isOffline(){
  return this.offLine;
}","/** 
 * @return true if this region is offline.
 */
@Override public boolean isOffline(){
  return this.offLine;
}",0.944954128440367
61014,"private void setHashCode(){
  int result=Arrays.hashCode(this.regionName);
  result^=this.regionId;
  result^=Arrays.hashCode(this.startKey);
  result^=Arrays.hashCode(this.endKey);
  result^=Boolean.valueOf(this.offLine).hashCode();
  result^=Arrays.hashCode(this.tableName.getName());
  result^=this.replicaId;
  this.hashCode=result;
}","private void setHashCode(){
  int result=Arrays.hashCode(this.regionName);
  result=(int)(result ^ this.regionId);
  result^=Arrays.hashCode(this.startKey);
  result^=Arrays.hashCode(this.endKey);
  result^=Boolean.valueOf(this.offLine).hashCode();
  result^=Arrays.hashCode(this.tableName.getName());
  result^=this.replicaId;
  this.hashCode=result;
}",0.9725036179450072
61015,"/** 
 * Returns true if the given inclusive range of rows is fully contained by this region. For example, if the region is foo,a,g and this is passed [""b"",""c""] or [""a"",""c""] it will return true, but if this is passed [""b"",""z""] it will return false.
 * @throws IllegalArgumentException if the range passed is invalid (ie. end &lt; start)
 */
public boolean containsRange(byte[] rangeStartKey,byte[] rangeEndKey){
  if (Bytes.compareTo(rangeStartKey,rangeEndKey) > 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + Bytes.toStringBinary(rangeStartKey) + ""String_Node_Str""+ Bytes.toStringBinary(rangeEndKey));
  }
  boolean firstKeyInRange=Bytes.compareTo(rangeStartKey,startKey) >= 0;
  boolean lastKeyInRange=Bytes.compareTo(rangeEndKey,endKey) < 0 || Bytes.equals(endKey,HConstants.EMPTY_BYTE_ARRAY);
  return firstKeyInRange && lastKeyInRange;
}","/** 
 * Returns true if the given inclusive range of rows is fully contained by this region. For example, if the region is foo,a,g and this is passed [""b"",""c""] or [""a"",""c""] it will return true, but if this is passed [""b"",""z""] it will return false.
 * @throws IllegalArgumentException if the range passed is invalid (ie. end &lt; start)
 */
@Override public boolean containsRange(byte[] rangeStartKey,byte[] rangeEndKey){
  if (Bytes.compareTo(rangeStartKey,rangeEndKey) > 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + Bytes.toStringBinary(rangeStartKey) + ""String_Node_Str""+ Bytes.toStringBinary(rangeEndKey));
  }
  boolean firstKeyInRange=Bytes.compareTo(rangeStartKey,startKey) >= 0;
  boolean lastKeyInRange=Bytes.compareTo(rangeEndKey,endKey) < 0 || Bytes.equals(endKey,HConstants.EMPTY_BYTE_ARRAY);
  return firstKeyInRange && lastKeyInRange;
}",0.9942062572421784
61016,"/** 
 * @return current setting for returnResults
 */
public boolean isReturnResults(){
  return super.isReturnResults();
}","/** 
 * @return current setting for returnResults
 */
@Override public boolean isReturnResults(){
  return super.isReturnResults();
}",0.9609375
61017,"/** 
 * @param returnResults True (default) if the append operation should return the results. A client that is not interested in the result can save network bandwidth setting this to false.
 */
public Append setReturnResults(boolean returnResults){
  super.setReturnResults(returnResults);
  return this;
}","/** 
 * @param returnResults True (default) if the append operation should return the results. A client that is not interested in the result can save network bandwidth setting this to false.
 */
@Override public Append setReturnResults(boolean returnResults){
  super.setReturnResults(returnResults);
  return this;
}",0.9839743589743588
61018,"CompletableFuture<T> call(){
  doCall();
  return future;
}","@Override CompletableFuture<T> call(){
  doCall();
  return future;
}",0.921875
61019,"public CompletableFuture<T> call(){
  doCall();
  return future;
}","@Override public CompletableFuture<T> call(){
  doCall();
  return future;
}",0.9295774647887324
61020,"AsyncProcess(ClusterConnection hc,Configuration conf,RpcRetryingCallerFactory rpcCaller,boolean useGlobalErrors,RpcControllerFactory rpcFactory){
  if (hc == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.connection=hc;
  this.globalErrors=useGlobalErrors ? new BatchErrors() : null;
  this.id=COUNTER.incrementAndGet();
  this.pause=conf.getLong(HConstants.HBASE_CLIENT_PAUSE,HConstants.DEFAULT_HBASE_CLIENT_PAUSE);
  long configuredPauseForCQTBE=conf.getLong(HConstants.HBASE_CLIENT_PAUSE_FOR_CQTBE,pause);
  if (configuredPauseForCQTBE < pause) {
    LOG.warn(""String_Node_Str"" + HConstants.HBASE_CLIENT_PAUSE_FOR_CQTBE + ""String_Node_Str""+ configuredPauseForCQTBE+ ""String_Node_Str""+ HConstants.HBASE_CLIENT_PAUSE+ ""String_Node_Str""+ pause+ ""String_Node_Str"");
    this.pauseForCQTBE=pause;
  }
 else {
    this.pauseForCQTBE=configuredPauseForCQTBE;
  }
  this.numTries=conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,HConstants.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER) + 1;
  this.primaryCallTimeoutMicroseconds=conf.getInt(PRIMARY_CALL_TIMEOUT_KEY,10000);
  this.startLogErrorsCnt=conf.getInt(START_LOG_ERRORS_AFTER_COUNT_KEY,DEFAULT_START_LOG_ERRORS_AFTER_COUNT);
  this.periodToLog=conf.getInt(LOG_DETAILS_PERIOD,DEFAULT_LOG_DETAILS_PERIOD);
  this.serverTrackerTimeout=0;
  for (int i=0; i < this.numTries; ++i) {
    serverTrackerTimeout+=ConnectionUtils.getPauseTime(this.pause,i);
  }
  this.rpcCallerFactory=rpcCaller;
  this.rpcFactory=rpcFactory;
  this.logBatchErrorDetails=conf.getBoolean(LOG_DETAILS_FOR_BATCH_ERROR,false);
  this.requestController=RequestControllerFactory.create(conf);
}","AsyncProcess(ClusterConnection hc,Configuration conf,RpcRetryingCallerFactory rpcCaller,boolean useGlobalErrors,RpcControllerFactory rpcFactory){
  if (hc == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.connection=hc;
  this.globalErrors=useGlobalErrors ? new BatchErrors() : null;
  this.id=COUNTER.incrementAndGet();
  this.pause=conf.getLong(HConstants.HBASE_CLIENT_PAUSE,HConstants.DEFAULT_HBASE_CLIENT_PAUSE);
  long configuredPauseForCQTBE=conf.getLong(HConstants.HBASE_CLIENT_PAUSE_FOR_CQTBE,pause);
  if (configuredPauseForCQTBE < pause) {
    LOG.warn(""String_Node_Str"" + HConstants.HBASE_CLIENT_PAUSE_FOR_CQTBE + ""String_Node_Str""+ configuredPauseForCQTBE+ ""String_Node_Str""+ HConstants.HBASE_CLIENT_PAUSE+ ""String_Node_Str""+ pause+ ""String_Node_Str"");
    this.pauseForCQTBE=pause;
  }
 else {
    this.pauseForCQTBE=configuredPauseForCQTBE;
  }
  this.numTries=conf.getInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,HConstants.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER) + 1;
  this.primaryCallTimeoutMicroseconds=conf.getInt(PRIMARY_CALL_TIMEOUT_KEY,10000);
  this.startLogErrorsCnt=conf.getInt(START_LOG_ERRORS_AFTER_COUNT_KEY,DEFAULT_START_LOG_ERRORS_AFTER_COUNT);
  this.periodToLog=conf.getInt(LOG_DETAILS_PERIOD,DEFAULT_LOG_DETAILS_PERIOD);
  this.serverTrackerTimeout=0L;
  for (int i=0; i < this.numTries; ++i) {
    serverTrackerTimeout=serverTrackerTimeout + ConnectionUtils.getPauseTime(this.pause,i);
  }
  this.rpcCallerFactory=rpcCaller;
  this.rpcFactory=rpcFactory;
  this.logBatchErrorDetails=conf.getBoolean(LOG_DETAILS_FOR_BATCH_ERROR,false);
  this.requestController=RequestControllerFactory.create(conf);
}",0.9924219460442558
61021,"CompletableFuture<T> call(){
  doCall();
  return future;
}","@Override CompletableFuture<T> call(){
  doCall();
  return future;
}",0.921875
61022,"@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public BufferedMutatorParams clone(){
  BufferedMutatorParams clone=new BufferedMutatorParams(this.tableName);
  clone.writeBufferSize=this.writeBufferSize;
  clone.maxKeyValueSize=maxKeyValueSize;
  clone.pool=this.pool;
  clone.listener=this.listener;
  clone.implementationClassName=this.implementationClassName;
  return clone;
}","@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @Override public BufferedMutatorParams clone(){
  BufferedMutatorParams clone=new BufferedMutatorParams(this.tableName);
  clone.writeBufferSize=this.writeBufferSize;
  clone.maxKeyValueSize=maxKeyValueSize;
  clone.pool=this.pool;
  clone.listener=this.listener;
  clone.implementationClassName=this.implementationClassName;
  return clone;
}",0.9887640449438202
61023,"/** 
 * By default, HBase only consider timestamp in versions. So a previous Delete with higher ts will mask a later Put with lower ts. Set this to true to enable new semantics of versions. We will also consider mvcc in versions. See HBASE-15968 for details.
 */
public boolean isNewVersionBehavior(){
  return getStringOrDefault(NEW_VERSION_BEHAVIOR_BYTES,Boolean::parseBoolean,DEFAULT_NEW_VERSION_BEHAVIOR);
}","/** 
 * By default, HBase only consider timestamp in versions. So a previous Delete with higher ts will mask a later Put with lower ts. Set this to true to enable new semantics of versions. We will also consider mvcc in versions. See HBASE-15968 for details.
 */
@Override public boolean isNewVersionBehavior(){
  return getStringOrDefault(NEW_VERSION_BEHAVIOR_BYTES,Boolean::parseBoolean,DEFAULT_NEW_VERSION_BEHAVIOR);
}",0.9879807692307692
61024,"public FastFailInterceptorContext prepare(RetryingCallable<?> callable,int tries){
  if (callable instanceof RegionServerCallable) {
    RegionServerCallable<?,?> retryingCallable=(RegionServerCallable<?,?>)callable;
    server=retryingCallable.getLocation().getServerName();
  }
  this.tries=tries;
  return this;
}","@Override public FastFailInterceptorContext prepare(RetryingCallable<?> callable,int tries){
  if (callable instanceof RegionServerCallable) {
    RegionServerCallable<?,?> retryingCallable=(RegionServerCallable<?,?>)callable;
    server=retryingCallable.getLocation().getServerName();
  }
  this.tries=tries;
  return this;
}",0.9844236760124612
61025,"public void clear(){
  server=null;
  fInfo=null;
  didTry=false;
  couldNotCommunicateWithServer.setValue(false);
  guaranteedClientSideOnly.setValue(false);
  retryDespiteFastFailMode=false;
  tries=0;
}","@Override public void clear(){
  server=null;
  fInfo=null;
  didTry=false;
  couldNotCommunicateWithServer.setValue(false);
  guaranteedClientSideOnly.setValue(false);
  retryDespiteFastFailMode=false;
  tries=0;
}",0.9761904761904762
61026,"public Get setLoadColumnFamiliesOnDemand(boolean value){
  return (Get)super.setLoadColumnFamiliesOnDemand(value);
}","@Override public Get setLoadColumnFamiliesOnDemand(boolean value){
  return (Get)super.setLoadColumnFamiliesOnDemand(value);
}",0.9586776859504132
61027,"/** 
 * Wakes up given waiting procedures by pushing them back into scheduler queues.
 * @return size of given {@code waitQueue}.
 */
protected int wakeWaitingProcedures(final ProcedureDeque waitQueue){
  int count=waitQueue.size();
  while (!waitQueue.isEmpty()) {
    wakeProcedure(waitQueue.removeLast());
  }
  return count;
}","/** 
 * Wakes up given waiting procedures by pushing them back into scheduler queues.
 * @return size of given {@code waitQueue}.
 */
protected int wakeWaitingProcedures(final ProcedureDeque waitQueue){
  int count=waitQueue.size();
  addFront(waitQueue.descendingIterator());
  waitQueue.clear();
  return count;
}",0.7534883720930232
61028,"public void addBack(final Procedure procedure){
  push(procedure,false,true);
}","@Override public void addBack(final Procedure procedure){
  push(procedure,false,true);
}",0.9404761904761904
61029,"@Override public void wakeEvents(final int count,final ProcedureEvent... events){
  final boolean traceEnabled=LOG.isTraceEnabled();
  schedLock();
  try {
    int waitingCount=0;
    for (int i=0; i < count; ++i) {
      final ProcedureEvent event=events[i];
synchronized (event) {
        if (!event.isReady()) {
          event.setReady(true);
          if (traceEnabled) {
            LOG.trace(""String_Node_Str"" + event);
          }
          waitingCount+=wakeWaitingProcedures(event.getSuspendedProcedures());
        }
 else {
          ProcedureDeque q=event.getSuspendedProcedures();
          if (q != null && !q.isEmpty()) {
            LOG.warn(""String_Node_Str"" + q.size() + ""String_Node_Str"");
            waitingCount+=wakeWaitingProcedures(event.getSuspendedProcedures());
          }
        }
      }
    }
    wakePollIfNeeded(waitingCount);
  }
  finally {
    schedUnlock();
  }
}","/** 
 * Wake up all of the given events. Note that we first take scheduler lock and then wakeInternal() synchronizes on the event. Access should remain package-private. Use ProcedureEvent class to wake/suspend events.
 * @param events the list of events to wake
 */
void wakeEvents(ProcedureEvent[] events){
  schedLock();
  try {
    for (    ProcedureEvent event : events) {
      if (event == null) {
        continue;
      }
      event.wakeInternal(this);
    }
  }
  finally {
    schedUnlock();
  }
}",0.0765414599574769
61030,"public void addFront(final Procedure procedure){
  push(procedure,true,true);
}","@Override public void addFront(Iterator<Procedure> procedureIterator){
  schedLock();
  try {
    int count=0;
    while (procedureIterator.hasNext()) {
      Procedure procedure=procedureIterator.next();
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + procedure);
      }
      push(procedure,true,false);
      count++;
    }
    wakePollIfNeeded(count);
  }
  finally {
    schedUnlock();
  }
}",0.116
61031,"public ProcedureDeque getSuspendedProcedures(){
  return suspendedProcedures;
}","/** 
 * Access to suspendedProcedures is 'synchronized' on this object, but it's fine to return it here for tests.
 */
@VisibleForTesting public ProcedureDeque getSuspendedProcedures(){
  return suspendedProcedures;
}",0.5337837837837838
61032,"@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + object+ ""String_Node_Str""+ isReady()+ ""String_Node_Str""+ getSuspendedProcedures();
}","@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + object+ ""String_Node_Str""+ isReady()+ ""String_Node_Str""+ suspendedProcedures;
}",0.98005698005698
61033,"/** 
 * Inserts the specified element at the front of this queue.
 * @param proc the Procedure to add
 */
void addFront(Procedure proc);","/** 
 * Inserts all elements in the iterator at the front of this queue.
 */
void addFront(Iterator<Procedure> procedureIterator);",0.6541353383458647
61034,"@Override protected Procedure[] execute(final TestProcEnv env) throws ProcedureSuspendedException {
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ ntimeouts);
  if (ntimeouts.get() > maxTimeouts) {
    setAbortFailure(""String_Node_Str"",""String_Node_Str"" + ntimeouts.get());
    return null;
  }
  env.getProcedureScheduler().suspendEvent(event);
  if (env.getProcedureScheduler().waitEvent(event,this)) {
    setState(ProcedureState.WAITING_TIMEOUT);
    throw new ProcedureSuspendedException();
  }
  return null;
}","@Override protected Procedure[] execute(final TestProcEnv env) throws ProcedureSuspendedException {
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ ntimeouts);
  if (ntimeouts.get() > maxTimeouts) {
    setAbortFailure(""String_Node_Str"",""String_Node_Str"" + ntimeouts.get());
    return null;
  }
  event.suspend();
  if (event.suspendIfNotReady(this)) {
    setState(ProcedureState.WAITING_TIMEOUT);
    throw new ProcedureSuspendedException();
  }
  return null;
}",0.868
61035,"@Override protected boolean setTimeoutFailure(final TestProcEnv env){
  int n=ntimeouts.incrementAndGet();
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ n);
  setState(ProcedureState.RUNNABLE);
  env.getProcedureScheduler().wakeEvent(event);
  return false;
}","@Override protected boolean setTimeoutFailure(final TestProcEnv env){
  int n=ntimeouts.incrementAndGet();
  LOG.info(""String_Node_Str"" + this + ""String_Node_Str""+ n);
  setState(ProcedureState.RUNNABLE);
  event.wake((AbstractProcedureScheduler)env.getProcedureScheduler());
  return false;
}",0.9023090586145648
61036,"@Override protected void afterReplay(final TestProcEnv env){
  if (getState() == ProcedureState.WAITING_TIMEOUT) {
    env.getProcedureScheduler().suspendEvent(event);
    env.getProcedureScheduler().waitEvent(event,this);
  }
}","@Override protected void afterReplay(final TestProcEnv env){
  if (getState() == ProcedureState.WAITING_TIMEOUT) {
    event.suspend();
    event.suspendIfNotReady(this);
  }
}",0.7821782178217822
61037,"/** 
 * FilterList with MUST_PASS_ALL choose the maximal forward step among sub-filters in filter list. Let's call it: The Maximal Step Rule. So if filter-A in filter list return INCLUDE and filter-B in filter list return INCLUDE_AND_NEXT_COL, then the filter list should return INCLUDE_AND_NEXT_COL. For SEEK_NEXT_USING_HINT, it's more special, and in method filterCellWithMustPassAll(), if any sub-filter return SEEK_NEXT_USING_HINT, then our filter list will return SEEK_NEXT_USING_HINT. so we don't care about the SEEK_NEXT_USING_HINT here. <br/> <br/> The jump step will be: <pre> INCLUDE &lt; SKIP &lt; INCLUDE_AND_NEXT_COL &lt; NEXT_COL &lt; INCLUDE_AND_SEEK_NEXT_ROW &lt; NEXT_ROW &lt; SEEK_NEXT_USING_HINT </pre> Here, we have the following map to describe The Maximal Step Rule. if current return code (for previous sub-filters in filter list) is <strong>ReturnCode</strong>, and current filter returns <strong>localRC</strong>, then we should return map[ReturnCode][localRC] for the merged result, according to The Maximal Step Rule. <br/> <pre> LocalCode\ReturnCode       INCLUDE                    INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE                    INCLUDE                    INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE_AND_NEXT_COL       INCLUDE_AND_NEXT_COL       INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  NEXT_COL              NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE_AND_SEEK_NEXT_ROW  INCLUDE_AND_SEEK_NEXT_ROW  INCLUDE_AND_SEEK_NEXT_ROW INCLUDE_AND_SEEK_NEXT_ROW  NEXT_ROW              NEXT_ROW              NEXT_ROW              SEEK_NEXT_USING_HINT SKIP                       SKIP                       NEXT_COL                  NEXT_ROW                   SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT NEXT_COL                   NEXT_COL                   NEXT_COL                  NEXT_ROW                   NEXT_COL              NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT NEXT_ROW                   NEXT_ROW                   NEXT_ROW                  NEXT_ROW                   NEXT_ROW              NEXT_ROW              NEXT_ROW              SEEK_NEXT_USING_HINT SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT      SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT </pre>
 * @param rc Return code which is calculated by previous sub-filter(s) in filter list.
 * @param localRC Return code of the current sub-filter in filter list.
 * @return Return code which is merged by the return code of previous sub-filter(s) and the returncode of current sub-filter.
 */
private ReturnCode mergeReturnCode(ReturnCode rc,ReturnCode localRC){
  if (rc == ReturnCode.SEEK_NEXT_USING_HINT || localRC == ReturnCode.SEEK_NEXT_USING_HINT) {
    return ReturnCode.SEEK_NEXT_USING_HINT;
  }
switch (localRC) {
case INCLUDE:
    return rc;
case INCLUDE_AND_NEXT_COL:
  if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL)) {
    return ReturnCode.INCLUDE_AND_NEXT_COL;
  }
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW)) {
  return ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
if (isInReturnCodes(rc,ReturnCode.SKIP,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case INCLUDE_AND_SEEK_NEXT_ROW:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW)) {
return ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
if (isInReturnCodes(rc,ReturnCode.SKIP,ReturnCode.NEXT_COL,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case SKIP:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.SKIP)) {
return ReturnCode.SKIP;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case NEXT_COL:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.SKIP,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case NEXT_ROW:
return ReturnCode.NEXT_ROW;
}
throw new IllegalStateException(""String_Node_Str"" + rc + ""String_Node_Str""+ localRC);
}","/** 
 * FilterList with MUST_PASS_ALL choose the maximal forward step among sub-filters in filter list. Let's call it: The Maximal Step Rule. So if filter-A in filter list return INCLUDE and filter-B in filter list return INCLUDE_AND_NEXT_COL, then the filter list should return INCLUDE_AND_NEXT_COL. For SEEK_NEXT_USING_HINT, it's more special, and in method filterCellWithMustPassAll(), if any sub-filter return SEEK_NEXT_USING_HINT, then our filter list will return SEEK_NEXT_USING_HINT. so we don't care about the SEEK_NEXT_USING_HINT here. <br/> <br/> The jump step will be: <pre> INCLUDE &lt; SKIP &lt; INCLUDE_AND_NEXT_COL &lt; NEXT_COL &lt; INCLUDE_AND_SEEK_NEXT_ROW &lt; NEXT_ROW &lt; SEEK_NEXT_USING_HINT </pre> Here, we have the following map to describe The Maximal Step Rule. if current return code (for previous sub-filters in filter list) is <strong>ReturnCode</strong>, and current filter returns <strong>localRC</strong>, then we should return map[ReturnCode][localRC] for the merged result, according to The Maximal Step Rule. <br/> <pre> LocalCode\ReturnCode       INCLUDE                    INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE                    INCLUDE                    INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE_AND_NEXT_COL       INCLUDE_AND_NEXT_COL       INCLUDE_AND_NEXT_COL      INCLUDE_AND_SEEK_NEXT_ROW  NEXT_COL              NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT INCLUDE_AND_SEEK_NEXT_ROW  INCLUDE_AND_SEEK_NEXT_ROW  INCLUDE_AND_SEEK_NEXT_ROW INCLUDE_AND_SEEK_NEXT_ROW  NEXT_ROW              NEXT_ROW              NEXT_ROW              SEEK_NEXT_USING_HINT SKIP                       SKIP                       NEXT_COL                  NEXT_ROW                   SKIP                  NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT NEXT_COL                   NEXT_COL                   NEXT_COL                  NEXT_ROW                   NEXT_COL              NEXT_COL              NEXT_ROW              SEEK_NEXT_USING_HINT NEXT_ROW                   NEXT_ROW                   NEXT_ROW                  NEXT_ROW                   NEXT_ROW              NEXT_ROW              NEXT_ROW              SEEK_NEXT_USING_HINT SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT      SEEK_NEXT_USING_HINT       SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT  SEEK_NEXT_USING_HINT </pre>
 * @param rc Return code which is calculated by previous sub-filter(s) in filter list.
 * @param localRC Return code of the current sub-filter in filter list.
 * @return Return code which is merged by the return code of previous sub-filter(s) and the returncode of current sub-filter.
 */
private ReturnCode mergeReturnCode(ReturnCode rc,ReturnCode localRC){
  if (rc == ReturnCode.SEEK_NEXT_USING_HINT) {
    return ReturnCode.SEEK_NEXT_USING_HINT;
  }
switch (localRC) {
case SEEK_NEXT_USING_HINT:
    return ReturnCode.SEEK_NEXT_USING_HINT;
case INCLUDE:
  return rc;
case INCLUDE_AND_NEXT_COL:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL)) {
  return ReturnCode.INCLUDE_AND_NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW)) {
return ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
if (isInReturnCodes(rc,ReturnCode.SKIP,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case INCLUDE_AND_SEEK_NEXT_ROW:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW)) {
return ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
if (isInReturnCodes(rc,ReturnCode.SKIP,ReturnCode.NEXT_COL,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case SKIP:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.SKIP)) {
return ReturnCode.SKIP;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case NEXT_COL:
if (isInReturnCodes(rc,ReturnCode.INCLUDE,ReturnCode.INCLUDE_AND_NEXT_COL,ReturnCode.SKIP,ReturnCode.NEXT_COL)) {
return ReturnCode.NEXT_COL;
}
if (isInReturnCodes(rc,ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW,ReturnCode.NEXT_ROW)) {
return ReturnCode.NEXT_ROW;
}
break;
case NEXT_ROW:
return ReturnCode.NEXT_ROW;
}
throw new IllegalStateException(""String_Node_Str"" + rc + ""String_Node_Str""+ localRC);
}",0.9836241036069784
61038,"/** 
 * Calculates the splits that will serve as input for the map tasks.
 * @param context  The current job context.
 * @return The list of input splits.
 * @throws IOException When creating the list of splits fails.
 * @see org.apache.hadoop.mapreduce.InputFormat#getSplits(org.apache.hadoop.mapreduce.JobContext)
 */
@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  boolean closeOnFinish=false;
  if (table == null) {
    initialize(context);
    closeOnFinish=true;
  }
  try {
    if (getTable() == null) {
      throw new IOException(INITIALIZATION_ERROR);
    }
  }
 catch (  IllegalStateException exception) {
    throw new IOException(INITIALIZATION_ERROR,exception);
  }
  try {
    List<InputSplit> splits=oneInputSplitPerRegion();
    if (context.getConfiguration().get(NUM_MAPPERS_PER_REGION) != null) {
      int nSplitsPerRegion=context.getConfiguration().getInt(NUM_MAPPERS_PER_REGION,1);
      List<InputSplit> res=new ArrayList<>();
      for (int i=0; i < splits.size(); i++) {
        List<InputSplit> tmp=createNInputSplitsUniform(splits.get(i),nSplitsPerRegion);
        res.addAll(tmp);
      }
      return res;
    }
    if (context.getConfiguration().getBoolean(MAPREDUCE_INPUT_AUTOBALANCE,false) != false) {
      long maxAveRegionSize=context.getConfiguration().getInt(MAX_AVERAGE_REGION_SIZE,8 * 1073741824);
      return calculateAutoBalancedSplits(splits,maxAveRegionSize);
    }
    return splits;
  }
  finally {
    if (closeOnFinish) {
      closeTable();
    }
  }
}","/** 
 * Calculates the splits that will serve as input for the map tasks.
 * @param context  The current job context.
 * @return The list of input splits.
 * @throws IOException When creating the list of splits fails.
 * @see org.apache.hadoop.mapreduce.InputFormat#getSplits(org.apache.hadoop.mapreduce.JobContext)
 */
@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  boolean closeOnFinish=false;
  if (table == null) {
    initialize(context);
    closeOnFinish=true;
  }
  try {
    if (getTable() == null) {
      throw new IOException(INITIALIZATION_ERROR);
    }
  }
 catch (  IllegalStateException exception) {
    throw new IOException(INITIALIZATION_ERROR,exception);
  }
  try {
    List<InputSplit> splits=oneInputSplitPerRegion();
    if (context.getConfiguration().get(NUM_MAPPERS_PER_REGION) != null) {
      int nSplitsPerRegion=context.getConfiguration().getInt(NUM_MAPPERS_PER_REGION,1);
      List<InputSplit> res=new ArrayList<>();
      for (int i=0; i < splits.size(); i++) {
        List<InputSplit> tmp=createNInputSplitsUniform(splits.get(i),nSplitsPerRegion);
        res.addAll(tmp);
      }
      return res;
    }
    if (context.getConfiguration().getBoolean(MAPREDUCE_INPUT_AUTOBALANCE,false)) {
      long maxAveRegionSize=context.getConfiguration().getLong(MAX_AVERAGE_REGION_SIZE,8L * 1073741824);
      return calculateAutoBalancedSplits(splits,maxAveRegionSize);
    }
    return splits;
  }
  finally {
    if (closeOnFinish) {
      closeTable();
    }
  }
}",0.9742922225837944
61039,"int getValueLength(final Random r){
  if (this.opts.isValueRandom())   return Math.abs(r.nextInt() % opts.valueSize);
 else   if (this.opts.isValueZipf())   return Math.abs(this.zipf.nextInt());
 else   return opts.valueSize;
}","int getValueLength(final Random r){
  if (this.opts.isValueRandom()) {
    return r.nextInt(opts.valueSize);
  }
 else   if (this.opts.isValueZipf()) {
    return Math.abs(this.zipf.nextInt());
  }
 else {
    return opts.valueSize;
  }
}",0.4946236559139785
61040,"@Test @SuppressWarnings(""String_Node_Str"") public void testSplitTableCompareTo(){
  TableSplit aTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  TableSplit bTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  TableSplit cTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  assertTrue(aTableSplit.compareTo(aTableSplit) == 0);
  assertTrue(bTableSplit.compareTo(bTableSplit) == 0);
  assertTrue(cTableSplit.compareTo(cTableSplit) == 0);
  assertTrue(aTableSplit.compareTo(bTableSplit) < 0);
  assertTrue(bTableSplit.compareTo(aTableSplit) > 0);
  assertTrue(aTableSplit.compareTo(cTableSplit) < 0);
  assertTrue(cTableSplit.compareTo(aTableSplit) > 0);
  assertTrue(bTableSplit.compareTo(cTableSplit) < 0);
  assertTrue(cTableSplit.compareTo(bTableSplit) > 0);
  assertTrue(cTableSplit.compareTo(aTableSplit) > 0);
}","@Test @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void testSplitTableCompareTo(){
  TableSplit aTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  TableSplit bTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  TableSplit cTableSplit=new TableSplit(Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""),""String_Node_Str"");
  assertEquals(0,aTableSplit.compareTo(aTableSplit));
  assertEquals(0,bTableSplit.compareTo(bTableSplit));
  assertEquals(0,cTableSplit.compareTo(cTableSplit));
  assertTrue(aTableSplit.compareTo(bTableSplit) < 0);
  assertTrue(bTableSplit.compareTo(aTableSplit) > 0);
  assertTrue(aTableSplit.compareTo(cTableSplit) < 0);
  assertTrue(cTableSplit.compareTo(aTableSplit) > 0);
  assertTrue(bTableSplit.compareTo(cTableSplit) < 0);
  assertTrue(cTableSplit.compareTo(bTableSplit) > 0);
  assertTrue(cTableSplit.compareTo(aTableSplit) > 0);
}",0.8133153396311291
61041,"/** 
 * Run an ImportTsv job and perform basic validation on the results. Returns the ImportTsv <code>Tool</code> instance so that other tests can inspect it for further validation as necessary. This method is static to insure non-reliance on instance's util/conf facilities.
 * @param args Any arguments to pass BEFORE inputFile path is appended.
 * @return The Tool instance used to run the test.
 */
protected static Tool doMROnTableTest(HBaseTestingUtility util,TableName table,String family,String data,Map<String,String> args,int valueMultiplier,int expectedKVCount) throws Exception {
  Configuration conf=new Configuration(util.getConfiguration());
  FileSystem fs=FileSystem.get(conf);
  Path inputPath=fs.makeQualified(new Path(util.getDataTestDirOnTestFS(table.getNameAsString()),""String_Node_Str""));
  FSDataOutputStream op=fs.create(inputPath,true);
  if (data == null) {
    data=""String_Node_Str"";
  }
  op.write(Bytes.toBytes(data));
  op.close();
  LOG.debug(String.format(""String_Node_Str"",inputPath));
  if (conf.getBoolean(FORCE_COMBINER_CONF,true)) {
    LOG.debug(""String_Node_Str"");
    conf.setInt(""String_Node_Str"",1);
  }
  String[] argsArray=new String[args.size() + 2];
  Iterator it=args.entrySet().iterator();
  int i=0;
  while (it.hasNext()) {
    Map.Entry pair=(Map.Entry)it.next();
    argsArray[i]=""String_Node_Str"" + pair.getKey() + ""String_Node_Str""+ pair.getValue();
    i++;
  }
  argsArray[i]=table.getNameAsString();
  argsArray[i + 1]=inputPath.toString();
  Tool tool=new ImportTsv();
  LOG.debug(""String_Node_Str"" + argsArray);
  assertEquals(0,ToolRunner.run(conf,tool,argsArray));
  boolean isDryRun=args.containsKey(ImportTsv.DRY_RUN_CONF_KEY) && ""String_Node_Str"".equalsIgnoreCase(args.get(ImportTsv.DRY_RUN_CONF_KEY));
  if (args.containsKey(ImportTsv.BULK_OUTPUT_CONF_KEY)) {
    if (isDryRun) {
      assertFalse(String.format(""String_Node_Str"",ImportTsv.BULK_OUTPUT_CONF_KEY),fs.exists(new Path(ImportTsv.BULK_OUTPUT_CONF_KEY)));
    }
 else {
      validateHFiles(fs,args.get(ImportTsv.BULK_OUTPUT_CONF_KEY),family,expectedKVCount);
    }
  }
 else {
    validateTable(conf,table,family,valueMultiplier,isDryRun);
  }
  if (conf.getBoolean(DELETE_AFTER_LOAD_CONF,true)) {
    LOG.debug(""String_Node_Str"");
    util.cleanupDataTestDirOnTestFS(table.getNameAsString());
  }
  return tool;
}","/** 
 * Run an ImportTsv job and perform basic validation on the results. Returns the ImportTsv <code>Tool</code> instance so that other tests can inspect it for further validation as necessary. This method is static to insure non-reliance on instance's util/conf facilities.
 * @param args Any arguments to pass BEFORE inputFile path is appended.
 * @return The Tool instance used to run the test.
 */
protected static Tool doMROnTableTest(HBaseTestingUtility util,TableName table,String family,String data,Map<String,String> args,int valueMultiplier,int expectedKVCount) throws Exception {
  Configuration conf=new Configuration(util.getConfiguration());
  FileSystem fs=FileSystem.get(conf);
  Path inputPath=fs.makeQualified(new Path(util.getDataTestDirOnTestFS(table.getNameAsString()),""String_Node_Str""));
  FSDataOutputStream op=fs.create(inputPath,true);
  if (data == null) {
    data=""String_Node_Str"";
  }
  op.write(Bytes.toBytes(data));
  op.close();
  LOG.debug(String.format(""String_Node_Str"",inputPath));
  if (conf.getBoolean(FORCE_COMBINER_CONF,true)) {
    LOG.debug(""String_Node_Str"");
    conf.setInt(""String_Node_Str"",1);
  }
  String[] argsArray=new String[args.size() + 2];
  Iterator it=args.entrySet().iterator();
  int i=0;
  while (it.hasNext()) {
    Map.Entry pair=(Map.Entry)it.next();
    argsArray[i]=""String_Node_Str"" + pair.getKey() + ""String_Node_Str""+ pair.getValue();
    i++;
  }
  argsArray[i]=table.getNameAsString();
  argsArray[i + 1]=inputPath.toString();
  Tool tool=new ImportTsv();
  LOG.debug(""String_Node_Str"" + Arrays.toString(argsArray));
  assertEquals(0,ToolRunner.run(conf,tool,argsArray));
  boolean isDryRun=args.containsKey(ImportTsv.DRY_RUN_CONF_KEY) && ""String_Node_Str"".equalsIgnoreCase(args.get(ImportTsv.DRY_RUN_CONF_KEY));
  if (args.containsKey(ImportTsv.BULK_OUTPUT_CONF_KEY)) {
    if (isDryRun) {
      assertFalse(String.format(""String_Node_Str"",ImportTsv.BULK_OUTPUT_CONF_KEY),fs.exists(new Path(ImportTsv.BULK_OUTPUT_CONF_KEY)));
    }
 else {
      validateHFiles(fs,args.get(ImportTsv.BULK_OUTPUT_CONF_KEY),family,expectedKVCount);
    }
  }
 else {
    validateTable(conf,table,family,valueMultiplier,isDryRun);
  }
  if (conf.getBoolean(DELETE_AFTER_LOAD_CONF,true)) {
    LOG.debug(""String_Node_Str"");
    util.cleanupDataTestDirOnTestFS(table.getNameAsString());
  }
  return tool;
}",0.9946819825569028
61042,"@Override protected void populatePut(byte[] lineBytes,ParsedLine parsed,Put put,int i) throws BadTsvLineException, IOException {
  KeyValue kv;
  kv=new KeyValue(lineBytes,parsed.getRowKeyOffset(),parsed.getRowKeyLength(),parser.getFamily(i),0,parser.getFamily(i).length,parser.getQualifier(i),0,parser.getQualifier(i).length,ts,KeyValue.Type.Put,lineBytes,parsed.getColumnOffset(i),parsed.getColumnLength(i));
  if (parsed.getIndividualAttributes() != null) {
    String[] attributes=parsed.getIndividualAttributes();
    for (    String attr : attributes) {
      String[] split=attr.split(ImportTsv.DEFAULT_ATTRIBUTES_SEPERATOR);
      if (split == null || split.length <= 1) {
        throw new BadTsvLineException(""String_Node_Str"" + attributes);
      }
 else {
        if (split[0].length() <= 0 || split[1].length() <= 0) {
          throw new BadTsvLineException(""String_Node_Str"" + attributes);
        }
        put.setAttribute(split[0],Bytes.toBytes(split[1]));
      }
    }
  }
  put.add(kv);
}","@Override protected void populatePut(byte[] lineBytes,ParsedLine parsed,Put put,int i) throws BadTsvLineException, IOException {
  KeyValue kv;
  kv=new KeyValue(lineBytes,parsed.getRowKeyOffset(),parsed.getRowKeyLength(),parser.getFamily(i),0,parser.getFamily(i).length,parser.getQualifier(i),0,parser.getQualifier(i).length,ts,KeyValue.Type.Put,lineBytes,parsed.getColumnOffset(i),parsed.getColumnLength(i));
  if (parsed.getIndividualAttributes() != null) {
    String[] attributes=parsed.getIndividualAttributes();
    for (    String attr : attributes) {
      String[] split=attr.split(ImportTsv.DEFAULT_ATTRIBUTES_SEPERATOR);
      if (split == null || split.length <= 1) {
        throw new BadTsvLineException(msg(attributes));
      }
 else {
        if (split[0].length() <= 0 || split[1].length() <= 0) {
          throw new BadTsvLineException(msg(attributes));
        }
        put.setAttribute(split[0],Bytes.toBytes(split[1]));
      }
    }
  }
  put.add(kv);
}",0.9748490945674044
61043,"@Test(timeout=30000) public void testLockLeakWithDelta() throws Exception, Throwable {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  HTableDescriptor desc=new HTableDescriptor(tableName);
  desc.addCoprocessor(WaitingForMultiMutationsObserver.class.getName());
  desc.setConfiguration(""String_Node_Str"",String.valueOf(5000));
  desc.addFamily(new HColumnDescriptor(FAMILY));
  TEST_UTIL.getAdmin().createTable(desc);
  Configuration copy=new Configuration(TEST_UTIL.getConfiguration());
  copy.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,2);
  try (Connection con=ConnectionFactory.createConnection(copy)){
    HRegion region=(HRegion)find(tableName);
    region.setTimeoutForWriteLock(10);
    ExecutorService putService=Executors.newSingleThreadExecutor();
    putService.execute(() -> {
      try (Table table=con.getTable(tableName)){
        Put put=new Put(ROW);
        put.addColumn(FAMILY,QUALIFIER,VALUE);
        table.put(put);
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
    }
);
    ExecutorService appendService=Executors.newSingleThreadExecutor();
    appendService.execute(() -> {
      Append append=new Append(ROW);
      append.addColumn(FAMILY,QUALIFIER,VALUE);
      try (Table table=con.getTable(tableName)){
        table.append(append);
        fail(""String_Node_Str"");
      }
 catch (      Throwable ex) {
      }
    }
);
    appendService.shutdown();
    appendService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    WaitingForMultiMutationsObserver observer=find(tableName,WaitingForMultiMutationsObserver.class);
    observer.latch.countDown();
    putService.shutdown();
    putService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    try (Table table=con.getTable(tableName)){
      Result r=table.get(new Get(ROW));
      assertFalse(r.isEmpty());
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),VALUE));
    }
   }
   HRegion region=(HRegion)find(tableName);
  int readLockCount=region.getReadLockCount();
  LOG.info(""String_Node_Str"" + readLockCount);
  assertEquals(0,readLockCount);
}","@Test(timeout=30000) public void testLockLeakWithDelta() throws Exception, Throwable {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  HTableDescriptor desc=new HTableDescriptor(tableName);
  desc.addCoprocessor(WaitingForMultiMutationsObserver.class.getName());
  desc.setConfiguration(""String_Node_Str"",String.valueOf(5000));
  desc.addFamily(new HColumnDescriptor(FAMILY));
  TEST_UTIL.getAdmin().createTable(desc);
  Configuration copy=new Configuration(TEST_UTIL.getConfiguration());
  copy.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,2);
  try (Connection con=ConnectionFactory.createConnection(copy)){
    HRegion region=(HRegion)find(tableName);
    region.setTimeoutForWriteLock(10);
    ExecutorService putService=Executors.newSingleThreadExecutor();
    putService.execute(() -> {
      try (Table table=con.getTable(tableName)){
        Put put=new Put(ROW);
        put.addColumn(FAMILY,QUALIFIER,VALUE);
        table.put(put);
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
    }
);
    ExecutorService appendService=Executors.newSingleThreadExecutor();
    appendService.execute(() -> {
      Append append=new Append(ROW);
      append.addColumn(FAMILY,QUALIFIER,VALUE);
      try (Table table=con.getTable(tableName)){
        table.append(append);
        fail(""String_Node_Str"");
      }
 catch (      Exception ex) {
      }
    }
);
    appendService.shutdown();
    appendService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    WaitingForMultiMutationsObserver observer=find(tableName,WaitingForMultiMutationsObserver.class);
    observer.latch.countDown();
    putService.shutdown();
    putService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    try (Table table=con.getTable(tableName)){
      Result r=table.get(new Get(ROW));
      assertFalse(r.isEmpty());
      assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),VALUE));
    }
   }
   HRegion region=(HRegion)find(tableName);
  int readLockCount=region.getReadLockCount();
  LOG.info(""String_Node_Str"" + readLockCount);
  assertEquals(0,readLockCount);
}",0.995736617716722
61044,"public void testHTableExistsMethodSingleRegionMultipleGets() throws Exception {
  Table table=TEST_UTIL.createTable(TableName.valueOf(name.getMethodName()),new byte[][]{FAMILY});
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  table.put(put);
  List<Get> gets=new ArrayList<>();
  gets.add(new Get(ROW));
  gets.add(null);
  gets.add(new Get(ANOTHERROW));
  boolean[] results=table.existsAll(gets);
  assertEquals(results[0],true);
  assertEquals(results[1],false);
  assertEquals(results[2],false);
}","@Test public void testHTableExistsMethodSingleRegionMultipleGets() throws Exception {
  Table table=TEST_UTIL.createTable(TableName.valueOf(name.getMethodName()),new byte[][]{FAMILY});
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  table.put(put);
  List<Get> gets=new ArrayList<>();
  gets.add(new Get(ROW));
  gets.add(new Get(ANOTHERROW));
  boolean[] results=table.exists(gets);
  assertTrue(results[0]);
  assertFalse(results[1]);
}",0.849539406345957
61045,"@Test(timeout=30000) public void testMultiRowMutations() throws Exception, Throwable {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  HTableDescriptor desc=new HTableDescriptor(tableName);
  desc.addCoprocessor(MultiRowMutationEndpoint.class.getName());
  desc.addCoprocessor(WaitingForMultiMutationsObserver.class.getName());
  desc.setConfiguration(""String_Node_Str"",String.valueOf(5000));
  desc.addFamily(new HColumnDescriptor(FAMILY));
  TEST_UTIL.getAdmin().createTable(desc);
  Configuration copy=new Configuration(TEST_UTIL.getConfiguration());
  copy.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,2);
  try (Connection con=ConnectionFactory.createConnection(copy)){
    byte[] row=Bytes.toBytes(""String_Node_Str"");
    byte[] rowLocked=Bytes.toBytes(""String_Node_Str"");
    byte[] value0=Bytes.toBytes(""String_Node_Str"");
    byte[] value1=Bytes.toBytes(""String_Node_Str"");
    byte[] value2=Bytes.toBytes(""String_Node_Str"");
    assertNoLocks(tableName);
    ExecutorService putService=Executors.newSingleThreadExecutor();
    putService.execute(() -> {
      try (Table table=con.getTable(tableName)){
        Put put0=new Put(rowLocked);
        put0.addColumn(FAMILY,QUALIFIER,value0);
        table.put(put0);
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
    }
);
    ExecutorService cpService=Executors.newSingleThreadExecutor();
    cpService.execute(() -> {
      Put put1=new Put(row);
      Put put2=new Put(rowLocked);
      put1.addColumn(FAMILY,QUALIFIER,value1);
      put2.addColumn(FAMILY,QUALIFIER,value2);
      try (Table table=con.getTable(tableName)){
        MultiRowMutationProtos.MutateRowsRequest request=MultiRowMutationProtos.MutateRowsRequest.newBuilder().addMutationRequest(org.apache.hadoop.hbase.protobuf.ProtobufUtil.toMutation(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.MutationProto.MutationType.PUT,put1)).addMutationRequest(org.apache.hadoop.hbase.protobuf.ProtobufUtil.toMutation(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.MutationProto.MutationType.PUT,put2)).build();
        table.coprocessorService(MultiRowMutationProtos.MultiRowMutationService.class,ROW,ROW,(        MultiRowMutationProtos.MultiRowMutationService exe) -> {
          ServerRpcController controller=new ServerRpcController();
          CoprocessorRpcUtils.BlockingRpcCallback<MultiRowMutationProtos.MutateRowsResponse> rpcCallback=new CoprocessorRpcUtils.BlockingRpcCallback<>();
          exe.mutateRows(controller,request,rpcCallback);
          return rpcCallback.get();
        }
);
        fail(""String_Node_Str"");
      }
 catch (      Throwable ex) {
      }
    }
);
    cpService.shutdown();
    cpService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    WaitingForMultiMutationsObserver observer=find(tableName,WaitingForMultiMutationsObserver.class);
    observer.latch.countDown();
    putService.shutdown();
    putService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    try (Table table=con.getTable(tableName)){
      Get g0=new Get(row);
      Get g1=new Get(rowLocked);
      Result r0=table.get(g0);
      Result r1=table.get(g1);
      assertTrue(r0.isEmpty());
      assertFalse(r1.isEmpty());
      assertTrue(Bytes.equals(r1.getValue(FAMILY,QUALIFIER),value0));
    }
     assertNoLocks(tableName);
  }
 }","@Test(timeout=30000) public void testMultiRowMutations() throws Exception, Throwable {
  final TableName tableName=TableName.valueOf(name.getMethodName());
  HTableDescriptor desc=new HTableDescriptor(tableName);
  desc.addCoprocessor(MultiRowMutationEndpoint.class.getName());
  desc.addCoprocessor(WaitingForMultiMutationsObserver.class.getName());
  desc.setConfiguration(""String_Node_Str"",String.valueOf(5000));
  desc.addFamily(new HColumnDescriptor(FAMILY));
  TEST_UTIL.getAdmin().createTable(desc);
  Configuration copy=new Configuration(TEST_UTIL.getConfiguration());
  copy.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,2);
  try (Connection con=ConnectionFactory.createConnection(copy)){
    byte[] row=Bytes.toBytes(""String_Node_Str"");
    byte[] rowLocked=Bytes.toBytes(""String_Node_Str"");
    byte[] value0=Bytes.toBytes(""String_Node_Str"");
    byte[] value1=Bytes.toBytes(""String_Node_Str"");
    byte[] value2=Bytes.toBytes(""String_Node_Str"");
    assertNoLocks(tableName);
    ExecutorService putService=Executors.newSingleThreadExecutor();
    putService.execute(() -> {
      try (Table table=con.getTable(tableName)){
        Put put0=new Put(rowLocked);
        put0.addColumn(FAMILY,QUALIFIER,value0);
        table.put(put0);
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
    }
);
    ExecutorService cpService=Executors.newSingleThreadExecutor();
    cpService.execute(() -> {
      boolean threw;
      Put put1=new Put(row);
      Put put2=new Put(rowLocked);
      put1.addColumn(FAMILY,QUALIFIER,value1);
      put2.addColumn(FAMILY,QUALIFIER,value2);
      try (Table table=con.getTable(tableName)){
        MultiRowMutationProtos.MutateRowsRequest request=MultiRowMutationProtos.MutateRowsRequest.newBuilder().addMutationRequest(org.apache.hadoop.hbase.protobuf.ProtobufUtil.toMutation(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.MutationProto.MutationType.PUT,put1)).addMutationRequest(org.apache.hadoop.hbase.protobuf.ProtobufUtil.toMutation(org.apache.hadoop.hbase.protobuf.generated.ClientProtos.MutationProto.MutationType.PUT,put2)).build();
        table.coprocessorService(MultiRowMutationProtos.MultiRowMutationService.class,ROW,ROW,(        MultiRowMutationProtos.MultiRowMutationService exe) -> {
          ServerRpcController controller=new ServerRpcController();
          CoprocessorRpcUtils.BlockingRpcCallback<MultiRowMutationProtos.MutateRowsResponse> rpcCallback=new CoprocessorRpcUtils.BlockingRpcCallback<>();
          exe.mutateRows(controller,request,rpcCallback);
          return rpcCallback.get();
        }
);
        threw=false;
      }
 catch (      Throwable ex) {
        threw=true;
      }
      if (!threw) {
        fail(""String_Node_Str"");
      }
    }
);
    cpService.shutdown();
    cpService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    WaitingForMultiMutationsObserver observer=find(tableName,WaitingForMultiMutationsObserver.class);
    observer.latch.countDown();
    putService.shutdown();
    putService.awaitTermination(Long.MAX_VALUE,TimeUnit.DAYS);
    try (Table table=con.getTable(tableName)){
      Get g0=new Get(row);
      Get g1=new Get(rowLocked);
      Result r0=table.get(g0);
      Result r1=table.get(g1);
      assertTrue(r0.isEmpty());
      assertFalse(r1.isEmpty());
      assertTrue(Bytes.equals(r1.getValue(FAMILY,QUALIFIER),value0));
    }
     assertNoLocks(tableName);
  }
 }",0.9755162241887906
61046,"@Test(timeout=60000) public void testAdvancedConfigOverride() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  final TableName tableName=TableName.valueOf(name.getMethodName());
  Table hTable=TEST_UTIL.createTable(tableName,FAMILY,10);
  Admin admin=TEST_UTIL.getAdmin();
  ClusterConnection connection=(ClusterConnection)TEST_UTIL.getConnection();
  byte[] row=Bytes.toBytes(random.nextInt());
  performMultiplePutAndFlush((HBaseAdmin)admin,hTable,row,FAMILY,3,100);
  try (RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName)){
    HRegionLocation loc=locator.getRegionLocation(row,true);
    byte[] regionName=loc.getRegionInfo().getRegionName();
    AdminProtos.AdminService.BlockingInterface server=connection.getAdmin(loc.getServerName());
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() > 1);
    admin.compact(tableName);
    for (int i=0; i < 10 * 1000 / 40; ++i) {
      loc=locator.getRegionLocation(row,true);
      if (!loc.getRegionInfo().isOffline()) {
        regionName=loc.getRegionInfo().getRegionName();
        server=connection.getAdmin(loc.getServerName());
        if (ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() <= 1) {
          break;
        }
      }
      Thread.sleep(40);
    }
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() <= 1);
    LOG.info(""String_Node_Str"");
    HTableDescriptor htd=new HTableDescriptor(hTable.getTableDescriptor());
    htd.setValue(""String_Node_Str"",String.valueOf(5));
    admin.modifyTable(tableName,htd);
    Pair<Integer,Integer> st;
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    performMultiplePutAndFlush((HBaseAdmin)admin,hTable,row,FAMILY,3,10);
    admin.compact(tableName);
    Thread.sleep(10 * 1000);
    loc=locator.getRegionLocation(row,true);
    regionName=loc.getRegionInfo().getRegionName();
    server=connection.getAdmin(loc.getServerName());
    int sfCount=ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size();
    assertTrue(sfCount > 1);
    LOG.info(""String_Node_Str"");
    HColumnDescriptor hcd=new HColumnDescriptor(htd.getFamily(FAMILY));
    hcd.setValue(""String_Node_Str"",String.valueOf(2));
    htd.modifyFamily(hcd);
    admin.modifyTable(tableName,htd);
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    admin.compact(tableName);
    for (int i=0; i < 10 * 1000 / 40; ++i) {
      loc=locator.getRegionLocation(row,true);
      regionName=loc.getRegionInfo().getRegionName();
      try {
        server=connection.getAdmin(loc.getServerName());
        if (ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() < sfCount) {
          break;
        }
      }
 catch (      Exception e) {
        LOG.debug(""String_Node_Str"" + regionName);
      }
      Thread.sleep(40);
    }
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() < sfCount);
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"");
    hcd=new HColumnDescriptor(htd.getFamily(FAMILY));
    hcd.setValue(""String_Node_Str"",null);
    htd.modifyFamily(hcd);
    admin.modifyTable(tableName,htd);
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    assertNull(hTable.getTableDescriptor().getFamily(FAMILY).getValue(""String_Node_Str""));
  }
 }","@Test(timeout=60000) public void testAdvancedConfigOverride() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  final TableName tableName=TableName.valueOf(name.getMethodName());
  Table hTable=TEST_UTIL.createTable(tableName,FAMILY,10);
  Admin admin=TEST_UTIL.getAdmin();
  ClusterConnection connection=(ClusterConnection)TEST_UTIL.getConnection();
  byte[] row=Bytes.toBytes(random.nextInt());
  performMultiplePutAndFlush((HBaseAdmin)admin,hTable,row,FAMILY,3,100);
  try (RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName)){
    HRegionLocation loc=locator.getRegionLocation(row,true);
    byte[] regionName=loc.getRegionInfo().getRegionName();
    AdminProtos.AdminService.BlockingInterface server=connection.getAdmin(loc.getServerName());
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() > 1);
    admin.compact(tableName);
    for (int i=0; i < 10 * 1000 / 40; ++i) {
      loc=locator.getRegionLocation(row,true);
      if (!loc.getRegionInfo().isOffline()) {
        regionName=loc.getRegionInfo().getRegionName();
        server=connection.getAdmin(loc.getServerName());
        if (ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() <= 1) {
          break;
        }
      }
      Thread.sleep(40);
    }
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() <= 1);
    LOG.info(""String_Node_Str"");
    HTableDescriptor htd=new HTableDescriptor(hTable.getTableDescriptor());
    htd.setValue(""String_Node_Str"",String.valueOf(5));
    admin.modifyTable(tableName,htd);
    Pair<Integer,Integer> st;
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    performMultiplePutAndFlush((HBaseAdmin)admin,hTable,row,FAMILY,3,10);
    admin.compact(tableName);
    Thread.sleep(10 * 1000);
    loc=locator.getRegionLocation(row,true);
    regionName=loc.getRegionInfo().getRegionName();
    server=connection.getAdmin(loc.getServerName());
    int sfCount=ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size();
    assertTrue(sfCount > 1);
    LOG.info(""String_Node_Str"");
    HColumnDescriptor hcd=new HColumnDescriptor(htd.getFamily(FAMILY));
    hcd.setValue(""String_Node_Str"",String.valueOf(2));
    htd.modifyFamily(hcd);
    admin.modifyTable(tableName,htd);
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    admin.compact(tableName);
    for (int i=0; i < 10 * 1000 / 40; ++i) {
      loc=locator.getRegionLocation(row,true);
      regionName=loc.getRegionInfo().getRegionName();
      try {
        server=connection.getAdmin(loc.getServerName());
        if (ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() < sfCount) {
          break;
        }
      }
 catch (      Exception e) {
        LOG.debug(""String_Node_Str"" + Bytes.toString(regionName));
      }
      Thread.sleep(40);
    }
    assertTrue(ProtobufUtil.getStoreFiles(server,regionName,FAMILY).size() < sfCount);
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"");
    hcd=new HColumnDescriptor(htd.getFamily(FAMILY));
    hcd.setValue(""String_Node_Str"",null);
    htd.modifyFamily(hcd);
    admin.modifyTable(tableName,htd);
    while (null != (st=admin.getAlterStatus(tableName)) && st.getFirst() > 0) {
      LOG.debug(st.getFirst() + ""String_Node_Str"");
      Thread.sleep(40);
    }
    LOG.info(""String_Node_Str"");
    assertNull(hTable.getTableDescriptor().getFamily(FAMILY).getValue(""String_Node_Str""));
  }
 }",0.9951664876476908
61047,"/** 
 * Test that on a major compaction, if all cells are expired or deleted, then we'll end up with no product. Make sure scanner over region returns right answer in this case - and that it just basically works.
 * @throws IOException
 */
public void testMajorCompactingToNoOutputWithReverseScan() throws IOException {
  createStoreFile(r);
  for (int i=0; i < compactionThreshold; i++) {
    createStoreFile(r);
  }
  Scan scan=new Scan();
  scan.setReversed(true);
  InternalScanner s=r.getScanner(scan);
  do {
    List<Cell> results=new ArrayList<>();
    boolean result=s.next(results);
    assertTrue(!results.isEmpty());
    r.delete(new Delete(CellUtil.cloneRow(results.get(0))));
    if (!result)     break;
  }
 while (true);
  s.close();
  r.flush(true);
  r.compact(true);
  scan=new Scan();
  scan.setReversed(true);
  s=r.getScanner(scan);
  int counter=0;
  do {
    List<Cell> results=new ArrayList<>();
    boolean result=s.next(results);
    if (!result)     break;
    counter++;
  }
 while (true);
  s.close();
  assertEquals(0,counter);
}","/** 
 * Test that on a major compaction, if all cells are expired or deleted, then we'll end up with no product. Make sure scanner over region returns right answer in this case - and that it just basically works.
 * @throws IOException
 */
@Test public void testMajorCompactingToNoOutputWithReverseScan() throws IOException {
  createStoreFile(r);
  for (int i=0; i < compactionThreshold; i++) {
    createStoreFile(r);
  }
  Scan scan=new Scan();
  scan.setReversed(true);
  InternalScanner s=r.getScanner(scan);
  do {
    List<Cell> results=new ArrayList<>();
    boolean result=s.next(results);
    assertTrue(!results.isEmpty());
    r.delete(new Delete(CellUtil.cloneRow(results.get(0))));
    if (!result)     break;
  }
 while (true);
  s.close();
  r.flush(true);
  r.compact(true);
  scan=new Scan();
  scan.setReversed(true);
  s=r.getScanner(scan);
  int counter=0;
  do {
    List<Cell> results=new ArrayList<>();
    boolean result=s.next(results);
    if (!result)     break;
    counter++;
  }
 while (true);
  s.close();
  assertEquals(0,counter);
}",0.9971777986829728
61048,"@Override public boolean equals(Object obj){
  if (obj == null || !(obj instanceof MemStoreSize)) {
    return false;
  }
  MemStoreSize other=(MemStoreSize)obj;
  return this.dataSize == other.dataSize && this.heapSize == other.heapSize;
}","@Override public boolean equals(Object obj){
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  MemStoreSize other=(MemStoreSize)obj;
  return this.dataSize == other.dataSize && this.heapSize == other.heapSize;
}",0.8870292887029289
61049,"@Override public boolean equals(Object obj){
  if (obj == null || !(obj instanceof MemStoreSizing)) {
    return false;
  }
  MemStoreSizing other=(MemStoreSizing)obj;
  return this.dataSize == other.dataSize && this.heapSize == other.heapSize;
}","@Override public boolean equals(Object obj){
  if (obj == null || (getClass() != obj.getClass())) {
    return false;
  }
  MemStoreSizing other=(MemStoreSizing)obj;
  return this.dataSize == other.dataSize && this.heapSize == other.heapSize;
}",0.8816326530612245
61050,"private int createCellReference(ByteBufferKeyValue cell,ByteBuffer idxBuffer,int idxOffset){
  int offset=idxOffset;
  int dataChunkID=cell.getChunkId();
  Chunk c=ChunkCreator.getInstance().saveChunkFromGC(dataChunkID);
  assert(c != null);
  offset=ByteBufferUtils.putInt(idxBuffer,offset,dataChunkID);
  offset=ByteBufferUtils.putInt(idxBuffer,offset,cell.getOffset());
  offset=ByteBufferUtils.putInt(idxBuffer,offset,KeyValueUtil.length(cell));
  offset=ByteBufferUtils.putLong(idxBuffer,offset,cell.getSequenceId());
  return offset;
}","private int createCellReference(ByteBufferKeyValue cell,ByteBuffer idxBuffer,int idxOffset){
  int offset=idxOffset;
  int dataChunkID=cell.getChunkId();
  offset=ByteBufferUtils.putInt(idxBuffer,offset,dataChunkID);
  offset=ByteBufferUtils.putInt(idxBuffer,offset,cell.getOffset());
  offset=ByteBufferUtils.putInt(idxBuffer,offset,KeyValueUtil.length(cell));
  offset=ByteBufferUtils.putLong(idxBuffer,offset,cell.getSequenceId());
  return offset;
}",0.4466800804828973
61051,"private void removeChunks(Set<Integer> chunkIDs){
  this.weakChunkIdMap.keySet().removeAll(chunkIDs);
  this.strongChunkIdMap.keySet().removeAll(chunkIDs);
}","private void removeChunks(Set<Integer> chunkIDs){
  this.chunkIdMap.keySet().removeAll(chunkIDs);
}",0.7734375
61052,"/** 
 * Creates the chunk either onheap or offheap
 * @param pool indicates if the chunks have to be created which will be used by the Pool
 * @return the chunk
 */
private Chunk createChunk(boolean pool){
}","/** 
 * Creates the chunk either onheap or offheap
 * @param pool indicates if the chunks have to be created which will be used by the Pool
 * @param chunkIndexType
 * @return the chunk
 */
private Chunk createChunk(boolean pool,CompactingMemStore.IndexType chunkIndexType){
}",0.8571428571428571
61053,"/** 
 * Poll a chunk from the pool, reset it if not null, else create a new chunk to return if we have not yet created max allowed chunks count. When we have already created max allowed chunks and no free chunks as of now, return null. It is the responsibility of the caller to make a chunk then. Note: Chunks returned by this pool must be put back to the pool after its use.
 * @return a chunk
 * @see #putbackChunks(Set)
 */
Chunk getChunk(){
  Chunk chunk=reclaimedChunks.poll();
  if (chunk != null) {
    chunk.reset();
    reusedChunkCount.incrementAndGet();
  }
 else {
    while (true) {
      long created=this.chunkCount.get();
      if (created < this.maxCount) {
        if (this.chunkCount.compareAndSet(created,created + 1)) {
          chunk=createChunk(true);
          break;
        }
      }
 else {
        break;
      }
    }
  }
  return chunk;
}","/** 
 * Poll a chunk from the pool, reset it if not null, else create a new chunk to return if we have not yet created max allowed chunks count. When we have already created max allowed chunks and no free chunks as of now, return null. It is the responsibility of the caller to make a chunk then. Note: Chunks returned by this pool must be put back to the pool after its use.
 * @return a chunk
 * @see #putbackChunks(Chunk)
 */
Chunk getChunk(){
  Chunk chunk=reclaimedChunks.poll();
  if (chunk != null) {
    chunk.reset();
    reusedChunkCount.incrementAndGet();
  }
 else {
    while (true) {
      long created=this.chunkCount.get();
      if (created < this.maxCount) {
        if (this.chunkCount.compareAndSet(created,created + 1)) {
          chunk=createChunk(true,CompactingMemStore.IndexType.ARRAY_MAP);
          break;
        }
      }
 else {
        break;
      }
    }
  }
  return chunk;
}",0.9735806632939854
61054,"MemStoreChunkPool(int maxCount,int initialCount,float poolSizePercentage){
  this.maxCount=maxCount;
  this.poolSizePercentage=poolSizePercentage;
  this.reclaimedChunks=new LinkedBlockingQueue<>();
  for (int i=0; i < initialCount; i++) {
    Chunk chunk=createChunk(true);
    chunk.init();
    reclaimedChunks.add(chunk);
  }
  chunkCount.set(initialCount);
  final String n=Thread.currentThread().getName();
  scheduleThreadPool=Executors.newScheduledThreadPool(1,new ThreadFactoryBuilder().setNameFormat(n + ""String_Node_Str"").setDaemon(true).build());
  this.scheduleThreadPool.scheduleAtFixedRate(new StatisticsThread(),statThreadPeriod,statThreadPeriod,TimeUnit.SECONDS);
}","MemStoreChunkPool(int maxCount,int initialCount,float poolSizePercentage){
  this.maxCount=maxCount;
  this.poolSizePercentage=poolSizePercentage;
  this.reclaimedChunks=new LinkedBlockingQueue<>();
  for (int i=0; i < initialCount; i++) {
    Chunk chunk=createChunk(true,CompactingMemStore.IndexType.ARRAY_MAP);
    chunk.init();
    reclaimedChunks.add(chunk);
  }
  chunkCount.set(initialCount);
  final String n=Thread.currentThread().getName();
  scheduleThreadPool=Executors.newScheduledThreadPool(1,new ThreadFactoryBuilder().setNameFormat(n + ""String_Node_Str"").setDaemon(true).build());
  this.scheduleThreadPool.scheduleAtFixedRate(new StatisticsThread(),statThreadPeriod,statThreadPeriod,TimeUnit.SECONDS);
}",0.9721627408993576
61055,"Chunk removeChunk(int chunkId){
  WeakReference<Chunk> weak=this.weakChunkIdMap.remove(chunkId);
  Chunk strong=this.strongChunkIdMap.remove(chunkId);
  if (weak != null) {
    return weak.get();
  }
  return strong;
}","Chunk removeChunk(int chunkId){
  return this.chunkIdMap.remove(chunkId);
}",0.4846416382252559
61056,"@VisibleForTesting void clearChunkIds(){
  this.strongChunkIdMap.clear();
  this.weakChunkIdMap.clear();
}","@VisibleForTesting void clearChunkIds(){
  this.chunkIdMap.clear();
}",0.7885714285714286
61057,"/** 
 * Initializes the instance of MSLABChunkCreator
 * @param chunkSize the chunkSize
 * @param offheap indicates if the chunk is to be created offheap or not
 * @param globalMemStoreSize  the global memstore size
 * @param poolSizePercentage pool size percentage
 * @param initialCountPercentage the initial count of the chunk pool if any
 * @param heapMemoryManager the heapmemory manager
 * @return singleton MSLABChunkCreator
 */
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @VisibleForTesting public static ChunkCreator initialize(int chunkSize,boolean offheap,long globalMemStoreSize,float poolSizePercentage,float initialCountPercentage,HeapMemoryManager heapMemoryManager){
  if (INSTANCE != null)   return INSTANCE;
  INSTANCE=new ChunkCreator(chunkSize,offheap,globalMemStoreSize,poolSizePercentage,initialCountPercentage,heapMemoryManager);
  return INSTANCE;
}","/** 
 * Initializes the instance of ChunkCreator
 * @param chunkSize the chunkSize
 * @param offheap indicates if the chunk is to be created offheap or not
 * @param globalMemStoreSize  the global memstore size
 * @param poolSizePercentage pool size percentage
 * @param initialCountPercentage the initial count of the chunk pool if any
 * @param heapMemoryManager the heapmemory manager
 * @return singleton MSLABChunkCreator
 */
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @VisibleForTesting public static ChunkCreator initialize(int chunkSize,boolean offheap,long globalMemStoreSize,float poolSizePercentage,float initialCountPercentage,HeapMemoryManager heapMemoryManager){
  if (INSTANCE != null)   return INSTANCE;
  INSTANCE=new ChunkCreator(chunkSize,offheap,globalMemStoreSize,poolSizePercentage,initialCountPercentage,heapMemoryManager);
  return INSTANCE;
}",0.5977504017139796
61058,"synchronized void putbackChunks(Set<Integer> chunks){
  if (pool != null) {
    pool.putbackChunks(chunks);
  }
 else {
    this.removeChunks(chunks);
  }
}","synchronized void putbackChunks(Set<Integer> chunks){
  if (pool == null) {
    this.removeChunks(chunks);
    return;
  }
  for (  int chunkID : chunks) {
    Chunk chunk=ChunkCreator.this.getChunk(chunkID);
    if (chunk != null) {
      pool.putbackChunks(chunk);
    }
  }
  return;
}",0.4684684684684684
61059,"private void replaceAtIndex(int idx,ImmutableSegment newSegment){
  pipeline.set(idx,newSegment);
  readOnlyCopy=new LinkedList<>(pipeline);
}","@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") private void replaceAtIndex(int idx,ImmutableSegment newSegment){
  pipeline.set(idx,newSegment);
  readOnlyCopy=new LinkedList<>(pipeline);
  version++;
}",0.7029702970297029
61060,"private void swapSuffix(List<? extends Segment> suffix,ImmutableSegment segment,boolean closeSegmentsInSuffix){
  if (closeSegmentsInSuffix) {
    for (    Segment itemInSuffix : suffix) {
      itemInSuffix.close();
    }
  }
  pipeline.removeAll(suffix);
  if (segment != null)   pipeline.addLast(segment);
}","private void swapSuffix(List<? extends Segment> suffix,ImmutableSegment segment,boolean closeSegmentsInSuffix){
  pipeline.removeAll(suffix);
  if (segment != null)   pipeline.addLast(segment);
  if (closeSegmentsInSuffix) {
    for (    Segment itemInSuffix : suffix) {
      itemInSuffix.close();
    }
  }
}",0.6290322580645161
61061,"@Override public Map<ServerName,List<HRegionInfo>> roundRobinAssignment(List<HRegionInfo> regions,List<ServerName> servers) throws HBaseIOException {
  Map<ServerName,List<HRegionInfo>> assignments=Maps.newHashMap();
  ListMultimap<String,HRegionInfo> regionMap=ArrayListMultimap.create();
  ListMultimap<String,ServerName> serverMap=ArrayListMultimap.create();
  generateGroupMaps(regions,servers,regionMap,serverMap);
  for (  String groupKey : regionMap.keySet()) {
    if (regionMap.get(groupKey).size() > 0) {
      Map<ServerName,List<HRegionInfo>> result=this.internalBalancer.roundRobinAssignment(regionMap.get(groupKey),serverMap.get(groupKey));
      if (result != null) {
        assignments.putAll(result);
      }
    }
  }
  return assignments;
}","@Override public Map<ServerName,List<HRegionInfo>> roundRobinAssignment(List<HRegionInfo> regions,List<ServerName> servers) throws HBaseIOException {
  Map<ServerName,List<HRegionInfo>> assignments=Maps.newHashMap();
  ListMultimap<String,HRegionInfo> regionMap=ArrayListMultimap.create();
  ListMultimap<String,ServerName> serverMap=ArrayListMultimap.create();
  generateGroupMaps(regions,servers,regionMap,serverMap);
  for (  String groupKey : regionMap.keySet()) {
    if (regionMap.get(groupKey).size() > 0) {
      Map<ServerName,List<HRegionInfo>> result=this.internalBalancer.roundRobinAssignment(regionMap.get(groupKey),serverMap.get(groupKey));
      if (result != null) {
        if (result.containsKey(LoadBalancer.BOGUS_SERVER_NAME) && assignments.containsKey(LoadBalancer.BOGUS_SERVER_NAME)) {
          assignments.get(LoadBalancer.BOGUS_SERVER_NAME).addAll(result.get(LoadBalancer.BOGUS_SERVER_NAME));
        }
 else {
          assignments.putAll(result);
        }
      }
    }
  }
  return assignments;
}",0.8246498599439775
61062,"public void runTestAtomicity(long millisToRun,int numWriters,int numGetters,int numScanners,int numUniqueRows,final boolean systemTest,final boolean useMob) throws Exception {
  createTableIfMissing(useMob);
  TestContext ctx=new TestContext(util.getConfiguration());
  byte rows[][]=new byte[numUniqueRows][];
  for (int i=0; i < numUniqueRows; i++) {
    rows[i]=Bytes.toBytes(""String_Node_Str"" + i);
  }
  List<AtomicityWriter> writers=Lists.newArrayList();
  for (int i=0; i < numWriters; i++) {
    AtomicityWriter writer=new AtomicityWriter(ctx,rows,FAMILIES,getSharedThreadPool());
    writers.add(writer);
    ctx.addThread(writer);
  }
  ctx.addThread(new RepeatingTestThread(ctx){
    Admin admin=util.getAdmin();
    public void doAnAction() throws Exception {
      try {
        admin.flush(TABLE_NAME);
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"" + StringUtils.stringifyException(ioe));
      }
      if (systemTest)       Thread.sleep(60000);
    }
  }
);
  List<AtomicGetReader> getters=Lists.newArrayList();
  for (int i=0; i < numGetters; i++) {
    AtomicGetReader getter=new AtomicGetReader(ctx,rows[i % numUniqueRows],FAMILIES,getSharedThreadPool());
    getters.add(getter);
    ctx.addThread(getter);
  }
  List<AtomicScanReader> scanners=Lists.newArrayList();
  for (int i=0; i < numScanners; i++) {
    AtomicScanReader scanner=new AtomicScanReader(ctx,FAMILIES,getSharedThreadPool());
    scanners.add(scanner);
    ctx.addThread(scanner);
  }
  ctx.startThreads();
  ctx.waitFor(millisToRun);
  ctx.stop();
  LOG.info(""String_Node_Str"");
  for (  AtomicityWriter writer : writers) {
    LOG.info(""String_Node_Str"" + writer.numWritten.get());
  }
  LOG.info(""String_Node_Str"");
  for (  AtomicGetReader reader : getters) {
    LOG.info(""String_Node_Str"" + reader.numRead.get());
  }
  LOG.info(""String_Node_Str"");
  for (  AtomicScanReader scanner : scanners) {
    LOG.info(""String_Node_Str"" + scanner.numScans.get());
    LOG.info(""String_Node_Str"" + scanner.numRowsScanned.get() + ""String_Node_Str"");
  }
}","public void runTestAtomicity(long millisToRun,int numWriters,int numGetters,int numScanners,int numUniqueRows,final boolean systemTest,final boolean useMob) throws Exception {
  createTableIfMissing(useMob);
  util.getConfiguration().setInt(""String_Node_Str"",40);
  TestContext ctx=new TestContext(util.getConfiguration());
  byte rows[][]=new byte[numUniqueRows][];
  for (int i=0; i < numUniqueRows; i++) {
    rows[i]=Bytes.toBytes(""String_Node_Str"" + i);
  }
  List<AtomicityWriter> writers=Lists.newArrayList();
  for (int i=0; i < numWriters; i++) {
    AtomicityWriter writer=new AtomicityWriter(ctx,rows,FAMILIES,getSharedThreadPool());
    writers.add(writer);
    ctx.addThread(writer);
  }
  ctx.addThread(new RepeatingTestThread(ctx){
    Admin admin=util.getAdmin();
    public void doAnAction() throws Exception {
      try {
        admin.flush(TABLE_NAME);
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"" + StringUtils.stringifyException(ioe));
      }
      if (systemTest)       Thread.sleep(60000);
    }
  }
);
  List<AtomicGetReader> getters=Lists.newArrayList();
  for (int i=0; i < numGetters; i++) {
    AtomicGetReader getter=new AtomicGetReader(ctx,rows[i % numUniqueRows],FAMILIES,getSharedThreadPool());
    getters.add(getter);
    ctx.addThread(getter);
  }
  List<AtomicScanReader> scanners=Lists.newArrayList();
  for (int i=0; i < numScanners; i++) {
    AtomicScanReader scanner=new AtomicScanReader(ctx,FAMILIES,getSharedThreadPool());
    scanners.add(scanner);
    ctx.addThread(scanner);
  }
  ctx.startThreads();
  ctx.waitFor(millisToRun);
  ctx.stop();
  LOG.info(""String_Node_Str"");
  for (  AtomicityWriter writer : writers) {
    LOG.info(""String_Node_Str"" + writer.numWritten.get());
  }
  LOG.info(""String_Node_Str"");
  for (  AtomicGetReader reader : getters) {
    LOG.info(""String_Node_Str"" + reader.numRead.get());
  }
  LOG.info(""String_Node_Str"");
  for (  AtomicScanReader scanner : scanners) {
    LOG.info(""String_Node_Str"" + scanner.numScans.get());
    LOG.info(""String_Node_Str"" + scanner.numRowsScanned.get() + ""String_Node_Str"");
  }
}",0.9866348448687352
61063,"@Override public Result[] addAndGet(Result[] results,boolean isHeartbeatMessage) throws IOException {
  if (results.length == 0) {
    return EMPTY_RESULT_ARRAY;
  }
  int i;
  for (i=0; i < results.length; i++) {
    Result r=filterCells(results[i],lastCell);
    if (r != null) {
      results[i]=r;
      break;
    }
  }
  if (i == results.length) {
    return EMPTY_RESULT_ARRAY;
  }
  updateLastCell(results[results.length - 1]);
  if (i > 0) {
    return Arrays.copyOfRange(results,i,results.length);
  }
 else {
    return results;
  }
}","@Override public Result[] addAndGet(Result[] results,boolean isHeartbeatMessage) throws IOException {
  if (results.length == 0) {
    if (!isHeartbeatMessage && lastResultPartial) {
      numberOfCompleteRows++;
    }
    return EMPTY_RESULT_ARRAY;
  }
  int i;
  for (i=0; i < results.length; i++) {
    Result r=filterCells(results[i],lastCell);
    if (r != null) {
      results[i]=r;
      break;
    }
  }
  if (i == results.length) {
    return EMPTY_RESULT_ARRAY;
  }
  if (lastResultPartial && !CellUtil.matchingRow(lastCell,results[0].getRow())) {
    numberOfCompleteRows++;
  }
  recordLastResult(results[results.length - 1]);
  if (i > 0) {
    results=Arrays.copyOfRange(results,i,results.length);
  }
  for (  Result result : results) {
    if (!result.mayHaveMoreCellsInRow()) {
      numberOfCompleteRows++;
    }
  }
  return results;
}",0.7142857142857143
61064,"synchronized boolean prepare(ScanResponse resp,int numberOfIndividualRows){
  if (state == ScanResumerState.RESUMED) {
    return false;
  }
  state=ScanResumerState.SUSPENDED;
  this.resp=resp;
  this.numberOfIndividualRows=numberOfIndividualRows;
  if (resp.getMoreResultsInRegion()) {
    scheduleRenewLeaseTask();
  }
  return true;
}","synchronized boolean prepare(ScanResponse resp,int numberOfCompleteRows){
  if (state == ScanResumerState.RESUMED) {
    return false;
  }
  state=ScanResumerState.SUSPENDED;
  this.resp=resp;
  this.numberOfCompleteRows=numberOfCompleteRows;
  if (resp.getMoreResultsInRegion()) {
    scheduleRenewLeaseTask();
  }
  return true;
}",0.9194029850746268
61065,"private void completeOrNext(ScanResponse resp,int numIndividualRows){
}","private void completeOrNext(ScanResponse resp,int numberOfCompleteRows){
}",0.8551724137931035
61066,"@Override public void resume(){
  ScanResponse localResp;
  int localNumberOfIndividualRows;
synchronized (this) {
    if (state == ScanResumerState.INITIALIZED) {
      state=ScanResumerState.RESUMED;
      return;
    }
    if (state == ScanResumerState.RESUMED) {
      return;
    }
    state=ScanResumerState.RESUMED;
    if (leaseRenewer != null) {
      leaseRenewer.cancel();
    }
    localResp=this.resp;
    localNumberOfIndividualRows=this.numberOfIndividualRows;
  }
  completeOrNext(localResp,localNumberOfIndividualRows);
}","@Override public void resume(){
  ScanResponse localResp;
  int localNumberOfCompleteRows;
synchronized (this) {
    if (state == ScanResumerState.INITIALIZED) {
      state=ScanResumerState.RESUMED;
      return;
    }
    if (state == ScanResumerState.RESUMED) {
      return;
    }
    state=ScanResumerState.RESUMED;
    if (leaseRenewer != null) {
      leaseRenewer.cancel();
    }
    localResp=this.resp;
    localNumberOfCompleteRows=this.numberOfCompleteRows;
  }
  completeOrNext(localResp,localNumberOfCompleteRows);
}",0.9325842696629212
61067,"private void onComplete(HBaseRpcController controller,ScanResponse resp){
  if (controller.failed()) {
    onError(controller.getFailed());
    return;
  }
  updateServerSideMetrics(scanMetrics,resp);
  boolean isHeartbeatMessage=resp.hasHeartbeatMessage() && resp.getHeartbeatMessage();
  Result[] results;
  try {
    Result[] rawResults=ResponseConverter.getResults(controller.cellScanner(),resp);
    updateResultsMetrics(scanMetrics,rawResults,isHeartbeatMessage);
    results=resultCache.addAndGet(Optional.ofNullable(rawResults).orElse(ScanResultCache.EMPTY_RESULT_ARRAY),isHeartbeatMessage);
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    completeWhenError(true);
    return;
  }
  int numberOfIndividualRows=numberOfIndividualRows(Arrays.asList(results));
  ScanControllerImpl scanController=new ScanControllerImpl();
  if (results.length == 0) {
    consumer.onHeartbeat(scanController);
  }
 else {
    updateNextStartRowWhenError(results[results.length - 1]);
    consumer.onNext(results,scanController);
  }
  ScanControllerState state=scanController.destroy();
  if (state == ScanControllerState.TERMINATED) {
    if (resp.getMoreResultsInRegion()) {
      closeScanner();
    }
    completeNoMoreResults();
    return;
  }
  if (state == ScanControllerState.SUSPENDED) {
    if (scanController.resumer.prepare(resp,numberOfIndividualRows)) {
      return;
    }
  }
  completeOrNext(resp,numberOfIndividualRows);
}","private void onComplete(HBaseRpcController controller,ScanResponse resp){
  if (controller.failed()) {
    onError(controller.getFailed());
    return;
  }
  updateServerSideMetrics(scanMetrics,resp);
  boolean isHeartbeatMessage=resp.hasHeartbeatMessage() && resp.getHeartbeatMessage();
  Result[] results;
  int numberOfCompleteRowsBefore=resultCache.numberOfCompleteRows();
  try {
    Result[] rawResults=ResponseConverter.getResults(controller.cellScanner(),resp);
    updateResultsMetrics(scanMetrics,rawResults,isHeartbeatMessage);
    results=resultCache.addAndGet(Optional.ofNullable(rawResults).orElse(ScanResultCache.EMPTY_RESULT_ARRAY),isHeartbeatMessage);
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"",e);
    completeWhenError(true);
    return;
  }
  ScanControllerImpl scanController=new ScanControllerImpl();
  if (results.length > 0) {
    updateNextStartRowWhenError(results[results.length - 1]);
    consumer.onNext(results,scanController);
  }
 else   if (resp.hasHeartbeatMessage() && resp.getHeartbeatMessage()) {
    consumer.onHeartbeat(scanController);
  }
  ScanControllerState state=scanController.destroy();
  if (state == ScanControllerState.TERMINATED) {
    if (resp.getMoreResultsInRegion()) {
      closeScanner();
    }
    completeNoMoreResults();
    return;
  }
  int numberOfCompleteRows=resultCache.numberOfCompleteRows() - numberOfCompleteRowsBefore;
  if (state == ScanControllerState.SUSPENDED) {
    if (scanController.resumer.prepare(resp,numberOfCompleteRows)) {
      return;
    }
  }
  completeOrNext(resp,numberOfCompleteRows);
}",0.8198227765014768
61068,"private Result createCompletedResult() throws IOException {
  Result result=Result.createCompleteResult(partialResults);
  partialResults.clear();
  numCellsOfPartialResults=0;
  return result;
}","private Result createCompletedResult() throws IOException {
  numberOfCompleteRows++;
  Result result=Result.createCompleteResult(partialResults);
  partialResults.clear();
  numCellsOfPartialResults=0;
  return result;
}",0.9375
61069,"@Override public Result[] addAndGet(Result[] results,boolean isHeartbeatMessage) throws IOException {
  if (results.length == 0) {
    if (!partialResults.isEmpty() && !isHeartbeatMessage) {
      return new Result[]{createCompletedResult()};
    }
    return EMPTY_RESULT_ARRAY;
  }
  List<Result> regroupedResults=new ArrayList<>();
  for (  Result result : results) {
    result=filterCells(result,lastCell);
    if (result == null) {
      continue;
    }
    if (!partialResults.isEmpty() && !Bytes.equals(partialResults.peek().getRow(),result.getRow())) {
      regroupedResults.add(createCompletedResult());
    }
    Result regroupedResult=regroupResults(result);
    if (regroupedResult != null) {
      regroupedResults.add(regroupedResult);
      updateLastCell(regroupedResult);
    }
    if (!result.mayHaveMoreCellsInRow() && !partialResults.isEmpty()) {
      regroupedResults.add(createCompletedResult());
    }
  }
  return regroupedResults.toArray(new Result[0]);
}","@Override public Result[] addAndGet(Result[] results,boolean isHeartbeatMessage) throws IOException {
  if (results.length == 0) {
    if (!isHeartbeatMessage) {
      if (!partialResults.isEmpty()) {
        return new Result[]{createCompletedResult()};
      }
      if (lastResultPartial) {
        numberOfCompleteRows++;
      }
    }
    return EMPTY_RESULT_ARRAY;
  }
  List<Result> regroupedResults=new ArrayList<>();
  for (  Result result : results) {
    result=filterCells(result,lastCell);
    if (result == null) {
      continue;
    }
    if (!partialResults.isEmpty()) {
      if (!Bytes.equals(partialResults.peek().getRow(),result.getRow())) {
        regroupedResults.add(createCompletedResult());
      }
    }
 else     if (lastResultPartial && !CellUtil.matchingRow(lastCell,result.getRow())) {
      numberOfCompleteRows++;
    }
    if (!partialResults.isEmpty() && !Bytes.equals(partialResults.peek().getRow(),result.getRow())) {
      regroupedResults.add(createCompletedResult());
    }
    Result regroupedResult=regroupResults(result);
    if (regroupedResult != null) {
      if (!regroupedResult.mayHaveMoreCellsInRow()) {
        numberOfCompleteRows++;
      }
      regroupedResults.add(regroupedResult);
      recordLastResult(regroupedResult);
    }
    if (!result.mayHaveMoreCellsInRow() && !partialResults.isEmpty()) {
      regroupedResults.add(createCompletedResult());
    }
  }
  return regroupedResults.toArray(new Result[0]);
}",0.740228013029316
61070,"void regionMoved(int region,int oldServer,int newServer){
  regionIndexToServerIndex[region]=newServer;
  if (initialRegionIndexToServerIndex[region] == newServer) {
    numMovedRegions--;
  }
 else   if (oldServer >= 0 && initialRegionIndexToServerIndex[region] == oldServer) {
    numMovedRegions++;
  }
  int tableIndex=regionIndexToTableIndex[region];
  if (oldServer >= 0) {
    numRegionsPerServerPerTable[oldServer][tableIndex]--;
  }
  numRegionsPerServerPerTable[newServer][tableIndex]++;
  if (numRegionsPerServerPerTable[newServer][tableIndex] > numMaxRegionsPerTable[tableIndex]) {
    numRegionsPerServerPerTable[newServer][tableIndex]=numMaxRegionsPerTable[tableIndex];
  }
 else   if (oldServer >= 0 && (numRegionsPerServerPerTable[oldServer][tableIndex] + 1) == numMaxRegionsPerTable[tableIndex]) {
    for (int serverIndex=0; serverIndex < numRegionsPerServerPerTable.length; serverIndex++) {
      if (numRegionsPerServerPerTable[serverIndex][tableIndex] > numMaxRegionsPerTable[tableIndex]) {
        numMaxRegionsPerTable[tableIndex]=numRegionsPerServerPerTable[serverIndex][tableIndex];
      }
    }
  }
  int primary=regionIndexToPrimaryIndex[region];
  if (oldServer >= 0) {
    primariesOfRegionsPerServer[oldServer]=removeRegion(primariesOfRegionsPerServer[oldServer],primary);
  }
  primariesOfRegionsPerServer[newServer]=addRegionSorted(primariesOfRegionsPerServer[newServer],primary);
  if (multiServersPerHost) {
    int oldHost=oldServer >= 0 ? serverIndexToHostIndex[oldServer] : -1;
    int newHost=serverIndexToHostIndex[newServer];
    if (newHost != oldHost) {
      regionsPerHost[newHost]=addRegion(regionsPerHost[newHost],region);
      primariesOfRegionsPerHost[newHost]=addRegionSorted(primariesOfRegionsPerHost[newHost],primary);
      if (oldHost >= 0) {
        regionsPerHost[oldHost]=removeRegion(regionsPerHost[oldHost],region);
        primariesOfRegionsPerHost[oldHost]=removeRegion(primariesOfRegionsPerHost[oldHost],primary);
      }
    }
  }
  if (numRacks > 1) {
    int oldRack=oldServer >= 0 ? serverIndexToRackIndex[oldServer] : -1;
    int newRack=serverIndexToRackIndex[newServer];
    if (newRack != oldRack) {
      regionsPerRack[newRack]=addRegion(regionsPerRack[newRack],region);
      primariesOfRegionsPerRack[newRack]=addRegionSorted(primariesOfRegionsPerRack[newRack],primary);
      if (oldRack >= 0) {
        regionsPerRack[oldRack]=removeRegion(regionsPerRack[oldRack],region);
        primariesOfRegionsPerRack[oldRack]=removeRegion(primariesOfRegionsPerRack[oldRack],primary);
      }
    }
  }
}","void regionMoved(int region,int oldServer,int newServer){
  regionIndexToServerIndex[region]=newServer;
  if (initialRegionIndexToServerIndex[region] == newServer) {
    numMovedRegions--;
  }
 else   if (oldServer >= 0 && initialRegionIndexToServerIndex[region] == oldServer) {
    numMovedRegions++;
  }
  int tableIndex=regionIndexToTableIndex[region];
  if (oldServer >= 0) {
    numRegionsPerServerPerTable[oldServer][tableIndex]--;
  }
  numRegionsPerServerPerTable[newServer][tableIndex]++;
  if (numRegionsPerServerPerTable[newServer][tableIndex] > numMaxRegionsPerTable[tableIndex]) {
    numMaxRegionsPerTable[tableIndex]=numRegionsPerServerPerTable[newServer][tableIndex];
  }
 else   if (oldServer >= 0 && (numRegionsPerServerPerTable[oldServer][tableIndex] + 1) == numMaxRegionsPerTable[tableIndex]) {
    for (int serverIndex=0; serverIndex < numRegionsPerServerPerTable.length; serverIndex++) {
      if (numRegionsPerServerPerTable[serverIndex][tableIndex] > numMaxRegionsPerTable[tableIndex]) {
        numMaxRegionsPerTable[tableIndex]=numRegionsPerServerPerTable[serverIndex][tableIndex];
      }
    }
  }
  int primary=regionIndexToPrimaryIndex[region];
  if (oldServer >= 0) {
    primariesOfRegionsPerServer[oldServer]=removeRegion(primariesOfRegionsPerServer[oldServer],primary);
  }
  primariesOfRegionsPerServer[newServer]=addRegionSorted(primariesOfRegionsPerServer[newServer],primary);
  if (multiServersPerHost) {
    int oldHost=oldServer >= 0 ? serverIndexToHostIndex[oldServer] : -1;
    int newHost=serverIndexToHostIndex[newServer];
    if (newHost != oldHost) {
      regionsPerHost[newHost]=addRegion(regionsPerHost[newHost],region);
      primariesOfRegionsPerHost[newHost]=addRegionSorted(primariesOfRegionsPerHost[newHost],primary);
      if (oldHost >= 0) {
        regionsPerHost[oldHost]=removeRegion(regionsPerHost[oldHost],region);
        primariesOfRegionsPerHost[oldHost]=removeRegion(primariesOfRegionsPerHost[oldHost],primary);
      }
    }
  }
  if (numRacks > 1) {
    int oldRack=oldServer >= 0 ? serverIndexToRackIndex[oldServer] : -1;
    int newRack=serverIndexToRackIndex[newServer];
    if (newRack != oldRack) {
      regionsPerRack[newRack]=addRegion(regionsPerRack[newRack],region);
      primariesOfRegionsPerRack[newRack]=addRegionSorted(primariesOfRegionsPerRack[newRack],primary);
      if (oldRack >= 0) {
        regionsPerRack[oldRack]=removeRegion(regionsPerRack[oldRack],region);
        primariesOfRegionsPerRack[oldRack]=removeRegion(primariesOfRegionsPerRack[oldRack],primary);
      }
    }
  }
}",0.980544747081712
61071,"@Test(timeout=180000) public void testRegionAvailabilityWithRegionMoves() throws Exception {
  List<HRegionInfo> list0=new ArrayList<HRegionInfo>();
  List<HRegionInfo> list1=new ArrayList<HRegionInfo>();
  List<HRegionInfo> list2=new ArrayList<HRegionInfo>();
  HRegionInfo hri1=new HRegionInfo(TableName.valueOf(name.getMethodName()),""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes(),false,100);
  HRegionInfo hri2=RegionReplicaUtil.getRegionInfoForReplica(hri1,1);
  HRegionInfo hri3=new HRegionInfo(TableName.valueOf(name.getMethodName()),""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes(),false,101);
  list0.add(hri1);
  list1.add(hri2);
  list2.add(hri3);
  Map<ServerName,List<HRegionInfo>> clusterState=new LinkedHashMap<ServerName,List<HRegionInfo>>();
  clusterState.put(servers[0],list0);
  clusterState.put(servers[1],list1);
  clusterState.put(servers[2],list2);
  Cluster cluster=new Cluster(clusterState,null,null,rackManager);
  assertTrue(!cluster.wouldLowerAvailability(hri1,servers[2]));
  cluster.doAction(new MoveRegionAction(0,0,2));
  assertTrue(cluster.wouldLowerAvailability(hri1,servers[2]));
  clusterState.clear();
  List<HRegionInfo> list3=new ArrayList<HRegionInfo>();
  HRegionInfo hri4=RegionReplicaUtil.getRegionInfoForReplica(hri3,1);
  list3.add(hri4);
  clusterState.put(servers[0],list0);
  clusterState.put(servers[5],list1);
  clusterState.put(servers[6],list2);
  clusterState.put(servers[12],list3);
  cluster=new Cluster(clusterState,null,null,rackManager);
  assertTrue(!cluster.wouldLowerAvailability(hri4,servers[0]));
  cluster.doAction(new MoveRegionAction(2,2,0));
  assertTrue(cluster.wouldLowerAvailability(hri3,servers[0]));
}","@Test(timeout=180000) public void testRegionAvailabilityWithRegionMoves() throws Exception {
  List<HRegionInfo> list0=new ArrayList<HRegionInfo>();
  List<HRegionInfo> list1=new ArrayList<HRegionInfo>();
  List<HRegionInfo> list2=new ArrayList<HRegionInfo>();
  HRegionInfo hri1=new HRegionInfo(TableName.valueOf(name.getMethodName()),""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes(),false,100);
  HRegionInfo hri2=RegionReplicaUtil.getRegionInfoForReplica(hri1,1);
  HRegionInfo hri3=new HRegionInfo(TableName.valueOf(name.getMethodName()),""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes(),false,101);
  list0.add(hri1);
  list1.add(hri2);
  list2.add(hri3);
  Map<ServerName,List<HRegionInfo>> clusterState=new LinkedHashMap<ServerName,List<HRegionInfo>>();
  clusterState.put(servers[0],list0);
  clusterState.put(servers[1],list1);
  clusterState.put(servers[2],list2);
  Cluster cluster=new Cluster(clusterState,null,null,rackManager);
  assertTrue(!cluster.wouldLowerAvailability(hri1,servers[2]));
  cluster.doAction(new MoveRegionAction(0,0,2));
  assertEquals(2,cluster.numMaxRegionsPerTable[0]);
  assertTrue(cluster.wouldLowerAvailability(hri1,servers[2]));
  clusterState.clear();
  List<HRegionInfo> list3=new ArrayList<HRegionInfo>();
  HRegionInfo hri4=RegionReplicaUtil.getRegionInfoForReplica(hri3,1);
  list3.add(hri4);
  clusterState.put(servers[0],list0);
  clusterState.put(servers[5],list1);
  clusterState.put(servers[6],list2);
  clusterState.put(servers[12],list3);
  cluster=new Cluster(clusterState,null,null,rackManager);
  assertTrue(!cluster.wouldLowerAvailability(hri4,servers[0]));
  cluster.doAction(new MoveRegionAction(2,2,0));
  assertTrue(cluster.wouldLowerAvailability(hri3,servers[0]));
}",0.9848749272833044
61072,"@Override public List<Segment> getSegments(){
  List<Segment> pipelineList=pipeline.getSegments();
  List<Segment> list=new ArrayList<Segment>(pipelineList.size() + 2);
  list.add(this.active);
  list.addAll(pipelineList);
  list.add(this.snapshot);
  return list;
}","@VisibleForTesting @Override protected List<Segment> getSegments(){
  List<Segment> pipelineList=pipeline.getSegments();
  List<Segment> list=new ArrayList<Segment>(pipelineList.size() + 2);
  list.add(this.active);
  list.addAll(pipelineList);
  list.add(this.snapshot);
  return list;
}",0.9458483754512635
61073,"private void pushTailToSnapshot(){
  ImmutableSegment tail=pipeline.pullTail();
  if (!tail.isEmpty()) {
    this.snapshot=tail;
  }
}","private void pushTailToSnapshot(){
  VersionedSegmentsList segments=pipeline.getVersionedTail();
  pushToSnapshot(segments.getStoreSegments());
  pipeline.swap(segments,null,false);
}",0.5236593059936908
61074,"/** 
 * Swaps the versioned list at the tail of the pipeline with the new compacted segment. Swapping only if there were no changes to the suffix of the list while it was compacted.
 * @param versionedList tail of the pipeline that was compacted
 * @param segment new compacted segment
 * @param closeSuffix whether to close the suffix (to release memory), as part of swapping it outDuring index merge op this will be false and for compaction it will be true.
 * @return true iff swapped tail with new compacted segment
 */
public boolean swap(VersionedSegmentsList versionedList,ImmutableSegment segment,boolean closeSuffix){
  if (versionedList.getVersion() != version) {
    return false;
  }
  List<ImmutableSegment> suffix;
synchronized (pipeline) {
    if (versionedList.getVersion() != version) {
      return false;
    }
    suffix=versionedList.getStoreSegments();
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + versionedList.getStoreSegments().size() + ""String_Node_Str""+ segment.getCellsCount());
    }
    swapSuffix(suffix,segment,closeSuffix);
  }
  if (region != null) {
    long suffixDataSize=getSegmentsKeySize(suffix);
    long newDataSize=segment.keySize();
    long dataSizeDelta=suffixDataSize - newDataSize;
    long suffixHeapOverhead=getSegmentsHeapOverhead(suffix);
    long newHeapOverhead=segment.heapOverhead();
    long heapOverheadDelta=suffixHeapOverhead - newHeapOverhead;
    region.addMemstoreSize(new MemstoreSize(-dataSizeDelta,-heapOverheadDelta));
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + suffixDataSize + ""String_Node_Str""+ newDataSize+ ""String_Node_Str""+ suffixHeapOverhead+ ""String_Node_Str""+ newHeapOverhead);
    }
  }
  return true;
}","/** 
 * Swaps the versioned list at the tail of the pipeline with a new segment. Swapping only if there were no changes to the suffix of the list since the version list was created.
 * @param versionedList suffix of the pipeline to be replaced can be tail or all the pipeline
 * @param segment new segment to replace the suffix. Can be null if the suffix just needs to beremoved.
 * @param closeSuffix whether to close the suffix (to release memory), as part of swapping it outDuring index merge op this will be false and for compaction it will be true.
 * @return true iff swapped tail with new segment
 */
public boolean swap(VersionedSegmentsList versionedList,ImmutableSegment segment,boolean closeSuffix){
  if (versionedList.getVersion() != version) {
    return false;
  }
  List<ImmutableSegment> suffix;
synchronized (pipeline) {
    if (versionedList.getVersion() != version) {
      return false;
    }
    suffix=versionedList.getStoreSegments();
    if (LOG.isDebugEnabled()) {
      int count=0;
      if (segment != null) {
        count=segment.getCellsCount();
      }
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + versionedList.getStoreSegments().size() + ""String_Node_Str""+ count);
    }
    swapSuffix(suffix,segment,closeSuffix);
  }
  if (closeSuffix && region != null) {
    long suffixDataSize=getSegmentsKeySize(suffix);
    long newDataSize=0;
    if (segment != null)     newDataSize=segment.keySize();
    long dataSizeDelta=suffixDataSize - newDataSize;
    long suffixHeapOverhead=getSegmentsHeapOverhead(suffix);
    long newHeapOverhead=0;
    if (segment != null)     newHeapOverhead=segment.heapOverhead();
    long heapOverheadDelta=suffixHeapOverhead - newHeapOverhead;
    region.addMemstoreSize(new MemstoreSize(-dataSizeDelta,-heapOverheadDelta));
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + suffixDataSize + ""String_Node_Str""+ newDataSize+ ""String_Node_Str""+ suffixHeapOverhead+ ""String_Node_Str""+ newHeapOverhead);
    }
  }
  return true;
}",0.6875664187035069
61075,"public VersionedSegmentsList getVersionedList(){
synchronized (pipeline) {
    LinkedList<ImmutableSegment> segmentList=new LinkedList<ImmutableSegment>(pipeline);
    VersionedSegmentsList res=new VersionedSegmentsList(segmentList,version);
    return res;
  }
}","public VersionedSegmentsList getVersionedList(){
synchronized (pipeline) {
    List<ImmutableSegment> segmentList=new ArrayList<>(pipeline);
    return new VersionedSegmentsList(segmentList,version);
  }
}",0.7564102564102564
61076,"private void swapSuffix(List<ImmutableSegment> suffix,ImmutableSegment segment,boolean closeSegmentsInSuffix){
  version++;
  if (closeSegmentsInSuffix) {
    for (    Segment itemInSuffix : suffix) {
      itemInSuffix.close();
    }
  }
  pipeline.removeAll(suffix);
  pipeline.addLast(segment);
}","private void swapSuffix(List<ImmutableSegment> suffix,ImmutableSegment segment,boolean closeSegmentsInSuffix){
  version++;
  if (closeSegmentsInSuffix) {
    for (    Segment itemInSuffix : suffix) {
      itemInSuffix.close();
    }
  }
  pipeline.removeAll(suffix);
  if (segment != null)   pipeline.addLast(segment);
}",0.9629629629629628
61077,"public CompactionPipeline(RegionServicesForStores region){
  this.region=region;
  this.pipeline=new LinkedList<ImmutableSegment>();
  this.version=0;
}","public CompactionPipeline(RegionServicesForStores region){
  this.region=region;
  this.pipeline=new LinkedList<>();
  this.version=0;
}",0.9444444444444444
61078,"public List<Segment> getSegments(){
synchronized (pipeline) {
    List<Segment> res=new LinkedList<Segment>(pipeline);
    return res;
  }
}","public List<Segment> getSegments(){
synchronized (pipeline) {
    return new LinkedList<>(pipeline);
  }
}",0.8211382113821138
61079,"public VersionedSegmentsList(LinkedList<ImmutableSegment> storeSegments,long version){
  this.storeSegments=storeSegments;
  this.version=version;
}","public VersionedSegmentsList(List<ImmutableSegment> storeSegments,long version){
  this.storeSegments=storeSegments;
  this.version=version;
}",0.9793103448275862
61080,"@BeforeClass public static void setUp() throws Exception {
  TEST_UTIL.getConfiguration().set(TABLES_ON_MASTER,""String_Node_Str"");
  TEST_UTIL.getConfiguration().setLong(HBASE_CLIENT_META_OPERATION_TIMEOUT,60000L);
  TEST_UTIL.getConfiguration().setLong(HBASE_RPC_READ_TIMEOUT_KEY,1000L);
  TEST_UTIL.getConfiguration().setInt(HBASE_CLIENT_RETRIES_NUMBER,1000);
  TEST_UTIL.getConfiguration().setInt(ByteBufferPool.MAX_POOL_SIZE_KEY,100);
  TEST_UTIL.startMiniCluster(5);
  SPLIT_KEYS=new byte[8][];
  for (int i=111; i < 999; i+=111) {
    SPLIT_KEYS[i / 111 - 1]=Bytes.toBytes(String.format(""String_Node_Str"",i));
  }
  TEST_UTIL.createTable(TABLE_NAME,FAMILY);
  TEST_UTIL.waitTableAvailable(TABLE_NAME);
  CONN=ConnectionFactory.createAsyncConnection(TEST_UTIL.getConfiguration());
  CONN.getRawTable(TABLE_NAME).putAll(IntStream.range(0,COUNT).mapToObj(i -> new Put(Bytes.toBytes(String.format(""String_Node_Str"",i))).addColumn(FAMILY,QUALIFIER,Bytes.toBytes(i))).collect(Collectors.toList())).get();
}","protected static void setUp(HColumnDescriptor.MemoryCompaction memoryCompaction) throws Exception {
  TEST_UTIL.getConfiguration().set(TABLES_ON_MASTER,""String_Node_Str"");
  TEST_UTIL.getConfiguration().setLong(HBASE_CLIENT_META_OPERATION_TIMEOUT,60000L);
  TEST_UTIL.getConfiguration().setLong(HBASE_RPC_READ_TIMEOUT_KEY,1000L);
  TEST_UTIL.getConfiguration().setInt(HBASE_CLIENT_RETRIES_NUMBER,1000);
  TEST_UTIL.getConfiguration().setInt(ByteBufferPool.MAX_POOL_SIZE_KEY,100);
  TEST_UTIL.getConfiguration().set(CompactingMemStore.COMPACTING_MEMSTORE_TYPE_KEY,String.valueOf(memoryCompaction));
  TEST_UTIL.startMiniCluster(5);
  SPLIT_KEYS=new byte[8][];
  for (int i=111; i < 999; i+=111) {
    SPLIT_KEYS[i / 111 - 1]=Bytes.toBytes(String.format(""String_Node_Str"",i));
  }
  TEST_UTIL.createTable(TABLE_NAME,FAMILY);
  TEST_UTIL.waitTableAvailable(TABLE_NAME);
  CONN=ConnectionFactory.createAsyncConnection(TEST_UTIL.getConfiguration());
  CONN.getRawTable(TABLE_NAME).putAll(IntStream.range(0,COUNT).mapToObj(i -> new Put(Bytes.toBytes(String.format(""String_Node_Str"",i))).addColumn(FAMILY,QUALIFIER,Bytes.toBytes(i))).collect(Collectors.toList())).get();
}",0.9101796407185628
61081,"private void run(AtomicBoolean stop) throws InterruptedException, ExecutionException {
  while (!stop.get()) {
    int i=ThreadLocalRandom.current().nextInt(COUNT);
    assertEquals(i,Bytes.toInt(CONN.getRawTable(TABLE_NAME).get(new Get(Bytes.toBytes(String.format(""String_Node_Str"",i)))).get().getValue(FAMILY,QUALIFIER)));
  }
}","private void run(AtomicBoolean stop) throws InterruptedException, ExecutionException {
  while (!stop.get()) {
    for (int i=0; i < COUNT; i++) {
      assertEquals(i,Bytes.toInt(CONN.getRawTable(TABLE_NAME).get(new Get(Bytes.toBytes(String.format(""String_Node_Str"",i)))).get().getValue(FAMILY,QUALIFIER)));
    }
  }
}",0.8984615384615384
61082,"/** 
 * Maps the data.
 * @param row     The current table row key.
 * @param values  The columns.
 * @param context The current context.
 * @throws IOException When something is broken with the data.
 * @see org.apache.hadoop.mapreduce.Mapper#map(KEYIN,VALUEIN,org.apache.hadoop.mapreduce.Mapper.Context)
 */
@Override public void map(ImmutableBytesWritable row,Result values,Context context) throws IOException {
  Preconditions.checkState(values != null,""String_Node_Str"");
  try {
    byte[] currentRow=values.getRow();
    if (lastRow == null || !Bytes.equals(lastRow,currentRow)) {
      lastRow=currentRow;
      currentRowKey=Bytes.toStringBinary(currentRow);
      currentFamily=null;
      currentQualifier=null;
      context.getCounter(Counters.ROWS).increment(1);
      context.write(new Text(""String_Node_Str""),new IntWritable(1));
    }
    if (!values.isEmpty()) {
      int cellCount=0;
      for (      Cell value : values.listCells()) {
        cellCount++;
        if (currentFamily == null || !CellUtil.matchingFamily(value,currentFamily)) {
          currentFamily=CellUtil.cloneFamily(value);
          currentFamilyName=Bytes.toStringBinary(currentFamily);
          currentQualifier=null;
          context.getCounter(""String_Node_Str"",currentFamilyName).increment(1);
          if (1 == context.getCounter(""String_Node_Str"",currentFamilyName).getValue()) {
            context.write(new Text(""String_Node_Str""),new IntWritable(1));
            context.write(new Text(currentFamily),new IntWritable(1));
          }
        }
        if (currentQualifier == null || !CellUtil.matchingQualifier(value,currentQualifier)) {
          currentQualifier=CellUtil.cloneQualifier(value);
          currentQualifierName=currentFamilyName + separator + Bytes.toStringBinary(currentQualifier);
          currentRowQualifierName=currentRowKey + separator + currentQualifierName;
          context.write(new Text(""String_Node_Str""),new IntWritable(1));
          context.write(new Text(currentQualifierName),new IntWritable(1));
        }
        context.write(new Text(currentRowQualifierName + ""String_Node_Str""),new IntWritable(1));
      }
      context.getCounter(Counters.CELLS).increment(cellCount);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","/** 
 * Maps the data.
 * @param row     The current table row key.
 * @param values  The columns.
 * @param context The current context.
 * @throws IOException When something is broken with the data.
 * @see org.apache.hadoop.mapreduce.Mapper#map(KEYIN,VALUEIN,org.apache.hadoop.mapreduce.Mapper.Context)
 */
@Override @edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public void map(ImmutableBytesWritable row,Result values,Context context) throws IOException {
  Preconditions.checkState(values != null,""String_Node_Str"");
  try {
    byte[] currentRow=values.getRow();
    if (lastRow == null || !Bytes.equals(lastRow,currentRow)) {
      lastRow=currentRow;
      currentRowKey=Bytes.toStringBinary(currentRow);
      currentFamily=null;
      currentQualifier=null;
      context.getCounter(Counters.ROWS).increment(1);
      context.write(new Text(""String_Node_Str""),new IntWritable(1));
    }
    if (!values.isEmpty()) {
      int cellCount=0;
      for (      Cell value : values.listCells()) {
        cellCount++;
        if (currentFamily == null || !CellUtil.matchingFamily(value,currentFamily)) {
          currentFamily=CellUtil.cloneFamily(value);
          currentFamilyName=Bytes.toStringBinary(currentFamily);
          currentQualifier=null;
          context.getCounter(""String_Node_Str"",currentFamilyName).increment(1);
          if (1 == context.getCounter(""String_Node_Str"",currentFamilyName).getValue()) {
            context.write(new Text(""String_Node_Str""),new IntWritable(1));
            context.write(new Text(currentFamily),new IntWritable(1));
          }
        }
        if (currentQualifier == null || !CellUtil.matchingQualifier(value,currentQualifier)) {
          currentQualifier=CellUtil.cloneQualifier(value);
          currentQualifierName=currentFamilyName + separator + Bytes.toStringBinary(currentQualifier);
          currentRowQualifierName=currentRowKey + separator + currentQualifierName;
          context.write(new Text(""String_Node_Str""),new IntWritable(1));
          context.write(new Text(currentQualifierName),new IntWritable(1));
        }
        context.write(new Text(currentRowQualifierName + ""String_Node_Str""),new IntWritable(1));
      }
      context.getCounter(Counters.CELLS).increment(cellCount);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9772195018096658
61083,"public BufferedMutatorParams clone(){
  BufferedMutatorParams clone=new BufferedMutatorParams(this.tableName);
  clone.writeBufferSize=this.writeBufferSize;
  clone.maxKeyValueSize=maxKeyValueSize;
  clone.pool=this.pool;
  clone.listener=this.listener;
  clone.implementationClassName=this.implementationClassName;
  return clone;
}","@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public BufferedMutatorParams clone(){
  BufferedMutatorParams clone=new BufferedMutatorParams(this.tableName);
  clone.writeBufferSize=this.writeBufferSize;
  clone.maxKeyValueSize=maxKeyValueSize;
  clone.pool=this.pool;
  clone.listener=this.listener;
  clone.implementationClassName=this.implementationClassName;
  return clone;
}",0.8615782664941786
61084,"/** 
 * Called to do a piece of the batch that came in to   {@link #batchMutate(Mutation[],long,long)}In here we also handle replay of edits on region recover.
 * @return Change in size brought about by applying <code>batchOp</code>
 */
@SuppressWarnings(""String_Node_Str"") private long doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {
  boolean replay=batchOp.isInReplay();
  boolean putsCfSetConsistent=true;
  boolean deletesCfSetConsistent=true;
  Set<byte[]> putsCfSet=null;
  Set<byte[]> deletesCfSet=null;
  long currentNonceGroup=HConstants.NO_NONCE;
  long currentNonce=HConstants.NO_NONCE;
  WALEdit walEdit=null;
  boolean locked=false;
  Map<byte[],List<Cell>>[] familyMaps=new Map[batchOp.operations.length];
  int firstIndex=batchOp.nextIndexToProcess;
  int lastIndexExclusive=firstIndex;
  boolean success=false;
  int noOfPuts=0;
  int noOfDeletes=0;
  WriteEntry writeEntry=null;
  int cellCount=0;
  List<RowLock> acquiredRowLocks=Lists.newArrayListWithCapacity(batchOp.operations.length);
  long addedSize=0;
  try {
    int numReadyToWrite=0;
    long now=EnvironmentEdgeManager.currentTime();
    while (lastIndexExclusive < batchOp.operations.length) {
      if (checkBatchOp(batchOp,lastIndexExclusive,familyMaps,now)) {
        lastIndexExclusive++;
        continue;
      }
      Mutation mutation=batchOp.getMutation(lastIndexExclusive);
      RowLock rowLock=null;
      try {
        rowLock=getRowLockInternal(mutation.getRow(),true);
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"" + Bytes.toStringBinary(mutation.getRow()),ioe);
      }
      if (rowLock == null) {
        break;
      }
 else {
        acquiredRowLocks.add(rowLock);
      }
      lastIndexExclusive++;
      numReadyToWrite++;
      if (replay) {
        for (        List<Cell> cells : mutation.getFamilyCellMap().values()) {
          cellCount+=cells.size();
        }
      }
      if (mutation instanceof Put) {
        if (putsCfSet == null) {
          putsCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          putsCfSetConsistent=putsCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(putsCfSet);
        }
      }
 else {
        if (deletesCfSet == null) {
          deletesCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          deletesCfSetConsistent=deletesCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(deletesCfSet);
        }
      }
    }
    now=EnvironmentEdgeManager.currentTime();
    byte[] byteNow=Bytes.toBytes(now);
    if (numReadyToWrite <= 0) {
      return 0L;
    }
    for (int i=firstIndex; !replay && i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      Mutation mutation=batchOp.getMutation(i);
      if (mutation instanceof Put) {
        updateCellTimestamps(familyMaps[i].values(),byteNow);
        noOfPuts++;
      }
 else {
        prepareDeleteTimestamps(mutation,familyMaps[i],byteNow);
        noOfDeletes++;
      }
      rewriteCellTags(familyMaps[i],mutation);
      WALEdit fromCP=batchOp.walEditsFromCoprocessors[i];
      if (fromCP != null) {
        cellCount+=fromCP.size();
      }
      for (      List<Cell> cells : familyMaps[i].values()) {
        cellCount+=cells.size();
      }
    }
    walEdit=new WALEdit(cellCount,replay);
    lock(this.updatesLock.readLock(),numReadyToWrite);
    locked=true;
    if (!replay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      if (coprocessorHost.preBatchMutate(miniBatchOp)) {
        return 0L;
      }
 else {
        for (int i=firstIndex; i < lastIndexExclusive; i++) {
          if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
            continue;
          }
          Mutation[] cpMutations=miniBatchOp.getOperationsFromCoprocessors(i - firstIndex);
          if (cpMutations == null) {
            continue;
          }
          for (int j=0; j < cpMutations.length; j++) {
            Mutation cpMutation=cpMutations[j];
            Map<byte[],List<Cell>> cpFamilyMap=cpMutation.getFamilyCellMap();
            checkAndPrepareMutation(cpMutation,replay,cpFamilyMap,now);
            acquiredRowLocks.add(getRowLockInternal(cpMutation.getRow(),true));
            if (cpMutation.getDurability() == Durability.SKIP_WAL) {
              recordMutationWithoutWal(cpFamilyMap);
            }
            mergeFamilyMaps(familyMaps[i],cpFamilyMap);
          }
        }
      }
    }
    Durability durability=Durability.USE_DEFAULT;
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      Mutation m=batchOp.getMutation(i);
      Durability tmpDur=getEffectiveDurability(m.getDurability());
      if (tmpDur.ordinal() > durability.ordinal()) {
        durability=tmpDur;
      }
      if (tmpDur == Durability.SKIP_WAL) {
        recordMutationWithoutWal(m.getFamilyCellMap());
        continue;
      }
      long nonceGroup=batchOp.getNonceGroup(i);
      long nonce=batchOp.getNonce(i);
      if (nonceGroup != currentNonceGroup || nonce != currentNonce) {
        appendCurrentNonces(m,replay,walEdit,now,currentNonceGroup,currentNonce);
        walEdit=new WALEdit(cellCount,replay);
        currentNonceGroup=nonceGroup;
        currentNonce=nonce;
      }
      WALEdit fromCP=batchOp.walEditsFromCoprocessors[i];
      if (fromCP != null) {
        for (        Cell cell : fromCP.getCells()) {
          walEdit.add(cell);
        }
      }
      addFamilyMapToWALEdit(familyMaps[i],walEdit);
    }
    Mutation mutation=batchOp.getMutation(firstIndex);
    WALKey walKey=null;
    long txid;
    if (replay) {
      walKey=new ReplayHLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc);
      walKey.setOrigLogSeqNum(batchOp.getReplaySequenceId());
      if (!walEdit.isEmpty()) {
        txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);
        if (txid != 0) {
          sync(txid,durability);
        }
      }
    }
 else {
      try {
        if (!walEdit.isEmpty()) {
          try {
            if (this.mvccPreAssign) {
              preAssignMvccLock.lock();
              writeEntry=mvcc.begin();
            }
            walKey=new HLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc,this.getReplicationScope());
            if (this.mvccPreAssign) {
              walKey.setPreAssignedWriteEntry(writeEntry);
            }
            txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);
          }
  finally {
            if (mvccPreAssign) {
              preAssignMvccLock.unlock();
            }
          }
          if (txid != 0) {
            sync(txid,durability);
          }
          if (writeEntry == null) {
            writeEntry=walKey.getWriteEntry();
          }
        }
      }
 catch (      IOException ioe) {
        if (walKey != null && writeEntry == null) {
          mvcc.complete(walKey.getWriteEntry());
        }
        throw ioe;
      }
    }
    if (walKey == null) {
      writeEntry=mvcc.begin();
    }
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      boolean updateSeqId=replay || batchOp.getMutation(i).getDurability() == Durability.SKIP_WAL;
      if (updateSeqId) {
        this.updateSequenceId(familyMaps[i].values(),replay ? batchOp.getReplaySequenceId() : writeEntry.getWriteNumber());
      }
      addedSize+=applyFamilyMapToMemstore(familyMaps[i]);
    }
    if (replay) {
      this.mvcc.advanceTo(batchOp.getReplaySequenceId());
    }
 else {
      mvcc.completeAndWait(writeEntry);
      writeEntry=null;
    }
    if (locked) {
      this.updatesLock.readLock().unlock();
      locked=false;
    }
    releaseRowLocks(acquiredRowLocks);
    if (!replay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutate(miniBatchOp);
    }
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i] == OperationStatus.NOT_RUN) {
        batchOp.retCodeDetails[i]=OperationStatus.SUCCESS;
      }
    }
    if (!replay && coprocessorHost != null) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.SUCCESS) {
          continue;
        }
        Mutation m=batchOp.getMutation(i);
        if (m instanceof Put) {
          coprocessorHost.postPut((Put)m,walEdit,m.getDurability());
        }
 else {
          coprocessorHost.postDelete((Delete)m,walEdit,m.getDurability());
        }
      }
    }
    success=true;
    return addedSize;
  }
  finally {
    if (writeEntry != null)     mvcc.complete(writeEntry);
    this.addAndGetGlobalMemstoreSize(addedSize);
    if (locked) {
      this.updatesLock.readLock().unlock();
    }
    releaseRowLocks(acquiredRowLocks);
    if (noOfPuts > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updatePut();
      }
    }
    if (noOfDeletes > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updateDelete();
      }
    }
    if (!success) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() == OperationStatusCode.NOT_RUN) {
          batchOp.retCodeDetails[i]=OperationStatus.FAILURE;
        }
      }
    }
    if (coprocessorHost != null && !batchOp.isInReplay()) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutateIndispensably(miniBatchOp,success);
    }
    batchOp.nextIndexToProcess=lastIndexExclusive;
  }
}","/** 
 * Called to do a piece of the batch that came in to   {@link #batchMutate(Mutation[],long,long)}In here we also handle replay of edits on region recover.
 * @return Change in size brought about by applying <code>batchOp</code>
 */
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @SuppressWarnings(""String_Node_Str"") private long doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {
  boolean replay=batchOp.isInReplay();
  boolean putsCfSetConsistent=true;
  boolean deletesCfSetConsistent=true;
  Set<byte[]> putsCfSet=null;
  Set<byte[]> deletesCfSet=null;
  long currentNonceGroup=HConstants.NO_NONCE;
  long currentNonce=HConstants.NO_NONCE;
  WALEdit walEdit=null;
  boolean locked=false;
  Map<byte[],List<Cell>>[] familyMaps=new Map[batchOp.operations.length];
  int firstIndex=batchOp.nextIndexToProcess;
  int lastIndexExclusive=firstIndex;
  boolean success=false;
  int noOfPuts=0;
  int noOfDeletes=0;
  WriteEntry writeEntry=null;
  int cellCount=0;
  List<RowLock> acquiredRowLocks=Lists.newArrayListWithCapacity(batchOp.operations.length);
  long addedSize=0;
  try {
    int numReadyToWrite=0;
    long now=EnvironmentEdgeManager.currentTime();
    while (lastIndexExclusive < batchOp.operations.length) {
      if (checkBatchOp(batchOp,lastIndexExclusive,familyMaps,now)) {
        lastIndexExclusive++;
        continue;
      }
      Mutation mutation=batchOp.getMutation(lastIndexExclusive);
      RowLock rowLock=null;
      try {
        rowLock=getRowLockInternal(mutation.getRow(),true);
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"" + Bytes.toStringBinary(mutation.getRow()),ioe);
      }
      if (rowLock == null) {
        break;
      }
 else {
        acquiredRowLocks.add(rowLock);
      }
      lastIndexExclusive++;
      numReadyToWrite++;
      if (replay) {
        for (        List<Cell> cells : mutation.getFamilyCellMap().values()) {
          cellCount+=cells.size();
        }
      }
      if (mutation instanceof Put) {
        if (putsCfSet == null) {
          putsCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          putsCfSetConsistent=putsCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(putsCfSet);
        }
      }
 else {
        if (deletesCfSet == null) {
          deletesCfSet=mutation.getFamilyCellMap().keySet();
        }
 else {
          deletesCfSetConsistent=deletesCfSetConsistent && mutation.getFamilyCellMap().keySet().equals(deletesCfSet);
        }
      }
    }
    now=EnvironmentEdgeManager.currentTime();
    byte[] byteNow=Bytes.toBytes(now);
    if (numReadyToWrite <= 0) {
      return 0L;
    }
    for (int i=firstIndex; !replay && i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      Mutation mutation=batchOp.getMutation(i);
      if (mutation instanceof Put) {
        updateCellTimestamps(familyMaps[i].values(),byteNow);
        noOfPuts++;
      }
 else {
        prepareDeleteTimestamps(mutation,familyMaps[i],byteNow);
        noOfDeletes++;
      }
      rewriteCellTags(familyMaps[i],mutation);
      WALEdit fromCP=batchOp.walEditsFromCoprocessors[i];
      if (fromCP != null) {
        cellCount+=fromCP.size();
      }
      for (      List<Cell> cells : familyMaps[i].values()) {
        cellCount+=cells.size();
      }
    }
    walEdit=new WALEdit(cellCount,replay);
    lock(this.updatesLock.readLock(),numReadyToWrite);
    locked=true;
    if (!replay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      if (coprocessorHost.preBatchMutate(miniBatchOp)) {
        return 0L;
      }
 else {
        for (int i=firstIndex; i < lastIndexExclusive; i++) {
          if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
            continue;
          }
          Mutation[] cpMutations=miniBatchOp.getOperationsFromCoprocessors(i - firstIndex);
          if (cpMutations == null) {
            continue;
          }
          for (int j=0; j < cpMutations.length; j++) {
            Mutation cpMutation=cpMutations[j];
            Map<byte[],List<Cell>> cpFamilyMap=cpMutation.getFamilyCellMap();
            checkAndPrepareMutation(cpMutation,replay,cpFamilyMap,now);
            acquiredRowLocks.add(getRowLockInternal(cpMutation.getRow(),true));
            if (cpMutation.getDurability() == Durability.SKIP_WAL) {
              recordMutationWithoutWal(cpFamilyMap);
            }
            mergeFamilyMaps(familyMaps[i],cpFamilyMap);
          }
        }
      }
    }
    Durability durability=Durability.USE_DEFAULT;
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      Mutation m=batchOp.getMutation(i);
      Durability tmpDur=getEffectiveDurability(m.getDurability());
      if (tmpDur.ordinal() > durability.ordinal()) {
        durability=tmpDur;
      }
      if (tmpDur == Durability.SKIP_WAL) {
        recordMutationWithoutWal(m.getFamilyCellMap());
        continue;
      }
      long nonceGroup=batchOp.getNonceGroup(i);
      long nonce=batchOp.getNonce(i);
      if (nonceGroup != currentNonceGroup || nonce != currentNonce) {
        appendCurrentNonces(m,replay,walEdit,now,currentNonceGroup,currentNonce);
        walEdit=new WALEdit(cellCount,replay);
        currentNonceGroup=nonceGroup;
        currentNonce=nonce;
      }
      WALEdit fromCP=batchOp.walEditsFromCoprocessors[i];
      if (fromCP != null) {
        for (        Cell cell : fromCP.getCells()) {
          walEdit.add(cell);
        }
      }
      addFamilyMapToWALEdit(familyMaps[i],walEdit);
    }
    Mutation mutation=batchOp.getMutation(firstIndex);
    WALKey walKey=null;
    long txid;
    if (replay) {
      walKey=new ReplayHLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc);
      walKey.setOrigLogSeqNum(batchOp.getReplaySequenceId());
      if (!walEdit.isEmpty()) {
        txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);
        if (txid != 0) {
          sync(txid,durability);
        }
      }
    }
 else {
      try {
        if (!walEdit.isEmpty()) {
          try {
            if (this.mvccPreAssign) {
              preAssignMvccLock.lock();
              writeEntry=mvcc.begin();
            }
            walKey=new HLogKey(this.getRegionInfo().getEncodedNameAsBytes(),this.htableDescriptor.getTableName(),WALKey.NO_SEQUENCE_ID,now,mutation.getClusterIds(),currentNonceGroup,currentNonce,mvcc,this.getReplicationScope());
            if (this.mvccPreAssign) {
              walKey.setPreAssignedWriteEntry(writeEntry);
            }
            txid=this.wal.append(this.getRegionInfo(),walKey,walEdit,true);
          }
  finally {
            if (mvccPreAssign) {
              preAssignMvccLock.unlock();
            }
          }
          if (txid != 0) {
            sync(txid,durability);
          }
          if (writeEntry == null) {
            writeEntry=walKey.getWriteEntry();
          }
        }
      }
 catch (      IOException ioe) {
        if (walKey != null && writeEntry == null) {
          mvcc.complete(walKey.getWriteEntry());
        }
        throw ioe;
      }
    }
    if (walKey == null) {
      writeEntry=mvcc.begin();
    }
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.NOT_RUN) {
        continue;
      }
      boolean updateSeqId=replay || batchOp.getMutation(i).getDurability() == Durability.SKIP_WAL;
      if (updateSeqId) {
        this.updateSequenceId(familyMaps[i].values(),replay ? batchOp.getReplaySequenceId() : writeEntry.getWriteNumber());
      }
      addedSize+=applyFamilyMapToMemstore(familyMaps[i]);
    }
    if (replay) {
      this.mvcc.advanceTo(batchOp.getReplaySequenceId());
    }
 else {
      mvcc.completeAndWait(writeEntry);
      writeEntry=null;
    }
    if (locked) {
      this.updatesLock.readLock().unlock();
      locked=false;
    }
    releaseRowLocks(acquiredRowLocks);
    if (!replay && coprocessorHost != null) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutate(miniBatchOp);
    }
    for (int i=firstIndex; i < lastIndexExclusive; i++) {
      if (batchOp.retCodeDetails[i] == OperationStatus.NOT_RUN) {
        batchOp.retCodeDetails[i]=OperationStatus.SUCCESS;
      }
    }
    if (!replay && coprocessorHost != null) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() != OperationStatusCode.SUCCESS) {
          continue;
        }
        Mutation m=batchOp.getMutation(i);
        if (m instanceof Put) {
          coprocessorHost.postPut((Put)m,walEdit,m.getDurability());
        }
 else {
          coprocessorHost.postDelete((Delete)m,walEdit,m.getDurability());
        }
      }
    }
    success=true;
    return addedSize;
  }
  finally {
    if (writeEntry != null)     mvcc.complete(writeEntry);
    this.addAndGetGlobalMemstoreSize(addedSize);
    if (locked) {
      this.updatesLock.readLock().unlock();
    }
    releaseRowLocks(acquiredRowLocks);
    if (noOfPuts > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updatePut();
      }
    }
    if (noOfDeletes > 0) {
      if (this.metricsRegion != null) {
        this.metricsRegion.updateDelete();
      }
    }
    if (!success) {
      for (int i=firstIndex; i < lastIndexExclusive; i++) {
        if (batchOp.retCodeDetails[i].getOperationStatusCode() == OperationStatusCode.NOT_RUN) {
          batchOp.retCodeDetails[i]=OperationStatus.FAILURE;
        }
      }
    }
    if (coprocessorHost != null && !batchOp.isInReplay()) {
      MiniBatchOperationInProgress<Mutation> miniBatchOp=new MiniBatchOperationInProgress<Mutation>(batchOp.getMutationsForCoprocs(),batchOp.retCodeDetails,batchOp.walEditsFromCoprocessors,firstIndex,lastIndexExclusive);
      coprocessorHost.postBatchMutateIndispensably(miniBatchOp,success);
    }
    batchOp.nextIndexToProcess=lastIndexExclusive;
  }
}",0.994991809033466
61085,"/** 
 * Bulkloads the current file.
 * @param connection to use to get admin/RegionLocator
 * @param table The current table.
 * @param bulkloadDirectory The path of bulkload directory.
 * @param fileName The current file name.
 * @throws IOException if IO failure is encountered
 */
private void bulkloadRefFile(Connection connection,Table table,Path bulkloadDirectory,String fileName) throws IOException {
  try {
    LoadIncrementalHFiles bulkload=new LoadIncrementalHFiles(conf);
    bulkload.doBulkLoad(bulkloadDirectory,connection.getAdmin(),table,connection.getRegionLocator(table.getName()));
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}","/** 
 * Bulkloads the current file.
 * @param connection to use to get admin/RegionLocator
 * @param table The current table.
 * @param bulkloadDirectory The path of bulkload directory.
 * @param fileName The current file name.
 * @throws IOException if IO failure is encountered
 */
private void bulkloadRefFile(Connection connection,Table table,Path bulkloadDirectory,String fileName) throws IOException {
  try {
    LoadIncrementalHFiles bulkload=new LoadIncrementalHFiles(conf);
    bulkload.doBulkLoad(bulkloadDirectory,connection.getAdmin(),table,connection.getRegionLocator(table.getName()));
  }
 catch (  Exception e) {
    deletePath(new Path(mobFamilyDir,fileName));
    throw new IOException(e);
  }
 finally {
    deletePath(bulkloadDirectory);
  }
}",0.9307207837648706
61086,"/** 
 * Compacts a partition of selected small mob files and all the del files in a batch.
 * @param request The compaction request.
 * @param partition A compaction partition.
 * @param connection To use for transport
 * @param table The current table.
 * @param filesToCompact The files to be compacted.
 * @param batch The number of mob files to be compacted in a batch.
 * @param bulkloadPathOfPartition The directory where the bulkload column of the currentpartition is saved.
 * @param bulkloadColumnPath The directory where the bulkload files of current partitionare saved.
 * @param newFiles The paths of new mob files after compactions.
 * @throws IOException if IO failure is encountered
 */
private void compactMobFilesInBatch(PartitionedMobCompactionRequest request,CompactionPartition partition,Connection connection,Table table,List<StoreFile> filesToCompact,int batch,Path bulkloadPathOfPartition,Path bulkloadColumnPath,List<Path> newFiles) throws IOException {
  StoreScanner scanner=createScanner(filesToCompact,ScanType.COMPACT_DROP_DELETES);
  List<StoreFile> mobFilesToCompact=filesToCompact.subList(0,batch);
  Pair<Long,Long> fileInfo=getFileInfo(mobFilesToCompact);
  StoreFileWriter writer=null;
  StoreFileWriter refFileWriter=null;
  Path filePath=null;
  long mobCells=0;
  boolean cleanupTmpMobFile=false;
  boolean cleanupBulkloadDirOfPartition=false;
  boolean cleanupCommittedMobFile=false;
  boolean closeReaders=true;
  try {
    try {
      writer=MobUtils.createWriter(conf,fs,column,partition.getPartitionId().getDate(),tempPath,Long.MAX_VALUE,column.getCompactionCompressionType(),partition.getPartitionId().getStartKey(),compactionCacheConfig,cryptoContext);
      cleanupTmpMobFile=true;
      filePath=writer.getPath();
      byte[] fileName=Bytes.toBytes(filePath.getName());
      refFileWriter=MobUtils.createRefFileWriter(conf,fs,column,bulkloadColumnPath,fileInfo.getSecond().longValue(),compactionCacheConfig,cryptoContext);
      cleanupBulkloadDirOfPartition=true;
      List<Cell> cells=new ArrayList<>();
      boolean hasMore;
      ScannerContext scannerContext=ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();
      do {
        hasMore=scanner.next(cells,scannerContext);
        for (        Cell cell : cells) {
          writer.append(cell);
          KeyValue reference=MobUtils.createMobRefKeyValue(cell,fileName,tableNameTag);
          refFileWriter.append(reference);
          mobCells++;
        }
        cells.clear();
      }
 while (hasMore);
    }
  finally {
      scanner.close();
      if (cleanupTmpMobFile) {
        closeMobFileWriter(writer,fileInfo.getFirst(),mobCells);
      }
      if (cleanupBulkloadDirOfPartition) {
        closeRefFileWriter(refFileWriter,fileInfo.getFirst(),request.selectionTime);
      }
    }
    if (mobCells > 0) {
      MobUtils.commitFile(conf,fs,filePath,mobFamilyDir,compactionCacheConfig);
      cleanupTmpMobFile=false;
      cleanupCommittedMobFile=true;
      bulkloadRefFile(connection,table,bulkloadPathOfPartition,filePath.getName());
      cleanupCommittedMobFile=false;
      newFiles.add(new Path(mobFamilyDir,filePath.getName()));
    }
    try {
      closeStoreFileReaders(mobFilesToCompact);
      closeReaders=false;
      MobUtils.removeMobFiles(conf,fs,tableName,mobTableDir,column.getName(),mobFilesToCompact);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"" + mobFilesToCompact,e);
    }
  }
  finally {
    if (closeReaders) {
      closeStoreFileReaders(mobFilesToCompact);
    }
    if (cleanupTmpMobFile) {
      deletePath(filePath);
    }
    if (cleanupBulkloadDirOfPartition) {
      deletePath(bulkloadPathOfPartition);
    }
    if (cleanupCommittedMobFile) {
      deletePath(new Path(mobFamilyDir,filePath.getName()));
    }
  }
}","/** 
 * Compacts a partition of selected small mob files and all the del files in a batch.
 * @param request The compaction request.
 * @param partition A compaction partition.
 * @param connection To use for transport
 * @param table The current table.
 * @param filesToCompact The files to be compacted.
 * @param batch The number of mob files to be compacted in a batch.
 * @param bulkloadPathOfPartition The directory where the bulkload column of the currentpartition is saved.
 * @param bulkloadColumnPath The directory where the bulkload files of current partitionare saved.
 * @param newFiles The paths of new mob files after compactions.
 * @throws IOException if IO failure is encountered
 */
private void compactMobFilesInBatch(PartitionedMobCompactionRequest request,CompactionPartition partition,Connection connection,Table table,List<StoreFile> filesToCompact,int batch,Path bulkloadPathOfPartition,Path bulkloadColumnPath,List<Path> newFiles) throws IOException {
  StoreScanner scanner=createScanner(filesToCompact,ScanType.COMPACT_DROP_DELETES);
  List<StoreFile> mobFilesToCompact=filesToCompact.subList(0,batch);
  Pair<Long,Long> fileInfo=getFileInfo(mobFilesToCompact);
  StoreFileWriter writer=null;
  StoreFileWriter refFileWriter=null;
  Path filePath=null;
  Path refFilePath=null;
  long mobCells=0;
  try {
    writer=MobUtils.createWriter(conf,fs,column,partition.getPartitionId().getDate(),tempPath,Long.MAX_VALUE,column.getCompactionCompressionType(),partition.getPartitionId().getStartKey(),compactionCacheConfig,cryptoContext);
    filePath=writer.getPath();
    byte[] fileName=Bytes.toBytes(filePath.getName());
    refFileWriter=MobUtils.createRefFileWriter(conf,fs,column,bulkloadColumnPath,fileInfo.getSecond().longValue(),compactionCacheConfig,cryptoContext);
    refFilePath=refFileWriter.getPath();
    List<Cell> cells=new ArrayList<>();
    boolean hasMore;
    ScannerContext scannerContext=ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();
    do {
      hasMore=scanner.next(cells,scannerContext);
      for (      Cell cell : cells) {
        writer.append(cell);
        KeyValue reference=MobUtils.createMobRefKeyValue(cell,fileName,tableNameTag);
        refFileWriter.append(reference);
        mobCells++;
      }
      cells.clear();
    }
 while (hasMore);
  }
  finally {
    scanner.close();
    closeMobFileWriter(writer,fileInfo.getFirst(),mobCells);
    closeRefFileWriter(refFileWriter,fileInfo.getFirst(),request.selectionTime);
  }
  if (mobCells > 0) {
    MobUtils.commitFile(conf,fs,filePath,mobFamilyDir,compactionCacheConfig);
    bulkloadRefFile(connection,table,bulkloadPathOfPartition,filePath.getName());
    newFiles.add(new Path(mobFamilyDir,filePath.getName()));
  }
 else {
    deletePath(filePath);
    deletePath(refFilePath);
  }
  try {
    closeStoreFileReaders(mobFilesToCompact);
    MobUtils.removeMobFiles(conf,fs,tableName,mobTableDir,column.getName(),mobFilesToCompact);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + mobFilesToCompact,e);
  }
}",0.7961616749054958
61087,"private void createStoreFiles(Path basePath,String family,String qualifier,int count,Type type,boolean sameStartKey) throws IOException {
  HFileContext meta=new HFileContextBuilder().withBlockSize(8 * 1024).build();
  String startKey=""String_Node_Str"";
  MobFileName mobFileName=null;
  for (int i=0; i < count; i++) {
    byte[] startRow;
    if (sameStartKey) {
      startRow=Bytes.toBytes(startKey);
      mobSuffix=UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
      delSuffix=UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    }
 else {
      startRow=Bytes.toBytes(startKey + i);
    }
    if (type.equals(Type.Delete)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),delSuffix);
    }
    if (type.equals(Type.Put)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),mobSuffix);
    }
    StoreFileWriter mobFileWriter=new StoreFileWriter.Builder(conf,cacheConf,fs).withFileContext(meta).withFilePath(new Path(basePath,mobFileName.getFileName())).build();
    writeStoreFile(mobFileWriter,startRow,Bytes.toBytes(family),Bytes.toBytes(qualifier),type,(i + 1) * 1000);
  }
}","/** 
 * Creates store files.
 * @param basePath the path to create file
 * @family the family name
 * @qualifier the column qualifier
 * @count the store file number
 * @type the key type
 */
private void createStoreFiles(Path basePath,String family,String qualifier,int count,Type type) throws IOException {
  HFileContext meta=new HFileContextBuilder().withBlockSize(8 * 1024).build();
  String startKey=""String_Node_Str"";
  MobFileName mobFileName=null;
  for (int i=0; i < count; i++) {
    byte[] startRow=Bytes.toBytes(startKey + i);
    if (type.equals(Type.Delete)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),delSuffix);
    }
    if (type.equals(Type.Put)) {
      mobFileName=MobFileName.create(Bytes.toBytes(startKey + i),MobUtils.formatDate(new Date()),mobSuffix);
    }
    StoreFileWriter mobFileWriter=new StoreFileWriter.Builder(conf,cacheConf,fs).withFileContext(meta).withFilePath(new Path(basePath,mobFileName.getFileName())).build();
    writeStoreFile(mobFileWriter,startRow,Bytes.toBytes(family),Bytes.toBytes(qualifier),type,(i + 1) * 1000);
  }
}",0.758147512864494
61088,"@BeforeClass public static void setUpBeforeClass() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  TEST_UTIL.getConfiguration().setClass(""String_Node_Str"",FaultyDistributedFileSystem.class,DistributedFileSystem.class);
  TEST_UTIL.startMiniCluster(1);
  pool=createThreadPool();
}","@BeforeClass public static void setUpBeforeClass() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  TEST_UTIL.startMiniCluster(1);
  pool=createThreadPool();
}",0.7579365079365079
61089,"/** 
 * Bulkloads the current file.
 * @param connection to use to get admin/RegionLocator
 * @param table The current table.
 * @param bulkloadDirectory The path of bulkload directory.
 * @param fileName The current file name.
 * @throws IOException if IO failure is encountered
 */
private void bulkloadRefFile(Connection connection,Table table,Path bulkloadDirectory,String fileName) throws IOException {
  try {
    LoadIncrementalHFiles bulkload=new LoadIncrementalHFiles(conf);
    bulkload.doBulkLoad(bulkloadDirectory,connection.getAdmin(),table,connection.getRegionLocator(table.getName()));
  }
 catch (  Exception e) {
    deletePath(new Path(mobFamilyDir,fileName));
    throw new IOException(e);
  }
 finally {
    deletePath(bulkloadDirectory);
  }
}","/** 
 * Bulkloads the current file.
 * @param connection to use to get admin/RegionLocator
 * @param table The current table.
 * @param bulkloadDirectory The path of bulkload directory.
 * @param fileName The current file name.
 * @throws IOException if IO failure is encountered
 */
private void bulkloadRefFile(Connection connection,Table table,Path bulkloadDirectory,String fileName) throws IOException {
  try {
    LoadIncrementalHFiles bulkload=new LoadIncrementalHFiles(conf);
    bulkload.doBulkLoad(bulkloadDirectory,connection.getAdmin(),table,connection.getRegionLocator(table.getName()));
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}",0.9307207837648706
61090,"/** 
 * Compacts a partition of selected small mob files and all the del files in a batch.
 * @param request The compaction request.
 * @param partition A compaction partition.
 * @param connection To use for transport
 * @param table The current table.
 * @param filesToCompact The files to be compacted.
 * @param batch The number of mob files to be compacted in a batch.
 * @param bulkloadPathOfPartition The directory where the bulkload column of the currentpartition is saved.
 * @param bulkloadColumnPath The directory where the bulkload files of current partitionare saved.
 * @param newFiles The paths of new mob files after compactions.
 * @throws IOException if IO failure is encountered
 */
private void compactMobFilesInBatch(PartitionedMobCompactionRequest request,CompactionPartition partition,Connection connection,Table table,List<StoreFile> filesToCompact,int batch,Path bulkloadPathOfPartition,Path bulkloadColumnPath,List<Path> newFiles) throws IOException {
  StoreScanner scanner=createScanner(filesToCompact,ScanType.COMPACT_DROP_DELETES);
  List<StoreFile> mobFilesToCompact=filesToCompact.subList(0,batch);
  Pair<Long,Long> fileInfo=getFileInfo(mobFilesToCompact);
  StoreFileWriter writer=null;
  StoreFileWriter refFileWriter=null;
  Path filePath=null;
  Path refFilePath=null;
  long mobCells=0;
  try {
    writer=MobUtils.createWriter(conf,fs,column,partition.getPartitionId().getDate(),tempPath,Long.MAX_VALUE,column.getCompactionCompressionType(),partition.getPartitionId().getStartKey(),compactionCacheConfig,cryptoContext);
    filePath=writer.getPath();
    byte[] fileName=Bytes.toBytes(filePath.getName());
    refFileWriter=MobUtils.createRefFileWriter(conf,fs,column,bulkloadColumnPath,fileInfo.getSecond().longValue(),compactionCacheConfig,cryptoContext);
    refFilePath=refFileWriter.getPath();
    List<Cell> cells=new ArrayList<>();
    boolean hasMore;
    ScannerContext scannerContext=ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();
    do {
      hasMore=scanner.next(cells,scannerContext);
      for (      Cell cell : cells) {
        writer.append(cell);
        KeyValue reference=MobUtils.createMobRefKeyValue(cell,fileName,tableNameTag);
        refFileWriter.append(reference);
        mobCells++;
      }
      cells.clear();
    }
 while (hasMore);
  }
  finally {
    scanner.close();
    closeMobFileWriter(writer,fileInfo.getFirst(),mobCells);
    closeRefFileWriter(refFileWriter,fileInfo.getFirst(),request.selectionTime);
  }
  if (mobCells > 0) {
    MobUtils.commitFile(conf,fs,filePath,mobFamilyDir,compactionCacheConfig);
    bulkloadRefFile(connection,table,bulkloadPathOfPartition,filePath.getName());
    newFiles.add(new Path(mobFamilyDir,filePath.getName()));
  }
 else {
    deletePath(filePath);
    deletePath(refFilePath);
  }
  try {
    closeStoreFileReaders(mobFilesToCompact);
    MobUtils.removeMobFiles(conf,fs,tableName,mobTableDir,column.getName(),mobFilesToCompact);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + mobFilesToCompact,e);
  }
}","/** 
 * Compacts a partition of selected small mob files and all the del files in a batch.
 * @param request The compaction request.
 * @param partition A compaction partition.
 * @param connection To use for transport
 * @param table The current table.
 * @param filesToCompact The files to be compacted.
 * @param batch The number of mob files to be compacted in a batch.
 * @param bulkloadPathOfPartition The directory where the bulkload column of the currentpartition is saved.
 * @param bulkloadColumnPath The directory where the bulkload files of current partitionare saved.
 * @param newFiles The paths of new mob files after compactions.
 * @throws IOException if IO failure is encountered
 */
private void compactMobFilesInBatch(PartitionedMobCompactionRequest request,CompactionPartition partition,Connection connection,Table table,List<StoreFile> filesToCompact,int batch,Path bulkloadPathOfPartition,Path bulkloadColumnPath,List<Path> newFiles) throws IOException {
  StoreScanner scanner=createScanner(filesToCompact,ScanType.COMPACT_DROP_DELETES);
  List<StoreFile> mobFilesToCompact=filesToCompact.subList(0,batch);
  Pair<Long,Long> fileInfo=getFileInfo(mobFilesToCompact);
  StoreFileWriter writer=null;
  StoreFileWriter refFileWriter=null;
  Path filePath=null;
  long mobCells=0;
  boolean cleanupTmpMobFile=false;
  boolean cleanupBulkloadDirOfPartition=false;
  boolean cleanupCommittedMobFile=false;
  boolean closeReaders=true;
  try {
    try {
      writer=MobUtils.createWriter(conf,fs,column,partition.getPartitionId().getDate(),tempPath,Long.MAX_VALUE,column.getCompactionCompressionType(),partition.getPartitionId().getStartKey(),compactionCacheConfig,cryptoContext);
      cleanupTmpMobFile=true;
      filePath=writer.getPath();
      byte[] fileName=Bytes.toBytes(filePath.getName());
      refFileWriter=MobUtils.createRefFileWriter(conf,fs,column,bulkloadColumnPath,fileInfo.getSecond().longValue(),compactionCacheConfig,cryptoContext);
      cleanupBulkloadDirOfPartition=true;
      List<Cell> cells=new ArrayList<>();
      boolean hasMore;
      ScannerContext scannerContext=ScannerContext.newBuilder().setBatchLimit(compactionKVMax).build();
      do {
        hasMore=scanner.next(cells,scannerContext);
        for (        Cell cell : cells) {
          writer.append(cell);
          KeyValue reference=MobUtils.createMobRefKeyValue(cell,fileName,tableNameTag);
          refFileWriter.append(reference);
          mobCells++;
        }
        cells.clear();
      }
 while (hasMore);
    }
  finally {
      scanner.close();
      if (cleanupTmpMobFile) {
        closeMobFileWriter(writer,fileInfo.getFirst(),mobCells);
      }
      if (cleanupBulkloadDirOfPartition) {
        closeRefFileWriter(refFileWriter,fileInfo.getFirst(),request.selectionTime);
      }
    }
    if (mobCells > 0) {
      MobUtils.commitFile(conf,fs,filePath,mobFamilyDir,compactionCacheConfig);
      cleanupTmpMobFile=false;
      cleanupCommittedMobFile=true;
      bulkloadRefFile(connection,table,bulkloadPathOfPartition,filePath.getName());
      cleanupCommittedMobFile=false;
      newFiles.add(new Path(mobFamilyDir,filePath.getName()));
    }
    try {
      closeStoreFileReaders(mobFilesToCompact);
      closeReaders=false;
      MobUtils.removeMobFiles(conf,fs,tableName,mobTableDir,column.getName(),mobFilesToCompact);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"" + mobFilesToCompact,e);
    }
  }
  finally {
    if (closeReaders) {
      closeStoreFileReaders(mobFilesToCompact);
    }
    if (cleanupTmpMobFile) {
      deletePath(filePath);
    }
    if (cleanupBulkloadDirOfPartition) {
      deletePath(bulkloadPathOfPartition);
    }
    if (cleanupCommittedMobFile) {
      deletePath(new Path(mobFamilyDir,filePath.getName()));
    }
  }
}",0.7976155859261413
61091,"/** 
 * Creates store files.
 * @param basePath the path to create file
 * @family the family name
 * @qualifier the column qualifier
 * @count the store file number
 * @type the key type
 */
private void createStoreFiles(Path basePath,String family,String qualifier,int count,Type type) throws IOException {
  HFileContext meta=new HFileContextBuilder().withBlockSize(8 * 1024).build();
  String startKey=""String_Node_Str"";
  MobFileName mobFileName=null;
  for (int i=0; i < count; i++) {
    byte[] startRow=Bytes.toBytes(startKey + i);
    if (type.equals(Type.Delete)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),delSuffix);
    }
    if (type.equals(Type.Put)) {
      mobFileName=MobFileName.create(Bytes.toBytes(startKey + i),MobUtils.formatDate(new Date()),mobSuffix);
    }
    StoreFileWriter mobFileWriter=new StoreFileWriter.Builder(conf,cacheConf,fs).withFileContext(meta).withFilePath(new Path(basePath,mobFileName.getFileName())).build();
    writeStoreFile(mobFileWriter,startRow,Bytes.toBytes(family),Bytes.toBytes(qualifier),type,(i + 1) * 1000);
  }
}","private void createStoreFiles(Path basePath,String family,String qualifier,int count,Type type,boolean sameStartKey) throws IOException {
  HFileContext meta=new HFileContextBuilder().withBlockSize(8 * 1024).build();
  String startKey=""String_Node_Str"";
  MobFileName mobFileName=null;
  for (int i=0; i < count; i++) {
    byte[] startRow;
    if (sameStartKey) {
      startRow=Bytes.toBytes(startKey);
      mobSuffix=UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
      delSuffix=UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    }
 else {
      startRow=Bytes.toBytes(startKey + i);
    }
    if (type.equals(Type.Delete)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),delSuffix);
    }
    if (type.equals(Type.Put)) {
      mobFileName=MobFileName.create(startRow,MobUtils.formatDate(new Date()),mobSuffix);
    }
    StoreFileWriter mobFileWriter=new StoreFileWriter.Builder(conf,cacheConf,fs).withFileContext(meta).withFilePath(new Path(basePath,mobFileName.getFileName())).build();
    writeStoreFile(mobFileWriter,startRow,Bytes.toBytes(family),Bytes.toBytes(qualifier),type,(i + 1) * 1000);
  }
}",0.6895368782161235
61092,"@BeforeClass public static void setUpBeforeClass() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  TEST_UTIL.startMiniCluster(1);
  pool=createThreadPool();
}","@BeforeClass public static void setUpBeforeClass() throws Exception {
  TEST_UTIL.getConfiguration().setInt(""String_Node_Str"",3);
  TEST_UTIL.getConfiguration().setClass(""String_Node_Str"",FaultyDistributedFileSystem.class,DistributedFileSystem.class);
  TEST_UTIL.startMiniCluster(1);
  pool=createThreadPool();
}",0.7579365079365079
61093,"/** 
 * Actually do the mvcc read. Does no checks.
 * @param offsetFromPos
 */
private void _readMvccVersion(int offsetFromPos){
  byte firstByte=blockBuffer.getByteAfterPosition(offsetFromPos);
  int len=WritableUtils.decodeVIntSize(firstByte);
  if (len == 1) {
    this.currMemstoreTS=firstByte;
  }
 else {
    int remaining=len - 1;
    long i=0;
    offsetFromPos++;
    if (remaining >= Bytes.SIZEOF_INT) {
      i=blockBuffer.getIntAfterPosition(offsetFromPos);
      remaining-=Bytes.SIZEOF_INT;
      offsetFromPos+=Bytes.SIZEOF_INT;
    }
    if (remaining >= Bytes.SIZEOF_SHORT) {
      short s=blockBuffer.getShortAfterPosition(offsetFromPos);
      i=i << 16;
      i=i | (s & 0xFFFF);
      remaining-=Bytes.SIZEOF_SHORT;
      offsetFromPos+=Bytes.SIZEOF_SHORT;
    }
    for (int idx=0; idx < remaining; idx++) {
      byte b=blockBuffer.getByteAfterPosition(offsetFromPos + idx);
      i=i << 8;
      i=i | (b & 0xFF);
    }
    currMemstoreTS=(WritableUtils.isNegativeVInt(firstByte) ? ~i : i);
  }
  this.currMemstoreTSLen=len;
}","/** 
 * Actually do the mvcc read. Does no checks.
 * @param offsetFromPos
 */
private void _readMvccVersion(int offsetFromPos){
  byte firstByte=blockBuffer.getByteAfterPosition(offsetFromPos);
  int len=WritableUtils.decodeVIntSize(firstByte);
  if (len == 1) {
    this.currMemstoreTS=firstByte;
  }
 else {
    int remaining=len - 1;
    long i=0;
    offsetFromPos++;
    if (remaining >= Bytes.SIZEOF_INT) {
      i=(blockBuffer.getIntAfterPosition(offsetFromPos) & 0x00000000ffffffffL);
      remaining-=Bytes.SIZEOF_INT;
      offsetFromPos+=Bytes.SIZEOF_INT;
    }
    if (remaining >= Bytes.SIZEOF_SHORT) {
      short s=blockBuffer.getShortAfterPosition(offsetFromPos);
      i=i << 16;
      i=i | (s & 0xFFFF);
      remaining-=Bytes.SIZEOF_SHORT;
      offsetFromPos+=Bytes.SIZEOF_SHORT;
    }
    for (int idx=0; idx < remaining; idx++) {
      byte b=blockBuffer.getByteAfterPosition(offsetFromPos + idx);
      i=i << 8;
      i=i | (b & 0xFF);
    }
    currMemstoreTS=(WritableUtils.isNegativeVInt(firstByte) ? ~i : i);
  }
  this.currMemstoreTSLen=len;
}",0.9887005649717514
61094,"@Override public void start(CoprocessorEnvironment env) throws IOException {
  MasterCoprocessorEnvironment menv=(MasterCoprocessorEnvironment)env;
  master=menv.getMasterServices();
  groupInfoManager=new RSGroupInfoManagerImpl(master);
  groupAdminServer=new RSGroupAdminServer(master,groupInfoManager);
  Class clazz=master.getConfiguration().getClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,null);
  if (!RSGroupableBalancer.class.isAssignableFrom(clazz)) {
    throw new IOException(""String_Node_Str"");
  }
}","@Override public void start(CoprocessorEnvironment env) throws IOException {
  MasterCoprocessorEnvironment menv=(MasterCoprocessorEnvironment)env;
  master=menv.getMasterServices();
  setGroupInfoManager(new RSGroupInfoManagerImpl(master));
  groupAdminServer=new RSGroupAdminServer(master,groupInfoManager);
  Class clazz=master.getConfiguration().getClass(HConstants.HBASE_MASTER_LOADBALANCER_CLASS,null);
  if (!RSGroupableBalancer.class.isAssignableFrom(clazz)) {
    throw new IOException(""String_Node_Str"");
  }
}",0.9922779922779924
61095,"@Override public void moveServers(Set<HostAndPort> servers,String targetGroupName) throws IOException {
  if (servers == null) {
    throw new ConstraintException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(targetGroupName)) {
    throw new ConstraintException(""String_Node_Str"");
  }
  if (servers.size() < 1) {
    return;
  }
  RSGroupInfo targetGrp=getRSGroupInfo(targetGroupName);
  if (targetGrp == null) {
    throw new ConstraintException(""String_Node_Str"" + targetGroupName);
  }
  RSGroupInfoManager manager=getRSGroupInfoManager();
synchronized (manager) {
    if (master.getMasterCoprocessorHost() != null) {
      master.getMasterCoprocessorHost().preMoveServers(servers,targetGroupName);
    }
    HostAndPort firstServer=servers.iterator().next();
    RSGroupInfo srcGrp=manager.getRSGroupOfServer(firstServer);
    if (srcGrp == null) {
      throw new ConstraintException(""String_Node_Str"" + firstServer + ""String_Node_Str"");
    }
    if (RSGroupInfo.DEFAULT_GROUP.equals(srcGrp.getName())) {
      Set<HostAndPort> onlineServers=new HashSet<HostAndPort>();
      for (      ServerName server : master.getServerManager().getOnlineServers().keySet()) {
        onlineServers.add(server.getHostPort());
      }
      for (      HostAndPort el : servers) {
        if (!onlineServers.contains(el)) {
          throw new ConstraintException(""String_Node_Str"" + el + ""String_Node_Str"");
        }
      }
    }
    if (srcGrp.getServers().size() <= servers.size() && srcGrp.getTables().size() > 0) {
      throw new ConstraintException(""String_Node_Str"" + srcGrp.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    String sourceGroupName=getRSGroupInfoManager().getRSGroupOfServer(srcGrp.getServers().iterator().next()).getName();
    if (getRSGroupInfo(targetGroupName) == null) {
      throw new ConstraintException(""String_Node_Str"" + targetGroupName);
    }
    for (    HostAndPort server : servers) {
      if (serversInTransition.containsKey(server)) {
        throw new ConstraintException(""String_Node_Str"" + server);
      }
      String tmpGroup=getRSGroupInfoManager().getRSGroupOfServer(server).getName();
      if (sourceGroupName != null && !tmpGroup.equals(sourceGroupName)) {
        throw new ConstraintException(""String_Node_Str"" + ""String_Node_Str"" + sourceGroupName + ""String_Node_Str""+ tmpGroup);
      }
    }
    if (sourceGroupName.equals(targetGroupName)) {
      throw new ConstraintException(""String_Node_Str"" + targetGroupName);
    }
    try {
      for (      HostAndPort server : servers) {
        serversInTransition.put(server,targetGroupName);
      }
      getRSGroupInfoManager().moveServers(servers,sourceGroupName,targetGroupName);
      boolean found;
      List<HostAndPort> tmpServers=Lists.newArrayList(servers);
      do {
        found=false;
        for (Iterator<HostAndPort> iter=tmpServers.iterator(); iter.hasNext(); ) {
          HostAndPort rs=iter.next();
          List<HRegionInfo> regions=new LinkedList<HRegionInfo>();
          for (          Map.Entry<HRegionInfo,ServerName> el : master.getAssignmentManager().getRegionStates().getRegionAssignments().entrySet()) {
            if (el.getValue().getHostPort().equals(rs)) {
              regions.add(el.getKey());
            }
          }
          for (          RegionState state : master.getAssignmentManager().getRegionStates().getRegionsInTransition()) {
            if (state.getServerName().getHostPort().equals(rs)) {
              regions.add(state.getRegion());
            }
          }
          LOG.info(""String_Node_Str"" + regions.size() + ""String_Node_Str""+ rs+ ""String_Node_Str""+ targetGroupName);
          if (regions.size() > 0) {
            for (            HRegionInfo region : regions) {
              if (!targetGrp.containsTable(region.getTable())) {
                master.getAssignmentManager().unassign(region);
                found=true;
              }
            }
          }
          if (!found) {
            iter.remove();
          }
        }
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          LOG.warn(""String_Node_Str"",e);
          Thread.currentThread().interrupt();
        }
      }
 while (found);
    }
  finally {
      for (      HostAndPort server : servers) {
        serversInTransition.remove(server);
      }
    }
    if (master.getMasterCoprocessorHost() != null) {
      master.getMasterCoprocessorHost().postMoveServers(servers,targetGroupName);
    }
    LOG.info(""String_Node_Str"" + sourceGroupName + ""String_Node_Str""+ targetGroupName);
  }
}","@Override public void moveServers(Set<HostAndPort> servers,String targetGroupName) throws IOException {
  if (servers == null) {
    throw new ConstraintException(""String_Node_Str"");
  }
  if (StringUtils.isEmpty(targetGroupName)) {
    throw new ConstraintException(""String_Node_Str"");
  }
  if (servers.size() < 1) {
    return;
  }
  RSGroupInfo targetGrp=getRSGroupInfo(targetGroupName);
  if (targetGrp == null) {
    throw new ConstraintException(""String_Node_Str"" + targetGroupName);
  }
  RSGroupInfoManager manager=getRSGroupInfoManager();
synchronized (manager) {
    if (master.getMasterCoprocessorHost() != null) {
      master.getMasterCoprocessorHost().preMoveServers(servers,targetGroupName);
    }
    HostAndPort firstServer=servers.iterator().next();
    RSGroupInfo srcGrp=manager.getRSGroupOfServer(firstServer);
    if (srcGrp == null) {
      throw new ConstraintException(""String_Node_Str"" + firstServer + ""String_Node_Str"");
    }
    if (RSGroupInfo.DEFAULT_GROUP.equals(srcGrp.getName())) {
      Set<HostAndPort> onlineServers=new HashSet<HostAndPort>();
      for (      ServerName server : master.getServerManager().getOnlineServers().keySet()) {
        onlineServers.add(server.getHostPort());
      }
      for (      HostAndPort el : servers) {
        if (!onlineServers.contains(el)) {
          throw new ConstraintException(""String_Node_Str"" + el + ""String_Node_Str"");
        }
      }
    }
    if (srcGrp.getServers().size() <= servers.size() && srcGrp.getTables().size() > 0) {
      throw new ConstraintException(""String_Node_Str"" + srcGrp.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    String sourceGroupName=getRSGroupInfoManager().getRSGroupOfServer(srcGrp.getServers().iterator().next()).getName();
    if (getRSGroupInfo(targetGroupName) == null) {
      throw new ConstraintException(""String_Node_Str"" + targetGroupName);
    }
    for (    HostAndPort server : servers) {
      if (serversInTransition.containsKey(server)) {
        throw new ConstraintException(""String_Node_Str"" + server);
      }
      String tmpGroup=getRSGroupInfoManager().getRSGroupOfServer(server).getName();
      if (sourceGroupName != null && !tmpGroup.equals(sourceGroupName)) {
        throw new ConstraintException(""String_Node_Str"" + ""String_Node_Str"" + sourceGroupName + ""String_Node_Str""+ tmpGroup);
      }
    }
    if (sourceGroupName.equals(targetGroupName)) {
      throw new ConstraintException(""String_Node_Str"" + targetGroupName);
    }
    try {
      for (      HostAndPort server : servers) {
        serversInTransition.put(server,targetGroupName);
      }
      getRSGroupInfoManager().moveServers(servers,sourceGroupName,targetGroupName);
      boolean found;
      List<HostAndPort> tmpServers=Lists.newArrayList(servers);
      do {
        found=false;
        for (Iterator<HostAndPort> iter=tmpServers.iterator(); iter.hasNext(); ) {
          HostAndPort rs=iter.next();
          List<HRegionInfo> regions=new LinkedList<HRegionInfo>();
          for (          Map.Entry<HRegionInfo,ServerName> el : master.getAssignmentManager().getRegionStates().getRegionAssignments().entrySet()) {
            if (el.getValue().getHostPort().equals(rs)) {
              regions.add(el.getKey());
            }
          }
          for (          RegionState state : master.getAssignmentManager().getRegionStates().getRegionsInTransition()) {
            if (state.getServerName().getHostPort().equals(rs)) {
              regions.add(state.getRegion());
            }
          }
          LOG.info(""String_Node_Str"" + regions.size() + ""String_Node_Str""+ rs+ ""String_Node_Str""+ targetGroupName);
          if (regions.size() > 0) {
            for (            HRegionInfo region : regions) {
              if (!targetGrp.containsTable(region.getTable())) {
                master.getAssignmentManager().unassign(region);
                found=true;
              }
            }
          }
          if (!found) {
            iter.remove();
          }
        }
        try {
          manager.wait(1000);
        }
 catch (        InterruptedException e) {
          LOG.warn(""String_Node_Str"",e);
          Thread.currentThread().interrupt();
        }
      }
 while (found);
    }
  finally {
      for (      HostAndPort server : servers) {
        serversInTransition.remove(server);
      }
    }
    if (master.getMasterCoprocessorHost() != null) {
      master.getMasterCoprocessorHost().postMoveServers(servers,targetGroupName);
    }
    LOG.info(""String_Node_Str"" + sourceGroupName + ""String_Node_Str""+ targetGroupName);
  }
}",0.9973901696389734
61096,"private Map<ServerName,List<HRegionInfo>> correctAssignments(Map<ServerName,List<HRegionInfo>> existingAssignments){
  Map<ServerName,List<HRegionInfo>> correctAssignments=new TreeMap<ServerName,List<HRegionInfo>>();
  List<HRegionInfo> misplacedRegions=new LinkedList<HRegionInfo>();
  correctAssignments.put(LoadBalancer.BOGUS_SERVER_NAME,new LinkedList<HRegionInfo>());
  for (  ServerName sName : existingAssignments.keySet()) {
    correctAssignments.put(sName,new LinkedList<HRegionInfo>());
    List<HRegionInfo> regions=existingAssignments.get(sName);
    for (    HRegionInfo region : regions) {
      RSGroupInfo info=null;
      try {
        info=RSGroupInfoManager.getRSGroup(RSGroupInfoManager.getRSGroupOfTable(region.getTable()));
      }
 catch (      IOException exp) {
        LOG.debug(""String_Node_Str"" + region.getTable(),exp);
      }
      if ((info == null) || (!info.containsServer(sName.getHostPort()))) {
        correctAssignments.get(LoadBalancer.BOGUS_SERVER_NAME).add(region);
      }
 else {
        correctAssignments.get(sName).add(region);
      }
    }
  }
  for (  HRegionInfo info : misplacedRegions) {
    this.masterServices.getAssignmentManager().unassign(info);
  }
  return correctAssignments;
}","private Map<ServerName,List<HRegionInfo>> correctAssignments(Map<ServerName,List<HRegionInfo>> existingAssignments){
  Map<ServerName,List<HRegionInfo>> correctAssignments=new TreeMap<ServerName,List<HRegionInfo>>();
  List<HRegionInfo> misplacedRegions=new LinkedList<HRegionInfo>();
  correctAssignments.put(LoadBalancer.BOGUS_SERVER_NAME,new LinkedList<HRegionInfo>());
  for (  Map.Entry<ServerName,List<HRegionInfo>> assignments : existingAssignments.entrySet()) {
    ServerName sName=assignments.getKey();
    correctAssignments.put(sName,new LinkedList<HRegionInfo>());
    List<HRegionInfo> regions=assignments.getValue();
    for (    HRegionInfo region : regions) {
      RSGroupInfo info=null;
      try {
        info=RSGroupInfoManager.getRSGroup(RSGroupInfoManager.getRSGroupOfTable(region.getTable()));
      }
 catch (      IOException exp) {
        LOG.debug(""String_Node_Str"" + region.getTable(),exp);
      }
      if ((info == null) || (!info.containsServer(sName.getHostPort()))) {
        correctAssignments.get(LoadBalancer.BOGUS_SERVER_NAME).add(region);
      }
 else {
        correctAssignments.get(sName).add(region);
      }
    }
  }
  for (  HRegionInfo info : misplacedRegions) {
    this.masterServices.getAssignmentManager().unassign(info);
  }
  return correctAssignments;
}",0.8580392156862745
61097,"private Set<HRegionInfo> getMisplacedRegions(Map<HRegionInfo,ServerName> regions) throws IOException {
  Set<HRegionInfo> misplacedRegions=new HashSet<HRegionInfo>();
  for (  HRegionInfo region : regions.keySet()) {
    ServerName assignedServer=regions.get(region);
    RSGroupInfo info=RSGroupInfoManager.getRSGroup(RSGroupInfoManager.getRSGroupOfTable(region.getTable()));
    if (assignedServer != null && (info == null || !info.containsServer(assignedServer.getHostPort()))) {
      LOG.debug(""String_Node_Str"" + region.getRegionNameAsString() + ""String_Node_Str""+ assignedServer+ ""String_Node_Str""+ RSGroupInfoManager.getRSGroupOfServer(assignedServer.getHostPort())+ ""String_Node_Str""+ (info == null ? ""String_Node_Str"" : info.getName()));
      misplacedRegions.add(region);
    }
  }
  return misplacedRegions;
}","private Set<HRegionInfo> getMisplacedRegions(Map<HRegionInfo,ServerName> regions) throws IOException {
  Set<HRegionInfo> misplacedRegions=new HashSet<HRegionInfo>();
  for (  Map.Entry<HRegionInfo,ServerName> region : regions.entrySet()) {
    HRegionInfo regionInfo=region.getKey();
    ServerName assignedServer=region.getValue();
    RSGroupInfo info=RSGroupInfoManager.getRSGroup(RSGroupInfoManager.getRSGroupOfTable(regionInfo.getTable()));
    if (assignedServer != null && (info == null || !info.containsServer(assignedServer.getHostPort()))) {
      LOG.debug(""String_Node_Str"" + regionInfo.getRegionNameAsString() + ""String_Node_Str""+ assignedServer+ ""String_Node_Str""+ RSGroupInfoManager.getRSGroupOfServer(assignedServer.getHostPort())+ ""String_Node_Str""+ (info == null ? ""String_Node_Str"" : info.getName()));
      misplacedRegions.add(regionInfo);
    }
  }
  return misplacedRegions;
}",0.9384436701509872
61098,"public boolean waitForGroupTableOnline(){
  final List<HRegionInfo> foundRegions=new LinkedList<HRegionInfo>();
  final List<HRegionInfo> assignedRegions=new LinkedList<HRegionInfo>();
  final AtomicBoolean found=new AtomicBoolean(false);
  final TableStateManager tsm=masterServices.getTableStateManager();
  boolean createSent=false;
  while (!found.get() && isMasterRunning()) {
    foundRegions.clear();
    assignedRegions.clear();
    found.set(true);
    try {
      final Table nsTable=conn.getTable(TableName.NAMESPACE_TABLE_NAME);
      final Table groupTable=conn.getTable(RSGROUP_TABLE_NAME);
      boolean rootMetaFound=masterServices.getMetaTableLocator().verifyMetaRegionLocation(conn,masterServices.getZooKeeper(),1);
      final AtomicBoolean nsFound=new AtomicBoolean(false);
      if (rootMetaFound) {
        MetaTableAccessor.Visitor visitor=new DefaultVisitorBase(){
          @Override public boolean visitInternal(          Result row) throws IOException {
            HRegionInfo info=MetaTableAccessor.getHRegionInfo(row);
            if (info != null) {
              Cell serverCell=row.getColumnLatestCell(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER);
              if (RSGROUP_TABLE_NAME.equals(info.getTable()) && serverCell != null) {
                ServerName sn=ServerName.parseVersionedServerName(CellUtil.cloneValue(serverCell));
                if (sn == null) {
                  found.set(false);
                }
 else                 if (tsm.isTableState(RSGROUP_TABLE_NAME,TableState.State.ENABLED)) {
                  try {
                    ClientProtos.ClientService.BlockingInterface rs=conn.getClient(sn);
                    ClientProtos.GetRequest request=RequestConverter.buildGetRequest(info.getRegionName(),new Get(ROW_KEY));
                    rs.get(null,request);
                    assignedRegions.add(info);
                  }
 catch (                  Exception ex) {
                    LOG.debug(""String_Node_Str"",ex);
                  }
                }
                foundRegions.add(info);
              }
              if (TableName.NAMESPACE_TABLE_NAME.equals(info.getTable())) {
                Cell cell=row.getColumnLatestCell(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER);
                ServerName sn=null;
                if (cell != null) {
                  sn=ServerName.parseVersionedServerName(CellUtil.cloneValue(cell));
                }
                if (tsm.isTableState(TableName.NAMESPACE_TABLE_NAME,TableState.State.ENABLED)) {
                  try {
                    ClientProtos.ClientService.BlockingInterface rs=conn.getClient(sn);
                    ClientProtos.GetRequest request=RequestConverter.buildGetRequest(info.getRegionName(),new Get(ROW_KEY));
                    rs.get(null,request);
                    nsFound.set(true);
                  }
 catch (                  Exception ex) {
                    LOG.debug(""String_Node_Str"",ex);
                  }
                }
              }
            }
            return true;
          }
        }
;
        MetaTableAccessor.fullScanRegions(conn,visitor);
        if (foundRegions.size() < 1 && rootMetaFound && !createSent && nsFound.get()) {
          groupInfoManager.createGroupTable(masterServices);
          createSent=true;
        }
        LOG.info(""String_Node_Str"" + RSGROUP_TABLE_NAME + ""String_Node_Str""+ found.get()+ ""String_Node_Str""+ foundRegions.size()+ ""String_Node_Str""+ assignedRegions.size()+ ""String_Node_Str""+ rootMetaFound);
        found.set(found.get() && assignedRegions.size() == foundRegions.size() && foundRegions.size() > 0);
      }
 else {
        LOG.info(""String_Node_Str"");
        found.set(false);
      }
      if (found.get()) {
        LOG.debug(""String_Node_Str"");
        groupInfoManager.refresh(true);
        isOnline=true;
        groupInfoManager.flushConfig(groupInfoManager.rsGroupMap);
      }
    }
 catch (    Exception e) {
      found.set(false);
      LOG.warn(""String_Node_Str"",e);
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      LOG.info(""String_Node_Str"",e);
    }
  }
  return found.get();
}","public boolean waitForGroupTableOnline(){
  final List<HRegionInfo> foundRegions=new LinkedList<HRegionInfo>();
  final List<HRegionInfo> assignedRegions=new LinkedList<HRegionInfo>();
  final AtomicBoolean found=new AtomicBoolean(false);
  final TableStateManager tsm=masterServices.getTableStateManager();
  boolean createSent=false;
  while (!found.get() && isMasterRunning()) {
    foundRegions.clear();
    assignedRegions.clear();
    found.set(true);
    try {
      final Table nsTable=conn.getTable(TableName.NAMESPACE_TABLE_NAME);
      final Table groupTable=conn.getTable(RSGROUP_TABLE_NAME);
      boolean rootMetaFound=masterServices.getMetaTableLocator().verifyMetaRegionLocation(conn,masterServices.getZooKeeper(),1);
      final AtomicBoolean nsFound=new AtomicBoolean(false);
      if (rootMetaFound) {
        MetaTableAccessor.Visitor visitor=new DefaultVisitorBase(){
          @Override public boolean visitInternal(          Result row) throws IOException {
            HRegionInfo info=MetaTableAccessor.getHRegionInfo(row);
            if (info != null) {
              Cell serverCell=row.getColumnLatestCell(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER);
              if (RSGROUP_TABLE_NAME.equals(info.getTable()) && serverCell != null) {
                ServerName sn=ServerName.parseVersionedServerName(CellUtil.cloneValue(serverCell));
                if (sn == null) {
                  found.set(false);
                }
 else                 if (tsm.isTableState(RSGROUP_TABLE_NAME,TableState.State.ENABLED)) {
                  try {
                    ClientProtos.ClientService.BlockingInterface rs=conn.getClient(sn);
                    ClientProtos.GetRequest request=RequestConverter.buildGetRequest(info.getRegionName(),new Get(ROW_KEY));
                    rs.get(null,request);
                    assignedRegions.add(info);
                  }
 catch (                  Exception ex) {
                    LOG.debug(""String_Node_Str"",ex);
                  }
                }
                foundRegions.add(info);
              }
              if (TableName.NAMESPACE_TABLE_NAME.equals(info.getTable())) {
                Cell cell=row.getColumnLatestCell(HConstants.CATALOG_FAMILY,HConstants.SERVER_QUALIFIER);
                ServerName sn=null;
                if (cell != null) {
                  sn=ServerName.parseVersionedServerName(CellUtil.cloneValue(cell));
                }
                if (tsm.isTableState(TableName.NAMESPACE_TABLE_NAME,TableState.State.ENABLED)) {
                  try {
                    ClientProtos.ClientService.BlockingInterface rs=conn.getClient(sn);
                    ClientProtos.GetRequest request=RequestConverter.buildGetRequest(info.getRegionName(),new Get(ROW_KEY));
                    rs.get(null,request);
                    nsFound.set(true);
                  }
 catch (                  Exception ex) {
                    LOG.debug(""String_Node_Str"",ex);
                  }
                }
              }
            }
            return true;
          }
        }
;
        MetaTableAccessor.fullScanRegions(conn,visitor);
        if (foundRegions.size() < 1 && rootMetaFound && !createSent && nsFound.get()) {
          groupInfoManager.createGroupTable(masterServices);
          createSent=true;
        }
        LOG.info(""String_Node_Str"" + RSGROUP_TABLE_NAME + ""String_Node_Str""+ found.get()+ ""String_Node_Str""+ foundRegions.size()+ ""String_Node_Str""+ assignedRegions.size()+ ""String_Node_Str""+ rootMetaFound);
        found.set(found.get() && assignedRegions.size() == foundRegions.size() && foundRegions.size() > 0);
      }
 else {
        LOG.info(""String_Node_Str"");
        found.set(false);
      }
      if (found.get()) {
        LOG.debug(""String_Node_Str"");
        groupInfoManager.refresh(true);
        isOnline=true;
        groupInfoManager.flushConfig(groupInfoManager.rsGroupMap);
      }
    }
 catch (    RuntimeException e) {
      throw e;
    }
catch (    Exception e) {
      found.set(false);
      LOG.warn(""String_Node_Str"",e);
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      LOG.info(""String_Node_Str"",e);
    }
  }
  return found.get();
}",0.9935988620199148
61099,"public RSGroupInfoManagerImpl(MasterServices master) throws IOException {
  this.rsGroupMap=Collections.EMPTY_MAP;
  this.tableMap=Collections.EMPTY_MAP;
  rsGroupSerDe=new RSGroupSerDe();
  this.master=master;
  this.watcher=master.getZooKeeper();
  this.conn=master.getClusterConnection();
  rsGroupStartupWorker=new RSGroupStartupWorker(this,master,conn);
  prevRSGroups=new HashSet<String>();
  refresh();
  rsGroupStartupWorker.start();
  defaultServerUpdater=new DefaultServerUpdater(this);
  master.getServerManager().registerListener(this);
  defaultServerUpdater.start();
}","public RSGroupInfoManagerImpl(MasterServices master) throws IOException {
  this.rsGroupMap=Collections.EMPTY_MAP;
  this.tableMap=Collections.EMPTY_MAP;
  rsGroupSerDe=new RSGroupSerDe();
  this.master=master;
  this.watcher=master.getZooKeeper();
  this.conn=master.getClusterConnection();
  prevRSGroups=new HashSet<String>();
}",0.7250821467688937
61100,"@Override public synchronized void moveTables(Set<TableName> tableNames,String groupName) throws IOException {
  if (groupName != null && !rsGroupMap.containsKey(groupName)) {
    throw new DoNotRetryIOException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  Map<String,RSGroupInfo> newGroupMap=Maps.newHashMap(rsGroupMap);
  for (  TableName tableName : tableNames) {
    if (tableMap.containsKey(tableName)) {
      RSGroupInfo src=new RSGroupInfo(rsGroupMap.get(tableMap.get(tableName)));
      src.removeTable(tableName);
      newGroupMap.put(src.getName(),src);
    }
    if (groupName != null) {
      RSGroupInfo dst=new RSGroupInfo(newGroupMap.get(groupName));
      dst.addTable(tableName);
      newGroupMap.put(dst.getName(),dst);
    }
  }
  flushConfig(newGroupMap);
}","@Override public synchronized void moveTables(Set<TableName> tableNames,String groupName) throws IOException {
  if (groupName != null && !rsGroupMap.containsKey(groupName)) {
    throw new DoNotRetryIOException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  Map<String,RSGroupInfo> newGroupMap=Maps.newHashMap(rsGroupMap);
  for (  TableName tableName : tableNames) {
    if (tableMap.containsKey(tableName)) {
      RSGroupInfo src=new RSGroupInfo(newGroupMap.get(tableMap.get(tableName)));
      src.removeTable(tableName);
      newGroupMap.put(src.getName(),src);
    }
    if (groupName != null) {
      RSGroupInfo dst=new RSGroupInfo(newGroupMap.get(groupName));
      dst.addTable(tableName);
      newGroupMap.put(dst.getName(),dst);
    }
  }
  flushConfig(newGroupMap);
}",0.9968494013862634
61101,"@Override public boolean evaluate() throws Exception {
  return cluster.getClusterStatus().getRegionsInTransition().size() == 0;
}","@Override public boolean evaluate() throws Exception {
  List<String> regionsA=getTableRegionMap().get(tableNameA);
  if (regionsA == null)   return false;
  List<String> regionsB=getTableRegionMap().get(tableNameB);
  if (regionsB == null)   return false;
  return getTableRegionMap().get(tableNameA).size() >= 1 && getTableRegionMap().get(tableNameB).size() >= 1;
}",0.3138832997987927
61102,"@Override public synchronized void moveTables(Set<TableName> tableNames,String groupName) throws IOException {
  if (groupName != null && !rsGroupMap.containsKey(groupName)) {
    throw new DoNotRetryIOException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  Map<String,RSGroupInfo> newGroupMap=Maps.newHashMap(rsGroupMap);
  for (  TableName tableName : tableNames) {
    if (tableMap.containsKey(tableName)) {
      RSGroupInfo src=new RSGroupInfo(rsGroupMap.get(tableMap.get(tableName)));
      src.removeTable(tableName);
      newGroupMap.put(src.getName(),src);
    }
    if (groupName != null) {
      RSGroupInfo dst=new RSGroupInfo(newGroupMap.get(groupName));
      dst.addTable(tableName);
      newGroupMap.put(dst.getName(),dst);
    }
  }
  flushConfig(newGroupMap);
}","@Override public synchronized void moveTables(Set<TableName> tableNames,String groupName) throws IOException {
  if (groupName != null && !rsGroupMap.containsKey(groupName)) {
    throw new DoNotRetryIOException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  Map<String,RSGroupInfo> newGroupMap=Maps.newHashMap(rsGroupMap);
  for (  TableName tableName : tableNames) {
    if (tableMap.containsKey(tableName)) {
      RSGroupInfo src=new RSGroupInfo(newGroupMap.get(tableMap.get(tableName)));
      src.removeTable(tableName);
      newGroupMap.put(src.getName(),src);
    }
    if (groupName != null) {
      RSGroupInfo dst=new RSGroupInfo(newGroupMap.get(groupName));
      dst.addTable(tableName);
      newGroupMap.put(dst.getName(),dst);
    }
  }
  flushConfig(newGroupMap);
}",0.9968494013862634
61103,"@Override public boolean evaluate() throws Exception {
  return cluster.getClusterStatus().getRegionsInTransition().size() == 0;
}","@Override public boolean evaluate() throws Exception {
  List<String> regionsA=getTableRegionMap().get(tableNameA);
  if (regionsA == null)   return false;
  List<String> regionsB=getTableRegionMap().get(tableNameB);
  if (regionsB == null)   return false;
  return getTableRegionMap().get(tableNameA).size() >= 1 && getTableRegionMap().get(tableNameB).size() >= 1;
}",0.3138832997987927
61104,"private void testConnectionClose(boolean allowsInterrupt) throws Exception {
  TableName tableName=TableName.valueOf(""String_Node_Str"" + allowsInterrupt);
  TEST_UTIL.createTable(tableName,FAM_NAM).close();
  boolean previousBalance=TEST_UTIL.getAdmin().setBalancerRunning(false,true);
  Configuration c2=new Configuration(TEST_UTIL.getConfiguration());
  c2.set(HConstants.HBASE_CLIENT_INSTANCE_ID,String.valueOf(-1));
  c2.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,100);
  c2.setInt(HConstants.HBASE_CLIENT_PAUSE,1);
  c2.setInt(RpcClient.FAILED_SERVER_EXPIRY_KEY,0);
  c2.setBoolean(RpcClient.SPECIFIC_WRITE_THREAD,allowsInterrupt);
  Connection connection=ConnectionFactory.createConnection(c2);
  final Table table=connection.getTable(tableName);
  Put put=new Put(ROW);
  put.addColumn(FAM_NAM,ROW,ROW);
  table.put(put);
  final AtomicInteger step=new AtomicInteger(0);
  final AtomicReference<Throwable> failed=new AtomicReference<Throwable>(null);
  Thread t=new Thread(""String_Node_Str""){
    @Override public void run(){
      int done=0;
      try {
        step.set(1);
        while (step.get() == 1) {
          Get get=new Get(ROW);
          table.get(get);
          done++;
          if (done % 100 == 0)           LOG.info(""String_Node_Str"" + done);
        }
      }
 catch (      Throwable t) {
        failed.set(t);
        LOG.error(t);
      }
      step.set(3);
    }
  }
;
  t.start();
  TEST_UTIL.waitFor(20000,new Waiter.Predicate<Exception>(){
    @Override public boolean evaluate() throws Exception {
      return step.get() == 1;
    }
  }
);
  ServerName sn;
  try (RegionLocator rl=connection.getRegionLocator(tableName)){
    sn=rl.getRegionLocation(ROW).getServerName();
  }
   ConnectionImplementation conn=(ConnectionImplementation)connection;
  RpcClient rpcClient=conn.getRpcClient();
  LOG.info(""String_Node_Str"" + conn.toString() + ""String_Node_Str""+ sn);
  for (int i=0; i < 5000; i++) {
    rpcClient.cancelConnections(sn);
    Thread.sleep(5);
  }
  step.compareAndSet(1,2);
  TEST_UTIL.waitFor(40000,new Waiter.Predicate<Exception>(){
    @Override public boolean evaluate() throws Exception {
      return step.get() == 3;
    }
  }
);
  table.close();
  connection.close();
  Assert.assertTrue(""String_Node_Str"" + failed.get(),failed.get() == null);
  TEST_UTIL.getHBaseAdmin().setBalancerRunning(previousBalance,true);
}","private void testConnectionClose(boolean allowsInterrupt) throws Exception {
  TableName tableName=TableName.valueOf(""String_Node_Str"" + allowsInterrupt);
  TEST_UTIL.createTable(tableName,FAM_NAM).close();
  boolean previousBalance=TEST_UTIL.getAdmin().setBalancerRunning(false,true);
  Configuration c2=new Configuration(TEST_UTIL.getConfiguration());
  c2.set(HConstants.HBASE_CLIENT_INSTANCE_ID,String.valueOf(-1));
  c2.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,100);
  c2.setInt(HConstants.HBASE_CLIENT_PAUSE,1);
  c2.setInt(RpcClient.FAILED_SERVER_EXPIRY_KEY,0);
  c2.setBoolean(RpcClient.SPECIFIC_WRITE_THREAD,allowsInterrupt);
  c2.setInt(HConstants.HBASE_CLIENT_META_OPERATION_TIMEOUT,10000);
  c2.setInt(HConstants.HBASE_CLIENT_OPERATION_TIMEOUT,10000);
  c2.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,5000);
  Connection connection=ConnectionFactory.createConnection(c2);
  final Table table=connection.getTable(tableName);
  Put put=new Put(ROW);
  put.addColumn(FAM_NAM,ROW,ROW);
  table.put(put);
  final AtomicInteger step=new AtomicInteger(0);
  final AtomicReference<Throwable> failed=new AtomicReference<Throwable>(null);
  Thread t=new Thread(""String_Node_Str""){
    @Override public void run(){
      int done=0;
      try {
        step.set(1);
        while (step.get() == 1) {
          Get get=new Get(ROW);
          table.get(get);
          done++;
          if (done % 100 == 0)           LOG.info(""String_Node_Str"" + done);
          Thread.sleep(100);
        }
      }
 catch (      Throwable t) {
        failed.set(t);
        LOG.error(t);
      }
      step.set(3);
    }
  }
;
  t.start();
  TEST_UTIL.waitFor(20000,new Waiter.Predicate<Exception>(){
    @Override public boolean evaluate() throws Exception {
      return step.get() == 1;
    }
  }
);
  ServerName sn;
  try (RegionLocator rl=connection.getRegionLocator(tableName)){
    sn=rl.getRegionLocation(ROW).getServerName();
  }
   ConnectionImplementation conn=(ConnectionImplementation)connection;
  RpcClient rpcClient=conn.getRpcClient();
  LOG.info(""String_Node_Str"" + conn.toString() + ""String_Node_Str""+ sn);
  for (int i=0; i < 5000; i++) {
    rpcClient.cancelConnections(sn);
    Thread.sleep(5);
  }
  step.compareAndSet(1,2);
  TEST_UTIL.waitFor(40000,new Waiter.Predicate<Exception>(){
    @Override public boolean evaluate() throws Exception {
      return step.get() == 3;
    }
  }
);
  table.close();
  connection.close();
  Assert.assertTrue(""String_Node_Str"" + failed.get(),failed.get() == null);
  TEST_UTIL.getHBaseAdmin().setBalancerRunning(previousBalance,true);
}",0.9576612903225806
61105,"/** 
 * Check if the range has any overlap with TimeRange
 * @param tr TimeRange
 * @return True if there is overlap, false otherwise
 */
public boolean includesTimeRange(final TimeRange tr){
  if (this.allTime) {
    return true;
  }
  return getMin() < tr.getMax() && getMax() >= tr.getMin();
}","/** 
 * Check if the range has any overlap with TimeRange
 * @param tr TimeRange
 * @return True if there is overlap, false otherwise
 */
public boolean includesTimeRange(final TimeRange tr){
}",0.7893660531697342
61106,"/** 
 * Represents interval [minStamp, maxStamp)
 * @param minStamp the minimum timestamp, inclusive
 * @param maxStamp the maximum timestamp, exclusive
 * @throws IOException
 */
public TimeRange(byte[] minStamp,byte[] maxStamp) throws IOException {
  this(Bytes.toLong(minStamp),Bytes.toLong(maxStamp));
}","/** 
 * Represents interval [minStamp, maxStamp)
 * @param minStamp the minimum timestamp, inclusive
 * @param maxStamp the maximum timestamp, exclusive
 * @throws IllegalArgumentException if either <0,
 * @deprecated This is made @InterfaceAudience.Private in the 2.0 line and above
 */
@Deprecated public TimeRange(long minStamp,long maxStamp){
  check(minStamp,maxStamp);
  this.minStamp=minStamp;
  this.maxStamp=maxStamp;
  this.allTime=isAllTime(minStamp,maxStamp);
}",0.5512820512820513
61107,"/** 
 * Check if the specified timestamp is within this TimeRange. <p> Returns true if within interval [minStamp, maxStamp), false if not.
 * @param timestamp timestamp to check
 * @return true if within TimeRange, false if not
 */
public boolean withinOrAfterTimeRange(long timestamp){
  if (allTime)   return true;
  return (timestamp >= minStamp);
}","/** 
 * Check if the specified timestamp is within this TimeRange. <p> Returns true if within interval [minStamp, maxStamp), false if not.
 * @param timestamp timestamp to check
 * @return true if within TimeRange, false if not
 */
public boolean withinOrAfterTimeRange(long timestamp){
}",0.9
61108,"/** 
 * Compare the timestamp to timerange
 * @param timestamp
 * @return -1 if timestamp is less than timerange,0 if timestamp is within timerange, 1 if timestamp is greater than timerange
 */
public int compare(long timestamp){
  if (allTime)   return 0;
  if (timestamp < minStamp) {
    return -1;
  }
 else   if (timestamp >= maxStamp) {
    return 1;
  }
 else {
    return 0;
  }
}","/** 
 * Compare the timestamp to timerange.
 * @return -1 if timestamp is less than timerange,0 if timestamp is within timerange, 1 if timestamp is greater than timerange
 */
public int compare(long timestamp){
}",0.7033333333333334
61109,"/** 
 * Check if the specified timestamp is within this TimeRange. <p> Returns true if within interval [minStamp, maxStamp), false if not.
 * @param timestamp timestamp to check
 * @return true if within TimeRange, false if not
 */
public boolean withinTimeRange(long timestamp){
  if (this.allTime) {
    return true;
  }
  return (minStamp <= timestamp && timestamp < maxStamp);
}","/** 
 * Check if the specified timestamp is within this TimeRange. <p> Returns true if within interval [minStamp, maxStamp), false if not.
 * @param timestamp timestamp to check
 * @return true if within TimeRange, false if not
 */
public boolean withinTimeRange(long timestamp){
}",0.8476621417797888
61110,"/** 
 * Flushes the snapshot of the MemStore. If this store is not a mob store, flush the cells in the snapshot to store files of HBase. If the store is a mob one, the flusher flushes the MemStore into two places. One is the store files of HBase, the other is the mob files. <ol> <li>Cells that are not PUT type or have the delete mark will be directly flushed to HBase.</li> <li>If the size of a cell value is larger than a threshold, it'll be flushed to a mob file, another cell with the path of this file will be flushed to HBase.</li> <li>If the size of a cell value is smaller than or equal with a threshold, it'll be flushed to HBase directly.</li> </ol>
 */
@Override public List<Path> flushSnapshot(MemStoreSnapshot snapshot,long cacheFlushId,MonitoredTask status,ThroughputController throughputController) throws IOException {
  ArrayList<Path> result=new ArrayList<Path>();
  int cellsCount=snapshot.getCellsCount();
  if (cellsCount == 0)   return result;
  long smallestReadPoint=store.getSmallestReadPoint();
  InternalScanner scanner=createScanner(snapshot.getScanner(),smallestReadPoint);
  if (scanner == null) {
    return result;
  }
  StoreFileWriter writer;
  try {
synchronized (flushLock) {
      status.setStatus(""String_Node_Str"" + store + ""String_Node_Str"");
      writer=store.createWriterInTmp(cellsCount,store.getFamily().getCompression(),false,true,true);
      writer.setTimeRangeTracker(snapshot.getTimeRangeTracker());
      try {
        performMobFlush(snapshot,cacheFlushId,scanner,writer,status);
      }
  finally {
        finalizeWriter(writer,cacheFlushId,status);
      }
    }
  }
  finally {
    scanner.close();
  }
  LOG.info(""String_Node_Str"" + cacheFlushId + ""String_Node_Str""+ StringUtils.TraditionalBinaryPrefix.long2String(snapshot.getSize(),""String_Node_Str"",1)+ ""String_Node_Str""+ writer.hasGeneralBloom()+ ""String_Node_Str""+ writer.getPath());
  result.add(writer.getPath());
  return result;
}","/** 
 * Flushes the snapshot of the MemStore. If this store is not a mob store, flush the cells in the snapshot to store files of HBase. If the store is a mob one, the flusher flushes the MemStore into two places. One is the store files of HBase, the other is the mob files. <ol> <li>Cells that are not PUT type or have the delete mark will be directly flushed to HBase.</li> <li>If the size of a cell value is larger than a threshold, it'll be flushed to a mob file, another cell with the path of this file will be flushed to HBase.</li> <li>If the size of a cell value is smaller than or equal with a threshold, it'll be flushed to HBase directly.</li> </ol>
 */
@Override public List<Path> flushSnapshot(MemStoreSnapshot snapshot,long cacheFlushId,MonitoredTask status,ThroughputController throughputController) throws IOException {
  ArrayList<Path> result=new ArrayList<Path>();
  long cellsCount=snapshot.getCellsCount();
  if (cellsCount == 0)   return result;
  long smallestReadPoint=store.getSmallestReadPoint();
  InternalScanner scanner=createScanner(snapshot.getScanner(),smallestReadPoint);
  if (scanner == null) {
    return result;
  }
  StoreFileWriter writer;
  try {
synchronized (flushLock) {
      status.setStatus(""String_Node_Str"" + store + ""String_Node_Str"");
      writer=store.createWriterInTmp(cellsCount,store.getFamily().getCompression(),false,true,true,false,snapshot.getTimeRangeTracker());
      try {
        performMobFlush(snapshot,cacheFlushId,scanner,writer,status);
      }
  finally {
        finalizeWriter(writer,cacheFlushId,status);
      }
    }
  }
  finally {
    scanner.close();
  }
  LOG.info(""String_Node_Str"" + cacheFlushId + ""String_Node_Str""+ StringUtils.TraditionalBinaryPrefix.long2String(snapshot.getSize(),""String_Node_Str"",1)+ ""String_Node_Str""+ writer.hasGeneralBloom()+ ""String_Node_Str""+ writer.getPath());
  result.add(writer.getPath());
  return result;
}",0.9870667356440764
61111,"@Override public List<Path> flushSnapshot(MemStoreSnapshot snapshot,long cacheFlushId,MonitoredTask status,ThroughputController throughputController) throws IOException {
  ArrayList<Path> result=new ArrayList<Path>();
  int cellsCount=snapshot.getCellsCount();
  if (cellsCount == 0)   return result;
  long smallestReadPoint=store.getSmallestReadPoint();
  InternalScanner scanner=createScanner(snapshot.getScanner(),smallestReadPoint);
  if (scanner == null) {
    return result;
  }
  StoreFileWriter writer;
  try {
synchronized (flushLock) {
      status.setStatus(""String_Node_Str"" + store + ""String_Node_Str"");
      writer=store.createWriterInTmp(cellsCount,store.getFamily().getCompressionType(),false,true,snapshot.isTagsPresent(),false);
      writer.setTimeRangeTracker(snapshot.getTimeRangeTracker());
      IOException e=null;
      try {
        performFlush(scanner,writer,smallestReadPoint,throughputController);
      }
 catch (      IOException ioe) {
        e=ioe;
        throw ioe;
      }
 finally {
        if (e != null) {
          writer.close();
        }
 else {
          finalizeWriter(writer,cacheFlushId,status);
        }
      }
    }
  }
  finally {
    scanner.close();
  }
  LOG.info(""String_Node_Str"" + cacheFlushId + ""String_Node_Str""+ StringUtils.TraditionalBinaryPrefix.long2String(snapshot.getSize(),""String_Node_Str"",1)+ ""String_Node_Str""+ writer.hasGeneralBloom()+ ""String_Node_Str""+ writer.getPath());
  result.add(writer.getPath());
  return result;
}","@Override public List<Path> flushSnapshot(MemStoreSnapshot snapshot,long cacheFlushId,MonitoredTask status,ThroughputController throughputController) throws IOException {
  ArrayList<Path> result=new ArrayList<Path>();
  int cellsCount=snapshot.getCellsCount();
  if (cellsCount == 0)   return result;
  long smallestReadPoint=store.getSmallestReadPoint();
  InternalScanner scanner=createScanner(snapshot.getScanner(),smallestReadPoint);
  if (scanner == null) {
    return result;
  }
  StoreFileWriter writer;
  try {
synchronized (flushLock) {
      status.setStatus(""String_Node_Str"" + store + ""String_Node_Str"");
      writer=store.createWriterInTmp(cellsCount,store.getFamily().getCompressionType(),false,true,snapshot.isTagsPresent(),false,snapshot.getTimeRangeTracker());
      IOException e=null;
      try {
        performFlush(scanner,writer,smallestReadPoint,throughputController);
      }
 catch (      IOException ioe) {
        e=ioe;
        throw ioe;
      }
 finally {
        if (e != null) {
          writer.close();
        }
 else {
          finalizeWriter(writer,cacheFlushId,status);
        }
      }
    }
  }
  finally {
    scanner.close();
  }
  LOG.info(""String_Node_Str"" + cacheFlushId + ""String_Node_Str""+ StringUtils.TraditionalBinaryPrefix.long2String(snapshot.getSize(),""String_Node_Str"",1)+ ""String_Node_Str""+ writer.hasGeneralBloom()+ ""String_Node_Str""+ writer.getPath());
  result.add(writer.getPath());
  return result;
}",0.98752107925801
61112,"/** 
 * Default constructor.
 * @param columns columns specified user in query
 * @param minVersions minimum number of versions to keep
 * @param maxVersions maximum versions to return per column
 * @param oldestUnexpiredTS the oldest timestamp we are interested in,based on TTL 
 */
public ExplicitColumnTracker(NavigableSet<byte[]> columns,int minVersions,int maxVersions,long oldestUnexpiredTS){
  this.maxVersions=maxVersions;
  this.minVersions=minVersions;
  this.oldestStamp=oldestUnexpiredTS;
  this.columns=new ColumnCount[columns.size()];
  int i=0;
  for (  byte[] column : columns) {
    this.columns[i++]=new ColumnCount(column);
  }
  reset();
}","/** 
 * Default constructor.
 * @param columns columns specified user in query
 * @param minVersions minimum number of versions to keep
 * @param maxVersions maximum versions to return per column
 * @param oldestUnexpiredTS the oldest timestamp we are interested in,based on TTL
 */
public ExplicitColumnTracker(NavigableSet<byte[]> columns,int minVersions,int maxVersions,long oldestUnexpiredTS){
  this.maxVersions=maxVersions;
  this.minVersions=minVersions;
  this.oldestStamp=oldestUnexpiredTS;
  this.columns=new ColumnCount[columns.size()];
  int i=0;
  for (  byte[] column : columns) {
    this.columns[i++]=new ColumnCount(column);
  }
  reset();
}",0.9992406985573272
61113,"@Override public StoreFileWriter createWriterInTmp(long maxKeyCount,Compression.Algorithm compression,boolean isCompaction,boolean includeMVCCReadpoint,boolean includesTag,boolean shouldDropBehind) throws IOException {
  final CacheConfig writerCacheConf;
  if (isCompaction) {
    writerCacheConf=new CacheConfig(cacheConf);
    writerCacheConf.setCacheDataOnWrite(false);
  }
 else {
    writerCacheConf=cacheConf;
  }
  InetSocketAddress[] favoredNodes=null;
  if (region.getRegionServerServices() != null) {
    favoredNodes=region.getRegionServerServices().getFavoredNodesForRegion(region.getRegionInfo().getEncodedName());
  }
  HFileContext hFileContext=createFileContext(compression,includeMVCCReadpoint,includesTag,cryptoContext);
  StoreFileWriter w=new StoreFileWriter.Builder(conf,writerCacheConf,this.getFileSystem()).withFilePath(fs.createTempName()).withComparator(comparator).withBloomType(family.getBloomFilterType()).withMaxKeyCount(maxKeyCount).withFavoredNodes(favoredNodes).withFileContext(hFileContext).withShouldDropCacheBehind(shouldDropBehind).build();
  return w;
}","@Override public StoreFileWriter createWriterInTmp(long maxKeyCount,Compression.Algorithm compression,boolean isCompaction,boolean includeMVCCReadpoint,boolean includesTag,boolean shouldDropBehind,final TimeRangeTracker trt) throws IOException {
  final CacheConfig writerCacheConf;
  if (isCompaction) {
    writerCacheConf=new CacheConfig(cacheConf);
    writerCacheConf.setCacheDataOnWrite(false);
  }
 else {
    writerCacheConf=cacheConf;
  }
  InetSocketAddress[] favoredNodes=null;
  if (region.getRegionServerServices() != null) {
    favoredNodes=region.getRegionServerServices().getFavoredNodesForRegion(region.getRegionInfo().getEncodedName());
  }
  HFileContext hFileContext=createFileContext(compression,includeMVCCReadpoint,includesTag,cryptoContext);
  StoreFileWriter.Builder builder=new StoreFileWriter.Builder(conf,writerCacheConf,this.getFileSystem()).withFilePath(fs.createTempName()).withComparator(comparator).withBloomType(family.getBloomFilterType()).withMaxKeyCount(maxKeyCount).withFavoredNodes(favoredNodes).withFileContext(hFileContext).withShouldDropCacheBehind(shouldDropBehind);
  if (trt != null) {
    builder.withTimeRangeTracker(trt);
  }
  return builder.build();
}",0.9411251635412125
61114,"/** 
 * Determines if the caller should do one of several things: - seek/skip to the next row (MatchCode.SEEK_NEXT_ROW) - seek/skip to the next column (MatchCode.SEEK_NEXT_COL) - include the current KeyValue (MatchCode.INCLUDE) - ignore the current KeyValue (MatchCode.SKIP) - got to the next row (MatchCode.DONE)
 * @param cell KeyValue to check
 * @return The match code instance.
 * @throws IOException in case there is an internal consistency problemcaused by a data corruption.
 */
public MatchCode match(Cell cell) throws IOException {
  if (filter != null && filter.filterAllRemaining()) {
    return MatchCode.DONE_SCAN;
  }
  if (curCell != null) {
    int ret=this.rowComparator.compareRows(curCell,cell);
    if (!this.isReversed) {
      if (ret <= -1) {
        return MatchCode.DONE;
      }
 else       if (ret >= 1) {
        return MatchCode.SEEK_NEXT_ROW;
      }
    }
 else {
      if (ret <= -1) {
        return MatchCode.SEEK_NEXT_ROW;
      }
 else       if (ret >= 1) {
        return MatchCode.DONE;
      }
    }
  }
 else {
    return MatchCode.DONE;
  }
  if (this.stickyNextRow) {
    return MatchCode.SEEK_NEXT_ROW;
  }
  if (this.columns.done()) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  long timestamp=cell.getTimestamp();
  if (columns.isDone(timestamp)) {
    return columns.getNextRowOrNextColumn(cell);
  }
  if (HStore.isCellTTLExpired(cell,this.oldestUnexpiredTS,this.now)) {
    return MatchCode.SKIP;
  }
  byte typeByte=cell.getTypeByte();
  long mvccVersion=cell.getSequenceId();
  if (CellUtil.isDelete(cell)) {
    if (keepDeletedCells == KeepDeletedCells.FALSE || (keepDeletedCells == KeepDeletedCells.TTL && timestamp < ttl)) {
      boolean includeDeleteMarker=seePastDeleteMarkers ? tr.withinTimeRange(timestamp) : tr.withinOrAfterTimeRange(timestamp);
      if (includeDeleteMarker && mvccVersion <= maxReadPointToTrackVersions) {
        this.deletes.add(cell);
      }
    }
    if ((!isUserScan) && timeToPurgeDeletes > 0 && (EnvironmentEdgeManager.currentTime() - timestamp) <= timeToPurgeDeletes) {
      return MatchCode.INCLUDE;
    }
 else     if (retainDeletesInOutput || mvccVersion > maxReadPointToTrackVersions) {
      if (!isUserScan) {
        return MatchCode.INCLUDE;
      }
    }
 else     if (keepDeletedCells == KeepDeletedCells.TRUE || (keepDeletedCells == KeepDeletedCells.TTL && timestamp >= ttl)) {
      if (timestamp < earliestPutTs) {
        return columns.getNextRowOrNextColumn(cell);
      }
    }
 else {
      return MatchCode.SKIP;
    }
  }
 else   if (!this.deletes.isEmpty()) {
    DeleteResult deleteResult=deletes.isDeleted(cell);
switch (deleteResult) {
case FAMILY_DELETED:
case COLUMN_DELETED:
      return columns.getNextRowOrNextColumn(cell);
case VERSION_DELETED:
case FAMILY_VERSION_DELETED:
    return MatchCode.SKIP;
case NOT_DELETED:
  break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}
int timestampComparison=tr.compare(timestamp);
if (timestampComparison >= 1) {
return MatchCode.SKIP;
}
 else if (timestampComparison <= -1) {
return columns.getNextRowOrNextColumn(cell);
}
MatchCode colChecker=columns.checkColumn(cell,typeByte);
if (colChecker == MatchCode.INCLUDE) {
ReturnCode filterResponse=ReturnCode.SKIP;
if (filter != null) {
filterResponse=filter.filterKeyValue(cell);
switch (filterResponse) {
case SKIP:
return MatchCode.SKIP;
case NEXT_COL:
return columns.getNextRowOrNextColumn(cell);
case NEXT_ROW:
stickyNextRow=true;
return MatchCode.SEEK_NEXT_ROW;
case SEEK_NEXT_USING_HINT:
return MatchCode.SEEK_NEXT_USING_HINT;
default :
break;
}
}
colChecker=columns.checkVersions(cell,timestamp,typeByte,mvccVersion > maxReadPointToTrackVersions);
boolean seekNextRowFromEssential=filterResponse == ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW && filter.isFamilyEssential(cell.getFamilyArray());
if (colChecker == MatchCode.INCLUDE_AND_SEEK_NEXT_ROW || seekNextRowFromEssential) {
stickyNextRow=true;
}
if (filterResponse == ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW) {
if (colChecker != MatchCode.SKIP) {
return MatchCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
return MatchCode.SEEK_NEXT_ROW;
}
return (filterResponse == ReturnCode.INCLUDE_AND_NEXT_COL && colChecker == MatchCode.INCLUDE) ? MatchCode.INCLUDE_AND_SEEK_NEXT_COL : colChecker;
}
stickyNextRow=(colChecker == MatchCode.SEEK_NEXT_ROW) ? true : stickyNextRow;
return colChecker;
}","/** 
 * Determines if the caller should do one of several things: - seek/skip to the next row (MatchCode.SEEK_NEXT_ROW) - seek/skip to the next column (MatchCode.SEEK_NEXT_COL) - include the current KeyValue (MatchCode.INCLUDE) - ignore the current KeyValue (MatchCode.SKIP) - got to the next row (MatchCode.DONE)
 * @param cell KeyValue to check
 * @return The match code instance.
 * @throws IOException in case there is an internal consistency problemcaused by a data corruption.
 */
public MatchCode match(Cell cell) throws IOException {
  if (filter != null && filter.filterAllRemaining()) {
    return MatchCode.DONE_SCAN;
  }
  if (curCell != null) {
    int ret=this.rowComparator.compareRows(curCell,cell);
    if (!this.isReversed) {
      if (ret <= -1) {
        return MatchCode.DONE;
      }
 else       if (ret >= 1) {
        return MatchCode.SEEK_NEXT_ROW;
      }
    }
 else {
      if (ret <= -1) {
        return MatchCode.SEEK_NEXT_ROW;
      }
 else       if (ret >= 1) {
        return MatchCode.DONE;
      }
    }
  }
 else {
    return MatchCode.DONE;
  }
  if (this.stickyNextRow) {
    return MatchCode.SEEK_NEXT_ROW;
  }
  if (this.columns.done()) {
    stickyNextRow=true;
    return MatchCode.SEEK_NEXT_ROW;
  }
  long timestamp=cell.getTimestamp();
  if (columns.isDone(timestamp)) {
    return columns.getNextRowOrNextColumn(cell);
  }
  if (HStore.isCellTTLExpired(cell,this.oldestUnexpiredTS,this.now)) {
    return MatchCode.SKIP;
  }
  byte typeByte=cell.getTypeByte();
  long mvccVersion=cell.getSequenceId();
  if (CellUtil.isDelete(cell)) {
    if (keepDeletedCells == KeepDeletedCells.FALSE || (keepDeletedCells == KeepDeletedCells.TTL && timestamp < ttl)) {
      boolean includeDeleteMarker=seePastDeleteMarkers ? tr.withinTimeRange(timestamp) : tr.withinOrAfterTimeRange(timestamp);
      if (includeDeleteMarker && mvccVersion <= maxReadPointToTrackVersions) {
        this.deletes.add(cell);
      }
    }
    if ((!isUserScan) && timeToPurgeDeletes > 0 && (EnvironmentEdgeManager.currentTime() - timestamp) <= timeToPurgeDeletes) {
      return MatchCode.INCLUDE;
    }
 else     if (retainDeletesInOutput || mvccVersion > maxReadPointToTrackVersions) {
      if (!isUserScan) {
        return MatchCode.INCLUDE;
      }
    }
 else     if (keepDeletedCells == KeepDeletedCells.TRUE || (keepDeletedCells == KeepDeletedCells.TTL && timestamp >= ttl)) {
      if (timestamp < earliestPutTs) {
        return columns.getNextRowOrNextColumn(cell);
      }
    }
 else {
      return MatchCode.SKIP;
    }
  }
 else   if (!this.deletes.isEmpty()) {
    DeleteResult deleteResult=deletes.isDeleted(cell);
switch (deleteResult) {
case FAMILY_DELETED:
case COLUMN_DELETED:
      return columns.getNextRowOrNextColumn(cell);
case VERSION_DELETED:
case FAMILY_VERSION_DELETED:
    return MatchCode.SKIP;
case NOT_DELETED:
  break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}
int timestampComparison=timestamp == HConstants.OLDEST_TIMESTAMP ? -1 : tr.compare(timestamp);
if (timestampComparison >= 1) {
return MatchCode.SKIP;
}
 else if (timestampComparison <= -1) {
return columns.getNextRowOrNextColumn(cell);
}
MatchCode colChecker=columns.checkColumn(cell,typeByte);
if (colChecker == MatchCode.INCLUDE) {
ReturnCode filterResponse=ReturnCode.SKIP;
if (filter != null) {
filterResponse=filter.filterKeyValue(cell);
switch (filterResponse) {
case SKIP:
return MatchCode.SKIP;
case NEXT_COL:
return columns.getNextRowOrNextColumn(cell);
case NEXT_ROW:
stickyNextRow=true;
return MatchCode.SEEK_NEXT_ROW;
case SEEK_NEXT_USING_HINT:
return MatchCode.SEEK_NEXT_USING_HINT;
default :
break;
}
}
colChecker=columns.checkVersions(cell,timestamp,typeByte,mvccVersion > maxReadPointToTrackVersions);
boolean seekNextRowFromEssential=filterResponse == ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW && filter.isFamilyEssential(cell.getFamilyArray());
if (colChecker == MatchCode.INCLUDE_AND_SEEK_NEXT_ROW || seekNextRowFromEssential) {
stickyNextRow=true;
}
if (filterResponse == ReturnCode.INCLUDE_AND_SEEK_NEXT_ROW) {
if (colChecker != MatchCode.SKIP) {
return MatchCode.INCLUDE_AND_SEEK_NEXT_ROW;
}
return MatchCode.SEEK_NEXT_ROW;
}
return (filterResponse == ReturnCode.INCLUDE_AND_NEXT_COL && colChecker == MatchCode.INCLUDE) ? MatchCode.INCLUDE_AND_SEEK_NEXT_COL : colChecker;
}
stickyNextRow=(colChecker == MatchCode.SEEK_NEXT_ROW) ? true : stickyNextRow;
return colChecker;
}",0.9945392491467576
61115,"/** 
 * @param maxKeyCount
 * @param compression Compression algorithm to use
 * @param isCompaction whether we are creating a new file in a compaction
 * @param includeMVCCReadpoint whether we should out the MVCC readpoint
 * @param shouldDropBehind should the writer drop caches behind writes
 * @return Writer for a new StoreFile in the tmp dir.
 */
StoreFileWriter createWriterInTmp(long maxKeyCount,Compression.Algorithm compression,boolean isCompaction,boolean includeMVCCReadpoint,boolean includesTags,boolean shouldDropBehind) throws IOException ;","/** 
 * @param maxKeyCount
 * @param compression Compression algorithm to use
 * @param isCompaction whether we are creating a new file in a compaction
 * @param includeMVCCReadpoint whether we should out the MVCC readpoint
 * @param shouldDropBehind should the writer drop caches behind writes
 * @param trt Ready-made timetracker to use.
 * @return Writer for a new StoreFile in the tmp dir.
 */
StoreFileWriter createWriterInTmp(long maxKeyCount,Compression.Algorithm compression,boolean isCompaction,boolean includeMVCCReadpoint,boolean includesTags,boolean shouldDropBehind,final TimeRangeTracker trt) throws IOException ;",0.9390862944162436
61116,"public long getMaxTimestamp(){
  return timeRange == null ? Long.MAX_VALUE : timeRange.getMax();
}","public long getMaxTimestamp(){
  return timeRange == null ? TimeRange.INITIAL_MAX_TIMESTAMP : timeRange.getMax();
}",0.863849765258216
61117,"/** 
 * Perform normalization of cluster (invoked by   {@link RegionNormalizerChore}).
 * @return true if normalization step was performed successfully, false otherwise(specifically, if HMaster hasn't been initialized properly or normalization is globally disabled)
 */
public boolean normalizeRegions() throws IOException {
  if (!isInitialized()) {
    LOG.debug(""String_Node_Str"");
    return false;
  }
  if (!this.regionNormalizerTracker.isNormalizerOn()) {
    LOG.debug(""String_Node_Str"");
    return false;
  }
synchronized (this.normalizer) {
    List<TableName> allEnabledTables=new ArrayList<>(this.tableStateManager.getTablesInStates(TableState.State.ENABLED));
    Collections.shuffle(allEnabledTables);
    for (    TableName table : allEnabledTables) {
      HTableDescriptor tblDesc=getTableDescriptors().get(table);
      if (table.isSystemTable() || (tblDesc != null && tblDesc != null && !tblDesc.isNormalizationEnabled())) {
        LOG.debug(""String_Node_Str"" + table + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      List<NormalizationPlan> plans=this.normalizer.computePlanForTable(table);
      if (plans != null) {
        for (        NormalizationPlan plan : plans) {
          plan.execute(clusterConnection.getAdmin());
          if (plan.getType() == PlanType.SPLIT) {
            splitPlanCount++;
          }
 else           if (plan.getType() == PlanType.MERGE) {
            mergePlanCount++;
          }
        }
      }
    }
  }
  return true;
}","/** 
 * Perform normalization of cluster (invoked by   {@link RegionNormalizerChore}).
 * @return true if normalization step was performed successfully, false otherwise(specifically, if HMaster hasn't been initialized properly or normalization is globally disabled)
 */
public boolean normalizeRegions() throws IOException {
  if (!isInitialized()) {
    LOG.debug(""String_Node_Str"");
    return false;
  }
  if (!this.regionNormalizerTracker.isNormalizerOn()) {
    LOG.debug(""String_Node_Str"");
    return false;
  }
synchronized (this.normalizer) {
    List<TableName> allEnabledTables=new ArrayList<>(this.tableStateManager.getTablesInStates(TableState.State.ENABLED));
    Collections.shuffle(allEnabledTables);
    for (    TableName table : allEnabledTables) {
      HTableDescriptor tblDesc=getTableDescriptors().get(table);
      if (table.isSystemTable() || (tblDesc != null && !tblDesc.isNormalizationEnabled())) {
        LOG.debug(""String_Node_Str"" + table + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      List<NormalizationPlan> plans=this.normalizer.computePlanForTable(table);
      if (plans != null) {
        for (        NormalizationPlan plan : plans) {
          plan.execute(clusterConnection.getAdmin());
          if (plan.getType() == PlanType.SPLIT) {
            splitPlanCount++;
          }
 else           if (plan.getType() == PlanType.MERGE) {
            mergePlanCount++;
          }
        }
      }
    }
  }
  return true;
}",0.9936518543267624
61118,"@Override protected void encode(ChannelHandlerContext channelHandlerContext,ClusterStatus clusterStatus,List<Object> objects){
  ClusterStatusProtos.ClusterStatus csp=clusterStatus.convert();
  objects.add(new DatagramPacket(Unpooled.wrappedBuffer(csp.toByteArray()),isa));
}","@Override protected void encode(ChannelHandlerContext channelHandlerContext,ClusterStatus clusterStatus,List<Object> objects){
  ClusterStatusProtos.ClusterStatus csp=ProtobufUtil.convert(clusterStatus);
  objects.add(new DatagramPacket(Unpooled.wrappedBuffer(csp.toByteArray()),isa));
}",0.9323843416370108
61119,"/** 
 * Verifies that one can't modify instance of EMPTY_RESULT.
 */
public void testEmptyResultIsReadonly(){
  Result emptyResult=Result.EMPTY_RESULT;
  Result otherResult=new Result();
  try {
    emptyResult.copyFrom(otherResult);
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    LOG.debug(""String_Node_Str"" + ex.getMessage());
  }
  try {
    emptyResult.addResults(new RegionLoadStats(0,0,0));
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    LOG.debug(""String_Node_Str"" + ex.getMessage());
  }
  try {
    emptyResult.setExists(true);
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    LOG.debug(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Verifies that one can't modify instance of EMPTY_RESULT.
 */
public void testEmptyResultIsReadonly(){
  Result emptyResult=Result.EMPTY_RESULT;
  Result otherResult=new Result();
  try {
    emptyResult.copyFrom(otherResult);
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    LOG.debug(""String_Node_Str"" + ex.getMessage());
  }
  try {
    emptyResult.setExists(true);
    fail(""String_Node_Str"");
  }
 catch (  UnsupportedOperationException ex) {
    LOG.debug(""String_Node_Str"" + ex.getMessage());
  }
}",0.8241673121611154
61120,"/** 
 * @return True if we should send data in cellblocks.  This is an expensive call.  Cache theresult if you can rather than call each time.
 */
private boolean isCellBlock(){
  HConnection connection=getConnection();
  if (!(connection instanceof ClusterConnection))   return true;
  return ((ClusterConnection)connection).hasCellBlockSupport();
}","/** 
 * @return True if we should send data in cellblocks.  This is an expensive call.  Cache theresult if you can rather than call each time.
 */
private boolean isCellBlock(){
  ClusterConnection conn=getConnection();
  return conn.hasCellBlockSupport();
}",0.743421052631579
61121,"/** 
 * Find the size of compressed data assuming that buffer will be compressed using given algorithm.
 * @param algo compression algorithm
 * @param compressor compressor already requested from codec
 * @param inputBuffer Array to be compressed.
 * @param offset Offset to beginning of the data.
 * @param length Length to be compressed.
 * @return Size of compressed data in bytes.
 * @throws IOException
 */
public static int getCompressedSize(Algorithm algo,Compressor compressor,byte[] inputBuffer,int offset,int length) throws IOException {
  DataOutputStream compressedStream=new DataOutputStream(new IOUtils.NullOutputStream());
  if (compressor != null) {
    compressor.reset();
  }
  OutputStream compressingStream=null;
  try {
    compressingStream=algo.createCompressionStream(compressedStream,compressor,0);
    compressingStream.write(inputBuffer,offset,length);
    compressingStream.flush();
    return compressedStream.size();
  }
  finally {
    if (compressingStream != null)     compressingStream.close();
  }
}","/** 
 * Find the size of compressed data assuming that buffer will be compressed using given algorithm.
 * @param algo compression algorithm
 * @param compressor compressor already requested from codec
 * @param inputBuffer Array to be compressed.
 * @param offset Offset to beginning of the data.
 * @param length Length to be compressed.
 * @return Size of compressed data in bytes.
 * @throws IOException
 */
public static int getCompressedSize(Algorithm algo,Compressor compressor,byte[] inputBuffer,int offset,int length) throws IOException {
  final IOUtils.NullOutputStream nullOutputStream=new IOUtils.NullOutputStream();
  final DataOutputStream compressedStream=new DataOutputStream(nullOutputStream);
  OutputStream compressingStream=null;
  try {
    if (compressor != null) {
      compressor.reset();
    }
    compressingStream=algo.createCompressionStream(compressedStream,compressor,0);
    compressingStream.write(inputBuffer,offset,length);
    compressingStream.flush();
    return compressedStream.size();
  }
  finally {
    nullOutputStream.close();
    compressedStream.close();
    if (compressingStream != null)     compressingStream.close();
  }
}",0.8677536231884058
61122,"/** 
 * Convenience method for reading a binary file and base64-encoding it.
 * @param filename Filename for reading binary data
 * @return base64-encoded string or null if unsuccessful
 * @since 2.1
 */
public static String encodeFromFile(String filename){
  String encodedData=null;
  Base64InputStream bis=null;
  try {
    File file=new File(filename);
    byte[] buffer=new byte[Math.max((int)(file.length() * 1.4),40)];
    bis=new Base64InputStream(new BufferedInputStream(new FileInputStream(file)),ENCODE);
    int length=0;
    for (int numBytes; (numBytes=bis.read(buffer,length,4096)) >= 0; ) {
      length+=numBytes;
    }
    encodedData=new String(buffer,0,length,PREFERRED_ENCODING);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + filename,e);
  }
 finally {
    if (bis != null) {
      try {
        bis.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  return encodedData;
}","/** 
 * Convenience method for reading a binary file and base64-encoding it.
 * @param filename Filename for reading binary data
 * @return base64-encoded string or null if unsuccessful
 * @since 2.1
 */
public static String encodeFromFile(String filename){
  String encodedData=null;
  FileInputStream fileInputStream=null;
  BufferedInputStream bufferedInputStream=null;
  Base64InputStream base64InputStream=null;
  try {
    File file=new File(filename);
    byte[] buffer=new byte[Math.max((int)(file.length() * 1.4),40)];
    fileInputStream=new FileInputStream(file);
    bufferedInputStream=new BufferedInputStream(fileInputStream);
    base64InputStream=new Base64InputStream(bufferedInputStream,ENCODE);
    int length=0;
    for (int numBytes; (numBytes=base64InputStream.read(buffer,length,4096)) >= 0; ) {
      length+=numBytes;
    }
    encodedData=new String(buffer,0,length,PREFERRED_ENCODING);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + filename,e);
  }
 finally {
    if (fileInputStream != null) {
      try {
        fileInputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    if (bufferedInputStream != null) {
      try {
        bufferedInputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    if (base64InputStream != null) {
      try {
        base64InputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  return encodedData;
}",0.7197149643705463
61123,"/** 
 * Convenience method for reading a base64-encoded file and decoding it.
 * @param filename Filename for reading encoded data
 * @return decoded byte array or null if unsuccessful
 * @since 2.1
 */
public static byte[] decodeFromFile(String filename){
  byte[] decodedData=null;
  Base64InputStream bis=null;
  try {
    File file=new File(filename);
    byte[] buffer;
    if (file.length() > Integer.MAX_VALUE) {
      LOG.fatal(""String_Node_Str"" + file.length() + ""String_Node_Str"");
      return null;
    }
    buffer=new byte[(int)file.length()];
    bis=new Base64InputStream(new BufferedInputStream(new FileInputStream(file)),DECODE);
    int length=0;
    for (int numBytes; (numBytes=bis.read(buffer,length,4096)) >= 0; ) {
      length+=numBytes;
    }
    decodedData=new byte[length];
    System.arraycopy(buffer,0,decodedData,0,length);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + filename,e);
  }
 finally {
    if (bis != null) {
      try {
        bis.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  return decodedData;
}","/** 
 * Convenience method for reading a base64-encoded file and decoding it.
 * @param filename Filename for reading encoded data
 * @return decoded byte array or null if unsuccessful
 * @since 2.1
 */
public static byte[] decodeFromFile(String filename){
  byte[] decodedData=null;
  BufferedInputStream bufferedInputStream=null;
  FileInputStream fileInputStream=null;
  Base64InputStream base64InputStream=null;
  try {
    File file=new File(filename);
    byte[] buffer;
    if (file.length() > Integer.MAX_VALUE) {
      LOG.fatal(""String_Node_Str"" + file.length() + ""String_Node_Str"");
      return null;
    }
    buffer=new byte[(int)file.length()];
    fileInputStream=new FileInputStream(file);
    bufferedInputStream=new BufferedInputStream(fileInputStream);
    base64InputStream=new Base64InputStream(bufferedInputStream,DECODE);
    int length=0;
    for (int numBytes; (numBytes=base64InputStream.read(buffer,length,4096)) >= 0; ) {
      length+=numBytes;
    }
    decodedData=new byte[length];
    System.arraycopy(buffer,0,decodedData,0,length);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"" + filename,e);
  }
 finally {
    if (fileInputStream != null) {
      try {
        fileInputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    if (bufferedInputStream != null) {
      try {
        bufferedInputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    if (base64InputStream != null) {
      try {
        base64InputStream.close();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  return decodedData;
}",0.7503526093088858
61124,"/** 
 * Determines if we are running in a 32-bit JVM. Some unit tests need to know this too.
 */
public static boolean is32BitJVM(){
  return System.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
}","/** 
 * Determines if we are running in a 32-bit JVM. Some unit tests need to know this too.
 */
public static boolean is32BitJVM(){
  final String model=System.getProperty(""String_Node_Str"");
  return model != null && model.equals(""String_Node_Str"");
}",0.8720173535791758
61125,"private synchronized void loadNewJars(){
  for (  File file : localDir.listFiles()) {
    String fileName=file.getName();
    if (jarModifiedTime.containsKey(fileName)) {
      continue;
    }
    if (file.isFile() && fileName.endsWith(""String_Node_Str"")) {
      jarModifiedTime.put(fileName,Long.valueOf(file.lastModified()));
      try {
        URL url=file.toURI().toURL();
        addURL(url);
      }
 catch (      MalformedURLException mue) {
        LOG.warn(""String_Node_Str"" + fileName,mue);
      }
    }
  }
  FileStatus[] statuses=null;
  if (remoteDir != null) {
    try {
      statuses=remoteDirFs.listStatus(remoteDir);
    }
 catch (    IOException ioe) {
      LOG.warn(""String_Node_Str"" + remoteDir,ioe);
    }
  }
  if (statuses == null || statuses.length == 0) {
    return;
  }
  for (  FileStatus status : statuses) {
    if (status.isDirectory())     continue;
    Path path=status.getPath();
    String fileName=path.getName();
    if (!fileName.endsWith(""String_Node_Str"")) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + fileName);
      }
      continue;
    }
    Long cachedLastModificationTime=jarModifiedTime.get(fileName);
    if (cachedLastModificationTime != null) {
      long lastModified=status.getModificationTime();
      if (lastModified < cachedLastModificationTime.longValue()) {
        continue;
      }
    }
    try {
      File dst=new File(localDir,fileName);
      remoteDirFs.copyToLocalFile(path,new Path(dst.getPath()));
      jarModifiedTime.put(fileName,Long.valueOf(dst.lastModified()));
      URL url=dst.toURI().toURL();
      addURL(url);
    }
 catch (    IOException ioe) {
      LOG.warn(""String_Node_Str"" + fileName,ioe);
    }
  }
}","private synchronized void loadNewJars(){
  if (localDir != null) {
    for (    File file : localDir.listFiles()) {
      String fileName=file.getName();
      if (jarModifiedTime.containsKey(fileName)) {
        continue;
      }
      if (file.isFile() && fileName.endsWith(""String_Node_Str"")) {
        jarModifiedTime.put(fileName,Long.valueOf(file.lastModified()));
        try {
          URL url=file.toURI().toURL();
          addURL(url);
        }
 catch (        MalformedURLException mue) {
          LOG.warn(""String_Node_Str"" + fileName,mue);
        }
      }
    }
  }
  FileStatus[] statuses=null;
  if (remoteDir != null) {
    try {
      statuses=remoteDirFs.listStatus(remoteDir);
    }
 catch (    IOException ioe) {
      LOG.warn(""String_Node_Str"" + remoteDir,ioe);
    }
  }
  if (statuses == null || statuses.length == 0) {
    return;
  }
  for (  FileStatus status : statuses) {
    if (status.isDirectory())     continue;
    Path path=status.getPath();
    String fileName=path.getName();
    if (!fileName.endsWith(""String_Node_Str"")) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + fileName);
      }
      continue;
    }
    Long cachedLastModificationTime=jarModifiedTime.get(fileName);
    if (cachedLastModificationTime != null) {
      long lastModified=status.getModificationTime();
      if (lastModified < cachedLastModificationTime.longValue()) {
        continue;
      }
    }
    try {
      File dst=new File(localDir,fileName);
      remoteDirFs.copyToLocalFile(path,new Path(dst.getPath()));
      jarModifiedTime.put(fileName,Long.valueOf(dst.lastModified()));
      URL url=dst.toURI().toURL();
      addURL(url);
    }
 catch (    IOException ioe) {
      LOG.warn(""String_Node_Str"" + fileName,ioe);
    }
  }
}",0.973234624145786
61126,"/** 
 * Removes all store files with max timestamp older than (current - maxAge).
 * @param storeFiles all store files to consider
 * @param maxAge the age in milliseconds when a store file stops participating in compaction.
 * @param now current time. store files with max timestamp less than (now - maxAge) are filtered.
 * @return a list of storeFiles with the store file older than maxAge excluded
 */
private static Iterable<StoreFile> filterOldStoreFiles(List<StoreFile> storeFiles,long maxAge,long now){
  if (maxAge == 0) {
    return ImmutableList.of();
  }
  final long cutoff=now - maxAge;
  return Iterables.filter(storeFiles,new Predicate<StoreFile>(){
    @Override public boolean apply(    StoreFile storeFile){
      if (storeFile == null) {
        throw new NullPointerException();
      }
      return storeFile.getMaximumTimestamp() >= cutoff;
    }
  }
);
}","/** 
 * Removes all store files with max timestamp older than (current - maxAge).
 * @param storeFiles all store files to consider
 * @param maxAge the age in milliseconds when a store file stops participating in compaction.
 * @param now current time. store files with max timestamp less than (now - maxAge) are filtered.
 * @return a list of storeFiles with the store file older than maxAge excluded
 */
private static Iterable<StoreFile> filterOldStoreFiles(List<StoreFile> storeFiles,long maxAge,long now){
  if (maxAge == 0) {
    return ImmutableList.of();
  }
  final long cutoff=now - maxAge;
  return Iterables.filter(storeFiles,new Predicate<StoreFile>(){
    @Override public boolean apply(    StoreFile storeFile){
      if (storeFile == null) {
        return false;
      }
      return storeFile.getMaximumTimestamp() >= cutoff;
    }
  }
);
}",0.9746543778801844
61127,"/** 
 * Input candidates are sorted from oldest to newest by seqId. Could return null if no candidates are found.
 */
@VisibleForTesting public ArrayList<StoreFile> applyCompactionPolicy(ArrayList<StoreFile> candidates,boolean mayUseOffPeak,boolean mayBeStuck,long now) throws IOException {
  Iterable<StoreFile> candidatesInWindow=filterOldStoreFiles(Lists.newArrayList(candidates),comConf.getMaxStoreFileAgeMillis(),now);
  List<ArrayList<StoreFile>> buckets=partitionFilesToBuckets(candidatesInWindow,comConf.getBaseWindowMillis(),comConf.getWindowsPerTier(),now);
  LOG.debug(""String_Node_Str"" + buckets);
  return newestBucket(buckets,comConf.getIncomingWindowMin(),now,comConf.getBaseWindowMillis(),mayUseOffPeak);
}","/** 
 * Input candidates are sorted from oldest to newest by seqId. Could return null if no candidates are found.
 */
@VisibleForTesting public ArrayList<StoreFile> applyCompactionPolicy(ArrayList<StoreFile> candidates,boolean mayUseOffPeak,boolean mayBeStuck,long now) throws IOException {
  Iterable<StoreFile> candidatesInWindow=filterOldStoreFiles(Lists.newArrayList(candidates),comConf.getMaxStoreFileAgeMillis(),now);
  List<ArrayList<StoreFile>> buckets=partitionFilesToBuckets(candidatesInWindow,comConf.getBaseWindowMillis(),comConf.getWindowsPerTier(),now);
  LOG.debug(""String_Node_Str"" + buckets);
  if (buckets.size() >= storeConfigInfo.getBlockingFileCount()) {
    LOG.warn(""String_Node_Str"" + buckets.size() + ""String_Node_Str""+ storeConfigInfo.getBlockingFileCount()+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  return newestBucket(buckets,comConf.getIncomingWindowMin(),now,comConf.getBaseWindowMillis(),mayUseOffPeak);
}",0.8688327316486161
61128,"@Override public boolean apply(StoreFile storeFile){
  if (storeFile == null) {
    throw new NullPointerException();
  }
  return storeFile.getMaximumTimestamp() >= cutoff;
}","@Override public boolean apply(StoreFile storeFile){
  if (storeFile == null) {
    return false;
  }
  return storeFile.getMaximumTimestamp() >= cutoff;
}",0.8909090909090909
61129,"@Test public void testAssignmentManagerTruncatedList() throws IOException {
  AssignmentManager am=Mockito.mock(AssignmentManager.class);
  RegionStates rs=Mockito.mock(RegionStates.class);
  NavigableMap<String,RegionState> regionsInTransition=Maps.newTreeMap();
  for (byte i=0; i < 100; i++) {
    HRegionInfo hri=new HRegionInfo(FAKE_TABLE.getTableName(),new byte[]{i},new byte[]{(byte)(i + 1)});
    regionsInTransition.put(hri.getEncodedName(),new RegionState(hri,RegionState.State.CLOSING,12345L,FAKE_HOST));
  }
  regionsInTransition.put(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName(),new RegionState(HRegionInfo.FIRST_META_REGIONINFO,RegionState.State.CLOSING,12345L,FAKE_HOST));
  Mockito.doReturn(rs).when(am).getRegionStates();
  Mockito.doReturn(regionsInTransition).when(rs).getRegionsInTransition();
  StringWriter sw=new StringWriter();
  new AssignmentManagerStatusTmpl().setLimit(50).render(sw,am);
  String result=sw.toString();
  assertTrue(result.contains(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName()));
  Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(result);
  int count=0;
  while (matcher.find()) {
    count++;
  }
  assertEquals(50,count);
}","@Test public void testAssignmentManagerTruncatedList() throws IOException {
  AssignmentManager am=Mockito.mock(AssignmentManager.class);
  RegionStates rs=Mockito.mock(RegionStates.class);
  NavigableMap<String,RegionState> regionsInTransition=Maps.newTreeMap();
  for (byte i=0; i < 100; i++) {
    HRegionInfo hri=new HRegionInfo(FAKE_TABLE.getTableName(),new byte[]{i},new byte[]{(byte)(i + 1)});
    regionsInTransition.put(hri.getEncodedName(),new RegionState(hri,RegionState.State.CLOSING,12345L,FAKE_HOST));
  }
  regionsInTransition.put(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName(),new RegionState(HRegionInfo.FIRST_META_REGIONINFO,RegionState.State.CLOSING,12345L,FAKE_HOST));
  Mockito.doReturn(rs).when(am).getRegionStates();
  Mockito.doReturn(regionsInTransition).when(rs).getRegionsInTransition();
  Mockito.doReturn(regionsInTransition).when(rs).getRegionsInTransitionOrderedByTimestamp();
  StringWriter sw=new StringWriter();
  new AssignmentManagerStatusTmpl().render(sw,am);
  String result=sw.toString();
  assertTrue(result.contains(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName()));
}",0.8868660598179454
61130,"/** 
 * Builds a scan object with the same specs as get.
 * @param get get to model scan after
 */
public Scan(Get get){
  this.startRow=get.getRow();
  this.stopRow=get.getRow();
  this.filter=get.getFilter();
  this.cacheBlocks=get.getCacheBlocks();
  this.maxVersions=get.getMaxVersions();
  this.storeLimit=get.getMaxResultsPerColumnFamily();
  this.storeOffset=get.getRowOffsetPerColumnFamily();
  this.tr=get.getTimeRange();
  this.familyMap=get.getFamilyMap();
  this.getScan=true;
  this.asyncPrefetch=false;
  this.consistency=get.getConsistency();
  for (  Map.Entry<String,byte[]> attr : get.getAttributesMap().entrySet()) {
    setAttribute(attr.getKey(),attr.getValue());
  }
  for (  Map.Entry<byte[],TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {
    TimeRange tr=entry.getValue();
    setColumnFamilyTimeRange(entry.getKey(),tr.getMin(),tr.getMax());
  }
}","/** 
 * Builds a scan object with the same specs as get.
 * @param get get to model scan after
 */
public Scan(Get get){
  this.startRow=get.getRow();
  this.stopRow=get.getRow();
  this.filter=get.getFilter();
  this.cacheBlocks=get.getCacheBlocks();
  this.maxVersions=get.getMaxVersions();
  this.storeLimit=get.getMaxResultsPerColumnFamily();
  this.storeOffset=get.getRowOffsetPerColumnFamily();
  this.tr=get.getTimeRange();
  this.familyMap=get.getFamilyMap();
  this.getScan=true;
  this.asyncPrefetch=false;
  this.consistency=get.getConsistency();
  this.setIsolationLevel(get.getIsolationLevel());
  for (  Map.Entry<String,byte[]> attr : get.getAttributesMap().entrySet()) {
    setAttribute(attr.getKey(),attr.getValue());
  }
  for (  Map.Entry<byte[],TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {
    TimeRange tr=entry.getValue();
    setColumnFamilyTimeRange(entry.getKey(),tr.getMin(),tr.getMax());
  }
}",0.9721159103335156
61131,"/** 
 * Util method to iterate through the tags in the given cell.
 * @param cell The Cell over which tags iterator is needed.
 * @return iterator for the tags
 */
public static Iterator<Tag> tagsIterator(final Cell cell){
  final int tagsLength=cell.getTagsLength();
  if (tagsLength == 0) {
    return EMPTY_TAGS_ITR;
  }
  if (cell instanceof ByteBufferedCell) {
    return tagsIterator(((ByteBufferedCell)cell).getTagsByteBuffer(),((ByteBufferedCell)cell).getTagsPosition(),tagsLength);
  }
  return tagsIterator(cell.getTagsArray(),cell.getTagsOffset(),tagsLength);
}","/** 
 * Util method to iterate through the tags in the given cell.
 * @param cell The Cell over which tags iterator is needed.
 * @return iterator for the tags
 */
public static Iterator<Tag> tagsIterator(final Cell cell){
  final int tagsLength=cell.getTagsLength();
  if (tagsLength == 0) {
    return TagUtil.EMPTY_TAGS_ITR;
  }
  if (cell instanceof ByteBufferedCell) {
    return tagsIterator(((ByteBufferedCell)cell).getTagsByteBuffer(),((ByteBufferedCell)cell).getTagsPosition(),tagsLength);
  }
  return tagsIterator(cell.getTagsArray(),cell.getTagsOffset(),tagsLength);
}",0.9930555555555556
61132,"/** 
 * Write a list of tags into a byte array
 * @param tags The list of tags
 * @return the serialized tag data as bytes
 */
public static byte[] fromList(List<Tag> tags){
  if (tags.isEmpty()) {
    return HConstants.EMPTY_BYTE_ARRAY;
  }
  int length=0;
  for (  Tag tag : tags) {
    length+=tag.getValueLength() + Tag.INFRASTRUCTURE_SIZE;
  }
  byte[] b=new byte[length];
  int pos=0;
  int tlen;
  for (  Tag tag : tags) {
    tlen=tag.getValueLength();
    pos=Bytes.putAsShort(b,pos,tlen + Tag.TYPE_LENGTH_SIZE);
    pos=Bytes.putByte(b,pos,tag.getType());
    if (tag.hasArray()) {
      pos=Bytes.putBytes(b,pos,tag.getValueArray(),tag.getValueOffset(),tlen);
    }
 else {
      ByteBufferUtils.copyFromBufferToArray(b,tag.getValueByteBuffer(),tag.getValueOffset(),pos,tlen);
      pos+=tlen;
    }
  }
  return b;
}","/** 
 * Write a list of tags into a byte array
 * @param tags The list of tags
 * @return the serialized tag data as bytes
 */
public static byte[] fromList(List<Tag> tags){
  if (tags == null || tags.isEmpty()) {
    return HConstants.EMPTY_BYTE_ARRAY;
  }
  int length=0;
  for (  Tag tag : tags) {
    length+=tag.getValueLength() + Tag.INFRASTRUCTURE_SIZE;
  }
  byte[] b=new byte[length];
  int pos=0;
  int tlen;
  for (  Tag tag : tags) {
    tlen=tag.getValueLength();
    pos=Bytes.putAsShort(b,pos,tlen + Tag.TYPE_LENGTH_SIZE);
    pos=Bytes.putByte(b,pos,tag.getType());
    if (tag.hasArray()) {
      pos=Bytes.putBytes(b,pos,tag.getValueArray(),tag.getValueOffset(),tlen);
    }
 else {
      ByteBufferUtils.copyFromBufferToArray(b,tag.getValueByteBuffer(),tag.getValueOffset(),pos,tlen);
      pos+=tlen;
    }
  }
  return b;
}",0.9904306220095692
61133,"@Override public KeyValueScanner preStoreScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> c,final Store store,final Scan scan,final NavigableSet<byte[]> targetCols,final KeyValueScanner s) throws IOException {
  ScanInfo scanInfo=getScanInfo(store,c.getEnvironment());
  if (scanInfo == null) {
    return null;
  }
  return new StoreScanner(store,scanInfo,scan,targetCols,((HStore)store).getHRegion().getReadpoint(IsolationLevel.READ_COMMITTED));
}","@Override public KeyValueScanner preStoreScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> c,final Store store,final Scan scan,final NavigableSet<byte[]> targetCols,final KeyValueScanner s) throws IOException {
  ScanInfo scanInfo=getScanInfo(store,c.getEnvironment());
  if (scanInfo == null) {
    return null;
  }
  return new StoreScanner(store,scanInfo,scan,targetCols,((HStore)store).getHRegion().getReadPoint(IsolationLevel.READ_COMMITTED));
}",0.9978448275862069
61134,"@Override public int reseekTo(Cell key) throws IOException {
  int compared;
  if (isSeeked()) {
    compared=compareKey(reader.getComparator(),key);
    if (compared < 1) {
      return compared;
    }
 else {
      if (this.nextIndexedKey != null && (this.nextIndexedKey == HConstants.NO_NEXT_INDEXED_KEY || reader.getComparator().compareKeyIgnoresMvcc(key,nextIndexedKey) < 0)) {
        return loadBlockAndSeekToKey(this.curBlock,nextIndexedKey,false,key,false);
      }
    }
  }
  return seekTo(key,false);
}","@Override public int reseekTo(Cell key) throws IOException {
  int compared;
  if (isSeeked()) {
    compared=compareKey(reader.getComparator(),key);
    if (compared < 1) {
      return compared;
    }
 else {
      if (this.nextIndexedKey != null && (this.nextIndexedKey == KeyValueScanner.NO_NEXT_INDEXED_KEY || reader.getComparator().compareKeyIgnoresMvcc(key,nextIndexedKey) < 0)) {
        return loadBlockAndSeekToKey(this.curBlock,nextIndexedKey,false,key,false);
      }
    }
  }
  return seekTo(key,false);
}",0.9757986447241046
61135,"protected synchronized void close(){
  disposeSasl();
  data=null;
  if (!channel.isOpen())   return;
  try {
    socket.shutdownOutput();
  }
 catch (  Exception ignored) {
  }
  if (channel.isOpen()) {
    try {
      channel.close();
    }
 catch (    Exception ignored) {
    }
  }
  try {
    socket.close();
  }
 catch (  Exception ignored) {
  }
}","protected synchronized void close(){
  disposeSasl();
  data=null;
  if (!channel.isOpen())   return;
  try {
    socket.shutdownOutput();
  }
 catch (  Exception ignored) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"",ignored);
    }
  }
  if (channel.isOpen()) {
    try {
      channel.close();
    }
 catch (    Exception ignored) {
    }
  }
  try {
    socket.close();
  }
 catch (  Exception ignored) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"",ignored);
    }
  }
}",0.805045871559633
61136,"/** 
 * Maps the data.
 * @param row     The current table row key.
 * @param values  The columns.
 * @param context The current context.
 * @throws IOException When something is broken with the data.
 * @see org.apache.hadoop.mapreduce.Mapper#map(KEYIN,VALUEIN,org.apache.hadoop.mapreduce.Mapper.Context)
 */
@Override public void map(ImmutableBytesWritable row,Result values,Context context) throws IOException {
  Preconditions.checkState(values != null,""String_Node_Str"");
  String currentFamilyName=null;
  String currentQualifierName=null;
  String currentRowKey=null;
  Configuration config=context.getConfiguration();
  String separator=config.get(""String_Node_Str"",""String_Node_Str"");
  try {
    context.getCounter(Counters.ROWS).increment(1);
    context.write(new Text(""String_Node_Str""),new IntWritable(1));
    for (    Cell value : values.listCells()) {
      currentRowKey=Bytes.toStringBinary(CellUtil.cloneRow(value));
      String thisRowFamilyName=Bytes.toStringBinary(CellUtil.cloneFamily(value));
      if (!thisRowFamilyName.equals(currentFamilyName)) {
        currentFamilyName=thisRowFamilyName;
        context.getCounter(""String_Node_Str"",thisRowFamilyName).increment(1);
        if (1 == context.getCounter(""String_Node_Str"",thisRowFamilyName).getValue()) {
          context.write(new Text(""String_Node_Str""),new IntWritable(1));
          context.write(new Text(thisRowFamilyName),new IntWritable(1));
        }
      }
      String thisRowQualifierName=thisRowFamilyName + separator + Bytes.toStringBinary(CellUtil.cloneQualifier(value));
      if (!thisRowQualifierName.equals(currentQualifierName)) {
        currentQualifierName=thisRowQualifierName;
        context.getCounter(""String_Node_Str"",thisRowQualifierName).increment(1);
        context.write(new Text(""String_Node_Str""),new IntWritable(1));
        context.write(new Text(thisRowQualifierName),new IntWritable(1));
        context.getCounter(""String_Node_Str"",currentRowKey + separator + thisRowQualifierName).increment(1);
        context.write(new Text(currentRowKey + separator + thisRowQualifierName+ ""String_Node_Str""),new IntWritable(1));
      }
 else {
        currentQualifierName=thisRowQualifierName;
        context.getCounter(""String_Node_Str"",currentRowKey + separator + thisRowQualifierName).increment(1);
        context.write(new Text(currentRowKey + separator + thisRowQualifierName+ ""String_Node_Str""),new IntWritable(1));
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","/** 
 * Maps the data.
 * @param row     The current table row key.
 * @param values  The columns.
 * @param context The current context.
 * @throws IOException When something is broken with the data.
 * @see org.apache.hadoop.mapreduce.Mapper#map(KEYIN,VALUEIN,org.apache.hadoop.mapreduce.Mapper.Context)
 */
@Override public void map(ImmutableBytesWritable row,Result values,Context context) throws IOException {
  Preconditions.checkState(values != null,""String_Node_Str"");
  String currentFamilyName=null;
  String currentQualifierName=null;
  String currentRowKey=null;
  Configuration config=context.getConfiguration();
  String separator=config.get(""String_Node_Str"",""String_Node_Str"");
  try {
    context.getCounter(Counters.ROWS).increment(1);
    context.write(new Text(""String_Node_Str""),new IntWritable(1));
    if (values != null && !values.isEmpty()) {
      for (      Cell value : values.listCells()) {
        currentRowKey=Bytes.toStringBinary(CellUtil.cloneRow(value));
        String thisRowFamilyName=Bytes.toStringBinary(CellUtil.cloneFamily(value));
        if (!thisRowFamilyName.equals(currentFamilyName)) {
          currentFamilyName=thisRowFamilyName;
          context.getCounter(""String_Node_Str"",thisRowFamilyName).increment(1);
          if (1 == context.getCounter(""String_Node_Str"",thisRowFamilyName).getValue()) {
            context.write(new Text(""String_Node_Str""),new IntWritable(1));
            context.write(new Text(thisRowFamilyName),new IntWritable(1));
          }
        }
        String thisRowQualifierName=thisRowFamilyName + separator + Bytes.toStringBinary(CellUtil.cloneQualifier(value));
        if (!thisRowQualifierName.equals(currentQualifierName)) {
          currentQualifierName=thisRowQualifierName;
          context.getCounter(""String_Node_Str"",thisRowQualifierName).increment(1);
          context.write(new Text(""String_Node_Str""),new IntWritable(1));
          context.write(new Text(thisRowQualifierName),new IntWritable(1));
          context.getCounter(""String_Node_Str"",currentRowKey + separator + thisRowQualifierName).increment(1);
          context.write(new Text(currentRowKey + separator + thisRowQualifierName+ ""String_Node_Str""),new IntWritable(1));
        }
 else {
          currentQualifierName=thisRowQualifierName;
          context.getCounter(""String_Node_Str"",currentRowKey + separator + thisRowQualifierName).increment(1);
          context.write(new Text(currentRowKey + separator + thisRowQualifierName+ ""String_Node_Str""),new IntWritable(1));
        }
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9780625121335664
61137,"/** 
 * Processes list of regions in transition at startup
 */
void processRegionsInTransition(Collection<RegionState> regionsInTransition){
  for (  RegionState regionState : regionsInTransition) {
    LOG.info(""String_Node_Str"" + regionState);
    ServerName serverName=regionState.getServerName();
    if (serverName != null && !serverManager.getOnlineServers().containsKey(serverName)) {
      LOG.info(""String_Node_Str"" + serverName + ""String_Node_Str"");
      continue;
    }
    HRegionInfo regionInfo=regionState.getRegion();
    RegionState.State state=regionState.getState();
switch (state) {
case CLOSED:
      invokeAssign(regionState.getRegion());
    break;
case PENDING_OPEN:
  retrySendRegionOpen(regionState);
break;
case PENDING_CLOSE:
retrySendRegionClose(regionState);
break;
case FAILED_CLOSE:
case FAILED_OPEN:
invokeUnAssign(regionInfo);
break;
default :
}
}
}","/** 
 * Processes list of regions in transition at startup
 */
void processRegionsInTransition(Collection<RegionState> regionsInTransition){
  for (  RegionState regionState : regionsInTransition) {
    LOG.info(""String_Node_Str"" + regionState);
    ServerName serverName=regionState.getServerName();
    if (serverName != null && !serverManager.getOnlineServers().containsKey(serverName)) {
      LOG.info(""String_Node_Str"" + serverName + ""String_Node_Str"");
      continue;
    }
    HRegionInfo regionInfo=regionState.getRegion();
    RegionState.State state=regionState.getState();
switch (state) {
case CLOSED:
      invokeAssign(regionState.getRegion());
    break;
case PENDING_OPEN:
  retrySendRegionOpen(regionState);
break;
case PENDING_CLOSE:
retrySendRegionClose(regionState);
break;
case FAILED_CLOSE:
case FAILED_OPEN:
invokeUnAssign(regionInfo);
break;
default :
break;
}
}
}",0.9960518894529048
61138,"public void run(){
  zkLeader.start();
  zkLeader.waitToBecomeLeader();
  isMaster=true;
  while (!stopped) {
    long now=EnvironmentEdgeManager.currentTime();
    removeExpiredKeys();
    long localLastKeyUpdate;
synchronized (this) {
      localLastKeyUpdate=lastKeyUpdate;
    }
    if (localLastKeyUpdate + keyUpdateInterval < now) {
      rollCurrentKey();
    }
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ie) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",ie);
      }
    }
  }
}","public void run(){
  zkLeader.start();
  zkLeader.waitToBecomeLeader();
  isMaster=true;
  while (!stopped) {
    long now=EnvironmentEdgeManager.currentTime();
    removeExpiredKeys();
    long localLastKeyUpdate=getLastKeyUpdate();
    if (localLastKeyUpdate + keyUpdateInterval < now) {
      rollCurrentKey();
    }
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ie) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",ie);
      }
    }
  }
}",0.9393647738209816
61139,"public void startConnectorServer(int rmiRegistryPort,int rmiConnectorPort) throws IOException {
  boolean rmiSSL=false;
  boolean authenticate=true;
  String passwordFile=null;
  String accessFile=null;
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String rmiSSLValue=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  rmiSSL=Boolean.parseBoolean(rmiSSLValue);
  String authenticateValue=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  authenticate=Boolean.parseBoolean(authenticateValue);
  passwordFile=System.getProperty(""String_Node_Str"");
  accessFile=System.getProperty(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + rmiSSLValue + ""String_Node_Str""+ authenticateValue+ ""String_Node_Str""+ passwordFile+ ""String_Node_Str""+ accessFile);
  HashMap<String,Object> jmxEnv=new HashMap<String,Object>();
  RMIClientSocketFactory csf=null;
  RMIServerSocketFactory ssf=null;
  if (rmiSSL) {
    if (rmiRegistryPort == rmiConnectorPort) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
    }
    csf=new SslRMIClientSocketFactory();
    ssf=new SslRMIServerSocketFactory();
  }
  if (csf != null) {
    jmxEnv.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,csf);
  }
  if (ssf != null) {
    jmxEnv.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,ssf);
  }
  if (authenticate) {
    jmxEnv.put(""String_Node_Str"",passwordFile);
    jmxEnv.put(""String_Node_Str"",accessFile);
  }
  LocateRegistry.createRegistry(rmiRegistryPort);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  JMXServiceURL serviceUrl=buildJMXServiceURL(rmiRegistryPort,rmiConnectorPort);
  try {
    jmxCS=JMXConnectorServerFactory.newJMXConnectorServer(serviceUrl,jmxEnv,mbs);
    jmxCS.start();
    LOG.info(""String_Node_Str"");
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public void startConnectorServer(int rmiRegistryPort,int rmiConnectorPort) throws IOException {
  boolean rmiSSL=false;
  boolean authenticate=true;
  String passwordFile=null;
  String accessFile=null;
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String rmiSSLValue=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  rmiSSL=Boolean.parseBoolean(rmiSSLValue);
  String authenticateValue=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  authenticate=Boolean.parseBoolean(authenticateValue);
  passwordFile=System.getProperty(""String_Node_Str"");
  accessFile=System.getProperty(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + rmiSSLValue + ""String_Node_Str""+ authenticateValue+ ""String_Node_Str""+ passwordFile+ ""String_Node_Str""+ accessFile);
  HashMap<String,Object> jmxEnv=new HashMap<String,Object>();
  RMIClientSocketFactory csf=null;
  RMIServerSocketFactory ssf=null;
  if (rmiSSL) {
    if (rmiRegistryPort == rmiConnectorPort) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
    }
    csf=new SslRMIClientSocketFactory();
    ssf=new SslRMIServerSocketFactory();
  }
  if (csf != null) {
    jmxEnv.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,csf);
  }
  if (ssf != null) {
    jmxEnv.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,ssf);
  }
  if (authenticate) {
    jmxEnv.put(""String_Node_Str"",passwordFile);
    jmxEnv.put(""String_Node_Str"",accessFile);
  }
  LocateRegistry.createRegistry(rmiRegistryPort);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  JMXServiceURL serviceUrl=buildJMXServiceURL(rmiRegistryPort,rmiConnectorPort);
  try {
synchronized (JMXListener.class) {
      if (JMX_CS != null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      JMX_CS=JMXConnectorServerFactory.newJMXConnectorServer(serviceUrl,jmxEnv,mbs);
      JMX_CS.start();
    }
    LOG.info(""String_Node_Str"");
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.9596064215432418
61140,"public void stopConnectorServer() throws IOException {
synchronized (JMXListener.class) {
    if (jmxCS != null) {
      jmxCS.stop();
      LOG.info(""String_Node_Str"");
      jmxCS=null;
    }
  }
}","public void stopConnectorServer() throws IOException {
synchronized (JMXListener.class) {
    if (JMX_CS != null) {
      JMX_CS.stop();
      LOG.info(""String_Node_Str"");
      JMX_CS=null;
    }
  }
}",0.9476309226932668
61141,"@Override public void start(CoprocessorEnvironment env) throws IOException {
  int rmiRegistryPort=-1;
  int rmiConnectorPort=-1;
  Configuration conf=env.getConfiguration();
  if (env instanceof MasterCoprocessorEnvironment) {
    rmiRegistryPort=conf.getInt(""String_Node_Str"" + RMI_REGISTRY_PORT_CONF_KEY,defMasterRMIRegistryPort);
    rmiConnectorPort=conf.getInt(""String_Node_Str"" + RMI_CONNECTOR_PORT_CONF_KEY,rmiRegistryPort);
    LOG.info(""String_Node_Str"" + rmiRegistryPort + ""String_Node_Str""+ rmiConnectorPort);
  }
 else   if (env instanceof RegionServerCoprocessorEnvironment) {
    rmiRegistryPort=conf.getInt(""String_Node_Str"" + RMI_REGISTRY_PORT_CONF_KEY,defRegionserverRMIRegistryPort);
    rmiConnectorPort=conf.getInt(""String_Node_Str"" + RMI_CONNECTOR_PORT_CONF_KEY,rmiRegistryPort);
    LOG.info(""String_Node_Str"" + rmiRegistryPort + ""String_Node_Str""+ rmiConnectorPort);
  }
 else   if (env instanceof RegionCoprocessorEnvironment) {
    LOG.error(""String_Node_Str"");
    return;
  }
synchronized (JMXListener.class) {
    if (jmxCS != null) {
      LOG.info(""String_Node_Str"" + rmiRegistryPort);
    }
 else {
      startConnectorServer(rmiRegistryPort,rmiConnectorPort);
    }
  }
}","@Override public void start(CoprocessorEnvironment env) throws IOException {
  int rmiRegistryPort=-1;
  int rmiConnectorPort=-1;
  Configuration conf=env.getConfiguration();
  if (env instanceof MasterCoprocessorEnvironment) {
    rmiRegistryPort=conf.getInt(""String_Node_Str"" + RMI_REGISTRY_PORT_CONF_KEY,defMasterRMIRegistryPort);
    rmiConnectorPort=conf.getInt(""String_Node_Str"" + RMI_CONNECTOR_PORT_CONF_KEY,rmiRegistryPort);
    LOG.info(""String_Node_Str"" + rmiRegistryPort + ""String_Node_Str""+ rmiConnectorPort);
  }
 else   if (env instanceof RegionServerCoprocessorEnvironment) {
    rmiRegistryPort=conf.getInt(""String_Node_Str"" + RMI_REGISTRY_PORT_CONF_KEY,defRegionserverRMIRegistryPort);
    rmiConnectorPort=conf.getInt(""String_Node_Str"" + RMI_CONNECTOR_PORT_CONF_KEY,rmiRegistryPort);
    LOG.info(""String_Node_Str"" + rmiRegistryPort + ""String_Node_Str""+ rmiConnectorPort);
  }
 else   if (env instanceof RegionCoprocessorEnvironment) {
    LOG.error(""String_Node_Str"");
    return;
  }
synchronized (JMXListener.class) {
    if (JMX_CS != null) {
      LOG.info(""String_Node_Str"" + rmiRegistryPort);
    }
 else {
      startConnectorServer(rmiRegistryPort,rmiConnectorPort);
    }
  }
}",0.9970942299709424
61142,"/** 
 * It is possible for a task to stay in UNASSIGNED state indefinitely - say SplitLogManager wants to resubmit a task. It forces the task to UNASSIGNED state but it dies before it could create the RESCAN task node to signal the SplitLogWorkers to pick up the task. To prevent this scenario the SplitLogManager resubmits all orphan and UNASSIGNED tasks at startup.
 * @param path
 */
private void handleUnassignedTask(String path){
  if (ZKSplitLog.isRescanNode(watcher,path)) {
    return;
  }
  Task task=findOrCreateOrphanTask(path);
  if (task.isOrphan() && (task.incarnation == 0)) {
    LOG.info(""String_Node_Str"" + path);
    resubmitTask(path,task,FORCE);
  }
}","/** 
 * It is possible for a task to stay in UNASSIGNED state indefinitely - say SplitLogManager wants to resubmit a task. It forces the task to UNASSIGNED state but it dies before it could create the RESCAN task node to signal the SplitLogWorkers to pick up the task. To prevent this scenario the SplitLogManager resubmits all orphan and UNASSIGNED tasks at startup.
 * @param path
 */
private void handleUnassignedTask(String path){
  if (ZKSplitLog.isRescanNode(watcher,path)) {
    return;
  }
  Task task=findOrCreateOrphanTask(path);
  if (task.isOrphan() && (task.incarnation.get() == 0)) {
    LOG.info(""String_Node_Str"" + path);
    resubmitTask(path,task,FORCE);
  }
}",0.9955555555555556
61143,"@Override public boolean resubmitTask(String path,Task task,ResubmitDirective directive){
  if (task.status != IN_PROGRESS) {
    return false;
  }
  int version;
  if (directive != FORCE) {
    final long time=EnvironmentEdgeManager.currentTime() - task.last_update;
    final boolean alive=details.getMaster().getServerManager() != null ? details.getMaster().getServerManager().isServerOnline(task.cur_worker_name) : true;
    if (alive && time < timeout) {
      LOG.trace(""String_Node_Str"" + task.toString() + ""String_Node_Str""+ task.cur_worker_name+ ""String_Node_Str""+ time+ ""String_Node_Str""+ timeout);
      return false;
    }
    if (task.unforcedResubmits.get() >= resubmitThreshold) {
      if (!task.resubmitThresholdReached) {
        task.resubmitThresholdReached=true;
        SplitLogCounters.tot_mgr_resubmit_threshold_reached.incrementAndGet();
        LOG.info(""String_Node_Str"" + path + ""String_Node_Str""+ resubmitThreshold+ ""String_Node_Str"");
      }
      return false;
    }
    version=task.last_version;
  }
 else {
    SplitLogCounters.tot_mgr_resubmit_force.incrementAndGet();
    version=-1;
  }
  LOG.info(""String_Node_Str"" + path);
  task.incarnation++;
  boolean result=resubmit(this.details.getServerName(),path,version);
  if (!result) {
    task.heartbeatNoDetails(EnvironmentEdgeManager.currentTime());
    return false;
  }
  if (directive != FORCE) {
    task.unforcedResubmits.incrementAndGet();
  }
  task.setUnassigned();
  rescan(Long.MAX_VALUE);
  SplitLogCounters.tot_mgr_resubmit.incrementAndGet();
  return true;
}","@Override public boolean resubmitTask(String path,Task task,ResubmitDirective directive){
  if (task.status != IN_PROGRESS) {
    return false;
  }
  int version;
  if (directive != FORCE) {
    final long time=EnvironmentEdgeManager.currentTime() - task.last_update;
    final boolean alive=details.getMaster().getServerManager() != null ? details.getMaster().getServerManager().isServerOnline(task.cur_worker_name) : true;
    if (alive && time < timeout) {
      LOG.trace(""String_Node_Str"" + task.toString() + ""String_Node_Str""+ task.cur_worker_name+ ""String_Node_Str""+ time+ ""String_Node_Str""+ timeout);
      return false;
    }
    if (task.unforcedResubmits.get() >= resubmitThreshold) {
      if (!task.resubmitThresholdReached) {
        task.resubmitThresholdReached=true;
        SplitLogCounters.tot_mgr_resubmit_threshold_reached.incrementAndGet();
        LOG.info(""String_Node_Str"" + path + ""String_Node_Str""+ resubmitThreshold+ ""String_Node_Str"");
      }
      return false;
    }
    version=task.last_version;
  }
 else {
    SplitLogCounters.tot_mgr_resubmit_force.incrementAndGet();
    version=-1;
  }
  LOG.info(""String_Node_Str"" + path);
  task.incarnation.incrementAndGet();
  boolean result=resubmit(this.details.getServerName(),path,version);
  if (!result) {
    task.heartbeatNoDetails(EnvironmentEdgeManager.currentTime());
    return false;
  }
  if (directive != FORCE) {
    task.unforcedResubmits.incrementAndGet();
  }
  task.setUnassigned();
  rescan(Long.MAX_VALUE);
  SplitLogCounters.tot_mgr_resubmit.incrementAndGet();
  return true;
}",0.9936224489795918
61144,"/** 
 * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This policy puts an upper-limit on the number of simultaneous log splitting that could be happening in a cluster. <p> Synchronization using   {@link #taskReadyLock} ensures that it will try to grab every task thathas been put up
 * @throws InterruptedException
 */
@Override public void taskLoop() throws InterruptedException {
  while (!shouldStop) {
    int seq_start=taskReadySeq;
    List<String> paths=null;
    paths=getTaskList();
    if (paths == null) {
      LOG.warn(""String_Node_Str"" + watcher.splitLogZNode + ""String_Node_Str"");
      return;
    }
    int offset=(int)(Math.random() * paths.size());
    for (int i=0; i < paths.size(); i++) {
      if (DefaultWALProvider.isMetaFile(paths.get(i))) {
        offset=i;
        break;
      }
    }
    int numTasks=paths.size();
    for (int i=0; i < numTasks; i++) {
      int idx=(i + offset) % paths.size();
      if (this.calculateAvailableSplitters(numTasks) > 0) {
        grabTask(ZKUtil.joinZNode(watcher.splitLogZNode,paths.get(idx)));
      }
 else {
        LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str""+ this.tasksInProgress.get()+ ""String_Node_Str"");
        break;
      }
      if (shouldStop) {
        return;
      }
    }
    SplitLogCounters.tot_wkr_task_grabing.incrementAndGet();
synchronized (taskReadyLock) {
      while (seq_start == taskReadySeq) {
        taskReadyLock.wait(checkInterval);
        if (server != null) {
          Map<String,Region> recoveringRegions=server.getRecoveringRegions();
          if (!recoveringRegions.isEmpty()) {
            List<String> tmpCopy=new ArrayList<String>(recoveringRegions.keySet());
            int listSize=tmpCopy.size();
            for (int i=0; i < listSize; i++) {
              String region=tmpCopy.get(i);
              String nodePath=ZKUtil.joinZNode(watcher.recoveringRegionsZNode,region);
              try {
                if (ZKUtil.checkExists(watcher,nodePath) == -1) {
                  server.getExecutorService().submit(new FinishRegionRecoveringHandler(server,region,nodePath));
                }
 else {
                  break;
                }
              }
 catch (              KeeperException e) {
                LOG.debug(""String_Node_Str"",e);
                break;
              }
            }
          }
        }
      }
    }
  }
}","/** 
 * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This policy puts an upper-limit on the number of simultaneous log splitting that could be happening in a cluster. <p> Synchronization using <code>taskReadyLock</code> ensures that it will try to grab every task that has been put up
 * @throws InterruptedException
 */
@Override public void taskLoop() throws InterruptedException {
  while (!shouldStop) {
    int seq_start=taskReadySeq.get();
    List<String> paths=null;
    paths=getTaskList();
    if (paths == null) {
      LOG.warn(""String_Node_Str"" + watcher.splitLogZNode + ""String_Node_Str"");
      return;
    }
    int offset=(int)(Math.random() * paths.size());
    for (int i=0; i < paths.size(); i++) {
      if (DefaultWALProvider.isMetaFile(paths.get(i))) {
        offset=i;
        break;
      }
    }
    int numTasks=paths.size();
    for (int i=0; i < numTasks; i++) {
      int idx=(i + offset) % paths.size();
      if (this.calculateAvailableSplitters(numTasks) > 0) {
        grabTask(ZKUtil.joinZNode(watcher.splitLogZNode,paths.get(idx)));
      }
 else {
        LOG.debug(""String_Node_Str"" + server.getServerName() + ""String_Node_Str""+ this.tasksInProgress.get()+ ""String_Node_Str"");
        break;
      }
      if (shouldStop) {
        return;
      }
    }
    SplitLogCounters.tot_wkr_task_grabing.incrementAndGet();
synchronized (taskReadyLock) {
      while (seq_start == taskReadySeq.get()) {
        taskReadyLock.wait(checkInterval);
        if (server != null) {
          Map<String,Region> recoveringRegions=server.getRecoveringRegions();
          if (!recoveringRegions.isEmpty()) {
            List<String> tmpCopy=new ArrayList<String>(recoveringRegions.keySet());
            int listSize=tmpCopy.size();
            for (int i=0; i < listSize; i++) {
              String region=tmpCopy.get(i);
              String nodePath=ZKUtil.joinZNode(watcher.recoveringRegionsZNode,region);
              try {
                if (ZKUtil.checkExists(watcher,nodePath) == -1) {
                  server.getExecutorService().submit(new FinishRegionRecoveringHandler(server,region,nodePath));
                }
 else {
                  break;
                }
              }
 catch (              KeeperException e) {
                LOG.debug(""String_Node_Str"",e);
                break;
              }
            }
          }
        }
      }
    }
  }
}",0.992413368874308
61145,"/** 
 * Override handler from   {@link ZooKeeperListener}
 */
@Override public void nodeChildrenChanged(String path){
  if (path.equals(watcher.splitLogZNode)) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + path);
synchronized (taskReadyLock) {
      taskReadySeq++;
      taskReadyLock.notify();
    }
  }
}","/** 
 * Override handler from   {@link ZooKeeperListener}
 */
@Override public void nodeChildrenChanged(String path){
  if (path.equals(watcher.splitLogZNode)) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + path);
synchronized (taskReadyLock) {
      this.taskReadySeq.incrementAndGet();
      taskReadyLock.notify();
    }
  }
}",0.9629629629629628
61146,"@Override public int getTaskReadySeq(){
  return taskReadySeq;
}","@Override public int getTaskReadySeq(){
  return taskReadySeq.get();
}",0.9552238805970148
61147,"/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response){
  try {
    if (!HttpServer.isInstrumentationAccessAllowed(getServletContext(),request,response)) {
      return;
    }
    String jsonpcb=null;
    PrintWriter writer=null;
    JSONBean.Writer beanWriter=null;
    try {
      writer=response.getWriter();
      beanWriter=this.jsonBeanWriter.open(writer);
      jsonpcb=request.getParameter(CALLBACK_PARAM);
      if (jsonpcb != null) {
        response.setContentType(""String_Node_Str"");
        writer.write(jsonpcb + ""String_Node_Str"");
      }
 else {
        response.setContentType(""String_Node_Str"");
      }
      String tmpStr=request.getParameter(INCLUDE_DESCRIPTION);
      boolean description=tmpStr != null && tmpStr.length() > 0;
      String getmethod=request.getParameter(""String_Node_Str"");
      if (getmethod != null) {
        String[] splitStrings=getmethod.split(""String_Node_Str"");
        if (splitStrings.length != 2) {
          beanWriter.write(""String_Node_Str"",""String_Node_Str"");
          beanWriter.write(""String_Node_Str"",""String_Node_Str"");
          beanWriter.flush();
          response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
          return;
        }
        if (beanWriter.write(this.mBeanServer,new ObjectName(splitStrings[0]),splitStrings[1],description) != 0) {
          beanWriter.flush();
          response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        }
        return;
      }
      String qry=request.getParameter(""String_Node_Str"");
      if (qry == null) {
        qry=""String_Node_Str"";
      }
      if (beanWriter.write(this.mBeanServer,new ObjectName(qry),null,description) != 0) {
        beanWriter.flush();
        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
      }
    }
  finally {
      if (beanWriter != null)       beanWriter.close();
      if (jsonpcb != null) {
        writer.write(""String_Node_Str"");
      }
      if (writer != null) {
        writer.close();
      }
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
catch (  MalformedObjectNameException e) {
    LOG.error(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
  }
}","/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 */
@Override @edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public void doGet(HttpServletRequest request,HttpServletResponse response){
  try {
    if (!HttpServer.isInstrumentationAccessAllowed(getServletContext(),request,response)) {
      return;
    }
    String jsonpcb=null;
    PrintWriter writer=null;
    JSONBean.Writer beanWriter=null;
    try {
      writer=response.getWriter();
      beanWriter=this.jsonBeanWriter.open(writer);
      jsonpcb=request.getParameter(CALLBACK_PARAM);
      if (jsonpcb != null) {
        response.setContentType(""String_Node_Str"");
        writer.write(jsonpcb + ""String_Node_Str"");
      }
 else {
        response.setContentType(""String_Node_Str"");
      }
      String tmpStr=request.getParameter(INCLUDE_DESCRIPTION);
      boolean description=tmpStr != null && tmpStr.length() > 0;
      String getmethod=request.getParameter(""String_Node_Str"");
      if (getmethod != null) {
        String[] splitStrings=getmethod.split(""String_Node_Str"");
        if (splitStrings.length != 2) {
          beanWriter.write(""String_Node_Str"",""String_Node_Str"");
          beanWriter.write(""String_Node_Str"",""String_Node_Str"");
          beanWriter.flush();
          response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
          return;
        }
        if (beanWriter.write(this.mBeanServer,new ObjectName(splitStrings[0]),splitStrings[1],description) != 0) {
          beanWriter.flush();
          response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        }
        return;
      }
      String qry=request.getParameter(""String_Node_Str"");
      if (qry == null) {
        qry=""String_Node_Str"";
      }
      if (beanWriter.write(this.mBeanServer,new ObjectName(qry),null,description) != 0) {
        beanWriter.flush();
        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
      }
    }
  finally {
      if (beanWriter != null)       beanWriter.close();
      if (jsonpcb != null) {
        writer.write(""String_Node_Str"");
      }
      if (writer != null) {
        writer.close();
      }
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
catch (  MalformedObjectNameException e) {
    LOG.error(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
  }
}",0.9787992867049732
61148,"/** 
 * Method returns the reader given the specified arguments. TODO This is a bad abstraction.  See HBASE-6635.
 * @param path hfile's path
 * @param fsdis stream of path's file
 * @param size max size of the trailer.
 * @param cacheConf Cache configuation values, cannot be null.
 * @param hfs
 * @return an appropriate instance of HFileReader
 * @throws IOException If file is invalid, will throw CorruptHFileException flavored IOException
 */
private static Reader pickReaderVersion(Path path,FSDataInputStreamWrapper fsdis,long size,CacheConfig cacheConf,HFileSystem hfs,Configuration conf) throws IOException {
}","/** 
 * Method returns the reader given the specified arguments. TODO This is a bad abstraction.  See HBASE-6635.
 * @param path hfile's path
 * @param fsdis stream of path's file
 * @param size max size of the trailer.
 * @param cacheConf Cache configuation values, cannot be null.
 * @param hfs
 * @return an appropriate instance of HFileReader
 * @throws IOException If file is invalid, will throw CorruptHFileException flavored IOException
 */
@edu.umd.cs.findbugs.annotations.SuppressWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") private static Reader pickReaderVersion(Path path,FSDataInputStreamWrapper fsdis,long size,CacheConfig cacheConf,HFileSystem hfs,Configuration conf) throws IOException {
}",0.9204460966542752
61149,"/** 
 * Internal method to create the copy on write matrix. Once created, all further operations are performed on the CoW matrix
 */
private void cow(){
  if (cow != null) {
    return;
  }
  if (chks[0].isSparse()) {
    cow=new SparseMatrix(chks[0].len(),chks.length);
  }
 else {
    cow=new DenseMatrix(chks[0].len(),chks.length);
  }
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chks[0].len(); r++) {
      cow.setQuick(r,c,chks[c].at0(r));
    }
  }
}","/** 
 * Internal method to create the copy on write matrix. Once created, all further operations are performed on the CoW matrix
 */
private void cow(){
  if (cow != null) {
    return;
  }
  if (chks[0].isSparse()) {
    cow=new SparseMatrix(chks[0].len(),chks.length);
  }
 else {
    cow=new DenseMatrix(chks[0].len(),chks.length);
  }
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chks[0].len(); r++) {
      cow.setQuick(r,c,chks[c].atd(r));
    }
  }
}",0.9620253164556962
61150,"@Override public double getQuick(int row,int col){
  if (cow != null) {
    return cow.getQuick(row,col);
  }
 else {
    return chks[col].at0(row);
  }
}","@Override public double getQuick(int row,int col){
  if (cow != null) {
    return cow.getQuick(row,col);
  }
 else {
    return chks[col].atd(row);
  }
}",0.9935064935064936
61151,"/** 
 * Calculate Sums of elements in a column, and return as a Vector. Run an MRTask Job to add up sums. WARNING: Vulnerable to overflow. No way around it.
 * @param frame Frame backing the H2O DRM.
 * @return Vector of calculated sums.
 */
public static Vector colSums(Frame frame){
  /** 
 * MRTask to calculate sums of elements in all columns.
 */
class MRTaskSum extends MRTask<MRTaskSum> {
    public double sums[];
    @Override public void map(    Chunk chks[]){
      sums=new double[chks.length];
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          sums[c]+=chks[c].at0(r);
        }
      }
    }
    @Override public void reduce(    MRTaskSum other){
      ArrayUtils.add(sums,other.sums);
    }
  }
  return new DenseVector(new MRTaskSum().doAll(frame).sums);
}","/** 
 * Calculate Sums of elements in a column, and return as a Vector. Run an MRTask Job to add up sums. WARNING: Vulnerable to overflow. No way around it.
 * @param frame Frame backing the H2O DRM.
 * @return Vector of calculated sums.
 */
public static Vector colSums(Frame frame){
  /** 
 * MRTask to calculate sums of elements in all columns.
 */
class MRTaskSum extends MRTask<MRTaskSum> {
    public double sums[];
    @Override public void map(    Chunk chks[]){
      sums=new double[chks.length];
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          sums[c]+=chks[c].atd(r);
        }
      }
    }
    @Override public void reduce(    MRTaskSum other){
      ArrayUtils.add(sums,other.sums);
    }
  }
  return new DenseVector(new MRTaskSum().doAll(frame).sums);
}",0.9987864077669902
61152,"/** 
 * Calculate Sum of squares of all elements in the DRM. Run an MRTask Job to add up sums of squares. WARNING: Vulnerable to overflow. No way around it.
 * @param frame Frame backing the H2O DRM.
 * @return Sum of squares of all elements in the DRM.
 */
public static double sumSqr(Frame frame){
  /** 
 * MRTask to calculate sums of squares of all elements.
 */
class MRTaskSumSqr extends MRTask<MRTaskSumSqr> {
    public double sumSqr;
    @Override public void map(    Chunk chks[]){
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          sumSqr+=(chks[c].at0(r) * chks[c].at0(r));
        }
      }
    }
    @Override public void reduce(    MRTaskSumSqr other){
      sumSqr+=other.sumSqr;
    }
  }
  return new MRTaskSumSqr().doAll(frame).sumSqr;
}","/** 
 * Calculate Sum of squares of all elements in the DRM. Run an MRTask Job to add up sums of squares. WARNING: Vulnerable to overflow. No way around it.
 * @param frame Frame backing the H2O DRM.
 * @return Sum of squares of all elements in the DRM.
 */
public static double sumSqr(Frame frame){
  /** 
 * MRTask to calculate sums of squares of all elements.
 */
class MRTaskSumSqr extends MRTask<MRTaskSumSqr> {
    public double sumSqr;
    @Override public void map(    Chunk chks[]){
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          sumSqr+=(chks[c].atd(r) * chks[c].atd(r));
        }
      }
    }
    @Override public void reduce(    MRTaskSumSqr other){
      sumSqr+=other.sumSqr;
    }
  }
  return new MRTaskSumSqr().doAll(frame).sumSqr;
}",0.9975216852540272
61153,"/** 
 * Count non-zero elements in all columns, and return as a Vector. Run an MRTask Job to count non-zero elements per column.
 * @param frame Frame backing the H2O DRM.
 * @return Vector of counted non-zero elements.
 */
public static Vector nonZeroCnt(Frame frame){
  /** 
 * MRTask to count all non-zero elements.
 */
class MRTaskNonZero extends MRTask<MRTaskNonZero> {
    public double sums[];
    @Override public void map(    Chunk chks[]){
      sums=new double[chks.length];
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          if ((long)chks[c].at0(r) != 0) {
            sums[c]++;
          }
        }
      }
    }
    @Override public void reduce(    MRTaskNonZero other){
      ArrayUtils.add(sums,other.sums);
    }
  }
  return new DenseVector(new MRTaskNonZero().doAll(frame).sums);
}","/** 
 * Count non-zero elements in all columns, and return as a Vector. Run an MRTask Job to count non-zero elements per column.
 * @param frame Frame backing the H2O DRM.
 * @return Vector of counted non-zero elements.
 */
public static Vector nonZeroCnt(Frame frame){
  /** 
 * MRTask to count all non-zero elements.
 */
class MRTaskNonZero extends MRTask<MRTaskNonZero> {
    public double sums[];
    @Override public void map(    Chunk chks[]){
      sums=new double[chks.length];
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chks[c].len(); r++) {
          if ((long)chks[c].atd(r) != 0) {
            sums[c]++;
          }
        }
      }
    }
    @Override public void reduce(    MRTaskNonZero other){
      ArrayUtils.add(sums,other.sums);
    }
  }
  return new DenseVector(new MRTaskNonZero().doAll(frame).sums);
}",0.9988290398126464
61154,"@Override public void map(Chunk chks[]){
  sums=new double[chks.length];
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chks[c].len(); r++) {
      if ((long)chks[c].at0(r) != 0) {
        sums[c]++;
      }
    }
  }
}","@Override public void map(Chunk chks[]){
  sums=new double[chks.length];
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chks[c].len(); r++) {
      if ((long)chks[c].atd(r) != 0) {
        sums[c]++;
      }
    }
  }
}",0.9658119658119658
61155,"public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  Vec B_vecs[]=B.vecs();
  for (int c=0; c < ncs.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (int i=0; i < chks.length; i++) {
        v+=(chks[i].at0(r) * B_vecs[i].at(c));
      }
      ncs[c].addNum(v);
    }
  }
}","public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  Vec B_vecs[]=B.vecs();
  for (int c=0; c < ncs.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (int i=0; i < chks.length; i++) {
        v+=(chks[i].atd(r) * B_vecs[i].at(c));
      }
      ncs[c].addNum(v);
    }
  }
}",0.996996996996997
61156,"/** 
 * Calculate AB' on two DRMs to create a new DRM holding the result.
 * @param drmA DRM representing matrix A
 * @param drmB DRM representing matrix B
 * @return new DRM containing AB'
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  final Frame B=drmB.frame;
  int ABt_cols=(int)B.numRows();
  Frame ABt=new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      Vec B_vecs[]=B.vecs();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (int i=0; i < chks.length; i++) {
            v+=(chks[i].at0(r) * B_vecs[i].at(c));
          }
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(ABt_cols,A).outputFrame(null,null);
  return new H2ODrm(ABt,keys);
}","/** 
 * Calculate AB' on two DRMs to create a new DRM holding the result.
 * @param drmA DRM representing matrix A
 * @param drmB DRM representing matrix B
 * @return new DRM containing AB'
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  final Frame B=drmB.frame;
  int ABt_cols=(int)B.numRows();
  Frame ABt=new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      Vec B_vecs[]=B.vecs();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (int i=0; i < chks.length; i++) {
            v+=(chks[i].atd(r) * B_vecs[i].at(c));
          }
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(ABt_cols,A).outputFrame(null,null);
  return new H2ODrm(ABt,keys);
}",0.9988235294117648
61157,"@Override public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  Vec B_vecs[]=B.vecs();
  long start=chks[0].start();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      ncs[c].addNum(opfn(op,chks[c].at0(r),B_vecs[c].at(start + r)));
    }
  }
}","@Override public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  Vec B_vecs[]=B.vecs();
  long start=chks[0].start();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      ncs[c].addNum(opfn(op,chks[c].atd(r),B_vecs[c].at(start + r)));
    }
  }
}",0.9966996699669968
61158,"/** 
 * Perform element-wise operation on two DRMs to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @param op Element-wise operator encoded as a String.
 * @return new DRM containing A (element-wise) B.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB,final String op){
  final Frame A=drmA.frame;
  final Frame B=drmB.frame;
  Vec keys=drmA.keys;
  int AewB_cols=A.numCols();
  Frame AewB=new MRTask(){
    private double opfn(    String op,    double a,    double b){
      if (a == 0.0 && b == 0.0) {
        return 0.0;
      }
      if (op.equals(""String_Node_Str"")) {
        return a + b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a - b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a * b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a / b;
      }
      return 0.0;
    }
    @Override public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      Vec B_vecs[]=B.vecs();
      long start=chks[0].start();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          ncs[c].addNum(opfn(op,chks[c].at0(r),B_vecs[c].at(start + r)));
        }
      }
    }
  }
.doAll(AewB_cols,A).outputFrame(null,null);
  return new H2ODrm(AewB,keys);
}","/** 
 * Perform element-wise operation on two DRMs to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @param op Element-wise operator encoded as a String.
 * @return new DRM containing A (element-wise) B.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB,final String op){
  final Frame A=drmA.frame;
  final Frame B=drmB.frame;
  Vec keys=drmA.keys;
  int AewB_cols=A.numCols();
  Frame AewB=new MRTask(){
    private double opfn(    String op,    double a,    double b){
      if (a == 0.0 && b == 0.0) {
        return 0.0;
      }
      if (op.equals(""String_Node_Str"")) {
        return a + b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a - b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a * b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a / b;
      }
      return 0.0;
    }
    @Override public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      Vec B_vecs[]=B.vecs();
      long start=chks[0].start();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          ncs[c].addNum(opfn(op,chks[c].atd(r),B_vecs[c].at(start + r)));
        }
      }
    }
  }
.doAll(AewB_cols,A).outputFrame(null,null);
  return new H2ODrm(AewB,keys);
}",0.9992641648270788
61159,"public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      ncs[c].addNum(opfn(op,chks[c].at0(r),s));
    }
  }
}","public void map(Chunk chks[],NewChunk ncs[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      ncs[c].addNum(opfn(op,chks[c].atd(r),s));
    }
  }
}",0.9959349593495936
61160,"/** 
 * Perform element-wise operation on a DRM with a Scalar to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param s Scalar value represented as a double.
 * @param op Element-wise operator encoded as a String.
 * @return new DRM containing A (element-wise) B.
 */
public static H2ODrm exec(H2ODrm drmA,final double s,final String op){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  int AewScalar_cols=A.numCols();
  Frame AewScalar=new MRTask(){
    private double opfn(    String op,    double a,    double b){
      if (a == 0.0 && b == 0.0) {
        return 0.0;
      }
      if (op.equals(""String_Node_Str"")) {
        return a + b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a - b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a * b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a / b;
      }
      return 0.0;
    }
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          ncs[c].addNum(opfn(op,chks[c].at0(r),s));
        }
      }
    }
  }
.doAll(AewScalar_cols,A).outputFrame(null,null);
  return new H2ODrm(AewScalar,keys);
}","/** 
 * Perform element-wise operation on a DRM with a Scalar to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param s Scalar value represented as a double.
 * @param op Element-wise operator encoded as a String.
 * @return new DRM containing A (element-wise) B.
 */
public static H2ODrm exec(H2ODrm drmA,final double s,final String op){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  int AewScalar_cols=A.numCols();
  Frame AewScalar=new MRTask(){
    private double opfn(    String op,    double a,    double b){
      if (a == 0.0 && b == 0.0) {
        return 0.0;
      }
      if (op.equals(""String_Node_Str"")) {
        return a + b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a - b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a * b;
      }
 else       if (op.equals(""String_Node_Str"")) {
        return a / b;
      }
      return 0.0;
    }
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          ncs[c].addNum(opfn(op,chks[c].atd(r),s));
        }
      }
    }
  }
.doAll(AewScalar_cols,A).outputFrame(null,null);
  return new H2ODrm(AewScalar,keys);
}",0.9992343032159264
61161,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec A_vecs[]=A.vecs();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      chks[c].set0(r,A_vecs[(int)(start + r)].at(c));
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec A_vecs[]=A.vecs();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      chks[c].set(r,A_vecs[(int)(start + r)].at(c));
    }
  }
}",0.9980879541108988
61162,"/** 
 * Perform transpose operation on a DRM to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @return new DRM containing A'.
 */
public static H2ODrm exec(H2ODrm drmA){
  final Frame A=drmA.frame;
  Frame At=H2OHelper.emptyFrame(A.numCols(),(int)A.numRows(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec A_vecs[]=A.vecs();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          chks[c].set0(r,A_vecs[(int)(start + r)].at(c));
        }
      }
    }
  }
.doAll(At);
  return new H2ODrm(At);
}","/** 
 * Perform transpose operation on a DRM to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @return new DRM containing A'.
 */
public static H2ODrm exec(H2ODrm drmA){
  final Frame A=drmA.frame;
  Frame At=H2OHelper.emptyFrame(A.numCols(),(int)A.numRows(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec A_vecs[]=A.vecs();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          chks[c].set(r,A_vecs[(int)(start + r)].at(c));
        }
      }
    }
  }
.doAll(At);
  return new H2ODrm(At);
}",0.9992277992277993
61163,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec A_vecs[]=A.vecs();
  long A_rows=A.numRows();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (long i=0; i < A_rows; i++) {
        v+=(A_vecs[(int)(start + r)].at(i) * A_vecs[c].at(i));
      }
      chks[c].set0(r,v);
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec A_vecs[]=A.vecs();
  long A_rows=A.numRows();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (long i=0; i < A_rows; i++) {
        v+=(A_vecs[(int)(start + r)].at(i) * A_vecs[c].at(i));
      }
      chks[c].set(r,v);
    }
  }
}",0.9987129987129988
61164,"/** 
 * Perform A'A operation on a DRM to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @return new DRM containing A'A.
 */
public static H2ODrm exec(H2ODrm drmA){
  final Frame A=drmA.frame;
  Frame AtA=H2OHelper.emptyFrame(A.numCols(),A.numCols(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec A_vecs[]=A.vecs();
      long A_rows=A.numRows();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (long i=0; i < A_rows; i++) {
            v+=(A_vecs[(int)(start + r)].at(i) * A_vecs[c].at(i));
          }
          chks[c].set0(r,v);
        }
      }
    }
  }
.doAll(AtA);
  return new H2ODrm(AtA);
}","/** 
 * Perform A'A operation on a DRM to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @return new DRM containing A'A.
 */
public static H2ODrm exec(H2ODrm drmA){
  final Frame A=drmA.frame;
  Frame AtA=H2OHelper.emptyFrame(A.numCols(),A.numCols(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec A_vecs[]=A.vecs();
      long A_rows=A.numRows();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (long i=0; i < A_rows; i++) {
            v+=(A_vecs[(int)(start + r)].at(i) * A_vecs[c].at(i));
          }
          chks[c].set(r,v);
        }
      }
    }
  }
.doAll(AtA);
  return new H2ODrm(AtA);
}",0.9993650793650792
61165,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  long A_rows=A.numRows();
  Vec A_vecs[]=A.vecs();
  Vec B_vecs[]=B.vecs();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (long i=0; i < A_rows; i++) {
        v+=(A_vecs[(int)(start + r)].at(i) * B_vecs[c].at(i));
      }
      chks[c].set0(r,v);
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  long A_rows=A.numRows();
  Vec A_vecs[]=A.vecs();
  Vec B_vecs[]=B.vecs();
  for (int c=0; c < chks.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (long i=0; i < A_rows; i++) {
        v+=(A_vecs[(int)(start + r)].at(i) * B_vecs[c].at(i));
      }
      chks[c].set(r,v);
    }
  }
}",0.9987908101571948
61166,"/** 
 * Perform A'B operation on two DRMs to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @return new DRM containing A'B.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  final Frame A=drmA.frame;
  final Frame B=drmB.frame;
  Frame AtB=H2OHelper.emptyFrame(A.numCols(),B.numCols(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      long A_rows=A.numRows();
      Vec A_vecs[]=A.vecs();
      Vec B_vecs[]=B.vecs();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (long i=0; i < A_rows; i++) {
            v+=(A_vecs[(int)(start + r)].at(i) * B_vecs[c].at(i));
          }
          chks[c].set0(r,v);
        }
      }
    }
  }
.doAll(AtB);
  return new H2ODrm(AtB);
}","/** 
 * Perform A'B operation on two DRMs to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @return new DRM containing A'B.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  final Frame A=drmA.frame;
  final Frame B=drmB.frame;
  Frame AtB=H2OHelper.emptyFrame(A.numCols(),B.numCols(),-1,-1);
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      long A_rows=A.numRows();
      Vec A_vecs[]=A.vecs();
      Vec B_vecs[]=B.vecs();
      for (int c=0; c < chks.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (long i=0; i < A_rows; i++) {
            v+=(A_vecs[(int)(start + r)].at(i) * B_vecs[c].at(i));
          }
          chks[c].set(r,v);
        }
      }
    }
  }
.doAll(AtB);
  return new H2ODrm(AtB);
}",0.9994453688297282
61167,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  Vector x=bx.value();
  long start=chks[0].start();
  atx=new double[chks.length];
  for (int r=0; r < chunkSize; r++) {
    double d=x.getQuick((int)start + r);
    for (int c=0; c < chks.length; c++) {
      atx[c]+=(chks[c].at0(r) * d);
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  Vector x=bx.value();
  long start=chks[0].start();
  atx=new double[chks.length];
  for (int r=0; r < chunkSize; r++) {
    double d=x.getQuick((int)start + r);
    for (int c=0; c < chks.length; c++) {
      atx[c]+=(chks[c].atd(r) * d);
    }
  }
}",0.9968152866242038
61168,"/** 
 * Perform A'x operation with a DRM and an in-core Vector to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param x in-core Mahout Vector.
 * @return new DRM containing A'x.
 */
public static H2ODrm exec(H2ODrm drmA,Vector x){
  Frame A=drmA.frame;
  final H2OBCast<Vector> bx=new H2OBCast<Vector>(x);
class MRTaskAtx extends MRTask<MRTaskAtx> {
    double atx[];
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      Vector x=bx.value();
      long start=chks[0].start();
      atx=new double[chks.length];
      for (int r=0; r < chunkSize; r++) {
        double d=x.getQuick((int)start + r);
        for (int c=0; c < chks.length; c++) {
          atx[c]+=(chks[c].at0(r) * d);
        }
      }
    }
    public void reduce(    MRTaskAtx other){
      ArrayUtils.add(atx,other.atx);
    }
  }
  Vector v=new DenseVector(new MRTaskAtx().doAll(A).atx);
  Matrix m=new DenseMatrix(A.numCols(),1);
  m.assignColumn(0,v);
  return H2OHelper.drmFromMatrix(m,-1,-1);
}","/** 
 * Perform A'x operation with a DRM and an in-core Vector to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param x in-core Mahout Vector.
 * @return new DRM containing A'x.
 */
public static H2ODrm exec(H2ODrm drmA,Vector x){
  Frame A=drmA.frame;
  final H2OBCast<Vector> bx=new H2OBCast<Vector>(x);
class MRTaskAtx extends MRTask<MRTaskAtx> {
    double atx[];
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      Vector x=bx.value();
      long start=chks[0].start();
      atx=new double[chks.length];
      for (int r=0; r < chunkSize; r++) {
        double d=x.getQuick((int)start + r);
        for (int c=0; c < chks.length; c++) {
          atx[c]+=(chks[c].atd(r) * d);
        }
      }
    }
    public void reduce(    MRTaskAtx other){
      ArrayUtils.add(atx,other.atx);
    }
  }
  Vector v=new DenseVector(new MRTaskAtx().doAll(A).atx);
  Matrix m=new DenseMatrix(A.numCols(),1);
  m.assignColumn(0,v);
  return H2OHelper.drmFromMatrix(m,-1,-1);
}",0.9990128331688056
61169,"public void map(Chunk chks[],NewChunk nc){
  int chunkSize=chks[0].len();
  Vector x=bx.value();
  for (int r=0; r < chunkSize; r++) {
    double v=0;
    for (int c=0; c < chks.length; c++) {
      v+=(chks[c].at0(r) * x.getQuick(c));
    }
    nc.addNum(v);
  }
}","public void map(Chunk chks[],NewChunk nc){
  int chunkSize=chks[0].len();
  Vector x=bx.value();
  for (int r=0; r < chunkSize; r++) {
    double v=0;
    for (int c=0; c < chks.length; c++) {
      v+=(chks[c].atd(r) * x.getQuick(c));
    }
    nc.addNum(v);
  }
}",0.9962264150943396
61170,"/** 
 * Perform Ax operation with a DRM and an in-core Vector to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param x in-core Mahout Vector.
 * @return new DRM containing Ax.
 */
public static H2ODrm exec(H2ODrm drmA,Vector x){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  final H2OBCast<Vector> bx=new H2OBCast<Vector>(x);
  Frame Ax=new MRTask(){
    public void map(    Chunk chks[],    NewChunk nc){
      int chunkSize=chks[0].len();
      Vector x=bx.value();
      for (int r=0; r < chunkSize; r++) {
        double v=0;
        for (int c=0; c < chks.length; c++) {
          v+=(chks[c].at0(r) * x.getQuick(c));
        }
        nc.addNum(v);
      }
    }
  }
.doAll(1,A).outputFrame(null,null);
  return new H2ODrm(Ax,keys);
}","/** 
 * Perform Ax operation with a DRM and an in-core Vector to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param x in-core Mahout Vector.
 * @return new DRM containing Ax.
 */
public static H2ODrm exec(H2ODrm drmA,Vector x){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  final H2OBCast<Vector> bx=new H2OBCast<Vector>(x);
  Frame Ax=new MRTask(){
    public void map(    Chunk chks[],    NewChunk nc){
      int chunkSize=chks[0].len();
      Vector x=bx.value();
      for (int r=0; r < chunkSize; r++) {
        double v=0;
        for (int c=0; c < chks.length; c++) {
          v+=(chks[c].atd(r) * x.getQuick(c));
        }
        nc.addNum(v);
      }
    }
  }
.doAll(1,A).outputFrame(null,null);
  return new H2ODrm(Ax,keys);
}",0.9986807387862796
61171,"/** 
 * Heavy weight join(), involves moving data 
 */
private static H2ODrm join(final Frame fra,final Vec keysa,final Frame frb,final Vec keysb){
  Vec bvecs[]=new Vec[frb.vecs().length];
  for (int i=0; i < bvecs.length; i++) {
    bvecs[i]=fra.anyVec().makeZero();
  }
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec vecs[]=frb.vecs();
      for (int r=0; r < chunkSize; r++) {
        for (int c=0; c < chks.length; c++) {
          chks[c].set0(r,vecs[c].at(start + r));
        }
      }
    }
  }
.doAll(bvecs);
  return zip(fra,keysa,new Frame(bvecs),null);
}","/** 
 * Heavy weight join(), involves moving data 
 */
private static H2ODrm join(final Frame fra,final Vec keysa,final Frame frb,final Vec keysb){
  Vec bvecs[]=new Vec[frb.vecs().length];
  for (int i=0; i < bvecs.length; i++) {
    bvecs[i]=fra.anyVec().makeZero();
  }
  new MRTask(){
    public void map(    Chunk chks[]){
      int chunkSize=chks[0].len();
      long start=chks[0].start();
      Vec vecs[]=frb.vecs();
      for (int r=0; r < chunkSize; r++) {
        for (int c=0; c < chks.length; c++) {
          chks[c].set(r,vecs[c].at(start + r));
        }
      }
    }
  }
.doAll(bvecs);
  return zip(fra,keysa,new Frame(bvecs),null);
}",0.9992348890589136
61172,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec vecs[]=frb.vecs();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      chks[c].set0(r,vecs[c].at(start + r));
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  long start=chks[0].start();
  Vec vecs[]=frb.vecs();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      chks[c].set(r,vecs[c].at(start + r));
    }
  }
}",0.998019801980198
61173,"public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  Vec vins[]=frin.vecs();
  long start=chks[0].start();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      chks[c].set0(r,vins[c].at(start + r));
    }
  }
}","public void map(Chunk chks[]){
  int chunkSize=chks[0].len();
  Vec vins[]=frin.vecs();
  long start=chks[0].start();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      chks[c].set(r,vins[c].at(start + r));
    }
  }
}",0.9980276134122288
61174,"/** 
 * (re)Parallelize DRM data according to new partitioning hints.
 * @param drmA Input DRM containing data.
 * @param min Hint of minimum number of partitions to parallelize, if not -1.
 * @param exact Hint of exact number of partitions to parallelize, if not -1.
 * @return new DRM holding the same data but parallelized according to new hints.
 */
public static H2ODrm exec(H2ODrm drmA,int min,int exact){
  final Frame frin=drmA.frame;
  final Vec vin=drmA.keys;
  Frame frout=H2OHelper.emptyFrame(frin.numRows(),frin.numCols(),min,exact);
  Vec vout=null;
  if (vin != null) {
    vout=new MRTask(){
      public void map(      Chunk chks[],      NewChunk nc){
        int chunkSize=chks[0].len();
        Vec vins[]=frin.vecs();
        long start=chks[0].start();
        ValueString vstr=new ValueString();
        for (int r=0; r < chunkSize; r++) {
          for (int c=0; c < chks.length; c++) {
            chks[c].set0(r,vins[c].at(start + r));
          }
          nc.addStr(vin.atStr(vstr,start + r));
        }
      }
    }
.doAll(1,frout).outputFrame(null,null).anyVec();
  }
 else {
    new MRTask(){
      public void map(      Chunk chks[]){
        int chunkSize=chks[0].len();
        Vec vins[]=frin.vecs();
        long start=chks[0].start();
        for (int r=0; r < chunkSize; r++) {
          for (int c=0; c < chks.length; c++) {
            chks[c].set0(r,vins[c].at(start + r));
          }
        }
      }
    }
.doAll(frout);
  }
  return new H2ODrm(frout,vout);
}","/** 
 * (re)Parallelize DRM data according to new partitioning hints.
 * @param drmA Input DRM containing data.
 * @param min Hint of minimum number of partitions to parallelize, if not -1.
 * @param exact Hint of exact number of partitions to parallelize, if not -1.
 * @return new DRM holding the same data but parallelized according to new hints.
 */
public static H2ODrm exec(H2ODrm drmA,int min,int exact){
  final Frame frin=drmA.frame;
  final Vec vin=drmA.keys;
  Frame frout=H2OHelper.emptyFrame(frin.numRows(),frin.numCols(),min,exact);
  Vec vout=null;
  if (vin != null) {
    vout=new MRTask(){
      public void map(      Chunk chks[],      NewChunk nc){
        int chunkSize=chks[0].len();
        Vec vins[]=frin.vecs();
        long start=chks[0].start();
        ValueString vstr=new ValueString();
        for (int r=0; r < chunkSize; r++) {
          for (int c=0; c < chks.length; c++) {
            chks[c].set(r,vins[c].at(start + r));
          }
          nc.addStr(vin.atStr(vstr,start + r));
        }
      }
    }
.doAll(1,frout).outputFrame(null,null).anyVec();
  }
 else {
    new MRTask(){
      public void map(      Chunk chks[]){
        int chunkSize=chks[0].len();
        Vec vins[]=frin.vecs();
        long start=chks[0].start();
        for (int r=0; r < chunkSize; r++) {
          for (int c=0; c < chks.length; c++) {
            chks[c].set(r,vins[c].at(start + r));
          }
        }
      }
    }
.doAll(frout);
  }
  return new H2ODrm(frout,vout);
}",0.9993346640053228
61175,"public void map(Chunk chks[],NewChunk nc){
  Vec A_vecs[]=fra.vecs();
  Vec B_vecs[]=frb.vecs();
  long A_rows=fra.numRows();
  long B_rows=frb.numRows();
  long start=chks[0].start();
  int chunkSize=chks[0].len();
  ValueString vstr=new ValueString();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      if (r + start < A_rows) {
        chks[c].set0(r,A_vecs[c].at(r + start));
        if (keysa != null) {
          nc.addStr(keysa.atStr(vstr,r + start));
        }
      }
 else {
        chks[c].set0(r,B_vecs[c].at(r + start - A_rows));
        if (keysb != null) {
          nc.addStr(keysb.atStr(vstr,r + start - A_rows));
        }
      }
    }
  }
}","public void map(Chunk chks[],NewChunk nc){
  Vec A_vecs[]=fra.vecs();
  Vec B_vecs[]=frb.vecs();
  long A_rows=fra.numRows();
  long B_rows=frb.numRows();
  long start=chks[0].start();
  int chunkSize=chks[0].len();
  ValueString vstr=new ValueString();
  for (int r=0; r < chunkSize; r++) {
    for (int c=0; c < chks.length; c++) {
      if (r + start < A_rows) {
        chks[c].set(r,A_vecs[c].at(r + start));
        if (keysa != null) {
          nc.addStr(keysa.atStr(vstr,r + start));
        }
      }
 else {
        chks[c].set(r,B_vecs[c].at(r + start - A_rows));
        if (keysb != null) {
          nc.addStr(keysb.atStr(vstr,r + start - A_rows));
        }
      }
    }
  }
}",0.9985590778097982
61176,"/** 
 * Combine the rows of two DRMs A and B to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @return new DRM containing rows of B below A.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  final Frame fra=drmA.frame;
  final Vec keysa=drmA.keys;
  final Frame frb=drmB.frame;
  final Vec keysb=drmB.keys;
  Frame frbind=H2OHelper.emptyFrame(fra.numRows() + frb.numRows(),fra.numCols(),-1,-1,fra.anyVec().group());
  Vec keys=null;
  MRTask task=new MRTask(){
    public void map(    Chunk chks[],    NewChunk nc){
      Vec A_vecs[]=fra.vecs();
      Vec B_vecs[]=frb.vecs();
      long A_rows=fra.numRows();
      long B_rows=frb.numRows();
      long start=chks[0].start();
      int chunkSize=chks[0].len();
      ValueString vstr=new ValueString();
      for (int r=0; r < chunkSize; r++) {
        for (int c=0; c < chks.length; c++) {
          if (r + start < A_rows) {
            chks[c].set0(r,A_vecs[c].at(r + start));
            if (keysa != null) {
              nc.addStr(keysa.atStr(vstr,r + start));
            }
          }
 else {
            chks[c].set0(r,B_vecs[c].at(r + start - A_rows));
            if (keysb != null) {
              nc.addStr(keysb.atStr(vstr,r + start - A_rows));
            }
          }
        }
      }
    }
  }
;
  if (keysa == null) {
    keys=task.doAll(1,frbind).outputFrame(null,null).anyVec();
  }
 else {
    task.doAll(frbind);
  }
  return new H2ODrm(frbind,keys);
}","/** 
 * Combine the rows of two DRMs A and B to create a new DRM.
 * @param drmA DRM representing matrix A.
 * @param drmB DRM representing matrix B.
 * @return new DRM containing rows of B below A.
 */
public static H2ODrm exec(H2ODrm drmA,H2ODrm drmB){
  final Frame fra=drmA.frame;
  final Vec keysa=drmA.keys;
  final Frame frb=drmB.frame;
  final Vec keysb=drmB.keys;
  Frame frbind=H2OHelper.emptyFrame(fra.numRows() + frb.numRows(),fra.numCols(),-1,-1,fra.anyVec().group());
  Vec keys=null;
  MRTask task=new MRTask(){
    public void map(    Chunk chks[],    NewChunk nc){
      Vec A_vecs[]=fra.vecs();
      Vec B_vecs[]=frb.vecs();
      long A_rows=fra.numRows();
      long B_rows=frb.numRows();
      long start=chks[0].start();
      int chunkSize=chks[0].len();
      ValueString vstr=new ValueString();
      for (int r=0; r < chunkSize; r++) {
        for (int c=0; c < chks.length; c++) {
          if (r + start < A_rows) {
            chks[c].set(r,A_vecs[c].at(r + start));
            if (keysa != null) {
              nc.addStr(keysa.atStr(vstr,r + start));
            }
          }
 else {
            chks[c].set(r,B_vecs[c].at(r + start - A_rows));
            if (keysb != null) {
              nc.addStr(keysb.atStr(vstr,r + start - A_rows));
            }
          }
        }
      }
    }
  }
;
  if (keysa == null) {
    keys=task.doAll(1,frbind).outputFrame(null,null).anyVec();
  }
 else {
    task.doAll(frbind);
  }
  return new H2ODrm(frbind,keys);
}",0.999330207635633
61177,"public void map(Chunk chk,NewChunk nc){
  int chunkSize=chk.len();
  long chunkStart=chk.start();
  ValueString vstr=new ValueString();
  if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
    return;
  }
  for (int r=0; r < chunkSize; r++) {
    if (!R.contains(chunkStart + r)) {
      continue;
    }
    nc.addStr(chk.atStr0(vstr,r));
  }
}","public void map(Chunk chk,NewChunk nc){
  int chunkSize=chk.len();
  long chunkStart=chk.start();
  ValueString vstr=new ValueString();
  if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
    return;
  }
  for (int r=0; r < chunkSize; r++) {
    if (!R.contains(chunkStart + r)) {
      continue;
    }
    nc.addStr(chk.atStr(vstr,r));
  }
}",0.9986130374479888
61178,"/** 
 * Filter rows from intput DRM, to include only row indiced included in R.
 * @param drmA Input DRM.
 * @param R Range object specifying the start and end row numbers to filter.
 * @return new DRM with just the filtered rows.
 */
public static H2ODrm exec(H2ODrm drmA,final Range R){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  Frame Arr=new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      long chunkStart=chks[0].start();
      if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
        return;
      }
      for (int r=0; r < chunkSize; r++) {
        if (!R.contains(chunkStart + r)) {
          continue;
        }
        for (int c=0; c < chks.length; c++) {
          ncs[c].addNum(chks[c].at0(r));
        }
      }
    }
  }
.doAll(A.numCols(),A).outputFrame(null,null);
  Vec Vrr=(keys == null) ? null : new MRTask(){
    public void map(    Chunk chk,    NewChunk nc){
      int chunkSize=chk.len();
      long chunkStart=chk.start();
      ValueString vstr=new ValueString();
      if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
        return;
      }
      for (int r=0; r < chunkSize; r++) {
        if (!R.contains(chunkStart + r)) {
          continue;
        }
        nc.addStr(chk.atStr0(vstr,r));
      }
    }
  }
.doAll(1,keys).outputFrame(null,null).anyVec();
  return new H2ODrm(Arr,Vrr);
}","/** 
 * Filter rows from intput DRM, to include only row indiced included in R.
 * @param drmA Input DRM.
 * @param R Range object specifying the start and end row numbers to filter.
 * @return new DRM with just the filtered rows.
 */
public static H2ODrm exec(H2ODrm drmA,final Range R){
  Frame A=drmA.frame;
  Vec keys=drmA.keys;
  Frame Arr=new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      int chunkSize=chks[0].len();
      long chunkStart=chks[0].start();
      if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
        return;
      }
      for (int r=0; r < chunkSize; r++) {
        if (!R.contains(chunkStart + r)) {
          continue;
        }
        for (int c=0; c < chks.length; c++) {
          ncs[c].addNum(chks[c].atd(r));
        }
      }
    }
  }
.doAll(A.numCols(),A).outputFrame(null,null);
  Vec Vrr=(keys == null) ? null : new MRTask(){
    public void map(    Chunk chk,    NewChunk nc){
      int chunkSize=chk.len();
      long chunkStart=chk.start();
      ValueString vstr=new ValueString();
      if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {
        return;
      }
      for (int r=0; r < chunkSize; r++) {
        if (!R.contains(chunkStart + r)) {
          continue;
        }
        nc.addStr(chk.atStr(vstr,r));
      }
    }
  }
.doAll(1,keys).outputFrame(null,null).anyVec();
  return new H2ODrm(Arr,Vrr);
}",0.9989447766443896
61179,"/** 
 * Multiply Frame A with in-core diagonal Matrix (whose diagonal Vector is d) A.numCols() == d.size()
 */
private static Frame execDiagonal(final Frame A,Vector d){
  final H2OBCast<Vector> bd=new H2OBCast<Vector>(d);
  return new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      Vector D=bd.value();
      int chunkSize=chks[0].len();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=(chks[c].at0(r) * D.getQuick(c));
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(d.size(),A).outputFrame(null,null);
}","/** 
 * Multiply Frame A with in-core diagonal Matrix (whose diagonal Vector is d) A.numCols() == d.size()
 */
private static Frame execDiagonal(final Frame A,Vector d){
  final H2OBCast<Vector> bd=new H2OBCast<Vector>(d);
  return new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      Vector D=bd.value();
      int chunkSize=chks[0].len();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=(chks[c].atd(r) * D.getQuick(c));
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(d.size(),A).outputFrame(null,null);
}",0.9983498349834984
61180,"public void map(Chunk chks[],NewChunk ncs[]){
  Matrix B=bb.value();
  int chunkSize=chks[0].len();
  for (int c=0; c < ncs.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (int i=0; i < chks.length; i++) {
        v+=(chks[i].at0(r) * B.getQuick(i,c));
      }
      ncs[c].addNum(v);
    }
  }
}","public void map(Chunk chks[],NewChunk ncs[]){
  Matrix B=bb.value();
  int chunkSize=chks[0].len();
  for (int c=0; c < ncs.length; c++) {
    for (int r=0; r < chunkSize; r++) {
      double v=0;
      for (int i=0; i < chks.length; i++) {
        v+=(chks[i].atd(r) * B.getQuick(i,c));
      }
      ncs[c].addNum(v);
    }
  }
}",0.9969788519637462
61181,"/** 
 * Multiply Frame A with in-core Matrix b A.numCols() == b.rowSize()
 */
private static Frame execCommon(final Frame A,Matrix b){
  final H2OBCast<Matrix> bb=new H2OBCast<Matrix>(b);
  return new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      Matrix B=bb.value();
      int chunkSize=chks[0].len();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (int i=0; i < chks.length; i++) {
            v+=(chks[i].at0(r) * B.getQuick(i,c));
          }
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(b.columnSize(),A).outputFrame(null,null);
}","/** 
 * Multiply Frame A with in-core Matrix b A.numCols() == b.rowSize()
 */
private static Frame execCommon(final Frame A,Matrix b){
  final H2OBCast<Matrix> bb=new H2OBCast<Matrix>(b);
  return new MRTask(){
    public void map(    Chunk chks[],    NewChunk ncs[]){
      Matrix B=bb.value();
      int chunkSize=chks[0].len();
      for (int c=0; c < ncs.length; c++) {
        for (int r=0; r < chunkSize; r++) {
          double v=0;
          for (int i=0; i < chks.length; i++) {
            v+=(chks[i].atd(r) * B.getQuick(i,c));
          }
          ncs[c].addNum(v);
        }
      }
    }
  }
.doAll(b.columnSize(),A).outputFrame(null,null);
}",0.9984779299847792
61182,"@Override public Iterable<Centroid> call(){
  UpdatableSearcher searcher=StreamingKMeansUtilsMR.searcherFromConfiguration(conf);
  int numClusters=conf.getInt(StreamingKMeansDriver.ESTIMATED_NUM_MAP_CLUSTERS,1);
  double estimateDistanceCutoff=conf.getFloat(StreamingKMeansDriver.ESTIMATED_DISTANCE_CUTOFF,StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF);
  Iterator<Centroid> dataPointsIterator=dataPoints.iterator();
  List<Centroid> dataPointsList=Lists.newArrayList();
  if (estimateDistanceCutoff == StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF) {
    List<Centroid> estimatePoints=Lists.newArrayListWithExpectedSize(NUM_ESTIMATE_POINTS);
    while (dataPointsIterator.hasNext() && estimatePoints.size() < NUM_ESTIMATE_POINTS) {
      Centroid centroid=dataPointsIterator.next();
      estimatePoints.add(centroid);
      dataPointsList.add(centroid);
    }
    if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"",estimatePoints.size());
    }
    estimateDistanceCutoff=ClusteringUtils.estimateDistanceCutoff(estimatePoints,searcher.getDistanceMeasure());
  }
 else {
    Iterators.addAll(dataPointsList,dataPointsIterator);
  }
  StreamingKMeans streamingKMeans=new StreamingKMeans(searcher,numClusters,estimateDistanceCutoff);
  for (  Centroid aDataPoints : dataPointsList) {
    streamingKMeans.cluster(aDataPoints);
  }
  streamingKMeans.reindexCentroids();
  return streamingKMeans;
}","@Override public Iterable<Centroid> call(){
  UpdatableSearcher searcher=StreamingKMeansUtilsMR.searcherFromConfiguration(conf);
  int numClusters=conf.getInt(StreamingKMeansDriver.ESTIMATED_NUM_MAP_CLUSTERS,1);
  double estimateDistanceCutoff=conf.getFloat(StreamingKMeansDriver.ESTIMATED_DISTANCE_CUTOFF,StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF);
  Iterator<Centroid> dataPointsIterator=dataPoints.iterator();
  if (estimateDistanceCutoff == StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF) {
    List<Centroid> estimatePoints=Lists.newArrayListWithExpectedSize(NUM_ESTIMATE_POINTS);
    while (dataPointsIterator.hasNext() && estimatePoints.size() < NUM_ESTIMATE_POINTS) {
      Centroid centroid=dataPointsIterator.next();
      estimatePoints.add(centroid);
    }
    if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"",estimatePoints.size());
    }
    estimateDistanceCutoff=ClusteringUtils.estimateDistanceCutoff(estimatePoints,searcher.getDistanceMeasure());
  }
  StreamingKMeans streamingKMeans=new StreamingKMeans(searcher,numClusters,estimateDistanceCutoff);
  if (!dataPointsIterator.hasNext()) {
    dataPointsIterator=dataPoints.iterator();
  }
  while (dataPointsIterator.hasNext()) {
    streamingKMeans.cluster(dataPointsIterator.next());
  }
  streamingKMeans.reindexCentroids();
  return streamingKMeans;
}",0.7639547610361183
61183,"/** 
 * Story: User can produce final canopy centers using a EuclideanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
@Test public void testCanopyReducerEuclidean() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=getConfiguration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.CF_KEY,""String_Node_Str"");
  DummyRecordWriter<Text,ClusterWritable> writer=new DummyRecordWriter<Text,ClusterWritable>();
  Reducer<Text,VectorWritable,Text,ClusterWritable>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  List<VectorWritable> points=getPointsWritable();
  reducer.reduce(new Text(""String_Node_Str""),points,context);
  Set<Text> keys=writer.getKeys();
  assertEquals(""String_Node_Str"",3,keys.size());
  int i=0;
  for (  Text key : keys) {
    List<ClusterWritable> data=writer.getValue(key);
    ClusterWritable clusterWritable=data.get(0);
    Canopy canopy=(Canopy)clusterWritable.getValue();
    assertEquals(euclideanCentroids.get(i).asFormatString() + ""String_Node_Str"" + canopy.computeCentroid().asFormatString(),euclideanCentroids.get(i),canopy.computeCentroid());
    i++;
  }
}","/** 
 * Story: User can produce final canopy centers using a EuclideanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
@Test public void testCanopyReducerEuclidean() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=getConfiguration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.CF_KEY,""String_Node_Str"");
  DummyRecordWriter<Text,ClusterWritable> writer=new DummyRecordWriter<Text,ClusterWritable>();
  Reducer<Text,VectorWritable,Text,ClusterWritable>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  List<VectorWritable> points=getPointsWritable();
  reducer.reduce(new Text(""String_Node_Str""),points,context);
  Iterable<Text> keys=writer.getKeysInInsertionOrder();
  assertEquals(""String_Node_Str"",3,Iterables.size(keys));
  int i=0;
  for (  Text key : keys) {
    List<ClusterWritable> data=writer.getValue(key);
    ClusterWritable clusterWritable=data.get(0);
    Canopy canopy=(Canopy)clusterWritable.getValue();
    assertEquals(euclideanCentroids.get(i).asFormatString() + ""String_Node_Str"" + canopy.computeCentroid().asFormatString(),euclideanCentroids.get(i),canopy.computeCentroid());
    i++;
  }
}",0.9835728952772074
61184,"/** 
 * Story: User can produce final canopy centers using a ManhattanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
@Test public void testCanopyReducerManhattan() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=getConfiguration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.CF_KEY,""String_Node_Str"");
  DummyRecordWriter<Text,ClusterWritable> writer=new DummyRecordWriter<Text,ClusterWritable>();
  Reducer<Text,VectorWritable,Text,ClusterWritable>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  List<VectorWritable> points=getPointsWritable();
  reducer.reduce(new Text(""String_Node_Str""),points,context);
  Set<Text> keys=writer.getKeys();
  assertEquals(""String_Node_Str"",3,keys.size());
  int i=0;
  for (  Text key : keys) {
    List<ClusterWritable> data=writer.getValue(key);
    ClusterWritable clusterWritable=data.get(0);
    Canopy canopy=(Canopy)clusterWritable.getValue();
    assertEquals(manhattanCentroids.get(i).asFormatString() + ""String_Node_Str"" + canopy.computeCentroid().asFormatString(),manhattanCentroids.get(i),canopy.computeCentroid());
    i++;
  }
}","/** 
 * Story: User can produce final canopy centers using a ManhattanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
@Test public void testCanopyReducerManhattan() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=getConfiguration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.CF_KEY,""String_Node_Str"");
  DummyRecordWriter<Text,ClusterWritable> writer=new DummyRecordWriter<Text,ClusterWritable>();
  Reducer<Text,VectorWritable,Text,ClusterWritable>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  List<VectorWritable> points=getPointsWritable();
  reducer.reduce(new Text(""String_Node_Str""),points,context);
  Iterable<Text> keys=writer.getKeysInInsertionOrder();
  assertEquals(""String_Node_Str"",3,Iterables.size(keys));
  int i=0;
  for (  Text key : keys) {
    List<ClusterWritable> data=writer.getValue(key);
    ClusterWritable clusterWritable=data.get(0);
    Canopy canopy=(Canopy)clusterWritable.getValue();
    assertEquals(manhattanCentroids.get(i).asFormatString() + ""String_Node_Str"" + canopy.computeCentroid().asFormatString(),manhattanCentroids.get(i),canopy.computeCentroid());
    i++;
  }
}",0.9835728952772074
61185,"private void cloneWritable(Writable from,Writable to) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(baos);
  from.write(dos);
  dos.close();
  ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
  DataInputStream dis=new DataInputStream(bais);
  to.readFields(dis);
}","private Writable cloneWritable(Writable original) throws IOException {
  Writable clone;
  try {
    clone=original.getClass().asSubclass(Writable.class).newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  ByteArrayOutputStream bytes=new ByteArrayOutputStream();
  original.write(new DataOutputStream(bytes));
  clone.readFields(new DataInputStream(new ByteArrayInputStream(bytes.toByteArray())));
  return clone;
}",0.3493975903614458
61186,"@Override public void write(K key,V value){
  try {
    if (!(key instanceof NullWritable)) {
      K newKey=(K)key.getClass().newInstance();
      cloneWritable(key,newKey);
      key=newKey;
    }
    V newValue=(V)value.getClass().newInstance();
    cloneWritable(value,newValue);
    value=newValue;
  }
 catch (  InstantiationException e) {
    log.error(e.getMessage());
  }
catch (  IllegalAccessException e) {
    log.error(e.getMessage());
  }
catch (  IOException e) {
    log.error(e.getMessage());
  }
  List<V> points=data.get(key);
  if (points == null) {
    points=Lists.newArrayList();
    data.put(key,points);
  }
  points.add(value);
}","@Override public void write(K key,V value){
  try {
    K keyToUse=key instanceof NullWritable ? key : (K)cloneWritable(key);
    V valueToUse=(V)cloneWritable(value);
    keysInInsertionOrder.add(keyToUse);
    List<V> points=data.get(key);
    if (points == null) {
      points=Lists.newArrayList();
      data.put(keyToUse,points);
    }
    points.add(valueToUse);
  }
 catch (  IOException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}",0.2412241224122412
61187,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  Configuration conf=context.getConfiguration();
  int k=Integer.parseInt(conf.get(PROP_K));
  int p=Integer.parseInt(conf.get(PROP_P));
  kp=k + p;
  long omegaSeed=Long.parseLong(conf.get(PROP_OMEGA_SEED));
  omega=new Omega(omegaSeed,k + p);
  String sbPathStr=conf.get(PROP_SB_PATH);
  if (sbPathStr != null) {
    sb=SSVDHelper.loadAndSumUpVectors(new Path(sbPathStr),conf);
  }
  outputs=new MultipleOutputs(new JobConf(conf));
  closeables.addFirst(new Closeable(){
    @Override public void close() throws IOException {
      outputs.close();
    }
  }
);
  qHatKey=new SplitPartitionedWritable(context);
  rHatKey=new SplitPartitionedWritable(context);
  OutputCollector<Writable,DenseBlockWritable> qhatCollector=new OutputCollector<Writable,DenseBlockWritable>(){
    @Override @SuppressWarnings(""String_Node_Str"") public void collect(    Writable nil,    DenseBlockWritable dbw) throws IOException {
      outputs.getCollector(OUTPUT_QHAT,null).collect(qHatKey,dbw);
      qHatKey.incrementItemOrdinal();
    }
  }
;
  OutputCollector<Writable,VectorWritable> rhatCollector=new OutputCollector<Writable,VectorWritable>(){
    @Override @SuppressWarnings(""String_Node_Str"") public void collect(    Writable nil,    VectorWritable rhat) throws IOException {
      outputs.getCollector(OUTPUT_RHAT,null).collect(rHatKey,rhat);
      rHatKey.incrementItemOrdinal();
    }
  }
;
  qr=new QRFirstStep(conf,qhatCollector,rhatCollector);
  closeables.addFirst(qr);
  yRow=new DenseVector(kp);
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  Configuration conf=context.getConfiguration();
  int k=Integer.parseInt(conf.get(PROP_K));
  int p=Integer.parseInt(conf.get(PROP_P));
  kp=k + p;
  long omegaSeed=Long.parseLong(conf.get(PROP_OMEGA_SEED));
  omega=new Omega(omegaSeed,k + p);
  String sbPathStr=conf.get(PROP_SB_PATH);
  if (sbPathStr != null) {
    sb=SSVDHelper.loadAndSumUpVectors(new Path(sbPathStr),conf);
    if (sb == null)     throw new IOException(String.format(""String_Node_Str"",sbPathStr));
  }
  outputs=new MultipleOutputs(new JobConf(conf));
  closeables.addFirst(new Closeable(){
    @Override public void close() throws IOException {
      outputs.close();
    }
  }
);
  qHatKey=new SplitPartitionedWritable(context);
  rHatKey=new SplitPartitionedWritable(context);
  OutputCollector<Writable,DenseBlockWritable> qhatCollector=new OutputCollector<Writable,DenseBlockWritable>(){
    @Override @SuppressWarnings(""String_Node_Str"") public void collect(    Writable nil,    DenseBlockWritable dbw) throws IOException {
      outputs.getCollector(OUTPUT_QHAT,null).collect(qHatKey,dbw);
      qHatKey.incrementItemOrdinal();
    }
  }
;
  OutputCollector<Writable,VectorWritable> rhatCollector=new OutputCollector<Writable,VectorWritable>(){
    @Override @SuppressWarnings(""String_Node_Str"") public void collect(    Writable nil,    VectorWritable rhat) throws IOException {
      outputs.getCollector(OUTPUT_RHAT,null).collect(rHatKey,rhat);
      rHatKey.incrementItemOrdinal();
    }
  }
;
  qr=new QRFirstStep(conf,qhatCollector,rhatCollector);
  closeables.addFirst(qr);
  yRow=new DenseVector(kp);
}",0.9721627408993576
61188,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Path uHatPath=new Path(context.getConfiguration().get(PROP_UHAT_PATH));
  Path sigmaPath=new Path(context.getConfiguration().get(PROP_SIGMA_PATH));
  FileSystem fs=FileSystem.get(uHatPath.toUri(),context.getConfiguration());
  uHat=new DenseMatrix(SSVDHelper.loadDistributedRowMatrix(fs,uHatPath,context.getConfiguration()));
  kp=uHat.columnSize();
  k=context.getConfiguration().getInt(PROP_K,kp);
  uRow=new DenseVector(k);
  uRowWritable=new VectorWritable(uRow);
  SSVDSolver.OutputScalingEnum outputScaling=SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));
switch (outputScaling) {
case SIGMA:
    sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
  break;
case HALFSIGMA:
sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
sValues.assign(Functions.SQRT);
break;
default :
}
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Path uHatPath=new Path(context.getConfiguration().get(PROP_UHAT_PATH));
  Path sigmaPath=new Path(context.getConfiguration().get(PROP_SIGMA_PATH));
  FileSystem fs=FileSystem.get(uHatPath.toUri(),context.getConfiguration());
  uHat=SSVDHelper.drmLoadAsDense(fs,uHatPath,context.getConfiguration());
  kp=uHat.columnSize();
  k=context.getConfiguration().getInt(PROP_K,kp);
  uRow=new DenseVector(k);
  uRowWritable=new VectorWritable(uRow);
  SSVDSolver.OutputScalingEnum outputScaling=SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));
switch (outputScaling) {
case SIGMA:
    sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
  break;
case HALFSIGMA:
sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
sValues.assign(Functions.SQRT);
break;
default :
}
}",0.9621172807472756
61189,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Configuration conf=context.getConfiguration();
  FileSystem fs=FileSystem.get(conf);
  Path uHatPath=new Path(conf.get(PROP_UHAT_PATH));
  Path sigmaPath=new Path(conf.get(PROP_SIGMA_PATH));
  uHat=new DenseMatrix(SSVDHelper.loadDistributedRowMatrix(fs,uHatPath,conf));
  kp=uHat.columnSize();
  k=context.getConfiguration().getInt(PROP_K,kp);
  vRow=new DenseVector(k);
  vRowWritable=new VectorWritable(vRow);
  sValues=SSVDHelper.loadVector(sigmaPath,conf);
  SSVDSolver.OutputScalingEnum outputScaling=SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));
switch (outputScaling) {
case SIGMA:
    sValues.assign(1.0);
  break;
case HALFSIGMA:
sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
sValues.assign(Functions.SQRT);
break;
default :
}
String xiPathStr=conf.get(PROP_XI_PATH);
if (xiPathStr != null) {
xi=SSVDHelper.loadAndSumUpVectors(new Path(xiPathStr),conf);
sq=SSVDHelper.loadAndSumUpVectors(new Path(conf.get(PROP_SQ_PATH)),conf);
}
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Configuration conf=context.getConfiguration();
  FileSystem fs=FileSystem.get(conf);
  Path uHatPath=new Path(conf.get(PROP_UHAT_PATH));
  Path sigmaPath=new Path(conf.get(PROP_SIGMA_PATH));
  uHat=SSVDHelper.drmLoadAsDense(fs,uHatPath,conf);
  kp=uHat.columnSize();
  k=context.getConfiguration().getInt(PROP_K,kp);
  vRow=new DenseVector(k);
  vRowWritable=new VectorWritable(vRow);
  sValues=SSVDHelper.loadVector(sigmaPath,conf);
  SSVDSolver.OutputScalingEnum outputScaling=SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));
switch (outputScaling) {
case SIGMA:
    sValues.assign(1.0);
  break;
case HALFSIGMA:
sValues=SSVDHelper.loadVector(sigmaPath,context.getConfiguration());
sValues.assign(Functions.SQRT);
break;
default :
}
String xiPathStr=conf.get(PROP_XI_PATH);
if (xiPathStr != null) {
xi=SSVDHelper.loadAndSumUpVectors(new Path(xiPathStr),conf);
sq=SSVDHelper.loadAndSumUpVectors(new Path(conf.get(PROP_SQ_PATH)),conf);
}
}",0.967161493477283
61190,"@Override public double similarity(double dots,double normA,double normB,int numberOfColumns){
  double euclideanDistance=Math.sqrt(normA - 2 * dots + normB);
  return 1.0 / (1.0 + euclideanDistance);
}","@Override public double similarity(double dots,double normA,double normB,int numberOfColumns){
  double euclideanDistance=Math.sqrt(Math.max(0.0,normA - 2 * dots + normB));
  return 1.0 / (1.0 + euclideanDistance);
}",0.9665071770334928
61191,"public int numFeatures(){
  return userFeatures[0].length;
}","public int numFeatures(){
  return userFeatures.length > 0 ? userFeatures[0].length : 0;
}",0.8
61192,"@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(addOption(DefaultOptionCreator.overwriteOption().create()));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,String.valueOf(false)));
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,String.valueOf(false)));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  Map<String,List<String>> parsedArgs=parseArguments(args);
  if (parsedArgs == null) {
    return -1;
  }
  if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
    HadoopUtil.delete(getConf(),getOutputPath());
  }
  boolean complementary=parsedArgs.containsKey(""String_Node_Str"");
  boolean sequential=Boolean.parseBoolean(getOption(""String_Node_Str""));
  if (sequential) {
    FileSystem fs=FileSystem.get(getConf());
    NaiveBayesModel model=NaiveBayesModel.materialize(new Path(getOption(""String_Node_Str"")),getConf());
    AbstractNaiveBayesClassifier classifier;
    if (complementary) {
      classifier=new ComplementaryNaiveBayesClassifier(model);
    }
 else {
      classifier=new StandardNaiveBayesClassifier(model);
    }
    SequenceFile.Writer writer=new SequenceFile.Writer(fs,getConf(),getOutputPath(),Text.class,VectorWritable.class);
    SequenceFile.Reader reader=new Reader(fs,getInputPath(),getConf());
    Text key=new Text();
    VectorWritable vw=new VectorWritable();
    while (reader.next(key,vw)) {
      writer.append(new Text(key.toString().split(""String_Node_Str"")[1]),new VectorWritable(classifier.classifyFull(vw.get())));
    }
    writer.close();
    reader.close();
  }
 else {
    boolean succeeded=runMapReduce(parsedArgs);
    if (!succeeded) {
      return -1;
    }
  }
  Map<Integer,String> labelMap=BayesUtils.readLabelIndex(getConf(),new Path(getOption(""String_Node_Str"")));
  SequenceFileDirIterable<Text,VectorWritable> dirIterable=new SequenceFileDirIterable<Text,VectorWritable>(getOutputPath(),PathType.LIST,PathFilters.partFilter(),getConf());
  ResultAnalyzer analyzer=new ResultAnalyzer(labelMap.values(),""String_Node_Str"");
  analyzeResults(labelMap,dirIterable,analyzer);
  log.info(""String_Node_Str"",complementary ? ""String_Node_Str"" : ""String_Node_Str"",analyzer);
  return 0;
}","@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(addOption(DefaultOptionCreator.overwriteOption().create()));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,String.valueOf(false)));
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,String.valueOf(false)));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  Map<String,List<String>> parsedArgs=parseArguments(args);
  if (parsedArgs == null) {
    return -1;
  }
  if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
    HadoopUtil.delete(getConf(),getOutputPath());
  }
  boolean complementary=hasOption(""String_Node_Str"");
  boolean sequential=hasOption(""String_Node_Str"");
  if (sequential) {
    FileSystem fs=FileSystem.get(getConf());
    NaiveBayesModel model=NaiveBayesModel.materialize(new Path(getOption(""String_Node_Str"")),getConf());
    AbstractNaiveBayesClassifier classifier;
    if (complementary) {
      classifier=new ComplementaryNaiveBayesClassifier(model);
    }
 else {
      classifier=new StandardNaiveBayesClassifier(model);
    }
    SequenceFile.Writer writer=new SequenceFile.Writer(fs,getConf(),getOutputPath(),Text.class,VectorWritable.class);
    SequenceFile.Reader reader=new Reader(fs,getInputPath(),getConf());
    Text key=new Text();
    VectorWritable vw=new VectorWritable();
    while (reader.next(key,vw)) {
      writer.append(new Text(key.toString().split(""String_Node_Str"")[1]),new VectorWritable(classifier.classifyFull(vw.get())));
    }
    writer.close();
    reader.close();
  }
 else {
    boolean succeeded=runMapReduce(parsedArgs);
    if (!succeeded) {
      return -1;
    }
  }
  Map<Integer,String> labelMap=BayesUtils.readLabelIndex(getConf(),new Path(getOption(""String_Node_Str"")));
  SequenceFileDirIterable<Text,VectorWritable> dirIterable=new SequenceFileDirIterable<Text,VectorWritable>(getOutputPath(),PathType.LIST,PathFilters.partFilter(),getConf());
  ResultAnalyzer analyzer=new ResultAnalyzer(labelMap.values(),""String_Node_Str"");
  analyzeResults(labelMap,dirIterable,analyzer);
  log.info(""String_Node_Str"",complementary ? ""String_Node_Str"" : ""String_Node_Str"",analyzer);
  return 0;
}",0.9759493670886076
61193,"private void tred2(){
  d.assign(v.viewColumn(n - 1));
  for (int i=n - 1; i > 0; i--) {
    double scale=d.norm(1);
    double h=0.0;
    if (scale == 0.0) {
      e.setQuick(i,d.getQuick(i - 1));
      for (int j=0; j < i; j++) {
        d.setQuick(j,v.getQuick(i - 1,j));
        v.setQuick(i,j,0.0);
        v.setQuick(j,i,0.0);
      }
    }
 else {
      for (int k=0; k < i; k++) {
        d.setQuick(k,d.getQuick(k) / scale);
        h+=d.getQuick(k) * d.getQuick(k);
      }
      double f=d.getQuick(i - 1);
      double g=Math.sqrt(h);
      if (f > 0) {
        g=-g;
      }
      e.setQuick(i,scale * g);
      h=h - f * g;
      d.setQuick(i - 1,f - g);
      for (int j=0; j < i; j++) {
        e.setQuick(j,0.0);
      }
      for (int j=0; j < i; j++) {
        f=d.getQuick(j);
        v.setQuick(j,i,f);
        g=e.getQuick(j) + v.getQuick(j,j) * f;
        for (int k=j + 1; k <= i - 1; k++) {
          g+=v.getQuick(k,j) * d.getQuick(k);
          e.setQuick(k,e.getQuick(k) + v.getQuick(k,j) * f);
        }
        e.setQuick(j,g);
      }
      f=0.0;
      for (int j=0; j < i; j++) {
        e.setQuick(j,e.getQuick(j) / h);
        f+=e.getQuick(j) * d.getQuick(j);
      }
      double hh=f / (h + h);
      for (int j=0; j < i; j++) {
        e.setQuick(j,e.getQuick(j) - hh * d.getQuick(j));
      }
      for (int j=0; j < i; j++) {
        f=d.getQuick(j);
        g=e.getQuick(j);
        for (int k=j; k <= i - 1; k++) {
          v.setQuick(k,j,v.getQuick(k,j) - (f * e.getQuick(k) + g * d.getQuick(k)));
        }
        d.setQuick(j,v.getQuick(i - 1,j));
        v.setQuick(i,j,0.0);
      }
    }
    d.setQuick(i,h);
  }
  for (int i=0; i < n - 1; i++) {
    v.setQuick(n - 1,i,v.getQuick(i,i));
    v.setQuick(i,i,1.0);
    double h=d.getQuick(i + 1);
    if (h != 0.0) {
      for (int k=0; k <= i; k++) {
        d.setQuick(k,v.getQuick(k,i + 1) / h);
      }
      for (int j=0; j <= i; j++) {
        double g=0.0;
        for (int k=0; k <= i; k++) {
          g+=v.getQuick(k,i + 1) * v.getQuick(k,j);
        }
        for (int k=0; k <= i; k++) {
          v.setQuick(k,j,v.getQuick(k,j) - g * d.getQuick(k));
        }
      }
    }
    for (int k=0; k <= i; k++) {
      v.setQuick(k,i + 1,0.0);
    }
  }
  d.assign(v.viewRow(n - 1));
  v.viewRow(n - 1).assign(0);
  v.setQuick(n - 1,n - 1,1.0);
  e.setQuick(0,0.0);
}","private void tred2(){
  d.assign(v.viewColumn(n - 1));
  for (int i=n - 1; i > 0; i--) {
    double scale=d.viewPart(0,i).norm(1);
    double h=0.0;
    if (scale == 0.0) {
      e.setQuick(i,d.getQuick(i - 1));
      for (int j=0; j < i; j++) {
        d.setQuick(j,v.getQuick(i - 1,j));
        v.setQuick(i,j,0.0);
        v.setQuick(j,i,0.0);
      }
    }
 else {
      for (int k=0; k < i; k++) {
        d.setQuick(k,d.getQuick(k) / scale);
        h+=d.getQuick(k) * d.getQuick(k);
      }
      double f=d.getQuick(i - 1);
      double g=Math.sqrt(h);
      if (f > 0) {
        g=-g;
      }
      e.setQuick(i,scale * g);
      h=h - f * g;
      d.setQuick(i - 1,f - g);
      for (int j=0; j < i; j++) {
        e.setQuick(j,0.0);
      }
      for (int j=0; j < i; j++) {
        f=d.getQuick(j);
        v.setQuick(j,i,f);
        g=e.getQuick(j) + v.getQuick(j,j) * f;
        for (int k=j + 1; k <= i - 1; k++) {
          g+=v.getQuick(k,j) * d.getQuick(k);
          e.setQuick(k,e.getQuick(k) + v.getQuick(k,j) * f);
        }
        e.setQuick(j,g);
      }
      f=0.0;
      for (int j=0; j < i; j++) {
        e.setQuick(j,e.getQuick(j) / h);
        f+=e.getQuick(j) * d.getQuick(j);
      }
      double hh=f / (h + h);
      for (int j=0; j < i; j++) {
        e.setQuick(j,e.getQuick(j) - hh * d.getQuick(j));
      }
      for (int j=0; j < i; j++) {
        f=d.getQuick(j);
        g=e.getQuick(j);
        for (int k=j; k <= i - 1; k++) {
          v.setQuick(k,j,v.getQuick(k,j) - (f * e.getQuick(k) + g * d.getQuick(k)));
        }
        d.setQuick(j,v.getQuick(i - 1,j));
        v.setQuick(i,j,0.0);
      }
    }
    d.setQuick(i,h);
  }
  for (int i=0; i < n - 1; i++) {
    v.setQuick(n - 1,i,v.getQuick(i,i));
    v.setQuick(i,i,1.0);
    double h=d.getQuick(i + 1);
    if (h != 0.0) {
      for (int k=0; k <= i; k++) {
        d.setQuick(k,v.getQuick(k,i + 1) / h);
      }
      for (int j=0; j <= i; j++) {
        double g=0.0;
        for (int k=0; k <= i; k++) {
          g+=v.getQuick(k,i + 1) * v.getQuick(k,j);
        }
        for (int k=0; k <= i; k++) {
          v.setQuick(k,j,v.getQuick(k,j) - g * d.getQuick(k));
        }
      }
    }
    for (int k=0; k <= i; k++) {
      v.setQuick(k,i + 1,0.0);
    }
  }
  d.assign(v.viewRow(n - 1));
  v.viewRow(n - 1).assign(0);
  v.setQuick(n - 1,n - 1,1.0);
  e.setQuick(0,0.0);
}",0.9970588235294118
61194,"/** 
 * Populates a list with clusters present in clusters-*-final directory.
 * @param clusterOutputPath The output path of the clustering.
 * @param conf The Hadoop Configuration
 * @return The list of clusters found by the clustering.
 * @throws IOException
 */
private static List<Cluster> populateClusterModels(Path clusterOutputPath,Configuration conf) throws IOException {
  List<Cluster> clusterModels=new ArrayList<Cluster>();
  Cluster cluster=null;
  Path finalClustersPath=finalClustersPath(conf,clusterOutputPath);
  Iterator<?> it=new SequenceFileDirValueIterator<Writable>(finalClustersPath,PathType.LIST,PathFilters.partFilter(),null,false,conf);
  while (it.hasNext()) {
    ClusterWritable next=(ClusterWritable)it.next();
    cluster=(Cluster)next.getValue();
    if (cluster instanceof DirichletCluster) {
      ((DirichletCluster)cluster).getModel().configure(conf);
    }
    clusterModels.add(cluster);
  }
  return clusterModels;
}","/** 
 * Populates a list with clusters present in clusters-*-final directory.
 * @param clusterOutputPath The output path of the clustering.
 * @param conf The Hadoop Configuration
 * @return The list of clusters found by the clustering.
 * @throws IOException
 */
private static List<Cluster> populateClusterModels(Path clusterOutputPath,Configuration conf) throws IOException {
  List<Cluster> clusterModels=new ArrayList<Cluster>();
  Cluster cluster=null;
  Path finalClustersPath=finalClustersPath(conf,clusterOutputPath);
  Iterator<?> it=new SequenceFileDirValueIterator<Writable>(finalClustersPath,PathType.LIST,PathFilters.partFilter(),null,false,conf);
  while (it.hasNext()) {
    ClusterWritable next=(ClusterWritable)it.next();
    cluster=(Cluster)next.getValue();
    cluster.configure(conf);
    clusterModels.add(cluster);
  }
  return clusterModels;
}",0.9385964912280702
61195,"public static List<Cluster> populateClusterModels(Path clusterOutputPath,Configuration conf) throws IOException {
  List<Cluster> clusters=new ArrayList<Cluster>();
  Cluster cluster=null;
  FileSystem fileSystem=clusterOutputPath.getFileSystem(conf);
  FileStatus[] clusterFiles=fileSystem.listStatus(clusterOutputPath,PathFilters.finalPartFilter());
  Iterator<?> it=new SequenceFileDirValueIterator<Writable>(clusterFiles[0].getPath(),PathType.LIST,PathFilters.partFilter(),null,false,conf);
  while (it.hasNext()) {
    ClusterWritable next=(ClusterWritable)it.next();
    cluster=next.getValue();
    if (cluster instanceof DirichletCluster) {
      ((DirichletCluster)cluster).getModel().configure(conf);
    }
    clusters.add(cluster);
  }
  return clusters;
}","public static List<Cluster> populateClusterModels(Path clusterOutputPath,Configuration conf) throws IOException {
  List<Cluster> clusters=new ArrayList<Cluster>();
  Cluster cluster=null;
  FileSystem fileSystem=clusterOutputPath.getFileSystem(conf);
  FileStatus[] clusterFiles=fileSystem.listStatus(clusterOutputPath,PathFilters.finalPartFilter());
  Iterator<?> it=new SequenceFileDirValueIterator<Writable>(clusterFiles[0].getPath(),PathType.LIST,PathFilters.partFilter(),null,false,conf);
  while (it.hasNext()) {
    ClusterWritable next=(ClusterWritable)it.next();
    cluster=next.getValue();
    cluster.configure(conf);
    clusters.add(cluster);
  }
  return clusters;
}",0.9089655172413792
61196,"public void readFromSeqFiles(Path path) throws IOException {
  Configuration config=new Configuration();
  List<Cluster> clusters=Lists.newArrayList();
  for (  ClusterWritable cw : new SequenceFileDirValueIterable<ClusterWritable>(path,PathType.LIST,PathFilters.logsCRCFilter(),config)) {
    clusters.add(cw.getValue());
  }
  this.models=clusters;
  modelClass=models.get(0).getClass().getName();
  this.policy=readPolicy(path);
}","public void readFromSeqFiles(Configuration conf,Path path) throws IOException {
  Configuration config=new Configuration();
  List<Cluster> clusters=Lists.newArrayList();
  for (  ClusterWritable cw : new SequenceFileDirValueIterable<ClusterWritable>(path,PathType.LIST,PathFilters.logsCRCFilter(),config)) {
    Cluster cluster=cw.getValue();
    cluster.configure(conf);
    clusters.add(cluster);
  }
  this.models=clusters;
  modelClass=models.get(0).getClass().getName();
  this.policy=readPolicy(path);
}",0.8907741251325557
61197,"@Override public Vector classify(Vector instance){
  Vector score=model.createScoringVector();
  for (int label=0; label < model.numLabels(); label++) {
    score.set(label,getScoreForLabelInstance(label,instance));
  }
  return score;
}","@Override public Vector classify(Vector instance){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.4102564102564102
61198,"protected double getScoreForLabelInstance(int label,Vector instance){
  double result=0.0;
  Iterator<Element> elements=instance.iterateNonZero();
  while (elements.hasNext()) {
    result+=getScoreForLabelFeature(label,elements.next().index());
  }
  return result / model.thetaNormalizer(label);
}","protected double getScoreForLabelInstance(int label,Vector instance){
  double result=0.0;
  Iterator<Element> elements=instance.iterateNonZero();
  while (elements.hasNext()) {
    Element e=elements.next();
    result+=e.get() * getScoreForLabelFeature(label,e.index());
  }
  return result / model.thetaNormalizer(label);
}",0.8992
61199,"public static NaiveBayesModel materialize(Path output,Configuration conf) throws IOException {
  FileSystem fs=output.getFileSystem(conf);
  Vector weightsPerLabel=null;
  Vector perLabelThetaNormalizer=null;
  Vector weightsPerFeature=null;
  Matrix weightsPerLabelAndFeature;
  float alphaI;
  FSDataInputStream in=fs.open(new Path(output,""String_Node_Str""));
  try {
    alphaI=in.readFloat();
    weightsPerFeature=VectorWritable.readVector(in);
    weightsPerLabel=VectorWritable.readVector(in);
    perLabelThetaNormalizer=VectorWritable.readVector(in);
    weightsPerLabelAndFeature=new SparseMatrix(weightsPerLabel.size(),weightsPerFeature.size());
    for (int label=0; label < weightsPerLabelAndFeature.numRows(); label++) {
      weightsPerLabelAndFeature.assignRow(label,VectorWritable.readVector(in));
    }
  }
  finally {
    Closeables.closeQuietly(in);
  }
  NaiveBayesModel model=new NaiveBayesModel(weightsPerLabelAndFeature,weightsPerFeature,weightsPerLabel,perLabelThetaNormalizer,alphaI);
  model.validate();
  return model;
}","public static NaiveBayesModel materialize(Path output,Configuration conf) throws IOException {
  FileSystem fs=output.getFileSystem(conf);
  Vector weightsPerLabel=null;
  Vector perLabelThetaNormalizer=null;
  Vector weightsPerFeature=null;
  Matrix weightsPerLabelAndFeature;
  float alphaI;
  FSDataInputStream in=fs.open(new Path(output,""String_Node_Str""));
  try {
    alphaI=in.readFloat();
    weightsPerFeature=VectorWritable.readVector(in);
    weightsPerLabel=new DenseVector(VectorWritable.readVector(in));
    perLabelThetaNormalizer=new DenseVector(VectorWritable.readVector(in));
    weightsPerLabelAndFeature=new SparseRowMatrix(weightsPerLabel.size(),weightsPerFeature.size());
    for (int label=0; label < weightsPerLabelAndFeature.numRows(); label++) {
      weightsPerLabelAndFeature.assignRow(label,VectorWritable.readVector(in));
    }
  }
  finally {
    Closeables.closeQuietly(in);
  }
  NaiveBayesModel model=new NaiveBayesModel(weightsPerLabelAndFeature,weightsPerFeature,weightsPerLabel,perLabelThetaNormalizer,alphaI);
  model.validate();
  return model;
}",0.9826535396155648
61200,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  Configuration conf=context.getConfiguration();
  Path modelPath=HadoopUtil.cachedFile(conf);
  NaiveBayesModel model=NaiveBayesModel.materialize(modelPath,conf);
  boolean compl=Boolean.parseBoolean(conf.get(TestNaiveBayesDriver.COMPLEMENTARY));
  if (compl) {
    classifier=new ComplementaryNaiveBayesClassifier(model);
  }
 else {
    classifier=new StandardNaiveBayesClassifier(model);
  }
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  System.out.println(""String_Node_Str"");
  Configuration conf=context.getConfiguration();
  Path modelPath=HadoopUtil.cachedFile(conf);
  NaiveBayesModel model=NaiveBayesModel.materialize(modelPath,conf);
  boolean compl=Boolean.parseBoolean(conf.get(TestNaiveBayesDriver.COMPLEMENTARY));
  if (compl) {
    classifier=new ComplementaryNaiveBayesClassifier(model);
  }
 else {
    classifier=new StandardNaiveBayesClassifier(model);
  }
}",0.9375600384245918
61201,"@Override protected void map(Text key,VectorWritable value,Context context) throws IOException, InterruptedException {
  Vector result=classifier.classify(value.get());
  context.write(key,new VectorWritable(result));
}","@Override protected void map(Text key,VectorWritable value,Context context) throws IOException, InterruptedException {
  Vector result=classifier.classifyFull(value.get());
  context.write(key,new VectorWritable(result));
}",0.990950226244344
61202,"@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(addOption(DefaultOptionCreator.overwriteOption().create()));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,String.valueOf(false)));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  Map<String,List<String>> parsedArgs=parseArguments(args);
  if (parsedArgs == null) {
    return -1;
  }
  if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
    HadoopUtil.delete(getConf(),getOutputPath());
  }
  Path model=new Path(getOption(""String_Node_Str""));
  HadoopUtil.cacheFiles(model,getConf());
  Job testJob=prepareJob(getInputPath(),getOutputPath(),SequenceFileInputFormat.class,BayesTestMapper.class,Text.class,VectorWritable.class,SequenceFileOutputFormat.class);
  boolean complementary=parsedArgs.containsKey(""String_Node_Str"");
  testJob.getConfiguration().set(COMPLEMENTARY,String.valueOf(complementary));
  boolean succeeded=testJob.waitForCompletion(true);
  if (!succeeded) {
    return -1;
  }
  Map<Integer,String> labelMap=BayesUtils.readLabelIndex(getConf(),new Path(getOption(""String_Node_Str"")));
  SequenceFileDirIterable<Text,VectorWritable> dirIterable=new SequenceFileDirIterable<Text,VectorWritable>(getOutputPath(),PathType.LIST,PathFilters.partFilter(),getConf());
  ResultAnalyzer analyzer=new ResultAnalyzer(labelMap.values(),""String_Node_Str"");
  analyzeResults(labelMap,dirIterable,analyzer);
  log.info(""String_Node_Str"",complementary ? ""String_Node_Str"" : ""String_Node_Str"",analyzer);
  return 0;
}","@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(addOption(DefaultOptionCreator.overwriteOption().create()));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,String.valueOf(false)));
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,String.valueOf(false)));
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true);
  Map<String,List<String>> parsedArgs=parseArguments(args);
  if (parsedArgs == null) {
    return -1;
  }
  if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
    HadoopUtil.delete(getConf(),getOutputPath());
  }
  boolean complementary=parsedArgs.containsKey(""String_Node_Str"");
  boolean sequential=Boolean.parseBoolean(getOption(""String_Node_Str""));
  if (sequential) {
    FileSystem fs=FileSystem.get(getConf());
    NaiveBayesModel model=NaiveBayesModel.materialize(new Path(getOption(""String_Node_Str"")),getConf());
    AbstractNaiveBayesClassifier classifier;
    if (complementary) {
      classifier=new ComplementaryNaiveBayesClassifier(model);
    }
 else {
      classifier=new StandardNaiveBayesClassifier(model);
    }
    SequenceFile.Writer writer=new SequenceFile.Writer(fs,getConf(),getOutputPath(),Text.class,VectorWritable.class);
    SequenceFile.Reader reader=new Reader(fs,getInputPath(),getConf());
    Text key=new Text();
    VectorWritable vw=new VectorWritable();
    while (reader.next(key,vw)) {
      writer.append(key,new VectorWritable(classifier.classifyFull(vw.get())));
    }
    writer.close();
    reader.close();
  }
 else {
    boolean succeeded=runMapReduce(parsedArgs);
    if (!succeeded) {
      return -1;
    }
  }
  Map<Integer,String> labelMap=BayesUtils.readLabelIndex(getConf(),new Path(getOption(""String_Node_Str"")));
  SequenceFileDirIterable<Text,VectorWritable> dirIterable=new SequenceFileDirIterable<Text,VectorWritable>(getOutputPath(),PathType.LIST,PathFilters.partFilter(),getConf());
  ResultAnalyzer analyzer=new ResultAnalyzer(labelMap.values(),""String_Node_Str"");
  analyzeResults(labelMap,dirIterable,analyzer);
  log.info(""String_Node_Str"",complementary ? ""String_Node_Str"" : ""String_Node_Str"",analyzer);
  return 0;
}",0.6439412789251058
61203,"@Override protected void map(IntWritable key,MultiLabelVectorWritable instance,Context ctx) throws IOException, InterruptedException {
  VectorWritable vw=new VectorWritable(instance.getVector());
  ctx.write(new IntWritable(instance.getLabels()[0]),vw);
}","@Override protected void map(Text labelText,VectorWritable instance,Context ctx) throws IOException, InterruptedException {
  String label=labelText.toString();
  if (labelIndex.containsKey(label)) {
    ctx.write(new IntWritable(labelIndex.get(label)),instance);
  }
 else {
    ctx.getCounter(Counter.SKIPPED_INSTANCES).increment(1);
  }
}",0.4589614740368509
61204,"@Override public void train(int label,Vector instance){
  double weight=Math.log((instance.zSum() + alphaI()) / (labelWeight(label) + alphaI() * numFeatures()));
  updatePerLabelThetaNormalizer(label,weight);
}","@Override public void train(int label,Vector instance){
  double sigmaK=labelWeight(label);
  Iterator<Vector.Element> it=instance.iterateNonZero();
  while (it.hasNext()) {
    Vector.Element e=it.next();
    double numerator=e.get() + alphaI();
    double denominator=sigmaK + alphaI() * numFeatures();
    double weight=Math.log(numerator / denominator);
    updatePerLabelThetaNormalizer(label,weight);
  }
}",0.4244372990353697
61205,"@Override protected void cleanup(Context ctx) throws IOException, InterruptedException {
  ctx.write(new Text(TrainNaiveBayesJob.LABEL_THETA_NORMALIZER),new VectorWritable(trainer.retrievePerLabelThetaNormalizer()));
}","@Override protected void cleanup(Context ctx) throws IOException, InterruptedException {
  ctx.write(new Text(TrainNaiveBayesJob.LABEL_THETA_NORMALIZER),new VectorWritable(trainer.retrievePerLabelThetaNormalizer()));
  super.cleanup(ctx);
}",0.9519650655021834
61206,"@Override protected void setup(Context ctx) throws IOException, InterruptedException {
  Configuration conf=ctx.getConfiguration();
  float alphaI=conf.getFloat(ALPHA_I,1.0f);
  Map<String,Vector> scores=BayesUtils.readScoresFromCache(conf);
  if (conf.getBoolean(TRAIN_COMPLEMENTARY,false)) {
    trainer=new ComplementaryThetaTrainer(scores.get(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE),scores.get(TrainNaiveBayesJob.WEIGHTS_PER_LABEL),alphaI);
  }
 else {
    trainer=new StandardThetaTrainer(scores.get(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE),scores.get(TrainNaiveBayesJob.WEIGHTS_PER_LABEL),alphaI);
  }
}","@Override protected void setup(Context ctx) throws IOException, InterruptedException {
  super.setup(ctx);
  Configuration conf=ctx.getConfiguration();
  float alphaI=conf.getFloat(ALPHA_I,1.0f);
  Map<String,Vector> scores=BayesUtils.readScoresFromCache(conf);
  if (conf.getBoolean(TRAIN_COMPLEMENTARY,false)) {
    trainer=new ComplementaryThetaTrainer(scores.get(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE),scores.get(TrainNaiveBayesJob.WEIGHTS_PER_LABEL),alphaI);
  }
 else {
    trainer=new StandardThetaTrainer(scores.get(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE),scores.get(TrainNaiveBayesJob.WEIGHTS_PER_LABEL),alphaI);
  }
}",0.9838187702265372
61207,"@Override public void write(Cluster cluster) throws IOException {
  StringBuilder line=new StringBuilder();
  line.append(createNode(String.valueOf(cluster.getId())));
  List<WeightedVectorWritable> points=getClusterIdToPoints().get(cluster.getId());
  if (points != null) {
    for (    WeightedVectorWritable point : points) {
      Vector theVec=point.getVector();
      String vecStr;
      if (theVec instanceof NamedVector) {
        vecStr=((NamedVector)theVec).getName();
        line.append(createNode(vecStr));
      }
 else {
        vecStr=theVec.asFormatString();
        vecStr=VEC_PATTERN.matcher(vecStr).replaceAll(""String_Node_Str"");
        line.append(createNode(vecStr));
      }
      line.append(createEdge(String.valueOf(cluster.getId()),vecStr));
    }
    getWriter().append(line).append(""String_Node_Str"");
  }
}","@Override public void write(Cluster cluster) throws IOException {
  StringBuilder line=new StringBuilder();
  line.append(createNode(String.valueOf(cluster.getId())));
  List<WeightedVectorWritable> points=getClusterIdToPoints().get(cluster.getId());
  if (points != null) {
    for (    WeightedVectorWritable point : points) {
      Vector theVec=point.getVector();
      String vecStr;
      if (theVec instanceof NamedVector) {
        vecStr=((NamedVector)theVec).getName();
        line.append(createNode(vecStr));
      }
 else {
        vecStr=theVec.asFormatString();
        vecStr=VEC_PATTERN.matcher(vecStr).replaceAll(""String_Node_Str"");
        line.append(createNode(vecStr));
      }
      line.append(createEdge(String.valueOf(cluster.getId()),vecStr));
    }
  }
  getWriter().append(line).append(""String_Node_Str"");
}",0.996415770609319
61208,"@Override public void map(IntWritable docId,VectorWritable document,Context context) throws IOException, InterruptedException {
  Vector topicVector=new DenseVector(new double[numTopics]).assign(1 / numTopics);
  modelTrainer.train(document.get(),topicVector,true,maxIters);
}","@Override public void map(IntWritable docId,VectorWritable document,Context context) throws IOException, InterruptedException {
  Vector topicVector=new DenseVector(new double[numTopics]).assign(1.0 / numTopics);
  modelTrainer.train(document.get(),topicVector,true,maxIters);
}",0.9963898916967509
61209,"public static Pair<Matrix,Vector> loadModel(Configuration conf,Path... modelPaths) throws IOException {
  int numTopics=-1;
  int numTerms=-1;
  List<Pair<Integer,Vector>> rows=Lists.newArrayList();
  for (  Path modelPath : modelPaths) {
    for (    Pair<IntWritable,VectorWritable> row : new SequenceFileIterable<IntWritable,VectorWritable>(modelPath,true,conf)) {
      rows.add(Pair.of(row.getFirst().get(),row.getSecond().get()));
      numTopics=Math.max(numTopics,row.getFirst().get());
      if (numTerms < 0) {
        numTerms=row.getSecond().get().size();
      }
    }
  }
  if (rows.isEmpty()) {
    throw new IOException(modelPaths + ""String_Node_Str"");
  }
  numTopics++;
  Matrix model=new DenseMatrix(numTopics,numTerms);
  Vector topicSums=new DenseVector(numTopics);
  for (  Pair<Integer,Vector> pair : rows) {
    model.viewRow(pair.getFirst()).assign(pair.getSecond());
    topicSums.set(pair.getFirst(),pair.getSecond().norm(1));
  }
  return Pair.of(model,topicSums);
}","public static Pair<Matrix,Vector> loadModel(Configuration conf,Path... modelPaths) throws IOException {
  int numTopics=-1;
  int numTerms=-1;
  List<Pair<Integer,Vector>> rows=Lists.newArrayList();
  for (  Path modelPath : modelPaths) {
    for (    Pair<IntWritable,VectorWritable> row : new SequenceFileIterable<IntWritable,VectorWritable>(modelPath,true,conf)) {
      rows.add(Pair.of(row.getFirst().get(),row.getSecond().get()));
      numTopics=Math.max(numTopics,row.getFirst().get());
      if (numTerms < 0) {
        numTerms=row.getSecond().get().size();
      }
    }
  }
  if (rows.isEmpty()) {
    throw new IOException(Arrays.toString(modelPaths) + ""String_Node_Str"");
  }
  numTopics++;
  Matrix model=new DenseMatrix(numTopics,numTerms);
  Vector topicSums=new DenseVector(numTopics);
  for (  Pair<Integer,Vector> pair : rows) {
    model.viewRow(pair.getFirst()).assign(pair.getSecond());
    topicSums.set(pair.getFirst(),pair.getSecond().norm(1));
  }
  return Pair.of(model,topicSums);
}",0.9915211970074812
61210,"public String toString(){
  String buf=""String_Node_Str"";
  for (int x=0; x < numTopics; x++) {
    String v=dictionary != null ? vectorToSortedString(topicTermCounts.viewRow(x).normalize(1),dictionary) : topicTermCounts.viewRow(x).asFormatString();
    buf+=v + ""String_Node_Str"";
  }
  return buf;
}","@Override public String toString(){
  String buf=""String_Node_Str"";
  for (int x=0; x < numTopics; x++) {
    String v=dictionary != null ? vectorToSortedString(topicTermCounts.viewRow(x).normalize(1),dictionary) : topicTermCounts.viewRow(x).asFormatString();
    buf+=v + ""String_Node_Str"";
  }
  return buf;
}",0.9836601307189542
61211,"private static List<Path> createDictionaryChunks(Path inputPath,Path dictionaryPathBase,String name,Configuration baseConf,int chunkSizeInMegabytes,int[] maxTermDimension) throws IOException {
  List<Path> chunkPaths=Lists.newArrayList();
  Configuration conf=new Configuration(baseConf);
  FileSystem fs=FileSystem.get(inputPath.toUri(),conf);
  long chunkSizeLimit=chunkSizeInMegabytes * 1024L * 1024L;
  int chunkIndex=0;
  Path chunkPath=new Path(dictionaryPathBase,name + chunkIndex);
  chunkPaths.add(chunkPath);
  SequenceFile.Writer dictWriter=new SequenceFile.Writer(fs,conf,chunkPath,Text.class,IntWritable.class);
  try {
    long currentChunkSize=0;
    Path filesPattern=new Path(inputPath,OUTPUT_FILES_PATTERN);
    int i=0;
    for (    Pair<Writable,Writable> record : new SequenceFileDirIterable<Writable,Writable>(filesPattern,PathType.GLOB,null,null,true,conf)) {
      if (currentChunkSize > chunkSizeLimit) {
        Closeables.closeQuietly(dictWriter);
        chunkIndex++;
        chunkPath=new Path(dictionaryPathBase,name + chunkIndex);
        chunkPaths.add(chunkPath);
        dictWriter=new SequenceFile.Writer(fs,conf,chunkPath,Text.class,IntWritable.class);
        currentChunkSize=0;
      }
      Writable key=record.getFirst();
      int fieldSize=DICTIONARY_BYTE_OVERHEAD + key.toString().length() * 2 + Integer.SIZE / 8;
      currentChunkSize+=fieldSize;
      dictWriter.append(key,new IntWritable(i++));
    }
    maxTermDimension[0]=i;
  }
  finally {
    Closeables.closeQuietly(dictWriter);
  }
  return chunkPaths;
}","private static List<Path> createDictionaryChunks(Path inputPath,Path dictionaryPathBase,String name,Configuration baseConf,int chunkSizeInMegabytes,int[] maxTermDimension) throws IOException {
  List<Path> chunkPaths=Lists.newArrayList();
  Configuration conf=new Configuration(baseConf);
  FileSystem fs=FileSystem.get(inputPath.toUri(),conf);
  long chunkSizeLimit=chunkSizeInMegabytes * 1024L * 1024L;
  int chunkIndex=0;
  Path chunkPath=new Path(dictionaryPathBase,name + chunkIndex);
  chunkPaths.add(chunkPath);
  SequenceFile.Writer dictWriter=new SequenceFile.Writer(fs,conf,chunkPath,Text.class,IntWritable.class);
  try {
    long currentChunkSize=0;
    Path filesPattern=new Path(inputPath,OUTPUT_FILES_PATTERN);
    int i=1;
    for (    Pair<Writable,Writable> record : new SequenceFileDirIterable<Writable,Writable>(filesPattern,PathType.GLOB,null,null,true,conf)) {
      if (currentChunkSize > chunkSizeLimit) {
        Closeables.closeQuietly(dictWriter);
        chunkIndex++;
        chunkPath=new Path(dictionaryPathBase,name + chunkIndex);
        chunkPaths.add(chunkPath);
        dictWriter=new SequenceFile.Writer(fs,conf,chunkPath,Text.class,IntWritable.class);
        currentChunkSize=0;
      }
      Writable key=record.getFirst();
      int fieldSize=DICTIONARY_BYTE_OVERHEAD + key.toString().length() * 2 + Integer.SIZE / 8;
      currentChunkSize+=fieldSize;
      dictWriter.append(key,new IntWritable(i++));
    }
    maxTermDimension[0]=i;
  }
  finally {
    Closeables.closeQuietly(dictWriter);
  }
  return chunkPaths;
}",0.9993593850096092
61212,"@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(DefaultOptionCreator.overwriteOption().create());
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> parsedArgs=parseArguments(args);
  Path input=getInputPath();
  Path output=getOutputPath();
  int chunkSize=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  String separator=parsedArgs.get(""String_Node_Str"");
  Configuration conf=getConf();
  if (conf == null) {
    setConf(new Configuration());
    conf=getConf();
  }
  AtomicInteger currentPhase=new AtomicInteger();
  int[] msgDim=new int[1];
  List<Path> msgIdChunks=null;
  boolean overwrite=hasOption(DefaultOptionCreator.OVERWRITE_OPTION);
  if (shouldRunNextPhase(parsedArgs,currentPhase)) {
    Path msgIdsPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,msgIdsPath);
    }
    log.info(""String_Node_Str"");
    Job createMsgIdDictionary=prepareJob(input,msgIdsPath,SequenceFileInputFormat.class,MsgIdToDictionaryMapper.class,Text.class,VarIntWritable.class,MailToDictionaryReducer.class,Text.class,VarIntWritable.class,SequenceFileOutputFormat.class);
    createMsgIdDictionary.waitForCompletion(true);
    msgIdChunks=createDictionaryChunks(msgIdsPath,output,""String_Node_Str"",createMsgIdDictionary.getConfiguration(),chunkSize,msgDim);
  }
  List<Path> fromChunks=null;
  if (shouldRunNextPhase(parsedArgs,currentPhase)) {
    Path fromIdsPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,fromIdsPath);
    }
    log.info(""String_Node_Str"");
    Job createFromIdDictionary=prepareJob(input,fromIdsPath,SequenceFileInputFormat.class,FromEmailToDictionaryMapper.class,Text.class,VarIntWritable.class,MailToDictionaryReducer.class,Text.class,VarIntWritable.class,SequenceFileOutputFormat.class);
    createFromIdDictionary.getConfiguration().set(EmailUtility.SEPARATOR,separator);
    createFromIdDictionary.waitForCompletion(true);
    int[] fromDim=new int[1];
    fromChunks=createDictionaryChunks(fromIdsPath,output,""String_Node_Str"",createFromIdDictionary.getConfiguration(),chunkSize,fromDim);
  }
  if (shouldRunNextPhase(parsedArgs,currentPhase) && fromChunks != null && msgIdChunks != null) {
    log.info(""String_Node_Str"");
    Path vecPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,vecPath);
    }
    conf.set(EmailUtility.MSG_ID_DIMENSION,String.valueOf(msgDim[0]));
    conf.set(EmailUtility.FROM_PREFIX,""String_Node_Str"");
    conf.set(EmailUtility.MSG_IDS_PREFIX,""String_Node_Str"");
    conf.set(EmailUtility.FROM_INDEX,parsedArgs.get(""String_Node_Str""));
    conf.set(EmailUtility.REFS_INDEX,parsedArgs.get(""String_Node_Str""));
    conf.set(EmailUtility.SEPARATOR,separator);
    int j=0;
    int i=0;
    for (    Path fromChunk : fromChunks) {
      for (      Path idChunk : msgIdChunks) {
        Path out=new Path(vecPath,""String_Node_Str"" + i + '-'+ j);
        DistributedCache.setCacheFiles(new URI[]{fromChunk.toUri(),idChunk.toUri()},conf);
        Job createRecMatrix=prepareJob(input,out,SequenceFileInputFormat.class,MailToRecMapper.class,NullWritable.class,Text.class,TextOutputFormat.class);
        createRecMatrix.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
        createRecMatrix.waitForCompletion(true);
        FileStatus[] fs=HadoopUtil.getFileStatus(new Path(out,""String_Node_Str""),PathType.GLOB,PathFilters.partFilter(),null,conf);
        for (int k=0; k < fs.length; k++) {
          FileStatus f=fs[k];
          Path outPath=new Path(vecPath,""String_Node_Str"" + i + '-'+ j+ '-'+ k);
          FileUtil.copy(f.getPath().getFileSystem(conf),f.getPath(),outPath.getFileSystem(conf),outPath,true,overwrite,conf);
        }
        HadoopUtil.delete(conf,out);
        j++;
      }
      i++;
    }
  }
  return 0;
}","@Override public int run(String[] args) throws Exception {
  addInputOption();
  addOutputOption();
  addOption(DefaultOptionCreator.overwriteOption().create());
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addOption(buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str""));
  Map<String,String> parsedArgs=parseArguments(args);
  Path input=getInputPath();
  Path output=getOutputPath();
  int chunkSize=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  String separator=parsedArgs.get(""String_Node_Str"");
  Configuration conf=getConf();
  if (conf == null) {
    setConf(new Configuration());
    conf=getConf();
  }
  boolean useCounts=hasOption(""String_Node_Str"");
  AtomicInteger currentPhase=new AtomicInteger();
  int[] msgDim=new int[1];
  List<Path> msgIdChunks=null;
  boolean overwrite=hasOption(DefaultOptionCreator.OVERWRITE_OPTION);
  if (shouldRunNextPhase(parsedArgs,currentPhase)) {
    Path msgIdsPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,msgIdsPath);
    }
    log.info(""String_Node_Str"");
    Job createMsgIdDictionary=prepareJob(input,msgIdsPath,SequenceFileInputFormat.class,MsgIdToDictionaryMapper.class,Text.class,VarIntWritable.class,MailToDictionaryReducer.class,Text.class,VarIntWritable.class,SequenceFileOutputFormat.class);
    createMsgIdDictionary.waitForCompletion(true);
    msgIdChunks=createDictionaryChunks(msgIdsPath,output,""String_Node_Str"",createMsgIdDictionary.getConfiguration(),chunkSize,msgDim);
  }
  List<Path> fromChunks=null;
  if (shouldRunNextPhase(parsedArgs,currentPhase)) {
    Path fromIdsPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,fromIdsPath);
    }
    log.info(""String_Node_Str"");
    Job createFromIdDictionary=prepareJob(input,fromIdsPath,SequenceFileInputFormat.class,FromEmailToDictionaryMapper.class,Text.class,VarIntWritable.class,MailToDictionaryReducer.class,Text.class,VarIntWritable.class,SequenceFileOutputFormat.class);
    createFromIdDictionary.getConfiguration().set(EmailUtility.SEPARATOR,separator);
    createFromIdDictionary.waitForCompletion(true);
    int[] fromDim=new int[1];
    fromChunks=createDictionaryChunks(fromIdsPath,output,""String_Node_Str"",createFromIdDictionary.getConfiguration(),chunkSize,fromDim);
  }
  if (shouldRunNextPhase(parsedArgs,currentPhase) && fromChunks != null && msgIdChunks != null) {
    log.info(""String_Node_Str"");
    Path vecPath=new Path(output,""String_Node_Str"");
    if (overwrite) {
      HadoopUtil.delete(conf,vecPath);
    }
    conf.set(EmailUtility.MSG_ID_DIMENSION,String.valueOf(msgDim[0]));
    conf.set(EmailUtility.FROM_PREFIX,""String_Node_Str"");
    conf.set(EmailUtility.MSG_IDS_PREFIX,""String_Node_Str"");
    conf.set(EmailUtility.FROM_INDEX,parsedArgs.get(""String_Node_Str""));
    conf.set(EmailUtility.REFS_INDEX,parsedArgs.get(""String_Node_Str""));
    conf.set(EmailUtility.SEPARATOR,separator);
    conf.set(MailToRecReducer.USE_COUNTS_PREFERENCE,String.valueOf(useCounts));
    int j=0;
    int i=0;
    for (    Path fromChunk : fromChunks) {
      for (      Path idChunk : msgIdChunks) {
        Path out=new Path(vecPath,""String_Node_Str"" + i + '-'+ j);
        DistributedCache.setCacheFiles(new URI[]{fromChunk.toUri(),idChunk.toUri()},conf);
        Job createRecMatrix=prepareJob(input,out,SequenceFileInputFormat.class,MailToRecMapper.class,Text.class,LongWritable.class,MailToRecReducer.class,Text.class,NullWritable.class,TextOutputFormat.class);
        createRecMatrix.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
        createRecMatrix.waitForCompletion(true);
        FileStatus[] fs=HadoopUtil.getFileStatus(new Path(out,""String_Node_Str""),PathType.GLOB,PathFilters.partFilter(),null,conf);
        for (int k=0; k < fs.length; k++) {
          FileStatus f=fs[k];
          Path outPath=new Path(vecPath,""String_Node_Str"" + i + '-'+ j+ '-'+ k);
          FileUtil.copy(f.getPath().getFileSystem(conf),f.getPath(),outPath.getFileSystem(conf),outPath,true,overwrite,conf);
        }
        HadoopUtil.delete(conf,out);
        j++;
      }
      i++;
    }
  }
  return 0;
}",0.965223399355136
61213,"@Override protected void map(Text key,Text value,Context context) throws IOException, InterruptedException {
  int msgIdKey=Integer.MIN_VALUE;
  int fromKey=Integer.MIN_VALUE;
  String valStr=value.toString();
  String[] splits=StringUtils.splitByWholeSeparatorPreserveAllTokens(valStr,separator);
  if (splits != null && splits.length > 0) {
    if (splits.length > refsIdx) {
      String from=EmailUtility.cleanUpEmailAddress(splits[fromIdx]);
      fromKey=fromDictionary.get(from);
    }
    if (splits.length > refsIdx) {
      String[] theRefs=EmailUtility.parseReferences(splits[refsIdx]);
      if (theRefs != null && theRefs.length > 0) {
        msgIdKey=msgIdDictionary.get(theRefs[0]);
        context.getCounter(Counters.REFERENCE).increment(1);
      }
    }
  }
  if (msgIdKey == Integer.MIN_VALUE) {
    String keyStr=key.toString();
    int idx=keyStr.lastIndexOf('/');
    if (idx != -1) {
      String msgId=keyStr.substring(idx + 1);
      msgIdKey=msgIdDictionary.get(msgId);
      context.getCounter(Counters.ORIGINAL).increment(1);
    }
  }
  if (msgIdKey != Integer.MIN_VALUE && fromKey != Integer.MIN_VALUE) {
    context.write(null,new Text(fromKey + ""String_Node_Str"" + msgIdKey+ ""String_Node_Str""));
  }
}","@Override protected void map(Text key,Text value,Context context) throws IOException, InterruptedException {
  int msgIdKey=Integer.MIN_VALUE;
  int fromKey=Integer.MIN_VALUE;
  String valStr=value.toString();
  String[] splits=StringUtils.splitByWholeSeparatorPreserveAllTokens(valStr,separator);
  if (splits != null && splits.length > 0) {
    if (splits.length > refsIdx) {
      String from=EmailUtility.cleanUpEmailAddress(splits[fromIdx]);
      fromKey=fromDictionary.get(from);
    }
    if (splits.length > refsIdx) {
      String[] theRefs=EmailUtility.parseReferences(splits[refsIdx]);
      if (theRefs != null && theRefs.length > 0) {
        msgIdKey=msgIdDictionary.get(theRefs[0]);
        context.getCounter(Counters.REFERENCE).increment(1);
      }
    }
  }
  if (msgIdKey == Integer.MIN_VALUE) {
    String keyStr=key.toString();
    int idx=keyStr.lastIndexOf('/');
    if (idx != -1) {
      String msgId=keyStr.substring(idx + 1);
      msgIdKey=msgIdDictionary.get(msgId);
      context.getCounter(Counters.ORIGINAL).increment(1);
    }
  }
  if (msgIdKey != Integer.MIN_VALUE && fromKey != Integer.MIN_VALUE) {
    context.write(new Text(fromKey + ""String_Node_Str"" + msgIdKey),new LongWritable(1));
  }
}",0.9821573398215734
61214,"private static void writeContent(String separator,StringBuilder contents,CharSequence body,String[] matches){
  for (  String match : matches) {
    contents.append(match).append(separator);
  }
  contents.append('\n').append(body);
}","private static void writeContent(String separator,StringBuilder contents,CharSequence body,String[] matches){
  for (  String match : matches) {
    if (match != null) {
      contents.append(match).append(separator);
    }
 else {
      contents.append(""String_Node_Str"").append(separator);
    }
  }
  contents.append('\n').append(body);
}",0.8139130434782609
61215,"/** 
 * Creates a new character-stream reader whose critical sections will synchronize on the reader itself.
 */
private CharSequenceReader(CharSequence input){
  int n=input.length();
  buf=CharBuffer.allocate(n);
  for (int i=0; i < n; i++) {
    buf.put(input.charAt(i));
  }
}","/** 
 * Creates a new character-stream reader whose critical sections will synchronize on the reader itself.
 */
private CharSequenceReader(CharSequence input){
  int n=input.length();
  buf=CharBuffer.allocate(n);
  for (int i=0; i < n; i++) {
    buf.put(input.charAt(i));
  }
  buf.rewind();
}",0.9722222222222222
61216,"/** 
 * Reads characters into a portion of an array.  This method will block until some input is available, an I/O error occurs, or the end of the stream is reached.
 * @param cbuf Destination buffer
 * @param off  Offset at which to start storing characters
 * @param len  Maximum number of characters to read
 * @return The number of characters read, or -1 if the end of the stream has been reached
 */
@Override public int read(char[] cbuf,int off,int len){
  buf.get(cbuf,off,len);
  return len;
}","/** 
 * Reads characters into a portion of an array.  This method will block until some input is available, an I/O error occurs, or the end of the stream is reached.
 * @param cbuf Destination buffer
 * @param off  Offset at which to start storing characters
 * @param len  Maximum number of characters to read
 * @return The number of characters read, or -1 if the end of the stream has been reached
 */
@Override public int read(char[] cbuf,int off,int len){
  int toRead=Math.min(len,buf.remaining());
  if (toRead > 0) {
    buf.get(cbuf,off,toRead);
    return toRead;
  }
 else {
    return -1;
  }
}",0.8816621499548328
61217,"/** 
 * Builds one tree
 * @param treeId tree identifier
 */
public Node build(int treeId,Random rng,PredictionCallback callback){
  log.debug(""String_Node_Str"");
  Arrays.fill(sampled,false);
  Data bag=data.bagging(rng,sampled);
  log.debug(""String_Node_Str"");
  Node tree=treeBuilder.build(rng,bag);
  if (callback != null) {
    log.debug(""String_Node_Str"");
    for (int index=0; index < data.size(); index++) {
      if (!sampled[index]) {
        int prediction=tree.classify(data.get(index));
        callback.prediction(treeId,index,prediction);
      }
    }
  }
  return tree;
}","/** 
 * Builds one tree
 * @param treeId tree identifier
 */
public Node build(int treeId,Random rng,PredictionCallback callback){
  log.debug(""String_Node_Str"");
  Arrays.fill(sampled,false);
  Data bag=data.bagging(rng,sampled);
  log.debug(""String_Node_Str"");
  Node tree=treeBuilder.build(rng,bag);
  if (callback != null) {
    log.debug(""String_Node_Str"");
    for (int index=0; index < data.size(); index++) {
      if (!sampled[index]) {
        Instance instance=data.get(index);
        int prediction=tree.classify(instance);
        callback.prediction(treeId,instance.getId(),prediction);
      }
    }
  }
  return tree;
}",0.9322448979591836
61218,"@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  instances.add(converter.convert((int)key.get(),value.toString()));
}","@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  instances.add(converter.convert(id++,value.toString()));
}",0.956043956043956
61219,"/** 
 * Lists all files in the output   {@code Path}
 * @param fs {@code FileSystem} to use
 * @param outpath output {@code Path}
 * @return {@code Path} array
 */
public static Path[] listOutputFiles(FileSystem fs,Path outpath) throws IOException {
  Collection<Path> outpaths=Lists.newArrayList();
  for (  FileStatus s : fs.listStatus(outpath,PathFilters.logsCRCFilter())) {
    if (!s.isDir()) {
      outpaths.add(s.getPath());
    }
  }
  return outpaths.toArray(new Path[outpaths.size()]);
}","/** 
 * Lists all files in the output   {@code Path}
 * @param fs {@code FileSystem} to use
 * @param outpath output {@code Path}
 * @return {@code Path} array
 */
public static Path[] listOutputFiles(FileSystem fs,Path outpath) throws IOException {
  Collection<Path> outpaths=Lists.newArrayList();
  for (  FileStatus s : fs.listStatus(outpath,PathFilters.logsCRCFilter())) {
    if (!s.isDir() && !s.getPath().getName().startsWith(""String_Node_Str"")) {
      outpaths.add(s.getPath());
    }
  }
  return outpaths.toArray(new Path[outpaths.size()]);
}",0.903041825095057
61220,"/** 
 * runs one iteration of the procedure.
 * @param rng random numbers generator
 * @param data training data
 * @param m number of random variables to select at each tree-node
 * @param nbtrees number of trees to grow
 * @throws Exception if an error occured while growing the trees
 */
private void runIteration(Random rng,Data data,int m,int nbtrees){
  int nblabels=data.getDataset().nblabels();
  log.info(""String_Node_Str"");
  Data train=data.clone();
  Data test=train.rsplit(rng,(int)(data.size() * 0.1));
  int[] trainLabels=train.extractLabels();
  int[] testLabels=test.extractLabels();
  DefaultTreeBuilder treeBuilder=new DefaultTreeBuilder();
  SequentialBuilder forestBuilder=new SequentialBuilder(rng,treeBuilder,train);
  ForestPredictions errorM=new ForestPredictions(train.size(),nblabels);
  treeBuilder.setM(m);
  long time=System.currentTimeMillis();
  log.info(""String_Node_Str"",m);
  DecisionForest forestM=forestBuilder.build(nbtrees,errorM);
  sumTimeM+=System.currentTimeMillis() - time;
  numNodesM+=forestM.nbNodes();
  double oobM=ErrorEstimate.errorRate(trainLabels,errorM.computePredictions(rng));
  ForestPredictions errorOne=new ForestPredictions(train.size(),nblabels);
  treeBuilder.setM(1);
  time=System.currentTimeMillis();
  log.info(""String_Node_Str"");
  DecisionForest forestOne=forestBuilder.build(nbtrees,errorOne);
  sumTimeOne+=System.currentTimeMillis() - time;
  numNodesOne+=forestOne.nbNodes();
  double oobOne=ErrorEstimate.errorRate(trainLabels,errorOne.computePredictions(rng));
  ForestPredictions testError=new ForestPredictions(test.size(),nblabels);
  MeanTreeCollector treeError=new MeanTreeCollector(test,nbtrees);
  errorOne=new ForestPredictions(test.size(),nblabels);
  if (oobM < oobOne) {
    forestM.classify(test,new MultiCallback(testError,treeError));
    forestOne.classify(test,errorOne);
  }
 else {
    forestOne.classify(test,new MultiCallback(testError,treeError,errorOne));
  }
  sumTestErr+=ErrorEstimate.errorRate(testLabels,testError.computePredictions(rng));
  sumOneErr+=ErrorEstimate.errorRate(testLabels,errorOne.computePredictions(rng));
  sumTreeErr+=treeError.meanTreeError();
}","/** 
 * runs one iteration of the procedure.
 * @param rng random numbers generator
 * @param data training data
 * @param m number of random variables to select at each tree-node
 * @param nbtrees number of trees to grow
 * @throws Exception if an error occured while growing the trees
 */
private void runIteration(Random rng,Data data,int m,int nbtrees){
  int nblabels=data.getDataset().nblabels();
  log.info(""String_Node_Str"");
  Data train=data.clone();
  Data test=train.rsplit(rng,(int)(data.size() * 0.1));
  int[] labels=data.extractLabels();
  int[] testLabels=test.extractLabels();
  DefaultTreeBuilder treeBuilder=new DefaultTreeBuilder();
  SequentialBuilder forestBuilder=new SequentialBuilder(rng,treeBuilder,train);
  ForestPredictions errorM=new ForestPredictions(data.size(),nblabels);
  treeBuilder.setM(m);
  long time=System.currentTimeMillis();
  log.info(""String_Node_Str"",m);
  DecisionForest forestM=forestBuilder.build(nbtrees,errorM);
  sumTimeM+=System.currentTimeMillis() - time;
  numNodesM+=forestM.nbNodes();
  double oobM=ErrorEstimate.errorRate(labels,errorM.computePredictions(rng));
  ForestPredictions errorOne=new ForestPredictions(data.size(),nblabels);
  treeBuilder.setM(1);
  time=System.currentTimeMillis();
  log.info(""String_Node_Str"");
  DecisionForest forestOne=forestBuilder.build(nbtrees,errorOne);
  sumTimeOne+=System.currentTimeMillis() - time;
  numNodesOne+=forestOne.nbNodes();
  double oobOne=ErrorEstimate.errorRate(labels,errorOne.computePredictions(rng));
  ForestPredictions testError=new ForestPredictions(test.size(),nblabels);
  MeanTreeCollector treeError=new MeanTreeCollector(test,nbtrees);
  errorOne=new ForestPredictions(test.size(),nblabels);
  if (oobM < oobOne) {
    forestM.classify(test,new MultiCallback(testError,treeError));
    forestOne.classify(test,errorOne);
  }
 else {
    forestOne.classify(test,new MultiCallback(testError,treeError,errorOne));
  }
  sumTestErr+=ErrorEstimate.errorRate(testLabels,testError.computePredictions(rng));
  sumOneErr+=ErrorEstimate.errorRate(testLabels,errorOne.computePredictions(rng));
  sumTreeErr+=treeError.meanTreeError();
}",0.7000463606861381
61221,"public AbstractMatrix(int rows,int columns){
  this.rows=rows;
  this.columns=columns;
}","protected AbstractMatrix(int rows,int columns){
  this.rows=rows;
  this.columns=columns;
}",0.9385474860335196
61222,"@Override public void setQuick(int index,double value){
  Vector v=rowToColumn ? matrix.viewRow(index) : matrix.viewRow(index);
  if (v == null) {
    v=newVector(numCols);
    matrix.assignRow(index,v);
  }
  v.setQuick(transposeOffset,value);
}","@Override public void setQuick(int index,double value){
  Vector v=rowToColumn ? matrix.viewColumn(index) : matrix.viewRow(index);
  if (v == null) {
    v=newVector(numCols);
    if (rowToColumn) {
      matrix.assignColumn(index,v);
    }
 else {
      matrix.assignRow(index,v);
    }
  }
  v.setQuick(transposeOffset,value);
}",0.84375
61223,"@Override public double getQuick(int index){
  Vector v=rowToColumn ? matrix.viewRow(index) : matrix.viewRow(index);
  return v == null ? 0 : v.getQuick(transposeOffset);
}","@Override public double getQuick(int index){
  Vector v=rowToColumn ? matrix.viewColumn(index) : matrix.viewRow(index);
  return v == null ? 0.0 : v.getQuick(transposeOffset);
}",0.9742120343839542
61224,"/** 
 * Story: User can set T3 and T4 values to be used by the reducer for its T1 and T2 thresholds
 */
@Test public void testCanopyReducerT3T4Configuration() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=new Configuration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.T3_KEY,String.valueOf(1.1));
  conf.set(CanopyConfigKeys.T4_KEY,String.valueOf(0.1));
  DummyRecordWriter<Text,Canopy> writer=new DummyRecordWriter<Text,Canopy>();
  Reducer<Text,VectorWritable,Text,Canopy>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  assertEquals(1.1,reducer.canopyClusterer.getT1(),EPSILON);
  assertEquals(0.1,reducer.canopyClusterer.getT2(),EPSILON);
}","/** 
 * Story: User can set T3 and T4 values to be used by the reducer for its T1 and T2 thresholds
 */
@Test public void testCanopyReducerT3T4Configuration() throws Exception {
  CanopyReducer reducer=new CanopyReducer();
  Configuration conf=new Configuration();
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(3.1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(2.1));
  conf.set(CanopyConfigKeys.T3_KEY,String.valueOf(1.1));
  conf.set(CanopyConfigKeys.T4_KEY,String.valueOf(0.1));
  DummyRecordWriter<Text,Canopy> writer=new DummyRecordWriter<Text,Canopy>();
  Reducer<Text,VectorWritable,Text,Canopy>.Context context=DummyRecordWriter.build(reducer,conf,writer,Text.class,VectorWritable.class);
  reducer.setup(context);
  assertEquals(1.1,reducer.getCanopyClusterer().getT1(),EPSILON);
  assertEquals(0.1,reducer.getCanopyClusterer().getT2(),EPSILON);
}",0.962406015037594
61225,"protected Integer userIndex(long userID){
  Integer userIndex=userIDMapping.get(userID);
  if (userIndex == null) {
    userIndex=userIDMapping.put(userID,userIDMapping.size());
  }
  return userIndex;
}","protected Integer userIndex(long userID){
  Integer userIndex=userIDMapping.get(userID);
  if (userIndex == null) {
    userIndex=userIDMapping.size();
    userIDMapping.put(userID,userIndex);
  }
  return userIndex;
}",0.8836104513064132
61226,"protected Integer itemIndex(long itemID){
  Integer itemIndex=itemIDMapping.get(itemID);
  if (itemIndex == null) {
    itemIndex=itemIDMapping.put(itemID,itemIDMapping.size());
  }
  return itemIndex;
}","protected Integer itemIndex(long itemID){
  Integer itemIndex=itemIDMapping.get(itemID);
  if (itemIndex == null) {
    itemIndex=itemIDMapping.size();
    itemIDMapping.put(itemID,itemIndex);
  }
  return itemIndex;
}",0.8836104513064132
61227,"/** 
 * Initializes a dataset using an info file.
 * @param fs file system
 * @param inpath info file
 * @return Initialized Dataset
 */
public static DataSet parseFile(FileSystem fs,Path inpath) throws IOException {
  Path info=getInfoFile(fs,inpath);
  FSDataInputStream input=fs.open(info);
  Scanner reader=new Scanner(input);
  List<Integer> ignored=new ArrayList<Integer>();
  List<Attribute> attributes=new ArrayList<Attribute>();
  int labelIndex=-1;
  int index=0;
  while (reader.hasNextLine()) {
    String line=reader.nextLine();
    Iterator<String> tokens=Arrays.asList(COMMA_SPACE.split(line)).iterator();
    String token=tokens.next();
    if (IGNORED_TOKEN.equals(token)) {
      ignored.add(index);
    }
 else     if (LABEL_TOKEN.equals(token)) {
      labelIndex=index;
      attributes.add(parseNominal(tokens));
    }
 else     if (NOMINAL_TOKEN.equals(token)) {
      attributes.add(parseNominal(tokens));
    }
 else     if (NUMERICAL_TOKEN.equals(token)) {
      attributes.add(parseNumerical(tokens));
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + token + ""String_Node_Str"");
    }
  }
  reader.close();
  if (labelIndex == -1) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new DataSet(attributes,ignored,labelIndex);
}","/** 
 * Initializes a dataset using an info file.
 * @param fs file system
 * @param inpath info file
 * @return Initialized Dataset
 */
public static DataSet parseFile(FileSystem fs,Path inpath) throws IOException {
  Path info=getInfoFile(fs,inpath);
  FSDataInputStream input=fs.open(info);
  Scanner reader=new Scanner(input);
  List<Integer> ignored=new ArrayList<Integer>();
  List<Attribute> attributes=new ArrayList<Attribute>();
  int labelIndex=-1;
  int index=0;
  while (reader.hasNextLine()) {
    String line=reader.nextLine();
    Iterator<String> tokens=COMMA.split(line).iterator();
    String token=tokens.next();
    if (IGNORED_TOKEN.equals(token)) {
      ignored.add(index);
    }
 else     if (LABEL_TOKEN.equals(token)) {
      labelIndex=index;
      attributes.add(parseNominal(tokens));
    }
 else     if (NOMINAL_TOKEN.equals(token)) {
      attributes.add(parseNominal(tokens));
    }
 else     if (NUMERICAL_TOKEN.equals(token)) {
      attributes.add(parseNumerical(tokens));
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + token + ""String_Node_Str"");
    }
  }
  reader.close();
  if (labelIndex == -1) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new DataSet(attributes,ignored,labelIndex);
}",0.983326870880186
61228,"/** 
 * Extracts the output and processes it
 * @return info for each partition in Hadoop's order
 */
protected Step0Output[] parseOutput(JobContext job) throws IOException {
  Configuration conf=job.getConfiguration();
  log.info(""String_Node_Str"",conf.getInt(""String_Node_Str"",-1));
  FileSystem fs=outputPath.getFileSystem(conf);
  Path[] outfiles=DFUtils.listOutputFiles(fs,outputPath);
  List<Integer> keys=new ArrayList<Integer>();
  List<Step0Output> values=new ArrayList<Step0Output>();
  for (  Path path : outfiles) {
    for (    Pair<IntWritable,Step0Output> record : new SequenceFileIterable<IntWritable,Step0Output>(path,conf)) {
      keys.add(record.getFirst().get());
      values.add(record.getSecond());
    }
  }
  return processOutput(keys,values);
}","/** 
 * Extracts the output and processes it
 * @return info for each partition in Hadoop's order
 */
protected Step0Output[] parseOutput(JobContext job) throws IOException {
  Configuration conf=job.getConfiguration();
  log.info(""String_Node_Str"",conf.getInt(""String_Node_Str"",-1));
  List<Integer> keys=new ArrayList<Integer>();
  List<Step0Output> values=new ArrayList<Step0Output>();
  for (  Pair<IntWritable,Step0Output> record : new SequenceFileDirIterable<IntWritable,Step0Output>(outputPath,PathType.LIST,PathFilters.logsCRCFilter(),conf)) {
    keys.add(record.getFirst().get());
    values.add(record.getSecond());
  }
  return processOutput(keys,values);
}",0.5875
61229,"/** 
 * Test the main method of the SequenceFilesFromMailArchives command-line application.
 */
@Test public void testMain() throws Exception {
  String[] args={""String_Node_Str"",inputDir.getAbsolutePath(),""String_Node_Str"",outputDir.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  SequenceFilesFromMailArchives.main(args);
  File expectedChunkFile=new File(outputDir,""String_Node_Str"");
  String expectedChunkPath=expectedChunkFile.getAbsolutePath();
  Assert.assertTrue(""String_Node_Str"" + expectedChunkPath + ""String_Node_Str"",expectedChunkFile.isFile());
  Configuration conf=new Configuration();
  SequenceFileIterator<Text,Text> iterator=new SequenceFileIterator<Text,Text>(new Path(expectedChunkPath),true,conf);
  Assert.assertTrue(""String_Node_Str"",iterator.hasNext());
  Pair<Text,Text> record=iterator.next();
  Assert.assertEquals(""String_Node_Str"" + testVars[0][0],record.getFirst().toString());
  Assert.assertEquals(testVars[0][1] + testVars[0][2],record.getSecond().toString());
  Assert.assertTrue(""String_Node_Str"",iterator.hasNext());
  record=iterator.next();
  Assert.assertEquals(""String_Node_Str"" + testVars[1][0],record.getFirst().toString());
  Assert.assertEquals(testVars[1][1] + testVars[1][2],record.getSecond().toString());
  Assert.assertFalse(""String_Node_Str"",iterator.hasNext());
}","/** 
 * Test the main method of the SequenceFilesFromMailArchives command-line application.
 */
@Test public void testMain() throws Exception {
  String[] args={""String_Node_Str"",inputDir.getAbsolutePath(),""String_Node_Str"",outputDir.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  SequenceFilesFromMailArchives.main(args);
  File expectedChunkFile=new File(outputDir,""String_Node_Str"");
  String expectedChunkPath=expectedChunkFile.getAbsolutePath();
  Assert.assertTrue(""String_Node_Str"" + expectedChunkPath + ""String_Node_Str"",expectedChunkFile.isFile());
  Configuration conf=new Configuration();
  SequenceFileIterator<Text,Text> iterator=new SequenceFileIterator<Text,Text>(new Path(expectedChunkPath),true,conf);
  Assert.assertTrue(""String_Node_Str"",iterator.hasNext());
  Pair<Text,Text> record=iterator.next();
  File parentFile=new File(new File(new File(""String_Node_Str""),""String_Node_Str""),""String_Node_Str"");
  Assert.assertEquals(new File(parentFile,testVars[0][0]).toString(),record.getFirst().toString());
  Assert.assertEquals(testVars[0][1] + testVars[0][2],record.getSecond().toString());
  Assert.assertTrue(""String_Node_Str"",iterator.hasNext());
  record=iterator.next();
  Assert.assertEquals(new File(parentFile,testVars[1][0]).toString(),record.getFirst().toString());
  Assert.assertEquals(testVars[1][1] + testVars[1][2],record.getSecond().toString());
  Assert.assertFalse(""String_Node_Str"",iterator.hasNext());
}",0.9273429273429272
61230,"public double[][] getUHat(){
  return m_uHat;
}","public double[][] getUHat(){
  return uHat;
}",0.9782608695652174
61231,"public EigenSolverWrapper(double[][] bbt){
  super();
  int dim=bbt.length;
  EigenDecompositionImpl evd2=new EigenDecompositionImpl(new Array2DRowRealMatrix(bbt),0);
  m_eigenvalues=evd2.getRealEigenvalues();
  RealMatrix uHatrm=evd2.getV();
  m_uHat=new double[dim][];
  for (int i=0; i < dim; i++)   m_uHat[i]=uHatrm.getRow(i);
}","public EigenSolverWrapper(double[][] bbt){
  super();
  int dim=bbt.length;
  EigenDecompositionImpl evd2=new EigenDecompositionImpl(new Array2DRowRealMatrix(bbt),0);
  eigenvalues=evd2.getRealEigenvalues();
  RealMatrix uHatrm=evd2.getV();
  uHat=new double[dim][];
  for (int i=0; i < dim; i++)   uHat[i]=uHatrm.getRow(i);
}",0.9908814589665652
61232,"public double[] getEigenValues(){
  return m_eigenvalues;
}","public double[] getEigenValues(){
  return eigenvalues;
}",0.9827586206896552
61233,"public MySQLJDBCDiffStorage(AbstractJDBCDataModel dataModel,String diffsTable,String itemIDAColumn,String itemIDBColumn,String countColumn,String avgColumn,String stdevColumn,int minDiffCount) throws TasteException {
  super(dataModel,""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ itemIDAColumn,""String_Node_Str"" + dataModel.getPreferenceColumn() + ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ itemIDBColumn+ ')',new String[]{""String_Node_Str"" + diffsTable + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""},""String_Node_Str"" + diffsTable + ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + itemIDAColumn + ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + diffsTable,""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ' '+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + diffsTable,minDiffCount);
}","public MySQLJDBCDiffStorage(AbstractJDBCDataModel dataModel,String diffsTable,String itemIDAColumn,String itemIDBColumn,String countColumn,String avgColumn,String stdevColumn,int minDiffCount) throws TasteException {
  super(dataModel,""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ itemIDBColumn,""String_Node_Str"" + dataModel.getPreferenceColumn() + ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + countColumn + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ itemIDBColumn+ ')',new String[]{""String_Node_Str"" + diffsTable + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""},""String_Node_Str"" + diffsTable + ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str"",""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + itemIDAColumn + ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ diffsTable+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + diffsTable,""String_Node_Str"" + diffsTable + ""String_Node_Str""+ itemIDAColumn+ ""String_Node_Str""+ itemIDBColumn+ ""String_Node_Str""+ avgColumn+ ""String_Node_Str""+ stdevColumn+ ""String_Node_Str""+ countColumn+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceColumn()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getPreferenceTable()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getUserIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ' '+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str""+ dataModel.getItemIDColumn()+ ""String_Node_Str"",""String_Node_Str"" + diffsTable,minDiffCount);
}",0.9260479382028852
61234,"public static void main(String[] args) throws Throwable {
  ProgramDriver programDriver=new ProgramDriver();
  Properties mainClasses=new Properties();
  InputStream propsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    mainClasses.load(propsStream);
  }
 catch (  IOException e) {
    propsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
    mainClasses.load(propsStream);
  }
  boolean foundShortName=false;
  for (  Object key : mainClasses.keySet()) {
    String keyString=(String)key;
    if (args.length > 0 && shortName(mainClasses.getProperty(keyString)).equals(args[0])) {
      foundShortName=true;
    }
    addClass(programDriver,keyString,mainClasses.getProperty(keyString));
  }
  if (args.length < 1 || args[0] == null || args[0].equals(""String_Node_Str"") || args[0].equals(""String_Node_Str"")) {
    programDriver.driver(args);
  }
  String progName=args[0];
  if (!foundShortName) {
    addClass(programDriver,progName,progName);
  }
  shift(args);
  InputStream defaultsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(progName + ""String_Node_Str"");
  Properties mainProps=new Properties();
  if (defaultsStream != null) {
    mainProps.load(defaultsStream);
  }
 else {
    log.warn(""String_Node_Str"" + progName + ""String_Node_Str"");
  }
  Map<String,String[]> argMap=new HashMap<String,String[]>();
  int i=0;
  while (i < args.length && args[i] != null) {
    List<String> argValues=new ArrayList<String>();
    String arg=args[i];
    i++;
    if (arg.length() > 2 && arg.charAt(1) == 'D') {
      String[] argSplit=arg.split(""String_Node_Str"");
      arg=argSplit[0];
      if (argSplit.length == 2) {
        argValues.add(argSplit[1]);
      }
    }
 else {
      while (i < args.length && args[i] != null) {
        if (args[i].length() > 0 && args[i].charAt(0) != '-') {
          argValues.add(args[i]);
          i++;
        }
 else {
          break;
        }
      }
    }
    argMap.put(arg,argValues.toArray(new String[argValues.size()]));
  }
  for (  String key : mainProps.stringPropertyNames()) {
    String[] argNamePair=key.split(""String_Node_Str"");
    String shortArg='-' + argNamePair[0].trim();
    String longArg=argNamePair.length < 2 ? null : ""String_Node_Str"" + argNamePair[1].trim();
    if (!argMap.containsKey(shortArg) && (longArg == null || !argMap.containsKey(longArg))) {
      argMap.put(longArg,new String[]{mainProps.getProperty(key)});
    }
  }
  List<String> argsList=new ArrayList<String>();
  argsList.add(progName);
  for (  String arg : argMap.keySet()) {
    if (arg.startsWith(""String_Node_Str"")) {
      if (argMap.get(arg).length > 0 && !argMap.get(arg)[0].trim().isEmpty()) {
        arg+='=' + argMap.get(arg)[0].trim();
      }
    }
    argsList.add(arg);
    if (!arg.startsWith(""String_Node_Str"")) {
      argsList.addAll(Arrays.asList(argMap.get(arg)));
    }
  }
  long start=System.currentTimeMillis();
  programDriver.driver(argsList.toArray(new String[argsList.size()]));
  long finish=System.currentTimeMillis();
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"" + (finish - start) + ""String_Node_Str"");
  }
}","public static void main(String[] args) throws Throwable {
  ProgramDriver programDriver=new ProgramDriver();
  Properties mainClasses=new Properties();
  InputStream propsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    mainClasses.load(propsStream);
  }
 catch (  IOException e) {
    propsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
    mainClasses.load(propsStream);
  }
  boolean foundShortName=false;
  for (  Object key : mainClasses.keySet()) {
    String keyString=(String)key;
    if (args.length > 0 && shortName(mainClasses.getProperty(keyString)).equals(args[0])) {
      foundShortName=true;
    }
    addClass(programDriver,keyString,mainClasses.getProperty(keyString));
  }
  if (args.length < 1 || args[0] == null || args[0].equals(""String_Node_Str"") || args[0].equals(""String_Node_Str"")) {
    programDriver.driver(args);
  }
  String progName=args[0];
  if (!foundShortName) {
    addClass(programDriver,progName,progName);
  }
  shift(args);
  InputStream defaultsStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(progName + ""String_Node_Str"");
  Properties mainProps=new Properties();
  if (defaultsStream != null) {
    mainProps.load(defaultsStream);
  }
 else {
    log.warn(""String_Node_Str"" + progName + ""String_Node_Str"");
  }
  Map<String,String[]> argMap=new HashMap<String,String[]>();
  int i=0;
  while (i < args.length && args[i] != null) {
    List<String> argValues=new ArrayList<String>();
    String arg=args[i];
    i++;
    if (arg.length() > 2 && arg.charAt(1) == 'D') {
      String[] argSplit=arg.split(""String_Node_Str"");
      arg=argSplit[0];
      if (argSplit.length == 2) {
        argValues.add(argSplit[1]);
      }
    }
 else {
      while (i < args.length && args[i] != null) {
        if (args[i].length() > 0 && args[i].charAt(0) != '-') {
          argValues.add(args[i]);
          i++;
        }
 else {
          break;
        }
      }
    }
    argMap.put(arg,argValues.toArray(new String[argValues.size()]));
  }
  for (  String key : mainProps.stringPropertyNames()) {
    String[] argNamePair=key.split(""String_Node_Str"");
    String shortArg='-' + argNamePair[0].trim();
    String longArg=argNamePair.length < 2 ? null : ""String_Node_Str"" + argNamePair[1].trim();
    if (!argMap.containsKey(shortArg) && (longArg == null || !argMap.containsKey(longArg))) {
      argMap.put(longArg,new String[]{mainProps.getProperty(key)});
    }
  }
  List<String> argsList=new ArrayList<String>();
  argsList.add(progName);
  for (  String arg : argMap.keySet()) {
    if (arg.startsWith(""String_Node_Str"")) {
      if (argMap.get(arg).length > 0 && !argMap.get(arg)[0].trim().isEmpty()) {
        arg+='=' + argMap.get(arg)[0].trim();
      }
      argsList.add(1,arg);
    }
 else {
      argsList.add(arg);
      argsList.addAll(Arrays.asList(argMap.get(arg)));
    }
  }
  long start=System.currentTimeMillis();
  programDriver.driver(argsList.toArray(new String[argsList.size()]));
  long finish=System.currentTimeMillis();
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"" + (finish - start) + ""String_Node_Str"");
  }
}",0.9033659066232356
61235,"/** 
 * Computes the AUC of points seen so far.  This can be moderately expensive since it requires that all points that have been retained be sorted.
 * @return The value of the Area Under the receiver operating Curve.
 */
public double auc(){
  Preconditions.checkArgument(hasScore,""String_Node_Str"");
  scores[0].sort();
  scores[1].sort();
  double n0=scores[0].size();
  double n1=scores[1].size();
  if (n0 == 0 || n1 == 0) {
    return 0.5;
  }
  int i0=0;
  int i1=0;
  int rank=1;
  double rankSum=0;
  while (i0 < n0 && i1 < n1) {
    double v0=scores[0].get(i0);
    double v1=scores[1].get(i1);
    if (v0 < v1) {
      i0++;
      rank++;
    }
 else     if (v1 < v0) {
      i1++;
      rankSum+=rank;
      rank++;
    }
 else {
      double tieScore=v0;
      int k0=0;
      while (i0 < n0 && v0 == tieScore) {
        k0++;
        i0++;
        v0=scores[0].get(i0);
      }
      int k1=0;
      while (i1 < n1 && v1 == tieScore) {
        k1++;
        i1++;
        v1=scores[1].get(i1);
      }
      rankSum+=(rank + (k0 + k1 - 1) / 2.0) * k1;
      rank+=k0 + k1;
    }
  }
  if (i1 < n1) {
    rankSum+=(rank + (n1 - i1 - 1) / 2.0) * (n1 - i1);
    rank+=n1 - i1;
  }
  return (rankSum / n1 - (n1 + 1) / 2) / n0;
}","/** 
 * Computes the AUC of points seen so far.  This can be moderately expensive since it requires that all points that have been retained be sorted.
 * @return The value of the Area Under the receiver operating Curve.
 */
public double auc(){
  Preconditions.checkArgument(hasScore,""String_Node_Str"");
  scores[0].sort();
  scores[1].sort();
  double n0=scores[0].size();
  double n1=scores[1].size();
  if (n0 == 0 || n1 == 0) {
    return 0.5;
  }
  int i0=0;
  int i1=0;
  int rank=1;
  double rankSum=0;
  while (i0 < n0 && i1 < n1) {
    double v0=scores[0].get(i0);
    double v1=scores[1].get(i1);
    if (v0 < v1) {
      i0++;
      rank++;
    }
 else     if (v1 < v0) {
      i1++;
      rankSum+=rank;
      rank++;
    }
 else {
      double tieScore=v0;
      int k0=0;
      while (i0 < n0 && scores[0].get(i0) == tieScore) {
        k0++;
        i0++;
      }
      int k1=0;
      while (i1 < n1 && scores[1].get(i1) == tieScore) {
        k1++;
        i1++;
      }
      rankSum+=(rank + (k0 + k1 - 1) / 2.0) * k1;
      rank+=k0 + k1;
    }
  }
  if (i1 < n1) {
    rankSum+=(rank + (n1 - i1 - 1) / 2.0) * (n1 - i1);
    rank+=n1 - i1;
  }
  return (rankSum / n1 - (n1 + 1) / 2) / n0;
}",0.96
61236,"/** 
 * Sets the number of locations in the feature vector that a value should be in. This causes the cached probe locations to be recomputed.
 * @param probes Number of locations to increment.
 */
@Override public void setProbes(int probes){
  super.setProbes(probes);
  cacheProbeLocations(CONTINUOUS_VALUE_HASH_SEED);
}","/** 
 * Sets the number of locations in the feature vector that a value should be in. This causes the cached probe locations to be recomputed.
 * @param probes Number of locations to increment.
 */
@Override public void setProbes(int probes){
  super.setProbes(probes);
  cacheProbeLocations(getSeed());
}",0.9473684210526316
61237,"@Override protected double getWeight(byte[] originalForm,double w){
  return w * Double.parseDouble(new String(originalForm));
}","@Override protected double getWeight(byte[] originalForm,double w){
  if (originalForm != null) {
    return w * Double.parseDouble(new String(originalForm));
  }
 else {
    return w;
  }
}",0.8050314465408805
61238,"@Test public void testAddToVector(){
  FeatureVectorEncoder enc=new ContinuousValueEncoder(""String_Node_Str"");
  Vector v1=new DenseVector(20);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(-123,v1.minValue(),0);
  assertEquals(0,v1.maxValue(),0);
  assertEquals(123,v1.norm(1),0);
  v1=new DenseVector(20);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(123,v1.maxValue(),0);
  assertEquals(0,v1.minValue(),0);
  assertEquals(123,v1.norm(1),0);
  Vector v2=new DenseVector(20);
  enc.setProbes(2);
  enc.addToVector(""String_Node_Str"",v2);
  assertEquals(123,v2.maxValue(),0);
  assertEquals(2 * 123,v2.norm(1),0);
  v1=v2.minus(v1);
  assertEquals(123,v1.maxValue(),0);
  assertEquals(123,v1.norm(1),0);
  Vector v3=new DenseVector(20);
  enc.setProbes(2);
  enc.addToVector(""String_Node_Str"",v3);
  v1=v2.minus(v3);
  assertEquals(23,v1.maxValue(),0);
  assertEquals(2 * 23,v1.norm(1),0);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(30,v1.maxValue(),0);
  assertEquals(2 * 30,v1.norm(1),0);
  assertEquals(30,v1.get(10),0);
  assertEquals(30,v1.get(18),0);
  try {
    enc.addToVector(""String_Node_Str"",v1);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}","@Test public void testAddToVector(){
  FeatureVectorEncoder enc=new ContinuousValueEncoder(""String_Node_Str"");
  Vector v1=new DenseVector(20);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(-123,v1.minValue(),0);
  assertEquals(0,v1.maxValue(),0);
  assertEquals(123,v1.norm(1),0);
  v1=new DenseVector(20);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(123,v1.maxValue(),0);
  assertEquals(0,v1.minValue(),0);
  assertEquals(123,v1.norm(1),0);
  Vector v2=new DenseVector(20);
  enc.setProbes(2);
  enc.addToVector(""String_Node_Str"",v2);
  assertEquals(123,v2.maxValue(),0);
  assertEquals(2 * 123,v2.norm(1),0);
  v1=v2.minus(v1);
  assertEquals(123,v1.maxValue(),0);
  assertEquals(123,v1.norm(1),0);
  Vector v3=new DenseVector(20);
  enc.setProbes(2);
  enc.addToVector(""String_Node_Str"",v3);
  v1=v2.minus(v3);
  assertEquals(23,v1.maxValue(),0);
  assertEquals(2 * 23,v1.norm(1),0);
  enc.addToVector(""String_Node_Str"",v1);
  assertEquals(30,v1.maxValue(),0);
  assertEquals(2 * 30,v1.norm(1),0);
  assertEquals(30,v1.get(10),0);
  assertEquals(30,v1.get(18),0);
  v2=new DenseVector(20);
  v3=new DenseVector(20);
  enc.setProbes(6);
  enc.addToVector(""String_Node_Str"",v2);
  enc.addToVector((byte[])null,145,v3);
  assertEquals(0,v2.minus(v3).norm(1),0);
  try {
    enc.addToVector(""String_Node_Str"",v1);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}",0.9271329183449286
61239,"public void setGramSize(int gramSize){
  set(""String_Node_Str"",Integer.toBinaryString(gramSize));
}","public void setGramSize(int gramSize){
  set(""String_Node_Str"",Integer.toString(gramSize));
}",0.96875
61240,"@Override protected void map(Text key,VectorWritable value,Context context) throws IOException, InterruptedException {
  if (!labelMap.containsKey(key.toString())) {
    context.getCounter(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  int label=labelMap.get(key.toString());
  context.write(new IntWritable(label),value);
}","@Override protected void map(Text key,VectorWritable value,Context context) throws IOException, InterruptedException {
  if (!labelMap.containsKey(key.toString())) {
    context.getCounter(""String_Node_Str"",""String_Node_Str"").increment(1);
    return;
  }
  int label=labelMap.get(key.toString());
  context.write(new IntWritable(label),value);
}",0.9808541973490428
61241,"/** 
 * Write the list of labels into a map file
 * @param wordCountPath
 * @param dictionaryPathBase
 * @throws IOException
 */
public static Path createLabelMapFile(List<String> labels,Configuration conf,Path labelMapPathBase) throws IOException {
  FileSystem fs=FileSystem.get(labelMapPathBase.toUri(),conf);
  Path labelMapPath=new Path(labelMapPathBase,LABEL_MAP);
  SequenceFile.Writer dictWriter=new SequenceFile.Writer(fs,conf,labelMapPath,Text.class,IntWritable.class);
  int i=0;
  for (  String label : labels) {
    Writable key=new Text(label);
    dictWriter.append(key,new IntWritable(i++));
  }
  return labelMapPath;
}","/** 
 * Write the list of labels into a map file
 * @param wordCountPath
 * @param dictionaryPathBase
 * @throws IOException
 */
public static Path createLabelMapFile(List<String> labels,Configuration conf,Path labelMapPathBase) throws IOException {
  FileSystem fs=FileSystem.get(labelMapPathBase.toUri(),conf);
  Path labelMapPath=new Path(labelMapPathBase,LABEL_MAP);
  SequenceFile.Writer dictWriter=new SequenceFile.Writer(fs,conf,labelMapPath,Text.class,IntWritable.class);
  int i=0;
  for (  String label : labels) {
    Writable key=new Text(label);
    dictWriter.append(key,new IntWritable(i++));
  }
  dictWriter.close();
  return labelMapPath;
}",0.982998454404946
61242,"@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  context.write(new Text(BayesConstants.FEATURE_SUM),new VectorWritable(featureSum));
  context.write(new Text(BayesConstants.LABEL_SUM),new VectorWritable(labelSum));
  super.cleanup(context);
}","@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  if (featureSum != null) {
    context.write(new Text(BayesConstants.FEATURE_SUM),new VectorWritable(featureSum));
    context.write(new Text(BayesConstants.LABEL_SUM),new VectorWritable(labelSum));
  }
  super.cleanup(context);
}",0.9411764705882352
61243,"/** 
 * Story: User can produce final point clustering using a Hadoop map/reduce job and a EuclideanDistanceMeasure.
 */
@Test public void testCanopyEuclideanSeqJob() throws Exception {
  Path input=getTestTempDirPath(""String_Node_Str"");
  Configuration conf=new Configuration();
  FileSystem fs=FileSystem.get(input.toUri(),conf);
  Collection<VectorWritable> points=new ArrayList<VectorWritable>();
  for (  Vector v : raw) {
    points.add(new VectorWritable(v));
  }
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  Path output=getTestTempDirPath(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + output.toString());
  String[] args={optKey(DefaultOptionCreator.INPUT_OPTION),getTestTempDirPath(""String_Node_Str"").toString(),optKey(DefaultOptionCreator.OUTPUT_OPTION),output.toString(),optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION),EuclideanDistanceMeasure.class.getName(),optKey(DefaultOptionCreator.T1_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.T2_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CLUSTERING_OPTION),optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.OVERWRITE_OPTION),optKey(DefaultOptionCreator.METHOD_OPTION),DefaultOptionCreator.SEQUENTIAL_METHOD};
  new MeanShiftCanopyDriver().run(args);
  Path outPart=new Path(output,""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,outPart,conf);
  Writable key=new Text();
  MeanShiftCanopy value=new MeanShiftCanopy();
  int count=0;
  while (reader.next(key,value)) {
    count++;
  }
  reader.close();
  assertEquals(""String_Node_Str"",5,count);
}","/** 
 * Story: User can produce final point clustering using a Hadoop map/reduce job and a EuclideanDistanceMeasure.
 */
@Test public void testCanopyEuclideanSeqJob() throws Exception {
  Path input=getTestTempDirPath(""String_Node_Str"");
  Configuration conf=new Configuration();
  FileSystem fs=FileSystem.get(input.toUri(),conf);
  Collection<VectorWritable> points=new ArrayList<VectorWritable>();
  for (  Vector v : raw) {
    points.add(new VectorWritable(v));
  }
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  Path output=getTestTempDirPath(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + output.toString());
  String[] args={optKey(DefaultOptionCreator.INPUT_OPTION),getTestTempDirPath(""String_Node_Str"").toString(),optKey(DefaultOptionCreator.OUTPUT_OPTION),output.toString(),optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION),EuclideanDistanceMeasure.class.getName(),optKey(DefaultOptionCreator.T1_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.T2_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CLUSTERING_OPTION),optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.OVERWRITE_OPTION),optKey(DefaultOptionCreator.METHOD_OPTION),DefaultOptionCreator.SEQUENTIAL_METHOD};
  ToolRunner.run(new Configuration(),new MeanShiftCanopyDriver(),args);
  Path outPart=new Path(output,""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,outPart,conf);
  Writable key=new Text();
  MeanShiftCanopy value=new MeanShiftCanopy();
  int count=0;
  while (reader.next(key,value)) {
    count++;
  }
  reader.close();
  assertEquals(""String_Node_Str"",5,count);
}",0.98893984353925
61244,"/** 
 * Story: User can produce final point clustering using a Hadoop map/reduce job and a EuclideanDistanceMeasure.
 */
@Test public void testCanopyEuclideanMRJob() throws Exception {
  Path input=getTestTempDirPath(""String_Node_Str"");
  Configuration conf=new Configuration();
  FileSystem fs=FileSystem.get(input.toUri(),conf);
  Collection<VectorWritable> points=new ArrayList<VectorWritable>();
  for (  Vector v : raw) {
    points.add(new VectorWritable(v));
  }
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  Path output=getTestTempDirPath(""String_Node_Str"");
  String[] args={optKey(DefaultOptionCreator.INPUT_OPTION),getTestTempDirPath(""String_Node_Str"").toString(),optKey(DefaultOptionCreator.OUTPUT_OPTION),output.toString(),optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION),EuclideanDistanceMeasure.class.getName(),optKey(DefaultOptionCreator.T1_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.T2_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CLUSTERING_OPTION),optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.OVERWRITE_OPTION)};
  new MeanShiftCanopyDriver().run(args);
  Path outPart=new Path(output,""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,outPart,conf);
  Writable key=new Text();
  Writable value=new MeanShiftCanopy();
  int count=0;
  while (reader.next(key,value)) {
    count++;
  }
  reader.close();
  assertEquals(""String_Node_Str"",3,count);
}","/** 
 * Story: User can produce final point clustering using a Hadoop map/reduce job and a EuclideanDistanceMeasure.
 */
@Test public void testCanopyEuclideanMRJob() throws Exception {
  Path input=getTestTempDirPath(""String_Node_Str"");
  Configuration conf=new Configuration();
  FileSystem fs=FileSystem.get(input.toUri(),conf);
  Collection<VectorWritable> points=new ArrayList<VectorWritable>();
  for (  Vector v : raw) {
    points.add(new VectorWritable(v));
  }
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  ClusteringTestUtils.writePointsToFile(points,getTestTempFilePath(""String_Node_Str""),fs,conf);
  Path output=getTestTempDirPath(""String_Node_Str"");
  String[] args={optKey(DefaultOptionCreator.INPUT_OPTION),getTestTempDirPath(""String_Node_Str"").toString(),optKey(DefaultOptionCreator.OUTPUT_OPTION),output.toString(),optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION),EuclideanDistanceMeasure.class.getName(),optKey(DefaultOptionCreator.T1_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.T2_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CLUSTERING_OPTION),optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION),""String_Node_Str"",optKey(DefaultOptionCreator.OVERWRITE_OPTION)};
  ToolRunner.run(conf,new MeanShiftCanopyDriver(),args);
  Path outPart=new Path(output,""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,outPart,conf);
  Writable key=new Text();
  Writable value=new MeanShiftCanopy();
  int count=0;
  while (reader.next(key,value)) {
    count++;
  }
  reader.close();
  assertEquals(""String_Node_Str"",3,count);
}",0.992330383480826
61245,"public double addSample(int category,double score){
  int n=(int)samples.get(category);
  if (n < HISTORY) {
    scores.set(category,n,score);
  }
 else {
switch (policy) {
case FIFO:
      scores.set(category,n % HISTORY,score);
    break;
case FAIR:
  int j1=random.nextInt(n + 1);
if (j1 < HISTORY) {
  scores.set(category,j1,score);
}
break;
case RANDOM:
int j2=random.nextInt(HISTORY);
scores.set(category,j2,score);
break;
}
}
samples.set(category,n + 1);
if (samples.minValue() >= 1) {
Vector row=scores.viewRow(1 - category);
double m=0.0;
double count=0.0;
for (Vector.Element element : row) {
double v=element.get();
if (Double.isNaN(v)) {
continue;
}
count++;
if (score > v) {
m++;
}
 else if (score < v) {
}
 else if (score == v) {
m+=0.5;
}
}
averages.set(category,averages.get(category) + (m / count - averages.get(category)) / samples.get(category));
}
return auc();
}","public double addSample(int category,double score){
  int n=(int)samples.get(category);
  if (n < HISTORY) {
    scores.set(category,n,score);
  }
 else {
switch (policy) {
case FIFO:
      scores.set(category,n % HISTORY,score);
    break;
case FAIR:
  int j1=random.nextInt(n + 1);
if (j1 < HISTORY) {
  scores.set(category,j1,score);
}
break;
case RANDOM:
int j2=random.nextInt(HISTORY);
scores.set(category,j2,score);
break;
}
}
samples.set(category,n + 1);
if (samples.minValue() >= 1) {
Vector row=scores.viewRow(1 - category);
double m=0.0;
double count=0.0;
for (Vector.Element element : row) {
double v=element.get();
if (Double.isNaN(v)) {
continue;
}
count++;
if (score > v) {
m++;
}
 else if (score < v) {
}
 else if (score == v) {
m+=0.5;
}
}
averages.set(category,averages.get(category) + (m / count - averages.get(category)) / Math.min(windowSize,samples.get(category)));
}
return auc();
}",0.9669837716843872
61246,"@Test public void testBinaryCase(){
  Random gen=RandomUtils.getRandom();
  OnlineSummarizer[] stats=new OnlineSummarizer[4];
  for (int i=0; i < 4; i++) {
    stats[i]=new OnlineSummarizer();
  }
  for (int i=0; i < 500; i++) {
    OnlineAuc a1=new OnlineAuc();
    a1.setPolicy(FAIR);
    OnlineAuc a2=new OnlineAuc();
    a2.setPolicy(FIFO);
    OnlineAuc a3=new OnlineAuc();
    a3.setPolicy(RANDOM);
    Auc a4=new Auc();
    for (int j=0; j < 10000; j++) {
      double x=gen.nextGaussian();
      a1.addSample(0,x);
      a2.addSample(0,x);
      a3.addSample(0,x);
      a4.add(0,x);
      x=gen.nextGaussian() + 1;
      a1.addSample(1,x);
      a2.addSample(1,x);
      a3.addSample(1,x);
      a4.add(1,x);
    }
    stats[0].add(a1.auc());
    stats[1].add(a2.auc());
    stats[2].add(a3.auc());
    stats[3].add(a4.auc());
  }
  int i=0;
  for (  OnlineAuc.ReplacementPolicy policy : new OnlineAuc.ReplacementPolicy[]{FAIR,FIFO,RANDOM,null}) {
    OnlineSummarizer summary=stats[i++];
    System.out.printf(""String_Node_Str"",policy,summary.getMean(),summary.getQuartile(0),summary.getQuartile(1),summary.getQuartile(2),summary.getQuartile(3));
  }
  assertEquals(0.7603,stats[0].getMean(),0.03);
  assertEquals(0.7603,stats[0].getQuartile(1),0.025);
  assertEquals(0.7603,stats[0].getQuartile(3),0.025);
  assertEquals(0.7603,stats[1].getMean(),0.001);
  assertEquals(0.7603,stats[1].getQuartile(1),0.006);
  assertEquals(0.7603,stats[1].getQuartile(3),0.006);
  assertEquals(0.7603,stats[2].getMean(),0.001);
  assertEquals(0.7603,stats[2].getQuartile(1),0.006);
  assertEquals(0.7603,stats[2].getQuartile(1),0.006);
}","@Test public void testBinaryCase(){
  Random gen=RandomUtils.getRandom();
  OnlineSummarizer[] stats=new OnlineSummarizer[4];
  for (int i=0; i < 4; i++) {
    stats[i]=new OnlineSummarizer();
  }
  for (int i=0; i < 500; i++) {
    OnlineAuc a1=new OnlineAuc();
    a1.setPolicy(FAIR);
    OnlineAuc a2=new OnlineAuc();
    a2.setPolicy(FIFO);
    OnlineAuc a3=new OnlineAuc();
    a3.setPolicy(RANDOM);
    Auc a4=new Auc();
    for (int j=0; j < 10000; j++) {
      double x=gen.nextGaussian();
      a1.addSample(0,x);
      a2.addSample(0,x);
      a3.addSample(0,x);
      a4.add(0,x);
      x=gen.nextGaussian() + 1;
      a1.addSample(1,x);
      a2.addSample(1,x);
      a3.addSample(1,x);
      a4.add(1,x);
    }
    stats[0].add(a1.auc());
    stats[1].add(a2.auc());
    stats[2].add(a3.auc());
    stats[3].add(a4.auc());
  }
  int i=0;
  for (  OnlineAuc.ReplacementPolicy policy : new OnlineAuc.ReplacementPolicy[]{FAIR,FIFO,RANDOM,null}) {
    OnlineSummarizer summary=stats[i++];
    System.out.printf(""String_Node_Str"",policy,summary.getMean(),summary.getQuartile(0),summary.getQuartile(1),summary.getQuartile(2),summary.getQuartile(3));
  }
  assertEquals(0.7603,stats[0].getMean(),0.03);
  assertEquals(0.7603,stats[0].getQuartile(1),0.03);
  assertEquals(0.7603,stats[0].getQuartile(3),0.03);
  assertEquals(0.7603,stats[1].getMean(),0.001);
  assertEquals(0.7603,stats[1].getQuartile(1),0.006);
  assertEquals(0.7603,stats[1].getQuartile(3),0.006);
  assertEquals(0.7603,stats[2].getMean(),0.001);
  assertEquals(0.7603,stats[2].getQuartile(1),0.006);
  assertEquals(0.7603,stats[2].getQuartile(1),0.006);
}",0.998160637645616
61247,"private void setStDev(int cI){
  List<VectorWritable> repPts=representativePoints.get(cI);
  int s0=0;
  Vector s1=null;
  Vector s2=null;
  for (  VectorWritable vw : repPts) {
    s0++;
    Vector v=vw.get();
    s1=s1 == null ? v.clone() : s1.plus(v);
    s2=s2 == null ? v.times(v) : s2.plus(v.times(v));
  }
  Vector std=s2.times(s0).minus(s1.times(s1)).assign(new SquareRootFunction()).divide(s0);
  double d=std.zSum() / std.size();
  stDevs.put(cI,d);
}","private void setStDev(int cI){
  List<VectorWritable> repPts=representativePoints.get(cI);
  int s0=0;
  Vector s1=null;
  Vector s2=null;
  for (  VectorWritable vw : repPts) {
    s0++;
    Vector v=vw.get();
    s1=s1 == null ? v.clone() : s1.plus(v);
    s2=s2 == null ? v.times(v) : s2.plus(v.times(v));
  }
  if (s0 > 1) {
    Vector std=s2.times(s0).minus(s1.times(s1)).assign(new SquareRootFunction()).divide(s0);
    double d=std.zSum() / std.size();
    stDevs.put(cI,d);
  }
}",0.9725738396624471
61248,"public double interClusterDensity(){
  double sum=0.0;
  for (  Map.Entry<Integer,List<VectorWritable>> entry1 : representativePoints.entrySet()) {
    Integer cI=entry1.getKey();
    List<VectorWritable> repI=entry1.getValue();
    double stDevI=stDevs.get(cI);
    for (    Map.Entry<Integer,List<VectorWritable>> entry2 : representativePoints.entrySet()) {
      Integer cJ=entry2.getKey();
      if (cI.equals(cJ)) {
        continue;
      }
      List<VectorWritable> repJ=entry2.getValue();
      double minDistance=Double.MAX_VALUE;
      Vector uIJ=null;
      for (      VectorWritable aRepI : repI) {
        for (        VectorWritable aRepJ : repJ) {
          Vector vI=aRepI.get();
          Vector vJ=aRepJ.get();
          double distance=measure.distance(vI,vJ);
          if (distance < minDistance) {
            minDistance=distance;
            uIJ=vI.plus(vJ).divide(2);
          }
        }
      }
      double stDevJ=stDevs.get(cJ);
      double interDensity=interDensity(uIJ,cI,cJ);
      double stdSum=stDevI + stDevJ;
      double density=0.0;
      if (stdSum > 0.0) {
        density=minDistance * interDensity / stdSum;
      }
      sum+=density;
    }
  }
  return sum;
}","public double interClusterDensity(){
  double sum=0.0;
  for (  Map.Entry<Integer,List<VectorWritable>> entry1 : representativePoints.entrySet()) {
    Integer cI=entry1.getKey();
    List<VectorWritable> repI=entry1.getValue();
    double stDevI=getStdev(cI);
    for (    Map.Entry<Integer,List<VectorWritable>> entry2 : representativePoints.entrySet()) {
      Integer cJ=entry2.getKey();
      if (cI.equals(cJ)) {
        continue;
      }
      List<VectorWritable> repJ=entry2.getValue();
      double minDistance=Double.MAX_VALUE;
      Vector uIJ=null;
      for (      VectorWritable aRepI : repI) {
        for (        VectorWritable aRepJ : repJ) {
          Vector vI=aRepI.get();
          Vector vJ=aRepJ.get();
          double distance=measure.distance(vI,vJ);
          if (distance < minDistance) {
            minDistance=distance;
            uIJ=vI.plus(vJ).divide(2);
          }
        }
      }
      double stDevJ=getStdev(cJ);
      double interDensity=uIJ == null ? 0 : interDensity(uIJ,cI,cJ);
      double stdSum=stDevI + stDevJ;
      double density=0.0;
      if (stdSum > 0.0) {
        density=minDistance * interDensity / stdSum;
      }
      log.debug(""String_Node_Str"" + cI + ""String_Node_Str""+ cJ+ ""String_Node_Str""+ minDistance);
      log.debug(""String_Node_Str"" + cI + ""String_Node_Str""+ stDevI);
      log.debug(""String_Node_Str"" + cJ + ""String_Node_Str""+ stDevJ);
      log.debug(""String_Node_Str"" + cI + ""String_Node_Str""+ cJ+ ""String_Node_Str""+ interDensity);
      log.debug(""String_Node_Str"" + cI + ""String_Node_Str""+ cJ+ ""String_Node_Str""+ density);
      sum+=density;
    }
  }
  return sum;
}",0.67671809256662
61249,"public double intraClusterDensity(){
  double avgStd=0.0;
  for (  Integer cId : representativePoints.keySet()) {
    avgStd+=stDevs.get(cId);
  }
  avgStd/=representativePoints.size();
  double sum=0.0;
  for (  Map.Entry<Integer,List<VectorWritable>> entry : representativePoints.entrySet()) {
    Integer cId=entry.getKey();
    List<VectorWritable> repI=entry.getValue();
    double cSum=0.0;
    for (    VectorWritable aRepI : repI) {
      double inDensity=intraDensity(clusters.get(cId).getCenter(),aRepI.get(),avgStd);
      double std=stDevs.get(cId);
      if (std > 0.0) {
        cSum+=inDensity / std;
      }
    }
    sum+=cSum / repI.size();
  }
  return sum / representativePoints.size();
}","public double intraClusterDensity(){
  double avgStd=0.0;
  for (  Integer cId : representativePoints.keySet()) {
    avgStd+=getStdev(cId);
  }
  avgStd/=representativePoints.size();
  double sum=0.0;
  for (  Map.Entry<Integer,List<VectorWritable>> entry : representativePoints.entrySet()) {
    Integer cId=entry.getKey();
    List<VectorWritable> repI=entry.getValue();
    double cSum=0.0;
    for (    VectorWritable aRepI : repI) {
      double inDensity=intraDensity(clusters.get(cId).getCenter(),aRepI.get(),avgStd);
      double std=getStdev(cId);
      if (std > 0.0) {
        cSum+=inDensity / std;
      }
    }
    if (repI.size() > 0) {
      sum+=cSum / repI.size();
    }
  }
  return sum / representativePoints.size();
}",0.9509329647546648
61250,"double interDensity(Vector uIJ,int cI,int cJ){
  List<VectorWritable> repI=representativePoints.get(cI);
  List<VectorWritable> repJ=representativePoints.get(cJ);
  double density=0.0;
  double std=(stDevs.get(cI) + stDevs.get(cJ)) / 2.0;
  for (  VectorWritable vwI : repI) {
    if (measure.distance(uIJ,vwI.get()) <= std) {
      density++;
    }
  }
  for (  VectorWritable vwJ : repJ) {
    if (measure.distance(uIJ,vwJ.get()) <= std) {
      density++;
    }
  }
  return density / (repI.size() + repJ.size());
}","double interDensity(Vector uIJ,int cI,int cJ){
  List<VectorWritable> repI=representativePoints.get(cI);
  List<VectorWritable> repJ=representativePoints.get(cJ);
  double density=0.0;
  double std=(getStdev(cI) + getStdev(cJ)) / 2.0;
  for (  VectorWritable vwI : repI) {
    if (measure.distance(uIJ,vwI.get()) <= std) {
      density++;
    }
  }
  for (  VectorWritable vwJ : repJ) {
    if (measure.distance(uIJ,vwJ.get()) <= std) {
      density++;
    }
  }
  return density / (repI.size() + repJ.size());
}",0.9767441860465116
61251,"@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  for (  Map.Entry<Integer,List<VectorWritable>> entry : referencePoints.entrySet()) {
    IntWritable iw=new IntWritable(entry.getKey());
    for (    VectorWritable vw : entry.getValue()) {
      context.write(iw,vw);
    }
  }
  super.cleanup(context);
}","@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  for (  Map.Entry<Integer,List<VectorWritable>> entry : representativePoints.entrySet()) {
    IntWritable iw=new IntWritable(entry.getKey());
    for (    VectorWritable vw : entry.getValue()) {
      context.write(iw,vw);
    }
  }
  super.cleanup(context);
}",0.4936170212765957
61252,"@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Configuration conf=context.getConfiguration();
  try {
    referencePoints=CDbwMapper.getRepresentativePoints(conf);
  }
 catch (  NumberFormatException e) {
    throw new IllegalStateException(e);
  }
catch (  SecurityException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalStateException(e);
  }
}","@Override protected void setup(Context context) throws IOException, InterruptedException {
  super.setup(context);
  Configuration conf=context.getConfiguration();
  try {
    representativePoints=CDbwMapper.getRepresentativePoints(conf);
  }
 catch (  NumberFormatException e) {
    throw new IllegalStateException(e);
  }
catch (  SecurityException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalStateException(e);
  }
}",0.9823468328141224
61253,"public void configure(Map<Integer,List<VectorWritable>> referencePoints){
  this.referencePoints=referencePoints;
}","public void configure(Map<Integer,List<VectorWritable>> representativePoints){
  this.representativePoints=representativePoints;
}",0.8653061224489796
61254,"/** 
 * Initialize synthetic data using 4 clusters dC units from origin having 4 representative points dP from each center
 * @param dC a double cluster center offset
 * @param dP a double representative point offset
 * @param measure TODO
 */
private void initData(double dC,double dP,DistanceMeasure measure){
  clusters=new HashMap<Integer,Cluster>();
  clusters.put(1,new Canopy(new DenseVector(new double[]{-dC,-dC}),1,measure));
  clusters.put(3,new Canopy(new DenseVector(new double[]{-dC,dC}),3,measure));
  clusters.put(5,new Canopy(new DenseVector(new double[]{dC,dC}),5,measure));
  clusters.put(7,new Canopy(new DenseVector(new double[]{dC,-dC}),7,measure));
  representativePoints=new HashMap<Integer,List<VectorWritable>>();
  for (  Cluster cluster : clusters.values()) {
    List<VectorWritable> points=new ArrayList<VectorWritable>();
    representativePoints.put(cluster.getId(),points);
    points.add(new VectorWritable(cluster.getCenter().clone()));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{dP,dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{dP,-dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{-dP,-dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{-dP,dP}))));
  }
}","/** 
 * Initialize synthetic data using 4 clusters dC units from origin having 4 representative points dP from each center
 * @param dC a double cluster center offset
 * @param dP a double representative point offset
 * @param measure the DistanceMeasure
 */
private void initData(double dC,double dP,DistanceMeasure measure){
  clusters=new HashMap<Integer,Cluster>();
  clusters.put(1,new Canopy(new DenseVector(new double[]{-dC,-dC}),1,measure));
  clusters.put(3,new Canopy(new DenseVector(new double[]{-dC,dC}),3,measure));
  clusters.put(5,new Canopy(new DenseVector(new double[]{dC,dC}),5,measure));
  clusters.put(7,new Canopy(new DenseVector(new double[]{dC,-dC}),7,measure));
  representativePoints=new HashMap<Integer,List<VectorWritable>>();
  for (  Cluster cluster : clusters.values()) {
    List<VectorWritable> points=new ArrayList<VectorWritable>();
    representativePoints.put(cluster.getId(),points);
    points.add(new VectorWritable(cluster.getCenter().clone()));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{dP,dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{dP,-dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{-dP,-dP}))));
    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[]{-dP,dP}))));
  }
}",0.9924324324324324
61255,"public static void runLoad(Recommender recommender) throws TasteException {
  DataModel dataModel=recommender.getDataModel();
  int numUsers=dataModel.getNumUsers();
  double sampleRate=1000.0 / numUsers;
  LongPrimitiveIterator userSampler=SamplingLongPrimitiveIterator.maybeWrapIterator(dataModel.getUserIDs(),sampleRate);
  recommender.recommend(userSampler.next(),10);
  Collection<Callable<Void>> callables=new ArrayList<Callable<Void>>();
  while (userSampler.hasNext()) {
    callables.add(new LoadCallable(recommender,userSampler.next()));
  }
  AbstractDifferenceRecommenderEvaluator.execute(callables);
}","public static void runLoad(Recommender recommender) throws TasteException {
  DataModel dataModel=recommender.getDataModel();
  int numUsers=dataModel.getNumUsers();
  double sampleRate=1000.0 / numUsers;
  LongPrimitiveIterator userSampler=SamplingLongPrimitiveIterator.maybeWrapIterator(dataModel.getUserIDs(),sampleRate);
  recommender.recommend(userSampler.next(),10);
  Collection<Callable<Void>> callables=new ArrayList<Callable<Void>>();
  while (userSampler.hasNext()) {
    callables.add(new LoadCallable(recommender,userSampler.next()));
  }
  AbstractDifferenceRecommenderEvaluator.execute(callables,new AtomicInteger());
}",0.9839743589743588
61256,"private NonZeroIterator(){
  it=vector.iterator();
  buffer();
}","private NonZeroIterator(){
  it=vector.iterateNonZero();
  buffer();
}",0.9552238805970148
61257,"@Override public FastByIDMap<FastIDSet> exportWithIDsOnly() throws TasteException {
  log.debug(""String_Node_Str"");
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  FastByIDMap<FastIDSet> result=new FastByIDMap<FastIDSet>();
  try {
    conn=dataSource.getConnection();
    stmt=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    log.debug(""String_Node_Str"",getAllUsersSQL);
    rs=stmt.executeQuery(getAllUsersSQL);
    boolean currentUserIDSet=false;
    long currentUserID=0L;
    FastIDSet currentItemIDs=new FastIDSet(2);
    while (rs.next()) {
      long nextUserID=getLongColumn(rs,1);
      if (currentUserIDSet && (currentUserID != nextUserID)) {
        if (!currentItemIDs.isEmpty()) {
          result.put(currentUserID,currentItemIDs);
          currentItemIDs=new FastIDSet(2);
        }
      }
 else {
        currentItemIDs.add(getLongColumn(rs,2));
      }
      currentUserID=nextUserID;
      currentUserIDSet=true;
    }
    if (!currentItemIDs.isEmpty()) {
      result.put(currentUserID,currentItemIDs);
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}","@Override public FastByIDMap<FastIDSet> exportWithIDsOnly() throws TasteException {
  log.debug(""String_Node_Str"");
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  FastByIDMap<FastIDSet> result=new FastByIDMap<FastIDSet>();
  try {
    conn=dataSource.getConnection();
    stmt=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    log.debug(""String_Node_Str"",getAllUsersSQL);
    rs=stmt.executeQuery(getAllUsersSQL);
    boolean currentUserIDSet=false;
    long currentUserID=0L;
    FastIDSet currentItemIDs=new FastIDSet(2);
    while (rs.next()) {
      long nextUserID=getLongColumn(rs,1);
      if (currentUserIDSet && (currentUserID != nextUserID) && !currentItemIDs.isEmpty()) {
        result.put(currentUserID,currentItemIDs);
        currentItemIDs=new FastIDSet(2);
      }
      currentItemIDs.add(getLongColumn(rs,2));
      currentUserID=nextUserID;
      currentUserIDSet=true;
    }
    if (!currentItemIDs.isEmpty()) {
      result.put(currentUserID,currentItemIDs);
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}",0.9567809239940388
61258,"@Override public FastByIDMap<PreferenceArray> exportWithPrefs() throws TasteException {
  log.debug(""String_Node_Str"");
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  FastByIDMap<PreferenceArray> result=new FastByIDMap<PreferenceArray>();
  try {
    conn=dataSource.getConnection();
    stmt=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    log.debug(""String_Node_Str"",getAllUsersSQL);
    rs=stmt.executeQuery(getAllUsersSQL);
    Long currentUserID=null;
    List<Preference> currentPrefs=new ArrayList<Preference>();
    while (rs.next()) {
      long nextUserID=getLongColumn(rs,1);
      if ((currentUserID != null) && !currentUserID.equals(nextUserID)) {
        if (!currentPrefs.isEmpty()) {
          result.put(currentUserID,new GenericUserPreferenceArray(currentPrefs));
          currentPrefs.clear();
        }
      }
 else {
        currentPrefs.add(buildPreference(rs));
      }
      currentUserID=nextUserID;
    }
    if (!currentPrefs.isEmpty()) {
      result.put(currentUserID,new GenericUserPreferenceArray(currentPrefs));
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}","@Override public FastByIDMap<PreferenceArray> exportWithPrefs() throws TasteException {
  log.debug(""String_Node_Str"");
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  FastByIDMap<PreferenceArray> result=new FastByIDMap<PreferenceArray>();
  try {
    conn=dataSource.getConnection();
    stmt=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    log.debug(""String_Node_Str"",getAllUsersSQL);
    rs=stmt.executeQuery(getAllUsersSQL);
    Long currentUserID=null;
    List<Preference> currentPrefs=new ArrayList<Preference>();
    while (rs.next()) {
      long nextUserID=getLongColumn(rs,1);
      if ((currentUserID != null) && !currentUserID.equals(nextUserID) && !currentPrefs.isEmpty()) {
        result.put(currentUserID,new GenericUserPreferenceArray(currentPrefs));
        currentPrefs.clear();
      }
      currentPrefs.add(buildPreference(rs));
      currentUserID=nextUserID;
    }
    if (!currentPrefs.isEmpty()) {
      result.put(currentUserID,new GenericUserPreferenceArray(currentPrefs));
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}",0.9648351648351648
61259,"/** 
 * Converts a value into a form that would help a human understand the internals of how the value is being interpreted.  For text-like things, this is likely to be a list of the terms found with associated weights (if any).
 * @param originalForm The original form of the value as a string.
 * @return A string that a human can read.
 */
@Override public String asString(String originalForm){
  return String.format(""String_Node_Str"",getName(),originalForm);
}","/** 
 * Converts a value into a form that would help a human understand the internals of how the value is being interpreted.  For text-like things, this is likely to be a list of the terms found with associated weights (if any).
 * @param originalForm The original form of the value as a string.
 * @return A string that a human can read.
 */
@Override public String asString(String originalForm){
  return String.format(Locale.ENGLISH,""String_Node_Str"",getName(),originalForm);
}",0.984126984126984
61260,"/** 
 * Adds a value to a vector.
 * @param originalForm1 The original form of the first value as a string.
 * @param originalForm2 The original form of the second value as a string.
 * @param data          The vector to which the value should be added.
 */
public void addInteractionToVector(String originalForm1,String originalForm2,Vector data){
  int probes=getProbes();
  String name=getName();
  for (int i=0; i < probes; i++) {
    int h1=hash1(name,originalForm1,i,data.size());
    int h2=hash2(name,originalForm1,i,data.size());
    int j=hash1(name,originalForm2,i,data.size());
    int n=(h1 + (j + 1) * h2) % data.size();
    trace(String.format(""String_Node_Str"",originalForm1,originalForm2),n);
    data.set(n,data.get(n) + 1);
  }
}","/** 
 * Adds a value to a vector.
 * @param originalForm1 The original form of the first value as a string.
 * @param originalForm2 The original form of the second value as a string.
 * @param data          The vector to which the value should be added.
 */
public void addInteractionToVector(String originalForm1,String originalForm2,Vector data){
  int probes=getProbes();
  String name=getName();
  for (int i=0; i < probes; i++) {
    int h1=hash1(name,originalForm1,i,data.size());
    int h2=hash2(name,originalForm1,i,data.size());
    int j=hash1(name,originalForm2,i,data.size());
    int n=(h1 + (j + 1) * h2) % data.size();
    if (n < 0) {
      n=n + data.size();
    }
    trace(String.format(""String_Node_Str"",originalForm1,originalForm2),n);
    data.set(n,data.get(n) + 1);
  }
}",0.9689119170984456
61261,"protected InteractionValueEncoder(String name){
  super(name,2);
}","public InteractionValueEncoder(String name){
  super(name,2);
}",0.9147286821705426
61262,"public static void main(String[] args) throws IOException {
  DefaultOptionBuilder obuilder=new DefaultOptionBuilder();
  ArgumentBuilder abuilder=new ArgumentBuilder();
  GroupBuilder gbuilder=new GroupBuilder();
  Option inputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option fieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option idFieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option dictOutOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option weightOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option delimiterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option powerOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outWriterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option minDFOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxDFPercentOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option helpOpt=obuilder.withLongName(""String_Node_Str"").withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Group group=gbuilder.withName(""String_Node_Str"").withOption(inputOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(delimiterOpt).withOption(helpOpt).withOption(fieldOpt).withOption(maxOpt).withOption(dictOutOpt).withOption(powerOpt).withOption(outWriterOpt).withOption(maxDFPercentOpt).withOption(weightOpt).withOption(minDFOpt).create();
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    CommandLine cmdLine=parser.parse(args);
    if (cmdLine.hasOption(helpOpt)) {
      CommandLineUtil.printHelp(group);
      return;
    }
    if (cmdLine.hasOption(inputOpt)) {
      File file=new File(cmdLine.getValue(inputOpt).toString());
      if (!file.isDirectory()) {
        throw new IllegalArgumentException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      }
      long maxDocs=Long.MAX_VALUE;
      if (cmdLine.hasOption(maxOpt)) {
        maxDocs=Long.parseLong(cmdLine.getValue(maxOpt).toString());
      }
      if (maxDocs < 0) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      Directory dir=FSDirectory.open(file);
      IndexReader reader=IndexReader.open(dir,true);
      Weight weight;
      if (cmdLine.hasOption(weightOpt)) {
        String wString=cmdLine.getValue(weightOpt).toString();
        if (wString.equalsIgnoreCase(""String_Node_Str"")) {
          weight=new TF();
        }
 else         if (wString.equalsIgnoreCase(""String_Node_Str"")) {
          weight=new TFIDF();
        }
 else {
          throw new OptionException(weightOpt);
        }
      }
 else {
        weight=new TFIDF();
      }
      String field=cmdLine.getValue(fieldOpt).toString();
      int minDf=1;
      if (cmdLine.hasOption(minDFOpt)) {
        minDf=Integer.parseInt(cmdLine.getValue(minDFOpt).toString());
      }
      int maxDFPercent=99;
      if (cmdLine.hasOption(maxDFPercentOpt)) {
        maxDFPercent=Integer.parseInt(cmdLine.getValue(maxDFPercentOpt).toString());
      }
      TermInfo termInfo=new CachedTermInfo(reader,field,minDf,maxDFPercent);
      VectorMapper mapper=new TFDFMapper(reader,weight,termInfo);
      double norm=LuceneIterable.NO_NORMALIZING;
      if (cmdLine.hasOption(powerOpt)) {
        String power=cmdLine.getValue(powerOpt).toString();
        if (power.equals(""String_Node_Str"")) {
          norm=Double.POSITIVE_INFINITY;
        }
 else {
          norm=Double.parseDouble(power);
        }
      }
      String idField=null;
      if (cmdLine.hasOption(idFieldOpt)) {
        idField=cmdLine.getValue(idFieldOpt).toString();
      }
      LuceneIterable iterable;
      if (norm == LuceneIterable.NO_NORMALIZING) {
        iterable=new LuceneIterable(reader,idField,field,mapper,LuceneIterable.NO_NORMALIZING);
      }
 else {
        iterable=new LuceneIterable(reader,idField,field,mapper,norm);
      }
      String outFile=cmdLine.getValue(outputOpt).toString();
      log.info(""String_Node_Str"",outFile);
      VectorWriter vectorWriter;
      if (cmdLine.hasOption(outWriterOpt)) {
        String outWriter=cmdLine.getValue(outWriterOpt).toString();
        if (outWriter.equals(""String_Node_Str"")) {
          BufferedWriter writer=new BufferedWriter(new FileWriter(outFile));
          vectorWriter=new JWriterVectorWriter(writer);
        }
 else {
          vectorWriter=getSeqFileWriter(outFile);
        }
      }
 else {
        vectorWriter=getSeqFileWriter(outFile);
      }
      long numDocs=vectorWriter.write(iterable,maxDocs);
      vectorWriter.close();
      log.info(""String_Node_Str"",numDocs);
      String delimiter=cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : ""String_Node_Str"";
      File dictOutFile=new File(cmdLine.getValue(dictOutOpt).toString());
      log.info(""String_Node_Str"",dictOutFile);
      BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dictOutFile),Charset.forName(""String_Node_Str"")));
      JWriterTermInfoWriter tiWriter=new JWriterTermInfoWriter(writer,delimiter,field);
      tiWriter.write(termInfo);
      tiWriter.close();
      writer.close();
    }
  }
 catch (  OptionException e) {
    log.error(""String_Node_Str"",e);
    CommandLineUtil.printHelp(group);
  }
}","public static void main(String[] args) throws IOException {
  DefaultOptionBuilder obuilder=new DefaultOptionBuilder();
  ArgumentBuilder abuilder=new ArgumentBuilder();
  GroupBuilder gbuilder=new GroupBuilder();
  Option inputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option fieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option idFieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option dictOutOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option weightOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option delimiterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option powerOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outWriterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option minDFOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxDFPercentOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option helpOpt=obuilder.withLongName(""String_Node_Str"").withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Group group=gbuilder.withName(""String_Node_Str"").withOption(inputOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(delimiterOpt).withOption(helpOpt).withOption(fieldOpt).withOption(maxOpt).withOption(dictOutOpt).withOption(powerOpt).withOption(outWriterOpt).withOption(maxDFPercentOpt).withOption(weightOpt).withOption(minDFOpt).create();
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    CommandLine cmdLine=parser.parse(args);
    if (cmdLine.hasOption(helpOpt)) {
      CommandLineUtil.printHelp(group);
      return;
    }
    if (cmdLine.hasOption(inputOpt)) {
      File file=new File(cmdLine.getValue(inputOpt).toString());
      if (!file.isDirectory()) {
        throw new IllegalArgumentException(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
      }
      long maxDocs=Long.MAX_VALUE;
      if (cmdLine.hasOption(maxOpt)) {
        maxDocs=Long.parseLong(cmdLine.getValue(maxOpt).toString());
      }
      if (maxDocs < 0) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      Directory dir=FSDirectory.open(file);
      IndexReader reader=IndexReader.open(dir,true);
      Weight weight;
      if (cmdLine.hasOption(weightOpt)) {
        String wString=cmdLine.getValue(weightOpt).toString();
        if (wString.equalsIgnoreCase(""String_Node_Str"")) {
          weight=new TF();
        }
 else         if (wString.equalsIgnoreCase(""String_Node_Str"")) {
          weight=new TFIDF();
        }
 else {
          throw new OptionException(weightOpt);
        }
      }
 else {
        weight=new TFIDF();
      }
      String field=cmdLine.getValue(fieldOpt).toString();
      int minDf=1;
      if (cmdLine.hasOption(minDFOpt)) {
        minDf=Integer.parseInt(cmdLine.getValue(minDFOpt).toString());
      }
      int maxDFPercent=99;
      if (cmdLine.hasOption(maxDFPercentOpt)) {
        maxDFPercent=Integer.parseInt(cmdLine.getValue(maxDFPercentOpt).toString());
      }
      TermInfo termInfo=new CachedTermInfo(reader,field,minDf,maxDFPercent);
      VectorMapper mapper=new TFDFMapper(reader,weight,termInfo);
      double norm=LuceneIterable.NO_NORMALIZING;
      if (cmdLine.hasOption(powerOpt)) {
        String power=cmdLine.getValue(powerOpt).toString();
        if (power.equals(""String_Node_Str"")) {
          norm=Double.POSITIVE_INFINITY;
        }
 else {
          norm=Double.parseDouble(power);
        }
      }
      String idField=null;
      if (cmdLine.hasOption(idFieldOpt)) {
        idField=cmdLine.getValue(idFieldOpt).toString();
      }
      LuceneIterable iterable;
      if (norm == LuceneIterable.NO_NORMALIZING) {
        iterable=new LuceneIterable(reader,idField,field,mapper,LuceneIterable.NO_NORMALIZING);
      }
 else {
        iterable=new LuceneIterable(reader,idField,field,mapper,norm);
      }
      String outFile=cmdLine.getValue(outputOpt).toString();
      log.info(""String_Node_Str"",outFile);
      VectorWriter vectorWriter;
      if (cmdLine.hasOption(outWriterOpt)) {
        String outWriter=cmdLine.getValue(outWriterOpt).toString();
        if (outWriter.equals(""String_Node_Str"")) {
          BufferedWriter writer=new BufferedWriter(new FileWriter(outFile));
          vectorWriter=new JWriterVectorWriter(writer);
        }
 else {
          vectorWriter=getSeqFileWriter(outFile);
        }
      }
 else {
        vectorWriter=getSeqFileWriter(outFile);
      }
      long numDocs=vectorWriter.write(iterable,maxDocs);
      vectorWriter.close();
      log.info(""String_Node_Str"",numDocs);
      String delimiter=cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : ""String_Node_Str"";
      File dictOutFile=new File(cmdLine.getValue(dictOutOpt).toString());
      log.info(""String_Node_Str"",dictOutFile);
      BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dictOutFile),Charset.forName(""String_Node_Str"")));
      JWriterTermInfoWriter tiWriter=new JWriterTermInfoWriter(writer,delimiter,field);
      tiWriter.write(termInfo);
      tiWriter.close();
      writer.close();
    }
  }
 catch (  OptionException e) {
    log.error(""String_Node_Str"",e);
    CommandLineUtil.printHelp(group);
  }
}",0.998950406717397
61263,"/** 
 * Emit the point to the most likely cluster
 * @param vector a VectorWritable holding the Vector
 * @param clusters a List of DirichletClusters
 * @param pi the normalized pdf Vector for the point
 * @param writer a SequenceFile.Writer to emit to
 * @throws IOException
 */
private void emitMostLikelyCluster(VectorWritable vector,List<DirichletCluster> clusters,Vector pi,Writer writer) throws IOException {
  for (int i=0; i < clusters.size(); i++) {
    double pdf=pi.get(i);
    if (pdf > threshold && clusters.get(i).getTotalCount() > 0) {
      writer.append(new IntWritable(i),new WeightedVectorWritable(pdf,vector));
    }
  }
}","/** 
 * Emit the point to the most likely cluster
 * @param vector a VectorWritable holding the Vector
 * @param clusters a List of DirichletClusters
 * @param pi the normalized pdf Vector for the point
 * @param writer a SequenceFile.Writer to emit to
 * @throws IOException
 */
private void emitMostLikelyCluster(VectorWritable vector,List<DirichletCluster> clusters,Vector pi,Writer writer) throws IOException {
  double maxPdf=0;
  int clusterId=-1;
  for (int i=0; i < clusters.size(); i++) {
    double pdf=pi.get(i);
    if (pdf > maxPdf) {
      maxPdf=pdf;
      clusterId=i;
    }
  }
  writer.append(new IntWritable(clusterId),new WeightedVectorWritable(maxPdf,vector));
}",0.7758490566037736
61264,"@Override public double pdf(VectorWritable v){
  Vector x=v.get();
  double pdf=pdf(x,stdDev.get(0));
  for (int i=1; i < x.size(); i++) {
    pdf*=pdf(x,stdDev.get(i));
  }
  return pdf;
}","@Override public double pdf(VectorWritable v){
  Vector x=v.get();
  double pdf=1;
  for (int i=0; i < x.size(); i++) {
    pdf*=UncommonDistributions.dNorm(x.getQuick(i),getCenter().getQuick(i),getRadius().getQuick(i));
  }
  return pdf;
}",0.6573426573426573
61265,"/** 
 * Calculate a pdf using the supplied sample and stdDev
 * @param x a Vector sample
 * @param sd a double std deviation
 */
private double pdf(Vector x,double sd){
  double sd2=sd * sd;
  double exp=-(x.dot(x) - 2 * x.dot(getCenter()) + getCenter().dot(getCenter())) / (2 * sd2);
  double ex=Math.exp(exp);
  return ex / (sd * SQRT2PI);
}","@Override public double pdf(VectorWritable vw){
  Vector x=vw.get();
  double pdf=0;
  for (int i=0; i < x.size(); i++) {
    double x2=x.get(i);
    double m=getCenter().get(i);
    double s=getRadius().get(i);
    double dNorm=UncommonDistributions.dNorm(x2,m,s);
    pdf+=dNorm;
  }
  return pdf / x.size();
}",0.015267175572519
61266,"public static void main(String[] args) throws Exception {
  VectorWritable modelPrototype=new VectorWritable(new DenseVector(2));
  ModelDistribution<VectorWritable> modelDist=new GaussianClusterDistribution(modelPrototype);
  RandomUtils.useTestSeed();
  generateSamples();
  int numIterations=40;
  int numClusters=40;
  int alpha_0=1;
  int thin=3;
  int burnin=5;
  generateResults(modelDist,numClusters,numIterations,alpha_0,thin,burnin);
  new DisplayDirichlet();
}","public static void main(String[] args) throws Exception {
  VectorWritable modelPrototype=new VectorWritable(new DenseVector(2));
  ModelDistribution<VectorWritable> modelDist=new AsymmetricSampledNormalDistribution(modelPrototype);
  RandomUtils.useTestSeed();
  generateSamples();
  int numIterations=40;
  int numClusters=40;
  int alpha_0=1;
  int thin=3;
  int burnin=5;
  generateResults(modelDist,numClusters,numIterations,alpha_0,thin,burnin);
  new DisplayDirichlet();
}",0.96
61267,"public double aggregate(Vector other,BinaryFunction aggregator,BinaryFunction combiner){
  double result=0.0;
  for (int i=0; i < size; i++) {
    result=aggregator.apply(result,combiner.apply(getQuick(i),other.getQuick(i)));
  }
  return result;
}","public double aggregate(Vector other,BinaryFunction aggregator,BinaryFunction combiner){
  if (size < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double result=combiner.apply(getQuick(0),other.getQuick(0));
  for (int i=1; i < size; i++) {
    result=aggregator.apply(result,combiner.apply(getQuick(i),other.getQuick(i)));
  }
  return result;
}",0.7948303715670436
61268,"/** 
 * Merge the given canopy into the canopies list. If it touches any existing canopy (norm<T1) then add the center of each to the other. If it covers any other canopies (norm<T2), then merge the given canopy with the closest covering canopy. If the given canopy does not cover any other canopies, add it to the canopies list.
 * @param aCanopy a MeanShiftCanopy to be merged
 * @param canopies the List<Canopy> to be appended
 */
public void mergeCanopy(MeanShiftCanopy aCanopy,List<MeanShiftCanopy> canopies){
  MeanShiftCanopy closestCoveringCanopy=null;
  double closestNorm=Double.MAX_VALUE;
  for (  MeanShiftCanopy canopy : canopies) {
    double norm=measure.distance(canopy.getCenter(),aCanopy.getCenter());
    if (norm < t1) {
      aCanopy.touch(canopy);
    }
    if (norm < t2) {
      if ((closestCoveringCanopy == null) || (norm < closestNorm)) {
        closestNorm=norm;
        closestCoveringCanopy=canopy;
      }
    }
  }
  if (closestCoveringCanopy == null) {
    canopies.add(aCanopy);
  }
 else {
    closestCoveringCanopy.merge(aCanopy);
  }
}","/** 
 * Merge the given canopy into the canopies list. If it touches any existing canopy (norm<T1) then add the center of each to the other. If it covers any other canopies (norm<T2), then merge the given canopy with the closest covering canopy. If the given canopy does not cover any other canopies, add it to the canopies list.
 * @param aCanopy a MeanShiftCanopy to be merged
 * @param canopies the List<Canopy> to be appended
 */
public void mergeCanopy(MeanShiftCanopy aCanopy,List<MeanShiftCanopy> canopies){
  MeanShiftCanopy closestCoveringCanopy=null;
  double closestNorm=Double.MAX_VALUE;
  for (  MeanShiftCanopy canopy : canopies) {
    double norm=measure.distance(canopy.getCenter(),aCanopy.getCenter());
    if (norm < t1) {
      aCanopy.touch(canopy);
    }
    if (norm < t2 && ((closestCoveringCanopy == null) || (norm < closestNorm))) {
      closestNorm=norm;
      closestCoveringCanopy=canopy;
    }
  }
  if (closestCoveringCanopy == null) {
    canopies.add(aCanopy);
  }
 else {
    closestCoveringCanopy.merge(aCanopy);
  }
}",0.986829727187206
61269,"/** 
 * This is the reference mean-shift implementation. Given its inputs it iterates over the points and clusters until their centers converge or until the maximum number of iterations is exceeded.
 * @param points the input List<Vector> of points
 * @param measure the DistanceMeasure to use
 * @param numIter the maximum number of iterations
 */
public static List<MeanShiftCanopy> clusterPoints(List<Vector> points,DistanceMeasure measure,double convergenceThreshold,double t1,double t2,int numIter){
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(measure,t1,t2,convergenceThreshold);
  List<MeanShiftCanopy> canopies=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector point : points) {
    clusterer.mergeCanopy(new MeanShiftCanopy(point,nextCanopyId++),canopies);
  }
  boolean converged=false;
  for (int iter=0; !converged && iter < numIter; iter++) {
    converged=runMeanShiftCanopyIteration(canopies,clusterer);
  }
  return canopies;
}","/** 
 * This is the reference mean-shift implementation. Given its inputs it iterates over the points and clusters until their centers converge or until the maximum number of iterations is exceeded.
 * @param points the input List<Vector> of points
 * @param measure the DistanceMeasure to use
 * @param numIter the maximum number of iterations
 */
public static List<MeanShiftCanopy> clusterPoints(List<Vector> points,DistanceMeasure measure,double convergenceThreshold,double t1,double t2,int numIter){
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(measure,t1,t2,convergenceThreshold);
  List<MeanShiftCanopy> canopies=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector point : points) {
    clusterer.mergeCanopy(new MeanShiftCanopy(point,nextCanopyId++),canopies);
  }
  boolean converged=false;
  for (int iter=0; !converged && iter < numIter; iter++) {
    converged=true;
    List<MeanShiftCanopy> migratedCanopies=new ArrayList<MeanShiftCanopy>();
    for (    MeanShiftCanopy canopy : canopies) {
      converged=clusterer.shiftToMean(canopy) && converged;
      clusterer.mergeCanopy(canopy,migratedCanopies);
    }
    canopies=migratedCanopies;
  }
  return canopies;
}",0.8592123132639203
61270,"/** 
 * Print a graphical representation of the clustered image points as a 10x10 character mask 
 */
private void printImage(List<MeanShiftCanopy> canopies){
  char[][] out=new char[10][10];
  for (int i=0; i < out.length; i++) {
    for (int j=0; j < out[0].length; j++) {
      out[i][j]=' ';
    }
  }
  for (  MeanShiftCanopy canopy : canopies) {
    int ch='A' + canopy.getCanopyId();
    for (    int pid : canopy.getBoundPoints().elements()) {
      Vector pt=raw[pid];
      out[(int)pt.getQuick(0)][(int)pt.getQuick(1)]=(char)ch;
    }
  }
  for (  char[] anOut : out) {
    System.out.println(anOut);
  }
}","/** 
 * Print a graphical representation of the clustered image points as a 10x10 character mask 
 */
private void printImage(List<MeanShiftCanopy> canopies){
  char[][] out=new char[10][10];
  for (int i=0; i < out.length; i++) {
    for (int j=0; j < out[0].length; j++) {
      out[i][j]=' ';
    }
  }
  for (  MeanShiftCanopy canopy : canopies) {
    int ch='A' + canopy.getCanopyId();
    for (    int pid : canopy.getBoundPoints().toList()) {
      Vector pt=raw[pid];
      out[(int)pt.getQuick(0)][(int)pt.getQuick(1)]=(char)ch;
    }
  }
  for (  char[] anOut : out) {
    System.out.println(anOut);
  }
}",0.9886363636363636
61271,"/** 
 * Story: User can produce final canopy centers using a EuclideanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
public void testCanopyReducerEuclidean() throws Exception {
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(euclideanDistanceMeasure,4,1,0.5);
  List<MeanShiftCanopy> canopies=getInitialCanopies();
  List<MeanShiftCanopy> mapperReference=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector aRaw : raw) {
    clusterer.mergeCanopy(new MeanShiftCanopy(aRaw,nextCanopyId++),mapperReference);
  }
  for (  MeanShiftCanopy canopy : mapperReference) {
    clusterer.shiftToMean(canopy);
  }
  List<MeanShiftCanopy> reducerReference=new ArrayList<MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : mapperReference) {
    clusterer.mergeCanopy(canopy,reducerReference);
  }
  for (  MeanShiftCanopy canopy : reducerReference) {
    clusterer.shiftToMean(canopy);
  }
  Configuration conf=new Configuration();
  conf.set(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T1_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T2_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY,""String_Node_Str"");
  MeanShiftCanopyMapper mapper=new MeanShiftCanopyMapper();
  DummyRecordWriter<Text,MeanShiftCanopy> mapWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Mapper<WritableComparable<?>,MeanShiftCanopy,Text,MeanShiftCanopy>.Context mapContext=DummyRecordWriter.build(mapper,conf,mapWriter);
  mapper.setup(mapContext);
  for (  MeanShiftCanopy canopy : canopies) {
    mapper.map(new Text(),canopy,mapContext);
  }
  mapper.cleanup(mapContext);
  assertEquals(""String_Node_Str"",1,mapWriter.getData().size());
  MeanShiftCanopyReducer reducer=new MeanShiftCanopyReducer();
  DummyRecordWriter<Text,MeanShiftCanopy> reduceWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Reducer<Text,MeanShiftCanopy,Text,MeanShiftCanopy>.Context reduceContext=DummyRecordWriter.build(reducer,conf,reduceWriter,Text.class,MeanShiftCanopy.class);
  reducer.setup(reduceContext);
  reducer.reduce(new Text(""String_Node_Str""),mapWriter.getValue(new Text(""String_Node_Str"")),reduceContext);
  reducer.cleanup(reduceContext);
  assertEquals(""String_Node_Str"",reducerReference.size(),reduceWriter.getKeys().size());
  Map<String,MeanShiftCanopy> reducerReferenceMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : reducerReference) {
    reducerReferenceMap.put(canopy.getIdentifier(),canopy);
  }
  for (  Map.Entry<String,MeanShiftCanopy> mapEntry : reducerReferenceMap.entrySet()) {
    MeanShiftCanopy refCanopy=mapEntry.getValue();
    List<MeanShiftCanopy> values=reduceWriter.getValue(new Text((refCanopy.isConverged() ? ""String_Node_Str"" : ""String_Node_Str"") + refCanopy.getCanopyId()));
    assertEquals(""String_Node_Str"",1,values.size());
    MeanShiftCanopy reducerCanopy=values.get(0);
    assertEquals(""String_Node_Str"",refCanopy.getCanopyId(),reducerCanopy.getCanopyId());
    int refNumPoints=refCanopy.getNumPoints();
    int reducerNumPoints=reducerCanopy.getNumPoints();
    assertEquals(""String_Node_Str"",refNumPoints,reducerNumPoints);
    String refCenter=refCanopy.getCenter().asFormatString();
    String reducerCenter=reducerCanopy.getCenter().asFormatString();
    assertEquals(""String_Node_Str"" + mapEntry.getKey() + ')',refCenter,reducerCenter);
    assertEquals(""String_Node_Str"",refCanopy.getBoundPoints().size(),reducerCanopy.getBoundPoints().size());
  }
}","/** 
 * Story: User can produce final canopy centers using a EuclideanDistanceMeasure and a CanopyReducer which clusters input centroid points to produce an output set of final canopy centroid points.
 */
public void testCanopyReducerEuclidean() throws Exception {
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(euclideanDistanceMeasure,4,1,0.5);
  List<MeanShiftCanopy> canopies=getInitialCanopies();
  List<MeanShiftCanopy> mapperReference=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector aRaw : raw) {
    clusterer.mergeCanopy(new MeanShiftCanopy(aRaw,nextCanopyId++),mapperReference);
  }
  for (  MeanShiftCanopy canopy : mapperReference) {
    clusterer.shiftToMean(canopy);
  }
  List<MeanShiftCanopy> reducerReference=new ArrayList<MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : mapperReference) {
    clusterer.mergeCanopy(canopy,reducerReference);
  }
  for (  MeanShiftCanopy canopy : reducerReference) {
    clusterer.shiftToMean(canopy);
  }
  Configuration conf=new Configuration();
  conf.set(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T1_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T2_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY,""String_Node_Str"");
  MeanShiftCanopyMapper mapper=new MeanShiftCanopyMapper();
  DummyRecordWriter<Text,MeanShiftCanopy> mapWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Mapper<WritableComparable<?>,MeanShiftCanopy,Text,MeanShiftCanopy>.Context mapContext=DummyRecordWriter.build(mapper,conf,mapWriter);
  mapper.setup(mapContext);
  for (  MeanShiftCanopy canopy : canopies) {
    mapper.map(new Text(),canopy,mapContext);
  }
  mapper.cleanup(mapContext);
  assertEquals(""String_Node_Str"",1,mapWriter.getData().size());
  MeanShiftCanopyReducer reducer=new MeanShiftCanopyReducer();
  DummyRecordWriter<Text,MeanShiftCanopy> reduceWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Reducer<Text,MeanShiftCanopy,Text,MeanShiftCanopy>.Context reduceContext=DummyRecordWriter.build(reducer,conf,reduceWriter,Text.class,MeanShiftCanopy.class);
  reducer.setup(reduceContext);
  reducer.reduce(new Text(""String_Node_Str""),mapWriter.getValue(new Text(""String_Node_Str"")),reduceContext);
  reducer.cleanup(reduceContext);
  assertEquals(""String_Node_Str"",reducerReference.size(),reduceWriter.getKeys().size());
  Map<String,MeanShiftCanopy> reducerReferenceMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : reducerReference) {
    reducerReferenceMap.put(canopy.getIdentifier(),canopy);
  }
  for (  Map.Entry<String,MeanShiftCanopy> mapEntry : reducerReferenceMap.entrySet()) {
    MeanShiftCanopy refCanopy=mapEntry.getValue();
    List<MeanShiftCanopy> values=reduceWriter.getValue(new Text((refCanopy.isConverged() ? ""String_Node_Str"" : ""String_Node_Str"") + refCanopy.getCanopyId()));
    assertEquals(""String_Node_Str"",1,values.size());
    MeanShiftCanopy reducerCanopy=values.get(0);
    assertEquals(""String_Node_Str"",refCanopy.getCanopyId(),reducerCanopy.getCanopyId());
    int refNumPoints=refCanopy.getNumPoints();
    int reducerNumPoints=reducerCanopy.getNumPoints();
    assertEquals(""String_Node_Str"",refNumPoints,reducerNumPoints);
    String refCenter=refCanopy.getCenter().asFormatString();
    String reducerCenter=reducerCanopy.getCenter().asFormatString();
    assertEquals(""String_Node_Str"" + mapEntry.getKey() + ')',refCenter,reducerCenter);
    assertEquals(""String_Node_Str"",refCanopy.getBoundPoints().toList().size(),reducerCanopy.getBoundPoints().toList().size());
  }
}",0.9975281516067016
61272,"/** 
 * Story: User can produce initial canopy centers using a EuclideanDistanceMeasure and a CanopyMapper/Combiner which clusters input points to produce an output set of canopies.
 */
public void testCanopyMapperEuclidean() throws Exception {
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(euclideanDistanceMeasure,4,1,0.5);
  List<MeanShiftCanopy> canopies=getInitialCanopies();
  List<MeanShiftCanopy> refCanopies=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector aRaw : raw) {
    clusterer.mergeCanopy(new MeanShiftCanopy(aRaw,nextCanopyId++),refCanopies);
  }
  Configuration conf=new Configuration();
  conf.set(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T1_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T2_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY,""String_Node_Str"");
  MeanShiftCanopyMapper mapper=new MeanShiftCanopyMapper();
  DummyRecordWriter<Text,MeanShiftCanopy> mapWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Mapper<WritableComparable<?>,MeanShiftCanopy,Text,MeanShiftCanopy>.Context mapContext=DummyRecordWriter.build(mapper,conf,mapWriter);
  mapper.setup(mapContext);
  for (  MeanShiftCanopy canopy : canopies) {
    mapper.map(new Text(),canopy,mapContext);
  }
  mapper.cleanup(mapContext);
  assertEquals(""String_Node_Str"",1,mapWriter.getData().size());
  List<MeanShiftCanopy> data=mapWriter.getValue(new Text(""String_Node_Str""));
  assertEquals(""String_Node_Str"",refCanopies.size(),data.size());
  Map<String,MeanShiftCanopy> refCanopyMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : refCanopies) {
    clusterer.shiftToMean(canopy);
    refCanopyMap.put(canopy.getIdentifier(),canopy);
  }
  Map<String,MeanShiftCanopy> canopyMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy d : data) {
    canopyMap.put(d.getIdentifier(),d);
  }
  for (  Map.Entry<String,MeanShiftCanopy> stringMeanShiftCanopyEntry : refCanopyMap.entrySet()) {
    MeanShiftCanopy ref=stringMeanShiftCanopyEntry.getValue();
    MeanShiftCanopy canopy=canopyMap.get((ref.isConverged() ? ""String_Node_Str"" : ""String_Node_Str"") + ref.getCanopyId());
    assertEquals(""String_Node_Str"",ref.getCanopyId(),canopy.getCanopyId());
    assertEquals(""String_Node_Str"" + ref.getIdentifier() + ')',ref.getCenter().asFormatString(),canopy.getCenter().asFormatString());
    assertEquals(""String_Node_Str"",ref.getBoundPoints().size(),canopy.getBoundPoints().size());
  }
}","/** 
 * Story: User can produce initial canopy centers using a EuclideanDistanceMeasure and a CanopyMapper/Combiner which clusters input points to produce an output set of canopies.
 */
public void testCanopyMapperEuclidean() throws Exception {
  MeanShiftCanopyClusterer clusterer=new MeanShiftCanopyClusterer(euclideanDistanceMeasure,4,1,0.5);
  List<MeanShiftCanopy> canopies=getInitialCanopies();
  List<MeanShiftCanopy> refCanopies=new ArrayList<MeanShiftCanopy>();
  int nextCanopyId=0;
  for (  Vector aRaw : raw) {
    clusterer.mergeCanopy(new MeanShiftCanopy(aRaw,nextCanopyId++),refCanopies);
  }
  Configuration conf=new Configuration();
  conf.set(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T1_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.T2_KEY,""String_Node_Str"");
  conf.set(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY,""String_Node_Str"");
  MeanShiftCanopyMapper mapper=new MeanShiftCanopyMapper();
  DummyRecordWriter<Text,MeanShiftCanopy> mapWriter=new DummyRecordWriter<Text,MeanShiftCanopy>();
  Mapper<WritableComparable<?>,MeanShiftCanopy,Text,MeanShiftCanopy>.Context mapContext=DummyRecordWriter.build(mapper,conf,mapWriter);
  mapper.setup(mapContext);
  for (  MeanShiftCanopy canopy : canopies) {
    mapper.map(new Text(),canopy,mapContext);
  }
  mapper.cleanup(mapContext);
  assertEquals(""String_Node_Str"",1,mapWriter.getData().size());
  List<MeanShiftCanopy> data=mapWriter.getValue(new Text(""String_Node_Str""));
  assertEquals(""String_Node_Str"",refCanopies.size(),data.size());
  Map<String,MeanShiftCanopy> refCanopyMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy canopy : refCanopies) {
    clusterer.shiftToMean(canopy);
    refCanopyMap.put(canopy.getIdentifier(),canopy);
  }
  Map<String,MeanShiftCanopy> canopyMap=new HashMap<String,MeanShiftCanopy>();
  for (  MeanShiftCanopy d : data) {
    canopyMap.put(d.getIdentifier(),d);
  }
  for (  Map.Entry<String,MeanShiftCanopy> stringMeanShiftCanopyEntry : refCanopyMap.entrySet()) {
    MeanShiftCanopy ref=stringMeanShiftCanopyEntry.getValue();
    MeanShiftCanopy canopy=canopyMap.get((ref.isConverged() ? ""String_Node_Str"" : ""String_Node_Str"") + ref.getCanopyId());
    assertEquals(""String_Node_Str"",ref.getCanopyId(),canopy.getCanopyId());
    assertEquals(""String_Node_Str"" + ref.getIdentifier() + ')',ref.getCenter().asFormatString(),canopy.getCenter().asFormatString());
    assertEquals(""String_Node_Str"",ref.getBoundPoints().toList().size(),canopy.getBoundPoints().toList().size());
  }
}",0.996514329976762
61273,"@Override public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  double sx=(double)res / DS;
  g2.setTransform(AffineTransform.getScaleInstance(sx,sx));
  g2.setColor(Color.BLACK);
  Vector dv=new DenseVector(2).assign(SIZE / 2.0);
  Vector dv1=new DenseVector(2).assign(t1);
  Vector dv2=new DenseVector(2).assign(t2);
  DisplayDirichlet.plotRectangle(g2,new DenseVector(2).assign(2),dv);
  DisplayDirichlet.plotRectangle(g2,new DenseVector(2).assign(-2),dv);
  g2.setColor(Color.DARK_GRAY);
  dv.assign(0.03);
  for (  VectorWritable v : SAMPLE_DATA) {
    DisplayDirichlet.plotRectangle(g2,v.get(),dv);
  }
  int i=0;
  for (  MeanShiftCanopy canopy : canopies) {
    if (canopy.getBoundPoints().toList().size() > 0.015 * DisplayDirichlet.SAMPLE_DATA.size()) {
      g2.setColor(COLORS[Math.min(i++,DisplayDirichlet.COLORS.length - 1)]);
      for (      int v : canopy.getBoundPoints().elements()) {
        DisplayDirichlet.plotRectangle(g2,SAMPLE_DATA.get(v).get(),dv);
      }
      DisplayDirichlet.plotEllipse(g2,canopy.getCenter(),dv1);
      DisplayDirichlet.plotEllipse(g2,canopy.getCenter(),dv2);
    }
  }
}","@Override public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  double sx=(double)res / DS;
  g2.setTransform(AffineTransform.getScaleInstance(sx,sx));
  g2.setColor(Color.BLACK);
  Vector dv=new DenseVector(2).assign(SIZE / 2.0);
  Vector dv1=new DenseVector(2).assign(t1);
  Vector dv2=new DenseVector(2).assign(t2);
  DisplayDirichlet.plotRectangle(g2,new DenseVector(2).assign(2),dv);
  DisplayDirichlet.plotRectangle(g2,new DenseVector(2).assign(-2),dv);
  g2.setColor(Color.DARK_GRAY);
  dv.assign(0.03);
  for (  VectorWritable v : SAMPLE_DATA) {
    DisplayDirichlet.plotRectangle(g2,v.get(),dv);
  }
  int i=0;
  for (  MeanShiftCanopy canopy : canopies) {
    if (canopy.getBoundPoints().toList().size() > 0.015 * DisplayDirichlet.SAMPLE_DATA.size()) {
      g2.setColor(COLORS[Math.min(i++,DisplayDirichlet.COLORS.length - 1)]);
      int count=0;
      Vector center=new DenseVector(2);
      for (      int vix : canopy.getBoundPoints().toList()) {
        Vector v=SAMPLE_DATA.get(vix).get();
        count++;
        v.addTo(center);
        DisplayDirichlet.plotRectangle(g2,v,dv);
      }
      center=center.divide(count);
      DisplayDirichlet.plotEllipse(g2,center,dv1);
      DisplayDirichlet.plotEllipse(g2,center,dv2);
    }
  }
}",0.858813700918964
61274,"public boolean inProgress(){
synchronized (inProgress) {
    return inProgress;
  }
}","public boolean inProgress(){
  return inProgress;
}",0.75
61275,"void setInProgress(boolean status){
synchronized (inProgress) {
    inProgress=status;
  }
}","void setInProgress(boolean status){
  inProgress=status;
}",0.7733333333333333
61276,"/** 
 */
protected double b00(double a,double b,RandomEngine randomGenerator){
  if (a != a_last || b != b_last) {
    a_last=a;
    b_last=b;
    a_=a - 1.0;
    b_=b - 1.0;
    double c=(b * b_) / (a * a_);
    t=(c == 1.0) ? 0.5 : (1.0 - Math.sqrt(c)) / (1.0 - c);
    fa=Math.exp(a_ * Math.log(t));
    fb=Math.exp(b_ * Math.log(1.0 - t));
    p1=t / a;
    p2=(1.0 - t) / b + p1;
  }
  double X;
  while (true) {
    double Z;
    double V;
    double U;
    if ((U=randomGenerator.raw() * p2) <= p1) {
      Z=Math.exp(Math.log(U / p1) / a);
      X=t * Z;
      if ((V=randomGenerator.raw() * fb) <= 1.0 - b_ * X) {
        break;
      }
      if (V <= 1.0 + (fb - 1.0) * Z) {
        if (Math.log(V) <= b_ * Math.log(1.0 - X)) {
          break;
        }
      }
    }
 else {
      Z=Math.exp(Math.log((U - p1) / (p2 - p1)) / b);
      X=1.0 - (1.0 - t) * Z;
      if ((V=randomGenerator.raw() * fa) <= 1.0 - a_ * (1.0 - X)) {
        break;
      }
      if (V <= 1.0 + (fa - 1.0) * Z) {
        if (Math.log(V) <= a_ * Math.log(X)) {
          break;
        }
      }
    }
  }
  return (X);
}","/** 
 */
protected double b00(double a,double b,RandomEngine randomGenerator){
  if (a != a_last || b != b_last) {
    a_last=a;
    b_last=b;
    a_=a - 1.0;
    b_=b - 1.0;
    double c=(b * b_) / (a * a_);
    if (Math.abs(c - 1.0) < 1e-8) {
      t=0.5;
    }
 else {
      t=(1.0 - Math.sqrt(c)) / (1.0 - c);
    }
    fa=Math.exp(a_ * Math.log(t));
    fb=Math.exp(b_ * Math.log(1.0 - t));
    p1=t / a;
    p2=(1.0 - t) / b + p1;
  }
  double X;
  while (true) {
    double Z;
    double V;
    double U;
    if ((U=randomGenerator.raw() * p2) <= p1) {
      Z=Math.exp(Math.log(U / p1) / a);
      X=t * Z;
      if ((V=randomGenerator.raw() * fb) <= 1.0 - b_ * X) {
        break;
      }
      if (V <= 1.0 + (fb - 1.0) * Z) {
        if (Math.log(V) <= b_ * Math.log(1.0 - X)) {
          break;
        }
      }
    }
 else {
      Z=Math.exp(Math.log((U - p1) / (p2 - p1)) / b);
      X=1.0 - (1.0 - t) * Z;
      if ((V=randomGenerator.raw() * fa) <= 1.0 - a_ * (1.0 - X)) {
        break;
      }
      if (V <= 1.0 + (fa - 1.0) * Z) {
        if (Math.log(V) <= a_ * Math.log(X)) {
          break;
        }
      }
    }
  }
  return (X);
}",0.9638128861429832
61277,"private static void setIOSort(JobConf conf){
  conf.setInt(""String_Node_Str"",100);
  conf.setInt(""String_Node_Str"",1000);
  String javaOpts=conf.get(""String_Node_Str"");
  if (javaOpts != null) {
    Matcher m=Pattern.compile(""String_Node_Str"").matcher(javaOpts);
    if (m.matches()) {
      int heapMB=Integer.parseInt(m.group(1));
      conf.setInt(""String_Node_Str"",heapMB / 2);
    }
  }
}","private static void setIOSort(JobConf conf){
  conf.setInt(""String_Node_Str"",100);
  conf.setInt(""String_Node_Str"",200);
  String javaOpts=conf.get(""String_Node_Str"");
  if (javaOpts != null) {
    Matcher m=Pattern.compile(""String_Node_Str"").matcher(javaOpts);
    if (m.find()) {
      int heapMB=Integer.parseInt(m.group(1));
      String megabyteOrGigabyte=m.group(2);
      if (""String_Node_Str"".equalsIgnoreCase(megabyteOrGigabyte)) {
        heapMB*=1024;
      }
      conf.setInt(""String_Node_Str"",heapMB / 2);
    }
  }
}",0.8311688311688312
61278,"private Vector maybePruneUserVector(Vector userVector){
  if (userVector.getNumNondefaultElements() <= MAX_PREFS_CONSIDERED) {
    return userVector;
  }
  OpenIntIntHashMap countCounts=new OpenIntIntHashMap();
  Iterator<Vector.Element> it=userVector.iterateNonZero();
  while (it.hasNext()) {
    int index=it.next().index();
    int count=indexCounts.get(index);
    countCounts.adjustOrPutValue(count,1,1);
  }
  int resultingSizeAtCutoff=0;
  int cutoff=0;
  while (resultingSizeAtCutoff <= MAX_PREFS_CONSIDERED) {
    cutoff++;
    int count=indexCounts.get(cutoff);
    resultingSizeAtCutoff+=count;
  }
  Iterator<Vector.Element> it2=userVector.iterateNonZero();
  while (it2.hasNext()) {
    Vector.Element e=it2.next();
    int index=e.index();
    int count=indexCounts.get(index);
    if (count > cutoff) {
      e.set(0.0);
    }
  }
  return userVector;
}","private Vector maybePruneUserVector(Vector userVector){
  if (userVector.getNumNondefaultElements() <= MAX_PREFS_CONSIDERED) {
    return userVector;
  }
  OpenIntIntHashMap countCounts=new OpenIntIntHashMap();
  Iterator<Vector.Element> it=userVector.iterateNonZero();
  while (it.hasNext()) {
    int index=it.next().index();
    int count=indexCounts.get(index);
    countCounts.adjustOrPutValue(count,1,1);
  }
  IntArrayList countsList=new IntArrayList(countCounts.size());
  countCounts.keys(countsList);
  int[] counts=countsList.elements();
  Arrays.sort(counts);
  int resultingSizeAtCutoff=0;
  int cutoffIndex=0;
  while (cutoffIndex < counts.length && resultingSizeAtCutoff <= MAX_PREFS_CONSIDERED) {
    int cutoff=counts[cutoffIndex];
    cutoffIndex++;
    int count=countCounts.get(cutoff);
    resultingSizeAtCutoff+=count;
  }
  cutoffIndex--;
  if (resultingSizeAtCutoff > MAX_PREFS_CONSIDERED) {
    int cutoff=counts[cutoffIndex];
    Iterator<Vector.Element> it2=userVector.iterateNonZero();
    while (it2.hasNext()) {
      Vector.Element e=it2.next();
      int index=e.index();
      int count=indexCounts.get(index);
      if (count >= cutoff) {
        e.set(0.0);
      }
    }
  }
  return userVector;
}",0.796384395813511
61279,"/** 
 * Return a human-readable formatted string representation of the vector, not intended to be complete nor usable as an input/output representation such as Json
 * @param v a Vector
 * @return a String
 */
public static String formatVector(Vector v,String[] bindings){
  StringBuilder buf=new StringBuilder();
  int nzero=0;
  Iterator<Element> iterateNonZero=v.iterateNonZero();
  while (iterateNonZero.hasNext()) {
    iterateNonZero.next();
    nzero++;
  }
  if ((nzero < v.size()) || (bindings != null)) {
    buf.append('[');
    for (int i=0; i < v.size(); i++) {
      double elem=v.get(i);
      if (elem == 0.0) {
        continue;
      }
      String label;
      if ((bindings != null) && ((label=bindings[i]) != null)) {
        buf.append(label).append(':');
      }
 else {
        buf.append(i).append(':');
      }
      buf.append(String.format(Locale.ENGLISH,""String_Node_Str"",elem)).append(""String_Node_Str"");
    }
  }
 else {
    buf.append('[');
    for (int i=0; i < v.size(); i++) {
      double elem=v.get(i);
      buf.append(String.format(Locale.ENGLISH,""String_Node_Str"",elem)).append(""String_Node_Str"");
    }
  }
  buf.setLength(buf.length() - 2);
  buf.append(']');
  return buf.toString();
}","/** 
 * Return a human-readable formatted string representation of the vector, not intended to be complete nor usable as an input/output representation such as Json
 * @param v a Vector
 * @return a String
 */
public static String formatVector(Vector v,String[] bindings){
  StringBuilder buf=new StringBuilder();
  int nzero=0;
  Iterator<Element> iterateNonZero=v.iterateNonZero();
  while (iterateNonZero.hasNext()) {
    iterateNonZero.next();
    nzero++;
  }
  if ((nzero < v.size()) || (bindings != null)) {
    buf.append('[');
    for (int i=0; i < v.size(); i++) {
      double elem=v.get(i);
      if (elem == 0.0) {
        continue;
      }
      String label;
      if ((bindings != null) && ((label=bindings[i]) != null)) {
        buf.append(label).append(':');
      }
 else {
        buf.append(i).append(':');
      }
      buf.append(String.format(Locale.ENGLISH,""String_Node_Str"",elem)).append(""String_Node_Str"");
    }
  }
 else {
    buf.append('[');
    for (int i=0; i < v.size(); i++) {
      double elem=v.get(i);
      buf.append(String.format(Locale.ENGLISH,""String_Node_Str"",elem)).append(""String_Node_Str"");
    }
  }
  if (buf.length() > 1) {
    buf.setLength(buf.length() - 2);
  }
  buf.append(']');
  return buf.toString();
}",0.98714859437751
61280,"/** 
 * This method is used by the CanopyMapper to perform canopy inclusion tests and to emit the point keyed by its covering canopies to the output. if the point is not covered by any canopies (due to canopy centroid clustering), emit the point to the closest covering canopy.
 * @param point the point to be added
 * @param canopies the List<Canopy> to be appended
 * @param collector an OutputCollector in which to emit the point
 * @param reporter to report status of the job
 */
public void emitPointToExistingCanopies(Vector point,List<Canopy> canopies,OutputCollector<Text,VectorWritable> collector,Reporter reporter) throws IOException {
  double minDist=Double.MAX_VALUE;
  Canopy closest=null;
  boolean isCovered=false;
  for (  Canopy canopy : canopies) {
    double dist=measure.distance(canopy.getCenter().getLengthSquared(),canopy.getCenter(),point);
    if (dist < t1) {
      isCovered=true;
      VectorWritable vw=new VectorWritable(point);
      collector.collect(new Text(canopy.getIdentifier()),vw);
      reporter.setStatus(""String_Node_Str"" + canopy.getIdentifier());
    }
 else     if (dist < minDist) {
      minDist=dist;
      closest=canopy;
    }
  }
  if (!isCovered) {
    VectorWritable vw=new VectorWritable(point);
    collector.collect(new Text(closest.getIdentifier()),vw);
    reporter.setStatus(""String_Node_Str"" + closest.getIdentifier());
  }
}","/** 
 * This method is used by the CanopyMapper to perform canopy inclusion tests and to emit the point keyed by its covering canopies to the output. if the point is not covered by any canopies (due to canopy centroid clustering), emit the point to the closest covering canopy.
 * @param point the point to be added
 * @param canopies the List<Canopy> to be appended
 * @param collector an OutputCollector in which to emit the point
 * @param reporter to report status of the job
 */
public void emitPointToExistingCanopies(Vector point,List<Canopy> canopies,OutputCollector<IntWritable,VectorWritable> collector,Reporter reporter) throws IOException {
  double minDist=Double.MAX_VALUE;
  Canopy closest=null;
  boolean isCovered=false;
  for (  Canopy canopy : canopies) {
    double dist=measure.distance(canopy.getCenter().getLengthSquared(),canopy.getCenter(),point);
    if (dist < t1) {
      isCovered=true;
      VectorWritable vw=new VectorWritable(point);
      collector.collect(new IntWritable(canopy.getId()),vw);
      reporter.setStatus(""String_Node_Str"" + canopy.getIdentifier());
    }
 else     if (dist < minDist) {
      minDist=dist;
      closest=canopy;
    }
  }
  if (!isCovered) {
    collector.collect(new IntWritable(closest.getId()),new VectorWritable(point));
    reporter.setStatus(""String_Node_Str"" + closest.getIdentifier());
  }
}",0.931297709923664
61281,"/** 
 * Run the job
 * @param points the input points directory pathname String
 * @param canopies the input canopies directory pathname String
 * @param output the output directory pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1 the T1 distance threshold
 * @param t2 the T2 distance threshold
 */
public static void runJob(String points,String canopies,String output,String measureClassName,double t1,double t2) throws IOException {
  Configurable client=new JobClient();
  JobConf conf=new JobConf(ClusterDriver.class);
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(t1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(t2));
  conf.set(CanopyConfigKeys.CANOPY_PATH_KEY,canopies);
  conf.setInputFormat(SequenceFileInputFormat.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(VectorWritable.class);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  FileInputFormat.setInputPaths(conf,new Path(points));
  Path outPath=new Path(output + DEFAULT_CLUSTER_OUTPUT_DIRECTORY);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(ClusterMapper.class);
  conf.setReducerClass(IdentityReducer.class);
  client.setConf(conf);
  FileSystem dfs=FileSystem.get(outPath.toUri(),conf);
  if (dfs.exists(outPath)) {
    dfs.delete(outPath,true);
  }
  JobClient.runJob(conf);
}","/** 
 * Run the job
 * @param points the input points directory pathname String
 * @param canopies the input canopies directory pathname String
 * @param output the output directory pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1 the T1 distance threshold
 * @param t2 the T2 distance threshold
 */
public static void runJob(String points,String canopies,String output,String measureClassName,double t1,double t2) throws IOException {
  Configurable client=new JobClient();
  JobConf conf=new JobConf(ClusterDriver.class);
  conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(CanopyConfigKeys.T1_KEY,String.valueOf(t1));
  conf.set(CanopyConfigKeys.T2_KEY,String.valueOf(t2));
  conf.set(CanopyConfigKeys.CANOPY_PATH_KEY,canopies);
  conf.setInputFormat(SequenceFileInputFormat.class);
  conf.setOutputKeyClass(IntWritable.class);
  conf.setOutputValueClass(VectorWritable.class);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  FileInputFormat.setInputPaths(conf,new Path(points));
  Path outPath=new Path(output + DEFAULT_CLUSTER_OUTPUT_DIRECTORY);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(ClusterMapper.class);
  conf.setReducerClass(IdentityReducer.class);
  conf.setNumReduceTasks(0);
  client.setConf(conf);
  FileSystem dfs=FileSystem.get(outPath.toUri(),conf);
  if (dfs.exists(outPath)) {
    dfs.delete(outPath,true);
  }
  JobClient.runJob(conf);
}",0.9847750865051904
61282,"@Override public void map(WritableComparable<?> key,VectorWritable point,OutputCollector<Text,VectorWritable> output,Reporter reporter) throws IOException {
  canopyClusterer.emitPointToExistingCanopies(point.get(),canopies,output,reporter);
}","@Override public void map(WritableComparable<?> key,VectorWritable point,OutputCollector<IntWritable,VectorWritable> output,Reporter reporter) throws IOException {
  canopyClusterer.emitPointToExistingCanopies(point.get(),canopies,output,reporter);
}",0.969574036511156
61283,"/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param stateIn the directory pathname for input state
 * @param output the directory pathname for output points
 */
public static void runClustering(String input,String stateIn,String output){
  Configurable client=new JobClient();
  JobConf conf=new JobConf(DirichletDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(output);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(DirichletMapper.class);
  conf.setNumReduceTasks(0);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
  }
}","/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param stateIn the directory pathname for input state
 * @param output the directory pathname for output points
 */
public static void runClustering(String input,String stateIn,String output){
  JobConf conf=new JobConf(DirichletDriver.class);
  conf.setJobName(""String_Node_Str"");
  conf.setOutputKeyClass(IntWritable.class);
  conf.setOutputValueClass(VectorWritable.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(output);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(DirichletClusterMapper.class);
  conf.setInputFormat(SequenceFileInputFormat.class);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  conf.setNumReduceTasks(0);
  conf.set(STATE_IN_KEY,stateIn);
  try {
    JobClient.runJob(conf);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
  }
}",0.5174585002862049
61284,"/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param output the directory pathname for output points
 * @param modelFactory the String ModelDistribution class name to use
 * @param numClusters the number of models
 * @param maxIterations the maximum number of iterations
 * @param alpha_0 the alpha_0 value for the DirichletDistribution
 * @param numReducers the number of Reducers desired
 */
public static void runJob(String input,String output,String modelFactory,String modelPrototype,int prototypeSize,int numClusters,int maxIterations,double alpha_0,int numReducers) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException, SecurityException, NoSuchMethodException, InvocationTargetException {
  String stateIn=output + ""String_Node_Str"";
  writeInitialState(output,stateIn,modelFactory,modelPrototype,prototypeSize,numClusters,alpha_0);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    log.info(""String_Node_Str"",iteration);
    String stateOut=output + ""String_Node_Str"" + (iteration + 1);
    runIteration(input,stateIn,stateOut,modelFactory,modelPrototype,prototypeSize,numClusters,alpha_0,numReducers);
    stateIn=stateOut;
  }
}","/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param output the directory pathname for output points
 * @param modelFactory the String ModelDistribution class name to use
 * @param modelPrototype the String class name of the model prototype
 * @param prototypeSize the int size of the prototype to use
 * @param numClusters the number of models
 * @param maxIterations the maximum number of iterations
 * @param alpha_0 the alpha_0 value for the DirichletDistribution
 * @param numReducers the number of Reducers desired
 */
public static void runJob(String input,String output,String modelFactory,String modelPrototype,int prototypeSize,int numClusters,int maxIterations,double alpha_0,int numReducers) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException, SecurityException, NoSuchMethodException, InvocationTargetException {
  String stateIn=output + ""String_Node_Str"";
  writeInitialState(output,stateIn,modelFactory,modelPrototype,prototypeSize,numClusters,alpha_0);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    log.info(""String_Node_Str"",iteration);
    String stateOut=output + ""String_Node_Str"" + (iteration + 1);
    runIteration(input,stateIn,stateOut,modelFactory,modelPrototype,prototypeSize,numClusters,alpha_0,numReducers);
    stateIn=stateOut;
  }
  runClustering(input,stateIn,output + ""String_Node_Str"");
}",0.9296296296296296
61285,"/** 
 * @return value reference if key is found, filled in with value data, or null if not found
 */
public V get(K key,V value) throws IOException {
  for (  MapFile.Reader reader : readers) {
    if (reader.get(key,value) != null) {
      return value;
    }
  }
  log.debug(""String_Node_Str"",key);
  return null;
}","/** 
 * @return value reference if key is found, filled in with value data, or null if not found
 */
public V get(K key,V value) throws IOException {
  for (  MapFile.Reader reader : readers) {
    V theValue;
    if ((theValue=(V)reader.get(key,value)) != null) {
      return theValue;
    }
  }
  log.debug(""String_Node_Str"",key);
  return null;
}",0.9355322338830584
61286,"@Override public void readFields(DataInput in) throws IOException {
  recommended=new ArrayList<RecommendedItem>();
  try {
    do {
      long itemID=in.readLong();
      float value=in.readFloat();
      if (!Float.isNaN(value)) {
        RecommendedItem recommendedItem=new GenericRecommendedItem(itemID,value);
        recommended.add(recommendedItem);
      }
    }
 while (true);
  }
 catch (  EOFException eofe) {
  }
catch (  ArrayIndexOutOfBoundsException aiooe) {
  }
}","@Override public void readFields(DataInput in) throws IOException {
  int size=in.readInt();
  recommended=new ArrayList<RecommendedItem>(size);
  for (int i=0; i < size; i++) {
    long itemID=in.readLong();
    float value=in.readFloat();
    RecommendedItem recommendedItem=new GenericRecommendedItem(itemID,value);
    recommended.add(recommendedItem);
  }
}",0.713436385255648
61287,"@Override public String toString(){
  StringBuilder result=new StringBuilder(200);
  result.append('[');
  boolean first=true;
  for (  RecommendedItem item : recommended) {
    if (first) {
      first=false;
    }
 else {
      result.append(',');
    }
    result.append(item.getItemID());
    result.append(':');
    result.append(item.getValue());
  }
  result.append(']');
  return result.toString();
}","@Override public String toString(){
  StringBuilder result=new StringBuilder(200);
  result.append('[');
  boolean first=true;
  for (  RecommendedItem item : recommended) {
    if (first) {
      first=false;
    }
 else {
      result.append(',');
    }
    result.append(String.valueOf(item.getItemID()));
    result.append(':');
    result.append(String.valueOf(item.getValue()));
  }
  result.append(']');
  return result.toString();
}",0.9622641509433962
61288,"@Override public void write(DataOutput out) throws IOException {
  for (  RecommendedItem item : recommended) {
    out.writeLong(item.getItemID());
    out.writeFloat(item.getValue());
  }
}","@Override public void write(DataOutput out) throws IOException {
  out.writeInt(recommended.size());
  for (  RecommendedItem item : recommended) {
    out.writeLong(item.getItemID());
    out.writeFloat(item.getValue());
  }
}",0.9138755980861244
61289,"private CooccurrenceCache(MapFilesMap<IntWritable,VectorWritable> map){
  this.map=map;
  columnVector=new VectorWritable();
  columnVector.set(new RandomAccessSparseVector(Integer.MAX_VALUE,1000));
}","private CooccurrenceCache(MapFilesMap<IntWritable,VectorWritable> map){
  this.map=map;
}",0.615916955017301
61290,"@Override public Vector get(IntWritable key) throws TasteException {
  VectorWritable writable;
  try {
    writable=map.get(key,columnVector);
  }
 catch (  IOException ioe) {
    throw new TasteException(ioe);
  }
  if (writable == null) {
    return null;
  }
  Vector value=writable.get();
  if (value == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  columnVector=new VectorWritable();
  columnVector.set(new RandomAccessSparseVector(Integer.MAX_VALUE,1000));
  return value;
}","@Override public Vector get(IntWritable key) throws TasteException {
  VectorWritable columnVector=new VectorWritable();
  try {
    columnVector=map.get(key,columnVector);
  }
 catch (  IOException ioe) {
    throw new TasteException(ioe);
  }
  if (columnVector == null) {
    return null;
  }
  Vector value=columnVector.get();
  if (value == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return value;
}",0.7884615384615384
61291,"@Override public void map(LongWritable userID,VectorWritable vectorWritable,OutputCollector<LongWritable,RecommendedItemsWritable> output,Reporter reporter) throws IOException {
  if ((usersToRecommendFor != null) && !usersToRecommendFor.contains(userID.get())) {
    return;
  }
  Vector userVector=vectorWritable.get();
  Iterator<Vector.Element> userVectorIterator=userVector.iterateNonZero();
  Vector recommendationVector=new RandomAccessSparseVector(Integer.MAX_VALUE,1000);
  while (userVectorIterator.hasNext()) {
    Vector.Element element=userVectorIterator.next();
    int index=element.index();
    Vector columnVector;
    try {
      columnVector=cooccurrenceColumnCache.get(new IntWritable(index));
    }
 catch (    TasteException te) {
      if (te.getCause() instanceof IOException) {
        throw (IOException)te.getCause();
      }
 else {
        throw new IOException(te.getCause());
      }
    }
    if (columnVector != null) {
      if (booleanData) {
        columnVector.addTo(recommendationVector);
      }
 else {
        double value=element.get();
        columnVector.times(value).addTo(recommendationVector);
      }
    }
  }
  Queue<RecommendedItem> topItems=new PriorityQueue<RecommendedItem>(recommendationsPerUser + 1,Collections.reverseOrder());
  Iterator<Vector.Element> recommendationVectorIterator=recommendationVector.iterateNonZero();
  LongWritable itemID=new LongWritable();
  while (recommendationVectorIterator.hasNext()) {
    Vector.Element element=recommendationVectorIterator.next();
    int index=element.index();
    if (userVector.get(index) == 0.0) {
      if (topItems.size() < recommendationsPerUser) {
        indexItemIDMap.get(new IntWritable(index),itemID);
        topItems.add(new GenericRecommendedItem(itemID.get(),(float)element.get()));
      }
 else       if (element.get() > topItems.peek().getValue()) {
        indexItemIDMap.get(new IntWritable(index),itemID);
        topItems.add(new GenericRecommendedItem(itemID.get(),(float)element.get()));
        topItems.poll();
      }
    }
  }
  List<RecommendedItem> recommendations=new ArrayList<RecommendedItem>(topItems.size());
  recommendations.addAll(topItems);
  Collections.sort(recommendations);
  output.collect(userID,new RecommendedItemsWritable(recommendations));
}","@Override public void map(LongWritable userID,VectorWritable vectorWritable,OutputCollector<LongWritable,RecommendedItemsWritable> output,Reporter reporter) throws IOException {
  if ((usersToRecommendFor != null) && !usersToRecommendFor.contains(userID.get())) {
    return;
  }
  Vector userVector=vectorWritable.get();
  Iterator<Vector.Element> userVectorIterator=userVector.iterateNonZero();
  Vector recommendationVector=new RandomAccessSparseVector(Integer.MAX_VALUE,1000);
  while (userVectorIterator.hasNext()) {
    Vector.Element element=userVectorIterator.next();
    int index=element.index();
    Vector columnVector;
    try {
      columnVector=cooccurrenceColumnCache.get(new IntWritable(index));
    }
 catch (    TasteException te) {
      if (te.getCause() instanceof IOException) {
        throw (IOException)te.getCause();
      }
 else {
        throw new IOException(te.getCause());
      }
    }
    if (columnVector != null) {
      if (booleanData) {
        columnVector.addTo(recommendationVector);
      }
 else {
        double value=element.get();
        columnVector.times(value).addTo(recommendationVector);
      }
    }
  }
  Queue<RecommendedItem> topItems=new PriorityQueue<RecommendedItem>(recommendationsPerUser + 1,Collections.reverseOrder(ByValueRecommendedItemComparator.getInstance()));
  Iterator<Vector.Element> recommendationVectorIterator=recommendationVector.iterateNonZero();
  LongWritable itemID=new LongWritable();
  while (recommendationVectorIterator.hasNext()) {
    Vector.Element element=recommendationVectorIterator.next();
    int index=element.index();
    if (userVector.get(index) == 0.0) {
      if (topItems.size() < recommendationsPerUser) {
        LongWritable theItemID=indexItemIDMap.get(new IntWritable(index),itemID);
        if (theItemID != null) {
          topItems.add(new GenericRecommendedItem(theItemID.get(),(float)element.get()));
        }
      }
 else       if (element.get() > topItems.peek().getValue()) {
        LongWritable theItemID=indexItemIDMap.get(new IntWritable(index),itemID);
        if (theItemID != null) {
          topItems.add(new GenericRecommendedItem(theItemID.get(),(float)element.get()));
          topItems.poll();
        }
      }
    }
  }
  List<RecommendedItem> recommendations=new ArrayList<RecommendedItem>(topItems.size());
  recommendations.addAll(topItems);
  Collections.sort(recommendations,ByValueRecommendedItemComparator.getInstance());
  output.collect(userID,new RecommendedItemsWritable(recommendations));
}",0.9435367114788004
61292,"public ItemPrefWithLengthWritable[] getItemPrefs(){
  Writable[] writables=get();
  ItemPrefWithLengthWritable[] itemPrefs=new ItemPrefWithLengthWritable[writables.length];
  for (int n=0; n < writables.length; n++) {
    itemPrefs[n]=(ItemPrefWithLengthWritable)writables[n];
  }
  return itemPrefs;
}","public ItemPrefWithLengthWritable[] getItemPrefs(){
  return (ItemPrefWithLengthWritable[])toArray();
}",0.4691358024691358
61293,"public UserPrefWritable[] getUserPrefs(){
  Writable[] writables=get();
  UserPrefWritable[] userPrefs=new UserPrefWritable[writables.length];
  for (int n=0; n < writables.length; n++) {
    userPrefs[n]=(UserPrefWritable)writables[n];
  }
  return userPrefs;
}","public UserPrefWritable[] getUserPrefs(){
  return (UserPrefWritable[])toArray();
}",0.4289855072463768
61294,"protected void processFile(FileLineIterator dataOrUpdateFileIterator,FastByIDMap<?> data){
  log.info(""String_Node_Str"");
  AtomicInteger count=new AtomicInteger();
  while (dataOrUpdateFileIterator.hasNext()) {
    String line=dataOrUpdateFileIterator.next();
    if (line.length() > 0) {
      processLine(line,data);
      int currentCount=count.incrementAndGet();
      if (currentCount % 1000000 == 0) {
        log.info(""String_Node_Str"",currentCount);
      }
    }
  }
  log.info(""String_Node_Str"",count.get());
}","protected void processFile(FileLineIterator dataOrUpdateFileIterator,FastByIDMap<?> data,boolean fromPriorData){
  log.info(""String_Node_Str"");
  AtomicInteger count=new AtomicInteger();
  while (dataOrUpdateFileIterator.hasNext()) {
    String line=dataOrUpdateFileIterator.next();
    if (line.length() > 0) {
      processLine(line,data,fromPriorData);
      int currentCount=count.incrementAndGet();
      if (currentCount % 1000000 == 0) {
        log.info(""String_Node_Str"",currentCount);
      }
    }
  }
  log.info(""String_Node_Str"",count.get());
}",0.9666048237476808
61295,"/** 
 * <p> Reads one line from the input file and adds the data to a   {@link Map} data structure which maps user IDsto preferences. This assumes that each line of the input file corresponds to one preference. After reading a line and determining which user and item the preference pertains to, the method should look to see if the data contains a mapping for the user ID already, and if not, add an empty  {@link List} of{@link Preference}s to the data. </p> <p> Note that if the line is empty or begins with '#' it will be ignored as a comment. </p>
 * @param line line from input data file
 * @param data all data read so far, as a mapping from user IDs to preferences
 */
protected void processLine(String line,FastByIDMap<?> data){
  if ((line.length() == 0) || (line.charAt(0) == COMMENT_CHAR)) {
    return;
  }
  int delimiterOne=line.indexOf(delimiter);
  if (delimiterOne < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  int delimiterTwo=line.indexOf(delimiter,delimiterOne + 1);
  if (delimiterTwo < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  int delimiterThree=line.indexOf(delimiter,delimiterTwo + 1);
  String userIDString=line.substring(0,delimiterOne);
  String itemIDString=line.substring(delimiterOne + 1,delimiterTwo);
  String preferenceValueString;
  if (delimiterThree > delimiterTwo) {
    preferenceValueString=line.substring(delimiterTwo + 1,delimiterThree);
  }
 else {
    preferenceValueString=line.substring(delimiterTwo + 1);
  }
  long userID=readUserIDFromString(userIDString);
  long itemID=readItemIDFromString(itemIDString);
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  Object maybePrefs=data.get(userID);
  if (maybePrefs instanceof PreferenceArray) {
    PreferenceArray prefs=(PreferenceArray)maybePrefs;
    if (preferenceValueString.length() == 0) {
      if (prefs != null) {
        boolean exists=false;
        int length=prefs.length();
        for (int i=0; i < length; i++) {
          if (prefs.getItemID(i) == itemID) {
            exists=true;
            break;
          }
        }
        if (exists) {
          if (length == 1) {
            data.remove(userID);
          }
 else {
            PreferenceArray newPrefs=new GenericUserPreferenceArray(length - 1);
            for (int i=0, j=0; i < length; i++, j++) {
              if (prefs.getItemID(i) == itemID) {
                j--;
              }
 else {
                newPrefs.set(j,prefs.get(i));
              }
            }
          }
        }
      }
    }
 else {
      float preferenceValue=Float.parseFloat(preferenceValueString);
      boolean exists=false;
      if (prefs != null) {
        for (int i=0; i < prefs.length(); i++) {
          if (prefs.getItemID(i) == itemID) {
            exists=true;
            prefs.setValue(i,preferenceValue);
            break;
          }
        }
      }
      if (!exists) {
        if (prefs == null) {
          prefs=new GenericUserPreferenceArray(1);
          ((FastByIDMap<PreferenceArray>)data).put(userID,prefs);
        }
 else {
          PreferenceArray newPrefs=new GenericUserPreferenceArray(prefs.length() + 1);
          for (int i=0, j=1; i < prefs.length(); i++, j++) {
            newPrefs.set(j,prefs.get(i));
          }
        }
        prefs.setUserID(0,userID);
        prefs.setItemID(0,itemID);
        prefs.setValue(0,preferenceValue);
      }
    }
  }
 else {
    Collection<Preference> prefs=(Collection<Preference>)maybePrefs;
    if (preferenceValueString.length() == 0) {
      if (prefs != null) {
        Iterator<Preference> prefsIterator=prefs.iterator();
        while (prefsIterator.hasNext()) {
          Preference pref=prefsIterator.next();
          if (pref.getItemID() == itemID) {
            prefsIterator.remove();
            break;
          }
        }
      }
    }
 else {
      float preferenceValue=Float.parseFloat(preferenceValueString);
      boolean exists=false;
      if (prefs != null) {
        for (        Preference pref : prefs) {
          if (pref.getItemID() == itemID) {
            exists=true;
            pref.setValue(preferenceValue);
            break;
          }
        }
      }
      if (!exists) {
        if (prefs == null) {
          prefs=new ArrayList<Preference>(2);
          ((FastByIDMap<Collection<Preference>>)data).put(userID,prefs);
        }
        prefs.add(new GenericPreference(userID,itemID,preferenceValue));
      }
    }
  }
}","/** 
 * <p> Reads one line from the input file and adds the data to a   {@link Map} data structure which maps user IDsto preferences. This assumes that each line of the input file corresponds to one preference. After reading a line and determining which user and item the preference pertains to, the method should look to see if the data contains a mapping for the user ID already, and if not, add an empty  {@link List} of{@link Preference}s to the data. </p> <p> Note that if the line is empty or begins with '#' it will be ignored as a comment. </p>
 * @param line line from input data file
 * @param data all data read so far, as a mapping from user IDs to preferences
 * @param fromPriorData an implementation detail -- if true, data will map IDs to{@link PreferenceArray} since the framework is attempting to read and update rawdata that is already in memory. Otherwise it maps to  {@link Collection}s of  {@link Preference}s, since it's reading fresh data. Subclasses must be prepared to handle this wrinkle.
 */
protected void processLine(String line,FastByIDMap<?> data,boolean fromPriorData){
  if ((line.length() == 0) || (line.charAt(0) == COMMENT_CHAR)) {
    return;
  }
  int delimiterOne=line.indexOf(delimiter);
  if (delimiterOne < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  int delimiterTwo=line.indexOf(delimiter,delimiterOne + 1);
  if (delimiterTwo < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  int delimiterThree=line.indexOf(delimiter,delimiterTwo + 1);
  String userIDString=line.substring(0,delimiterOne);
  String itemIDString=line.substring(delimiterOne + 1,delimiterTwo);
  String preferenceValueString;
  if (delimiterThree > delimiterTwo) {
    preferenceValueString=line.substring(delimiterTwo + 1,delimiterThree);
  }
 else {
    preferenceValueString=line.substring(delimiterTwo + 1);
  }
  long userID=readUserIDFromString(userIDString);
  long itemID=readItemIDFromString(itemIDString);
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  Object maybePrefs=data.get(userID);
  if (fromPriorData) {
    PreferenceArray prefs=(PreferenceArray)maybePrefs;
    if (preferenceValueString.length() == 0) {
      if (prefs != null) {
        boolean exists=false;
        int length=prefs.length();
        for (int i=0; i < length; i++) {
          if (prefs.getItemID(i) == itemID) {
            exists=true;
            break;
          }
        }
        if (exists) {
          if (length == 1) {
            data.remove(userID);
          }
 else {
            PreferenceArray newPrefs=new GenericUserPreferenceArray(length - 1);
            for (int i=0, j=0; i < length; i++, j++) {
              if (prefs.getItemID(i) == itemID) {
                j--;
              }
 else {
                newPrefs.set(j,prefs.get(i));
              }
            }
          }
        }
      }
    }
 else {
      float preferenceValue=Float.parseFloat(preferenceValueString);
      boolean exists=false;
      if (prefs != null) {
        for (int i=0; i < prefs.length(); i++) {
          if (prefs.getItemID(i) == itemID) {
            exists=true;
            prefs.setValue(i,preferenceValue);
            break;
          }
        }
      }
      if (!exists) {
        if (prefs == null) {
          prefs=new GenericUserPreferenceArray(1);
          ((FastByIDMap<PreferenceArray>)data).put(userID,prefs);
        }
 else {
          PreferenceArray newPrefs=new GenericUserPreferenceArray(prefs.length() + 1);
          for (int i=0, j=1; i < prefs.length(); i++, j++) {
            newPrefs.set(j,prefs.get(i));
          }
        }
        prefs.setUserID(0,userID);
        prefs.setItemID(0,itemID);
        prefs.setValue(0,preferenceValue);
      }
    }
  }
 else {
    Collection<Preference> prefs=(Collection<Preference>)maybePrefs;
    if (preferenceValueString.length() == 0) {
      if (prefs != null) {
        Iterator<Preference> prefsIterator=prefs.iterator();
        while (prefsIterator.hasNext()) {
          Preference pref=prefsIterator.next();
          if (pref.getItemID() == itemID) {
            prefsIterator.remove();
            break;
          }
        }
      }
    }
 else {
      float preferenceValue=Float.parseFloat(preferenceValueString);
      boolean exists=false;
      if (prefs != null) {
        for (        Preference pref : prefs) {
          if (pref.getItemID() == itemID) {
            exists=true;
            pref.setValue(preferenceValue);
            break;
          }
        }
      }
      if (!exists) {
        if (prefs == null) {
          prefs=new ArrayList<Preference>(2);
          ((FastByIDMap<Collection<Preference>>)data).put(userID,prefs);
        }
        prefs.add(new GenericPreference(userID,itemID,preferenceValue));
      }
    }
  }
}",0.9560850518217758
61296,"protected DataModel buildModel() throws IOException {
  long newLastModified=dataFile.lastModified();
  long newLastUpdateFileModified=readLastUpdateFileModified();
  boolean loadFreshData=(delegate == null) || (newLastModified > lastModified + MIN_RELOAD_INTERVAL_MS);
  lastModified=newLastModified;
  lastUpdateFileModified=newLastUpdateFileModified;
  if (hasPrefValues) {
    if (loadFreshData) {
      FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
      FileLineIterator iterator=new FileLineIterator(dataFile,false);
      processFile(iterator,data);
      for (      File updateFile : findUpdateFiles()) {
        processFile(new FileLineIterator(updateFile,false),data);
      }
      return new GenericDataModel(GenericDataModel.toDataMap(data,true));
    }
 else {
      FastByIDMap<PreferenceArray> rawData=((GenericDataModel)delegate).getRawUserData();
      for (      File updateFile : findUpdateFiles()) {
        processFile(new FileLineIterator(updateFile,false),rawData);
      }
      return new GenericDataModel(rawData);
    }
  }
 else {
    if (loadFreshData) {
      FastByIDMap<FastIDSet> data=new FastByIDMap<FastIDSet>();
      FileLineIterator iterator=new FileLineIterator(dataFile,false);
      processFileWithoutID(iterator,data);
      for (      File updateFile : findUpdateFiles()) {
        processFileWithoutID(new FileLineIterator(updateFile,false),data);
      }
      return new GenericBooleanPrefDataModel(data);
    }
 else {
      FastByIDMap<FastIDSet> rawData=((GenericBooleanPrefDataModel)delegate).getRawUserData();
      for (      File updateFile : findUpdateFiles()) {
        processFileWithoutID(new FileLineIterator(updateFile,false),rawData);
      }
      return new GenericBooleanPrefDataModel(rawData);
    }
  }
}","protected DataModel buildModel() throws IOException {
  long newLastModified=dataFile.lastModified();
  long newLastUpdateFileModified=readLastUpdateFileModified();
  boolean loadFreshData=(delegate == null) || (newLastModified > lastModified + MIN_RELOAD_INTERVAL_MS);
  lastModified=newLastModified;
  lastUpdateFileModified=newLastUpdateFileModified;
  if (hasPrefValues) {
    if (loadFreshData) {
      FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
      FileLineIterator iterator=new FileLineIterator(dataFile,false);
      processFile(iterator,data,false);
      for (      File updateFile : findUpdateFiles()) {
        processFile(new FileLineIterator(updateFile,false),data,false);
      }
      return new GenericDataModel(GenericDataModel.toDataMap(data,true));
    }
 else {
      FastByIDMap<PreferenceArray> rawData=((GenericDataModel)delegate).getRawUserData();
      for (      File updateFile : findUpdateFiles()) {
        processFile(new FileLineIterator(updateFile,false),rawData,true);
      }
      return new GenericDataModel(rawData);
    }
  }
 else {
    if (loadFreshData) {
      FastByIDMap<FastIDSet> data=new FastByIDMap<FastIDSet>();
      FileLineIterator iterator=new FileLineIterator(dataFile,false);
      processFileWithoutID(iterator,data);
      for (      File updateFile : findUpdateFiles()) {
        processFileWithoutID(new FileLineIterator(updateFile,false),data);
      }
      return new GenericBooleanPrefDataModel(data);
    }
 else {
      FastByIDMap<FastIDSet> rawData=((GenericBooleanPrefDataModel)delegate).getRawUserData();
      for (      File updateFile : findUpdateFiles()) {
        processFileWithoutID(new FileLineIterator(updateFile,false),rawData);
      }
      return new GenericBooleanPrefDataModel(rawData);
    }
  }
}",0.9953232462173316
61297,"@Override protected DataModel buildModel() throws IOException {
  FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
  FileLineIterator iterator=new FileLineIterator(getDataFile(),false);
  processFile(iterator,data);
  return new GenericDataModel(GenericDataModel.toDataMap(data,true));
}","@Override protected DataModel buildModel() throws IOException {
  FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
  FileLineIterator iterator=new FileLineIterator(getDataFile(),false);
  processFile(iterator,data,false);
  return new GenericDataModel(GenericDataModel.toDataMap(data,true));
}",0.9907692307692308
61298,"@Override protected void processLine(String line,FastByIDMap<?> rawData){
  FastByIDMap<Collection<Preference>> data=(FastByIDMap<Collection<Preference>>)rawData;
  String[] jokePrefs=line.split(""String_Node_Str"");
  int count=Integer.parseInt(jokePrefs[0]);
  Collection<Preference> prefs=new ArrayList<Preference>(count);
  for (int itemID=1; itemID < jokePrefs.length; itemID++) {
    String jokePref=jokePrefs[itemID];
    if (!""String_Node_Str"".equals(jokePref)) {
      float jokePrefValue=Float.parseFloat(jokePref);
      prefs.add(new GenericPreference(userBeingRead,itemID,jokePrefValue));
    }
  }
  data.put(userBeingRead,prefs);
  userBeingRead++;
}","@Override protected void processLine(String line,FastByIDMap<?> rawData,boolean fromPriorData){
  FastByIDMap<Collection<Preference>> data=(FastByIDMap<Collection<Preference>>)rawData;
  String[] jokePrefs=line.split(""String_Node_Str"");
  int count=Integer.parseInt(jokePrefs[0]);
  Collection<Preference> prefs=new ArrayList<Preference>(count);
  for (int itemID=1; itemID < jokePrefs.length; itemID++) {
    String jokePref=jokePrefs[itemID];
    if (!""String_Node_Str"".equals(jokePref)) {
      float jokePrefValue=Float.parseFloat(jokePref);
      prefs.add(new GenericPreference(userBeingRead,itemID,jokePrefValue));
    }
  }
  data.put(userBeingRead,prefs);
  userBeingRead++;
}",0.983679525222552
61299,"@Override public void skip(int n){
  delegate.skip((int)(n / samplingRate));
}","@Override public void skip(int n){
  delegate.skip((int)(n / samplingRate));
  if (delegate.hasNext()) {
    next=delegate.next();
  }
 else {
    hasNext=false;
  }
}",0.636734693877551
61300,"private void doNext(){
  int toSkip=0;
  while (SamplingLongPrimitiveIterator.r.nextDouble() >= samplingRate) {
    toSkip++;
  }
  if (toSkip > 0) {
    delegate.skip(toSkip);
  }
  boolean found=false;
  if (delegate.hasNext()) {
    next=delegate.next();
    found=true;
  }
  if (!found) {
    hasNext=false;
  }
}","private void doNext(){
  int toSkip=0;
  while (SamplingLongPrimitiveIterator.r.nextDouble() >= samplingRate) {
    toSkip++;
  }
  if (toSkip > 0) {
    delegate.skip(toSkip);
  }
  if (delegate.hasNext()) {
    next=delegate.next();
  }
 else {
    hasNext=false;
  }
}",0.6587436332767402
61301,"@Override public void configure(JobConf job){
  try {
    labelWeightSum.clear();
    Map<String,Double> labelWeightSumTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelWeightSumTemp));
    String labelWeightSumString=mapStringifier.toString(labelWeightSumTemp);
    labelWeightSumString=job.get(""String_Node_Str"",labelWeightSumString);
    labelWeightSumTemp=mapStringifier.fromString(labelWeightSumString);
    for (    String key : labelWeightSumTemp.keySet()) {
      this.labelWeightSum.put(key,labelWeightSumTemp.get(key));
    }
    DefaultStringifier<Double> stringifier=new DefaultStringifier<Double>(job,GenericsUtil.getClass(sigmaJSigmaK));
    String sigmaJSigmaKString=stringifier.toString(sigmaJSigmaK);
    sigmaJSigmaKString=job.get(""String_Node_Str"",sigmaJSigmaKString);
    sigmaJSigmaK=stringifier.fromString(sigmaJSigmaKString);
    String vocabCountString=stringifier.toString(vocabCount);
    vocabCountString=job.get(""String_Node_Str"",vocabCountString);
    vocabCount=stringifier.fromString(vocabCountString);
    Parameters params=Parameters.fromString(job.get(""String_Node_Str"",""String_Node_Str""));
    alphaI=Double.valueOf(params.get(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}","@Override public void configure(JobConf job){
  try {
    labelWeightSum.clear();
    Map<String,Double> labelWeightSumTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelWeightSumTemp));
    String labelWeightSumString=mapStringifier.toString(labelWeightSumTemp);
    labelWeightSumString=job.get(""String_Node_Str"",labelWeightSumString);
    labelWeightSumTemp=mapStringifier.fromString(labelWeightSumString);
    for (    Map.Entry<String,Double> stringDoubleEntry : labelWeightSumTemp.entrySet()) {
      this.labelWeightSum.put(stringDoubleEntry.getKey(),stringDoubleEntry.getValue());
    }
    DefaultStringifier<Double> stringifier=new DefaultStringifier<Double>(job,GenericsUtil.getClass(sigmaJSigmaK));
    String sigmaJSigmaKString=stringifier.toString(sigmaJSigmaK);
    sigmaJSigmaKString=job.get(""String_Node_Str"",sigmaJSigmaKString);
    sigmaJSigmaK=stringifier.fromString(sigmaJSigmaKString);
    String vocabCountString=stringifier.toString(vocabCount);
    vocabCountString=job.get(""String_Node_Str"",vocabCountString);
    vocabCount=stringifier.fromString(vocabCountString);
    Parameters params=Parameters.fromString(job.get(""String_Node_Str"",""String_Node_Str""));
    alphaI=Double.valueOf(params.get(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}",0.952683615819209
61302,"@Override public void configure(JobConf job){
  try {
    labelWeightSum.clear();
    Map<String,Double> labelWeightSumTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelWeightSumTemp));
    String labelWeightSumString=mapStringifier.toString(labelWeightSumTemp);
    labelWeightSumString=job.get(""String_Node_Str"",labelWeightSumString);
    labelWeightSumTemp=mapStringifier.fromString(labelWeightSumString);
    for (    String key : labelWeightSumTemp.keySet()) {
      this.labelWeightSum.put(key,labelWeightSumTemp.get(key));
    }
    DefaultStringifier<Double> stringifier=new DefaultStringifier<Double>(job,GenericsUtil.getClass(sigmaJSigmaK));
    String sigmaJSigmaKString=stringifier.toString(sigmaJSigmaK);
    sigmaJSigmaKString=job.get(""String_Node_Str"",sigmaJSigmaKString);
    sigmaJSigmaK=stringifier.fromString(sigmaJSigmaKString);
    String vocabCountString=stringifier.toString(vocabCount);
    vocabCountString=job.get(""String_Node_Str"",vocabCountString);
    vocabCount=stringifier.fromString(vocabCountString);
    Parameters params=Parameters.fromString(job.get(""String_Node_Str"",""String_Node_Str""));
    alphaI=Double.valueOf(params.get(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}","@Override public void configure(JobConf job){
  try {
    labelWeightSum.clear();
    Map<String,Double> labelWeightSumTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelWeightSumTemp));
    String labelWeightSumString=mapStringifier.toString(labelWeightSumTemp);
    labelWeightSumString=job.get(""String_Node_Str"",labelWeightSumString);
    labelWeightSumTemp=mapStringifier.fromString(labelWeightSumString);
    for (    Map.Entry<String,Double> stringDoubleEntry : labelWeightSumTemp.entrySet()) {
      this.labelWeightSum.put(stringDoubleEntry.getKey(),stringDoubleEntry.getValue());
    }
    DefaultStringifier<Double> stringifier=new DefaultStringifier<Double>(job,GenericsUtil.getClass(sigmaJSigmaK));
    String sigmaJSigmaKString=stringifier.toString(sigmaJSigmaK);
    sigmaJSigmaKString=job.get(""String_Node_Str"",sigmaJSigmaKString);
    sigmaJSigmaK=stringifier.fromString(sigmaJSigmaKString);
    String vocabCountString=stringifier.toString(vocabCount);
    vocabCountString=job.get(""String_Node_Str"",vocabCountString);
    vocabCount=stringifier.fromString(vocabCountString);
    Parameters params=Parameters.fromString(job.get(""String_Node_Str"",""String_Node_Str""));
    alphaI=Double.valueOf(params.get(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}",0.952683615819209
61303,"@Override public void configure(JobConf job){
  try {
    this.labelDocumentCounts.clear();
    Map<String,Double> labelDocCountTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelDocCountTemp));
    String labelDocumentCountString=mapStringifier.toString(labelDocCountTemp);
    labelDocumentCountString=job.get(""String_Node_Str"",labelDocumentCountString);
    labelDocCountTemp=mapStringifier.fromString(labelDocumentCountString);
    for (    String key : labelDocCountTemp.keySet()) {
      this.labelDocumentCounts.put(key,labelDocCountTemp.get(key));
    }
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}","@Override public void configure(JobConf job){
  try {
    this.labelDocumentCounts.clear();
    Map<String,Double> labelDocCountTemp=new HashMap<String,Double>();
    DefaultStringifier<Map<String,Double>> mapStringifier=new DefaultStringifier<Map<String,Double>>(job,GenericsUtil.getClass(labelDocCountTemp));
    String labelDocumentCountString=mapStringifier.toString(labelDocCountTemp);
    labelDocumentCountString=job.get(""String_Node_Str"",labelDocumentCountString);
    labelDocCountTemp=mapStringifier.fromString(labelDocumentCountString);
    for (    Map.Entry<String,Double> stringDoubleEntry : labelDocCountTemp.entrySet()) {
      this.labelDocumentCounts.put(stringDoubleEntry.getKey(),stringDoubleEntry.getValue());
    }
  }
 catch (  IOException ex) {
    log.warn(ex.toString(),ex);
  }
}",0.9143593045717964
61304,"/** 
 * Configure the Canopy and its distance measure
 * @param job the JobConf for this job
 */
public void configure(JobConf job){
  try {
    measure=Class.forName(job.get(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY)).asSubclass(DistanceMeasure.class).newInstance();
    measure.configure(job);
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalStateException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalStateException(e);
  }
  nextCanopyId=0;
  t1=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.T1_KEY));
  t2=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.T2_KEY));
  convergenceDelta=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY));
}","/** 
 * Configure the Canopy and its distance measure
 * @param job the JobConf for this job
 */
public void configure(JobConf job){
  try {
    measure=Class.forName(job.get(MeanShiftCanopyConfigKeys.DISTANCE_MEASURE_KEY)).asSubclass(DistanceMeasure.class).newInstance();
    measure.configure(job);
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalStateException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalStateException(e);
  }
  t1=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.T1_KEY));
  t2=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.T2_KEY));
  convergenceDelta=Double.parseDouble(job.get(MeanShiftCanopyConfigKeys.CLUSTER_CONVERGENCE_KEY));
}",0.9886649874055417
61305,"/** 
 * Configure the Canopy for unit tests
 * @param aDelta the convergence criteria
 */
public void config(DistanceMeasure aMeasure,double aT1,double aT2,double aDelta){
  nextCanopyId=100;
  measure=aMeasure;
  t1=aT1;
  t2=aT2;
  convergenceDelta=aDelta;
}","/** 
 * Configure the Canopy for unit tests
 * @param aDelta the convergence criteria
 */
public void config(DistanceMeasure aMeasure,double aT1,double aT2,double aDelta){
  measure=aMeasure;
  t1=aT1;
  t2=aT2;
  convergenceDelta=aDelta;
}",0.864
61306,"/** 
 * Extracts the output and processes it
 * @param job
 * @param callback
 * @throws IOException
 */
protected void parseOutput(JobConf job,PredictionCallback callback) throws IOException {
  int numMaps=job.getNumMapTasks();
  int numTrees=Builder.getNbTrees(job);
  int total=0;
  for (int partition=0; partition < numMaps; partition++) {
    total+=Step2Mapper.nbConcerned(numMaps,numTrees,partition);
  }
  int[] firstIds=Step0Output.extractFirstIds(partitions);
  PartialBuilder.processOutput(job,outputPath,firstIds,null,null,callback);
}","/** 
 * Extracts the output and processes it
 * @param job
 * @param callback
 * @throws IOException
 */
protected void parseOutput(JobConf job,PredictionCallback callback) throws IOException {
  int numMaps=job.getNumMapTasks();
  int numTrees=Builder.getNbTrees(job);
  for (int partition=0; partition < numMaps; partition++) {
    Step2Mapper.nbConcerned(numMaps,numTrees,partition);
  }
  int[] firstIds=Step0Output.extractFirstIds(partitions);
  PartialBuilder.processOutput(job,outputPath,firstIds,null,null,callback);
}",0.8100558659217877
61307,"protected static Map<String,String> parseArguments(String[] args,Option... extraOpts){
  Option inputOpt=DefaultOptionCreator.inputOption().create();
  Option tempDirOpt=AbstractJob.buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option outputOpt=DefaultOptionCreator.outputOption().create();
  Option helpOpt=DefaultOptionCreator.helpOption();
  Option jarFileOpt=AbstractJob.buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  GroupBuilder gBuilder=new GroupBuilder().withName(""String_Node_Str"").withOption(inputOpt).withOption(tempDirOpt).withOption(outputOpt).withOption(helpOpt).withOption(jarFileOpt);
  for (  Option opt : extraOpts) {
    gBuilder=gBuilder.withOption(opt);
  }
  Group group=gBuilder.create();
  CommandLine cmdLine;
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    cmdLine=parser.parse(args);
  }
 catch (  OptionException e) {
    AbstractJob.log.error(e.getMessage());
    CommandLineUtil.printHelp(group);
    return null;
  }
  if (cmdLine.hasOption(helpOpt)) {
    CommandLineUtil.printHelp(group);
    return null;
  }
  Map<String,String> result=new HashMap<String,String>();
  AbstractJob.maybePut(result,cmdLine,inputOpt);
  AbstractJob.maybePut(result,cmdLine,tempDirOpt);
  AbstractJob.maybePut(result,cmdLine,outputOpt);
  AbstractJob.maybePut(result,cmdLine,helpOpt);
  AbstractJob.maybePut(result,cmdLine,jarFileOpt);
  for (  Option opt : extraOpts) {
    AbstractJob.maybePut(result,cmdLine,opt);
  }
  return result;
}","protected static Map<String,String> parseArguments(String[] args,Option... extraOpts){
  Option inputOpt=DefaultOptionCreator.inputOption().create();
  Option tempDirOpt=AbstractJob.buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option outputOpt=DefaultOptionCreator.outputOption().create();
  Option helpOpt=DefaultOptionCreator.helpOption();
  Option jarFileOpt=AbstractJob.buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  GroupBuilder gBuilder=new GroupBuilder().withName(""String_Node_Str"").withOption(inputOpt).withOption(tempDirOpt).withOption(outputOpt).withOption(helpOpt).withOption(jarFileOpt);
  for (  Option opt : extraOpts) {
    gBuilder=gBuilder.withOption(opt);
  }
  Group group=gBuilder.create();
  CommandLine cmdLine;
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    cmdLine=parser.parse(args);
  }
 catch (  OptionException e) {
    log.error(e.getMessage());
    CommandLineUtil.printHelp(group);
    return null;
  }
  if (cmdLine.hasOption(helpOpt)) {
    CommandLineUtil.printHelp(group);
    return null;
  }
  Map<String,String> result=new HashMap<String,String>();
  AbstractJob.maybePut(result,cmdLine,inputOpt);
  AbstractJob.maybePut(result,cmdLine,tempDirOpt);
  AbstractJob.maybePut(result,cmdLine,outputOpt);
  AbstractJob.maybePut(result,cmdLine,helpOpt);
  AbstractJob.maybePut(result,cmdLine,jarFileOpt);
  for (  Option opt : extraOpts) {
    AbstractJob.maybePut(result,cmdLine,opt);
  }
  return result;
}",0.99609375
61308,"@Override public int run(String[] args) throws IOException {
  if (args.length < 2) {
    ItemBigramGenerator.log.error(""String_Node_Str"");
    ToolRunner.printGenericCommandUsage(System.out);
    return -1;
  }
  String inputPaths=args[0];
  Path outputPath=new Path(args[1]);
  int reducers=args.length > 2 ? Integer.parseInt(args[2]) : 1;
  JobConf jobConf=prepareJob(inputPaths,outputPath,reducers);
  JobClient.runJob(jobConf);
  return 0;
}","@Override public int run(String[] args) throws IOException {
  if (args.length < 2) {
    log.error(""String_Node_Str"");
    ToolRunner.printGenericCommandUsage(System.out);
    return -1;
  }
  String inputPaths=args[0];
  Path outputPath=new Path(args[1]);
  int reducers=args.length > 2 ? Integer.parseInt(args[2]) : 1;
  JobConf jobConf=prepareJob(inputPaths,outputPath,reducers);
  JobClient.runJob(jobConf);
  return 0;
}",0.9770642201834864
61309,"@Override public void map(LongWritable lineNumber,Text userPrefEntry,OutputCollector<VIntWritable,VIntWritable> output,Reporter reporter) throws IOException {
  String userPrefLine=userPrefEntry.toString();
  String[] prefFields=userPrefLine.split(fieldSeparator);
  if (prefFields.length > 1) {
    try {
      int userId=Integer.parseInt(prefFields[0]);
      int itemId=Integer.parseInt(prefFields[1]);
      user.set(userId);
      item.set(itemId);
      output.collect(user,item);
    }
 catch (    NumberFormatException nfe) {
      reporter.incrCounter(Records.INVALID_IDS,1);
      UserItemMapper.log.warn(""String_Node_Str"",userPrefLine);
    }
catch (    IllegalArgumentException iae) {
      reporter.incrCounter(Records.INVALID_IDS,1);
      UserItemMapper.log.warn(""String_Node_Str"",userPrefLine);
    }
  }
 else {
    reporter.incrCounter(Records.INVALID_SCHEMA,1);
    UserItemMapper.log.warn(""String_Node_Str"",userPrefLine);
  }
}","@Override public void map(LongWritable lineNumber,Text userPrefEntry,OutputCollector<VIntWritable,VIntWritable> output,Reporter reporter) throws IOException {
  String userPrefLine=userPrefEntry.toString();
  String[] prefFields=userPrefLine.split(fieldSeparator);
  if (prefFields.length > 1) {
    try {
      int userId=Integer.parseInt(prefFields[0]);
      int itemId=Integer.parseInt(prefFields[1]);
      user.set(userId);
      item.set(itemId);
      output.collect(user,item);
    }
 catch (    NumberFormatException nfe) {
      reporter.incrCounter(Records.INVALID_IDS,1);
      log.warn(""String_Node_Str"",userPrefLine);
    }
catch (    IllegalArgumentException iae) {
      reporter.incrCounter(Records.INVALID_IDS,1);
      log.warn(""String_Node_Str"",userPrefLine);
    }
  }
 else {
    reporter.incrCounter(Records.INVALID_SCHEMA,1);
    log.warn(""String_Node_Str"",userPrefLine);
  }
}",0.9756625202812332
61310,"@Override public void map(VIntWritable item1,VIntWritable item2,OutputCollector<Bigram,Bigram> output,Reporter reporter) throws IOException {
  keyBigram.set(item1.get(),item2.get());
  valueBigram.set(item2.get(),ItemItemMapper.ONE);
  output.collect(keyBigram,valueBigram);
}","@Override public void map(VIntWritable item1,VIntWritable item2,OutputCollector<Bigram,Bigram> output,Reporter reporter) throws IOException {
  keyBigram.set(item1.get(),item2.get());
  valueBigram.set(item2.get(),ONE);
  output.collect(keyBigram,valueBigram);
}",0.9721706864564008
61311,"@Override public int run(String[] args) throws IOException {
  if (args.length < 3) {
    UserItemJoiner.log.error(""String_Node_Str"");
    ToolRunner.printGenericCommandUsage(System.out);
    return -1;
  }
  Path userInputPath=new Path(args[0]);
  Path itemInputPath=new Path(args[1]);
  Path outputPath=new Path(args[2]);
  int reducers=args.length > 3 ? Integer.parseInt(args[3]) : 1;
  JobConf jobConf=prepareJob(userInputPath,itemInputPath,outputPath,reducers);
  JobClient.runJob(jobConf);
  return 0;
}","@Override public int run(String[] args) throws IOException {
  if (args.length < 3) {
    log.error(""String_Node_Str"");
    ToolRunner.printGenericCommandUsage(System.out);
    return -1;
  }
  Path userInputPath=new Path(args[0]);
  Path itemInputPath=new Path(args[1]);
  Path outputPath=new Path(args[2]);
  int reducers=args.length > 3 ? Integer.parseInt(args[3]) : 1;
  JobConf jobConf=prepareJob(userInputPath,itemInputPath,outputPath,reducers);
  JobClient.runJob(jobConf);
  return 0;
}",0.9850448654037888
61312,"@Override public void configure(JobConf jobConf){
  try {
    FileSystem fs=FileSystem.get(jobConf);
    Path cooccurrencePath=new Path(jobConf.get(RecommenderMapper.COOCCURRENCE_PATH)).makeQualified(fs);
    Path itemIDIndexPath=new Path(jobConf.get(RecommenderMapper.ITEMID_INDEX_PATH)).makeQualified(fs);
    recommendationsPerUser=jobConf.getInt(RecommenderMapper.RECOMMENDATIONS_PER_USER,10);
    indexItemIDMap=new MapFilesMap<IntWritable,LongWritable>(fs,itemIDIndexPath,new Configuration());
    cooccurrenceColumnMap=new MapFilesMap<IntWritable,VectorWritable>(fs,cooccurrencePath,new Configuration());
    String usersFilePathString=jobConf.get(RecommenderMapper.USERS_FILE);
    if (usersFilePathString == null) {
      usersToRecommendFor=null;
    }
 else {
      usersToRecommendFor=new FastIDSet();
      Path usersFilePath=new Path(usersFilePathString).makeQualified(fs);
      FSDataInputStream in=fs.open(usersFilePath);
      for (      String line : new FileLineIterable(in)) {
        usersToRecommendFor.add(Long.parseLong(line));
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
  cooccurrenceColumnCache=new Cache<IntWritable,Vector>(new CooccurrenceCache(cooccurrenceColumnMap),100);
}","@Override public void configure(JobConf jobConf){
  try {
    FileSystem fs=FileSystem.get(jobConf);
    Path cooccurrencePath=new Path(jobConf.get(COOCCURRENCE_PATH)).makeQualified(fs);
    Path itemIDIndexPath=new Path(jobConf.get(ITEMID_INDEX_PATH)).makeQualified(fs);
    recommendationsPerUser=jobConf.getInt(RECOMMENDATIONS_PER_USER,10);
    indexItemIDMap=new MapFilesMap<IntWritable,LongWritable>(fs,itemIDIndexPath,new Configuration());
    cooccurrenceColumnMap=new MapFilesMap<IntWritable,VectorWritable>(fs,cooccurrencePath,new Configuration());
    String usersFilePathString=jobConf.get(USERS_FILE);
    if (usersFilePathString == null) {
      usersToRecommendFor=null;
    }
 else {
      usersToRecommendFor=new FastIDSet();
      Path usersFilePath=new Path(usersFilePathString).makeQualified(fs);
      FSDataInputStream in=fs.open(usersFilePath);
      for (      String line : new FileLineIterable(in)) {
        usersToRecommendFor.add(Long.parseLong(line));
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
  cooccurrenceColumnCache=new Cache<IntWritable,Vector>(new CooccurrenceCache(cooccurrenceColumnMap),100);
}",0.9704433497536946
61313,"@Override public void reduce(LongWritable userID,Iterator<ItemPrefWritable> itemPrefs,OutputCollector<LongWritable,VectorWritable> output,Reporter reporter) throws IOException {
  if (itemPrefs.hasNext()) {
    RandomAccessSparseVector userVector=new RandomAccessSparseVector(Integer.MAX_VALUE,100);
    while (itemPrefs.hasNext()) {
      ItemPrefWritable itemPref=itemPrefs.next();
      int index=ItemIDIndexMapper.idToIndex(itemPref.getItemID());
      userVector.set(index,itemPref.getPrefValue());
    }
    if (userVector.getNumNondefaultElements() > ToUserVectorReducer.MAX_PREFS_CONSIDERED) {
      double cutoff=ToUserVectorReducer.findTopNPrefsCutoff(ToUserVectorReducer.MAX_PREFS_CONSIDERED,userVector);
      RandomAccessSparseVector filteredVector=new RandomAccessSparseVector(Integer.MAX_VALUE,ToUserVectorReducer.MAX_PREFS_CONSIDERED);
      Iterator<Vector.Element> it=userVector.iterateNonZero();
      while (it.hasNext()) {
        Vector.Element element=it.next();
        if (element.get() >= cutoff) {
          filteredVector.set(element.index(),element.get());
        }
      }
      userVector=filteredVector;
    }
    vectorWritable.set(userVector);
    output.collect(userID,vectorWritable);
  }
}","@Override public void reduce(LongWritable userID,Iterator<ItemPrefWritable> itemPrefs,OutputCollector<LongWritable,VectorWritable> output,Reporter reporter) throws IOException {
  if (itemPrefs.hasNext()) {
    RandomAccessSparseVector userVector=new RandomAccessSparseVector(Integer.MAX_VALUE,100);
    while (itemPrefs.hasNext()) {
      ItemPrefWritable itemPref=itemPrefs.next();
      int index=ItemIDIndexMapper.idToIndex(itemPref.getItemID());
      userVector.set(index,itemPref.getPrefValue());
    }
    if (userVector.getNumNondefaultElements() > MAX_PREFS_CONSIDERED) {
      double cutoff=findTopNPrefsCutoff(MAX_PREFS_CONSIDERED,userVector);
      RandomAccessSparseVector filteredVector=new RandomAccessSparseVector(Integer.MAX_VALUE,MAX_PREFS_CONSIDERED);
      Iterator<Vector.Element> it=userVector.iterateNonZero();
      while (it.hasNext()) {
        Vector.Element element=it.next();
        if (element.get() >= cutoff) {
          filteredVector.set(element.index(),element.get());
        }
      }
      userVector=filteredVector;
    }
    vectorWritable.set(userVector);
    output.collect(userID,vectorWritable);
  }
}",0.9629317607413648
61314,"@Override public void configure(JobConf jobConf){
  String dataModelFile=jobConf.get(RecommenderReducer.DATA_MODEL_FILE);
  String recommenderClassName=jobConf.get(RecommenderReducer.RECOMMENDER_CLASS_NAME);
  FileDataModel fileDataModel;
  try {
    Path dataModelPath=new Path(dataModelFile);
    FileSystem fs=FileSystem.get(dataModelPath.toUri(),jobConf);
    File tempDataFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempDataFile.deleteOnExit();
    fs.copyToLocalFile(dataModelPath,new Path(tempDataFile.getAbsolutePath()));
    fileDataModel=new FileDataModel(tempDataFile);
    String usersFilePathString=jobConf.get(RecommenderReducer.USERS_FILE);
    if (usersFilePathString == null) {
      usersToRecommendFor=null;
    }
 else {
      usersToRecommendFor=new FastIDSet();
      Path usersFilePath=new Path(usersFilePathString).makeQualified(fs);
      FSDataInputStream in=fs.open(usersFilePath);
      for (      String line : new FileLineIterable(in)) {
        usersToRecommendFor.add(Long.parseLong(line));
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
  try {
    Class<? extends Recommender> recommenderClass=Class.forName(recommenderClassName).asSubclass(Recommender.class);
    Constructor<? extends Recommender> constructor=recommenderClass.getConstructor(DataModel.class);
    recommender=constructor.newInstance(fileDataModel);
  }
 catch (  NoSuchMethodException nsme) {
    throw new IllegalStateException(nsme);
  }
catch (  ClassNotFoundException cnfe) {
    throw new IllegalStateException(cnfe);
  }
catch (  InstantiationException ie) {
    throw new IllegalStateException(ie);
  }
catch (  IllegalAccessException iae) {
    throw new IllegalStateException(iae);
  }
catch (  InvocationTargetException ite) {
    throw new IllegalStateException(ite.getCause());
  }
  recommendationsPerUser=jobConf.getInt(RecommenderReducer.RECOMMENDATIONS_PER_USER,10);
}","@Override public void configure(JobConf jobConf){
  String dataModelFile=jobConf.get(DATA_MODEL_FILE);
  String recommenderClassName=jobConf.get(RECOMMENDER_CLASS_NAME);
  FileDataModel fileDataModel;
  try {
    Path dataModelPath=new Path(dataModelFile);
    FileSystem fs=FileSystem.get(dataModelPath.toUri(),jobConf);
    File tempDataFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempDataFile.deleteOnExit();
    fs.copyToLocalFile(dataModelPath,new Path(tempDataFile.getAbsolutePath()));
    fileDataModel=new FileDataModel(tempDataFile);
    String usersFilePathString=jobConf.get(USERS_FILE);
    if (usersFilePathString == null) {
      usersToRecommendFor=null;
    }
 else {
      usersToRecommendFor=new FastIDSet();
      Path usersFilePath=new Path(usersFilePathString).makeQualified(fs);
      FSDataInputStream in=fs.open(usersFilePath);
      for (      String line : new FileLineIterable(in)) {
        usersToRecommendFor.add(Long.parseLong(line));
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
  try {
    Class<? extends Recommender> recommenderClass=Class.forName(recommenderClassName).asSubclass(Recommender.class);
    Constructor<? extends Recommender> constructor=recommenderClass.getConstructor(DataModel.class);
    recommender=constructor.newInstance(fileDataModel);
  }
 catch (  NoSuchMethodException nsme) {
    throw new IllegalStateException(nsme);
  }
catch (  ClassNotFoundException cnfe) {
    throw new IllegalStateException(cnfe);
  }
catch (  InstantiationException ie) {
    throw new IllegalStateException(ie);
  }
catch (  IllegalAccessException iae) {
    throw new IllegalStateException(iae);
  }
catch (  InvocationTargetException ite) {
    throw new IllegalStateException(ite.getCause());
  }
  recommendationsPerUser=jobConf.getInt(RECOMMENDATIONS_PER_USER,10);
}",0.9801876955161628
61315,"private void rehash(int newHashSize){
  long[] oldKeys=keys;
  V[] oldValues=values;
  numEntries=0;
  numSlotsUsed=0;
  if (countingAccesses) {
    recentlyAccessed=new BitSet(newHashSize);
  }
  keys=new long[newHashSize];
  Arrays.fill(keys,FastByIDMap.NULL);
  values=(V[])new Object[newHashSize];
  int length=oldKeys.length;
  for (int i=0; i < length; i++) {
    long key=oldKeys[i];
    if ((key != FastByIDMap.NULL) && (key != FastByIDMap.REMOVED)) {
      put(key,oldValues[i]);
    }
  }
}","private void rehash(int newHashSize){
  long[] oldKeys=keys;
  V[] oldValues=values;
  numEntries=0;
  numSlotsUsed=0;
  if (countingAccesses) {
    recentlyAccessed=new BitSet(newHashSize);
  }
  keys=new long[newHashSize];
  Arrays.fill(keys,NULL);
  values=(V[])new Object[newHashSize];
  int length=oldKeys.length;
  for (int i=0; i < length; i++) {
    long key=oldKeys[i];
    if ((key != NULL) && (key != REMOVED)) {
      put(key,oldValues[i]);
    }
  }
}",0.9626556016597512
61316,"public V put(long key,V value){
  if ((key == FastByIDMap.NULL) || (key == FastByIDMap.REMOVED)) {
    throw new IllegalArgumentException();
  }
  if (value == null) {
    throw new NullPointerException();
  }
  if (numSlotsUsed * FastByIDMap.ALLOWED_LOAD_FACTOR >= keys.length) {
    if (numEntries * FastByIDMap.ALLOWED_LOAD_FACTOR >= numSlotsUsed) {
      growAndRehash();
    }
 else {
      rehash();
    }
  }
  int index=findForAdd(key);
  long keyIndex=keys[index];
  if (keyIndex == key) {
    V oldValue=values[index];
    values[index]=value;
    return oldValue;
  }
 else {
    if (countingAccesses && (numEntries >= maxSize)) {
      clearStaleEntry(index);
    }
    keys[index]=key;
    values[index]=value;
    numEntries++;
    if (keyIndex == FastByIDMap.NULL) {
      numSlotsUsed++;
    }
    return null;
  }
}","public V put(long key,V value){
  if ((key == NULL) || (key == REMOVED)) {
    throw new IllegalArgumentException();
  }
  if (value == null) {
    throw new NullPointerException();
  }
  if (numSlotsUsed * ALLOWED_LOAD_FACTOR >= keys.length) {
    if (numEntries * ALLOWED_LOAD_FACTOR >= numSlotsUsed) {
      growAndRehash();
    }
 else {
      rehash();
    }
  }
  int index=findForAdd(key);
  long keyIndex=keys[index];
  if (keyIndex == key) {
    V oldValue=values[index];
    values[index]=value;
    return oldValue;
  }
 else {
    if (countingAccesses && (numEntries >= maxSize)) {
      clearStaleEntry(index);
    }
    keys[index]=key;
    values[index]=value;
    numEntries++;
    if (keyIndex == NULL) {
      numSlotsUsed++;
    }
    return null;
  }
}",0.9625935162094764
61317,"/** 
 * @see #findForAdd(long)
 */
private int find(long key){
  int theHashCode=(int)key & 0x7FFFFFFF;
  long[] keys=this.keys;
  int hashSize=keys.length;
  int jump=1 + theHashCode % (hashSize - 2);
  int index=theHashCode % hashSize;
  long currentKey=keys[index];
  while ((currentKey != FastByIDMap.NULL) && (key != currentKey)) {
    if (index < jump) {
      index+=hashSize - jump;
    }
 else {
      index-=jump;
    }
    currentKey=keys[index];
  }
  return index;
}","/** 
 * @see #findForAdd(long)
 */
private int find(long key){
  int theHashCode=(int)key & 0x7FFFFFFF;
  long[] keys=this.keys;
  int hashSize=keys.length;
  int jump=1 + theHashCode % (hashSize - 2);
  int index=theHashCode % hashSize;
  long currentKey=keys[index];
  while ((currentKey != NULL) && (key != currentKey)) {
    if (index < jump) {
      index+=hashSize - jump;
    }
 else {
      index-=jump;
    }
    currentKey=keys[index];
  }
  return index;
}",0.9873150105708244
61318,"public V get(long key){
  if (key == FastByIDMap.NULL) {
    return null;
  }
  int index=find(key);
  if (countingAccesses) {
    recentlyAccessed.set(index);
  }
  return values[index];
}","public V get(long key){
  if (key == NULL) {
    return null;
  }
  int index=find(key);
  if (countingAccesses) {
    recentlyAccessed.set(index);
  }
  return values[index];
}",0.9672131147540984
61319,"void iteratorRemove(int lastNext){
  if (lastNext >= values.length) {
    throw new NoSuchElementException();
  }
  if (lastNext < 0) {
    throw new IllegalStateException();
  }
  values[lastNext]=null;
  keys[lastNext]=FastByIDMap.REMOVED;
  numEntries--;
}","void iteratorRemove(int lastNext){
  if (lastNext >= values.length) {
    throw new NoSuchElementException();
  }
  if (lastNext < 0) {
    throw new IllegalStateException();
  }
  values[lastNext]=null;
  keys[lastNext]=REMOVED;
  numEntries--;
}",0.9762845849802372
61320,"private void clearStaleEntry(int index){
  while (true) {
    long currentKey;
    do {
      if (index == 0) {
        index=keys.length - 1;
      }
 else {
        index--;
      }
      currentKey=keys[index];
    }
 while ((currentKey == FastByIDMap.NULL) || (currentKey == FastByIDMap.REMOVED));
    if (recentlyAccessed.get(index)) {
      recentlyAccessed.clear(index);
    }
 else {
      break;
    }
  }
  keys[index]=FastByIDMap.REMOVED;
  numEntries--;
  values[index]=null;
}","private void clearStaleEntry(int index){
  while (true) {
    long currentKey;
    do {
      if (index == 0) {
        index=keys.length - 1;
      }
 else {
        index--;
      }
      currentKey=keys[index];
    }
 while ((currentKey == NULL) || (currentKey == REMOVED));
    if (recentlyAccessed.get(index)) {
      recentlyAccessed.clear(index);
    }
 else {
      break;
    }
  }
  keys[index]=REMOVED;
  numEntries--;
  values[index]=null;
}",0.961783439490446
61321,"public boolean containsKey(long key){
  return (key != FastByIDMap.NULL) && (key != FastByIDMap.REMOVED) && (keys[find(key)] != FastByIDMap.NULL);
}","public boolean containsKey(long key){
  return (key != NULL) && (key != REMOVED) && (keys[find(key)] != NULL);
}",0.8615384615384616
61322,"@Override public boolean isEmpty(){
  return FastByIDMap.this.isEmpty();
}","@Override public boolean isEmpty(){
  return this.isEmpty();
}",0.9117647058823528
61323,"@Override public void clear(){
  FastByIDMap.this.clear();
}","@Override public void clear(){
  this.clear();
}",0.8888888888888888
61324,"/** 
 * Creates a new   {@link FastByIDMap} whose capacity can accommodate the given number of entries withoutrehash.</p>
 * @param size desired capacity
 * @param maxSize max capacity
 * @throws IllegalArgumentException if size is less than 0, maxSize is less than 1, or at least half of {@link RandomUtils#MAX_INT_SMALLER_TWIN_PRIME}
 */
public FastByIDMap(int size,int maxSize){
  if (size < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int max=(int)(RandomUtils.MAX_INT_SMALLER_TWIN_PRIME / FastByIDMap.ALLOWED_LOAD_FACTOR);
  if (size >= max) {
    throw new IllegalArgumentException(""String_Node_Str"" + max);
  }
  if (maxSize < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int hashSize=RandomUtils.nextTwinPrime((int)(FastByIDMap.ALLOWED_LOAD_FACTOR * size));
  keys=new long[hashSize];
  Arrays.fill(keys,FastByIDMap.NULL);
  values=(V[])new Object[hashSize];
  this.maxSize=maxSize;
  this.countingAccesses=maxSize != Integer.MAX_VALUE;
  this.recentlyAccessed=countingAccesses ? new BitSet(hashSize) : null;
}","/** 
 * Creates a new   {@link FastByIDMap} whose capacity can accommodate the given number of entries withoutrehash.</p>
 * @param size desired capacity
 * @param maxSize max capacity
 * @throws IllegalArgumentException if size is less than 0, maxSize is less than 1, or at least half of {@link RandomUtils#MAX_INT_SMALLER_TWIN_PRIME}
 */
public FastByIDMap(int size,int maxSize){
  if (size < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int max=(int)(RandomUtils.MAX_INT_SMALLER_TWIN_PRIME / ALLOWED_LOAD_FACTOR);
  if (size >= max) {
    throw new IllegalArgumentException(""String_Node_Str"" + max);
  }
  if (maxSize < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int hashSize=RandomUtils.nextTwinPrime((int)(ALLOWED_LOAD_FACTOR * size));
  keys=new long[hashSize];
  Arrays.fill(keys,NULL);
  values=(V[])new Object[hashSize];
  this.maxSize=maxSize;
  this.countingAccesses=maxSize != Integer.MAX_VALUE;
  this.recentlyAccessed=countingAccesses ? new BitSet(hashSize) : null;
}",0.9828734538534728
61325,"@Override public int size(){
  return FastByIDMap.this.size();
}","@Override public int size(){
  return this.size();
}",0.896551724137931
61326,"/** 
 * @see #find(long)
 */
private int findForAdd(long key){
  int theHashCode=(int)key & 0x7FFFFFFF;
  long[] keys=this.keys;
  int hashSize=keys.length;
  int jump=1 + theHashCode % (hashSize - 2);
  int index=theHashCode % hashSize;
  long currentKey=keys[index];
  while ((currentKey != FastByIDMap.NULL) && (currentKey != FastByIDMap.REMOVED) && (key != currentKey)) {
    if (index < jump) {
      index+=hashSize - jump;
    }
 else {
      index-=jump;
    }
    currentKey=keys[index];
  }
  return index;
}","/** 
 * @see #find(long)
 */
private int findForAdd(long key){
  int theHashCode=(int)key & 0x7FFFFFFF;
  long[] keys=this.keys;
  int hashSize=keys.length;
  int jump=1 + theHashCode % (hashSize - 2);
  int index=theHashCode % hashSize;
  long currentKey=keys[index];
  while ((currentKey != NULL) && (currentKey != REMOVED) && (key != currentKey)) {
    if (index < jump) {
      index+=hashSize - jump;
    }
 else {
      index-=jump;
    }
    currentKey=keys[index];
  }
  return index;
}",0.9762845849802372
61327,"@Override public String toString(){
  if (isEmpty()) {
    return ""String_Node_Str"";
  }
  StringBuilder result=new StringBuilder();
  result.append('{');
  for (int i=0; i < keys.length; i++) {
    long key=keys[i];
    if ((key != FastByIDMap.NULL) && (key != FastByIDMap.REMOVED)) {
      result.append(key).append('=').append(values[i]).append(',');
    }
  }
  result.setCharAt(result.length() - 1,'}');
  return result.toString();
}","@Override public String toString(){
  if (isEmpty()) {
    return ""String_Node_Str"";
  }
  StringBuilder result=new StringBuilder();
  result.append('{');
  for (int i=0; i < keys.length; i++) {
    long key=keys[i];
    if ((key != NULL) && (key != REMOVED)) {
      result.append(key).append('=').append(values[i]).append(',');
    }
  }
  result.setCharAt(result.length() - 1,'}');
  return result.toString();
}",0.971830985915493
61328,"private void growAndRehash(){
  if (keys.length * FastByIDMap.ALLOWED_LOAD_FACTOR >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  rehash(RandomUtils.nextTwinPrime((int)(FastByIDMap.ALLOWED_LOAD_FACTOR * keys.length)));
}","private void growAndRehash(){
  if (keys.length * ALLOWED_LOAD_FACTOR >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  rehash(RandomUtils.nextTwinPrime((int)(ALLOWED_LOAD_FACTOR * keys.length)));
}",0.8689138576779026
61329,"/** 
 * Adds the specified   {@link Refreshable} to the given collection of {@link Refreshable}s if it is not already there and immediately refreshes it.
 * @param alreadyRefreshed the collection of  {@link Refreshable}s
 * @param refreshable the  {@link Refreshable} to potentially add and refresh
 */
public static void maybeRefresh(Collection<Refreshable> alreadyRefreshed,Refreshable refreshable){
  if (!alreadyRefreshed.contains(refreshable)) {
    alreadyRefreshed.add(refreshable);
    RefreshHelper.log.info(""String_Node_Str"",refreshable);
    refreshable.refresh(alreadyRefreshed);
    RefreshHelper.log.info(""String_Node_Str"",alreadyRefreshed);
  }
}","/** 
 * Adds the specified   {@link Refreshable} to the given collection of {@link Refreshable}s if it is not already there and immediately refreshes it.
 * @param alreadyRefreshed the collection of  {@link Refreshable}s
 * @param refreshable the  {@link Refreshable} to potentially add and refresh
 */
public static void maybeRefresh(Collection<Refreshable> alreadyRefreshed,Refreshable refreshable){
  if (!alreadyRefreshed.contains(refreshable)) {
    alreadyRefreshed.add(refreshable);
    log.info(""String_Node_Str"",refreshable);
    refreshable.refresh(alreadyRefreshed);
    log.info(""String_Node_Str"",alreadyRefreshed);
  }
}",0.9783616692426584
61330,"/** 
 * Typically this is called in   {@link Refreshable#refresh(java.util.Collection)} and is the entire body ofthat method.
 */
@Override public void refresh(Collection<Refreshable> alreadyRefreshed){
  if (!refreshLock.isLocked()) {
    refreshLock.lock();
    try {
      alreadyRefreshed=RefreshHelper.buildRefreshed(alreadyRefreshed);
      for (      Refreshable dependency : dependencies) {
        RefreshHelper.maybeRefresh(alreadyRefreshed,dependency);
      }
      if (refreshRunnable != null) {
        try {
          refreshRunnable.call();
        }
 catch (        Exception e) {
          RefreshHelper.log.warn(""String_Node_Str"",e);
        }
      }
    }
  finally {
      refreshLock.unlock();
    }
  }
}","/** 
 * Typically this is called in   {@link Refreshable#refresh(java.util.Collection)} and is the entire body ofthat method.
 */
@Override public void refresh(Collection<Refreshable> alreadyRefreshed){
  if (!refreshLock.isLocked()) {
    refreshLock.lock();
    try {
      alreadyRefreshed=RefreshHelper.buildRefreshed(alreadyRefreshed);
      for (      Refreshable dependency : dependencies) {
        RefreshHelper.maybeRefresh(alreadyRefreshed,dependency);
      }
      if (refreshRunnable != null) {
        try {
          refreshRunnable.call();
        }
 catch (        Exception e) {
          log.warn(""String_Node_Str"",e);
        }
      }
    }
  finally {
      refreshLock.unlock();
    }
  }
}",0.9902912621359224
61331,"protected static void checkNotNullAndLog(String argName,Object[] values){
  if ((values == null) || (values.length == 0)) {
    throw new IllegalArgumentException(argName + ""String_Node_Str"");
  }
  for (  Object value : values) {
    AbstractJDBCComponent.checkNotNullAndLog(argName,value);
  }
}","protected static void checkNotNullAndLog(String argName,Object[] values){
  if ((values == null) || (values.length == 0)) {
    throw new IllegalArgumentException(argName + ""String_Node_Str"");
  }
  for (  Object value : values) {
    checkNotNullAndLog(argName,value);
  }
}",0.9195804195804196
61332,"/** 
 * <p> Looks up a   {@link DataSource} by name from JNDI. ""java:comp/env/"" is prepended to the argument beforelooking up the name in JNDI. </p>
 * @param dataSourceName JNDI name where a  {@link DataSource} is bound (e.g. ""jdbc/taste"")
 * @return {@link DataSource} under that JNDI name
 * @throws TasteException if a JNDI error occurs
 */
protected static DataSource lookupDataSource(String dataSourceName) throws TasteException {
  Context context=null;
  try {
    context=new InitialContext();
    return (DataSource)context.lookup(""String_Node_Str"" + dataSourceName);
  }
 catch (  NamingException ne) {
    throw new TasteException(ne);
  }
 finally {
    if (context != null) {
      try {
        context.close();
      }
 catch (      NamingException ne) {
        AbstractJDBCComponent.log.warn(""String_Node_Str"",ne);
      }
    }
  }
}","/** 
 * <p> Looks up a   {@link DataSource} by name from JNDI. ""java:comp/env/"" is prepended to the argument beforelooking up the name in JNDI. </p>
 * @param dataSourceName JNDI name where a  {@link DataSource} is bound (e.g. ""jdbc/taste"")
 * @return {@link DataSource} under that JNDI name
 * @throws TasteException if a JNDI error occurs
 */
protected static DataSource lookupDataSource(String dataSourceName) throws TasteException {
  Context context=null;
  try {
    context=new InitialContext();
    return (DataSource)context.lookup(""String_Node_Str"" + dataSourceName);
  }
 catch (  NamingException ne) {
    throw new TasteException(ne);
  }
 finally {
    if (context != null) {
      try {
        context.close();
      }
 catch (      NamingException ne) {
        log.warn(""String_Node_Str"",ne);
      }
    }
  }
}",0.9869203329369798
61333,"protected int getFetchSize(){
  return AbstractJDBCComponent.DEFAULT_FETCH_SIZE;
}","protected int getFetchSize(){
  return DEFAULT_FETCH_SIZE;
}",0.8450704225352113
61334,"public static void main(String[] args){
  RandomUtils.useTestSeed();
  generateSamples();
  new DisplayDirichlet();
}","public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException {
  RandomUtils.useTestSeed();
  generateSamples();
  new DisplayDirichlet();
}",0.7697368421052632
61335,"@Override public int run(String[] args) throws IOException {
  Option numReccomendationsOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option usersFileOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  Map<String,String> parsedArgs=parseArguments(args,numReccomendationsOpt,usersFileOpt);
  String inputPath=parsedArgs.get(""String_Node_Str"");
  String tempDirPath=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  int recommendationsPerUser=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  String usersFile=parsedArgs.get(""String_Node_Str"");
  String userVectorPath=tempDirPath + ""String_Node_Str"";
  String itemIDIndexPath=tempDirPath + ""String_Node_Str"";
  String cooccurrencePath=tempDirPath + ""String_Node_Str"";
  JobConf itemIDIndexConf=prepareJobConf(inputPath,itemIDIndexPath,jarFile,TextInputFormat.class,ItemIDIndexMapper.class,IntWritable.class,LongWritable.class,ItemIDIndexReducer.class,IntWritable.class,LongWritable.class,MapFileOutputFormat.class);
  JobClient.runJob(itemIDIndexConf);
  JobConf toUserVectorConf=prepareJobConf(inputPath,userVectorPath,jarFile,TextInputFormat.class,ToItemPrefsMapper.class,LongWritable.class,ItemPrefWritable.class,ToUserVectorReducer.class,LongWritable.class,VectorWritable.class,SequenceFileOutputFormat.class);
  JobClient.runJob(toUserVectorConf);
  JobConf toCooccurrenceConf=prepareJobConf(userVectorPath,cooccurrencePath,jarFile,SequenceFileInputFormat.class,UserVectorToCooccurrenceMapper.class,IntWritable.class,IntWritable.class,UserVectorToCooccurrenceReducer.class,IntWritable.class,VectorWritable.class,MapFileOutputFormat.class);
  JobClient.runJob(toCooccurrenceConf);
  JobConf recommenderConf=prepareJobConf(userVectorPath,outputPath,jarFile,SequenceFileInputFormat.class,RecommenderMapper.class,LongWritable.class,RecommendedItemsWritable.class,IdentityReducer.class,LongWritable.class,RecommendedItemsWritable.class,TextOutputFormat.class);
  recommenderConf.set(RecommenderMapper.COOCCURRENCE_PATH,cooccurrencePath);
  recommenderConf.set(RecommenderMapper.ITEMID_INDEX_PATH,itemIDIndexPath);
  recommenderConf.setInt(RecommenderMapper.RECOMMENDATIONS_PER_USER,recommendationsPerUser);
  recommenderConf.set(RecommenderMapper.USERS_FILE,usersFile);
  recommenderConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(recommenderConf);
  return 0;
}","@Override public int run(String[] args) throws IOException {
  Option numReccomendationsOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option usersFileOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  Map<String,String> parsedArgs=parseArguments(args,numReccomendationsOpt,usersFileOpt);
  if (parsedArgs == null) {
    return -1;
  }
  String inputPath=parsedArgs.get(""String_Node_Str"");
  String tempDirPath=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  int recommendationsPerUser=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  String usersFile=parsedArgs.get(""String_Node_Str"");
  String userVectorPath=tempDirPath + ""String_Node_Str"";
  String itemIDIndexPath=tempDirPath + ""String_Node_Str"";
  String cooccurrencePath=tempDirPath + ""String_Node_Str"";
  JobConf itemIDIndexConf=prepareJobConf(inputPath,itemIDIndexPath,jarFile,TextInputFormat.class,ItemIDIndexMapper.class,IntWritable.class,LongWritable.class,ItemIDIndexReducer.class,IntWritable.class,LongWritable.class,MapFileOutputFormat.class);
  JobClient.runJob(itemIDIndexConf);
  JobConf toUserVectorConf=prepareJobConf(inputPath,userVectorPath,jarFile,TextInputFormat.class,ToItemPrefsMapper.class,LongWritable.class,ItemPrefWritable.class,ToUserVectorReducer.class,LongWritable.class,VectorWritable.class,SequenceFileOutputFormat.class);
  JobClient.runJob(toUserVectorConf);
  JobConf toCooccurrenceConf=prepareJobConf(userVectorPath,cooccurrencePath,jarFile,SequenceFileInputFormat.class,UserVectorToCooccurrenceMapper.class,IntWritable.class,IntWritable.class,UserVectorToCooccurrenceReducer.class,IntWritable.class,VectorWritable.class,MapFileOutputFormat.class);
  JobClient.runJob(toCooccurrenceConf);
  JobConf recommenderConf=prepareJobConf(userVectorPath,outputPath,jarFile,SequenceFileInputFormat.class,RecommenderMapper.class,LongWritable.class,RecommendedItemsWritable.class,IdentityReducer.class,LongWritable.class,RecommendedItemsWritable.class,TextOutputFormat.class);
  recommenderConf.set(RecommenderMapper.COOCCURRENCE_PATH,cooccurrencePath);
  recommenderConf.set(RecommenderMapper.ITEMID_INDEX_PATH,itemIDIndexPath);
  recommenderConf.setInt(RecommenderMapper.RECOMMENDATIONS_PER_USER,recommendationsPerUser);
  recommenderConf.set(RecommenderMapper.USERS_FILE,usersFile);
  recommenderConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(recommenderConf);
  return 0;
}",0.9907861203685552
61336,"@Override public int run(String[] args) throws IOException {
  Option recommendClassOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option numReccomendationsOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option usersFileOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  Map<String,String> parsedArgs=parseArguments(args,recommendClassOpt,numReccomendationsOpt,usersFileOpt);
  String inputFile=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  String usersFile=parsedArgs.get(""String_Node_Str"");
  if (usersFile == null) {
    usersFile=inputFile;
  }
  String recommendClassName=parsedArgs.get(""String_Node_Str"");
  int recommendationsPerUser=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  JobConf jobConf=prepareJobConf(usersFile,outputPath,jarFile,TextInputFormat.class,UserIDsMapper.class,LongWritable.class,NullWritable.class,RecommenderReducer.class,LongWritable.class,RecommendedItemsWritable.class,TextOutputFormat.class);
  jobConf.set(RecommenderReducer.RECOMMENDER_CLASS_NAME,recommendClassName);
  jobConf.setInt(RecommenderReducer.RECOMMENDATIONS_PER_USER,recommendationsPerUser);
  jobConf.set(RecommenderReducer.DATA_MODEL_FILE,inputFile);
  jobConf.set(RecommenderReducer.USERS_FILE,usersFile);
  jobConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(jobConf);
  return 0;
}","@Override public int run(String[] args) throws IOException {
  Option recommendClassOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option numReccomendationsOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Option usersFileOpt=buildOption(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  Map<String,String> parsedArgs=parseArguments(args,recommendClassOpt,numReccomendationsOpt,usersFileOpt);
  if (parsedArgs == null) {
    return -1;
  }
  String inputFile=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  String usersFile=parsedArgs.get(""String_Node_Str"");
  if (usersFile == null) {
    usersFile=inputFile;
  }
  String recommendClassName=parsedArgs.get(""String_Node_Str"");
  int recommendationsPerUser=Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  JobConf jobConf=prepareJobConf(usersFile,outputPath,jarFile,TextInputFormat.class,UserIDsMapper.class,LongWritable.class,NullWritable.class,RecommenderReducer.class,LongWritable.class,RecommendedItemsWritable.class,TextOutputFormat.class);
  jobConf.set(RecommenderReducer.RECOMMENDER_CLASS_NAME,recommendClassName);
  jobConf.setInt(RecommenderReducer.RECOMMENDATIONS_PER_USER,recommendationsPerUser);
  jobConf.set(RecommenderReducer.DATA_MODEL_FILE,inputFile);
  jobConf.set(RecommenderReducer.USERS_FILE,usersFile);
  jobConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(jobConf);
  return 0;
}",0.9849020237712818
61337,"@Override public int run(String[] args) throws IOException {
  Map<String,String> parsedArgs=parseArguments(args);
  String prefsFile=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  String averagesOutputPath=parsedArgs.get(""String_Node_Str"");
  JobConf prefsToDiffsJobConf=prepareJobConf(prefsFile,averagesOutputPath,jarFile,TextInputFormat.class,ToItemPrefsMapper.class,LongWritable.class,ItemPrefWritable.class,SlopeOnePrefsToDiffsReducer.class,ItemItemWritable.class,FloatWritable.class,SequenceFileOutputFormat.class);
  JobClient.runJob(prefsToDiffsJobConf);
  JobConf diffsToAveragesJobConf=prepareJobConf(averagesOutputPath,outputPath,jarFile,SequenceFileInputFormat.class,IdentityMapper.class,ItemItemWritable.class,FloatWritable.class,SlopeOneDiffsToAveragesReducer.class,ItemItemWritable.class,FloatWritable.class,TextOutputFormat.class);
  diffsToAveragesJobConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(diffsToAveragesJobConf);
  return 0;
}","@Override public int run(String[] args) throws IOException {
  Map<String,String> parsedArgs=parseArguments(args);
  if (parsedArgs == null) {
    return -1;
  }
  String prefsFile=parsedArgs.get(""String_Node_Str"");
  String outputPath=parsedArgs.get(""String_Node_Str"");
  String jarFile=parsedArgs.get(""String_Node_Str"");
  String averagesOutputPath=parsedArgs.get(""String_Node_Str"");
  JobConf prefsToDiffsJobConf=prepareJobConf(prefsFile,averagesOutputPath,jarFile,TextInputFormat.class,ToItemPrefsMapper.class,LongWritable.class,ItemPrefWritable.class,SlopeOnePrefsToDiffsReducer.class,ItemItemWritable.class,FloatWritable.class,SequenceFileOutputFormat.class);
  JobClient.runJob(prefsToDiffsJobConf);
  JobConf diffsToAveragesJobConf=prepareJobConf(averagesOutputPath,outputPath,jarFile,SequenceFileInputFormat.class,IdentityMapper.class,ItemItemWritable.class,FloatWritable.class,SlopeOneDiffsToAveragesReducer.class,ItemItemWritable.class,FloatWritable.class,TextOutputFormat.class);
  diffsToAveragesJobConf.setClass(""String_Node_Str"",GzipCodec.class,CompressionCodec.class);
  JobClient.runJob(diffsToAveragesJobConf);
  return 0;
}",0.9789897183728208
61338,"private static void getSamples() throws IOException {
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles())   sampleData.addAll(readFile(g.getCanonicalPath()));
}","private static void getSamples() throws IOException {
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles()) {
    sampleData.addAll(readFile(g.getCanonicalPath()));
  }
}",0.9781420765027322
61339,"private static void getResults() throws IOException {
  result=new ArrayList<Model<VectorWritable>[]>();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.set(DirichletDriver.MODEL_FACTORY_KEY,""String_Node_Str"");
  conf.set(DirichletDriver.NUM_CLUSTERS_KEY,Integer.toString(20));
  conf.set(DirichletDriver.ALPHA_0_KEY,Double.toString(1.0));
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles()) {
    conf.set(DirichletDriver.STATE_IN_KEY,g.getCanonicalPath());
    DirichletState<VectorWritable> dirichletState=DirichletMapper.getDirichletState(conf);
    result.add(dirichletState.getModels());
  }
}","private static void getResults() throws IOException, InvocationTargetException, NoSuchMethodException {
  result=new ArrayList<Model<VectorWritable>[]>();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.set(DirichletDriver.MODEL_FACTORY_KEY,""String_Node_Str"");
  conf.set(DirichletDriver.NUM_CLUSTERS_KEY,Integer.toString(20));
  conf.set(DirichletDriver.ALPHA_0_KEY,Double.toString(1.0));
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles()) {
    conf.set(DirichletDriver.STATE_IN_KEY,g.getCanonicalPath());
    DirichletState<VectorWritable> dirichletState=DirichletMapper.getDirichletState(conf);
    result.add(dirichletState.getModels());
  }
}",0.9615384615384616
61340,"@Override public void paint(Graphics g){
  super.plotSampleData(g);
  Graphics2D g2=(Graphics2D)g;
  Vector dv=new DenseVector(2);
  int i=result.size() - 1;
  for (  Model<VectorWritable>[] models : result) {
    g2.setStroke(new BasicStroke(i == 0 ? 3 : 1));
    g2.setColor(colors[Math.min(colors.length - 1,i--)]);
    for (    Model<VectorWritable> m : models) {
      AsymmetricSampledNormalModel mm=(AsymmetricSampledNormalModel)m;
      dv.set(0,mm.getStdDev().get(0) * 3);
      dv.set(1,mm.getStdDev().get(1) * 3);
      if (isSignificant(mm))       plotEllipse(g2,mm.getMean(),dv);
    }
  }
}","@Override public void paint(Graphics g){
  super.plotSampleData(g);
  Graphics2D g2=(Graphics2D)g;
  Vector dv=new DenseVector(2);
  int i=result.size() - 1;
  for (  Model<VectorWritable>[] models : result) {
    g2.setStroke(new BasicStroke(i == 0 ? 3 : 1));
    g2.setColor(colors[Math.min(colors.length - 1,i--)]);
    for (    Model<VectorWritable> m : models) {
      AsymmetricSampledNormalModel mm=(AsymmetricSampledNormalModel)m;
      dv.set(0,mm.getStdDev().get(0) * 3);
      dv.set(1,mm.getStdDev().get(1) * 3);
      if (isSignificant(mm)) {
        plotEllipse(g2,mm.getMean(),dv);
      }
    }
  }
}",0.9901639344262296
61341,"public static void main(String[] args) throws IOException {
  RandomUtils.useTestSeed();
  getSamples();
  getResults();
  new DisplayASNOutputState();
}","public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException {
  RandomUtils.useTestSeed();
  getSamples();
  getResults();
  new DisplayASNOutputState();
}",0.8595505617977528
61342,"/** 
 * Creates a DirichletState object from the given arguments. Note that the modelFactory is presumed to be a subclass of VectorModelDistribution that can be initialized with a concrete Vector prototype.
 * @param modelFactory a String which is the class name of the model factory
 * @param modelPrototype a String which is the class name of the Vector used to initialize the factory
 * @param prototypeSie an int number of dimensions of the model prototype vector
 * @param numModels an int number of models to be created
 * @param alpha_0 the double alpha_0 argument to the algorithm
 * @return an initialized DirichletState
 * @throws ClassNotFoundException
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws InvocationTargetException 
 * @throws IllegalArgumentException 
 */
public static DirichletState<VectorWritable> createState(String modelFactory,String modelPrototype,int prototypeSize,int numModels,double alpha_0) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
  ClassLoader ccl=Thread.currentThread().getContextClassLoader();
  Class<? extends VectorModelDistribution> cl=ccl.loadClass(modelFactory).asSubclass(VectorModelDistribution.class);
  VectorModelDistribution factory=(VectorModelDistribution)cl.newInstance();
  Class<? extends Vector> vcl=ccl.loadClass(modelPrototype).asSubclass(Vector.class);
  Constructor<? extends Vector> v=vcl.getConstructor(int.class);
  factory.setModelPrototype(new VectorWritable(v.newInstance(prototypeSize)));
  return new DirichletState<VectorWritable>(factory,numModels,alpha_0,1,1);
}","/** 
 * Creates a DirichletState object from the given arguments. Note that the modelFactory is presumed to be a subclass of VectorModelDistribution that can be initialized with a concrete Vector prototype.
 * @param modelFactory a String which is the class name of the model factory
 * @param modelPrototype a String which is the class name of the Vector used to initialize the factory
 * @param prototypeSize an int number of dimensions of the model prototype vector
 * @param numModels an int number of models to be created
 * @param alpha_0 the double alpha_0 argument to the algorithm
 * @return an initialized DirichletState
 * @throws ClassNotFoundException
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws InvocationTargetException 
 * @throws IllegalArgumentException 
 */
public static DirichletState<VectorWritable> createState(String modelFactory,String modelPrototype,int prototypeSize,int numModels,double alpha_0) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
  ClassLoader ccl=Thread.currentThread().getContextClassLoader();
  Class<? extends VectorModelDistribution> cl=ccl.loadClass(modelFactory).asSubclass(VectorModelDistribution.class);
  VectorModelDistribution factory=cl.newInstance();
  Class<? extends Vector> vcl=ccl.loadClass(modelPrototype).asSubclass(Vector.class);
  Constructor<? extends Vector> v=vcl.getConstructor(int.class);
  factory.setModelPrototype(new VectorWritable(v.newInstance(prototypeSize)));
  return new DirichletState<VectorWritable>(factory,numModels,alpha_0,1,1);
}",0.992579908675799
61343,"public static DirichletState<VectorWritable> getDirichletState(JobConf job) throws NumberFormatException, SecurityException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException {
  String statePath=job.get(DirichletDriver.STATE_IN_KEY);
  String modelFactory=job.get(DirichletDriver.MODEL_FACTORY_KEY);
  String modelPrototype=job.get(DirichletDriver.MODEL_PROTOTYPE_KEY);
  String prototypeSize=job.get(DirichletDriver.PROTOTYPE_SIZE_KEY);
  String numClusters=job.get(DirichletDriver.NUM_CLUSTERS_KEY);
  String alpha_0=job.get(DirichletDriver.ALPHA_0_KEY);
  try {
    DirichletState<VectorWritable> state=DirichletDriver.createState(modelFactory,modelPrototype,Integer.parseInt(prototypeSize),Integer.parseInt(numClusters),Double.parseDouble(alpha_0));
    Path path=new Path(statePath);
    FileSystem fs=FileSystem.get(path.toUri(),job);
    FileStatus[] status=fs.listStatus(path,new OutputLogFilter());
    for (    FileStatus s : status) {
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,s.getPath(),job);
      try {
        Text key=new Text();
        DirichletCluster<VectorWritable> cluster=new DirichletCluster<VectorWritable>();
        while (reader.next(key,cluster)) {
          int index=Integer.parseInt(key.toString());
          state.getClusters().set(index,cluster);
          cluster=new DirichletCluster<VectorWritable>();
        }
      }
  finally {
        reader.close();
      }
    }
    state.setMixture(UncommonDistributions.rDirichlet(state.totalCounts()));
    return state;
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalStateException(e);
  }
catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}","public static DirichletState<VectorWritable> getDirichletState(JobConf job) throws SecurityException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException {
  String statePath=job.get(DirichletDriver.STATE_IN_KEY);
  String modelFactory=job.get(DirichletDriver.MODEL_FACTORY_KEY);
  String modelPrototype=job.get(DirichletDriver.MODEL_PROTOTYPE_KEY);
  String prototypeSize=job.get(DirichletDriver.PROTOTYPE_SIZE_KEY);
  String numClusters=job.get(DirichletDriver.NUM_CLUSTERS_KEY);
  String alpha_0=job.get(DirichletDriver.ALPHA_0_KEY);
  try {
    DirichletState<VectorWritable> state=DirichletDriver.createState(modelFactory,modelPrototype,Integer.parseInt(prototypeSize),Integer.parseInt(numClusters),Double.parseDouble(alpha_0));
    Path path=new Path(statePath);
    FileSystem fs=FileSystem.get(path.toUri(),job);
    FileStatus[] status=fs.listStatus(path,new OutputLogFilter());
    for (    FileStatus s : status) {
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,s.getPath(),job);
      try {
        Text key=new Text();
        DirichletCluster<VectorWritable> cluster=new DirichletCluster<VectorWritable>();
        while (reader.next(key,cluster)) {
          int index=Integer.parseInt(key.toString());
          state.getClusters().set(index,cluster);
          cluster=new DirichletCluster<VectorWritable>();
        }
      }
  finally {
        reader.close();
      }
    }
    state.setMixture(UncommonDistributions.rDirichlet(state.totalCounts()));
    return state;
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalStateException(e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalStateException(e);
  }
catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}",0.9938022096469954
61344,"public static void main(String[] args) throws IOException {
  RandomUtils.useTestSeed();
  generateSamples();
  new DisplayDirichlet();
}","public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException {
  RandomUtils.useTestSeed();
  generateSamples();
  new DisplayDirichlet();
}",0.845679012345679
61345,"private static void getResults() throws IOException {
  result=new ArrayList<Model<VectorWritable>[]>();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.set(DirichletDriver.MODEL_FACTORY_KEY,""String_Node_Str"");
  conf.set(DirichletDriver.NUM_CLUSTERS_KEY,Integer.toString(20));
  conf.set(DirichletDriver.ALPHA_0_KEY,Double.toString(1.0));
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles()) {
    conf.set(DirichletDriver.STATE_IN_KEY,g.getCanonicalPath());
    DirichletState<VectorWritable> dirichletState=DirichletMapper.getDirichletState(conf);
    result.add(dirichletState.getModels());
  }
}","private static void getResults() throws IOException, InvocationTargetException, NoSuchMethodException {
  result=new ArrayList<Model<VectorWritable>[]>();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.set(DirichletDriver.MODEL_FACTORY_KEY,""String_Node_Str"");
  conf.set(DirichletDriver.NUM_CLUSTERS_KEY,Integer.toString(20));
  conf.set(DirichletDriver.ALPHA_0_KEY,Double.toString(1.0));
  File f=new File(""String_Node_Str"");
  for (  File g : f.listFiles()) {
    conf.set(DirichletDriver.STATE_IN_KEY,g.getCanonicalPath());
    DirichletState<VectorWritable> dirichletState=DirichletMapper.getDirichletState(conf);
    result.add(dirichletState.getModels());
  }
}",0.9615384615384616
61346,"public static void main(String[] args) throws IOException {
  RandomUtils.useTestSeed();
  getSamples();
  getResults();
  new DisplayOutputState();
}","public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException {
  RandomUtils.useTestSeed();
  getSamples();
  getResults();
  new DisplayOutputState();
}",0.8571428571428571
61347,"@Override public long toLongID(String stringID) throws TasteException {
  return hash(stringID);
}","@Override public long toLongID(String stringID){
  return hash(stringID);
}",0.8670520231213873
61348,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null || !(obj instanceof CDFitness))   return false;
  CDFitness f=(CDFitness)obj;
  return tp == f.getFp() && fp == f.getFp() && tn == f.getTn() && fn == f.getTn();
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null || !(obj instanceof CDFitness))   return false;
  CDFitness f=(CDFitness)obj;
  return tp == f.getTp() && fp == f.getFp() && tn == f.getTn() && fn == f.getFn();
}",0.8223938223938224
61349,"@Override public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
  return delegate.getItemIDsFromUser(userID);
}","@Override public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
  checkLoaded();
  return delegate.getItemIDsFromUser(userID);
}",0.9386281588447654
61350,"private static void processOtherUser(long id,FastIDSet relevantItemIDs,FastByIDMap<PreferenceArray> trainingUsers,long userID2,DataModel dataModel) throws TasteException {
  PreferenceArray prefs2Array=dataModel.getPreferencesFromUser(userID2);
  if (id == userID2) {
    List<Preference> prefs2=new ArrayList<Preference>(prefs2Array.length());
    for (    Preference pref : prefs2Array) {
      prefs2.add(pref);
    }
    for (Iterator<Preference> iterator=prefs2.iterator(); iterator.hasNext(); ) {
      Preference pref=iterator.next();
      if (relevantItemIDs.contains(pref.getItemID())) {
        iterator.remove();
      }
    }
    prefs2Array=new GenericUserPreferenceArray(prefs2);
  }
  trainingUsers.put(userID2,prefs2Array);
}","private static void processOtherUser(long id,FastIDSet relevantItemIDs,FastByIDMap<PreferenceArray> trainingUsers,long userID2,DataModel dataModel) throws TasteException {
  PreferenceArray prefs2Array=dataModel.getPreferencesFromUser(userID2);
  if (id == userID2) {
    List<Preference> prefs2=new ArrayList<Preference>(prefs2Array.length());
    for (    Preference pref : prefs2Array) {
      prefs2.add(pref);
    }
    for (Iterator<Preference> iterator=prefs2.iterator(); iterator.hasNext(); ) {
      Preference pref=iterator.next();
      if (relevantItemIDs.contains(pref.getItemID())) {
        iterator.remove();
      }
    }
    if (!prefs2.isEmpty()) {
      trainingUsers.put(userID2,new GenericUserPreferenceArray(prefs2));
    }
  }
 else {
    trainingUsers.put(userID2,prefs2Array);
  }
}",0.8774193548387097
61351,"@Override public OrderedIntDoubleMapping clone(){
  return new OrderedIntDoubleMapping(indices,values,numMappings);
}","@Override public OrderedIntDoubleMapping clone(){
  return new OrderedIntDoubleMapping(indices.clone(),values.clone(),numMappings);
}",0.936
61352,"@Override public IRStatistics evaluate(RecommenderBuilder recommenderBuilder,DataModelBuilder dataModelBuilder,DataModel dataModel,Rescorer<Long> rescorer,int at,double relevanceThreshold,double evaluationPercentage) throws TasteException {
  if (recommenderBuilder == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dataModel == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (at < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Double.isNaN(evaluationPercentage) || evaluationPercentage <= 0.0 || evaluationPercentage > 1.0) {
    throw new IllegalArgumentException(""String_Node_Str"" + evaluationPercentage);
  }
  if (Double.isNaN(relevanceThreshold)) {
    throw new IllegalArgumentException(""String_Node_Str"" + evaluationPercentage);
  }
  int numItems=dataModel.getNumItems();
  RunningAverage precision=new FullRunningAverage();
  RunningAverage recall=new FullRunningAverage();
  RunningAverage fallOut=new FullRunningAverage();
  LongPrimitiveIterator it=dataModel.getUserIDs();
  while (it.hasNext()) {
    long userID=it.nextLong();
    if (random.nextDouble() < evaluationPercentage) {
      long start=System.currentTimeMillis();
      FastIDSet relevantItemIDs=new FastIDSet(at);
      PreferenceArray prefs=dataModel.getPreferencesFromUser(userID);
      int size=prefs.length();
      if (size < 2 * at) {
        continue;
      }
      double theRelevanceThreshold=Double.isNaN(relevanceThreshold) ? computeThreshold(prefs) : relevanceThreshold;
      prefs.sortByValueReversed();
      for (int i=0; i < size && relevantItemIDs.size() < at; i++) {
        if (prefs.getValue(i) >= theRelevanceThreshold) {
          relevantItemIDs.add(prefs.getItemID(i));
        }
      }
      int numRelevantItems=relevantItemIDs.size();
      if (numRelevantItems > 0) {
        FastByIDMap<PreferenceArray> trainingUsers=new FastByIDMap<PreferenceArray>(dataModel.getNumUsers());
        LongPrimitiveIterator it2=dataModel.getUserIDs();
        while (it2.hasNext()) {
          processOtherUser(userID,relevantItemIDs,trainingUsers,it2.nextLong(),dataModel);
        }
        DataModel trainingModel=dataModelBuilder == null ? new GenericDataModel(trainingUsers) : dataModelBuilder.buildDataModel(trainingUsers);
        Recommender recommender=recommenderBuilder.buildRecommender(trainingModel);
        try {
          trainingModel.getPreferencesFromUser(userID);
        }
 catch (        NoSuchUserException nsee) {
          continue;
        }
        int intersectionSize=0;
        List<RecommendedItem> recommendedItems=recommender.recommend(userID,at,rescorer);
        for (        RecommendedItem recommendedItem : recommendedItems) {
          if (relevantItemIDs.contains(recommendedItem.getItemID())) {
            intersectionSize++;
          }
        }
        int numRecommendedItems=recommendedItems.size();
        if (numRecommendedItems > 0) {
          precision.addDatum((double)intersectionSize / (double)numRecommendedItems);
        }
        recall.addDatum((double)intersectionSize / (double)numRelevantItems);
        if (numRelevantItems < size) {
          fallOut.addDatum((double)(numRecommendedItems - intersectionSize) / (double)(numItems - numRelevantItems));
        }
        long end=System.currentTimeMillis();
        log.info(""String_Node_Str"" + userID + ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
        log.info(""String_Node_Str"",new Object[]{precision.getAverage(),recall.getAverage(),fallOut.getAverage()});
      }
    }
  }
  return new IRStatisticsImpl(precision.getAverage(),recall.getAverage(),fallOut.getAverage());
}","@Override public IRStatistics evaluate(RecommenderBuilder recommenderBuilder,DataModelBuilder dataModelBuilder,DataModel dataModel,Rescorer<Long> rescorer,int at,double relevanceThreshold,double evaluationPercentage) throws TasteException {
  if (recommenderBuilder == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dataModel == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (at < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Double.isNaN(evaluationPercentage) || evaluationPercentage <= 0.0 || evaluationPercentage > 1.0) {
    throw new IllegalArgumentException(""String_Node_Str"" + evaluationPercentage);
  }
  int numItems=dataModel.getNumItems();
  RunningAverage precision=new FullRunningAverage();
  RunningAverage recall=new FullRunningAverage();
  RunningAverage fallOut=new FullRunningAverage();
  LongPrimitiveIterator it=dataModel.getUserIDs();
  while (it.hasNext()) {
    long userID=it.nextLong();
    if (random.nextDouble() < evaluationPercentage) {
      long start=System.currentTimeMillis();
      FastIDSet relevantItemIDs=new FastIDSet(at);
      PreferenceArray prefs=dataModel.getPreferencesFromUser(userID);
      int size=prefs.length();
      if (size < 2 * at) {
        continue;
      }
      double theRelevanceThreshold=Double.isNaN(relevanceThreshold) ? computeThreshold(prefs) : relevanceThreshold;
      prefs.sortByValueReversed();
      for (int i=0; i < size && relevantItemIDs.size() < at; i++) {
        if (prefs.getValue(i) >= theRelevanceThreshold) {
          relevantItemIDs.add(prefs.getItemID(i));
        }
      }
      int numRelevantItems=relevantItemIDs.size();
      if (numRelevantItems > 0) {
        FastByIDMap<PreferenceArray> trainingUsers=new FastByIDMap<PreferenceArray>(dataModel.getNumUsers());
        LongPrimitiveIterator it2=dataModel.getUserIDs();
        while (it2.hasNext()) {
          processOtherUser(userID,relevantItemIDs,trainingUsers,it2.nextLong(),dataModel);
        }
        DataModel trainingModel=dataModelBuilder == null ? new GenericDataModel(trainingUsers) : dataModelBuilder.buildDataModel(trainingUsers);
        Recommender recommender=recommenderBuilder.buildRecommender(trainingModel);
        try {
          trainingModel.getPreferencesFromUser(userID);
        }
 catch (        NoSuchUserException nsee) {
          continue;
        }
        int intersectionSize=0;
        List<RecommendedItem> recommendedItems=recommender.recommend(userID,at,rescorer);
        for (        RecommendedItem recommendedItem : recommendedItems) {
          if (relevantItemIDs.contains(recommendedItem.getItemID())) {
            intersectionSize++;
          }
        }
        int numRecommendedItems=recommendedItems.size();
        if (numRecommendedItems > 0) {
          precision.addDatum((double)intersectionSize / (double)numRecommendedItems);
        }
        recall.addDatum((double)intersectionSize / (double)numRelevantItems);
        if (numRelevantItems < size) {
          fallOut.addDatum((double)(numRecommendedItems - intersectionSize) / (double)(numItems - numRelevantItems));
        }
        long end=System.currentTimeMillis();
        log.info(""String_Node_Str"" + userID + ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
        log.info(""String_Node_Str"",new Object[]{precision.getAverage(),recall.getAverage(),fallOut.getAverage()});
      }
    }
  }
  return new IRStatisticsImpl(precision.getAverage(),recall.getAverage(),fallOut.getAverage());
}",0.982310668877833
61353,"@SuppressWarnings(""String_Node_Str"") public static DirichletState<Vector> getDirichletState(JobConf job){
  String statePath=job.get(DirichletDriver.STATE_IN_KEY);
  String modelFactory=job.get(DirichletDriver.MODEL_FACTORY_KEY);
  String numClusters=job.get(DirichletDriver.NUM_CLUSTERS_KEY);
  String alpha_0=job.get(DirichletDriver.ALPHA_0_KEY);
  try {
    DirichletState<Vector> state=DirichletDriver.createState(modelFactory,Integer.parseInt(numClusters),Double.parseDouble(alpha_0));
    Path path=new Path(statePath);
    FileSystem fs=FileSystem.get(path.toUri(),job);
    FileStatus[] status=fs.listStatus(path);
    for (    FileStatus s : status) {
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,s.getPath(),job);
      try {
        Text key=new Text();
        DirichletCluster<Vector> cluster=new DirichletCluster();
        while (reader.next(key,cluster)) {
          int index=Integer.parseInt(key.toString());
          state.clusters.set(index,cluster);
          cluster=new DirichletCluster();
        }
      }
  finally {
        reader.close();
      }
    }
    state.mixture=UncommonDistributions.rDirichlet(state.totalCounts());
    return state;
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static DirichletState<Vector> getDirichletState(JobConf job){
  String statePath=job.get(DirichletDriver.STATE_IN_KEY);
  String modelFactory=job.get(DirichletDriver.MODEL_FACTORY_KEY);
  String numClusters=job.get(DirichletDriver.NUM_CLUSTERS_KEY);
  String alpha_0=job.get(DirichletDriver.ALPHA_0_KEY);
  try {
    DirichletState<Vector> state=DirichletDriver.createState(modelFactory,Integer.parseInt(numClusters),Double.parseDouble(alpha_0));
    Path path=new Path(statePath);
    FileSystem fs=FileSystem.get(path.toUri(),job);
    FileStatus[] status=fs.listStatus(path,new OutputLogFilter());
    for (    FileStatus s : status) {
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,s.getPath(),job);
      try {
        Text key=new Text();
        DirichletCluster<Vector> cluster=new DirichletCluster();
        while (reader.next(key,cluster)) {
          int index=Integer.parseInt(key.toString());
          state.clusters.set(index,cluster);
          cluster=new DirichletCluster();
        }
      }
  finally {
        reader.close();
      }
    }
    state.mixture=UncommonDistributions.rDirichlet(state.totalCounts());
    return state;
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
}",0.9913589945011784
61354,"@Override public ItemItemSimilarity next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  long itemID2=itemIDs[j];
  double similarity;
  try {
    similarity=otherSimilarity.itemSimilarity(itemID1,itemID2);
  }
 catch (  TasteException te) {
    throw new RuntimeException(te);
  }
  ItemItemSimilarity result=new ItemItemSimilarity(itemID1,itemID2,similarity);
  j++;
  if (j == size) {
    i++;
    itemID1=itemIDs[i];
    j=i + 1;
  }
  return result;
}","@Override public ItemItemSimilarity next(){
  if (next == null) {
    throw new NoSuchElementException();
  }
  ItemItemSimilarity result=next;
  goToNext();
  return result;
}",0.4777947932618683
61355,"private DataModelSimilaritiesIterator(ItemSimilarity otherSimilarity,long[] itemIDs){
  this.otherSimilarity=otherSimilarity;
  this.itemIDs=itemIDs;
  this.size=itemIDs.length;
  i=0;
  itemID1=itemIDs[0];
  j=1;
}","private DataModelSimilaritiesIterator(ItemSimilarity otherSimilarity,long[] itemIDs){
  this.otherSimilarity=otherSimilarity;
  this.itemIDs=itemIDs;
  i=0;
  itemID1=itemIDs[0];
  j=1;
  goToNext();
}",0.8990384615384616
61356,"@Override public boolean hasNext(){
  return i < size - 1;
}","@Override public boolean hasNext(){
  return next != null;
}",0.8333333333333334
61357,"private DataModel buildModel() throws IOException {
  FileLineIterator iterator=new FileLineIterator(dataFile,false);
  String firstLine=iterator.peek();
  char delimiter=determineDelimiter(firstLine);
  boolean hasPrefValues=firstLine.indexOf(delimiter,firstLine.indexOf(delimiter) + 1) >= 0;
  if (hasPrefValues) {
    FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
    processFile(iterator,data,delimiter);
    for (    File updateFile : findUpdateFiles()) {
      processFile(new FileLineIterator(updateFile,false),data,delimiter);
    }
    return new GenericDataModel(GenericDataModel.toDataMap(data,true));
  }
 else {
    FastByIDMap<FastIDSet> data=new FastByIDMap<FastIDSet>();
    processFileWithoutID(iterator,data,delimiter);
    for (    File updateFile : findUpdateFiles()) {
      processFileWithoutID(new FileLineIterator(updateFile,false),data,delimiter);
    }
    return new GenericBooleanPrefDataModel(data);
  }
}","private DataModel buildModel() throws IOException {
  FileLineIterator iterator=new FileLineIterator(dataFile,false);
  String firstLine=iterator.peek();
  while (firstLine.length() == 0 || firstLine.charAt(0) == COMMENT_CHAR) {
    iterator.next();
    firstLine=iterator.peek();
  }
  char delimiter=determineDelimiter(firstLine);
  boolean hasPrefValues=firstLine.indexOf(delimiter,firstLine.indexOf(delimiter) + 1) >= 0;
  if (hasPrefValues) {
    FastByIDMap<Collection<Preference>> data=new FastByIDMap<Collection<Preference>>();
    processFile(iterator,data,delimiter);
    for (    File updateFile : findUpdateFiles()) {
      processFile(new FileLineIterator(updateFile,false),data,delimiter);
    }
    return new GenericDataModel(GenericDataModel.toDataMap(data,true));
  }
 else {
    FastByIDMap<FastIDSet> data=new FastByIDMap<FastIDSet>();
    processFileWithoutID(iterator,data,delimiter);
    for (    File updateFile : findUpdateFiles()) {
      processFileWithoutID(new FileLineIterator(updateFile,false),data,delimiter);
    }
    return new GenericBooleanPrefDataModel(data);
  }
}",0.936867469879518
61358,"/** 
 * <p>Reads one line from the input file and adds the data to a   {@link Map} data structure which maps user IDs topreferences. This assumes that each line of the input file corresponds to one preference. After reading a line and determining which user and item the preference pertains to, the method should look to see if the data contains a mapping for the user ID already, and if not, add an empty  {@link List} of {@link Preference}s to the data.</p> <p>Note that if the line is empty or begins with '#' it will be ignored as a comment.</p>
 * @param line      line from input data file
 * @param data      all data read so far, as a mapping from user IDs to preferences
 */
protected void processLine(String line,FastByIDMap<Collection<Preference>> data,char delimiter){
  if (line.length() == 0 || line.charAt(0) == '#') {
    return;
  }
  int delimiterOne=line.indexOf((int)delimiter);
  int delimiterTwo=line.indexOf((int)delimiter,delimiterOne + 1);
  if (delimiterOne < 0 || delimiterTwo < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  long userID=Long.parseLong(line.substring(0,delimiterOne));
  long itemID=Long.parseLong(line.substring(delimiterOne + 1,delimiterTwo));
  String preferenceValueString=line.substring(delimiterTwo + 1);
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  Collection<Preference> prefs=data.get(userID);
  if (prefs == null) {
    prefs=new ArrayList<Preference>(2);
    data.put(userID,prefs);
  }
  if (preferenceValueString.length() == 0) {
    Iterator<Preference> prefsIterator=prefs.iterator();
    while (prefsIterator.hasNext()) {
      Preference pref=prefsIterator.next();
      if (pref.getItemID() == itemID) {
        prefsIterator.remove();
        break;
      }
    }
  }
 else {
    float preferenceValue=Float.parseFloat(preferenceValueString);
    prefs.add(new GenericPreference(userID,itemID,preferenceValue));
  }
}","/** 
 * <p>Reads one line from the input file and adds the data to a   {@link Map} data structure which maps user IDs topreferences. This assumes that each line of the input file corresponds to one preference. After reading a line and determining which user and item the preference pertains to, the method should look to see if the data contains a mapping for the user ID already, and if not, add an empty  {@link List} of {@link Preference}s to the data.</p> <p>Note that if the line is empty or begins with '#' it will be ignored as a comment.</p>
 * @param line      line from input data file
 * @param data      all data read so far, as a mapping from user IDs to preferences
 */
protected void processLine(String line,FastByIDMap<Collection<Preference>> data,char delimiter){
  if (line.length() == 0 || line.charAt(0) == COMMENT_CHAR) {
    return;
  }
  int delimiterOne=line.indexOf((int)delimiter);
  int delimiterTwo=line.indexOf((int)delimiter,delimiterOne + 1);
  if (delimiterOne < 0 || delimiterTwo < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  long userID=Long.parseLong(line.substring(0,delimiterOne));
  long itemID=Long.parseLong(line.substring(delimiterOne + 1,delimiterTwo));
  String preferenceValueString=line.substring(delimiterTwo + 1);
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  Collection<Preference> prefs=data.get(userID);
  if (prefs == null) {
    prefs=new ArrayList<Preference>(2);
    data.put(userID,prefs);
  }
  if (preferenceValueString.length() == 0) {
    Iterator<Preference> prefsIterator=prefs.iterator();
    while (prefsIterator.hasNext()) {
      Preference pref=prefsIterator.next();
      if (pref.getItemID() == itemID) {
        prefsIterator.remove();
        break;
      }
    }
  }
 else {
    float preferenceValue=Float.parseFloat(preferenceValueString);
    prefs.add(new GenericPreference(userID,itemID,preferenceValue));
  }
}",0.9961548320943348
61359,"protected void processLineWithoutID(String line,FastByIDMap<FastIDSet> data,char delimiter){
  if (line.length() == 0 || line.charAt(0) == '#') {
    return;
  }
  int delimiterOne=line.indexOf((int)delimiter);
  if (delimiterOne < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  long userID=Long.parseLong(line.substring(0,delimiterOne));
  long itemID=Long.parseLong(line.substring(delimiterOne + 1));
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  FastIDSet itemIDs=data.get(userID);
  if (itemIDs == null) {
    itemIDs=new FastIDSet(2);
    data.put(userID,itemIDs);
  }
  itemIDs.add(itemID);
}","protected void processLineWithoutID(String line,FastByIDMap<FastIDSet> data,char delimiter){
  if (line.length() == 0 || line.charAt(0) == COMMENT_CHAR) {
    return;
  }
  int delimiterOne=line.indexOf((int)delimiter);
  if (delimiterOne < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + line);
  }
  long userID=Long.parseLong(line.substring(0,delimiterOne));
  long itemID=Long.parseLong(line.substring(delimiterOne + 1));
  if (transpose) {
    long tmp=userID;
    userID=itemID;
    itemID=tmp;
  }
  FastIDSet itemIDs=data.get(userID);
  if (itemIDs == null) {
    itemIDs=new FastIDSet(2);
    data.put(userID,itemIDs);
  }
  itemIDs.add(itemID);
}",0.9887640449438202
61360,"/** 
 * @throws NoSuchUserException if there is no such user 
 */
@Override public FastIDSet getItemIDsFromUser(long id) throws TasteException {
  log.debug(""String_Node_Str"",id);
  Connection conn=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  try {
    conn=dataSource.getConnection();
    stmt=conn.prepareStatement(getUserSQL,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    stmt.setLong(1,id);
    log.debug(""String_Node_Str"",getUserSQL);
    rs=stmt.executeQuery();
    FastIDSet result=new FastIDSet();
    while (rs.next()) {
      result.add(rs.getLong(1));
    }
    if (result.isEmpty()) {
      throw new NoSuchUserException();
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}","/** 
 * @throws NoSuchUserException if there is no such user 
 */
@Override public FastIDSet getItemIDsFromUser(long id) throws TasteException {
  log.debug(""String_Node_Str"",id);
  Connection conn=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  try {
    conn=dataSource.getConnection();
    stmt=conn.prepareStatement(getUserSQL,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
    stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
    stmt.setFetchSize(getFetchSize());
    stmt.setLong(1,id);
    log.debug(""String_Node_Str"",getUserSQL);
    rs=stmt.executeQuery();
    FastIDSet result=new FastIDSet();
    while (rs.next()) {
      result.add(rs.getLong(2));
    }
    if (result.isEmpty()) {
      throw new NoSuchUserException();
    }
    return result;
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new TasteException(sqle);
  }
 finally {
    IOUtils.quietClose(rs,stmt,conn);
  }
}",0.9989462592202318
61361,"private static char determineDelimiter(String line){
  char delimiter;
  if (line.indexOf(',') >= 0) {
    delimiter=',';
  }
 else   if (line.indexOf('\t') >= 0) {
    delimiter='\t';
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int delimiterCount=1;
  int lastDelimiter=line.indexOf(delimiter);
  int nextDelimiter;
  while ((nextDelimiter=line.indexOf(delimiter,lastDelimiter + 1)) >= 0) {
    delimiterCount++;
    if (delimiterCount == 3) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (nextDelimiter == lastDelimiter + 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  return delimiter;
}","private static char determineDelimiter(String line){
  char delimiter;
  if (line.indexOf(',') >= 0) {
    delimiter=',';
  }
 else   if (line.indexOf('\t') >= 0) {
    delimiter='\t';
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int delimiterCount=0;
  int lastDelimiter=line.indexOf(delimiter);
  int nextDelimiter;
  while ((nextDelimiter=line.indexOf(delimiter,lastDelimiter + 1)) >= 0) {
    delimiterCount++;
    if (delimiterCount == 3) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (nextDelimiter == lastDelimiter + 1) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    lastDelimiter=nextDelimiter;
  }
  return delimiter;
}",0.9749821300929236
61362,"@Override public void removePreference(long userID,long itemID) throws NoSuchUserException {
  throw new UnsupportedOperationException();
}","@Override public void removePreference(long userID,long itemID){
  throw new UnsupportedOperationException();
}",0.888
61363,"public static FastByIDMap<FastIDSet> toDataMap(FastByIDMap<PreferenceArray> data) throws TasteException {
  for (  Map.Entry<Long,Object> entry : ((FastByIDMap<Object>)(FastByIDMap<?>)data).entrySet()) {
    PreferenceArray prefArray=(PreferenceArray)entry.getValue();
    int size=prefArray.length();
    FastIDSet itemIDs=new FastIDSet(size);
    for (int i=0; i < size; i++) {
      itemIDs.add(prefArray.getItemID(i));
    }
    entry.setValue(itemIDs);
  }
  return (FastByIDMap<FastIDSet>)(FastByIDMap<?>)data;
}","public static FastByIDMap<FastIDSet> toDataMap(FastByIDMap<PreferenceArray> data){
  for (  Map.Entry<Long,Object> entry : ((FastByIDMap<Object>)(FastByIDMap<?>)data).entrySet()) {
    PreferenceArray prefArray=(PreferenceArray)entry.getValue();
    int size=prefArray.length();
    FastIDSet itemIDs=new FastIDSet(size);
    for (int i=0; i < size; i++) {
      itemIDs.add(prefArray.getItemID(i));
    }
    entry.setValue(itemIDs);
  }
  return (FastByIDMap<FastIDSet>)(FastByIDMap<?>)data;
}",0.9772951628825272
61364,"@Override public Float getPreferenceValue(long userID,long itemID) throws NoSuchUserException, NoSuchItemException {
  FastIDSet itemIDs=preferenceFromUsers.get(userID);
  if (itemIDs == null) {
    throw new NoSuchUserException();
  }
  if (itemIDs.contains(itemID)) {
    return 1.0f;
  }
  return null;
}","@Override public Float getPreferenceValue(long userID,long itemID) throws NoSuchUserException {
  FastIDSet itemIDs=preferenceFromUsers.get(userID);
  if (itemIDs == null) {
    throw new NoSuchUserException();
  }
  if (itemIDs.contains(itemID)) {
    return 1.0f;
  }
  return null;
}",0.9645868465430016
61365,"@Override public int getNumUsersWithPreferenceFor(long... itemIDs) throws NoSuchItemException {
  if (itemIDs.length == 0) {
    return 0;
  }
  FastIDSet userIDs=preferenceForItems.get(itemIDs[0]);
  if (userIDs == null) {
    throw new NoSuchItemException();
  }
  FastIDSet intersection=new FastIDSet(userIDs.size());
  intersection.addAll(userIDs);
  int i=1;
  while (!intersection.isEmpty() && i < itemIDs.length) {
    userIDs=preferenceForItems.get(itemIDs[i]);
    if (userIDs == null) {
      throw new NoSuchItemException();
    }
    intersection.retainAll(userIDs);
  }
  return intersection.size();
}","@Override public int getNumUsersWithPreferenceFor(long... itemIDs) throws NoSuchItemException {
  if (itemIDs.length == 0) {
    return 0;
  }
  FastIDSet userIDs=preferenceForItems.get(itemIDs[0]);
  if (userIDs == null) {
    throw new NoSuchItemException();
  }
  FastIDSet intersection=new FastIDSet(userIDs.size());
  intersection.addAll(userIDs);
  int i=1;
  while (!intersection.isEmpty() && i < itemIDs.length) {
    userIDs=preferenceForItems.get(itemIDs[i]);
    if (userIDs == null) {
      throw new NoSuchItemException();
    }
    intersection.retainAll(userIDs);
    i++;
  }
  return intersection.size();
}",0.9927243330638642
61366,"@Override public void setPreference(long userID,long itemID,float value) throws NoSuchUserException {
  throw new UnsupportedOperationException();
}","@Override public void setPreference(long userID,long itemID,float value){
  throw new UnsupportedOperationException();
}",0.8955223880597015
61367,"protected AbstractJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn,String preferenceColumn,String getUserSQL,String getNumItemsSQL,String getNumUsersSQL,String setPreferenceSQL,String removePreferenceSQL,String getUsersSQL,String getItemsSQL,String getItemSQL,String getPrefsForItemSQL,String getNumPreferenceForItemSQL,String getNumPreferenceForItemsSQL){
  log.debug(""String_Node_Str"");
  checkNotNullAndLog(""String_Node_Str"",preferenceTable);
  checkNotNullAndLog(""String_Node_Str"",userIDColumn);
  checkNotNullAndLog(""String_Node_Str"",itemIDColumn);
  checkNotNullAndLog(""String_Node_Str"",preferenceColumn);
  checkNotNullAndLog(""String_Node_Str"",dataSource);
  checkNotNullAndLog(""String_Node_Str"",getUserSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumItemsSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumUsersSQL);
  checkNotNullAndLog(""String_Node_Str"",setPreferenceSQL);
  checkNotNullAndLog(""String_Node_Str"",removePreferenceSQL);
  checkNotNullAndLog(""String_Node_Str"",getUsersSQL);
  checkNotNullAndLog(""String_Node_Str"",getItemsSQL);
  checkNotNullAndLog(""String_Node_Str"",getItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getPrefsForItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumPreferenceForItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumPreferenceForItemsSQL);
  if (!(dataSource instanceof ConnectionPoolDataSource)) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.preferenceTable=preferenceTable;
  this.userIDColumn=userIDColumn;
  this.itemIDColumn=itemIDColumn;
  this.preferenceColumn=preferenceColumn;
  this.dataSource=dataSource;
  this.getUserSQL=getUserSQL;
  this.getNumItemsSQL=getNumItemsSQL;
  this.getNumUsersSQL=getNumUsersSQL;
  this.setPreferenceSQL=setPreferenceSQL;
  this.removePreferenceSQL=removePreferenceSQL;
  this.getUsersSQL=getUsersSQL;
  this.getItemsSQL=getItemsSQL;
  this.getItemSQL=getItemSQL;
  this.getPrefsForItemSQL=getPrefsForItemSQL;
  this.getNumPreferenceForItemSQL=getNumPreferenceForItemSQL;
  this.getNumPreferenceForItemsSQL=getNumPreferenceForItemsSQL;
}","protected AbstractJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn,String preferenceColumn,String getUserSQL,String getNumItemsSQL,String getNumUsersSQL,String setPreferenceSQL,String removePreferenceSQL,String getUsersSQL,String getItemsSQL,String getItemSQL,String getPrefsForItemSQL,String getNumPreferenceForItemSQL,String getNumPreferenceForItemsSQL){
  log.debug(""String_Node_Str"");
  checkNotNullAndLog(""String_Node_Str"",preferenceTable);
  checkNotNullAndLog(""String_Node_Str"",userIDColumn);
  checkNotNullAndLog(""String_Node_Str"",itemIDColumn);
  checkNotNullAndLog(""String_Node_Str"",preferenceColumn);
  checkNotNullAndLog(""String_Node_Str"",dataSource);
  checkNotNullAndLog(""String_Node_Str"",getUserSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumItemsSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumUsersSQL);
  checkNotNullAndLog(""String_Node_Str"",setPreferenceSQL);
  checkNotNullAndLog(""String_Node_Str"",removePreferenceSQL);
  checkNotNullAndLog(""String_Node_Str"",getUsersSQL);
  checkNotNullAndLog(""String_Node_Str"",getItemsSQL);
  checkNotNullAndLog(""String_Node_Str"",getItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getPrefsForItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumPreferenceForItemSQL);
  checkNotNullAndLog(""String_Node_Str"",getNumPreferenceForItemsSQL);
  if (!(dataSource instanceof ConnectionPoolDataSource)) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.preferenceTable=preferenceTable;
  this.userIDColumn=userIDColumn;
  this.itemIDColumn=itemIDColumn;
  this.preferenceColumn=preferenceColumn;
  this.dataSource=dataSource;
  this.getUserSQL=getUserSQL;
  this.getNumItemsSQL=getNumItemsSQL;
  this.getNumUsersSQL=getNumUsersSQL;
  this.setPreferenceSQL=setPreferenceSQL;
  this.removePreferenceSQL=removePreferenceSQL;
  this.getUsersSQL=getUsersSQL;
  this.getItemsSQL=getItemsSQL;
  this.getItemSQL=getItemSQL;
  this.getPrefsForItemSQL=getPrefsForItemSQL;
  this.getNumPreferenceForItemSQL=getNumPreferenceForItemSQL;
  this.getNumPreferenceForItemsSQL=getNumPreferenceForItemsSQL;
  this.cachedNumUsers=-1;
  this.cachedNumItems=-1;
}",0.9878334113242864
61368,"@Override public int getNumItems() throws TasteException {
  return getNumThings(""String_Node_Str"",getNumItemsSQL);
}","@Override public int getNumItems() throws TasteException {
  if (cachedNumItems < 0) {
    cachedNumItems=getNumThings(""String_Node_Str"",getNumItemsSQL);
  }
  return cachedNumItems;
}",0.7508305647840532
61369,"@Override public int getNumUsers() throws TasteException {
  return getNumThings(""String_Node_Str"",getNumUsersSQL);
}","@Override public int getNumUsers() throws TasteException {
  if (cachedNumUsers < 0) {
    cachedNumUsers=getNumThings(""String_Node_Str"",getNumUsersSQL);
  }
  return cachedNumUsers;
}",0.7574750830564784
61370,"@Override public void refresh(Collection<Refreshable> alreadyRefreshed){
}","@Override public void refresh(Collection<Refreshable> alreadyRefreshed){
  cachedNumUsers=-1;
  cachedNumItems=-1;
}",0.7789473684210526
61371,"/** 
 * <p>Creates a   {@link MySQLBooleanPrefJDBCDataModel} using the given {@link javax.sql.DataSource}and default table/column names.</p>
 * @param dataSource {@link javax.sql.DataSource} to use
 * @param preferenceTable name of table containing preference data
 * @param userIDColumn user ID column name
 * @param itemIDColumn item ID column name
 * @param preferenceColumn preference column name
 */
public MySQLBooleanPrefJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn,String preferenceColumn){
  super(dataSource,preferenceTable,userIDColumn,itemIDColumn,preferenceColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + preferenceTable + '('+ userIDColumn+ ','+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"");
}","/** 
 * <p>Creates a   {@link MySQLBooleanPrefJDBCDataModel} using the given {@link javax.sql.DataSource}and default table/column names.</p>
 * @param dataSource {@link javax.sql.DataSource} to use
 * @param preferenceTable name of table containing preference data
 * @param userIDColumn user ID column name
 * @param itemIDColumn item ID column name
 */
public MySQLBooleanPrefJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn){
  super(dataSource,preferenceTable,userIDColumn,itemIDColumn,NO_SUCH_COLUMN,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + preferenceTable + '('+ userIDColumn+ ','+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"");
}",0.9695686689600423
61372,"/** 
 * <p>Creates a   {@link MySQLJDBCDataModel} using the given {@link DataSource}and default table/column names.</p>
 * @param dataSource {@link DataSource} to use
 * @param preferenceTable name of table containing preference data
 * @param userIDColumn user ID column name
 * @param itemIDColumn item ID column name
 * @param preferenceColumn preference column name
 */
public MySQLJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn,String preferenceColumn){
  super(dataSource,preferenceTable,userIDColumn,itemIDColumn,preferenceColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + preferenceTable + '('+ userIDColumn+ ','+ itemIDColumn+ ','+ preferenceColumn+ ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceColumn + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"");
}","/** 
 * <p>Creates a   {@link MySQLJDBCDataModel} using the given {@link DataSource}and default table/column names.</p>
 * @param dataSource {@link DataSource} to use
 * @param preferenceTable name of table containing preference data
 * @param userIDColumn user ID column name
 * @param itemIDColumn item ID column name
 * @param preferenceColumn preference column name
 */
public MySQLJDBCDataModel(DataSource dataSource,String preferenceTable,String userIDColumn,String itemIDColumn,String preferenceColumn){
  super(dataSource,preferenceTable,userIDColumn,itemIDColumn,preferenceColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + userIDColumn + ""String_Node_Str""+ preferenceTable,""String_Node_Str"" + preferenceTable + '('+ userIDColumn+ ','+ itemIDColumn+ ','+ preferenceColumn+ ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + itemIDColumn + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceColumn + ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ userIDColumn,""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"",""String_Node_Str"" + preferenceTable + ""String_Node_Str""+ preferenceTable+ ""String_Node_Str""+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ userIDColumn+ ""String_Node_Str""+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str""+ itemIDColumn+ ""String_Node_Str"");
}",0.9973853101972904
61373,"public static void main(String[] args) throws IOException {
  DefaultOptionBuilder obuilder=new DefaultOptionBuilder();
  ArgumentBuilder abuilder=new ArgumentBuilder();
  GroupBuilder gbuilder=new GroupBuilder();
  Option inputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option fieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option idFieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option dictOutOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option delimiterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option powerOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option helpOpt=obuilder.withLongName(""String_Node_Str"").withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Group group=gbuilder.withName(""String_Node_Str"").withOption(inputOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(delimiterOpt).withOption(helpOpt).withOption(fieldOpt).withOption(maxOpt).withOption(dictOutOpt).withOption(powerOpt).create();
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    CommandLine cmdLine=parser.parse(args);
    if (cmdLine.hasOption(helpOpt)) {
      printHelp(group);
      return;
    }
    if (cmdLine.hasOption(inputOpt)) {
      File file=new File(cmdLine.getValue(inputOpt).toString());
      if (file.exists() && file.isDirectory()) {
        int maxDocs=Integer.MAX_VALUE;
        if (cmdLine.hasOption(maxOpt)) {
          maxDocs=Integer.parseInt(cmdLine.getValue(maxOpt).toString());
        }
        if (maxDocs < 0) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        Directory dir=FSDirectory.open(file);
        IndexReader reader=IndexReader.open(dir,true);
        Weight weight=new TFIDF();
        String field=cmdLine.getValue(fieldOpt).toString();
        TermInfo termInfo=new CachedTermInfo(reader,field,1,99);
        VectorMapper mapper=new TFDFMapper(reader,weight,termInfo);
        LuceneIteratable iteratable=null;
        String power=null;
        double norm=-1;
        if (cmdLine.hasOption(powerOpt)) {
          power=cmdLine.getValue(powerOpt).toString();
          if (power.equals(""String_Node_Str"")) {
            norm=Double.POSITIVE_INFINITY;
          }
 else {
            norm=Double.parseDouble(power);
          }
        }
        String idField=null;
        if (cmdLine.hasOption(idFieldOpt)) {
          idField=cmdLine.getValue(idFieldOpt).toString();
        }
        if (norm == -1) {
          iteratable=new LuceneIteratable(reader,idField,field,mapper);
        }
 else {
          iteratable=new LuceneIteratable(reader,idField,field,mapper,norm);
        }
        File outFile=new File(cmdLine.getValue(outputOpt).toString());
        log.info(""String_Node_Str"" + outFile);
        BufferedWriter writer=new BufferedWriter(new FileWriter(outFile));
        int i=0;
        for (        Vector vector : iteratable) {
          if (i >= maxDocs) {
            break;
          }
          writer.write(vector.asFormatString());
          writer.write(""String_Node_Str"");
          if (i % 500 == 0) {
            log.info(""String_Node_Str"" + i);
          }
          i++;
        }
        log.info(""String_Node_Str"" + i + ""String_Node_Str"");
        writer.flush();
        writer.close();
        File dictOutFile=new File(cmdLine.getValue(dictOutOpt).toString());
        log.info(""String_Node_Str"" + dictOutFile);
        writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dictOutFile),Charset.forName(""String_Node_Str"")));
        Iterator<TermEntry> entIter=termInfo.getAllEntries();
        String delimiter=cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : ""String_Node_Str"";
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(file.getAbsolutePath());
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(field);
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(String.valueOf(termInfo.totalTerms(field)));
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"" + delimiter + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
        writer.write(""String_Node_Str"");
        while (entIter.hasNext()) {
          TermEntry entry=entIter.next();
          writer.write(entry.term);
          writer.write(delimiter);
          writer.write(String.valueOf(entry.docFreq));
          writer.write(delimiter);
          writer.write(String.valueOf(entry.termIdx));
          writer.write(""String_Node_Str"");
        }
        writer.flush();
        writer.close();
      }
    }
  }
 catch (  OptionException e) {
    log.error(""String_Node_Str"",e);
    printHelp(group);
  }
}","public static void main(String[] args) throws IOException {
  DefaultOptionBuilder obuilder=new DefaultOptionBuilder();
  ArgumentBuilder abuilder=new ArgumentBuilder();
  GroupBuilder gbuilder=new GroupBuilder();
  Option inputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option outputOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option fieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option idFieldOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option dictOutOpt=obuilder.withLongName(""String_Node_Str"").withRequired(true).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option delimiterOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option powerOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"" + ""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option maxOpt=obuilder.withLongName(""String_Node_Str"").withRequired(false).withArgument(abuilder.withName(""String_Node_Str"").withMinimum(1).withMaximum(1).create()).withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Option helpOpt=obuilder.withLongName(""String_Node_Str"").withDescription(""String_Node_Str"").withShortName(""String_Node_Str"").create();
  Group group=gbuilder.withName(""String_Node_Str"").withOption(inputOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(delimiterOpt).withOption(helpOpt).withOption(fieldOpt).withOption(maxOpt).withOption(dictOutOpt).withOption(powerOpt).create();
  try {
    Parser parser=new Parser();
    parser.setGroup(group);
    CommandLine cmdLine=parser.parse(args);
    if (cmdLine.hasOption(helpOpt)) {
      printHelp(group);
      return;
    }
    if (cmdLine.hasOption(inputOpt)) {
      File file=new File(cmdLine.getValue(inputOpt).toString());
      if (file.exists() && file.isDirectory()) {
        int maxDocs=Integer.MAX_VALUE;
        if (cmdLine.hasOption(maxOpt)) {
          maxDocs=Integer.parseInt(cmdLine.getValue(maxOpt).toString());
        }
        if (maxDocs < 0) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        Directory dir=FSDirectory.open(file);
        IndexReader reader=IndexReader.open(dir,true);
        Weight weight=new TFIDF();
        String field=cmdLine.getValue(fieldOpt).toString();
        TermInfo termInfo=new CachedTermInfo(reader,field,1,99);
        VectorMapper mapper=new TFDFMapper(reader,weight,termInfo);
        LuceneIteratable iteratable=null;
        String power=null;
        double norm=-1;
        if (cmdLine.hasOption(powerOpt)) {
          power=cmdLine.getValue(powerOpt).toString();
          if (power.equals(""String_Node_Str"")) {
            norm=Double.POSITIVE_INFINITY;
          }
 else {
            norm=Double.parseDouble(power);
          }
        }
        String idField=null;
        if (cmdLine.hasOption(idFieldOpt)) {
          idField=cmdLine.getValue(idFieldOpt).toString();
        }
        if (norm == LuceneIteratable.NO_NORMALIZING) {
          iteratable=new LuceneIteratable(reader,idField,field,mapper,LuceneIteratable.NO_NORMALIZING);
        }
 else {
          iteratable=new LuceneIteratable(reader,idField,field,mapper,norm);
        }
        File outFile=new File(cmdLine.getValue(outputOpt).toString());
        log.info(""String_Node_Str"" + outFile);
        BufferedWriter writer=new BufferedWriter(new FileWriter(outFile));
        int i=0;
        for (        Vector vector : iteratable) {
          if (i >= maxDocs) {
            break;
          }
          writer.write(vector.asFormatString());
          writer.write(""String_Node_Str"");
          if (i % 500 == 0) {
            log.info(""String_Node_Str"" + i);
          }
          i++;
        }
        log.info(""String_Node_Str"" + i + ""String_Node_Str"");
        writer.flush();
        writer.close();
        File dictOutFile=new File(cmdLine.getValue(dictOutOpt).toString());
        log.info(""String_Node_Str"" + dictOutFile);
        writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dictOutFile),Charset.forName(""String_Node_Str"")));
        Iterator<TermEntry> entIter=termInfo.getAllEntries();
        String delimiter=cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : ""String_Node_Str"";
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(file.getAbsolutePath());
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(field);
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"");
        writer.write(delimiter);
        writer.write(String.valueOf(termInfo.totalTerms(field)));
        writer.write(""String_Node_Str"");
        writer.write(""String_Node_Str"" + delimiter + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
        writer.write(""String_Node_Str"");
        while (entIter.hasNext()) {
          TermEntry entry=entIter.next();
          writer.write(entry.term);
          writer.write(delimiter);
          writer.write(String.valueOf(entry.docFreq));
          writer.write(delimiter);
          writer.write(String.valueOf(entry.termIdx));
          writer.write(""String_Node_Str"");
        }
        writer.flush();
        writer.close();
      }
    }
  }
 catch (  OptionException e) {
    log.error(""String_Node_Str"",e);
    printHelp(group);
  }
}",0.9950180118034796
61374,"@Override public Vector next(){
  Vector result=null;
  int doc=termDocs.doc();
  try {
    indexReader.getTermFreqVector(doc,field,mapper);
    result=mapper.getVector();
    if (idField != null) {
      String id=indexReader.document(doc,idFieldSelector).get(idField);
      result.setName(id);
    }
 else {
      result.setName(String.valueOf(doc));
    }
    if (normPower >= 0) {
      result=result.normalize(normPower);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}","@Override public Vector next(){
  Vector result=null;
  int doc=termDocs.doc();
  try {
    indexReader.getTermFreqVector(doc,field,mapper);
    result=mapper.getVector();
    if (idField != null) {
      String id=indexReader.document(doc,idFieldSelector).get(idField);
      result.setName(id);
    }
 else {
      result.setName(String.valueOf(doc));
    }
    if (normPower != NO_NORMALIZING) {
      result=result.normalize(normPower);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}",0.9801324503311258
61375,"/** 
 * Produce a LuceneIterable that can create the Vector plus normalize it.
 * @param reader
 * @param idField - The Field containing the id.  May be null
 * @param field The field to use for the Vector
 * @param mapper
 * @param normPower
 */
public LuceneIteratable(IndexReader reader,String idField,String field,VectorMapper mapper,double normPower){
  this.indexReader=reader;
  this.idField=idField;
  this.field=field;
  this.mapper=mapper;
  this.normPower=normPower;
  idFieldSelector=new SetBasedFieldSelector(Collections.singleton(idField),Collections.emptySet());
}","/** 
 * Produce a LuceneIterable that can create the Vector plus normalize it.
 * @param reader The {@link org.apache.lucene.index.IndexReader} to read the documents from.
 * @param idField - The Field containing the id.  May be null
 * @param field The field to use for the Vector
 * @param mapper The {@link org.apache.mahout.utils.vectors.lucene.VectorMapper} for creating {@link org.apache.mahout.matrix.Vector}s from Lucene's TermVectors.
 * @param normPower The normalization value.  Must be greater than or equal to 0 or equal to {@link #NO_NORMALIZING}
 */
public LuceneIteratable(IndexReader reader,String idField,String field,VectorMapper mapper,double normPower){
  if (normPower != NO_NORMALIZING && normPower < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  idFieldSelector=new SetBasedFieldSelector(Collections.singleton(idField),Collections.emptySet());
  this.indexReader=reader;
  this.idField=idField;
  this.field=field;
  this.mapper=mapper;
  this.normPower=normPower;
}",0.5850596359070935
61376,"public static void main(String[] args) throws IOException {
  if (args.length == 7) {
    String input=args[0];
    String output=args[1];
    String measureClass=args[2];
    double t1=Double.parseDouble(args[3]);
    double t2=Double.parseDouble(args[4]);
    double convergenceDelta=Double.parseDouble(args[5]);
    int maxIterations=Integer.parseInt(args[6]);
    runJob(input,output,measureClass,convergenceDelta,t1,t2,maxIterations);
  }
 else   runJob(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",80,55,0.5,10);
}","public static void main(String[] args) throws IOException {
  if (args.length == 7) {
    String input=args[0];
    String output=args[1];
    String measureClass=args[2];
    double t1=Double.parseDouble(args[3]);
    double t2=Double.parseDouble(args[4]);
    double convergenceDelta=Double.parseDouble(args[5]);
    int maxIterations=Integer.parseInt(args[6]);
    runJob(input,output,measureClass,t1,t2,convergenceDelta,maxIterations);
  }
 else   runJob(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",80,55,0.5,10);
}",0.9886578449905482
61377,"@Override public void map(WritableComparable<?> key,Text values,OutputCollector<Text,Text> output,Reporter reporter) throws IOException {
  Vector v=DenseVector.decodeFormat(values.toString());
  Vector pi=normalizedProbabilities(state,v);
  int k=UncommonDistributions.rMultinom(pi);
  output.collect(new Text(String.valueOf(k)),values);
}","@Override public void map(WritableComparable<?> key,Text values,OutputCollector<Text,Text> output,Reporter reporter) throws IOException {
  Vector v=AbstractVector.decodeVector(values.toString());
  Vector pi=normalizedProbabilities(state,v);
  int k=UncommonDistributions.rMultinom(pi);
  output.collect(new Text(String.valueOf(k)),values);
}",0.9633967789165446
61378,"@Override public Collection<User> getUserNeighborhood(Object userID) throws TasteException {
  log.trace(""String_Node_Str"",userID);
  DataModel dataModel=getDataModel();
  User theUser=dataModel.getUser(userID);
  UserSimilarity userSimilarityImpl=getUserSimilarity();
  TopItems.Estimator<User> estimator=new Estimator(userSimilarityImpl,theUser,minSimilarity);
  List<User> neighborhood=TopItems.getTopUsers(n,dataModel.getUsers(),null,estimator);
  log.trace(""String_Node_Str"",userID,neighborhood);
  return Collections.unmodifiableList(neighborhood);
}","@Override public Collection<User> getUserNeighborhood(Object userID) throws TasteException {
  log.trace(""String_Node_Str"",userID);
  DataModel dataModel=getDataModel();
  User theUser=dataModel.getUser(userID);
  UserSimilarity userSimilarityImpl=getUserSimilarity();
  TopItems.Estimator<User> estimator=new Estimator(userSimilarityImpl,theUser,minSimilarity);
  Iterable<? extends User> users=SamplingIterable.maybeWrapIterable(dataModel.getUsers(),getSamplingRate());
  List<User> neighborhood=TopItems.getTopUsers(n,users,null,estimator);
  log.trace(""String_Node_Str"",userID,neighborhood);
  return Collections.unmodifiableList(neighborhood);
}",0.8888888888888888
61379,"@Override public Collection<User> getUserNeighborhood(Object userID) throws TasteException {
  log.trace(""String_Node_Str"",userID);
  DataModel dataModel=getDataModel();
  User theUser=dataModel.getUser(userID);
  List<User> neighborhood=new ArrayList<User>();
  Iterator<? extends User> users=dataModel.getUsers().iterator();
  UserSimilarity userSimilarityImpl=getUserSimilarity();
  while (users.hasNext()) {
    User user=users.next();
    if (sampleForUser() && !userID.equals(user.getID())) {
      double theSimilarity=userSimilarityImpl.userSimilarity(theUser,user);
      if (!Double.isNaN(theSimilarity) && theSimilarity >= threshold) {
        neighborhood.add(user);
      }
    }
  }
  log.trace(""String_Node_Str"",userID,neighborhood);
  return Collections.unmodifiableList(neighborhood);
}","@Override public Collection<User> getUserNeighborhood(Object userID) throws TasteException {
  log.trace(""String_Node_Str"",userID);
  DataModel dataModel=getDataModel();
  User theUser=dataModel.getUser(userID);
  List<User> neighborhood=new ArrayList<User>();
  Iterable<? extends User> usersIterable=SamplingIterable.maybeWrapIterable(dataModel.getUsers(),getSamplingRate());
  Iterator<? extends User> users=usersIterable.iterator();
  UserSimilarity userSimilarityImpl=getUserSimilarity();
  while (users.hasNext()) {
    User user=users.next();
    if (!userID.equals(user.getID())) {
      double theSimilarity=userSimilarityImpl.userSimilarity(theUser,user);
      if (!Double.isNaN(theSimilarity) && theSimilarity >= threshold) {
        neighborhood.add(user);
      }
    }
  }
  log.trace(""String_Node_Str"",userID,neighborhood);
  return Collections.unmodifiableList(neighborhood);
}",0.7000589275191514
61380,"@Override public ModelDistribution<?> deserialize(JsonElement json,Type typeOfT,JsonDeserializationContext context) throws JsonParseException {
  ClassLoader ccl=Thread.currentThread().getContextClassLoader();
  Class<?> cl=null;
  try {
    cl=ccl.loadClass(json.getAsString());
  }
 catch (  ClassNotFoundException e) {
    log.warn(""String_Node_Str"",e);
  }
  try {
    return (ModelDistribution<?>)cl.newInstance();
  }
 catch (  InstantiationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    log.warn(""String_Node_Str"",e);
  }
  return null;
}","@Override public ModelDistribution<?> deserialize(JsonElement json,Type typeOfT,JsonDeserializationContext context) throws JsonParseException {
  ClassLoader ccl=Thread.currentThread().getContextClassLoader();
  Class<?> cl=null;
  try {
    cl=ccl.loadClass(json.getAsString());
  }
 catch (  ClassNotFoundException e) {
    log.warn(""String_Node_Str"",e);
    return null;
  }
  try {
    return (ModelDistribution<?>)cl.newInstance();
  }
 catch (  InstantiationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    log.warn(""String_Node_Str"",e);
  }
  return null;
}",0.9858686616791354
61381,"public void test() throws IOException {
  Analyzer analyzer=new WhitespaceAnalyzer();
  File[] files=out.listFiles();
  assertEquals(""String_Node_Str"" + files.length + ""String_Node_Str""+ 0,0,files.length);
  Charset charset=Charset.forName(""String_Node_Str"");
  BayesFileFormatter.format(""String_Node_Str"",analyzer,input,charset,out);
  files=out.listFiles();
  assertEquals(""String_Node_Str"" + files.length + ""String_Node_Str""+ words.length,files.length,words.length);
  for (  File file : files) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file),charset));
    String line=reader.readLine().trim();
    String label=""String_Node_Str"" + '\t' + file.getName();
    assertEquals(line + ""String_Node_Str"" + label+ ""String_Node_Str"",line,label);
    reader.close();
  }
}","public void test() throws IOException {
  Analyzer analyzer=new WhitespaceAnalyzer();
  File[] files=out.listFiles();
  assertEquals(""String_Node_Str"" + files.length + ""String_Node_Str""+ 0,0,files.length);
  Charset charset=Charset.forName(""String_Node_Str"");
  BayesFileFormatter.format(""String_Node_Str"",analyzer,input,charset,out);
  files=out.listFiles();
  assertEquals(""String_Node_Str"" + files.length + ""String_Node_Str""+ words.length,files.length,words.length);
  for (  File file : files) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file),charset));
    String line=reader.readLine();
    if (line != null) {
      line=line.trim();
    }
    String label=""String_Node_Str"" + '\t' + file.getName();
    assertEquals(line + ""String_Node_Str"" + label+ ""String_Node_Str"",line,label);
    reader.close();
  }
}",0.9719067543335326
61382,"private void printResults(List<List<DirichletCluster<Vector>>> clusters,int significant){
  int row=0;
  for (  List<DirichletCluster<Vector>> r : clusters) {
    System.out.print(""String_Node_Str"" + row++ + ""String_Node_Str"");
    for (int k=0; k < r.size(); k++) {
      Model<Vector> model=r.get(k).model;
      if (model.count() > significant) {
        int total=new Double(r.get(k).totalCount).intValue();
        System.out.print(""String_Node_Str"" + k + ""String_Node_Str""+ total+ ""String_Node_Str""+ model.toString()+ ""String_Node_Str"");
      }
    }
    System.out.println();
  }
  System.out.println();
}","private static void printResults(List<List<DirichletCluster<Vector>>> clusters,int significant){
  int row=0;
  for (  List<DirichletCluster<Vector>> r : clusters) {
    System.out.print(""String_Node_Str"" + row++ + ""String_Node_Str"");
    for (int k=0; k < r.size(); k++) {
      Model<Vector> model=r.get(k).model;
      if (model.count() > significant) {
        int total=(int)r.get(k).totalCount;
        System.out.print(""String_Node_Str"" + k + '('+ total+ ')'+ model.toString()+ ""String_Node_Str"");
      }
    }
    System.out.println();
  }
  System.out.println();
}",0.8879528222409435
61383,"/** 
 * Actually prints out the clusters
 * @param clusters a List of Lists of DirichletClusters
 * @param significant the minimum number of samples to enable printing a model
 */
private static void printResults(List<List<DirichletCluster<Vector>>> clusters,int significant){
  int row=0;
  for (  List<DirichletCluster<Vector>> r : clusters) {
    System.out.print(""String_Node_Str"" + row++ + ""String_Node_Str"");
    for (int k=0; k < r.size(); k++) {
      Model<Vector> model=r.get(k).model;
      if (model.count() > significant) {
        int total=new Double(r.get(k).totalCount).intValue();
        System.out.print(""String_Node_Str"" + k + ""String_Node_Str""+ total+ ""String_Node_Str""+ model.toString()+ ""String_Node_Str"");
      }
    }
    System.out.println();
  }
  System.out.println();
}","/** 
 * Actually prints out the clusters
 * @param clusters a List of Lists of DirichletClusters
 * @param significant the minimum number of samples to enable printing a model
 */
private static void printResults(List<List<DirichletCluster<Vector>>> clusters,int significant){
  int row=0;
  for (  List<DirichletCluster<Vector>> r : clusters) {
    System.out.print(""String_Node_Str"" + row++ + ""String_Node_Str"");
    for (int k=0; k < r.size(); k++) {
      Model<Vector> model=r.get(k).model;
      if (model.count() > significant) {
        int total=(int)r.get(k).totalCount;
        System.out.print(""String_Node_Str"" + k + '('+ total+ ')'+ model.toString()+ ""String_Node_Str"");
      }
    }
    System.out.println();
  }
  System.out.println();
}",0.918918918918919
61384,"public void testRanges() throws IOException {
  FileSystem fs=FileSystem.get(new Configuration());
  Path inpath=new Path(""String_Node_Str"");
  DataSet dataset=FileInfoParser.parseFile(fs,inpath);
  DataSet.initialize(dataset);
  String filename=""String_Node_Str"";
  BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(filename),Charset.forName(""String_Node_Str"")));
  String line;
  DataLine dl=new DataLine();
  while ((line=in.readLine()) != null) {
    dl.set(line);
    for (int index=0; index < dataset.getNbAttributes(); index++) {
      if (dataset.isNumerical(index)) {
        assertInRange(dl.getAttribut(index),dataset.getMin(index),dataset.getMax(index));
      }
 else {
        assertInRange(dl.getAttribut(index),0,dataset.getNbValues(index));
      }
    }
  }
}","public void testRanges() throws IOException {
  FileSystem fs=FileSystem.get(new Configuration());
  Path inpath=new Path(""String_Node_Str"");
  DataSet dataset=FileInfoParser.parseFile(fs,inpath);
  DataSet.initialize(dataset);
  String filename=""String_Node_Str"";
  BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(filename),Charset.forName(""String_Node_Str"")));
  String line;
  DataLine dl=new DataLine();
  while ((line=in.readLine()) != null) {
    dl.set(line);
    for (int index=0; index < dataset.getNbAttributes(); index++) {
      if (dataset.isNumerical(index)) {
        assertInRange(dl.getAttribut(index),dataset.getMin(index),dataset.getMax(index));
      }
 else {
        assertInRange(dl.getAttribut(index),0,dataset.getNbValues(index));
      }
    }
  }
  in.close();
}",0.991389913899139
61385,"/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param clustersIn the directory pathname for input clusters
 * @param output the directory pathname for output points
 * @param measureClass the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 */
private static void runClustering(String input,String clustersIn,String output,String measureClass,String convergenceDelta){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(output);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(KMeansClusterMapper.class);
  conf.setNumReduceTasks(0);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  conf.set(""String_Node_Str"",""String_Node_Str"");
  try {
    JobClient.runJob(conf);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
  }
}","/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param clustersIn the directory pathname for input clusters
 * @param output the directory pathname for output points
 * @param measureClass the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 */
private static void runClustering(String input,String clustersIn,String output,String measureClass,String convergenceDelta){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(output);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(KMeansClusterMapper.class);
  conf.setNumReduceTasks(0);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
  }
}",0.9788702026735662
61386,"/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param clustersIn the directory pathname for iniput clusters
 * @param clustersOut the directory pathname for output clusters
 * @param measureClass the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @return true if the iteration successfully runs
 */
private static boolean runIteration(String input,String clustersIn,String clustersOut,String measureClass,String convergenceDelta,int numReduceTasks){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setInputFormat(TextInputFormat.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(clustersOut);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setMapperClass(KMeansMapper.class);
  conf.setCombinerClass(KMeansCombiner.class);
  conf.setReducerClass(KMeansReducer.class);
  conf.setNumReduceTasks(numReduceTasks);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  conf.set(""String_Node_Str"",""String_Node_Str"");
  conf.set(""String_Node_Str"",""String_Node_Str"");
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
    FileSystem fs=FileSystem.get(conf);
    return isConverged(clustersOut + ""String_Node_Str"",conf,fs);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
    return true;
  }
}","/** 
 * Run the job using supplied arguments
 * @param input the directory pathname for input points
 * @param clustersIn the directory pathname for iniput clusters
 * @param clustersOut the directory pathname for output clusters
 * @param measureClass the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @return true if the iteration successfully runs
 */
private static boolean runIteration(String input,String clustersIn,String clustersOut,String measureClass,String convergenceDelta,int numReduceTasks){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  FileInputFormat.setInputPaths(conf,new Path(input));
  Path outPath=new Path(clustersOut);
  FileOutputFormat.setOutputPath(conf,outPath);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  conf.setMapperClass(KMeansMapper.class);
  conf.setCombinerClass(KMeansCombiner.class);
  conf.setReducerClass(KMeansReducer.class);
  conf.setNumReduceTasks(numReduceTasks);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
    FileSystem fs=FileSystem.get(conf);
    return isConverged(clustersOut + ""String_Node_Str"",conf,fs);
  }
 catch (  IOException e) {
    log.warn(e.toString(),e);
    return true;
  }
}",0.827831715210356
61387,"/** 
 * Return if all of the Clusters in the filePath have converged or not
 * @param filePath the file path to the single file containing the clusters
 * @param conf the JobConf
 * @param fs the FileSystem
 * @return true if all Clusters are converged
 * @throws IOException if there was an IO error
 */
private static boolean isConverged(String filePath,JobConf conf,FileSystem fs) throws IOException {
  Path clusterPath=new Path(filePath);
  List<Path> result=new ArrayList<Path>();
  PathFilter clusterFileFilter=new PathFilter(){
    public boolean accept(    Path path){
      return path.getName().startsWith(""String_Node_Str"");
    }
  }
;
  FileStatus[] matches=fs.listStatus(FileUtil.stat2Paths(fs.globStatus(clusterPath,clusterFileFilter)),clusterFileFilter);
  for (  FileStatus match : matches) {
    result.add(fs.makeQualified(match.getPath()));
  }
  boolean converged=true;
  for (  Path p : result) {
    KeyValueLineRecordReader reader=null;
    try {
      reader=new KeyValueLineRecordReader(conf,new FileSplit(p,0,fs.getFileStatus(p).getLen(),(String[])null));
      Text key=new Text();
      Text value=new Text();
      while (converged && reader.next(key,value)) {
        converged=value.toString().startsWith(""String_Node_Str"");
      }
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
  return converged;
}","/** 
 * Return if all of the Clusters in the filePath have converged or not
 * @param filePath the file path to the single file containing the clusters
 * @param conf     the JobConf
 * @param fs       the FileSystem
 * @return true if all Clusters are converged
 * @throws IOException if there was an IO error
 */
private static boolean isConverged(String filePath,JobConf conf,FileSystem fs) throws IOException {
  Path outPart=new Path(filePath);
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,outPart,conf);
  Text key=new Text();
  Text value=new Text();
  boolean converged=true;
  while (converged && reader.next(key,value)) {
    converged=value.toString().charAt(0) == 'V';
  }
  return converged;
}",0.5544933078393881
61388,"/** 
 * Configure the mapper with the cluster info
 * @param job
 * @param clusters
 */
public static void configureWithClusterInfo(String clusterPathStr,List<Cluster> clusters){
  JobConf job=new JobConf(KMeansUtil.class);
  Path clusterPath=new Path(clusterPathStr);
  List<Path> result=new ArrayList<Path>();
  PathFilter clusterFileFilter=new PathFilter(){
    public boolean accept(    Path path){
      return path.getName().startsWith(""String_Node_Str"");
    }
  }
;
  try {
    FileSystem fs=clusterPath.getFileSystem(job);
    FileStatus[] matches=fs.listStatus(FileUtil.stat2Paths(fs.globStatus(clusterPath,clusterFileFilter)),clusterFileFilter);
    for (    FileStatus match : matches) {
      result.add(fs.makeQualified(match.getPath()));
    }
    for (    Path path : result) {
      RecordReader<Text,Text> recordReader=null;
      try {
        recordReader=new KeyValueLineRecordReader(job,new FileSplit(path,0,fs.getFileStatus(path).getLen(),(String[])null));
        Text key=new Text();
        Text value=new Text();
        int counter=1;
        while (recordReader.next(key,value)) {
          Cluster cluster=Cluster.decodeCluster(value.toString());
          clusters.add(cluster);
        }
      }
  finally {
        if (recordReader != null) {
          recordReader.close();
        }
      }
    }
  }
 catch (  IOException e) {
    log.info(""String_Node_Str"",e);
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","/** 
 * Configure the mapper with the cluster info
 * @param job
 * @param clusters
 */
public static void configureWithClusterInfo(String clusterPathStr,List<Cluster> clusters){
  JobConf job=new JobConf(KMeansUtil.class);
  Path clusterPath=new Path(clusterPathStr);
  List<Path> result=new ArrayList<Path>();
  PathFilter clusterFileFilter=new PathFilter(){
    public boolean accept(    Path path){
      return path.getName().startsWith(""String_Node_Str"");
    }
  }
;
  try {
    FileSystem fs=clusterPath.getFileSystem(job);
    FileStatus[] matches=fs.listStatus(FileUtil.stat2Paths(fs.globStatus(clusterPath,clusterFileFilter)),clusterFileFilter);
    for (    FileStatus match : matches) {
      result.add(fs.makeQualified(match.getPath()));
    }
    for (    Path path : result) {
      SequenceFile.Reader reader=null;
      try {
        reader=new SequenceFile.Reader(fs,path,job);
        Text key=new Text();
        Text value=new Text();
        int counter=1;
        while (reader.next(key,value)) {
          Cluster cluster=Cluster.decodeCluster(value.toString());
          clusters.add(cluster);
        }
      }
  finally {
        if (reader != null) {
          reader.close();
        }
      }
    }
  }
 catch (  IOException e) {
    log.info(""String_Node_Str"",e);
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}",0.9058740268931352
61389,"/** 
 * Story: Test the reference implementation
 * @throws Exception
 */
public void testReferenceImplementation() throws Exception {
  List<Vector> points=getPoints(reference);
  DistanceMeasure measure=new EuclideanDistanceMeasure();
  Cluster.config(measure,0.001);
  for (int k=0; k < points.size(); k++) {
    System.out.println(""String_Node_Str"" + (k + 1) + ""String_Node_Str"");
    List<Cluster> clusters=new ArrayList<Cluster>();
    for (int i=0; i < k + 1; i++) {
      Vector vec=points.get(i);
      clusters.add(new VisibleCluster(vec));
    }
    int maxIter=10;
    referenceKmeans(points,clusters,measure,maxIter);
    for (int c=0; c < clusters.size(); c++) {
      Cluster cluster=clusters.get(c);
      assertEquals(""String_Node_Str"" + c + ""String_Node_Str""+ k,expectedNumPoints[k][c],cluster.getNumPoints());
      System.out.println(cluster.toString());
    }
  }
}","/** 
 * Story: Test the reference implementation
 * @throws Exception
 */
public void testReferenceImplementation() throws Exception {
  List<Vector> points=getPoints(reference);
  DistanceMeasure measure=new EuclideanDistanceMeasure();
  Cluster.config(measure,0.001);
  for (int k=0; k < points.size(); k++) {
    System.out.println(""String_Node_Str"" + (k + 1) + ':');
    List<Cluster> clusters=new ArrayList<Cluster>();
    for (int i=0; i < k + 1; i++) {
      Vector vec=points.get(i);
      clusters.add(new VisibleCluster(vec));
    }
    int maxIter=10;
    referenceKmeans(points,clusters,measure,maxIter);
    for (int c=0; c < clusters.size(); c++) {
      Cluster cluster=clusters.get(c);
      assertEquals(""String_Node_Str"" + c + ""String_Node_Str""+ k,expectedNumPoints[k][c],cluster.getNumPoints());
      System.out.println(cluster.toString());
    }
  }
}",0.9886234357224118
61390,"/** 
 * Story: User wishes to run kmeans job on reference data
 * @throws Exception
 */
public void testKMeansMRJob() throws Exception {
  List<Vector> points=getPoints(reference);
  File testData=new File(""String_Node_Str"");
  if (!testData.exists())   testData.mkdir();
  testData=new File(""String_Node_Str"");
  if (!testData.exists())   testData.mkdir();
  writePointsToFile(points,""String_Node_Str"");
  writePointsToFile(points,""String_Node_Str"");
  for (int k=1; k < points.size(); k++) {
    System.out.println(""String_Node_Str"" + k);
    JobConf job=new JobConf(KMeansDriver.class);
    FileSystem fs=FileSystem.get(job);
    Path path=new Path(""String_Node_Str"");
    BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(fs.create(path)));
    for (int i=0; i < k + 1; i++) {
      Vector vec=points.get(i);
      Cluster cluster=new Cluster(vec,i);
      cluster.addPoint(cluster.getCenter());
      writer.write(cluster.getIdentifier() + ""String_Node_Str"" + Cluster.formatCluster(cluster)+ ""String_Node_Str"");
    }
    writer.close();
    KMeansJob.runJob(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",EuclideanDistanceMeasure.class.getName(),0.001,10,k + 1);
    File outDir=new File(""String_Node_Str"");
    assertTrue(""String_Node_Str"",outDir.exists());
    String[] outFiles=outDir.list();
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str""),Charset.forName(""String_Node_Str"")));
    int[] expect=expectedNumPoints[k];
    DummyOutputCollector<Text,Text> collector=new DummyOutputCollector<Text,Text>();
    while (reader.ready()) {
      String line=reader.readLine();
      String[] lineParts=line.split(""String_Node_Str"");
      assertEquals(""String_Node_Str"",2,lineParts.length);
      collector.collect(new Text(lineParts[1]),new Text(lineParts[0]));
    }
    reader.close();
    if (k == 2)     assertEquals(""String_Node_Str"" + k + ""String_Node_Str"",expect.length - 1,collector.getKeys().size());
 else     assertEquals(""String_Node_Str"" + k + ""String_Node_Str"",expect.length,collector.getKeys().size());
  }
}","/** 
 * Story: User wishes to run kmeans job on reference data
 * @throws Exception
 */
public void testKMeansMRJob() throws Exception {
  List<Vector> points=getPoints(reference);
  File testData=new File(""String_Node_Str"");
  if (!testData.exists())   testData.mkdir();
  testData=new File(""String_Node_Str"");
  if (!testData.exists())   testData.mkdir();
  writePointsToFile(points,""String_Node_Str"");
  writePointsToFile(points,""String_Node_Str"");
  for (int k=1; k < points.size(); k++) {
    System.out.println(""String_Node_Str"" + k);
    JobConf job=new JobConf(KMeansDriver.class);
    FileSystem fs=FileSystem.get(job);
    Path path=new Path(""String_Node_Str"");
    SequenceFile.Writer writer=new SequenceFile.Writer(fs,job,path,Text.class,Text.class);
    for (int i=0; i < k + 1; i++) {
      Vector vec=points.get(i);
      Cluster cluster=new Cluster(vec,i);
      cluster.addPoint(cluster.getCenter());
      writer.append(new Text(cluster.getIdentifier()),new Text(Cluster.formatCluster(cluster)));
    }
    writer.close();
    KMeansJob.runJob(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",EuclideanDistanceMeasure.class.getName(),0.001,10,k + 1);
    File outDir=new File(""String_Node_Str"");
    assertTrue(""String_Node_Str"",outDir.exists());
    String[] outFiles=outDir.list();
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(""String_Node_Str""),Charset.forName(""String_Node_Str"")));
    int[] expect=expectedNumPoints[k];
    DummyOutputCollector<Text,Text> collector=new DummyOutputCollector<Text,Text>();
    while (reader.ready()) {
      String line=reader.readLine();
      String[] lineParts=line.split(""String_Node_Str"");
      assertEquals(""String_Node_Str"",2,lineParts.length);
      collector.collect(new Text(lineParts[1]),new Text(lineParts[0]));
    }
    reader.close();
    if (k == 2)     assertEquals(""String_Node_Str"" + k + ""String_Node_Str"",expect.length - 1,collector.getKeys().size());
 else     assertEquals(""String_Node_Str"" + k + ""String_Node_Str"",expect.length,collector.getKeys().size());
  }
}",0.9456106870229009
61391,"/** 
 * Run the kmeans clustering job on an input dataset using the given distance measure, t1, t2 and iteration parameters. All output data will be written to the output directory, which will be initially deleted if it exists. The clustered points will reside in the path <output>/clustered-points. By default, the job expects the a file containing synthetic_control.data as obtained from http://archive.ics.uci.edu/ml/datasets/Synthetic+Control+Chart+Time+Series resides in a directory named ""testdata"", and writes output to a directory named ""output"".
 * @param input the String denoting the input directory path
 * @param output the String denoting the output directory path
 * @param measureClass the String class name of the DistanceMeasure to use
 * @param t1 the canopy T1 threshold
 * @param t2 the canopy T2 threshold
 * @param convergenceDelta the double convergence criteria for iterations
 * @param maxIterations the int maximum number of iterations
 */
private static void runJob(String input,String output,String measureClass,double t1,double t2,double convergenceDelta,int maxIterations) throws IOException {
  JobClient client=new JobClient();
  JobConf conf=new JobConf(Job.class);
  Path outPath=new Path(output);
  client.setConf(conf);
  FileSystem dfs=FileSystem.get(conf);
  if (dfs.exists(outPath))   dfs.delete(outPath,true);
  InputDriver.runJob(input,output + ""String_Node_Str"");
  CanopyClusteringJob.runJob(output + ""String_Node_Str"",output,measureClass,t1,t2);
  KMeansDriver.runJob(output + ""String_Node_Str"",output + ""String_Node_Str"",output,measureClass,convergenceDelta,maxIterations,1);
  OutputDriver.runJob(output + ""String_Node_Str"",output + ""String_Node_Str"");
}","/** 
 * Run the kmeans clustering job on an input dataset using the given distance measure, t1, t2 and iteration parameters. All output data will be written to the output directory, which will be initially deleted if it exists. The clustered points will reside in the path <output>/clustered-points. By default, the job expects the a file containing synthetic_control.data as obtained from http://archive.ics.uci.edu/ml/datasets/Synthetic+Control+Chart+Time+Series resides in a directory named ""testdata"", and writes output to a directory named ""output"".
 * @param input the String denoting the input directory path
 * @param output the String denoting the output directory path
 * @param measureClass the String class name of the DistanceMeasure to use
 * @param t1 the canopy T1 threshold
 * @param t2 the canopy T2 threshold
 * @param convergenceDelta the double convergence criteria for iterations
 * @param maxIterations the int maximum number of iterations
 */
private static void runJob(String input,String output,String measureClass,double t1,double t2,double convergenceDelta,int maxIterations) throws IOException {
  JobClient client=new JobClient();
  JobConf conf=new JobConf(Job.class);
  Path outPath=new Path(output);
  client.setConf(conf);
  FileSystem dfs=FileSystem.get(conf);
  if (dfs.exists(outPath))   dfs.delete(outPath,true);
  InputDriver.runJob(input,output + ""String_Node_Str"");
  CanopyClusteringJob.runJob(output + ""String_Node_Str"",output,measureClass,t1,t2);
  KMeansDriver.runJob(output + ""String_Node_Str"",output + ""String_Node_Str"",output,measureClass,convergenceDelta,maxIterations,1);
}",0.9765342960288808
61392,"/** 
 * Add the point to the cluster
 * @param count the number of points in the delta
 * @param delta a point to add
 */
public void addPoints(int count,Vector delta){
  centroid=null;
  numPoints+=count;
  if (pointTotal == null)   pointTotal=delta.copy();
 else   pointTotal=delta.plus(pointTotal);
}","/** 
 * Add the point to the cluster
 * @param count the number of points in the delta
 * @param delta a point to add
 */
public void addPoints(int count,Vector delta){
  centroid=null;
  numPoints+=count;
  if (pointTotal == null)   pointTotal=delta.copy();
 else   pointTotal=pointTotal.plus(delta);
}",0.9504950495049505
61393,"/** 
 * Format the cluster for output
 * @param cluster the Cluster
 */
public static String formatCluster(Cluster cluster){
  return cluster.getIdentifier() + ""String_Node_Str"" + cluster.computeCentroid().asFormatString();
}","/** 
 * Format the cluster for output
 * @param cluster the Cluster
 * @return
 */
public static String formatCluster(Cluster cluster){
  return cluster.getIdentifier() + ""String_Node_Str"" + cluster.computeCentroid().asFormatString();
}",0.9761388286334056
61394,"/** 
 * Construct a new cluster with the given point as its center
 * @param center the center point
 */
public Cluster(Vector center,int clusterId){
  this.clusterId=clusterId;
  this.center=center;
  this.numPoints=0;
  this.pointTotal=center.like();
}","/** 
 * Construct a new clsuter with the given id as identifier
 * @param identifier
 */
public Cluster(String clusterId){
  this.clusterId=Integer.parseInt((clusterId.substring(1)));
  this.numPoints=0;
  this.converged=clusterId.startsWith(""String_Node_Str"");
}",0.3752417794970986
61395,"/** 
 * Configure the distance measure from the job
 * @param job the JobConf for the job
 */
public static void configure(JobConf job){
  try {
    ClassLoader ccl=Thread.currentThread().getContextClassLoader();
    Class<?> cl=ccl.loadClass(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
    convergenceDelta=Double.parseDouble(job.get(CLUSTER_CONVERGENCE_KEY));
    nextClusterId=0;
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Configure the distance measure from the job
 * @param job the JobConf for the job
 */
public static void configure(JobConf job){
  try {
    final ClassLoader ccl=Thread.currentThread().getContextClassLoader();
    Class<?> cl=ccl.loadClass(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
    convergenceDelta=Double.parseDouble(job.get(CLUSTER_CONVERGENCE_KEY));
    nextClusterId=0;
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(e);
  }
}",0.9956076134699854
61396,"/** 
 * Add the point to the cluster
 * @param point a point to add
 */
public void addPoint(Vector point){
  centroid=null;
  numPoints++;
  if (pointTotal == null)   pointTotal=point.copy();
 else   pointTotal=point.plus(pointTotal);
}","/** 
 * Add the point to the cluster
 * @param point a point to add
 */
public void addPoint(Vector point){
  addPoints(1,point);
}",0.6902173913043478
61397,"/** 
 * Emit the point to the nearest cluster center
 * @param point a point
 * @param clusters a List<Cluster> to test
 * @param values a Writable containing the input point and possible other values of interest (payload)
 * @param output the OutputCollector to emit into
 * @throws IOException
 */
public static void emitPointToNearestCluster(Vector point,List<Cluster> clusters,Text values,OutputCollector<Text,Text> output) throws IOException {
  Cluster nearestCluster=null;
  double nearestDistance=Double.MAX_VALUE;
  for (  Cluster cluster : clusters) {
    double distance=measure.distance(point,cluster.getCenter());
    if (nearestCluster == null || distance < nearestDistance) {
      nearestCluster=cluster;
      nearestDistance=distance;
    }
  }
  output.collect(new Text(formatCluster(nearestCluster)),values);
}","/** 
 * Emit the point to the nearest cluster center
 * @param point a point
 * @param clusters a List<Cluster> to test
 * @param values a Writable containing the input point and possible othervalues of interest (payload)
 * @param output the OutputCollector to emit into
 * @throws IOException
 */
public static void emitPointToNearestCluster(Vector point,List<Cluster> clusters,Text values,OutputCollector<Text,Text> output) throws IOException {
  Cluster nearestCluster=null;
  double nearestDistance=Double.MAX_VALUE;
  for (  Cluster cluster : clusters) {
    double distance=measure.distance(point,cluster.getCenter());
    if (nearestCluster == null || distance < nearestDistance) {
      nearestCluster=cluster;
      nearestDistance=distance;
    }
  }
  String outKey=nearestCluster.getIdentifier();
  String value=""String_Node_Str"" + values.toString();
  output.collect(new Text(outKey),new Text(value));
}",0.907842014882656
61398,"@Override public void reduce(Text key,Iterator<Text> values,OutputCollector<Text,Text> output,Reporter reporter) throws IOException {
  Cluster cluster=Cluster.decodeCluster(key.toString());
  while (values.hasNext()) {
    cluster.addPoint(AbstractVector.decodeVector(values.next().toString()));
  }
  output.collect(key,new Text(cluster.getNumPoints() + ""String_Node_Str"" + cluster.getPointTotal().asFormatString()));
}","@Override public void reduce(Text key,Iterator<Text> values,OutputCollector<Text,Text> output,Reporter reporter) throws IOException {
  Cluster cluster=new Cluster(key.toString());
  while (values.hasNext()) {
    String[] numPointnValue=values.next().toString().split(""String_Node_Str"");
    cluster.addPoints(Integer.parseInt(numPointnValue[0].trim()),AbstractVector.decodeVector(numPointnValue[1].trim()));
  }
  output.collect(key,new Text(cluster.getNumPoints() + ""String_Node_Str"" + cluster.getPointTotal().asFormatString()));
}",0.7811518324607329
61399,"/** 
 * @param dataFile file containing preferences data. If file is compressed (and name ends in .gzor .zip accordingly) it will be decompressed as it is read)
 * @throws FileNotFoundException if dataFile does not exist
 */
public FileDataModel(File dataFile) throws FileNotFoundException {
  if (dataFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!dataFile.exists() || dataFile.isDirectory()) {
    throw new FileNotFoundException(dataFile.toString());
  }
  this.delimiter=UNKNOWN_DELIMITER;
  log.info(""String_Node_Str"" + dataFile);
  this.dataFile=dataFile;
  this.lastModified=dataFile.lastModified();
  this.reloadLock=new ReentrantLock();
}","/** 
 * @param dataFile file containing preferences data. If file is compressed (and name ends in .gzor .zip accordingly) it will be decompressed as it is read)
 * @throws FileNotFoundException if dataFile does not exist
 */
public FileDataModel(File dataFile) throws FileNotFoundException {
  if (dataFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!dataFile.exists() || dataFile.isDirectory()) {
    throw new FileNotFoundException(dataFile.toString());
  }
  this.delimiter=UNKNOWN_DELIMITER;
  log.info(""String_Node_Str"" + dataFile);
  this.dataFile=dataFile.getAbsoluteFile();
  this.lastModified=dataFile.lastModified();
  this.reloadLock=new ReentrantLock();
}",0.9870503597122302
61400,"public void refresh(){
  recommender.refresh();
}","public void refresh(Collection<Refreshable> alreadyRefreshed){
  recommender.refresh(alreadyRefreshed);
}",0.6363636363636364
61401,"private void buildAverageDiffs() throws TasteException {
  log.info(""String_Node_Str"");
  try {
    buildAverageDiffsLock.writeLock().lock();
    long averageCount=0L;
    for (    User user : dataModel.getUsers()) {
      averageCount=processOneUser(averageCount,user);
    }
    double numItems=(double)dataModel.getNumItems();
    double threshold=1.0 / numItems / numItems/ numItems;
    for (Iterator<Map<Object,RunningAverage>> it1=averageDiffs.values().iterator(); it1.hasNext(); ) {
      Map<Object,RunningAverage> map=it1.next();
      for (Iterator<RunningAverage> it2=map.values().iterator(); it2.hasNext(); ) {
        RunningAverage average=it2.next();
        if (Math.abs(average.getAverage()) < threshold) {
          it2.remove();
        }
      }
      if (map.isEmpty()) {
        it1.remove();
      }
    }
  }
  finally {
    buildAverageDiffsLock.writeLock().unlock();
  }
}","private void buildAverageDiffs() throws TasteException {
  log.info(""String_Node_Str"");
  try {
    buildAverageDiffsLock.writeLock().lock();
    averageDiffs.clear();
    long averageCount=0L;
    for (    User user : dataModel.getUsers()) {
      averageCount=processOneUser(averageCount,user);
    }
    double numItems=(double)dataModel.getNumItems();
    double threshold=1.0 / numItems / numItems/ numItems;
    for (Iterator<Map<Object,RunningAverage>> it1=averageDiffs.values().iterator(); it1.hasNext(); ) {
      Map<Object,RunningAverage> map=it1.next();
      for (Iterator<RunningAverage> it2=map.values().iterator(); it2.hasNext(); ) {
        RunningAverage average=it2.next();
        if (Math.abs(average.getAverage()) < threshold) {
          it2.remove();
        }
      }
      if (map.isEmpty()) {
        it1.remove();
      }
    }
  }
  finally {
    buildAverageDiffsLock.writeLock().unlock();
  }
}",0.9857456140350878
61402,"public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.1,firstRecommended.getValue(),EPSILON);
}","public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.1,firstRecommended.getValue(),EPSILON);
  recommender.refresh();
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.1,firstRecommended.getValue(),EPSILON);
}",0.8398104265402844
61403,"public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  Collection<GenericItemCorrelation.ItemItemCorrelation> correlations=new ArrayList<GenericItemCorrelation.ItemItemCorrelation>(6);
  for (int i=0; i < 6; i++) {
    for (int j=i + 1; j < 6; j++) {
      correlations.add(new GenericItemCorrelation.ItemItemCorrelation(new GenericItem<String>(String.valueOf(i)),new GenericItem<String>(String.valueOf(j)),1.0 / (1.0 + (double)i + (double)j)));
    }
  }
  ItemCorrelation correlation=new GenericItemCorrelation(correlations);
  Recommender recommender=new GenericItemBasedRecommender(dataModel,correlation);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}","public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  Collection<GenericItemCorrelation.ItemItemCorrelation> correlations=new ArrayList<GenericItemCorrelation.ItemItemCorrelation>(6);
  for (int i=0; i < 6; i++) {
    for (int j=i + 1; j < 6; j++) {
      correlations.add(new GenericItemCorrelation.ItemItemCorrelation(new GenericItem<String>(String.valueOf(i)),new GenericItem<String>(String.valueOf(j)),1.0 / (1.0 + (double)i + (double)j)));
    }
  }
  ItemCorrelation correlation=new GenericItemCorrelation(correlations);
  Recommender recommender=new GenericItemBasedRecommender(dataModel,correlation);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
  recommender.refresh();
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}",0.9407918634217216
61404,"public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.3,firstRecommended.getValue());
}","public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.3,firstRecommended.getValue());
  recommender.refresh();
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.3,firstRecommended.getValue());
}",0.8438409311348206
61405,"public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  UserNeighborhood neighborhood=new NearestNUserNeighborhood(2,correlation,dataModel);
  Recommender recommender=new GenericUserBasedRecommender(dataModel,neighborhood,correlation);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}","public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  UserNeighborhood neighborhood=new NearestNUserNeighborhood(2,correlation,dataModel);
  Recommender recommender=new GenericUserBasedRecommender(dataModel,neighborhood,correlation);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
  recommender.refresh();
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}",0.923581809657759
61406,"public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  ClusterSimilarity similarity=new FarthestNeighborClusterSimilarity(correlation);
  Recommender recommender=new TreeClusteringRecommender(dataModel,similarity,2);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}","public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  ClusterSimilarity similarity=new FarthestNeighborClusterSimilarity(correlation);
  Recommender recommender=new TreeClusteringRecommender(dataModel,similarity,2);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
  recommender.refresh();
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}",0.9222699093943728
61407,"public void testNoRecommendations() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1));
  users.add(getUser(""String_Node_Str"",0.2,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.9));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  ClusterSimilarity similarity=new FarthestNeighborClusterSimilarity(correlation);
  Recommender recommender=new TreeClusteringRecommender(dataModel,similarity,2);
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(0,recommended.size());
}","public void testNoRecommendations() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1));
  users.add(getUser(""String_Node_Str"",0.2,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.9));
  DataModel dataModel=new GenericDataModel(users);
  UserCorrelation correlation=new PearsonCorrelation(dataModel);
  ClusterSimilarity similarity=new FarthestNeighborClusterSimilarity(correlation);
  Recommender recommender=new TreeClusteringRecommender(dataModel,similarity,2);
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(0,recommended.size());
  recommender.refresh();
  assertNotNull(recommended);
  assertEquals(0,recommended.size());
}",0.9351011863224006
61408,"public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.34803885284992736,firstRecommended.getValue(),EPSILON);
}","public void testRecommender() throws Exception {
  Recommender recommender=buildRecommender();
  List<RecommendedItem> recommended=recommender.recommend(""String_Node_Str"",1);
  assertNotNull(recommended);
  assertEquals(1,recommended.size());
  RecommendedItem firstRecommended=recommended.get(0);
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.34803885284992736,firstRecommended.getValue(),EPSILON);
  recommender.refresh();
  assertEquals(new GenericItem<String>(""String_Node_Str""),firstRecommended.getItem());
  assertEquals(0.34803885284992736,firstRecommended.getValue(),EPSILON);
}",0.8322756119673618
61409,"public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  Recommender recommender=new SlopeOneRecommender(dataModel);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}","public void testHowMany() throws Exception {
  List<User> users=new ArrayList<User>(3);
  users.add(getUser(""String_Node_Str"",0.1,0.2));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.3,0.6));
  users.add(getUser(""String_Node_Str"",0.4,0.4,0.5,0.9));
  users.add(getUser(""String_Node_Str"",0.1,0.4,0.5,0.8,0.9,1.0));
  users.add(getUser(""String_Node_Str"",0.2,0.3,0.6,0.7,0.1,0.2));
  DataModel dataModel=new GenericDataModel(users);
  Recommender recommender=new SlopeOneRecommender(dataModel);
  List<RecommendedItem> fewRecommended=recommender.recommend(""String_Node_Str"",2);
  List<RecommendedItem> moreRecommended=recommender.recommend(""String_Node_Str"",4);
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
  recommender.refresh();
  for (int i=0; i < fewRecommended.size(); i++) {
    assertEquals(fewRecommended.get(i).getItem(),moreRecommended.get(i).getItem());
  }
}",0.907543959160522
61410,"/** 
 * Configure the Canopy and its distance measure
 * @param job the JobConf for this job
 */
public static void configure(JobConf job){
  try {
    Class cl=Class.forName(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  nextCanopyId=0;
  t1=new Float(job.get(T1_KEY));
  t2=new Float(job.get(T2_KEY));
}","/** 
 * Configure the Canopy and its distance measure
 * @param job the JobConf for this job
 */
public static void configure(JobConf job){
  try {
    final ClassLoader ccl=Thread.currentThread().getContextClassLoader();
    Class cl=ccl.loadClass(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  nextCanopyId=0;
  t1=new Float(job.get(T1_KEY));
  t2=new Float(job.get(T2_KEY));
}",0.8813559322033898
61411,"/** 
 * @param args
 */
public static void main(String[] args){
  String input=args[0];
  String output=args[1];
  String measureClassName=args[2];
  float t1=new Float(args[3]);
  float t2=new Float(args[4]);
  String jarLocation=""String_Node_Str"";
  if (args.length > 5) {
    jarLocation=args[5];
  }
  runJob(input,output,measureClassName,t1,t2,jarLocation);
}","/** 
 * @param args
 */
public static void main(String[] args){
  String input=args[0];
  String output=args[1];
  String measureClassName=args[2];
  float t1=new Float(args[3]);
  float t2=new Float(args[4]);
  runJob(input,output,measureClassName,t1,t2);
}",0.6881028938906752
61412,"/** 
 * Run the job
 * @param input            the input pathname String
 * @param output           the output pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 */
public static void runJob(String input,String output,String measureClassName,float t1,float t2,String jarLocation){
  CanopyDriver.runJob(input,output + ""String_Node_Str"",measureClassName,t1,t2,jarLocation);
  ClusterDriver.runJob(input,output + ""String_Node_Str"",output,measureClassName,t1,t2,jarLocation);
}","/** 
 * Run the job
 * @param input            the input pathname String
 * @param output           the output pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 */
public static void runJob(String input,String output,String measureClassName,float t1,float t2){
  CanopyDriver.runJob(input,output + ""String_Node_Str"",measureClassName,t1,t2);
  ClusterDriver.runJob(input,output + ""String_Node_Str"",output,measureClassName,t1,t2);
}",0.9630901287553648
61413,"public static void main(String[] args){
  String input=args[0];
  String output=args[1];
  String measureClassName=args[2];
  float t1=new Float(args[3]);
  float t2=new Float(args[4]);
  String jarLocation=""String_Node_Str"";
  if (args.length > 5) {
    jarLocation=args[5];
  }
  runJob(input,output,measureClassName,t1,t2,jarLocation);
}","public static void main(String[] args){
  String input=args[0];
  String output=args[1];
  String measureClassName=args[2];
  float t1=new Float(args[3]);
  float t2=new Float(args[4]);
  runJob(input,output,measureClassName,t1,t2);
}",0.662020905923345
61414,"/** 
 * Run the job
 * @param input            the input pathname String
 * @param output           the output pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 */
public static void runJob(String input,String output,String measureClassName,float t1,float t2,String jarLocation){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(org.apache.mahout.clustering.canopy.CanopyDriver.class);
  conf.setJar(jarLocation);
  conf.set(Canopy.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(Canopy.T1_KEY,""String_Node_Str"" + t1);
  conf.set(Canopy.T2_KEY,""String_Node_Str"" + t2);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(output);
  conf.setOutputPath(outPath);
  conf.setMapperClass(CanopyMapper.class);
  conf.setCombinerClass(CanopyCombiner.class);
  conf.setReducerClass(CanopyReducer.class);
  conf.setNumReduceTasks(1);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  client.setConf(conf);
  try {
    FileSystem dfs=FileSystem.get(conf);
    if (dfs.exists(outPath))     dfs.delete(outPath);
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Run the job
 * @param input            the input pathname String
 * @param output           the output pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 */
public static void runJob(String input,String output,String measureClassName,float t1,float t2){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(org.apache.mahout.clustering.canopy.CanopyDriver.class);
  conf.set(Canopy.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(Canopy.T1_KEY,""String_Node_Str"" + t1);
  conf.set(Canopy.T2_KEY,""String_Node_Str"" + t2);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(output);
  conf.setOutputPath(outPath);
  conf.setMapperClass(CanopyMapper.class);
  conf.setCombinerClass(CanopyCombiner.class);
  conf.setReducerClass(CanopyReducer.class);
  conf.setNumReduceTasks(1);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  client.setConf(conf);
  try {
    FileSystem dfs=FileSystem.get(conf);
    if (dfs.exists(outPath))     dfs.delete(outPath);
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9821631878557876
61415,"public static void main(String[] args){
  String points=args[0];
  String canopies=args[1];
  String output=args[2];
  String measureClassName=args[3];
  float t1=new Float(args[4]);
  float t2=new Float(args[5]);
  String jarLocation=""String_Node_Str"";
  if (args.length > 6) {
    jarLocation=args[6];
  }
  runJob(points,canopies,output,measureClassName,t1,t2,jarLocation);
}","public static void main(String[] args){
  String points=args[0];
  String canopies=args[1];
  String output=args[2];
  String measureClassName=args[3];
  float t1=new Float(args[4]);
  float t2=new Float(args[5]);
  runJob(points,canopies,output,measureClassName,t1,t2);
}",0.6707692307692308
61416,"/** 
 * Run the job
 * @param points           the input points directory pathname String
 * @param canopies         the input canopies directory pathname String
 * @param output           the output directory pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 * @param jarLocation
 */
public static void runJob(String points,String canopies,String output,String measureClassName,float t1,float t2,String jarLocation){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(org.apache.mahout.clustering.canopy.ClusterDriver.class);
  conf.setJar(jarLocation);
  conf.set(Canopy.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(Canopy.T1_KEY,""String_Node_Str"" + t1);
  conf.set(Canopy.T2_KEY,""String_Node_Str"" + t2);
  conf.set(Canopy.CANOPY_PATH_KEY,canopies);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(points));
  Path outPath=new Path(output + ""String_Node_Str"");
  conf.setOutputPath(outPath);
  conf.setMapperClass(ClusterMapper.class);
  conf.setReducerClass(IdentityReducer.class);
  client.setConf(conf);
  try {
    FileSystem dfs=FileSystem.get(conf);
    if (dfs.exists(outPath))     dfs.delete(outPath);
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Run the job
 * @param points           the input points directory pathname String
 * @param canopies         the input canopies directory pathname String
 * @param output           the output directory pathname String
 * @param measureClassName the DistanceMeasure class name
 * @param t1               the T1 distance threshold
 * @param t2               the T2 distance threshold
 * @param jarLocation
 */
public static void runJob(String points,String canopies,String output,String measureClassName,float t1,float t2){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(org.apache.mahout.clustering.canopy.ClusterDriver.class);
  conf.set(Canopy.DISTANCE_MEASURE_KEY,measureClassName);
  conf.set(Canopy.T1_KEY,""String_Node_Str"" + t1);
  conf.set(Canopy.T2_KEY,""String_Node_Str"" + t2);
  conf.set(Canopy.CANOPY_PATH_KEY,canopies);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(points));
  Path outPath=new Path(output + ""String_Node_Str"");
  conf.setOutputPath(outPath);
  conf.setMapperClass(ClusterMapper.class);
  conf.setReducerClass(IdentityReducer.class);
  client.setConf(conf);
  try {
    FileSystem dfs=FileSystem.get(conf);
    if (dfs.exists(outPath))     dfs.delete(outPath);
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9171151776103336
61417,"/** 
 * Configure the distance measure from the job
 * @param job the JobConf for the job
 */
public static void configure(JobConf job){
  try {
    Class cl=Class.forName(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
    convergenceDelta=new Float(job.get(CLUSTER_CONVERGENCE_KEY));
    nextClusterId=0;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Configure the distance measure from the job
 * @param job the JobConf for the job
 */
public static void configure(JobConf job){
  try {
    final ClassLoader ccl=Thread.currentThread().getContextClassLoader();
    Class cl=ccl.loadClass(job.get(DISTANCE_MEASURE_KEY));
    measure=(DistanceMeasure)cl.newInstance();
    measure.configure(job);
    convergenceDelta=new Float(job.get(CLUSTER_CONVERGENCE_KEY));
    nextClusterId=0;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.8813559322033898
61418,"/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for input clusters
 * @param output           the directory pathname for output points
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @param jarLocation      The location of the mahout jar
 */
static void runClustering(String input,String clustersIn,String output,String measureClass,String convergenceDelta,String jarLocation){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setJar(jarLocation);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(output);
  conf.setOutputPath(outPath);
  conf.setMapperClass(KMeansMapper.class);
  conf.setNumReduceTasks(0);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for input clusters
 * @param output           the directory pathname for output points
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 */
static void runClustering(String input,String clustersIn,String output,String measureClass,String convergenceDelta){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(output);
  conf.setOutputPath(outPath);
  conf.setMapperClass(KMeansMapper.class);
  conf.setNumReduceTasks(0);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9548387096774194
61419,"/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for iniput clusters
 * @param clustersOut      the directory pathname for output clusters
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @param jarLocation      The location of the mahout jar
 * @return true if the iteration successfully runs
 */
static boolean runIteration(String input,String clustersIn,String clustersOut,String measureClass,String convergenceDelta,String jarLocation){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setJar(jarLocation);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(clustersOut);
  conf.setOutputPath(outPath);
  conf.setMapperClass(KMeansMapper.class);
  conf.setCombinerClass(KMeansCombiner.class);
  conf.setReducerClass(KMeansReducer.class);
  conf.setNumReduceTasks(1);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
    FileSystem fs=FileSystem.get(conf);
    return isConverged(clustersOut + ""String_Node_Str"",conf,fs);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return true;
  }
}","/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for iniput clusters
 * @param clustersOut      the directory pathname for output clusters
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @return true if the iteration successfully runs
 */
static boolean runIteration(String input,String clustersIn,String clustersOut,String measureClass,String convergenceDelta){
  JobClient client=new JobClient();
  JobConf conf=new JobConf(KMeansDriver.class);
  conf.setOutputKeyClass(Text.class);
  conf.setOutputValueClass(Text.class);
  conf.setInputPath(new Path(input));
  Path outPath=new Path(clustersOut);
  conf.setOutputPath(outPath);
  conf.setMapperClass(KMeansMapper.class);
  conf.setCombinerClass(KMeansCombiner.class);
  conf.setReducerClass(KMeansReducer.class);
  conf.setNumReduceTasks(1);
  conf.setOutputFormat(SequenceFileOutputFormat.class);
  conf.set(Cluster.CLUSTER_PATH_KEY,clustersIn);
  conf.set(Cluster.DISTANCE_MEASURE_KEY,measureClass);
  conf.set(Cluster.CLUSTER_CONVERGENCE_KEY,convergenceDelta);
  client.setConf(conf);
  try {
    JobClient.runJob(conf);
    FileSystem fs=FileSystem.get(conf);
    return isConverged(clustersOut + ""String_Node_Str"",conf,fs);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return true;
  }
}",0.964964964964965
61420,"public static void main(String[] args){
  String input=args[0];
  String clusters=args[1];
  String output=args[2];
  String measureClass=args[3];
  String convergenceDelta=args[4];
  String maxIterations=args[5];
  String jarLocation=""String_Node_Str"";
  if (args.length > 6) {
    jarLocation=args[6];
  }
  runJob(input,clusters,output,measureClass,convergenceDelta,maxIterations,jarLocation);
}","public static void main(String[] args){
  String input=args[0];
  String clusters=args[1];
  String output=args[2];
  String measureClass=args[3];
  String convergenceDelta=args[4];
  String maxIterations=args[5];
  runJob(input,clusters,output,measureClass,convergenceDelta,maxIterations);
}",0.8463768115942029
61421,"/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for initial & computed clusters
 * @param output           the directory pathname for output points
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @param maxIterations    the maximum number of iterations
 * @param jarLocation      The location of the Mahout jar
 */
public static void runJob(String input,String clustersIn,String output,String measureClass,String convergenceDelta,String maxIterations,String jarLocation){
  int maxIter=new Integer(maxIterations);
  try {
    JobConf conf=new JobConf(KMeansDriver.class);
    Path outPath=new Path(output);
    FileSystem fs=FileSystem.get(conf);
    if (fs.exists(outPath)) {
      fs.delete(outPath);
    }
    fs.mkdirs(outPath);
    boolean converged=false;
    int iteration=0;
    while (!converged && iteration < maxIter) {
      System.out.println(""String_Node_Str"" + iteration);
      String clustersOut=output + ""String_Node_Str"" + iteration;
      converged=runIteration(input,clustersIn,clustersOut,measureClass,convergenceDelta,jarLocation);
      clustersIn=output + ""String_Node_Str"" + iteration;
      iteration++;
    }
    System.out.println(""String_Node_Str"");
    runClustering(input,clustersIn,output + ""String_Node_Str"",measureClass,convergenceDelta,jarLocation);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Run the job using supplied arguments
 * @param input            the directory pathname for input points
 * @param clustersIn       the directory pathname for initial & computed clusters
 * @param output           the directory pathname for output points
 * @param measureClass     the classname of the DistanceMeasure
 * @param convergenceDelta the convergence delta value
 * @param maxIterations    the maximum number of iterations
 * @param jarLocation      The location of the Mahout jar
 */
public static void runJob(String input,String clustersIn,String output,String measureClass,String convergenceDelta,String maxIterations){
  int maxIter=new Integer(maxIterations);
  try {
    JobConf conf=new JobConf(KMeansDriver.class);
    Path outPath=new Path(output);
    FileSystem fs=FileSystem.get(conf);
    if (fs.exists(outPath)) {
      fs.delete(outPath);
    }
    fs.mkdirs(outPath);
    boolean converged=false;
    int iteration=0;
    while (!converged && iteration < maxIter) {
      System.out.println(""String_Node_Str"" + iteration);
      String clustersOut=output + ""String_Node_Str"" + iteration;
      converged=runIteration(input,clustersIn,clustersOut,measureClass,convergenceDelta);
      clustersIn=output + ""String_Node_Str"" + iteration;
      iteration++;
    }
    System.out.println(""String_Node_Str"");
    runClustering(input,clustersIn,output + ""String_Node_Str"",measureClass,convergenceDelta);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9858692080184028
61422,"public Matrix times(Matrix other) throws CardinalityException {
  int[] c=cardinality();
  int[] o=other.cardinality();
  if (c[COL] != o[ROW])   throw new CardinalityException();
  Matrix result=like(c[ROW],o[COL]);
  for (int row=0; row < c[ROW]; row++)   for (int col=0; col < c[COL]; col++) {
    double sum=0;
    for (int k=0; k < c[COL]; k++)     sum+=getQuick(row,k) * other.getQuick(k,col);
    result.setQuick(row,col,sum);
  }
  return result;
}","public Matrix times(Matrix other) throws CardinalityException {
  int[] c=cardinality();
  int[] o=other.cardinality();
  if (c[COL] != o[ROW])   throw new CardinalityException();
  Matrix result=like(c[ROW],o[COL]);
  for (int row=0; row < c[ROW]; row++)   for (int col=0; col < o[COL]; col++) {
    double sum=0;
    for (int k=0; k < c[COL]; k++)     sum+=getQuick(row,k) * other.getQuick(k,col);
    result.setQuick(row,col,sum);
  }
  return result;
}",0.9978070175438596
61423,"@Override public View getSelectedView(){
  throw new UnsupportedOperationException();
}","@Override public View getSelectedView(){
  return mTopCard;
}",0.7027027027027027
61424,"public CardModel(int cardImageResource){
  this.cardImageResource=cardImageResource;
  this.intent=intent;
}","public CardModel(int cardImageResource){
  this.cardImageResource=cardImageResource;
}",0.8865979381443299
61425,"public void translateCardToCenter(){
  AnimationSet animSet=new AnimationSet(true);
  TranslateAnimation anim=new TranslateAnimation(0,-getX(),0,-getY());
  anim.setDuration(600);
  anim.setAnimationListener(new TranslateAnimation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      setX(0);
      setY(0);
      setRotation(0);
      clearAnimation();
    }
  }
);
  animSet.addAnimation(anim);
  startAnimation(animSet);
}","public void translateCardToCenter(){
  AnimationSet animSet=new AnimationSet(true);
  TranslateAnimation anim=new TranslateAnimation(0,-getX(),0,-getY());
  anim.setDuration(600);
  anim.setAnimationListener(new TranslateAnimation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      setX(0);
      setY(0);
      clearAnimation();
    }
  }
);
  startAnimation(anim);
}",0.921119592875318
61426,"@Override public void onAnimationEnd(Animation animation){
  setX(0);
  setY(0);
  setRotation(0);
  clearAnimation();
}","@Override public void onAnimationEnd(Animation animation){
  setX(0);
  setY(0);
  clearAnimation();
}",0.918918918918919
61427,"public long addEvent(Event event,long userId,int eventTypeId){
  long id=numEvents.incrementAndGet();
  events.add(event);
  metaDatas.add(event.getMetaData(userId,eventTypeId));
  return id;
}","public long addEvent(Event event,long userId,int eventTypeId){
  int id=(int)numEvents.incrementAndGet();
  if (id >= events.length) {
synchronized (this) {
      if (id >= events.length) {
        Event[] newEvents=new Event[events.length * 2];
        System.arraycopy(events,0,newEvents,0,events.length);
        events=newEvents;
        Event.MetaData[] newMetaDatas=new Event.MetaData[events.length * 2];
        System.arraycopy(metaDatas,0,newMetaDatas,0,metaDatas.length);
        metaDatas=newMetaDatas;
      }
    }
  }
  events[id]=event;
  metaDatas[id]=event.getMetaData(userId,eventTypeId);
  return id;
}",0.1891891891891892
61428,"public static EventStorage build(){
  return new EventStorage(Lists.<Event>newArrayList(),Lists.<Event.MetaData>newArrayList(),new AtomicLong(-1));
}","public static EventStorage build(){
  return new EventStorage(new Event[1024],new Event.MetaData[1024],new AtomicLong(-1));
}",0.781021897810219
61429,"public Event.MetaData getEventMetaData(long eventId){
  return metaDatas.get((int)eventId);
}","public Event.MetaData getEventMetaData(long eventId){
  return metaDatas[(int)eventId];
}",0.956043956043956
61430,"private EventStorage(ArrayList<Event> events,ArrayList<Event.MetaData> metaDatas,AtomicLong numEvents){
  this.events=events;
  this.metaDatas=metaDatas;
  this.numEvents=numEvents;
}","private EventStorage(Event[] events,Event.MetaData[] metaDatas,AtomicLong numEvents){
  this.events=events;
  this.metaDatas=metaDatas;
  this.numEvents=numEvents;
}",0.9252873563218392
61431,"public static UserStorage build(){
  return new UserStorage(Lists.<User>newArrayList(),Lists.<User.MetaData>newArrayList(),Maps.<String,Long>newHashMap(),new AtomicLong(-1));
}","public static UserStorage build(){
  return new UserStorage(new User[1024],new User.MetaData[1024],Maps.<String,Long>newConcurrentMap(),new AtomicLong(-1));
}",0.7784431137724551
61432,"public long addUser(User user){
  long id=numEvents.incrementAndGet();
  users.add(user);
  idMap.put(user.getExternalId(),id);
  metaDatas.add(user.getMetaData());
  return id;
}","public long addUser(User user){
  int id=(int)numEvents.incrementAndGet();
  if (id >= users.length) {
synchronized (this) {
      if (id >= users.length) {
        User[] newUsers=new User[users.length * 2];
        System.arraycopy(users,0,newUsers,0,users.length);
        users=newUsers;
        User.MetaData[] newMetaDatas=new User.MetaData[users.length * 2];
        System.arraycopy(metaDatas,0,newMetaDatas,0,metaDatas.length);
        metaDatas=newMetaDatas;
      }
    }
  }
  users[id]=user;
  idMap.put(user.getExternalId(),new Long(id));
  metaDatas[id]=user.getMetaData();
  return id;
}",0.3427109974424552
61433,"private UserStorage(ArrayList<User> users,ArrayList<User.MetaData> metaDatas,Map<String,Long> idMap,AtomicLong numEvents){
  this.users=users;
  this.metaDatas=metaDatas;
  this.idMap=idMap;
  this.numEvents=numEvents;
}","private UserStorage(User[] users,User.MetaData[] metaDatas,Map<String,Long> idMap,AtomicLong numEvents){
  this.users=users;
  this.metaDatas=metaDatas;
  this.idMap=idMap;
  this.numEvents=numEvents;
}",0.90521327014218
61434,"/** 
 * WRITE_APN_SETTINGS
 * @param context 
 * @return 0-70
 */
public static int getRingVolume(Context context){
  return Settings.System.getInt(context.getContentResolver(),Settings.System.VOLUME_RING,0);
}","/** 
 * WRITE_APN_SETTINGS
 * @param context 
 * @return 0-70
 */
public static int getRingVolume(Context context){
  return ((AudioManager)context.getSystemService(Context.AUDIO_SERVICE)).getStreamVolume(AudioManager.STREAM_RING);
}",0.7054108216432866
61435,"private void parseAttrs(Context context,AttributeSet attrs){
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.FButton);
  if (typedArray == null)   return;
  for (int i=0; i < typedArray.getIndexCount(); i++) {
    int attr=typedArray.getIndex(i);
    if (attr == R.styleable.FButton_shadowEnabled) {
      isShadowEnabled=typedArray.getBoolean(attr,true);
    }
 else     if (attr == R.styleable.FButton_buttonColor) {
      mButtonColor=typedArray.getColor(attr,R.color.fbutton_default_color);
    }
 else     if (attr == R.styleable.FButton_shadowColor) {
      mShadowColor=typedArray.getColor(attr,R.color.fbutton_default_shadow_color);
      isShadowColorDefined=true;
    }
 else     if (attr == R.styleable.FButton_shadowHeight) {
      mShadowHeight=typedArray.getDimensionPixelSize(attr,R.dimen.fbutton_default_shadow_height);
    }
 else     if (attr == R.styleable.FButton_cornerRadius) {
      mCornerRadius=typedArray.getDimensionPixelSize(attr,R.dimen.fbutton_default_conner_radius);
    }
  }
  typedArray.recycle();
  int[] attrsArray=new int[]{android.R.attr.paddingLeft,android.R.attr.paddingRight};
  TypedArray ta=context.obtainStyledAttributes(attrs,attrsArray);
  if (ta == null)   return;
  mPaddingLeft=ta.getDimensionPixelSize(0,0);
  mPaddingRight=ta.getDimensionPixelSize(1,0);
  ta.recycle();
  int[] attrsArray2=new int[]{android.R.attr.paddingTop,android.R.attr.paddingBottom};
  TypedArray ta1=context.obtainStyledAttributes(attrs,attrsArray2);
  if (ta1 == null)   return;
  mPaddingTop=ta.getDimensionPixelSize(0,0);
  mPaddingBottom=ta.getDimensionPixelSize(1,0);
  ta1.recycle();
}","private void parseAttrs(Context context,AttributeSet attrs){
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.FButton);
  if (typedArray == null)   return;
  for (int i=0; i < typedArray.getIndexCount(); i++) {
    int attr=typedArray.getIndex(i);
    if (attr == R.styleable.FButton_shadowEnabled) {
      isShadowEnabled=typedArray.getBoolean(attr,true);
    }
 else     if (attr == R.styleable.FButton_buttonColor) {
      mButtonColor=typedArray.getColor(attr,R.color.fbutton_default_color);
    }
 else     if (attr == R.styleable.FButton_shadowColor) {
      mShadowColor=typedArray.getColor(attr,R.color.fbutton_default_shadow_color);
      isShadowColorDefined=true;
    }
 else     if (attr == R.styleable.FButton_shadowHeight) {
      mShadowHeight=typedArray.getDimensionPixelSize(attr,R.dimen.fbutton_default_shadow_height);
    }
 else     if (attr == R.styleable.FButton_cornerRadius) {
      mCornerRadius=typedArray.getDimensionPixelSize(attr,R.dimen.fbutton_default_conner_radius);
    }
  }
  typedArray.recycle();
  int[] attrsArray=new int[]{android.R.attr.paddingLeft,android.R.attr.paddingRight};
  TypedArray ta=context.obtainStyledAttributes(attrs,attrsArray);
  if (ta == null)   return;
  mPaddingLeft=ta.getDimensionPixelSize(0,0);
  mPaddingRight=ta.getDimensionPixelSize(1,0);
  ta.recycle();
  int[] attrsArray2=new int[]{android.R.attr.paddingTop,android.R.attr.paddingBottom};
  TypedArray ta1=context.obtainStyledAttributes(attrs,attrsArray2);
  if (ta1 == null)   return;
  mPaddingTop=ta1.getDimensionPixelSize(0,0);
  mPaddingBottom=ta1.getDimensionPixelSize(1,0);
  ta1.recycle();
}",0.9993909866017052
61436,"private void parseAttrs(Context context,AttributeSet attrs){
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.FButton);
  if (typedArray == null)   return;
  for (int i=0; i < typedArray.getIndexCount(); i++) {
    int attr=typedArray.getIndex(i);
    if (attr == R.styleable.FButton_shadowEnabled) {
      isShadowEnabled=typedArray.getBoolean(attr,true);
    }
 else     if (attr == R.styleable.FButton_buttonColor) {
      mButtonColor=typedArray.getColor(attr,R.color.button_default_color);
    }
 else     if (attr == R.styleable.FButton_shadowColor) {
      mShadowColor=typedArray.getColor(attr,R.color.button_default_shadow_color);
      isShadowColorDefined=true;
    }
 else     if (attr == R.styleable.FButton_shadowHeight) {
      mShadowHeight=typedArray.getDimensionPixelSize(attr,R.dimen.default_shadow_height);
    }
 else     if (attr == R.styleable.FButton_cornerRadius) {
      mCornerRadius=typedArray.getDimensionPixelSize(attr,R.dimen.default_conner_radius);
    }
  }
  typedArray.recycle();
}","private void parseAttrs(Context context,AttributeSet attrs){
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.FButton);
  if (typedArray == null)   return;
  for (int i=0; i < typedArray.getIndexCount(); i++) {
    int attr=typedArray.getIndex(i);
    if (attr == R.styleable.FButton_shadowEnabled) {
      isShadowEnabled=typedArray.getBoolean(attr,true);
    }
 else     if (attr == R.styleable.FButton_buttonColor) {
      mButtonColor=typedArray.getColor(attr,R.color.button_default_color);
    }
 else     if (attr == R.styleable.FButton_shadowColor) {
      mShadowColor=typedArray.getColor(attr,R.color.button_default_shadow_color);
      isShadowColorDefined=true;
    }
 else     if (attr == R.styleable.FButton_shadowHeight) {
      mShadowHeight=typedArray.getDimensionPixelSize(attr,R.dimen.default_shadow_height);
    }
 else     if (attr == R.styleable.FButton_cornerRadius) {
      mCornerRadius=typedArray.getDimensionPixelSize(attr,R.dimen.default_conner_radius);
    }
  }
  typedArray.recycle();
  int[] attrsArray=new int[]{android.R.attr.paddingLeft,android.R.attr.paddingRight};
  TypedArray ta=context.obtainStyledAttributes(attrs,attrsArray);
  if (ta == null)   return;
  mPaddingLeft=ta.getDimensionPixelSize(0,0);
  mPaddingRight=ta.getDimensionPixelSize(1,0);
  ta.recycle();
}",0.8780075981426763
61437,"@Override public boolean onTouch(View view,MotionEvent motionEvent){
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (isShadowEnabled) {
      this.setPadding(getResources().getDimensionPixelSize(R.dimen.default_padding_left),getResources().getDimensionPixelSize(R.dimen.default_padding_top),getResources().getDimensionPixelSize(R.dimen.default_padding_right),0);
    }
  break;
case MotionEvent.ACTION_MOVE:
Rect r=new Rect();
view.getLocalVisibleRect(r);
if (!r.contains((int)motionEvent.getX(),(int)motionEvent.getY())) {
if (isShadowEnabled) {
this.setPadding(getResources().getDimensionPixelSize(R.dimen.default_padding_left),getResources().getDimensionPixelSize(R.dimen.default_shadow_height),getResources().getDimensionPixelSize(R.dimen.default_padding_right),getResources().getDimensionPixelSize(R.dimen.default_shadow_height));
}
}
break;
case MotionEvent.ACTION_OUTSIDE:
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (isShadowEnabled) {
this.setPadding(getResources().getDimensionPixelSize(R.dimen.default_padding_left),getResources().getDimensionPixelSize(R.dimen.default_shadow_height),getResources().getDimensionPixelSize(R.dimen.default_padding_right),getResources().getDimensionPixelSize(R.dimen.default_shadow_height));
}
break;
}
return false;
}","@Override public boolean onTouch(View view,MotionEvent motionEvent){
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    if (isShadowEnabled) {
      this.setPadding(mPaddingLeft,mShadowHeight,mPaddingRight,0);
    }
  break;
case MotionEvent.ACTION_MOVE:
Rect r=new Rect();
view.getLocalVisibleRect(r);
if (!r.contains((int)motionEvent.getX(),(int)motionEvent.getY())) {
if (isShadowEnabled) {
this.setPadding(mPaddingLeft,mShadowHeight,mPaddingRight,mShadowHeight);
}
}
break;
case MotionEvent.ACTION_OUTSIDE:
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (isShadowEnabled) {
this.setPadding(mPaddingLeft,mShadowHeight,mPaddingRight,mShadowHeight);
}
break;
}
return false;
}",0.5392254220456802
61438,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  refresh();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  refresh();
  if (isShadowEnabled) {
    this.setPadding(mPaddingLeft,mShadowHeight,mPaddingRight,mShadowHeight);
  }
}",0.6159420289855072
61439,"public void scale(double factor){
  scaleX*=factor;
  scaleY*=factor;
  rotateSkew0*=factor;
  rotateSkew1*=factor;
}","public void scale(double factorX,double factorY){
  scaleX*=factorX;
  scaleY*=factorY;
  rotateSkew0*=factorX;
  rotateSkew1*=factorY;
}",0.9212598425196852
61440,"public static Matrix getScaleInstance(double scale){
  Matrix mat=new Matrix();
  mat.scale(scale);
  return mat;
}","public static Matrix getScaleInstance(double scaleX,double scaleY){
  Matrix mat=new Matrix();
  mat.scale(scaleX,scaleY);
  return mat;
}",0.9090909090909092
61441,"public Tag importSvg(ShapeTag st,String svgXml,boolean fill){
  shapeTag=st;
  SHAPEWITHSTYLE shapes=new SHAPEWITHSTYLE();
  shapes.fillStyles=new FILLSTYLEARRAY();
  shapes.lineStyles=new LINESTYLEARRAY();
  shapes.fillStyles.fillStyles=new FILLSTYLE[0];
  shapes.lineStyles.lineStyles=new LINESTYLE[0];
  int shapeNum=st.getShapeNum();
  shapes.shapeRecords=new ArrayList<>();
  Rectangle2D.Double viewBox=null;
  try {
    DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
    docFactory.setFeature(""String_Node_Str"",false);
    DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
    Document doc=docBuilder.parse(new InputSource(new StringReader(svgXml)));
    Element rootElement=doc.getDocumentElement();
    Map<String,Element> idMap=new HashMap<>();
    populateIds(rootElement,idMap);
    if (!""String_Node_Str"".equals(rootElement.getTagName())) {
      throw new IOException(""String_Node_Str"");
    }
    double width=800;
    double height=600;
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      String params=rootElement.getAttribute(""String_Node_Str"");
      String[] args=Matrix.parseSvgNumberList(params);
      viewBox=new Rectangle2D.Double();
      if (args.length > 0) {
        viewBox.x=parseNumber(args[0]);
      }
      if (args.length > 1) {
        viewBox.y=parseNumber(args[1]);
      }
      if (args.length > 2) {
        viewBox.width=parseNumber(args[2]);
      }
      if (args.length > 3) {
        viewBox.height=parseNumber(args[3]);
      }
      width=viewBox.width;
      height=viewBox.height;
    }
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      width=parseLength(rootElement.getAttribute(""String_Node_Str""),width);
    }
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      height=parseLength(rootElement.getAttribute(""String_Node_Str""),height);
    }
    if (viewBox == null) {
      viewBox=new Rectangle2D.Double();
      viewBox.width=width;
      viewBox.height=height;
    }
    this.viewBox=viewBox;
    SvgStyle style=new SvgStyle(this,idMap,rootElement);
    Matrix transform=new Matrix();
    processSvgObject(idMap,shapeNum,shapes,rootElement,transform,style);
  }
 catch (  SAXException|IOException|ParserConfigurationException ex) {
    Logger.getLogger(ShapeImporter.class.getName()).log(Level.SEVERE,null,ex);
  }
  shapes.shapeRecords.add(new EndShapeRecord());
  RECT rect=st.getRect();
  int origXmin=rect.Xmin;
  int origYmin=rect.Ymin;
  rect.Xmin-=origXmin;
  rect.Xmax-=origXmin;
  rect.Ymin-=origYmin;
  rect.Ymax-=origYmin;
  if (!fill && viewBox != null) {
    rect.Xmin=(int)Math.round(viewBox.x * SWF.unitDivisor);
    rect.Ymin=(int)Math.round(viewBox.y * SWF.unitDivisor);
    rect.Xmax=(int)Math.round((viewBox.x + viewBox.width) * SWF.unitDivisor);
    rect.Ymax=(int)Math.round((viewBox.y + viewBox.height) * SWF.unitDivisor);
  }
 else   if (viewBox != null) {
    double width=viewBox.width * SWF.unitDivisor;
    double height=viewBox.height * SWF.unitDivisor;
    double radioX=rect.getWidth() / width;
    double radioY=rect.getHeight() / height;
    shapes=shapes.resize(radioX,radioY);
  }
  st.shapes=shapes;
  st.setModified(true);
  return (Tag)st;
}","public Tag importSvg(ShapeTag st,String svgXml,boolean fill){
  shapeTag=st;
  SHAPEWITHSTYLE shapes=new SHAPEWITHSTYLE();
  shapes.fillStyles=new FILLSTYLEARRAY();
  shapes.lineStyles=new LINESTYLEARRAY();
  shapes.fillStyles.fillStyles=new FILLSTYLE[0];
  shapes.lineStyles.lineStyles=new LINESTYLE[0];
  int shapeNum=st.getShapeNum();
  RECT rect=st.getRect();
  int origXmin=rect.Xmin;
  int origYmin=rect.Ymin;
  rect.Xmin-=origXmin;
  rect.Xmax-=origXmin;
  rect.Ymin-=origYmin;
  rect.Ymax-=origYmin;
  shapes.shapeRecords=new ArrayList<>();
  Rectangle2D.Double viewBox=null;
  try {
    DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
    docFactory.setFeature(""String_Node_Str"",false);
    DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
    Document doc=docBuilder.parse(new InputSource(new StringReader(svgXml)));
    Element rootElement=doc.getDocumentElement();
    Map<String,Element> idMap=new HashMap<>();
    populateIds(rootElement,idMap);
    if (!""String_Node_Str"".equals(rootElement.getTagName())) {
      throw new IOException(""String_Node_Str"");
    }
    double width=800;
    double height=600;
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      String params=rootElement.getAttribute(""String_Node_Str"");
      String[] args=Matrix.parseSvgNumberList(params);
      viewBox=new Rectangle2D.Double();
      if (args.length > 0) {
        viewBox.x=parseNumber(args[0]);
      }
      if (args.length > 1) {
        viewBox.y=parseNumber(args[1]);
      }
      if (args.length > 2) {
        viewBox.width=parseNumber(args[2]);
      }
      if (args.length > 3) {
        viewBox.height=parseNumber(args[3]);
      }
      width=viewBox.width;
      height=viewBox.height;
    }
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      width=parseLength(rootElement.getAttribute(""String_Node_Str""),width);
    }
    if (rootElement.hasAttribute(""String_Node_Str"")) {
      height=parseLength(rootElement.getAttribute(""String_Node_Str""),height);
    }
    if (viewBox == null) {
      viewBox=new Rectangle2D.Double();
      viewBox.width=width;
      viewBox.height=height;
    }
    this.viewBox=viewBox;
    SvgStyle style=new SvgStyle(this,idMap,rootElement);
    Matrix transform=new Matrix();
    if (!fill) {
      rect.Xmin=(int)Math.round(viewBox.x * SWF.unitDivisor);
      rect.Ymin=(int)Math.round(viewBox.y * SWF.unitDivisor);
      rect.Xmax=(int)Math.round((viewBox.x + viewBox.width) * SWF.unitDivisor);
      rect.Ymax=(int)Math.round((viewBox.y + viewBox.height) * SWF.unitDivisor);
    }
 else {
      double ratioX=rect.getWidth() / width / SWF.unitDivisor;
      double ratioY=rect.getHeight() / height / SWF.unitDivisor;
      transform=Matrix.getScaleInstance(ratioX,ratioY);
    }
    processSvgObject(idMap,shapeNum,shapes,rootElement,transform,style);
  }
 catch (  SAXException|IOException|ParserConfigurationException ex) {
    Logger.getLogger(ShapeImporter.class.getName()).log(Level.SEVERE,null,ex);
  }
  shapes.shapeRecords.add(new EndShapeRecord());
  st.shapes=shapes;
  st.setModified(true);
  return (Tag)st;
}",0.7554992878620035
61442,"private void processCommands(int shapeNum,SHAPEWITHSTYLE shapes,List<PathCommand> commands,Matrix transform,SvgStyle style){
  Matrix transform2=transform.preConcatenate(Matrix.getScaleInstance(SWF.unitDivisor));
  Point prevPoint=new Point(0,0);
  Point startPoint=prevPoint;
  double x0=0;
  double y0=0;
  StyleChangeRecord scrStyle=getStyleChangeRecord(shapeNum,style);
  int fillStyle=scrStyle.fillStyle1;
  int lineStyle=scrStyle.lineStyle;
  scrStyle.stateFillStyle0=true;
  scrStyle.stateFillStyle1=true;
  scrStyle.stateLineStyle=true;
  scrStyle.fillStyle0=0;
  scrStyle.fillStyle1=0;
  scrStyle.lineStyle=0;
  List<SHAPERECORD> newRecords=new ArrayList<>();
  newRecords.add(scrStyle);
  LINESTYLE lineStyleObj=scrStyle.lineStyles.lineStyles.length < 1 ? null : scrStyle.lineStyles.lineStyles[0];
  LINESTYLE2 lineStyle2Obj=null;
  if (lineStyleObj instanceof LINESTYLE2) {
    lineStyle2Obj=(LINESTYLE2)lineStyleObj;
    lineStyle2Obj.noClose=true;
  }
  for (  PathCommand command : commands) {
    double x=x0;
    double y=y0;
    Point p;
    char cmd=Character.toUpperCase(command.command);
switch (cmd) {
case 'M':
      StyleChangeRecord scr=new StyleChangeRecord();
    if (fillStyle != 0) {
      scr.stateFillStyle1=true;
      scr.fillStyle1=fillStyle;
    }
  if (lineStyle != 0) {
    scr.lineStyle=lineStyle;
    scr.stateLineStyle=true;
  }
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
scr.moveDeltaX=(int)Math.round(p.x);
scr.moveDeltaY=(int)Math.round(p.y);
prevPoint=p;
scr.stateMoveTo=true;
newRecords.add(scr);
startPoint=p;
break;
case 'Z':
StraightEdgeRecord serz=new StraightEdgeRecord();
p=startPoint;
serz.deltaX=(int)Math.round(p.x - prevPoint.x);
serz.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
serz.generalLineFlag=true;
newRecords.add(serz);
if (lineStyle2Obj != null) {
lineStyle2Obj.noClose=false;
}
break;
case 'L':
StraightEdgeRecord serl=new StraightEdgeRecord();
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
serl.deltaX=(int)Math.round(p.x - prevPoint.x);
serl.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
serl.generalLineFlag=true;
serl.simplify();
newRecords.add(serl);
break;
case 'H':
StraightEdgeRecord serh=new StraightEdgeRecord();
x=command.params[0];
p=transform2.transform(x,y);
serh.deltaX=(int)Math.round(p.x - prevPoint.x);
prevPoint=p;
newRecords.add(serh);
break;
case 'V':
StraightEdgeRecord serv=new StraightEdgeRecord();
y=command.params[0];
p=transform2.transform(x,y);
serv.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
serv.vertLineFlag=true;
newRecords.add(serv);
break;
case 'Q':
CurvedEdgeRecord cer=new CurvedEdgeRecord();
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
cer.controlDeltaX=(int)Math.round(p.x - prevPoint.x);
cer.controlDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
x=command.params[2];
y=command.params[3];
p=transform2.transform(x,y);
cer.anchorDeltaX=(int)Math.round(p.x - prevPoint.x);
cer.anchorDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
newRecords.add(cer);
break;
case 'C':
showWarning(""String_Node_Str"",""String_Node_Str"");
Point pStart=prevPoint;
Point pControl1;
x=command.params[0];
y=command.params[1];
pControl1=transform2.transform(x,y);
x=command.params[2];
y=command.params[3];
Point pControl2=transform2.transform(x,y);
x=command.params[4];
y=command.params[5];
p=transform2.transform(x,y);
List<Double> quadCoordinates=new CubicToQuad().cubicToQuad(pStart.x,pStart.y,pControl1.x,pControl1.y,pControl2.x,pControl2.y,p.x,p.y,1);
for (int i=2; i < quadCoordinates.size(); ) {
CurvedEdgeRecord cerc=new CurvedEdgeRecord();
p=new Point(quadCoordinates.get(i++),quadCoordinates.get(i++));
cerc.controlDeltaX=(int)Math.round(p.x - prevPoint.x);
cerc.controlDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
p=new Point(quadCoordinates.get(i++),quadCoordinates.get(i++));
cerc.anchorDeltaX=(int)Math.round(p.x - prevPoint.x);
cerc.anchorDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=p;
newRecords.add(cerc);
}
break;
default :
Logger.getLogger(ShapeImporter.class.getName()).log(Level.WARNING,""String_Node_Str"",command);
return;
}
x0=x;
y0=y;
}
applyStyleGradients(SHAPERECORD.getBounds(newRecords),scrStyle,transform2,shapeNum,style);
shapes.shapeRecords.addAll(newRecords);
}","private void processCommands(int shapeNum,SHAPEWITHSTYLE shapes,List<PathCommand> commands,Matrix transform,SvgStyle style){
  Matrix transform2=transform.preConcatenate(Matrix.getScaleInstance(SWF.unitDivisor));
  Point prevPoint=new Point(0,0);
  Point startPoint=prevPoint;
  double x0=0;
  double y0=0;
  StyleChangeRecord scrStyle=getStyleChangeRecord(shapeNum,style);
  int fillStyle=scrStyle.fillStyle1;
  int lineStyle=scrStyle.lineStyle;
  scrStyle.stateFillStyle0=true;
  scrStyle.stateFillStyle1=true;
  scrStyle.stateLineStyle=true;
  scrStyle.fillStyle0=0;
  scrStyle.fillStyle1=0;
  scrStyle.lineStyle=0;
  List<SHAPERECORD> newRecords=new ArrayList<>();
  newRecords.add(scrStyle);
  LINESTYLE lineStyleObj=scrStyle.lineStyles.lineStyles.length < 1 ? null : scrStyle.lineStyles.lineStyles[0];
  LINESTYLE2 lineStyle2Obj=null;
  if (lineStyleObj instanceof LINESTYLE2) {
    lineStyle2Obj=(LINESTYLE2)lineStyleObj;
    lineStyle2Obj.noClose=true;
  }
  for (  PathCommand command : commands) {
    double x=x0;
    double y=y0;
    Point p;
    boolean isRelative=Character.isLowerCase(command.command);
    if (isRelative) {
      throw new Error(""String_Node_Str"");
    }
    char cmd=command.command;
switch (cmd) {
case 'M':
      StyleChangeRecord scr=new StyleChangeRecord();
    if (fillStyle != 0) {
      scr.stateFillStyle1=true;
      scr.fillStyle1=fillStyle;
    }
  if (lineStyle != 0) {
    scr.lineStyle=lineStyle;
    scr.stateLineStyle=true;
  }
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
scr.moveDeltaX=(int)Math.round(p.x);
scr.moveDeltaY=(int)Math.round(p.y);
prevPoint=new Point(scr.moveDeltaX,scr.moveDeltaY);
scr.stateMoveTo=true;
newRecords.add(scr);
startPoint=prevPoint;
break;
case 'Z':
StraightEdgeRecord serz=new StraightEdgeRecord();
p=startPoint;
serz.deltaX=(int)Math.round(p.x - prevPoint.x);
serz.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + serz.deltaX,prevPoint.y + serz.deltaY);
serz.generalLineFlag=true;
newRecords.add(serz);
if (lineStyle2Obj != null) {
lineStyle2Obj.noClose=false;
}
break;
case 'L':
StraightEdgeRecord serl=new StraightEdgeRecord();
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
serl.deltaX=(int)Math.round(p.x - prevPoint.x);
serl.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + serl.deltaX,prevPoint.y + serl.deltaY);
serl.generalLineFlag=true;
serl.simplify();
newRecords.add(serl);
break;
case 'H':
StraightEdgeRecord serh=new StraightEdgeRecord();
x=command.params[0];
p=transform2.transform(x,y);
serh.deltaX=(int)Math.round(p.x - prevPoint.x);
prevPoint=new Point(prevPoint.x + serh.deltaX,prevPoint.y);
newRecords.add(serh);
break;
case 'V':
StraightEdgeRecord serv=new StraightEdgeRecord();
y=command.params[0];
p=transform2.transform(x,y);
serv.deltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x,prevPoint.y + serv.deltaY);
serv.vertLineFlag=true;
newRecords.add(serv);
break;
case 'Q':
CurvedEdgeRecord cer=new CurvedEdgeRecord();
x=command.params[0];
y=command.params[1];
p=transform2.transform(x,y);
cer.controlDeltaX=(int)Math.round(p.x - prevPoint.x);
cer.controlDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + cer.controlDeltaX,prevPoint.y + cer.controlDeltaY);
x=command.params[2];
y=command.params[3];
p=transform2.transform(x,y);
cer.anchorDeltaX=(int)Math.round(p.x - prevPoint.x);
cer.anchorDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + cer.anchorDeltaX,prevPoint.y + cer.anchorDeltaY);
newRecords.add(cer);
break;
case 'C':
showWarning(""String_Node_Str"",""String_Node_Str"");
Point pStart=prevPoint;
Point pControl1;
x=command.params[0];
y=command.params[1];
pControl1=transform2.transform(x,y);
x=command.params[2];
y=command.params[3];
Point pControl2=transform2.transform(x,y);
x=command.params[4];
y=command.params[5];
p=transform2.transform(x,y);
List<Double> quadCoordinates=new CubicToQuad().cubicToQuad(pStart.x,pStart.y,pControl1.x,pControl1.y,pControl2.x,pControl2.y,p.x,p.y,1);
for (int i=2; i < quadCoordinates.size(); ) {
CurvedEdgeRecord cerc=new CurvedEdgeRecord();
p=new Point(quadCoordinates.get(i++),quadCoordinates.get(i++));
cerc.controlDeltaX=(int)Math.round(p.x - prevPoint.x);
cerc.controlDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + cerc.controlDeltaX,prevPoint.y + cerc.controlDeltaY);
p=new Point(quadCoordinates.get(i++),quadCoordinates.get(i++));
cerc.anchorDeltaX=(int)Math.round(p.x - prevPoint.x);
cerc.anchorDeltaY=(int)Math.round(p.y - prevPoint.y);
prevPoint=new Point(prevPoint.x + cerc.anchorDeltaX,prevPoint.y + cerc.anchorDeltaY);
newRecords.add(cerc);
}
break;
default :
Logger.getLogger(ShapeImporter.class.getName()).log(Level.WARNING,""String_Node_Str"",command);
return;
}
x0=x;
y0=y;
}
applyStyleGradients(SHAPERECORD.getBounds(newRecords),scrStyle,transform2,shapeNum,style);
shapes.shapeRecords.addAll(newRecords);
}",0.9237880253681608
61443,"public float getSwfFrameRate(int swfIndex){
  return headers.get(swfIndex).getFrameRate();
}","public float getSwfFrameRate(int swfIndex){
  return iggySwfs.get(swfIndex).getHdr().getFrameRate();
}",0.8865979381443299
61444,"public long getSwfYMax(int swfIndex){
  return headers.get(swfIndex).getYMax();
}","public long getSwfYMax(int swfIndex){
  return iggySwfs.get(swfIndex).getHdr().getYMax();
}",0.872093023255814
61445,"public long getSwfYMin(int swfIndex){
  return headers.get(swfIndex).getYMin();
}","public long getSwfYMin(int swfIndex){
  return iggySwfs.get(swfIndex).getHdr().getYMin();
}",0.872093023255814
61446,"public long getSwfXMax(int swfIndex){
  return headers.get(swfIndex).getXMax();
}","public long getSwfXMax(int swfIndex){
  return iggySwfs.get(swfIndex).getHdr().getXMax();
}",0.872093023255814
61447,"public long getSwfXMin(int swfIndex){
  return headers.get(swfIndex).getXMin();
}","public long getSwfXMin(int swfIndex){
  return iggySwfs.get(swfIndex).getHdr().getXMin();
}",0.872093023255814
61448,"public Tag importImage(ImageTag it,byte[] newData,int tagType) throws IOException {
  if (newData[0] == 'B' && newData[1] == 'M') {
    BufferedImage b=ImageHelper.read(newData);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    ImageHelper.write(b,ImageFormat.PNG,baos);
    newData=baos.toByteArray();
  }
  if (tagType == 0) {
    if (it instanceof DefineBitsTag) {
      tagType=DefineBitsTag.ID;
    }
 else {
      tagType=it.getId();
    }
  }
  if (it.getId() == tagType) {
    it.setImage(newData);
  }
 else {
    SWF swf=it.getSwf();
    ImageTag imageTag;
    ByteArrayRange range=it.getOriginalRange();
    int characterId=it.getCharacterId();
switch (tagType) {
case DefineBitsJPEG2Tag.ID:
{
        imageTag=new DefineBitsJPEG2Tag(swf,range,characterId,newData);
        break;
      }
case DefineBitsJPEG3Tag.ID:
{
      imageTag=new DefineBitsJPEG3Tag(swf,range,characterId,newData);
      break;
    }
case DefineBitsJPEG4Tag.ID:
{
    imageTag=new DefineBitsJPEG4Tag(swf,range,characterId,newData);
    break;
  }
case DefineBitsLosslessTag.ID:
{
  DefineBitsLosslessTag losslessTag=new DefineBitsLosslessTag(swf,range,characterId);
  losslessTag.setImage(newData);
  imageTag=losslessTag;
  break;
}
case DefineBitsLossless2Tag.ID:
{
DefineBitsLossless2Tag lossless2Tag=new DefineBitsLossless2Tag(swf,range,characterId);
lossless2Tag.setImage(newData);
imageTag=lossless2Tag;
break;
}
default :
throw new Error(""String_Node_Str"");
}
imageTag.setModified(true);
swf.replaceTag(it,imageTag);
swf.updateCharacters();
return imageTag;
}
return null;
}","public Tag importImage(ImageTag it,byte[] newData,int tagType) throws IOException {
  if (newData[0] == 'B' && newData[1] == 'M') {
    BufferedImage b=ImageHelper.read(newData);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    ImageHelper.write(b,ImageFormat.PNG,baos);
    newData=baos.toByteArray();
  }
  if (tagType == 0) {
    if (it instanceof DefineBitsTag) {
      tagType=DefineBitsJPEG2Tag.ID;
    }
 else {
      tagType=it.getId();
    }
  }
  if (it.getId() == tagType) {
    it.setImage(newData);
  }
 else {
    SWF swf=it.getSwf();
    ImageTag imageTag;
    ByteArrayRange range=it.getOriginalRange();
    int characterId=it.getCharacterId();
switch (tagType) {
case DefineBitsJPEG2Tag.ID:
{
        imageTag=new DefineBitsJPEG2Tag(swf,range,characterId,newData);
        break;
      }
case DefineBitsJPEG3Tag.ID:
{
      imageTag=new DefineBitsJPEG3Tag(swf,range,characterId,newData);
      break;
    }
case DefineBitsJPEG4Tag.ID:
{
    imageTag=new DefineBitsJPEG4Tag(swf,range,characterId,newData);
    break;
  }
case DefineBitsLosslessTag.ID:
{
  DefineBitsLosslessTag losslessTag=new DefineBitsLosslessTag(swf,range,characterId);
  losslessTag.setImage(newData);
  imageTag=losslessTag;
  break;
}
case DefineBitsLossless2Tag.ID:
{
DefineBitsLossless2Tag lossless2Tag=new DefineBitsLossless2Tag(swf,range,characterId);
lossless2Tag.setImage(newData);
imageTag=lossless2Tag;
break;
}
default :
throw new Error(""String_Node_Str"");
}
imageTag.setModified(true);
swf.replaceTag(it,imageTag);
swf.updateCharacters();
return imageTag;
}
return null;
}",0.8001263024944743
61449,"private void reloadChildren(){
  InGetVariable igv=Main.getDebugHandler().getVariable(parentId,thisVar.name,true);
  childs=new ArrayList<>();
  childTraits=new ArrayList<>();
  if (thisVar.vType != VariableType.FUNCTION || ((thisVar.flags & VariableFlags.HAS_GETTER) > 0)) {
    thisVar=igv.parent;
  }
  Variable curTrait=null;
  for (int i=0; i < igv.childs.size(); i++) {
    if (!isTraits(igv.childs.get(i))) {
      childs.add(igv.childs.get(i));
      childTraits.add(curTrait);
    }
 else {
      curTrait=igv.childs.get(i);
    }
  }
}","private void reloadChildren(){
  childs=new ArrayList<>();
  childTraits=new ArrayList<>();
  InGetVariable igv=Main.getDebugHandler().getVariable(parentId,thisVar.name,true);
  if (thisVar.vType != VariableType.FUNCTION || ((thisVar.flags & VariableFlags.HAS_GETTER) > 0)) {
    if (parentId != 0) {
      thisVar=igv.parent;
    }
  }
  Variable curTrait=null;
  for (int i=0; i < igv.childs.size(); i++) {
    if (!isTraits(igv.childs.get(i))) {
      childs.add(igv.childs.get(i));
      childTraits.add(curTrait);
    }
 else {
      curTrait=igv.childs.get(i);
    }
  }
}",0.8388245770258237
61450,"private void convertMedia(SWF swf,Map<Integer,String> characterVariables,Map<Integer,String> characterClasses,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,HashMap<Integer,CharacterTag> characters,HashMap<String,byte[]> files,HashMap<String,byte[]> datfiles,FLAVersion flaVersion,XFLXmlWriter writer) throws XMLStreamException {
  boolean hasMedia=false;
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if (symbol instanceof ImageTag || symbol instanceof SoundStreamHeadTypeTag || symbol instanceof DefineSoundTag|| symbol instanceof DefineVideoStreamTag) {
      hasMedia=true;
    }
  }
  if (!hasMedia) {
    return;
  }
  int mediaCount=0;
  writer.writeStartElement(""String_Node_Str"");
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if (symbol instanceof ImageTag) {
      ImageTag imageTag=(ImageTag)symbol;
      boolean allowSmoothing=false;
      looptags:       for (      Tag tag : swf.getTags()) {
        if (tag instanceof ShapeTag) {
          Set<Integer> needed=new HashSet<>();
          tag.getNeededCharacters(needed);
          ShapeTag sht=(ShapeTag)tag;
          if (needed.contains(imageTag.getCharacterId())) {
            List<FILLSTYLE> fs=new ArrayList<>();
            SHAPEWITHSTYLE s=sht.getShapes();
            for (            FILLSTYLE f : s.fillStyles.fillStyles) {
              fs.add(f);
            }
            for (            SHAPERECORD r : s.shapeRecords) {
              if (r instanceof StyleChangeRecord) {
                StyleChangeRecord scr=(StyleChangeRecord)r;
                if (scr.stateNewStyles) {
                  for (                  FILLSTYLE f : scr.fillStyles.fillStyles) {
                    fs.add(f);
                  }
                }
              }
            }
            for (            FILLSTYLE f : fs) {
              if (Arrays.asList(FILLSTYLE.REPEATING_BITMAP,FILLSTYLE.CLIPPED_BITMAP,FILLSTYLE.NON_SMOOTHED_REPEATING_BITMAP,FILLSTYLE.NON_SMOOTHED_CLIPPED_BITMAP).contains(f.fillStyleType) && f.bitmapId == imageTag.getCharacterId()) {
                allowSmoothing=f.fillStyleType == FILLSTYLE.CLIPPED_BITMAP || f.fillStyleType == FILLSTYLE.REPEATING_BITMAP;
                break looptags;
              }
            }
          }
        }
      }
      byte[] imageBytes=Helper.readStream(imageTag.getImageData());
      SerializableImage image=imageTag.getImageCached();
      ImageFormat format=imageTag.getImageFormat();
      String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + imageTag.getImageFormat().getExtension();
      files.put(symbolFile,imageBytes);
      writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(imageBytes.length)});
      if (allowSmoothing) {
        writer.writeAttribute(""String_Node_Str"",true);
      }
switch (format) {
case PNG:
case GIF:
        if (imageTag.getOriginalImageFormat() != ImageFormat.JPEG) {
          writer.writeAttribute(""String_Node_Str"",false);
          writer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
        }
      writer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    break;
case JPEG:
  writer.writeAttribute(""String_Node_Str"",true);
break;
}
if (characterClasses.containsKey(symbol.getCharacterId())) {
writer.writeAttribute(""String_Node_Str"",true);
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
writer.writeAttribute(""String_Node_Str"",50);
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + (mediaCount + 1) + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str"");
writer.writeAttribute(""String_Node_Str"",image.getWidth());
writer.writeAttribute(""String_Node_Str"",image.getHeight());
writer.writeEndElement();
mediaCount++;
}
 else if ((symbol instanceof SoundStreamHeadTypeTag) || (symbol instanceof DefineSoundTag)) {
int soundFormat=0;
int soundRate=0;
boolean soundType=false;
boolean soundSize=false;
long soundSampleCount=0;
byte[] soundData=SWFInputStream.BYTE_ARRAY_EMPTY;
int[] rateMap={5,11,22,44};
String exportFormat=""String_Node_Str"";
if (symbol instanceof SoundStreamHeadTypeTag) {
SoundStreamHeadTypeTag sstream=(SoundStreamHeadTypeTag)symbol;
soundFormat=sstream.getSoundFormatId();
soundRate=sstream.getSoundRate();
soundType=sstream.getSoundType();
soundSize=sstream.getSoundSize();
soundSampleCount=sstream.getSoundSampleCount();
boolean found=false;
for (Tag t : tags) {
if (found && (t instanceof SoundStreamBlockTag)) {
  SoundStreamBlockTag bl=(SoundStreamBlockTag)t;
  soundData=bl.streamSoundData.getRangeData();
  break;
}
if (t == symbol) {
  found=true;
}
}
}
 else if (symbol instanceof DefineSoundTag) {
DefineSoundTag sound=(DefineSoundTag)symbol;
soundFormat=sound.soundFormat;
soundRate=sound.soundRate;
soundType=sound.soundType;
soundData=sound.soundData.getRangeData();
soundSize=sound.soundSize;
soundSampleCount=sound.soundSampleCount;
}
int format=0;
int bits=0;
if ((soundFormat == SoundFormat.FORMAT_ADPCM) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_NATIVE_ENDIAN)) {
exportFormat=""String_Node_Str"";
if (soundType) {
format+=1;
}
switch (soundRate) {
case 0:
format+=2;
break;
case 1:
format+=6;
break;
case 2:
format+=10;
break;
case 3:
format+=14;
break;
}
}
if (soundFormat == SoundFormat.FORMAT_SPEEX) {
bits=18;
}
if (soundFormat == SoundFormat.FORMAT_ADPCM) {
exportFormat=""String_Node_Str"";
try {
SWFInputStream sis=new SWFInputStream(swf,soundData);
int adpcmCodeSize=(int)sis.readUB(2,""String_Node_Str"");
bits=2 + adpcmCodeSize;
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
if (soundFormat == SoundFormat.FORMAT_MP3) {
exportFormat=""String_Node_Str"";
if (!soundType) {
format+=1;
}
format+=4;
try {
MP3SOUNDDATA s=new MP3SOUNDDATA(new SWFInputStream(swf,soundData),false);
MP3FRAME frame=s.frames.get(0);
int bitRate=frame.getBitRate();
switch (bitRate) {
case 8:
bits=6;
break;
case 16:
bits=7;
break;
case 20:
bits=8;
break;
case 24:
bits=9;
break;
case 32:
bits=10;
break;
case 48:
bits=11;
break;
case 56:
bits=12;
break;
case 64:
bits=13;
break;
case 80:
bits=14;
break;
case 112:
bits=15;
break;
case 128:
bits=16;
break;
case 160:
bits=17;
break;
}
}
 catch (IOException|ArrayIndexOutOfBoundsException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
SoundTag st=(SoundTag)symbol;
SoundFormat fmt=st.getSoundFormat();
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new SoundExporter().exportSound(st,SoundExportMode.MP3_WAV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ exportFormat;
files.put(symbolFile,data);
writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(data.length)});
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",rateMap[soundRate] + ""String_Node_Str"" + ""String_Node_Str""+ (soundSize ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (soundType ? ""String_Node_Str"" : ""String_Node_Str""));
writer.writeAttribute(""String_Node_Str"",format);
writer.writeAttribute(""String_Node_Str"",bits);
writer.writeAttribute(""String_Node_Str"",soundSampleCount);
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterVariables.get(symbol.getCharacterId()));
}
if (linkageExportForAS) {
writer.writeAttribute(""String_Node_Str"",true);
}
writer.writeEndElement();
mediaCount++;
}
 else if (symbol instanceof DefineVideoStreamTag) {
DefineVideoStreamTag video=(DefineVideoStreamTag)symbol;
String videoType=""String_Node_Str"";
switch (video.codecID) {
case 2:
videoType=""String_Node_Str"";
break;
case 3:
videoType=""String_Node_Str"";
break;
case 4:
videoType=""String_Node_Str"";
break;
case 5:
videoType=""String_Node_Str"";
break;
}
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new MovieExporter().exportMovie(video,MovieExportMode.FLV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ ""String_Node_Str"";
if (data.length == 0) {
long ts=getTimestamp(swf);
String datFileName=""String_Node_Str"" + (datfiles.size() + 1) + ""String_Node_Str""+ ts+ ""String_Node_Str"";
writer.writeEmptyElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",""String_Node_Str"" + symbolFile,""String_Node_Str"",Long.toString(ts),""String_Node_Str"",datFileName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
datfiles.put(datFileName,new byte[]{(byte)0x03,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xA0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x78,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x59,(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xFF,(byte)0xFE,(byte)0xFF,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00});
}
 else {
files.put(symbolFile,data);
writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(data.length)});
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",videoType);
writer.writeAttribute(""String_Node_Str"",(int)swf.frameRate);
writer.writeAttribute(""String_Node_Str"",video.width);
writer.writeAttribute(""String_Node_Str"",video.height);
double len=(double)video.numFrames / swf.frameRate;
writer.writeAttribute(""String_Node_Str"",len);
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterVariables.get(symbol.getCharacterId()));
}
if (linkageExportForAS) {
writer.writeAttribute(""String_Node_Str"",true);
}
writer.writeEndElement();
}
mediaCount++;
}
}
writer.writeEndElement();
}","private void convertMedia(SWF swf,Map<Integer,String> characterVariables,Map<Integer,String> characterClasses,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,HashMap<Integer,CharacterTag> characters,HashMap<String,byte[]> files,HashMap<String,byte[]> datfiles,FLAVersion flaVersion,XFLXmlWriter writer) throws XMLStreamException {
  boolean hasMedia=false;
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if (symbol instanceof ImageTag || symbol instanceof SoundStreamHeadTypeTag || symbol instanceof DefineSoundTag|| symbol instanceof DefineVideoStreamTag) {
      hasMedia=true;
    }
  }
  if (!hasMedia) {
    return;
  }
  int mediaCount=0;
  writer.writeStartElement(""String_Node_Str"");
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if (symbol instanceof ImageTag) {
      ImageTag imageTag=(ImageTag)symbol;
      boolean allowSmoothing=false;
      looptags:       for (      Tag tag : swf.getTags()) {
        if (tag instanceof ShapeTag) {
          Set<Integer> needed=new HashSet<>();
          tag.getNeededCharacters(needed);
          ShapeTag sht=(ShapeTag)tag;
          if (needed.contains(imageTag.getCharacterId())) {
            List<FILLSTYLE> fs=new ArrayList<>();
            SHAPEWITHSTYLE s=sht.getShapes();
            for (            FILLSTYLE f : s.fillStyles.fillStyles) {
              fs.add(f);
            }
            for (            SHAPERECORD r : s.shapeRecords) {
              if (r instanceof StyleChangeRecord) {
                StyleChangeRecord scr=(StyleChangeRecord)r;
                if (scr.stateNewStyles) {
                  for (                  FILLSTYLE f : scr.fillStyles.fillStyles) {
                    fs.add(f);
                  }
                }
              }
            }
            for (            FILLSTYLE f : fs) {
              if (Arrays.asList(FILLSTYLE.REPEATING_BITMAP,FILLSTYLE.CLIPPED_BITMAP,FILLSTYLE.NON_SMOOTHED_REPEATING_BITMAP,FILLSTYLE.NON_SMOOTHED_CLIPPED_BITMAP).contains(f.fillStyleType) && f.bitmapId == imageTag.getCharacterId()) {
                allowSmoothing=f.fillStyleType == FILLSTYLE.CLIPPED_BITMAP || f.fillStyleType == FILLSTYLE.REPEATING_BITMAP;
                break looptags;
              }
            }
          }
        }
      }
      byte[] imageBytes=Helper.readStream(imageTag.getImageData());
      SerializableImage image=imageTag.getImageCached();
      ImageFormat format=imageTag.getImageFormat();
      String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + imageTag.getImageFormat().getExtension();
      files.put(symbolFile,imageBytes);
      writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(imageBytes.length)});
      if (allowSmoothing) {
        writer.writeAttribute(""String_Node_Str"",true);
      }
switch (format) {
case PNG:
case GIF:
        if (imageTag.getOriginalImageFormat() != ImageFormat.JPEG) {
          writer.writeAttribute(""String_Node_Str"",false);
          writer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
        }
      writer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    break;
case JPEG:
  writer.writeAttribute(""String_Node_Str"",true);
break;
}
if (characterClasses.containsKey(symbol.getCharacterId())) {
writer.writeAttribute(""String_Node_Str"",true);
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
writer.writeAttribute(""String_Node_Str"",50);
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + (mediaCount + 1) + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str"");
writer.writeAttribute(""String_Node_Str"",image.getWidth());
writer.writeAttribute(""String_Node_Str"",image.getHeight());
writer.writeEndElement();
mediaCount++;
}
 else if ((symbol instanceof SoundStreamHeadTypeTag) || (symbol instanceof DefineSoundTag)) {
int soundFormat=0;
int soundRate=0;
boolean soundType=false;
boolean soundSize=false;
long soundSampleCount=0;
byte[] soundData=SWFInputStream.BYTE_ARRAY_EMPTY;
int[] rateMap={5,11,22,44};
String exportFormat=""String_Node_Str"";
if (symbol instanceof SoundStreamHeadTypeTag) {
SoundStreamHeadTypeTag sstream=(SoundStreamHeadTypeTag)symbol;
soundFormat=sstream.getSoundFormatId();
soundRate=sstream.getSoundRate();
soundType=sstream.getSoundType();
soundSize=sstream.getSoundSize();
soundSampleCount=sstream.getSoundSampleCount();
boolean found=false;
for (Tag t : tags) {
if (found && (t instanceof SoundStreamBlockTag)) {
  SoundStreamBlockTag bl=(SoundStreamBlockTag)t;
  soundData=bl.streamSoundData.getRangeData();
  break;
}
if (t == symbol) {
  found=true;
}
}
}
 else if (symbol instanceof DefineSoundTag) {
DefineSoundTag sound=(DefineSoundTag)symbol;
soundFormat=sound.soundFormat;
soundRate=sound.soundRate;
soundType=sound.soundType;
soundData=sound.soundData.getRangeData();
soundSize=sound.soundSize;
soundSampleCount=sound.soundSampleCount;
}
int format=0;
int bits=0;
if ((soundFormat == SoundFormat.FORMAT_ADPCM) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_NATIVE_ENDIAN)) {
exportFormat=""String_Node_Str"";
if (soundType) {
format+=1;
}
switch (soundRate) {
case 0:
format+=2;
break;
case 1:
format+=6;
break;
case 2:
format+=10;
break;
case 3:
format+=14;
break;
}
}
if (soundFormat == SoundFormat.FORMAT_SPEEX) {
bits=18;
}
if (soundFormat == SoundFormat.FORMAT_ADPCM) {
exportFormat=""String_Node_Str"";
try {
SWFInputStream sis=new SWFInputStream(swf,soundData);
int adpcmCodeSize=(int)sis.readUB(2,""String_Node_Str"");
bits=2 + adpcmCodeSize;
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
if (soundFormat == SoundFormat.FORMAT_MP3) {
exportFormat=""String_Node_Str"";
if (!soundType) {
format+=1;
}
format+=4;
try {
MP3SOUNDDATA s=new MP3SOUNDDATA(new SWFInputStream(swf,soundData),false);
MP3FRAME frame=s.frames.get(0);
int bitRate=frame.getBitRate();
switch (bitRate) {
case 8:
bits=6;
break;
case 16:
bits=7;
break;
case 20:
bits=8;
break;
case 24:
bits=9;
break;
case 32:
bits=10;
break;
case 48:
bits=11;
break;
case 56:
bits=12;
break;
case 64:
bits=13;
break;
case 80:
bits=14;
break;
case 112:
bits=15;
break;
case 128:
bits=16;
break;
case 160:
bits=17;
break;
}
}
 catch (IOException|IndexOutOfBoundsException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
SoundTag st=(SoundTag)symbol;
SoundFormat fmt=st.getSoundFormat();
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new SoundExporter().exportSound(st,SoundExportMode.MP3_WAV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ exportFormat;
files.put(symbolFile,data);
writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(data.length)});
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",rateMap[soundRate] + ""String_Node_Str"" + ""String_Node_Str""+ (soundSize ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (soundType ? ""String_Node_Str"" : ""String_Node_Str""));
writer.writeAttribute(""String_Node_Str"",format);
writer.writeAttribute(""String_Node_Str"",bits);
writer.writeAttribute(""String_Node_Str"",soundSampleCount);
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterVariables.get(symbol.getCharacterId()));
}
if (linkageExportForAS) {
writer.writeAttribute(""String_Node_Str"",true);
}
writer.writeEndElement();
mediaCount++;
}
 else if (symbol instanceof DefineVideoStreamTag) {
DefineVideoStreamTag video=(DefineVideoStreamTag)symbol;
String videoType=""String_Node_Str"";
switch (video.codecID) {
case 2:
videoType=""String_Node_Str"";
break;
case 3:
videoType=""String_Node_Str"";
break;
case 4:
videoType=""String_Node_Str"";
break;
case 5:
videoType=""String_Node_Str"";
break;
}
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new MovieExporter().exportMovie(video,MovieExportMode.FLV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ ""String_Node_Str"";
if (data.length == 0) {
long ts=getTimestamp(swf);
String datFileName=""String_Node_Str"" + (datfiles.size() + 1) + ""String_Node_Str""+ ts+ ""String_Node_Str"";
writer.writeEmptyElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",""String_Node_Str"" + symbolFile,""String_Node_Str"",Long.toString(ts),""String_Node_Str"",datFileName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
datfiles.put(datFileName,new byte[]{(byte)0x03,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xA0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x78,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x59,(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xFF,(byte)0xFE,(byte)0xFF,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00});
}
 else {
files.put(symbolFile,data);
writer.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",symbolFile,""String_Node_Str"",Long.toString(getTimestamp(swf)),""String_Node_Str"",Integer.toString(data.length)});
writer.writeAttribute(""String_Node_Str"",symbolFile);
writer.writeAttribute(""String_Node_Str"",videoType);
writer.writeAttribute(""String_Node_Str"",(int)swf.frameRate);
writer.writeAttribute(""String_Node_Str"",video.width);
writer.writeAttribute(""String_Node_Str"",video.height);
double len=(double)video.numFrames / swf.frameRate;
writer.writeAttribute(""String_Node_Str"",len);
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterClasses.get(symbol.getCharacterId()));
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
writer.writeAttribute(""String_Node_Str"",characterVariables.get(symbol.getCharacterId()));
}
if (linkageExportForAS) {
writer.writeAttribute(""String_Node_Str"",true);
}
writer.writeEndElement();
}
mediaCount++;
}
}
writer.writeEndElement();
}",0.9997802487584054
61451,"public void exportXfl(AbortRetryIgnoreHandler handler,String outfile,String swfName,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion version,XFLExportSettings settings) throws IOException, InterruptedException {
  XFLConverter.convertSWF(handler,this,swfName,outfile,settings,generator,generatorVerName,generatorVersion,parallel,version);
  clearAllCache();
}","public void exportXfl(AbortRetryIgnoreHandler handler,String outfile,String swfName,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion version,XFLExportSettings settings) throws IOException, InterruptedException {
  new XFLConverter().convertSWF(handler,this,swfName,outfile,settings,generator,generatorVerName,generatorVersion,parallel,version);
  clearAllCache();
}",0.9926108374384236
61452,"public static void convertSWF(AbortRetryIgnoreHandler handler,SWF swf,String swfFileName,String outfile,XFLExportSettings settings,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion flaVersion) throws IOException, InterruptedException {
  FileAttributesTag fa=swf.getFileAttributes();
  boolean useAS3=false;
  boolean useNetwork=false;
  if (fa != null) {
    useAS3=fa.actionScript3;
    useNetwork=fa.useNetwork;
  }
  if (!useAS3 && flaVersion.minASVersion() > 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + flaVersion + ""String_Node_Str"");
  }
  File file=new File(outfile);
  File outDir=file.getParentFile();
  Path.createDirectorySafe(outDir);
  StringBuilder domDocument=new StringBuilder();
  String baseName=swfFileName;
  File f=new File(baseName);
  baseName=f.getName();
  if (baseName.contains(""String_Node_Str"")) {
    baseName=baseName.substring(0,baseName.lastIndexOf('.'));
  }
  final HashMap<String,byte[]> files=new HashMap<>();
  final HashMap<String,byte[]> datfiles=new HashMap<>();
  HashMap<Integer,CharacterTag> characters=getCharacters(swf.getTags());
  List<Integer> nonLibraryShapes=getNonLibraryShapes(swf.getTags(),characters);
  Map<Integer,String> characterClasses=getCharacterClasses(swf.getTags());
  Map<Integer,String> characterVariables=getCharacterVariables(swf.getTags());
  String backgroundColor=""String_Node_Str"";
  SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
  if (setBgColorTag != null) {
    backgroundColor=setBgColorTag.backgroundColor.toHexRGB();
  }
  domDocument.append(""String_Node_Str"").append(flaVersion.xflVersion()).append(""String_Node_Str"").append(generator).append(""String_Node_Str"").append(generatorVerName).append(""String_Node_Str"").append(generatorVersion).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append(backgroundColor).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append((int)swf.frameRate).append(""String_Node_Str"");
  double width=twipToPixel(swf.displayRect.getWidth());
  double height=twipToPixel(swf.displayRect.getHeight());
  if (Double.compare(width,550) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(width)).append(""String_Node_Str"");
  }
  if (Double.compare(height,400) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(height)).append(""String_Node_Str"");
  }
  domDocument.append(""String_Node_Str"");
  convertFonts(swf.getTags(),domDocument);
  convertLibrary(swf,characterVariables,characterClasses,nonLibraryShapes,backgroundColor,swf.getTags(),characters,files,datfiles,flaVersion,domDocument);
  domDocument.append(""String_Node_Str"");
  domDocument.append(convertTimeline(0,nonLibraryShapes,backgroundColor,swf.getTags(),swf.getTags(),characters,""String_Node_Str"",flaVersion,files));
  domDocument.append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"");
  String domDocumentStr=prettyFormatXML(domDocument.toString());
  if (settings.exportScript) {
    for (    Tag t : swf.getTags()) {
      if (t instanceof DoInitActionTag) {
        DoInitActionTag dia=(DoInitActionTag)t;
        int chid=dia.getCharacterId();
        if (characters.containsKey(chid)) {
          if (characters.get(chid) instanceof DefineSpriteTag) {
            DefineSpriteTag sprite=(DefineSpriteTag)characters.get(chid);
            if (sprite.getTags().isEmpty()) {
              String data=convertActionScript(dia);
              String expName=dia.getSwf().getExportName(dia.spriteId);
              expName=expName != null ? expName : ""String_Node_Str"";
              String expPath=expName;
              final String prefix=""String_Node_Str"";
              if (expPath.startsWith(prefix)) {
                expPath=expPath.substring(prefix.length());
              }
              String expDir=""String_Node_Str"";
              if (expPath.contains(""String_Node_Str"")) {
                expDir=expPath.substring(0,expPath.lastIndexOf('.'));
                expDir=expDir.replace(""String_Node_Str"",File.separator);
              }
              expPath=expPath.replace(""String_Node_Str"",File.separator);
              File cdir=new File(outDir.getAbsolutePath() + File.separator + expDir);
              Path.createDirectorySafe(cdir);
              writeFile(handler,Utf8Helper.getBytes(data),outDir.getAbsolutePath() + File.separator + expPath+ ""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  int flaSwfVersion=swf.version > flaVersion.maxSwfVersion() ? flaVersion.maxSwfVersion() : swf.version;
  boolean greaterThanCC=flaVersion.ordinal() >= FLAVersion.CC.ordinal();
  XFLXmlWriter psXml=new XFLXmlWriter();
  try {
    psXml.writeStartElement(""String_Node_Str"");
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",flaSwfVersion);
    psXml.writeElementValue(""String_Node_Str"",FLAVersion.swfVersionToPlayer(flaSwfVersion));
    psXml.writeElementValue(""String_Node_Str"",useAS3 ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",swf.compression == SWFCompression.NONE ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",swf.compression == SWFCompression.LZMA ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",useNetwork ? 1 : 0);
    psXml.writeElementValue(""String_Node_Str"",characterClasses.containsKey(0) ? characterClasses.get(0) : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    if (greaterThanCC) {
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
      psXml.writeElementValueRaw(""String_Node_Str"",Helper.newLine + ""String_Node_Str"");
    }
 else {
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEmptyElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
    }
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    if (!greaterThanCC) {
      psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",width);
      psXml.writeElementValue(""String_Node_Str"",height);
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
    }
    psXml.writeEndElement();
    psXml.writeEndElement();
  }
 catch (  XMLStreamException ex) {
    Logger.getLogger(XFLConverter.class.getName()).log(Level.SEVERE,null,ex);
  }
  String publishSettingsStr=psXml.toString();
  if (settings.compressed) {
    final String domDocumentF=domDocumentStr;
    final String publishSettingsF=publishSettingsStr;
    final String outfileF=outfile;
    new RetryTask(() -> {
      try (ZipOutputStream out=new ZipOutputStream(new FileOutputStream(outfileF))){
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(domDocumentF));
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(publishSettingsF));
        for (        String fileName : files.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(files.get(fileName));
        }
        for (        String fileName : datfiles.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(datfiles.get(fileName));
        }
      }
     }
,handler).run();
  }
 else {
    Path.createDirectorySafe(outDir);
    writeFile(handler,Utf8Helper.getBytes(domDocumentStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    writeFile(handler,Utf8Helper.getBytes(publishSettingsStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    File libraryDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    libraryDir.mkdir();
    File binDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    binDir.mkdir();
    for (    String fileName : files.keySet()) {
      writeFile(handler,files.get(fileName),libraryDir.getAbsolutePath() + File.separator + fileName);
    }
    for (    String fileName : datfiles.keySet()) {
      writeFile(handler,datfiles.get(fileName),binDir.getAbsolutePath() + File.separator + fileName);
    }
    writeFile(handler,Utf8Helper.getBytes(""String_Node_Str""),outfile);
  }
  if (useAS3 && settings.exportScript) {
    try {
      ScriptExportSettings scriptExportSettings=new ScriptExportSettings(ScriptExportMode.AS,false);
      swf.exportActionScript(handler,Path.combine(outDir.getAbsolutePath(),""String_Node_Str""),scriptExportSettings,parallel,null);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}","public void convertSWF(AbortRetryIgnoreHandler handler,SWF swf,String swfFileName,String outfile,XFLExportSettings settings,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion flaVersion) throws IOException, InterruptedException {
  FileAttributesTag fa=swf.getFileAttributes();
  boolean useAS3=false;
  boolean useNetwork=false;
  if (fa != null) {
    useAS3=fa.actionScript3;
    useNetwork=fa.useNetwork;
  }
  if (!useAS3 && flaVersion.minASVersion() > 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + flaVersion + ""String_Node_Str"");
  }
  File file=new File(outfile);
  File outDir=file.getParentFile();
  Path.createDirectorySafe(outDir);
  StringBuilder domDocument=new StringBuilder();
  String baseName=swfFileName;
  File f=new File(baseName);
  baseName=f.getName();
  if (baseName.contains(""String_Node_Str"")) {
    baseName=baseName.substring(0,baseName.lastIndexOf('.'));
  }
  final HashMap<String,byte[]> files=new HashMap<>();
  final HashMap<String,byte[]> datfiles=new HashMap<>();
  HashMap<Integer,CharacterTag> characters=getCharacters(swf.getTags());
  List<Integer> nonLibraryShapes=getNonLibraryShapes(swf.getTags(),characters);
  Map<Integer,String> characterClasses=getCharacterClasses(swf.getTags());
  Map<Integer,String> characterVariables=getCharacterVariables(swf.getTags());
  String backgroundColor=""String_Node_Str"";
  SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
  if (setBgColorTag != null) {
    backgroundColor=setBgColorTag.backgroundColor.toHexRGB();
  }
  domDocument.append(""String_Node_Str"").append(flaVersion.xflVersion()).append(""String_Node_Str"").append(generator).append(""String_Node_Str"").append(generatorVerName).append(""String_Node_Str"").append(generatorVersion).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append(backgroundColor).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append((int)swf.frameRate).append(""String_Node_Str"");
  double width=twipToPixel(swf.displayRect.getWidth());
  double height=twipToPixel(swf.displayRect.getHeight());
  if (Double.compare(width,550) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(width)).append(""String_Node_Str"");
  }
  if (Double.compare(height,400) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(height)).append(""String_Node_Str"");
  }
  domDocument.append(""String_Node_Str"");
  convertFonts(swf.getTags(),domDocument);
  convertLibrary(swf,characterVariables,characterClasses,nonLibraryShapes,backgroundColor,swf.getTags(),characters,files,datfiles,flaVersion,domDocument);
  domDocument.append(""String_Node_Str"");
  domDocument.append(convertTimeline(0,nonLibraryShapes,backgroundColor,swf.getTags(),swf.getTags(),characters,""String_Node_Str"",flaVersion,files));
  domDocument.append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"");
  String domDocumentStr=prettyFormatXML(domDocument.toString());
  if (settings.exportScript) {
    for (    Tag t : swf.getTags()) {
      if (t instanceof DoInitActionTag) {
        DoInitActionTag dia=(DoInitActionTag)t;
        int chid=dia.getCharacterId();
        if (characters.containsKey(chid)) {
          if (characters.get(chid) instanceof DefineSpriteTag) {
            DefineSpriteTag sprite=(DefineSpriteTag)characters.get(chid);
            if (sprite.getTags().isEmpty()) {
              String data=convertActionScript(dia);
              String expName=dia.getSwf().getExportName(dia.spriteId);
              expName=expName != null ? expName : ""String_Node_Str"";
              String expPath=expName;
              final String prefix=""String_Node_Str"";
              if (expPath.startsWith(prefix)) {
                expPath=expPath.substring(prefix.length());
              }
              String expDir=""String_Node_Str"";
              if (expPath.contains(""String_Node_Str"")) {
                expDir=expPath.substring(0,expPath.lastIndexOf('.'));
                expDir=expDir.replace(""String_Node_Str"",File.separator);
              }
              expPath=expPath.replace(""String_Node_Str"",File.separator);
              File cdir=new File(outDir.getAbsolutePath() + File.separator + expDir);
              Path.createDirectorySafe(cdir);
              writeFile(handler,Utf8Helper.getBytes(data),outDir.getAbsolutePath() + File.separator + expPath+ ""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  int flaSwfVersion=swf.version > flaVersion.maxSwfVersion() ? flaVersion.maxSwfVersion() : swf.version;
  boolean greaterThanCC=flaVersion.ordinal() >= FLAVersion.CC.ordinal();
  XFLXmlWriter psXml=new XFLXmlWriter();
  try {
    psXml.writeStartElement(""String_Node_Str"");
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",baseName + ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",flaSwfVersion);
    psXml.writeElementValue(""String_Node_Str"",FLAVersion.swfVersionToPlayer(flaSwfVersion));
    psXml.writeElementValue(""String_Node_Str"",useAS3 ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",swf.compression == SWFCompression.NONE ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",swf.compression == SWFCompression.LZMA ? ""String_Node_Str"" : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",useNetwork ? 1 : 0);
    psXml.writeElementValue(""String_Node_Str"",characterClasses.containsKey(0) ? characterClasses.get(0) : ""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    if (greaterThanCC) {
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
      psXml.writeElementValueRaw(""String_Node_Str"",Helper.newLine + ""String_Node_Str"");
    }
 else {
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeStartElement(""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEmptyElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
      psXml.writeEndElement();
    }
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    psXml.writeElementValue(""String_Node_Str"",width);
    psXml.writeElementValue(""String_Node_Str"",height);
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
    psXml.writeEndElement();
    if (!greaterThanCC) {
      psXml.writeStartElement(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
      psXml.writeElementValue(""String_Node_Str"",width);
      psXml.writeElementValue(""String_Node_Str"",height);
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeElementValue(""String_Node_Str"",""String_Node_Str"");
      psXml.writeEndElement();
    }
    psXml.writeEndElement();
    psXml.writeEndElement();
  }
 catch (  XMLStreamException ex) {
    Logger.getLogger(XFLConverter.class.getName()).log(Level.SEVERE,null,ex);
  }
  String publishSettingsStr=psXml.toString();
  if (settings.compressed) {
    final String domDocumentF=domDocumentStr;
    final String publishSettingsF=publishSettingsStr;
    final String outfileF=outfile;
    new RetryTask(() -> {
      try (ZipOutputStream out=new ZipOutputStream(new FileOutputStream(outfileF))){
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(domDocumentF));
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(publishSettingsF));
        for (        String fileName : files.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(files.get(fileName));
        }
        for (        String fileName : datfiles.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(datfiles.get(fileName));
        }
      }
     }
,handler).run();
  }
 else {
    Path.createDirectorySafe(outDir);
    writeFile(handler,Utf8Helper.getBytes(domDocumentStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    writeFile(handler,Utf8Helper.getBytes(publishSettingsStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    File libraryDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    libraryDir.mkdir();
    File binDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    binDir.mkdir();
    for (    String fileName : files.keySet()) {
      writeFile(handler,files.get(fileName),libraryDir.getAbsolutePath() + File.separator + fileName);
    }
    for (    String fileName : datfiles.keySet()) {
      writeFile(handler,datfiles.get(fileName),binDir.getAbsolutePath() + File.separator + fileName);
    }
    writeFile(handler,Utf8Helper.getBytes(""String_Node_Str""),outfile);
  }
  if (useAS3 && settings.exportScript) {
    try {
      ScriptExportSettings scriptExportSettings=new ScriptExportSettings(ScriptExportMode.AS,false);
      swf.exportActionScript(handler,Path.combine(outDir.getAbsolutePath(),""String_Node_Str""),scriptExportSettings,parallel,null);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}",0.9998429753920008
61453,"private static String randomOutlineColor(){
  RGB outlineColor=new RGB();
  do {
    outlineColor.red=random.nextInt(256);
    outlineColor.green=random.nextInt(256);
    outlineColor.blue=random.nextInt(256);
  }
 while ((outlineColor.red + outlineColor.green + outlineColor.blue) / 3 < 128);
  return outlineColor.toHexRGB();
}","private String randomOutlineColor(){
  RGB outlineColor=new RGB();
  do {
    outlineColor.red=random.nextInt(256);
    outlineColor.green=random.nextInt(256);
    outlineColor.blue=random.nextInt(256);
  }
 while ((outlineColor.red + outlineColor.green + outlineColor.blue) / 3 < 128);
  return outlineColor.toHexRGB();
}",0.989247311827957
61454,"private static void convertSoundLayer(int layerIndex,String backgroundColor,HashMap<Integer,CharacterTag> characters,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,HashMap<String,byte[]> files,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  StartSoundTag lastStartSound=null;
  SoundStreamHeadTypeTag lastSoundStreamHead=null;
  StartSoundTag startSound=null;
  SoundStreamHeadTypeTag soundStreamHead=null;
  int duration=1;
  int frame=0;
  for (  Tag t : timeLineTags) {
    if (t instanceof StartSoundTag) {
      startSound=(StartSoundTag)t;
      for (      Tag ta : tags) {
        if (ta instanceof DefineSoundTag) {
          DefineSoundTag s=(DefineSoundTag)ta;
          if (s.soundId == startSound.soundId) {
            if (!files.containsKey(""String_Node_Str"" + s.soundId + ""String_Node_Str""+ s.getExportFormat().toString().toLowerCase())) {
              startSound=null;
            }
            break;
          }
        }
      }
    }
    if (t instanceof SoundStreamHeadTypeTag) {
      soundStreamHead=(SoundStreamHeadTypeTag)t;
      if (!files.containsKey(""String_Node_Str"" + soundStreamHead.getCharacterId() + ""String_Node_Str""+ soundStreamHead.getExportFormat().toString().toLowerCase())) {
        soundStreamHead=null;
      }
    }
    if (t instanceof ShowFrameTag) {
      if (soundStreamHead != null || startSound != null) {
        if (lastSoundStreamHead != null || lastStartSound != null) {
          convertFrame(false,characters,tags,lastSoundStreamHead,lastStartSound,frame,duration,""String_Node_Str"",""String_Node_Str"",files,ret2);
        }
        frame+=duration;
        duration=1;
        lastSoundStreamHead=soundStreamHead;
        lastStartSound=startSound;
        soundStreamHead=null;
        startSound=null;
      }
 else {
        duration++;
      }
    }
  }
  if (lastSoundStreamHead != null || lastStartSound != null) {
    if (frame < 0) {
      frame=0;
      duration=1;
    }
    convertFrame(false,characters,tags,lastSoundStreamHead,lastStartSound,frame,duration,""String_Node_Str"",""String_Node_Str"",files,ret2);
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(layerIndex).append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"" + ""String_Node_Str"").append(ret2).append(""String_Node_Str"" + ""String_Node_Str"");
  }
}","private void convertSoundLayer(int layerIndex,String backgroundColor,HashMap<Integer,CharacterTag> characters,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,HashMap<String,byte[]> files,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  StartSoundTag lastStartSound=null;
  SoundStreamHeadTypeTag lastSoundStreamHead=null;
  StartSoundTag startSound=null;
  SoundStreamHeadTypeTag soundStreamHead=null;
  int duration=1;
  int frame=0;
  for (  Tag t : timeLineTags) {
    if (t instanceof StartSoundTag) {
      startSound=(StartSoundTag)t;
      for (      Tag ta : tags) {
        if (ta instanceof DefineSoundTag) {
          DefineSoundTag s=(DefineSoundTag)ta;
          if (s.soundId == startSound.soundId) {
            if (!files.containsKey(""String_Node_Str"" + s.soundId + ""String_Node_Str""+ s.getExportFormat().toString().toLowerCase())) {
              startSound=null;
            }
            break;
          }
        }
      }
    }
    if (t instanceof SoundStreamHeadTypeTag) {
      soundStreamHead=(SoundStreamHeadTypeTag)t;
      if (!files.containsKey(""String_Node_Str"" + soundStreamHead.getCharacterId() + ""String_Node_Str""+ soundStreamHead.getExportFormat().toString().toLowerCase())) {
        soundStreamHead=null;
      }
    }
    if (t instanceof ShowFrameTag) {
      if (soundStreamHead != null || startSound != null) {
        if (lastSoundStreamHead != null || lastStartSound != null) {
          convertFrame(false,characters,tags,lastSoundStreamHead,lastStartSound,frame,duration,""String_Node_Str"",""String_Node_Str"",files,ret2);
        }
        frame+=duration;
        duration=1;
        lastSoundStreamHead=soundStreamHead;
        lastStartSound=startSound;
        soundStreamHead=null;
        startSound=null;
      }
 else {
        duration++;
      }
    }
  }
  if (lastSoundStreamHead != null || lastStartSound != null) {
    if (frame < 0) {
      frame=0;
      duration=1;
    }
    convertFrame(false,characters,tags,lastSoundStreamHead,lastStartSound,frame,duration,""String_Node_Str"",""String_Node_Str"",files,ret2);
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(layerIndex).append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"" + ""String_Node_Str"").append(ret2).append(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9985045930356762
61455,"private static String convertTimeline(int spriteId,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,ReadOnlyTagList timelineTags,HashMap<Integer,CharacterTag> characters,String name,FLAVersion flaVersion,HashMap<String,byte[]> files){
  StringBuilder ret=new StringBuilder();
  ret.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  String labelsLayer=convertLabelsLayer(spriteId,tags,timelineTags,backgroundColor);
  ret.append(labelsLayer);
  String scriptLayer=convertActionScriptLayer(spriteId,tags,timelineTags,backgroundColor);
  ret.append(scriptLayer);
  int index=0;
  if (!labelsLayer.isEmpty()) {
    index++;
  }
  if (!scriptLayer.isEmpty()) {
    index++;
  }
  int layerCount=getLayerCount(timelineTags);
  Stack<Integer> parentLayers=new Stack<>();
  for (int d=layerCount; d >= 1; d--, index++) {
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getClipDepth() == d) {
          for (int m=po.getDepth(); m < po.getClipDepth(); m++) {
            parentLayers.push(index);
          }
          ret.append(""String_Node_Str"").append(index + 1).append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          convertFrames(""String_Node_Str"",""String_Node_Str"",nonLibraryShapes,tags,timelineTags,characters,po.getDepth(),flaVersion,files,ret);
          ret.append(""String_Node_Str"");
          index++;
          break;
        }
      }
    }
    boolean hasClipDepth=false;
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getDepth() == d) {
          if (po.getClipDepth() != -1) {
            hasClipDepth=true;
            break;
          }
        }
      }
    }
    if (hasClipDepth) {
      index--;
      continue;
    }
    int parentLayer=-1;
    if (!parentLayers.isEmpty()) {
      parentLayer=parentLayers.pop();
    }
    String layerPrev=""String_Node_Str"";
    layerPrev+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
    if (d == 1) {
      layerPrev+=""String_Node_Str"";
    }
    if (parentLayer != -1) {
      if (parentLayer != d) {
        layerPrev+=""String_Node_Str"" + (parentLayer) + ""String_Node_Str"";
      }
    }
    layerPrev+=""String_Node_Str"";
    String layerAfter=""String_Node_Str"";
    int prevLength=ret.length();
    convertFrames(layerPrev,layerAfter,nonLibraryShapes,tags,timelineTags,characters,d,flaVersion,files,ret);
    if (ret.length() == prevLength) {
      index--;
    }
  }
  int soundLayerIndex=layerCount;
  layerCount++;
  convertSoundLayer(soundLayerIndex,backgroundColor,characters,tags,timelineTags,files,ret);
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  return ret.toString();
}","private String convertTimeline(int spriteId,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,ReadOnlyTagList timelineTags,HashMap<Integer,CharacterTag> characters,String name,FLAVersion flaVersion,HashMap<String,byte[]> files){
  StringBuilder ret=new StringBuilder();
  ret.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  String labelsLayer=convertLabelsLayer(spriteId,tags,timelineTags,backgroundColor);
  ret.append(labelsLayer);
  String scriptLayer=convertActionScriptLayer(spriteId,tags,timelineTags,backgroundColor);
  ret.append(scriptLayer);
  int index=0;
  if (!labelsLayer.isEmpty()) {
    index++;
  }
  if (!scriptLayer.isEmpty()) {
    index++;
  }
  int layerCount=getLayerCount(timelineTags);
  Stack<Integer> parentLayers=new Stack<>();
  for (int d=layerCount; d >= 1; d--, index++) {
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getClipDepth() == d) {
          for (int m=po.getDepth(); m < po.getClipDepth(); m++) {
            parentLayers.push(index);
          }
          ret.append(""String_Node_Str"").append(index + 1).append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          convertFrames(""String_Node_Str"",""String_Node_Str"",nonLibraryShapes,tags,timelineTags,characters,po.getDepth(),flaVersion,files,ret);
          ret.append(""String_Node_Str"");
          index++;
          break;
        }
      }
    }
    boolean hasClipDepth=false;
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getDepth() == d) {
          if (po.getClipDepth() != -1) {
            hasClipDepth=true;
            break;
          }
        }
      }
    }
    if (hasClipDepth) {
      index--;
      continue;
    }
    int parentLayer=-1;
    if (!parentLayers.isEmpty()) {
      parentLayer=parentLayers.pop();
    }
    String layerPrev=""String_Node_Str"";
    layerPrev+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
    if (d == 1) {
      layerPrev+=""String_Node_Str"";
    }
    if (parentLayer != -1) {
      if (parentLayer != d) {
        layerPrev+=""String_Node_Str"" + (parentLayer) + ""String_Node_Str"";
      }
    }
    layerPrev+=""String_Node_Str"";
    String layerAfter=""String_Node_Str"";
    int prevLength=ret.length();
    convertFrames(layerPrev,layerAfter,nonLibraryShapes,tags,timelineTags,characters,d,flaVersion,files,ret);
    if (ret.length() == prevLength) {
      index--;
    }
  }
  int soundLayerIndex=layerCount;
  layerCount++;
  convertSoundLayer(soundLayerIndex,backgroundColor,characters,tags,timelineTags,files,ret);
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  return ret.toString();
}",0.9988354683081018
61456,"private static String convertActionScriptLayer(int spriteId,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,String backgroundColor){
  StringBuilder ret=new StringBuilder();
  String script=""String_Node_Str"";
  int duration=0;
  int frame=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      DoInitActionTag dia=(DoInitActionTag)t;
      if (dia.spriteId == spriteId) {
        script+=convertActionScript(dia);
      }
    }
  }
  if (!script.isEmpty()) {
    script=""String_Node_Str"" + script + ""String_Node_Str"";
  }
  for (  Tag t : timeLineTags) {
    if (t instanceof DoActionTag) {
      DoActionTag da=(DoActionTag)t;
      script+=convertActionScript(da);
    }
    if (t instanceof ShowFrameTag) {
      if (script.isEmpty()) {
        duration++;
      }
 else {
        if (duration > 0) {
          ret.append(""String_Node_Str"").append(frame - duration).append(""String_Node_Str"");
          if (duration > 1) {
            ret.append(""String_Node_Str"").append(duration).append(""String_Node_Str"");
          }
          ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(frame).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(script);
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        script=""String_Node_Str"";
        duration=0;
      }
      frame++;
    }
  }
  String retStr=ret.toString();
  if (!retStr.isEmpty()) {
    retStr=""String_Node_Str"" + randomOutlineColor() + ""String_Node_Str""+ ""String_Node_Str""+ retStr+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  return retStr;
}","private String convertActionScriptLayer(int spriteId,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,String backgroundColor){
  StringBuilder ret=new StringBuilder();
  String script=""String_Node_Str"";
  int duration=0;
  int frame=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      DoInitActionTag dia=(DoInitActionTag)t;
      if (dia.spriteId == spriteId) {
        script+=convertActionScript(dia);
      }
    }
  }
  if (!script.isEmpty()) {
    script=""String_Node_Str"" + script + ""String_Node_Str"";
  }
  for (  Tag t : timeLineTags) {
    if (t instanceof DoActionTag) {
      DoActionTag da=(DoActionTag)t;
      script+=convertActionScript(da);
    }
    if (t instanceof ShowFrameTag) {
      if (script.isEmpty()) {
        duration++;
      }
 else {
        if (duration > 0) {
          ret.append(""String_Node_Str"").append(frame - duration).append(""String_Node_Str"");
          if (duration > 1) {
            ret.append(""String_Node_Str"").append(duration).append(""String_Node_Str"");
          }
          ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(frame).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(script);
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        script=""String_Node_Str"";
        duration=0;
      }
      frame++;
    }
  }
  String retStr=ret.toString();
  if (!retStr.isEmpty()) {
    retStr=""String_Node_Str"" + randomOutlineColor() + ""String_Node_Str""+ ""String_Node_Str""+ retStr+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  return retStr;
}",0.998216560509554
61457,"private static String convertLabelsLayer(int spriteId,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,String backgroundColor){
  StringBuilder ret=new StringBuilder();
  int duration=0;
  int frame=0;
  String frameLabel=""String_Node_Str"";
  boolean isAnchor=false;
  for (  Tag t : timeLineTags) {
    if (t instanceof FrameLabelTag) {
      FrameLabelTag fl=(FrameLabelTag)t;
      frameLabel=fl.getLabelName();
      isAnchor=fl.isNamedAnchor();
    }
    if (t instanceof ShowFrameTag) {
      if (frameLabel.isEmpty()) {
        duration++;
      }
 else {
        if (duration > 0) {
          ret.append(""String_Node_Str"").append(frame - duration).append(""String_Node_Str"");
          if (duration > 1) {
            ret.append(""String_Node_Str"").append(duration).append(""String_Node_Str"");
          }
          ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(frame).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(frameLabel).append(""String_Node_Str"");
        if (isAnchor) {
          ret.append(""String_Node_Str"");
        }
 else {
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        frameLabel=""String_Node_Str"";
        duration=0;
      }
      frame++;
    }
  }
  String retStr=ret.toString();
  if (!retStr.isEmpty()) {
    retStr=""String_Node_Str"" + randomOutlineColor() + ""String_Node_Str""+ ""String_Node_Str""+ retStr+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  return retStr;
}","private String convertLabelsLayer(int spriteId,ReadOnlyTagList tags,ReadOnlyTagList timeLineTags,String backgroundColor){
  StringBuilder ret=new StringBuilder();
  int duration=0;
  int frame=0;
  String frameLabel=""String_Node_Str"";
  boolean isAnchor=false;
  for (  Tag t : timeLineTags) {
    if (t instanceof FrameLabelTag) {
      FrameLabelTag fl=(FrameLabelTag)t;
      frameLabel=fl.getLabelName();
      isAnchor=fl.isNamedAnchor();
    }
    if (t instanceof ShowFrameTag) {
      if (frameLabel.isEmpty()) {
        duration++;
      }
 else {
        if (duration > 0) {
          ret.append(""String_Node_Str"").append(frame - duration).append(""String_Node_Str"");
          if (duration > 1) {
            ret.append(""String_Node_Str"").append(duration).append(""String_Node_Str"");
          }
          ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(frame).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(frameLabel).append(""String_Node_Str"");
        if (isAnchor) {
          ret.append(""String_Node_Str"");
        }
 else {
          ret.append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        frameLabel=""String_Node_Str"";
        duration=0;
      }
      frame++;
    }
  }
  String retStr=ret.toString();
  if (!retStr.isEmpty()) {
    retStr=""String_Node_Str"" + randomOutlineColor() + ""String_Node_Str""+ ""String_Node_Str""+ retStr+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  return retStr;
}",0.9981427434332716
61458,"private static void convertLibrary(SWF swf,Map<Integer,String> characterVariables,Map<Integer,String> characterClasses,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,HashMap<Integer,CharacterTag> characters,HashMap<String,byte[]> files,HashMap<String,byte[]> datfiles,FLAVersion flaVersion,StringBuilder ret){
  List<String> media=new ArrayList<>();
  List<String> symbols=new ArrayList<>();
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if ((symbol instanceof ShapeTag) && nonLibraryShapes.contains(symbol.getCharacterId())) {
      continue;
    }
    if ((symbol instanceof ShapeTag) || (symbol instanceof DefineSpriteTag) || (symbol instanceof ButtonTag)) {
      StringBuilder symbolStr=new StringBuilder();
      symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"").append(getTimestamp(swf)).append(""String_Node_Str"");
      if (symbol instanceof ShapeTag) {
        symbolStr.append(""String_Node_Str"");
      }
 else       if (symbol instanceof ButtonTag) {
        symbolStr.append(""String_Node_Str"");
        if (((ButtonTag)symbol).trackAsMenu()) {
          symbolStr.append(""String_Node_Str"");
        }
      }
      boolean linkageExportForAS=false;
      if (characterClasses.containsKey(symbol.getCharacterId())) {
        linkageExportForAS=true;
        symbolStr.append(""String_Node_Str"").append(Helper.escapeHTML(characterClasses.get(symbol.getCharacterId()))).append(""String_Node_Str"");
      }
      if (characterVariables.containsKey(symbol.getCharacterId())) {
        linkageExportForAS=true;
        symbolStr.append(""String_Node_Str"").append(Helper.escapeHTML(characterVariables.get(symbol.getCharacterId()))).append(""String_Node_Str"");
      }
      if (linkageExportForAS) {
        symbolStr.append(""String_Node_Str"");
      }
      symbolStr.append(""String_Node_Str"");
      symbolStr.append(""String_Node_Str"");
      String itemIcon=null;
      if (symbol instanceof ButtonTag) {
        itemIcon=""String_Node_Str"";
        symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"");
        symbolStr.append(""String_Node_Str"");
        ButtonTag button=(ButtonTag)symbol;
        List<BUTTONRECORD> records=button.getRecords();
        int maxDepth=0;
        for (        BUTTONRECORD rec : records) {
          if (rec.placeDepth > maxDepth) {
            maxDepth=rec.placeDepth;
          }
        }
        for (int i=maxDepth; i >= 1; i--) {
          symbolStr.append(""String_Node_Str"").append(maxDepth - i + 1).append(""String_Node_Str"");
          if (i == 1) {
            symbolStr.append(""String_Node_Str"");
          }
          symbolStr.append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"");
          symbolStr.append(""String_Node_Str"");
          int lastFrame=0;
          loopframes:           for (int frame=1; frame <= 4; frame++) {
            for (            BUTTONRECORD rec : records) {
              if (rec.placeDepth == i) {
                boolean ok=false;
switch (frame) {
case 1:
                  ok=rec.buttonStateUp;
                break;
case 2:
              ok=rec.buttonStateOver;
            break;
case 3:
          ok=rec.buttonStateDown;
        break;
case 4:
      ok=rec.buttonStateHitTest;
    break;
}
if (!ok) {
  continue;
}
CXFORMWITHALPHA colorTransformAlpha=null;
int blendMode=0;
List<FILTER> filters=new ArrayList<>();
if (button instanceof DefineButton2Tag) {
  colorTransformAlpha=rec.colorTransform;
  if (rec.buttonHasBlendMode) {
    blendMode=rec.blendMode;
  }
  if (rec.buttonHasFilterList) {
    filters=rec.filterList;
  }
}
CharacterTag character=characters.get(rec.characterId);
MATRIX matrix=rec.placeMatrix;
String recCharStr;
int characterId=character.getCharacterId();
if ((character instanceof ShapeTag) && (nonLibraryShapes.contains(characterId))) {
  ShapeTag shape=(ShapeTag)character;
  recCharStr=convertShape(characters,matrix,shape.getShapeNum(),shape.getShapes().shapeRecords,shape.getShapes().fillStyles,shape.getShapes().lineStyles,false,false);
}
 else if (character instanceof TextTag) {
  recCharStr=convertText(null,(TextTag)character,matrix,filters,null);
}
 else if (character instanceof DefineVideoStreamTag) {
  recCharStr=convertVideoInstance(null,matrix,(DefineVideoStreamTag)character,null);
}
 else {
  recCharStr=convertSymbolInstance(null,matrix,colorTransformAlpha,false,blendMode,filters,true,null,null,characters.get(rec.characterId),characters,tags,flaVersion);
}
int duration=frame - lastFrame;
lastFrame=frame;
if (duration > 0) {
  if (duration > 1) {
    symbolStr.append(""String_Node_Str"");
    symbolStr.append((frame - duration));
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"").append(duration - 1).append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
  }
  symbolStr.append(""String_Node_Str"");
  symbolStr.append((frame - 1));
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(recCharStr);
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"");
}
}
}
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
 else if (symbol instanceof DefineSpriteTag) {
DefineSpriteTag sprite=(DefineSpriteTag)symbol;
if (sprite.getTags().isEmpty()) {
continue;
}
symbolStr.append(convertTimeline(sprite.spriteId,nonLibraryShapes,backgroundColor,tags,sprite.getTags(),characters,""String_Node_Str"" + symbol.getCharacterId(),flaVersion,files));
}
 else if (symbol instanceof ShapeTag) {
itemIcon=""String_Node_Str"";
ShapeTag shape=(ShapeTag)symbol;
symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
SHAPEWITHSTYLE shapeWithStyle=shape.getShapes();
if (shapeWithStyle != null) {
symbolStr.append(convertShape(characters,null,shape.getShapeNum(),shapeWithStyle.shapeRecords,shapeWithStyle.fillStyles,shapeWithStyle.lineStyles,false,true));
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
String symbolStr2=prettyFormatXML(symbolStr.toString());
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str"";
files.put(symbolFile,Utf8Helper.getBytes(symbolStr2));
String symbLinkStr=""String_Node_Str"";
symbLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
if (itemIcon != null) {
symbLinkStr+=""String_Node_Str"" + itemIcon + ""String_Node_Str"";
}
symbLinkStr+=""String_Node_Str"";
if (flaVersion.ordinal() >= FLAVersion.CS5_5.ordinal()) {
symbLinkStr+=""String_Node_Str"" + getTimestamp(swf) + ""String_Node_Str"";
}
symbLinkStr+=""String_Node_Str"";
symbols.add(symbLinkStr);
}
 else if (symbol instanceof ImageTag) {
ImageTag imageTag=(ImageTag)symbol;
boolean allowSmoothing=false;
looptags: for (Tag tag : swf.getTags()) {
if (tag instanceof ShapeTag) {
Set<Integer> needed=new HashSet<>();
tag.getNeededCharacters(needed);
ShapeTag sht=(ShapeTag)tag;
if (needed.contains(imageTag.getCharacterId())) {
List<FILLSTYLE> fs=new ArrayList<>();
SHAPEWITHSTYLE s=sht.getShapes();
for (FILLSTYLE f : s.fillStyles.fillStyles) {
fs.add(f);
}
for (SHAPERECORD r : s.shapeRecords) {
if (r instanceof StyleChangeRecord) {
StyleChangeRecord scr=(StyleChangeRecord)r;
if (scr.stateNewStyles) {
  for (  FILLSTYLE f : scr.fillStyles.fillStyles) {
    fs.add(f);
  }
}
}
}
for (FILLSTYLE f : fs) {
if (Arrays.asList(FILLSTYLE.REPEATING_BITMAP,FILLSTYLE.CLIPPED_BITMAP,FILLSTYLE.NON_SMOOTHED_REPEATING_BITMAP,FILLSTYLE.NON_SMOOTHED_CLIPPED_BITMAP).contains(f.fillStyleType) && f.bitmapId == imageTag.getCharacterId()) {
allowSmoothing=f.fillStyleType == FILLSTYLE.CLIPPED_BITMAP || f.fillStyleType == FILLSTYLE.REPEATING_BITMAP;
break looptags;
}
}
}
}
}
byte imageBytes[]=Helper.readStream(imageTag.getImageData());
SerializableImage image=imageTag.getImage(false);
ImageFormat format=imageTag.getImageFormat();
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + imageTag.getImageFormat().getExtension();
files.put(symbolFile,imageBytes);
String mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ imageBytes.length+ ""String_Node_Str"";
if (allowSmoothing) {
mediaLinkStr+=""String_Node_Str"";
}
switch (format) {
case PNG:
case GIF:
mediaLinkStr+=""String_Node_Str"";
break;
case JPEG:
mediaLinkStr+=""String_Node_Str"";
break;
}
if (characterClasses.containsKey(symbol.getCharacterId())) {
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ (media.size() + 1)+ ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ image.getWidth()+ ""String_Node_Str""+ image.getHeight()+ ""String_Node_Str"";
media.add(mediaLinkStr);
}
 else if ((symbol instanceof SoundStreamHeadTypeTag) || (symbol instanceof DefineSoundTag)) {
int soundFormat=0;
int soundRate=0;
boolean soundType=false;
boolean soundSize=false;
long soundSampleCount=0;
byte[] soundData=SWFInputStream.BYTE_ARRAY_EMPTY;
int[] rateMap={5,11,22,44};
String exportFormat=""String_Node_Str"";
if (symbol instanceof SoundStreamHeadTypeTag) {
SoundStreamHeadTypeTag sstream=(SoundStreamHeadTypeTag)symbol;
soundFormat=sstream.getSoundFormatId();
soundRate=sstream.getSoundRate();
soundType=sstream.getSoundType();
soundSize=sstream.getSoundSize();
soundSampleCount=sstream.getSoundSampleCount();
boolean found=false;
for (Tag t : tags) {
if (found && (t instanceof SoundStreamBlockTag)) {
SoundStreamBlockTag bl=(SoundStreamBlockTag)t;
soundData=bl.streamSoundData.getRangeData();
break;
}
if (t == symbol) {
found=true;
}
}
}
 else if (symbol instanceof DefineSoundTag) {
DefineSoundTag sound=(DefineSoundTag)symbol;
soundFormat=sound.soundFormat;
soundRate=sound.soundRate;
soundType=sound.soundType;
soundData=sound.soundData.getRangeData();
soundSize=sound.soundSize;
soundSampleCount=sound.soundSampleCount;
}
int format=0;
int bits=0;
if ((soundFormat == SoundFormat.FORMAT_ADPCM) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_NATIVE_ENDIAN)) {
exportFormat=""String_Node_Str"";
if (soundType) {
format+=1;
}
switch (soundRate) {
case 0:
format+=2;
break;
case 1:
format+=6;
break;
case 2:
format+=10;
break;
case 3:
format+=14;
break;
}
}
if (soundFormat == SoundFormat.FORMAT_SPEEX) {
bits=18;
}
if (soundFormat == SoundFormat.FORMAT_ADPCM) {
exportFormat=""String_Node_Str"";
try {
SWFInputStream sis=new SWFInputStream(swf,soundData);
int adpcmCodeSize=(int)sis.readUB(2,""String_Node_Str"");
bits=2 + adpcmCodeSize;
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
if (soundFormat == SoundFormat.FORMAT_MP3) {
exportFormat=""String_Node_Str"";
if (!soundType) {
format+=1;
}
format+=4;
try {
MP3SOUNDDATA s=new MP3SOUNDDATA(new SWFInputStream(swf,soundData),false);
MP3FRAME frame=s.frames.get(0);
int bitRate=frame.getBitRate();
switch (bitRate) {
case 8:
bits=6;
break;
case 16:
bits=7;
break;
case 20:
bits=8;
break;
case 24:
bits=9;
break;
case 32:
bits=10;
break;
case 48:
bits=11;
break;
case 56:
bits=12;
break;
case 64:
bits=13;
break;
case 80:
bits=14;
break;
case 112:
bits=15;
break;
case 128:
bits=16;
break;
case 160:
bits=17;
break;
}
}
 catch (IOException|ArrayIndexOutOfBoundsException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
SoundTag st=(SoundTag)symbol;
SoundFormat fmt=st.getSoundFormat();
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new SoundExporter().exportSound(st,SoundExportMode.MP3_WAV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ exportFormat;
files.put(symbolFile,data);
String mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ data.length+ ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"";
mediaLinkStr+=rateMap[soundRate] + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + (soundSize ? ""String_Node_Str"" : ""String_Node_Str"");
mediaLinkStr+=""String_Node_Str"" + (soundType ? ""String_Node_Str"" : ""String_Node_Str"");
mediaLinkStr+=""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + format + ""String_Node_Str""+ bits+ ""String_Node_Str""+ soundSampleCount+ ""String_Node_Str"";
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + Helper.escapeHTML(characterVariables.get(symbol.getCharacterId())) + ""String_Node_Str"";
}
if (linkageExportForAS) {
mediaLinkStr+=""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"";
media.add(mediaLinkStr);
}
 else if (symbol instanceof DefineVideoStreamTag) {
DefineVideoStreamTag video=(DefineVideoStreamTag)symbol;
String videoType=""String_Node_Str"";
switch (video.codecID) {
case 2:
videoType=""String_Node_Str"";
break;
case 3:
videoType=""String_Node_Str"";
break;
case 4:
videoType=""String_Node_Str"";
break;
case 5:
videoType=""String_Node_Str"";
break;
}
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new MovieExporter().exportMovie(video,MovieExportMode.FLV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ ""String_Node_Str"";
String mediaLinkStr=""String_Node_Str"";
if (data.length == 0) {
long ts=getTimestamp(swf);
String datFileName=""String_Node_Str"" + (datfiles.size() + 1) + ""String_Node_Str""+ ts+ ""String_Node_Str"";
mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ symbolFile+ ""String_Node_Str""+ ts+ ""String_Node_Str""+ datFileName+ ""String_Node_Str"";
datfiles.put(datFileName,new byte[]{(byte)0x03,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xA0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x78,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x59,(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xFF,(byte)0xFE,(byte)0xFF,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00});
}
 else {
files.put(symbolFile,data);
mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ data.length+ ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + videoType + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + (int)swf.frameRate + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + video.width + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + video.height + ""String_Node_Str"";
double len=(double)video.numFrames / swf.frameRate;
mediaLinkStr+=""String_Node_Str"" + len + ""String_Node_Str"";
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + Helper.escapeHTML(characterVariables.get(symbol.getCharacterId())) + ""String_Node_Str"";
}
if (linkageExportForAS) {
mediaLinkStr+=""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"";
}
media.add(mediaLinkStr);
}
}
if (!media.isEmpty()) {
ret.append(""String_Node_Str"");
for (String m : media) {
ret.append(m);
}
ret.append(""String_Node_Str"");
}
if (!symbols.isEmpty()) {
ret.append(""String_Node_Str"");
for (String s : symbols) {
ret.append(s);
}
ret.append(""String_Node_Str"");
}
}","private void convertLibrary(SWF swf,Map<Integer,String> characterVariables,Map<Integer,String> characterClasses,List<Integer> nonLibraryShapes,String backgroundColor,ReadOnlyTagList tags,HashMap<Integer,CharacterTag> characters,HashMap<String,byte[]> files,HashMap<String,byte[]> datfiles,FLAVersion flaVersion,StringBuilder ret){
  List<String> media=new ArrayList<>();
  List<String> symbols=new ArrayList<>();
  for (  int ch : characters.keySet()) {
    CharacterTag symbol=characters.get(ch);
    if ((symbol instanceof ShapeTag) && nonLibraryShapes.contains(symbol.getCharacterId())) {
      continue;
    }
    if ((symbol instanceof ShapeTag) || (symbol instanceof DefineSpriteTag) || (symbol instanceof ButtonTag)) {
      StringBuilder symbolStr=new StringBuilder();
      symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"").append(getTimestamp(swf)).append(""String_Node_Str"");
      if (symbol instanceof ShapeTag) {
        symbolStr.append(""String_Node_Str"");
      }
 else       if (symbol instanceof ButtonTag) {
        symbolStr.append(""String_Node_Str"");
        if (((ButtonTag)symbol).trackAsMenu()) {
          symbolStr.append(""String_Node_Str"");
        }
      }
      boolean linkageExportForAS=false;
      if (characterClasses.containsKey(symbol.getCharacterId())) {
        linkageExportForAS=true;
        symbolStr.append(""String_Node_Str"").append(Helper.escapeHTML(characterClasses.get(symbol.getCharacterId()))).append(""String_Node_Str"");
      }
      if (characterVariables.containsKey(symbol.getCharacterId())) {
        linkageExportForAS=true;
        symbolStr.append(""String_Node_Str"").append(Helper.escapeHTML(characterVariables.get(symbol.getCharacterId()))).append(""String_Node_Str"");
      }
      if (linkageExportForAS) {
        symbolStr.append(""String_Node_Str"");
      }
      symbolStr.append(""String_Node_Str"");
      symbolStr.append(""String_Node_Str"");
      String itemIcon=null;
      if (symbol instanceof ButtonTag) {
        itemIcon=""String_Node_Str"";
        symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"");
        symbolStr.append(""String_Node_Str"");
        ButtonTag button=(ButtonTag)symbol;
        List<BUTTONRECORD> records=button.getRecords();
        int maxDepth=0;
        for (        BUTTONRECORD rec : records) {
          if (rec.placeDepth > maxDepth) {
            maxDepth=rec.placeDepth;
          }
        }
        for (int i=maxDepth; i >= 1; i--) {
          symbolStr.append(""String_Node_Str"").append(maxDepth - i + 1).append(""String_Node_Str"");
          if (i == 1) {
            symbolStr.append(""String_Node_Str"");
          }
          symbolStr.append(""String_Node_Str"").append(randomOutlineColor()).append(""String_Node_Str"");
          symbolStr.append(""String_Node_Str"");
          int lastFrame=0;
          loopframes:           for (int frame=1; frame <= 4; frame++) {
            for (            BUTTONRECORD rec : records) {
              if (rec.placeDepth == i) {
                boolean ok=false;
switch (frame) {
case 1:
                  ok=rec.buttonStateUp;
                break;
case 2:
              ok=rec.buttonStateOver;
            break;
case 3:
          ok=rec.buttonStateDown;
        break;
case 4:
      ok=rec.buttonStateHitTest;
    break;
}
if (!ok) {
  continue;
}
CXFORMWITHALPHA colorTransformAlpha=null;
int blendMode=0;
List<FILTER> filters=new ArrayList<>();
if (button instanceof DefineButton2Tag) {
  colorTransformAlpha=rec.colorTransform;
  if (rec.buttonHasBlendMode) {
    blendMode=rec.blendMode;
  }
  if (rec.buttonHasFilterList) {
    filters=rec.filterList;
  }
}
CharacterTag character=characters.get(rec.characterId);
MATRIX matrix=rec.placeMatrix;
String recCharStr;
int characterId=character.getCharacterId();
if ((character instanceof ShapeTag) && (nonLibraryShapes.contains(characterId))) {
  ShapeTag shape=(ShapeTag)character;
  recCharStr=convertShape(characters,matrix,shape.getShapeNum(),shape.getShapes().shapeRecords,shape.getShapes().fillStyles,shape.getShapes().lineStyles,false,false);
}
 else if (character instanceof TextTag) {
  recCharStr=convertText(null,(TextTag)character,matrix,filters,null);
}
 else if (character instanceof DefineVideoStreamTag) {
  recCharStr=convertVideoInstance(null,matrix,(DefineVideoStreamTag)character,null);
}
 else {
  recCharStr=convertSymbolInstance(null,matrix,colorTransformAlpha,false,blendMode,filters,true,null,null,characters.get(rec.characterId),characters,tags,flaVersion);
}
int duration=frame - lastFrame;
lastFrame=frame;
if (duration > 0) {
  if (duration > 1) {
    symbolStr.append(""String_Node_Str"");
    symbolStr.append((frame - duration));
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"").append(duration - 1).append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
    symbolStr.append(""String_Node_Str"");
  }
  symbolStr.append(""String_Node_Str"");
  symbolStr.append((frame - 1));
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"").append(KEY_MODE_NORMAL).append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(recCharStr);
  symbolStr.append(""String_Node_Str"");
  symbolStr.append(""String_Node_Str"");
}
}
}
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
 else if (symbol instanceof DefineSpriteTag) {
DefineSpriteTag sprite=(DefineSpriteTag)symbol;
if (sprite.getTags().isEmpty()) {
continue;
}
symbolStr.append(convertTimeline(sprite.spriteId,nonLibraryShapes,backgroundColor,tags,sprite.getTags(),characters,""String_Node_Str"" + symbol.getCharacterId(),flaVersion,files));
}
 else if (symbol instanceof ShapeTag) {
itemIcon=""String_Node_Str"";
ShapeTag shape=(ShapeTag)symbol;
symbolStr.append(""String_Node_Str"").append(symbol.getCharacterId()).append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
SHAPEWITHSTYLE shapeWithStyle=shape.getShapes();
if (shapeWithStyle != null) {
symbolStr.append(convertShape(characters,null,shape.getShapeNum(),shapeWithStyle.shapeRecords,shapeWithStyle.fillStyles,shapeWithStyle.lineStyles,false,true));
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
}
symbolStr.append(""String_Node_Str"");
symbolStr.append(""String_Node_Str"");
String symbolStr2=prettyFormatXML(symbolStr.toString());
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str"";
files.put(symbolFile,Utf8Helper.getBytes(symbolStr2));
String symbLinkStr=""String_Node_Str"";
symbLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
if (itemIcon != null) {
symbLinkStr+=""String_Node_Str"" + itemIcon + ""String_Node_Str"";
}
symbLinkStr+=""String_Node_Str"";
if (flaVersion.ordinal() >= FLAVersion.CS5_5.ordinal()) {
symbLinkStr+=""String_Node_Str"" + getTimestamp(swf) + ""String_Node_Str"";
}
symbLinkStr+=""String_Node_Str"";
symbols.add(symbLinkStr);
}
 else if (symbol instanceof ImageTag) {
ImageTag imageTag=(ImageTag)symbol;
boolean allowSmoothing=false;
looptags: for (Tag tag : swf.getTags()) {
if (tag instanceof ShapeTag) {
Set<Integer> needed=new HashSet<>();
tag.getNeededCharacters(needed);
ShapeTag sht=(ShapeTag)tag;
if (needed.contains(imageTag.getCharacterId())) {
List<FILLSTYLE> fs=new ArrayList<>();
SHAPEWITHSTYLE s=sht.getShapes();
for (FILLSTYLE f : s.fillStyles.fillStyles) {
fs.add(f);
}
for (SHAPERECORD r : s.shapeRecords) {
if (r instanceof StyleChangeRecord) {
StyleChangeRecord scr=(StyleChangeRecord)r;
if (scr.stateNewStyles) {
  for (  FILLSTYLE f : scr.fillStyles.fillStyles) {
    fs.add(f);
  }
}
}
}
for (FILLSTYLE f : fs) {
if (Arrays.asList(FILLSTYLE.REPEATING_BITMAP,FILLSTYLE.CLIPPED_BITMAP,FILLSTYLE.NON_SMOOTHED_REPEATING_BITMAP,FILLSTYLE.NON_SMOOTHED_CLIPPED_BITMAP).contains(f.fillStyleType) && f.bitmapId == imageTag.getCharacterId()) {
allowSmoothing=f.fillStyleType == FILLSTYLE.CLIPPED_BITMAP || f.fillStyleType == FILLSTYLE.REPEATING_BITMAP;
break looptags;
}
}
}
}
}
byte imageBytes[]=Helper.readStream(imageTag.getImageData());
SerializableImage image=imageTag.getImage(false);
ImageFormat format=imageTag.getImageFormat();
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + imageTag.getImageFormat().getExtension();
files.put(symbolFile,imageBytes);
String mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ imageBytes.length+ ""String_Node_Str"";
if (allowSmoothing) {
mediaLinkStr+=""String_Node_Str"";
}
switch (format) {
case PNG:
case GIF:
mediaLinkStr+=""String_Node_Str"";
break;
case JPEG:
mediaLinkStr+=""String_Node_Str"";
break;
}
if (characterClasses.containsKey(symbol.getCharacterId())) {
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ (media.size() + 1)+ ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ image.getWidth()+ ""String_Node_Str""+ image.getHeight()+ ""String_Node_Str"";
media.add(mediaLinkStr);
}
 else if ((symbol instanceof SoundStreamHeadTypeTag) || (symbol instanceof DefineSoundTag)) {
int soundFormat=0;
int soundRate=0;
boolean soundType=false;
boolean soundSize=false;
long soundSampleCount=0;
byte[] soundData=SWFInputStream.BYTE_ARRAY_EMPTY;
int[] rateMap={5,11,22,44};
String exportFormat=""String_Node_Str"";
if (symbol instanceof SoundStreamHeadTypeTag) {
SoundStreamHeadTypeTag sstream=(SoundStreamHeadTypeTag)symbol;
soundFormat=sstream.getSoundFormatId();
soundRate=sstream.getSoundRate();
soundType=sstream.getSoundType();
soundSize=sstream.getSoundSize();
soundSampleCount=sstream.getSoundSampleCount();
boolean found=false;
for (Tag t : tags) {
if (found && (t instanceof SoundStreamBlockTag)) {
SoundStreamBlockTag bl=(SoundStreamBlockTag)t;
soundData=bl.streamSoundData.getRangeData();
break;
}
if (t == symbol) {
found=true;
}
}
}
 else if (symbol instanceof DefineSoundTag) {
DefineSoundTag sound=(DefineSoundTag)symbol;
soundFormat=sound.soundFormat;
soundRate=sound.soundRate;
soundType=sound.soundType;
soundData=sound.soundData.getRangeData();
soundSize=sound.soundSize;
soundSampleCount=sound.soundSampleCount;
}
int format=0;
int bits=0;
if ((soundFormat == SoundFormat.FORMAT_ADPCM) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN) || (soundFormat == SoundFormat.FORMAT_UNCOMPRESSED_NATIVE_ENDIAN)) {
exportFormat=""String_Node_Str"";
if (soundType) {
format+=1;
}
switch (soundRate) {
case 0:
format+=2;
break;
case 1:
format+=6;
break;
case 2:
format+=10;
break;
case 3:
format+=14;
break;
}
}
if (soundFormat == SoundFormat.FORMAT_SPEEX) {
bits=18;
}
if (soundFormat == SoundFormat.FORMAT_ADPCM) {
exportFormat=""String_Node_Str"";
try {
SWFInputStream sis=new SWFInputStream(swf,soundData);
int adpcmCodeSize=(int)sis.readUB(2,""String_Node_Str"");
bits=2 + adpcmCodeSize;
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
if (soundFormat == SoundFormat.FORMAT_MP3) {
exportFormat=""String_Node_Str"";
if (!soundType) {
format+=1;
}
format+=4;
try {
MP3SOUNDDATA s=new MP3SOUNDDATA(new SWFInputStream(swf,soundData),false);
MP3FRAME frame=s.frames.get(0);
int bitRate=frame.getBitRate();
switch (bitRate) {
case 8:
bits=6;
break;
case 16:
bits=7;
break;
case 20:
bits=8;
break;
case 24:
bits=9;
break;
case 32:
bits=10;
break;
case 48:
bits=11;
break;
case 56:
bits=12;
break;
case 64:
bits=13;
break;
case 80:
bits=14;
break;
case 112:
bits=15;
break;
case 128:
bits=16;
break;
case 160:
bits=17;
break;
}
}
 catch (IOException|ArrayIndexOutOfBoundsException ex) {
logger.log(Level.SEVERE,null,ex);
}
}
SoundTag st=(SoundTag)symbol;
SoundFormat fmt=st.getSoundFormat();
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new SoundExporter().exportSound(st,SoundExportMode.MP3_WAV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ exportFormat;
files.put(symbolFile,data);
String mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ data.length+ ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"";
mediaLinkStr+=rateMap[soundRate] + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + (soundSize ? ""String_Node_Str"" : ""String_Node_Str"");
mediaLinkStr+=""String_Node_Str"" + (soundType ? ""String_Node_Str"" : ""String_Node_Str"");
mediaLinkStr+=""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + format + ""String_Node_Str""+ bits+ ""String_Node_Str""+ soundSampleCount+ ""String_Node_Str"";
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + Helper.escapeHTML(characterVariables.get(symbol.getCharacterId())) + ""String_Node_Str"";
}
if (linkageExportForAS) {
mediaLinkStr+=""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"";
media.add(mediaLinkStr);
}
 else if (symbol instanceof DefineVideoStreamTag) {
DefineVideoStreamTag video=(DefineVideoStreamTag)symbol;
String videoType=""String_Node_Str"";
switch (video.codecID) {
case 2:
videoType=""String_Node_Str"";
break;
case 3:
videoType=""String_Node_Str"";
break;
case 4:
videoType=""String_Node_Str"";
break;
case 5:
videoType=""String_Node_Str"";
break;
}
byte[] data=SWFInputStream.BYTE_ARRAY_EMPTY;
try {
data=new MovieExporter().exportMovie(video,MovieExportMode.FLV);
}
 catch (IOException ex) {
logger.log(Level.SEVERE,null,ex);
}
String symbolFile=""String_Node_Str"" + symbol.getCharacterId() + ""String_Node_Str""+ ""String_Node_Str"";
String mediaLinkStr=""String_Node_Str"";
if (data.length == 0) {
long ts=getTimestamp(swf);
String datFileName=""String_Node_Str"" + (datfiles.size() + 1) + ""String_Node_Str""+ ts+ ""String_Node_Str"";
mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ symbolFile+ ""String_Node_Str""+ ts+ ""String_Node_Str""+ datFileName+ ""String_Node_Str"";
datfiles.put(datFileName,new byte[]{(byte)0x03,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xA0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x78,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x59,(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xFF,(byte)0xFE,(byte)0xFF,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00});
}
 else {
files.put(symbolFile,data);
mediaLinkStr=""String_Node_Str"" + symbolFile + ""String_Node_Str""+ getTimestamp(swf)+ ""String_Node_Str""+ data.length+ ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + symbolFile + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + videoType + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + (int)swf.frameRate + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + video.width + ""String_Node_Str"";
mediaLinkStr+=""String_Node_Str"" + video.height + ""String_Node_Str"";
double len=(double)video.numFrames / swf.frameRate;
mediaLinkStr+=""String_Node_Str"" + len + ""String_Node_Str"";
boolean linkageExportForAS=false;
if (characterClasses.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + characterClasses.get(symbol.getCharacterId()) + ""String_Node_Str"";
}
if (characterVariables.containsKey(symbol.getCharacterId())) {
linkageExportForAS=true;
mediaLinkStr+=""String_Node_Str"" + Helper.escapeHTML(characterVariables.get(symbol.getCharacterId())) + ""String_Node_Str"";
}
if (linkageExportForAS) {
mediaLinkStr+=""String_Node_Str"";
}
mediaLinkStr+=""String_Node_Str"";
}
media.add(mediaLinkStr);
}
}
if (!media.isEmpty()) {
ret.append(""String_Node_Str"");
for (String m : media) {
ret.append(m);
}
ret.append(""String_Node_Str"");
}
if (!symbols.isEmpty()) {
ret.append(""String_Node_Str"");
for (String s : symbols) {
ret.append(s);
}
ret.append(""String_Node_Str"");
}
}",0.9997935894789608
61459,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(AsciiToCharActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(AsciiToCharActionItem.getResult(lda.pop()));
  return true;
}",0.9617486338797814
61460,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stage.callFrame(EcmaScript.toInt32(lda.stack.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stage.callFrame(EcmaScript.toInt32(lda.stack.pop()));
  return true;
}",0.9613259668508288
61461,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(CharToAsciiActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(CharToAsciiActionItem.getResult(lda.pop()));
  return true;
}",0.9617486338797814
61462,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  Object value=lda.localVariables.get(EcmaScript.toString(lda.pop()));
  if (value == null) {
    value=Undefined.INSTANCE;
  }
  lda.stack.push(value);
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  Object value=lda.localVariables.get(EcmaScript.toString(lda.pop()));
  if (value == null) {
    value=Undefined.INSTANCE;
  }
  lda.stack.push(value);
  return true;
}",0.9635036496350364
61463,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() < 1) {
    return false;
  }
  String frame=EcmaScript.toString(lda.stack.pop());
  String target=""String_Node_Str"";
  if (frame.contains(""String_Node_Str"")) {
    target=frame.substring(0,frame.indexOf(""String_Node_Str""));
    frame=frame.substring(frame.indexOf(""String_Node_Str"") + 1);
  }
  if (frame.matches(""String_Node_Str"")) {
    int frameNum=Integer.parseInt(frame);
    if (target.equals(""String_Node_Str"")) {
      lda.stage.gotoFrame(frameNum);
    }
 else {
      Object member=lda.stage.getMember(target);
      if (member instanceof DisplayObject) {
        ((DisplayObject)member).gotoFrame(frameNum);
      }
    }
  }
 else {
    String frameLabel=frame;
    if (target.equals(""String_Node_Str"")) {
      lda.stage.gotoLabel(frameLabel);
    }
 else {
      Object member=lda.stage.getMember(target);
      if (member instanceof DisplayObject) {
        ((DisplayObject)member).gotoLabel(frameLabel);
      }
    }
  }
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  String frame=EcmaScript.toString(lda.stack.pop());
  String target=""String_Node_Str"";
  if (frame.contains(""String_Node_Str"")) {
    target=frame.substring(0,frame.indexOf(""String_Node_Str""));
    frame=frame.substring(frame.indexOf(""String_Node_Str"") + 1);
  }
  if (frame.matches(""String_Node_Str"")) {
    int frameNum=Integer.parseInt(frame);
    if (target.equals(""String_Node_Str"")) {
      lda.stage.gotoFrame(frameNum);
    }
 else {
      Object member=lda.stage.getMember(target);
      if (member instanceof DisplayObject) {
        ((DisplayObject)member).gotoFrame(frameNum);
      }
    }
  }
 else {
    String frameLabel=frame;
    if (target.equals(""String_Node_Str"")) {
      lda.stage.gotoLabel(frameLabel);
    }
 else {
      Object member=lda.stage.getMember(target);
      if (member instanceof DisplayObject) {
        ((DisplayObject)member).gotoLabel(frameLabel);
      }
    }
  }
  return true;
}",0.9907722195240408
61464,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  if (EcmaScript.toBoolean(lda.pop())) {
    lda.jump=getTargetAddress();
  }
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  if (EcmaScript.toBoolean(lda.pop())) {
    lda.jump=getTargetAddress();
  }
  return true;
}",0.964824120603015
61465,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(MBAsciiToCharActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(MBAsciiToCharActionItem.getResult(lda.pop()));
  return true;
}",0.9621621621621622
61466,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(MBCharToAsciiActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(MBCharToAsciiActionItem.getResult(lda.pop()));
  return true;
}",0.9621621621621622
61467,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(MBStringLengthActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(MBStringLengthActionItem.getResult(lda.pop()));
  return true;
}",0.9623655913978496
61468,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(NotItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(NotItem.getResult(lda.pop()));
  return true;
}",0.9585798816568049
61469,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() < 1) {
    return false;
  }
  lda.stack.push(RandomNumberActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(RandomNumberActionItem.getResult(lda.pop()));
  return true;
}",0.9645776566757494
61470,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(StringLengthActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(StringLengthActionItem.getResult(lda.pop()));
  return true;
}",0.9619565217391304
61471,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(ToIntegerActionItem.getResult(lda.pop()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(ToIntegerActionItem.getResult(lda.pop()));
  return true;
}",0.9613259668508288
61472,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(DecrementActionItem.getResult(lda.popAsNumber()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(DecrementActionItem.getResult(lda.popAsNumber()));
  return true;
}",0.9629629629629628
61473,"@Override public boolean execute(LocalDataArea lda){
  String memberName=lda.popAsString();
  Object o=lda.target;
  if (o instanceof ActionScriptObject) {
    ((ActionScriptObject)o).setMember(memberName,Undefined.INSTANCE);
  }
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  String memberName=lda.popAsString();
  Object o=lda.target;
  if (o instanceof ActionScriptObject) {
    ((ActionScriptObject)o).setMember(memberName,Undefined.INSTANCE);
  }
  return true;
}",0.9060773480662984
61474,"@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.size() == 0) {
    return false;
  }
  lda.stack.push(IncrementActionItem.getResult(lda.popAsNumber()));
  return true;
}","@Override public boolean execute(LocalDataArea lda){
  if (lda.stack.isEmpty()) {
    return false;
  }
  lda.stack.push(IncrementActionItem.getResult(lda.popAsNumber()));
  return true;
}",0.9629629629629628
61475,"public ForEachInAVM2Item(GraphSourceItem instruction,GraphSourceItem lineStartIns,Loop loop,InAVM2Item expression,List<GraphTargetItem> commands){
  super(instruction,lineStartIns,loop);
  if (!commands.isEmpty()) {
    GraphTargetItem firstAssign=commands.get(0);
    if (firstAssign instanceof SetTypeAVM2Item) {
      if (expression.object instanceof LocalRegAVM2Item) {
        if (((SetTypeAVM2Item)firstAssign).getValue().getNotCoerced() instanceof LocalRegAVM2Item) {
          if (((LocalRegAVM2Item)((SetTypeAVM2Item)firstAssign).getValue().getNotCoerced()).regIndex == ((LocalRegAVM2Item)expression.object).regIndex) {
            commands.remove(0);
            expression.object=((SetTypeAVM2Item)firstAssign).getObject();
          }
        }
      }
    }
  }
  this.expression=expression;
  this.commands=commands;
}","public ForEachInAVM2Item(GraphSourceItem instruction,GraphSourceItem lineStartIns,Loop loop,InAVM2Item expression,List<GraphTargetItem> commands){
  super(instruction,lineStartIns,loop);
  this.expression=expression;
  this.commands=commands;
}",0.3884758364312267
61476,"/** 
 * Traverse loops deep first search
 * @param localData
 * @param loopHeaders Resulting loop headers
 * @param b0 Current node
 * @param DFSP_pos Position in DFSP
 * @return innermost loop header of b0
 */
protected GraphPart trav_loops_DFS(BaseLocalData localData,List<GraphPart> loopHeaders,GraphPart b0,int DFSP_pos){
  List<GraphPart> folParts=new ArrayList<>(b0.nextParts);
  folParts.addAll(b0.throwParts);
  b0.traversed=true;
  b0.DFSP_pos=DFSP_pos;
  for (  GraphPart b : folParts) {
    b=checkPart(null,localData,b,null);
    if (b == null) {
      continue;
    }
    if (!b.traversed) {
      GraphPart nh=trav_loops_DFS(localData,loopHeaders,b,DFSP_pos + 1);
      tag_lhead(b0,nh);
    }
 else {
      if (b.DFSP_pos > 0) {
        if (b.type != GraphPart.TYPE_LOOP_HEADER) {
          b.type=GraphPart.TYPE_LOOP_HEADER;
          loopHeaders.add(b);
        }
        tag_lhead(b0,b);
      }
 else       if (b.iloop_header == null) {
      }
 else {
        GraphPart h=b.iloop_header;
        if (h.DFSP_pos > 0) {
          tag_lhead(b0,h);
        }
 else {
          b.type=GraphPart.TYPE_REENTRY;
          h.irreducible=true;
          while (h.iloop_header != null) {
            h=h.iloop_header;
            if (h.DFSP_pos > 0) {
              tag_lhead(b0,h);
              break;
            }
            h.irreducible=true;
          }
        }
      }
    }
  }
  b0.DFSP_pos=0;
  return b0.iloop_header;
}","/** 
 * Traverse loops deep first search
 * @param localData
 * @param loopHeaders Resulting loop headers
 * @param b0 Current node
 * @param DFSP_pos Position in DFSP
 * @return innermost loop header of b0
 */
protected GraphPart trav_loops_DFS(BaseLocalData localData,List<GraphPart> loopHeaders,GraphPart b0,int DFSP_pos){
  List<GraphPart> folParts=new ArrayList<>(b0.nextParts);
  folParts.addAll(b0.throwParts);
  b0.traversed=true;
  b0.DFSP_pos=DFSP_pos;
  for (  GraphPart b : folParts) {
    b=checkPart(null,localData,b,null);
    if (b == null) {
      continue;
    }
    if (!b.traversed) {
      GraphPart nh=trav_loops_DFS(localData,loopHeaders,b,DFSP_pos + 1);
      tag_lhead(b0,nh);
    }
 else     if (b.DFSP_pos > 0) {
      if (b.type != GraphPart.TYPE_LOOP_HEADER) {
        b.type=GraphPart.TYPE_LOOP_HEADER;
        loopHeaders.add(b);
      }
      tag_lhead(b0,b);
    }
 else     if (b.iloop_header == null) {
    }
 else {
      GraphPart h=b.iloop_header;
      if (h.DFSP_pos > 0) {
        tag_lhead(b0,h);
      }
 else {
        b.type=GraphPart.TYPE_REENTRY;
        h.irreducible=true;
        while (h.iloop_header != null) {
          h=h.iloop_header;
          if (h.DFSP_pos > 0) {
            tag_lhead(b0,h);
            break;
          }
          h.irreducible=true;
        }
      }
    }
  }
  b0.DFSP_pos=0;
  return b0.iloop_header;
}",0.9667609618104668
61477,"protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if (code.size() <= part.start) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,localData.lineStartInstruction,labelName));
    }
    ret.add(new GotoItem(null,localData.lineStartInstruction,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,localData.lineStartInstruction,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (int i=1; i < part.nextParts.size(); i++) {
        if (hasExpr && i == 1 + defaultBranch) {
          continue;
        }
        if (part.nextParts.get(i) != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,localData.lineStartInstruction,pos));
          }
        }
        pos++;
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,localData.lineStartInstruction,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        List<GraphTargetItem> filteredOnTrue=filter(onTrue);
        List<GraphTargetItem> filteredOnFalse=filter(onFalse);
        if (!isEmpty(filteredOnTrue) && !isEmpty(filteredOnFalse) && filteredOnTrue.size() == 1 && filteredOnFalse.size() == 1 && (filteredOnTrue.get(0) instanceof PushItem) && (filteredOnFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,localData.lineStartInstruction,expr.invert(null),((PushItem)filteredOnTrue.get(0)).value,((PushItem)filteredOnFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (filteredOnTrue.isEmpty() && !filteredOnFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
            filteredOnTrue=filteredOnFalse;
          }
          if (!stack.isEmpty() && ((filteredOnTrue.size() == 1 && (filteredOnTrue.get(0) instanceof PopItem)) || ((filteredOnTrue.size() >= 2) && (filteredOnTrue.get(0) instanceof PopItem) && (filteredOnTrue.get(filteredOnTrue.size() - 1) instanceof PushItem)))) {
            if (filteredOnTrue.size() > 1) {
              GraphTargetItem rightSide=((PushItem)filteredOnTrue.get(filteredOnTrue.size() - 1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr.getNotCoercedNoDup();
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,localData.lineStartInstruction,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null).getNotCoercedNoDup() instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,localData.lineStartInstruction,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                leftSide=leftSide.invert(null);
                stack.push(new AndItem(null,localData.lineStartInstruction,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,localData.lineStartInstruction,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,localData.lineStartInstruction,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null,localData.lineStartInstruction));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop && loopItem != null && currentLoop != null) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr.getLineStartItem(),expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),expr.getLineStartItem(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),expr.getLineStartItem(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,exprList.get(0).getLineStartItem(),currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,expr.getLineStartItem(),currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,localData.lineStartInstruction,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if (code.size() <= part.start) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,localData.lineStartInstruction,labelName));
    }
    ret.add(new GotoItem(null,localData.lineStartInstruction,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,localData.lineStartInstruction,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else         if (to.expression instanceof FalseItem) {
          it=to.onFalse;
        }
 else         if (to.expression instanceof TrueItem) {
          it=to.onTrue;
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (int i=1; i < part.nextParts.size(); i++) {
        if (part.nextParts.get(i) != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,localData.lineStartInstruction,pos));
          }
        }
        pos++;
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else         if (p == defaultPart) {
          defaultCommands=nextCommands;
        }
 else {
          caseCommands.add(nextCommands);
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,localData.lineStartInstruction,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        List<GraphTargetItem> filteredOnTrue=filter(onTrue);
        List<GraphTargetItem> filteredOnFalse=filter(onFalse);
        if (!isEmpty(filteredOnTrue) && !isEmpty(filteredOnFalse) && filteredOnTrue.size() == 1 && filteredOnFalse.size() == 1 && (filteredOnTrue.get(0) instanceof PushItem) && (filteredOnFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,localData.lineStartInstruction,expr.invert(null),((PushItem)filteredOnTrue.get(0)).value,((PushItem)filteredOnFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (filteredOnTrue.isEmpty() && !filteredOnFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
            filteredOnTrue=filteredOnFalse;
          }
          if (!stack.isEmpty() && ((filteredOnTrue.size() == 1 && (filteredOnTrue.get(0) instanceof PopItem)) || ((filteredOnTrue.size() >= 2) && (filteredOnTrue.get(0) instanceof PopItem) && (filteredOnTrue.get(filteredOnTrue.size() - 1) instanceof PushItem)))) {
            if (filteredOnTrue.size() > 1) {
              GraphTargetItem rightSide=((PushItem)filteredOnTrue.get(filteredOnTrue.size() - 1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr.getNotCoercedNoDup();
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,localData.lineStartInstruction,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null).getNotCoercedNoDup() instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,localData.lineStartInstruction,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                leftSide=leftSide.invert(null);
                stack.push(new AndItem(null,localData.lineStartInstruction,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,localData.lineStartInstruction,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,localData.lineStartInstruction,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null,localData.lineStartInstruction));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop && loopItem != null && currentLoop != null) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr.getLineStartItem(),expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),expr.getLineStartItem(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),expr.getLineStartItem(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,exprList.get(0).getLineStartItem(),currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,expr.getLineStartItem(),currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}",0.9417185078239452
61478,"@Override public HighlightedText getFormattedText(){
  FontTag fnt=null;
  HighlightedTextWriter writer=new HighlightedTextWriter(Configuration.getCodeFormatting(),true);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").append(textBounds.Xmin).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Ymin).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Xmax).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Ymax).newLine();
  if (textMatrix.translateX != 0) {
    writer.append(""String_Node_Str"").append(textMatrix.translateX).newLine();
  }
  if (textMatrix.translateY != 0) {
    writer.append(""String_Node_Str"").append(textMatrix.translateY).newLine();
  }
  if (textMatrix.hasScale) {
    writer.append(""String_Node_Str"").append(textMatrix.scaleX).newLine();
    writer.append(""String_Node_Str"").append(textMatrix.scaleY).newLine();
  }
  if (textMatrix.hasRotate) {
    writer.append(""String_Node_Str"").append(textMatrix.rotateSkew0).newLine();
    writer.append(""String_Node_Str"").append(textMatrix.rotateSkew1).newLine();
  }
  writer.append(""String_Node_Str"");
  for (  TEXTRECORD rec : textRecords) {
    if (rec.styleFlagsHasFont || rec.styleFlagsHasColor || rec.styleFlagsHasXOffset|| rec.styleFlagsHasYOffset) {
      writer.append(""String_Node_Str"").newLine();
      if (rec.styleFlagsHasFont) {
        FontTag fnt2=swf.getFont(rec.fontId);
        if (fnt2 != null) {
          fnt=fnt2;
        }
        writer.append(""String_Node_Str"").append(rec.fontId).newLine();
        writer.append(""String_Node_Str"").append(rec.textHeight).newLine();
      }
      if (fnt != null) {
        int letterSpacing=detectLetterSpacing(rec,fnt,rec.textHeight);
        if (letterSpacing != 0) {
          writer.append(""String_Node_Str"").append(letterSpacing).newLine();
        }
      }
      if (rec.styleFlagsHasColor) {
        if (getTextNum() == 1) {
          writer.append(""String_Node_Str"").append(rec.textColor.toHexRGB()).newLine();
        }
 else {
          writer.append(""String_Node_Str"").append(rec.textColorA.toHexARGB()).newLine();
        }
      }
      if (rec.styleFlagsHasXOffset) {
        writer.append(""String_Node_Str"").append(rec.xOffset).newLine();
      }
      if (rec.styleFlagsHasYOffset) {
        writer.append(""String_Node_Str"").append(rec.yOffset).newLine();
      }
      writer.append(""String_Node_Str"");
    }
    if (fnt == null) {
      writer.append(AppResources.translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(rec.fontId)));
    }
 else {
      writer.hilightSpecial(Helper.escapeActionScriptString(rec.getText(fnt)).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),HighlightSpecialType.TEXT);
    }
  }
  return new HighlightedText(writer);
}","@Override public HighlightedText getFormattedText(){
  FontTag fnt=null;
  HighlightedTextWriter writer=new HighlightedTextWriter(Configuration.getCodeFormatting(),true);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").append(textBounds.Xmin).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Ymin).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Xmax).newLine();
  writer.append(""String_Node_Str"").append(textBounds.Ymax).newLine();
  if (textMatrix.translateX != 0) {
    writer.append(""String_Node_Str"").append(textMatrix.translateX).newLine();
  }
  if (textMatrix.translateY != 0) {
    writer.append(""String_Node_Str"").append(textMatrix.translateY).newLine();
  }
  if (textMatrix.hasScale) {
    writer.append(""String_Node_Str"").append(textMatrix.scaleX).newLine();
    writer.append(""String_Node_Str"").append(textMatrix.scaleY).newLine();
  }
  if (textMatrix.hasRotate) {
    writer.append(""String_Node_Str"").append(textMatrix.rotateSkew0).newLine();
    writer.append(""String_Node_Str"").append(textMatrix.rotateSkew1).newLine();
  }
  writer.append(""String_Node_Str"");
  int textHeight=12;
  for (  TEXTRECORD rec : textRecords) {
    if (rec.styleFlagsHasFont || rec.styleFlagsHasColor || rec.styleFlagsHasXOffset|| rec.styleFlagsHasYOffset) {
      writer.append(""String_Node_Str"").newLine();
      if (rec.styleFlagsHasFont) {
        FontTag fnt2=swf.getFont(rec.fontId);
        if (fnt2 != null) {
          fnt=fnt2;
        }
        writer.append(""String_Node_Str"").append(rec.fontId).newLine();
        writer.append(""String_Node_Str"").append(rec.textHeight).newLine();
        textHeight=rec.textHeight;
      }
      if (fnt != null) {
        int letterSpacing=detectLetterSpacing(rec,fnt,textHeight);
        if (letterSpacing != 0) {
          writer.append(""String_Node_Str"").append(letterSpacing).newLine();
        }
      }
      if (rec.styleFlagsHasColor) {
        if (getTextNum() == 1) {
          writer.append(""String_Node_Str"").append(rec.textColor.toHexRGB()).newLine();
        }
 else {
          writer.append(""String_Node_Str"").append(rec.textColorA.toHexARGB()).newLine();
        }
      }
      if (rec.styleFlagsHasXOffset) {
        writer.append(""String_Node_Str"").append(rec.xOffset).newLine();
      }
      if (rec.styleFlagsHasYOffset) {
        writer.append(""String_Node_Str"").append(rec.yOffset).newLine();
      }
      writer.append(""String_Node_Str"");
    }
    if (fnt == null) {
      writer.append(AppResources.translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(rec.fontId)));
    }
 else {
      writer.hilightSpecial(Helper.escapeActionScriptString(rec.getText(fnt)).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),HighlightSpecialType.TEXT);
    }
  }
  return new HighlightedText(writer);
}",0.989492119089317
61479,"private static void convertFonts(ReadOnlyTagList tags,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      FontTag font=(FontTag)t;
      int fontId=font.getFontId();
      String fontName=null;
      for (      Tag t2 : tags) {
        if (t2 instanceof DefineFontNameTag) {
          if (((DefineFontNameTag)t2).fontId == fontId) {
            fontName=((DefineFontNameTag)t2).fontName;
          }
        }
      }
      if (fontName == null) {
        fontName=font.getFontNameIntag();
      }
      if (fontName == null) {
        fontName=FontTag.defaultFontName;
      }
      int fontStyle=font.getFontStyle();
      String installedFont;
      if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
        fontName=new Font(installedFont,fontStyle,10).getPSName();
      }
      String embedRanges=""String_Node_Str"";
      String fontChars=font.getCharacters();
      if (""String_Node_Str"".equals(fontChars)) {
        continue;
      }
      String embeddedCharacters=fontChars;
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      boolean hasAllRanges=false;
      for (int r=0; r < CharacterRanges.rangeCount(); r++) {
        int[] codes=CharacterRanges.rangeCodes(r);
        boolean hasAllInRange=true;
        for (int i=0; i < codes.length; i++) {
          if (!fontChars.contains(""String_Node_Str"" + (char)codes[i])) {
            hasAllInRange=false;
            break;
          }
        }
        if (hasAllInRange) {
          for (int i=0; i < codes.length; i++) {
            embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"" + (char)codes[i],""String_Node_Str"");
          }
          if (!""String_Node_Str"".equals(embedRanges)) {
            embedRanges+=""String_Node_Str"";
          }
          embedRanges+=(r + 1);
        }
 else {
          hasAllRanges=false;
        }
      }
      if (hasAllRanges) {
        embedRanges=""String_Node_Str"";
      }
      ret2.append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(xmlString(fontName)).append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(embedRanges).append(""String_Node_Str"").append(!""String_Node_Str"".equals(embeddedCharacters) ? ""String_Node_Str"" + xmlString(embeddedCharacters) + ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(ret2).append(""String_Node_Str"");
  }
}","private static void convertFonts(ReadOnlyTagList tags,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      FontTag font=(FontTag)t;
      int fontId=font.getFontId();
      String fontName=null;
      for (      Tag t2 : tags) {
        if (t2 instanceof DefineFontNameTag) {
          if (((DefineFontNameTag)t2).fontId == fontId) {
            fontName=((DefineFontNameTag)t2).fontName;
          }
        }
      }
      if (fontName == null) {
        fontName=font.getFontNameIntag();
      }
      if (fontName == null) {
        fontName=FontTag.defaultFontName;
      }
      int fontStyle=font.getFontStyle();
      String installedFont;
      if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
        fontName=new Font(installedFont,fontStyle,10).getPSName();
      }
      String embedRanges=""String_Node_Str"";
      String fontChars=font.getCharacters();
      if (""String_Node_Str"".equals(fontChars)) {
        continue;
      }
      String embeddedCharacters=fontChars;
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      for (char i=0; i < 32; i++) {
        if (i == 9 || i == 10 || i == 13) {
          continue;
        }
        embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"" + i,""String_Node_Str"");
      }
      boolean hasAllRanges=false;
      for (int r=0; r < CharacterRanges.rangeCount(); r++) {
        int[] codes=CharacterRanges.rangeCodes(r);
        boolean hasAllInRange=true;
        for (int i=0; i < codes.length; i++) {
          if (!fontChars.contains(""String_Node_Str"" + (char)codes[i])) {
            hasAllInRange=false;
            break;
          }
        }
        if (hasAllInRange) {
          for (int i=0; i < codes.length; i++) {
            embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"" + (char)codes[i],""String_Node_Str"");
          }
          if (!""String_Node_Str"".equals(embedRanges)) {
            embedRanges+=""String_Node_Str"";
          }
          embedRanges+=(r + 1);
        }
 else {
          hasAllRanges=false;
        }
      }
      if (hasAllRanges) {
        embedRanges=""String_Node_Str"";
      }
      ret2.append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(xmlString(fontName)).append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(embedRanges).append(""String_Node_Str"").append(!""String_Node_Str"".equals(embeddedCharacters) ? ""String_Node_Str"" + xmlString(embeddedCharacters) + ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(ret2).append(""String_Node_Str"");
  }
}",0.9331140350877192
61480,"public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,final SWF swf,int containerId,List<Integer> frames,final FrameExportSettings settings,final EventListener evl) throws IOException, InterruptedException {
  final List<File> ret=new ArrayList<>();
  if (swf.tags.isEmpty()) {
    return ret;
  }
  Timeline tim0;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim0=swf.getTimeline();
  }
 else {
    tim0=((Timelined)swf.getCharacter(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(swf.getCharacter(containerId).getExportFileName());
  }
  final Timeline tim=tim0;
  if (frames == null) {
    int frameCnt=tim.getFrameCount();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  Path.createDirectorySafe(foutdir);
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  if (settings.mode == FrameExportMode.AVI) {
    for (    Tag t : swf.tags) {
      if (t instanceof SetBackgroundColorTag) {
        SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
        backgroundColor=sb.backgroundColor.toColor();
      }
    }
  }
  if (settings.mode == FrameExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      if (evl != null) {
        evl.handleExportingEvent(""String_Node_Str"",i + 1,frames.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      final int fi=i;
      final Color fbackgroundColor=backgroundColor;
      new RetryTask(() -> {
        int frame=fframes.get(fi);
        File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
        try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(f))){
          ExportRectangle rect=new ExportRectangle(tim.displayRect);
          rect.xMax*=settings.zoom;
          rect.yMax*=settings.zoom;
          rect.xMin*=settings.zoom;
          rect.yMin*=settings.zoom;
          SVGExporter exporter=new SVGExporter(rect);
          if (fbackgroundColor != null) {
            exporter.setBackGroundColor(fbackgroundColor);
          }
          SWF.frameToSvg(tim,frame,0,null,0,exporter,new ColorTransform(),0,settings.zoom);
          fos.write(Utf8Helper.getBytes(exporter.getSVG()));
        }
         ret.add(f);
      }
,handler).run();
      if (evl != null) {
        evl.handleExportedEvent(""String_Node_Str"",i + 1,frames.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
    }
    return ret;
  }
  if (settings.mode == FrameExportMode.CANVAS) {
    if (evl != null) {
      evl.handleExportingEvent(""String_Node_Str"",1,1,tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
    }
    final Timeline ftim=tim;
    final Color fbackgroundColor=backgroundColor;
    final SWF fswf=swf;
    new RetryTask(() -> {
      File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
      Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
      ret.add(fcanvas);
      File f=new File(foutdir + File.separator + ""String_Node_Str"");
      File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
      int width=(int)(ftim.displayRect.getWidth() * settings.zoom / SWF.unitDivisor);
      int height=(int)(ftim.displayRect.getHeight() * settings.zoom / SWF.unitDivisor);
      try (final OutputStream fos=new BufferedOutputStream(new FileOutputStream(f))){
        fos.write(Utf8Helper.getBytes(""String_Node_Str""));
        Set<Integer> library=new HashSet<>();
        ftim.getNeededCharacters(fframes,library);
        SWF.writeLibrary(fswf,library,fos);
        String currentName=ftim.id == 0 ? ""String_Node_Str"" : SWF.getTypePrefix(fswf.getCharacter(ftim.id)) + ftim.id;
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(currentName).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(-ftim.displayRect.Xmin * settings.zoom / SWF.unitDivisor).append(""String_Node_Str"").append(-ftim.displayRect.Ymin * settings.zoom / SWF.unitDivisor).append(""String_Node_Str"");
        framesToHtmlCanvas(sb,SWF.unitDivisor / settings.zoom,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        for (        int i : fframes) {
          sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        RGB backgroundColor1=new RGB(255,255,255);
        for (        Tag t : fswf.tags) {
          if (t instanceof SetBackgroundColorTag) {
            SetBackgroundColorTag sbgct=(SetBackgroundColorTag)t;
            backgroundColor1=sbgct.backgroundColor;
          }
        }
        sb.append(""String_Node_Str"").append(backgroundColor1.toHexRGB()).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(currentName).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        if (ftim.swf.frameRate > 0) {
          sb.append(""String_Node_Str"").append((int)(1000.0 / ftim.swf.frameRate)).append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        fos.write(Utf8Helper.getBytes(sb.toString()));
      }
       boolean packed=false;
      if (Configuration.packJavaScripts.get()) {
        try {
          JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
          f.delete();
          packed=true;
        }
 catch (        Exception|Error e) {
          logger.log(Level.WARNING,""String_Node_Str"");
          f.renameTo(fmin);
        }
      }
 else {
        f.renameTo(fmin);
      }
      File fh=new File(foutdir + File.separator + ""String_Node_Str"");
      try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fh));FileInputStream fis=new FileInputStream(fmin)){
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
        byte[] buf=new byte[1000];
        int cnt;
        while ((cnt=fis.read(buf)) > 0) {
          fos.write(buf,0,cnt);
        }
        if (packed) {
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
        }
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
      }
       fmin.delete();
      ret.add(f);
    }
,handler).run();
    if (evl != null) {
      evl.handleExportedEvent(""String_Node_Str"",1,1,tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
    }
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      if (evl != null) {
        evl.handleExportingEvent(""String_Node_Str"",pos + 1,fframes.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      BufferedImage result=SWF.frameToImageGet(ftim,fframes.get(pos++),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false,settings.zoom).getBufferedImage();
      if (evl != null) {
        evl.handleExportedEvent(""String_Node_Str"",pos,fframes.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      return result;
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(() -> {
      File f=new File(foutdir + File.separator + ""String_Node_Str"");
      makeGIF(frameImages,swf.frameRate,f,evl);
      ret.add(f);
    }
,handler).run();
  break;
case BMP:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(() -> {
    File f=new File(foutdir + File.separator + (fframes.get(fi) + 1)+ ""String_Node_Str"");
    BMPFile.saveBitmap(frameImages.next(),f);
    ret.add(f);
  }
,handler).run();
}
break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
final int fi=i;
new RetryTask(() -> {
File file=new File(foutdir + File.separator + (fframes.get(fi) + 1)+ ""String_Node_Str"");
ImageHelper.write(frameImages.next(),ImageFormat.PNG,file);
ret.add(file);
}
,handler).run();
}
break;
case PDF:
if (frameImages.hasNext()) {
new RetryTask(() -> {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new BufferedOutputStream(new FileOutputStream(f)));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
BufferedImage img=frameImages.next();
Graphics g=job.getGraphics(pf);
g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
g.dispose();
}
job.end();
ret.add(f);
}
,handler).run();
}
break;
case AVI:
new RetryTask(() -> {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,swf.frameRate,f,evl);
ret.add(f);
}
,handler).run();
break;
}
return ret;
}","public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,final SWF swf,int containerId,List<Integer> frames,final FrameExportSettings settings,final EventListener evl) throws IOException, InterruptedException {
  final List<File> ret=new ArrayList<>();
  if (swf.tags.isEmpty()) {
    return ret;
  }
  Timeline tim0;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim0=swf.getTimeline();
  }
 else {
    tim0=((Timelined)swf.getCharacter(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(swf.getCharacter(containerId).getExportFileName());
  }
  final Timeline tim=tim0;
  if (frames == null) {
    int frameCnt=tim.getFrameCount();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  Path.createDirectorySafe(foutdir);
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
  if (setBgColorTag != null) {
    backgroundColor=setBgColorTag.backgroundColor.toColor();
  }
  if (settings.mode == FrameExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      if (evl != null) {
        evl.handleExportingEvent(""String_Node_Str"",i + 1,frames.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      final int fi=i;
      final Color fbackgroundColor=null;
      new RetryTask(() -> {
        int frame=fframes.get(fi);
        File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
        try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(f))){
          ExportRectangle rect=new ExportRectangle(tim.displayRect);
          rect.xMax*=settings.zoom;
          rect.yMax*=settings.zoom;
          rect.xMin*=settings.zoom;
          rect.yMin*=settings.zoom;
          SVGExporter exporter=new SVGExporter(rect);
          if (fbackgroundColor != null) {
            exporter.setBackGroundColor(fbackgroundColor);
          }
          SWF.frameToSvg(tim,frame,0,null,0,exporter,new ColorTransform(),0,settings.zoom);
          fos.write(Utf8Helper.getBytes(exporter.getSVG()));
        }
         ret.add(f);
      }
,handler).run();
      if (evl != null) {
        evl.handleExportedEvent(""String_Node_Str"",i + 1,frames.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
    }
    return ret;
  }
  if (settings.mode == FrameExportMode.CANVAS) {
    if (evl != null) {
      evl.handleExportingEvent(""String_Node_Str"",1,1,tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
    }
    final Timeline ftim=tim;
    final Color fbackgroundColor=null;
    final SWF fswf=swf;
    new RetryTask(() -> {
      File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
      Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
      ret.add(fcanvas);
      File f=new File(foutdir + File.separator + ""String_Node_Str"");
      File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
      int width=(int)(ftim.displayRect.getWidth() * settings.zoom / SWF.unitDivisor);
      int height=(int)(ftim.displayRect.getHeight() * settings.zoom / SWF.unitDivisor);
      try (final OutputStream fos=new BufferedOutputStream(new FileOutputStream(f))){
        fos.write(Utf8Helper.getBytes(""String_Node_Str""));
        Set<Integer> library=new HashSet<>();
        ftim.getNeededCharacters(fframes,library);
        SWF.writeLibrary(fswf,library,fos);
        String currentName=ftim.id == 0 ? ""String_Node_Str"" : SWF.getTypePrefix(fswf.getCharacter(ftim.id)) + ftim.id;
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(currentName).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(-ftim.displayRect.Xmin * settings.zoom / SWF.unitDivisor).append(""String_Node_Str"").append(-ftim.displayRect.Ymin * settings.zoom / SWF.unitDivisor).append(""String_Node_Str"");
        framesToHtmlCanvas(sb,SWF.unitDivisor / settings.zoom,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        for (        int i : fframes) {
          sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        RGB backgroundColor1=new RGB(255,255,255);
        if (setBgColorTag != null) {
          backgroundColor1=setBgColorTag.backgroundColor;
        }
        sb.append(""String_Node_Str"").append(backgroundColor1.toHexRGB()).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"").append(currentName).append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        if (ftim.swf.frameRate > 0) {
          sb.append(""String_Node_Str"").append((int)(1000.0 / ftim.swf.frameRate)).append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"");
        fos.write(Utf8Helper.getBytes(sb.toString()));
      }
       boolean packed=false;
      if (Configuration.packJavaScripts.get()) {
        try {
          JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
          f.delete();
          packed=true;
        }
 catch (        Exception|Error e) {
          logger.log(Level.WARNING,""String_Node_Str"");
          f.renameTo(fmin);
        }
      }
 else {
        f.renameTo(fmin);
      }
      File fh=new File(foutdir + File.separator + ""String_Node_Str"");
      try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fh));FileInputStream fis=new FileInputStream(fmin)){
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
        byte[] buf=new byte[1000];
        int cnt;
        while ((cnt=fis.read(buf)) > 0) {
          fos.write(buf,0,cnt);
        }
        if (packed) {
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
        }
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
        fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
      }
       fmin.delete();
      ret.add(f);
    }
,handler).run();
    if (evl != null) {
      evl.handleExportedEvent(""String_Node_Str"",1,1,tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
    }
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      if (evl != null) {
        evl.handleExportingEvent(""String_Node_Str"",pos + 1,fframes.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      BufferedImage result=SWF.frameToImageGet(ftim,fframes.get(pos++),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false,settings.zoom).getBufferedImage();
      if (evl != null) {
        evl.handleExportedEvent(""String_Node_Str"",pos,fframes.size(),tim.parentTag == null ? ""String_Node_Str"" : tim.parentTag.getName());
      }
      return result;
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(() -> {
      File f=new File(foutdir + File.separator + ""String_Node_Str"");
      makeGIF(frameImages,swf.frameRate,f,evl);
      ret.add(f);
    }
,handler).run();
  break;
case BMP:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(() -> {
    File f=new File(foutdir + File.separator + (fframes.get(fi) + 1)+ ""String_Node_Str"");
    BMPFile.saveBitmap(frameImages.next(),f);
    ret.add(f);
  }
,handler).run();
}
break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
final int fi=i;
new RetryTask(() -> {
File file=new File(foutdir + File.separator + (fframes.get(fi) + 1)+ ""String_Node_Str"");
ImageHelper.write(frameImages.next(),ImageFormat.PNG,file);
ret.add(file);
}
,handler).run();
}
break;
case PDF:
if (frameImages.hasNext()) {
new RetryTask(() -> {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new BufferedOutputStream(new FileOutputStream(f)));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
BufferedImage img=frameImages.next();
Graphics g=job.getGraphics(pf);
g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
g.dispose();
}
job.end();
ret.add(f);
}
,handler).run();
}
break;
case AVI:
new RetryTask(() -> {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,swf.frameRate,f,evl);
ret.add(f);
}
,handler).run();
break;
}
return ret;
}",0.9426478648662115
61481,"public static void convertSWF(AbortRetryIgnoreHandler handler,SWF swf,String swfFileName,String outfile,boolean compressed,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion flaVersion) throws IOException, InterruptedException {
  FileAttributesTag fa=swf.getFileAttributes();
  boolean useAS3=false;
  boolean useNetwork=false;
  if (fa != null) {
    useAS3=fa.actionScript3;
    useNetwork=fa.useNetwork;
  }
  if (!useAS3 && flaVersion.minASVersion() > 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + flaVersion + ""String_Node_Str"");
  }
  File file=new File(outfile);
  File outDir=file.getParentFile();
  Path.createDirectorySafe(outDir);
  StringBuilder domDocument=new StringBuilder();
  String baseName=swfFileName;
  File f=new File(baseName);
  baseName=f.getName();
  if (baseName.contains(""String_Node_Str"")) {
    baseName=baseName.substring(0,baseName.lastIndexOf('.'));
  }
  final HashMap<String,byte[]> files=new HashMap<>();
  final HashMap<String,byte[]> datfiles=new HashMap<>();
  HashMap<Integer,CharacterTag> characters=getCharacters(swf.tags);
  List<Integer> nonLibraryShapes=getNonLibraryShapes(swf.tags,characters);
  Map<Integer,String> characterClasses=getCharacterClasses(swf.tags);
  Map<Integer,String> characterVariables=getCharacterVariables(swf.tags);
  String backgroundColor=""String_Node_Str"";
  for (  Tag t : swf.tags) {
    if (t instanceof SetBackgroundColorTag) {
      SetBackgroundColorTag sbc=(SetBackgroundColorTag)t;
      backgroundColor=sbc.backgroundColor.toHexRGB();
    }
  }
  domDocument.append(""String_Node_Str"").append(flaVersion.xflVersion()).append(""String_Node_Str"").append(generator).append(""String_Node_Str"").append(generatorVerName).append(""String_Node_Str"").append(generatorVersion).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append(backgroundColor).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append((int)swf.frameRate).append(""String_Node_Str"");
  double width=twipToPixel(swf.displayRect.getWidth());
  double height=twipToPixel(swf.displayRect.getHeight());
  if (Double.compare(width,550) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(width)).append(""String_Node_Str"");
  }
  if (Double.compare(height,400) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(height)).append(""String_Node_Str"");
  }
  domDocument.append(""String_Node_Str"");
  convertFonts(swf.tags,domDocument);
  convertLibrary(swf,characterVariables,characterClasses,nonLibraryShapes,backgroundColor,swf.tags,characters,files,datfiles,flaVersion,domDocument);
  domDocument.append(""String_Node_Str"");
  domDocument.append(convertTimeline(0,nonLibraryShapes,backgroundColor,swf.tags,swf.tags,characters,""String_Node_Str"",flaVersion,files));
  domDocument.append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"");
  String domDocumentStr=prettyFormatXML(domDocument.toString());
  for (  Tag t : swf.tags) {
    if (t instanceof DoInitActionTag) {
      DoInitActionTag dia=(DoInitActionTag)t;
      int chid=dia.getCharacterId();
      if (characters.containsKey(chid)) {
        if (characters.get(chid) instanceof DefineSpriteTag) {
          DefineSpriteTag sprite=(DefineSpriteTag)characters.get(chid);
          if (sprite.subTags.isEmpty()) {
            String data=convertActionScript(dia);
            String expName=dia.getSwf().getExportName(dia.spriteId);
            expName=expName != null ? expName : ""String_Node_Str"";
            String expPath=expName;
            final String prefix=""String_Node_Str"";
            if (expPath.startsWith(prefix)) {
              expPath=expPath.substring(prefix.length());
            }
            String expDir=""String_Node_Str"";
            if (expPath.contains(""String_Node_Str"")) {
              expDir=expPath.substring(0,expPath.lastIndexOf('.'));
              expDir=expDir.replace(""String_Node_Str"",File.separator);
            }
            expPath=expPath.replace(""String_Node_Str"",File.separator);
            File cdir=new File(outDir.getAbsolutePath() + File.separator + expDir);
            Path.createDirectorySafe(cdir);
            writeFile(handler,Utf8Helper.getBytes(data),outDir.getAbsolutePath() + File.separator + expPath+ ""String_Node_Str"");
          }
        }
      }
    }
  }
  int flaSwfVersion=swf.version > flaVersion.maxSwfVersion() ? flaVersion.maxSwfVersion() : swf.version;
  boolean greaterThanCC=flaVersion.ordinal() >= FLAVersion.CC.ordinal();
  StringBuilder publishSettings=new StringBuilder();
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(flaSwfVersion).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(FLAVersion.swfVersionToPlayer(flaSwfVersion)).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(useAS3 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(swf.compression == SWFCompression.NONE ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(swf.compression == SWFCompression.LZMA ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(useNetwork ? 1 : 0).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(xmlString(characterClasses.containsKey(0) ? characterClasses.get(0) : ""String_Node_Str"")).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  if (greaterThanCC) {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
 else {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  if (!greaterThanCC) {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  String publishSettingsStr=publishSettings.toString();
  if (compressed) {
    final String domDocumentF=domDocumentStr;
    final String publishSettingsF=publishSettingsStr;
    final String outfileF=outfile;
    new RetryTask(() -> {
      try (ZipOutputStream out=new ZipOutputStream(new FileOutputStream(outfileF))){
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(domDocumentF));
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(publishSettingsF));
        for (        String fileName : files.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(files.get(fileName));
        }
        for (        String fileName : datfiles.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(datfiles.get(fileName));
        }
      }
     }
,handler).run();
  }
 else {
    Path.createDirectorySafe(outDir);
    writeFile(handler,Utf8Helper.getBytes(domDocumentStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    writeFile(handler,Utf8Helper.getBytes(publishSettingsStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    File libraryDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    libraryDir.mkdir();
    File binDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    binDir.mkdir();
    for (    String fileName : files.keySet()) {
      writeFile(handler,files.get(fileName),libraryDir.getAbsolutePath() + File.separator + fileName);
    }
    for (    String fileName : datfiles.keySet()) {
      writeFile(handler,datfiles.get(fileName),binDir.getAbsolutePath() + File.separator + fileName);
    }
    writeFile(handler,Utf8Helper.getBytes(""String_Node_Str""),outfile);
  }
  if (useAS3) {
    try {
      ScriptExportSettings scriptExportSettings=new ScriptExportSettings(ScriptExportMode.AS,false);
      swf.exportActionScript(handler,Path.combine(outDir.getAbsolutePath(),""String_Node_Str""),scriptExportSettings,parallel,null);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}","public static void convertSWF(AbortRetryIgnoreHandler handler,SWF swf,String swfFileName,String outfile,boolean compressed,String generator,String generatorVerName,String generatorVersion,boolean parallel,FLAVersion flaVersion) throws IOException, InterruptedException {
  FileAttributesTag fa=swf.getFileAttributes();
  boolean useAS3=false;
  boolean useNetwork=false;
  if (fa != null) {
    useAS3=fa.actionScript3;
    useNetwork=fa.useNetwork;
  }
  if (!useAS3 && flaVersion.minASVersion() > 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + flaVersion + ""String_Node_Str"");
  }
  File file=new File(outfile);
  File outDir=file.getParentFile();
  Path.createDirectorySafe(outDir);
  StringBuilder domDocument=new StringBuilder();
  String baseName=swfFileName;
  File f=new File(baseName);
  baseName=f.getName();
  if (baseName.contains(""String_Node_Str"")) {
    baseName=baseName.substring(0,baseName.lastIndexOf('.'));
  }
  final HashMap<String,byte[]> files=new HashMap<>();
  final HashMap<String,byte[]> datfiles=new HashMap<>();
  HashMap<Integer,CharacterTag> characters=getCharacters(swf.tags);
  List<Integer> nonLibraryShapes=getNonLibraryShapes(swf.tags,characters);
  Map<Integer,String> characterClasses=getCharacterClasses(swf.tags);
  Map<Integer,String> characterVariables=getCharacterVariables(swf.tags);
  String backgroundColor=""String_Node_Str"";
  SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
  if (setBgColorTag != null) {
    backgroundColor=setBgColorTag.backgroundColor.toHexRGB();
  }
  domDocument.append(""String_Node_Str"").append(flaVersion.xflVersion()).append(""String_Node_Str"").append(generator).append(""String_Node_Str"").append(generatorVerName).append(""String_Node_Str"").append(generatorVersion).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append(backgroundColor).append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"").append((int)swf.frameRate).append(""String_Node_Str"");
  double width=twipToPixel(swf.displayRect.getWidth());
  double height=twipToPixel(swf.displayRect.getHeight());
  if (Double.compare(width,550) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(width)).append(""String_Node_Str"");
  }
  if (Double.compare(height,400) != 0) {
    domDocument.append(""String_Node_Str"").append(doubleToString(height)).append(""String_Node_Str"");
  }
  domDocument.append(""String_Node_Str"");
  convertFonts(swf.tags,domDocument);
  convertLibrary(swf,characterVariables,characterClasses,nonLibraryShapes,backgroundColor,swf.tags,characters,files,datfiles,flaVersion,domDocument);
  domDocument.append(""String_Node_Str"");
  domDocument.append(convertTimeline(0,nonLibraryShapes,backgroundColor,swf.tags,swf.tags,characters,""String_Node_Str"",flaVersion,files));
  domDocument.append(""String_Node_Str"");
  domDocument.append(""String_Node_Str"");
  String domDocumentStr=prettyFormatXML(domDocument.toString());
  for (  Tag t : swf.tags) {
    if (t instanceof DoInitActionTag) {
      DoInitActionTag dia=(DoInitActionTag)t;
      int chid=dia.getCharacterId();
      if (characters.containsKey(chid)) {
        if (characters.get(chid) instanceof DefineSpriteTag) {
          DefineSpriteTag sprite=(DefineSpriteTag)characters.get(chid);
          if (sprite.subTags.isEmpty()) {
            String data=convertActionScript(dia);
            String expName=dia.getSwf().getExportName(dia.spriteId);
            expName=expName != null ? expName : ""String_Node_Str"";
            String expPath=expName;
            final String prefix=""String_Node_Str"";
            if (expPath.startsWith(prefix)) {
              expPath=expPath.substring(prefix.length());
            }
            String expDir=""String_Node_Str"";
            if (expPath.contains(""String_Node_Str"")) {
              expDir=expPath.substring(0,expPath.lastIndexOf('.'));
              expDir=expDir.replace(""String_Node_Str"",File.separator);
            }
            expPath=expPath.replace(""String_Node_Str"",File.separator);
            File cdir=new File(outDir.getAbsolutePath() + File.separator + expDir);
            Path.createDirectorySafe(cdir);
            writeFile(handler,Utf8Helper.getBytes(data),outDir.getAbsolutePath() + File.separator + expPath+ ""String_Node_Str"");
          }
        }
      }
    }
  }
  int flaSwfVersion=swf.version > flaVersion.maxSwfVersion() ? flaVersion.maxSwfVersion() : swf.version;
  boolean greaterThanCC=flaVersion.ordinal() >= FLAVersion.CC.ordinal();
  StringBuilder publishSettings=new StringBuilder();
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(greaterThanCC ? ""String_Node_Str"" : ""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(baseName).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(flaSwfVersion).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(FLAVersion.swfVersionToPlayer(flaSwfVersion)).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(useAS3 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(swf.compression == SWFCompression.NONE ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(swf.compression == SWFCompression.LZMA ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(useNetwork ? 1 : 0).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(xmlString(characterClasses.containsKey(0) ? characterClasses.get(0) : ""String_Node_Str"")).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  if (greaterThanCC) {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
 else {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  if (!greaterThanCC) {
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
    publishSettings.append(""String_Node_Str"");
  }
  publishSettings.append(""String_Node_Str"");
  publishSettings.append(""String_Node_Str"");
  String publishSettingsStr=publishSettings.toString();
  if (compressed) {
    final String domDocumentF=domDocumentStr;
    final String publishSettingsF=publishSettingsStr;
    final String outfileF=outfile;
    new RetryTask(() -> {
      try (ZipOutputStream out=new ZipOutputStream(new FileOutputStream(outfileF))){
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(domDocumentF));
        out.putNextEntry(new ZipEntry(""String_Node_Str""));
        out.write(Utf8Helper.getBytes(publishSettingsF));
        for (        String fileName : files.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(files.get(fileName));
        }
        for (        String fileName : datfiles.keySet()) {
          out.putNextEntry(new ZipEntry(""String_Node_Str"" + fileName));
          out.write(datfiles.get(fileName));
        }
      }
     }
,handler).run();
  }
 else {
    Path.createDirectorySafe(outDir);
    writeFile(handler,Utf8Helper.getBytes(domDocumentStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    writeFile(handler,Utf8Helper.getBytes(publishSettingsStr),outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    File libraryDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    libraryDir.mkdir();
    File binDir=new File(outDir.getAbsolutePath() + File.separator + ""String_Node_Str"");
    binDir.mkdir();
    for (    String fileName : files.keySet()) {
      writeFile(handler,files.get(fileName),libraryDir.getAbsolutePath() + File.separator + fileName);
    }
    for (    String fileName : datfiles.keySet()) {
      writeFile(handler,datfiles.get(fileName),binDir.getAbsolutePath() + File.separator + fileName);
    }
    writeFile(handler,Utf8Helper.getBytes(""String_Node_Str""),outfile);
  }
  if (useAS3) {
    try {
      ScriptExportSettings scriptExportSettings=new ScriptExportSettings(ScriptExportMode.AS,false);
      swf.exportActionScript(handler,Path.combine(outDir.getAbsolutePath(),""String_Node_Str""),scriptExportSettings,parallel,null);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}",0.9951198584222664
61482,"public void createAndShowTempSwf(TreeItem tagObj){
  SWF swf=null;
  try {
    if (tempFile != null) {
      tempFile.delete();
    }
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempFile.deleteOnExit();
    Color backgroundColor=View.getSwfBackgroundColor();
    if (tagObj instanceof Tag) {
      Tag tag=(Tag)tagObj;
      swf=tag.getSwf();
      if (tag instanceof FontTag) {
        backgroundColor=View.getDefaultBackgroundColor();
      }
    }
 else     if (tagObj instanceof Frame) {
      Frame fn=(Frame)tagObj;
      swf=fn.getSwf();
      if (fn.timeline.timelined == swf) {
        for (        Tag t : swf.tags) {
          if (t instanceof SetBackgroundColorTag) {
            backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
            break;
          }
        }
      }
    }
    int frameCount=1;
    float frameRate=swf.frameRate;
    HashMap<Integer,VideoFrameTag> videoFrames=new HashMap<>();
    if (tagObj instanceof DefineVideoStreamTag) {
      DefineVideoStreamTag vs=(DefineVideoStreamTag)tagObj;
      SWF.populateVideoFrames(vs.getCharacterId(),swf.tags,videoFrames);
      frameCount=videoFrames.size();
    }
    List<SoundStreamBlockTag> soundFrames=new ArrayList<>();
    if (tagObj instanceof SoundStreamHeadTypeTag) {
      soundFrames=((SoundStreamHeadTypeTag)tagObj).getBlocks();
      frameCount=soundFrames.size();
    }
    if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
      frameRate=MainPanel.MORPH_SHAPE_ANIMATION_FRAME_RATE;
      frameCount=(int)(MainPanel.MORPH_SHAPE_ANIMATION_LENGTH * frameRate);
    }
    if (tagObj instanceof DefineSoundTag) {
      frameCount=1;
    }
    if (tagObj instanceof DefineSpriteTag) {
      frameCount=((DefineSpriteTag)tagObj).frameCount;
    }
    byte[] data;
    try (ByteArrayOutputStream baos=new ByteArrayOutputStream()){
      SWFOutputStream sos2=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
      RECT outrect=new RECT(swf.displayRect);
      if (tagObj instanceof FontTag) {
        outrect.Xmin=0;
        outrect.Ymin=0;
        outrect.Xmax=FontTag.PREVIEWSIZE * 20;
        outrect.Ymax=FontTag.PREVIEWSIZE * 20;
      }
      int width=outrect.getWidth();
      int height=outrect.getHeight();
      sos2.writeRECT(outrect);
      sos2.writeFIXED8(frameRate);
      sos2.writeUI16(frameCount);
      new SetBackgroundColorTag(swf,new RGB(backgroundColor)).writeTag(sos2);
      if (tagObj instanceof Frame) {
        Frame fn=(Frame)tagObj;
        Timelined parent=fn.timeline.timelined;
        List<Tag> subs=fn.timeline.tags;
        List<Integer> doneCharacters=new ArrayList<>();
        int frameCnt=0;
        for (        Tag t : subs) {
          if (t instanceof ShowFrameTag) {
            frameCnt++;
            continue;
          }
          if (frameCnt > fn.frame) {
            break;
          }
          if (t instanceof DoActionTag || t instanceof DoInitActionTag) {
            continue;
          }
          Set<Integer> needed=new HashSet<>();
          t.getNeededCharactersDeep(needed);
          for (          int n : needed) {
            if (!doneCharacters.contains(n)) {
              classicTag(swf.getCharacter(n)).writeTag(sos2);
              doneCharacters.add(n);
            }
          }
          if (t instanceof CharacterTag) {
            int characterId=((CharacterTag)t).getCharacterId();
            if (!doneCharacters.contains(characterId)) {
              doneCharacters.add(((CharacterTag)t).getCharacterId());
            }
          }
          classicTag(t).writeTag(sos2);
          if (parent != null) {
            if (t instanceof PlaceObjectTypeTag) {
              PlaceObjectTypeTag pot=(PlaceObjectTypeTag)t;
              int chid=pot.getCharacterId();
              int depth=pot.getDepth();
              MATRIX mat=pot.getMatrix();
              if (mat == null) {
                mat=new MATRIX();
              }
              mat=Helper.deepCopy(mat);
              RECT r=parent.getRect();
              mat.translateX+=width / 2 - r.getWidth() / 2;
              mat.translateY+=height / 2 - r.getHeight() / 2;
              new PlaceObject2Tag(swf,false,false,false,false,false,true,false,true,depth,chid,mat,null,0,null,0,null).writeTag(sos2);
            }
          }
        }
        new ShowFrameTag(swf).writeTag(sos2);
      }
 else {
        boolean isSprite=false;
        if (tagObj instanceof DefineSpriteTag) {
          isSprite=true;
        }
        int chtId=0;
        if (tagObj instanceof CharacterTag) {
          chtId=((CharacterTag)tagObj).getCharacterId();
        }
        if (tagObj instanceof DefineBitsTag) {
          JPEGTablesTag jtt=swf.getJtt();
          if (jtt != null) {
            jtt.writeTag(sos2);
          }
        }
 else         if (tagObj instanceof AloneTag) {
        }
 else {
          Set<Integer> needed=new HashSet<>();
          ((Tag)tagObj).getNeededCharactersDeep(needed);
          for (          int n : needed) {
            if (isSprite && chtId == n) {
              continue;
            }
            CharacterTag characterTag=swf.getCharacter(n);
            if (characterTag instanceof DefineBitsTag) {
              JPEGTablesTag jtt=swf.getJtt();
              if (jtt != null) {
                jtt.writeTag(sos2);
              }
            }
            classicTag(characterTag).writeTag(sos2);
          }
        }
        classicTag((Tag)tagObj).writeTag(sos2);
        MATRIX mat=new MATRIX();
        mat.hasRotate=false;
        mat.hasScale=false;
        mat.translateX=0;
        mat.translateY=0;
        if (tagObj instanceof BoundedTag) {
          RECT r=((BoundedTag)tagObj).getRect();
          mat.translateX=-r.Xmin;
          mat.translateY=-r.Ymin;
          mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
          mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
        }
 else {
          mat.translateX=width / 4;
          mat.translateY=height / 4;
        }
        if (tagObj instanceof FontTag) {
          FontTag ft=(FontTag)classicTag((Tag)tagObj);
          int countGlyphsTotal=ft.getGlyphShapeTable().size();
          int countGlyphs=Math.min(SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW,countGlyphsTotal);
          int fontId=ft.getFontId();
          int cols=(int)Math.ceil(Math.sqrt(countGlyphs));
          int rows=(int)Math.ceil(((float)countGlyphs) / ((float)cols));
          if (rows == 0) {
            rows=1;
            cols=1;
          }
          int x=0;
          int y=0;
          int firstGlyphIndex=fontPageNum * SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW;
          countGlyphs=Math.min(SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW,countGlyphsTotal - firstGlyphIndex);
          List<SHAPE> shapes=ft.getGlyphShapeTable();
          int maxw=0;
          for (int f=firstGlyphIndex; f < firstGlyphIndex + countGlyphs; f++) {
            RECT b=shapes.get(f).getBounds();
            if (b.Xmin == Integer.MAX_VALUE) {
              continue;
            }
            if (b.Ymin == Integer.MAX_VALUE) {
              continue;
            }
            int w=(int)(b.getWidth() / ft.getDivider());
            if (w > maxw) {
              maxw=w;
            }
            x++;
          }
          x=0;
          int BORDER=3 * 20;
          int textHeight=height / rows;
          while (maxw * textHeight / 1024.0 > width / cols - 2 * BORDER) {
            textHeight--;
          }
          MATRIX tmat=new MATRIX();
          for (int f=firstGlyphIndex; f < firstGlyphIndex + countGlyphs; f++) {
            if (x >= cols) {
              x=0;
              y++;
            }
            List<TEXTRECORD> rec=new ArrayList<>();
            TEXTRECORD tr=new TEXTRECORD();
            RECT b=shapes.get(f).getBounds();
            int xmin=b.Xmin == Integer.MAX_VALUE ? 0 : (int)(b.Xmin / ft.getDivider());
            xmin*=textHeight / 1024.0;
            int ymin=b.Ymin == Integer.MAX_VALUE ? 0 : (int)(b.Ymin / ft.getDivider());
            ymin*=textHeight / 1024.0;
            int w=(int)(b.getWidth() / ft.getDivider());
            w*=textHeight / 1024.0;
            int h=(int)(b.getHeight() / ft.getDivider());
            h*=textHeight / 1024.0;
            tr.fontId=fontId;
            tr.styleFlagsHasFont=true;
            tr.textHeight=textHeight;
            tr.xOffset=-xmin;
            tr.yOffset=0;
            tr.styleFlagsHasXOffset=true;
            tr.styleFlagsHasYOffset=true;
            tr.glyphEntries=new ArrayList<>(1);
            tr.styleFlagsHasColor=true;
            tr.textColor=new RGB(0,0,0);
            GLYPHENTRY ge=new GLYPHENTRY();
            double ga=ft.getGlyphAdvance(f);
            int cw=ga == -1 ? w : (int)(ga / ft.getDivider() * textHeight / 1024.0);
            ge.glyphAdvance=0;
            ge.glyphIndex=f;
            tr.glyphEntries.add(ge);
            rec.add(tr);
            tmat.translateX=x * width / cols + width / cols / 2 - w / 2;
            tmat.translateY=y * height / rows + height / rows / 2;
            new DefineTextTag(swf,999 + f,new RECT(0,cw,ymin,ymin + h),new MATRIX(),rec).writeTag(sos2);
            new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1 + f,999 + f,tmat,null,0,null,0,null).writeTag(sos2);
            x++;
          }
          new ShowFrameTag(swf).writeTag(sos2);
        }
 else         if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
          new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          for (int ratio=0; ratio < 65536; ratio+=65536 / frameCount) {
            new PlaceObject2Tag(swf,false,false,false,true,false,true,false,true,1,chtId,mat,null,ratio,null,0,null).writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else         if (tagObj instanceof SoundStreamHeadTypeTag) {
          for (          SoundStreamBlockTag blk : soundFrames) {
            blk.writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else         if (tagObj instanceof DefineSoundTag) {
          ExportAssetsTag ea=new ExportAssetsTag(swf);
          DefineSoundTag ds=(DefineSoundTag)tagObj;
          ea.tags.add(ds.soundId);
          ea.names.add(""String_Node_Str"");
          ea.writeTag(sos2);
          List<Action> actions;
          DoActionTag doa;
          doa=new DoActionTag(swf,null);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
        }
 else         if (tagObj instanceof DefineVideoStreamTag) {
          new PlaceObject2Tag(swf,false,false,false,false,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          List<VideoFrameTag> frs=new ArrayList<>(videoFrames.values());
          Collections.sort(frs,new Comparator<VideoFrameTag>(){
            @Override public int compare(            VideoFrameTag o1,            VideoFrameTag o2){
              return o1.frameNum - o2.frameNum;
            }
          }
);
          boolean first=true;
          int ratio=0;
          for (          VideoFrameTag f : frs) {
            if (!first) {
              ratio++;
              new PlaceObject2Tag(swf,false,false,false,true,false,false,false,true,1,0,null,null,ratio,null,0,null).writeTag(sos2);
            }
            f.writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
            first=false;
          }
        }
 else         if (tagObj instanceof DefineSpriteTag) {
          DefineSpriteTag s=(DefineSpriteTag)tagObj;
          Tag lastTag=null;
          for (          Tag t : s.subTags) {
            if (t instanceof EndTag) {
              break;
            }
 else             if (t instanceof PlaceObjectTypeTag) {
              PlaceObjectTypeTag pt=(PlaceObjectTypeTag)t;
              MATRIX m=pt.getMatrix();
              MATRIX m2=new Matrix(m).preConcatenate(new Matrix(mat)).toMATRIX();
              pt.writeTagWithMatrix(sos2,m2);
              lastTag=t;
            }
 else {
              t.writeTag(sos2);
              lastTag=t;
            }
          }
          if (!s.subTags.isEmpty() && (lastTag != null) && (!(lastTag instanceof ShowFrameTag))) {
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else {
          new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
        }
      }
      new EndTag(swf).writeTag(sos2);
      data=baos.toByteArray();
    }
     try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
      SWFOutputStream sos=new SWFOutputStream(fos,Math.max(10,swf.version));
      sos.write(""String_Node_Str"".getBytes());
      sos.write(swf.version);
      sos.writeUI32(sos.getPos() + data.length + 4);
      sos.write(data);
      fos.flush();
    }
     if (flashPanel != null) {
      flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,frameRate);
    }
    showFlashViewerPanel();
  }
 catch (  IOException|ActionParseException ex) {
    Logger.getLogger(PreviewPanel.class.getName()).log(Level.SEVERE,null,ex);
  }
}","public void createAndShowTempSwf(TreeItem tagObj){
  SWF swf=null;
  try {
    if (tempFile != null) {
      tempFile.delete();
    }
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempFile.deleteOnExit();
    Color backgroundColor=View.getSwfBackgroundColor();
    if (tagObj instanceof Tag) {
      Tag tag=(Tag)tagObj;
      swf=tag.getSwf();
      if (tag instanceof FontTag) {
        backgroundColor=View.getDefaultBackgroundColor();
      }
    }
 else     if (tagObj instanceof Frame) {
      Frame fn=(Frame)tagObj;
      swf=fn.getSwf();
      if (fn.timeline.timelined == swf) {
        SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
        if (setBgColorTag != null) {
          backgroundColor=setBgColorTag.backgroundColor.toColor();
        }
      }
    }
    int frameCount=1;
    float frameRate=swf.frameRate;
    HashMap<Integer,VideoFrameTag> videoFrames=new HashMap<>();
    if (tagObj instanceof DefineVideoStreamTag) {
      DefineVideoStreamTag vs=(DefineVideoStreamTag)tagObj;
      SWF.populateVideoFrames(vs.getCharacterId(),swf.tags,videoFrames);
      frameCount=videoFrames.size();
    }
    List<SoundStreamBlockTag> soundFrames=new ArrayList<>();
    if (tagObj instanceof SoundStreamHeadTypeTag) {
      soundFrames=((SoundStreamHeadTypeTag)tagObj).getBlocks();
      frameCount=soundFrames.size();
    }
    if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
      frameRate=MainPanel.MORPH_SHAPE_ANIMATION_FRAME_RATE;
      frameCount=(int)(MainPanel.MORPH_SHAPE_ANIMATION_LENGTH * frameRate);
    }
    if (tagObj instanceof DefineSoundTag) {
      frameCount=1;
    }
    if (tagObj instanceof DefineSpriteTag) {
      frameCount=((DefineSpriteTag)tagObj).frameCount;
    }
    byte[] data;
    try (ByteArrayOutputStream baos=new ByteArrayOutputStream()){
      SWFOutputStream sos2=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
      RECT outrect=new RECT(swf.displayRect);
      if (tagObj instanceof FontTag) {
        outrect.Xmin=0;
        outrect.Ymin=0;
        outrect.Xmax=FontTag.PREVIEWSIZE * 20;
        outrect.Ymax=FontTag.PREVIEWSIZE * 20;
      }
      int width=outrect.getWidth();
      int height=outrect.getHeight();
      sos2.writeRECT(outrect);
      sos2.writeFIXED8(frameRate);
      sos2.writeUI16(frameCount);
      FileAttributesTag fa=swf.getFileAttributes();
      if (fa != null) {
        fa.writeTag(sos2);
      }
      SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
      if (setBgColorTag == null) {
        setBgColorTag=new SetBackgroundColorTag(swf,new RGB(backgroundColor));
      }
      setBgColorTag.writeTag(sos2);
      if (tagObj instanceof Frame) {
        Frame fn=(Frame)tagObj;
        Timelined parent=fn.timeline.timelined;
        List<Tag> subs=fn.timeline.tags;
        List<Integer> doneCharacters=new ArrayList<>();
        int frameCnt=0;
        for (        Tag t : subs) {
          if (t instanceof FileAttributesTag || t instanceof SetBackgroundColorTag) {
            continue;
          }
          if (t instanceof ShowFrameTag) {
            frameCnt++;
            continue;
          }
          if (frameCnt > fn.frame) {
            break;
          }
          if (t instanceof DoActionTag || t instanceof DoInitActionTag) {
            continue;
          }
          Set<Integer> needed=new HashSet<>();
          t.getNeededCharactersDeep(needed);
          for (          int n : needed) {
            if (!doneCharacters.contains(n)) {
              classicTag(swf.getCharacter(n)).writeTag(sos2);
              doneCharacters.add(n);
            }
          }
          if (t instanceof CharacterTag) {
            int characterId=((CharacterTag)t).getCharacterId();
            if (!doneCharacters.contains(characterId)) {
              doneCharacters.add(((CharacterTag)t).getCharacterId());
            }
          }
          classicTag(t).writeTag(sos2);
          if (parent != null) {
            if (t instanceof PlaceObjectTypeTag) {
              PlaceObjectTypeTag pot=(PlaceObjectTypeTag)t;
              int chid=pot.getCharacterId();
              int depth=pot.getDepth();
              MATRIX mat=pot.getMatrix();
              if (mat == null) {
                mat=new MATRIX();
              }
              mat=Helper.deepCopy(mat);
              RECT r=parent.getRect();
              mat.translateX+=width / 2 - r.getWidth() / 2;
              mat.translateY+=height / 2 - r.getHeight() / 2;
              new PlaceObject2Tag(swf,false,false,false,false,false,true,false,true,depth,chid,mat,null,0,null,0,null).writeTag(sos2);
            }
          }
        }
        new ShowFrameTag(swf).writeTag(sos2);
      }
 else {
        boolean isSprite=false;
        if (tagObj instanceof DefineSpriteTag) {
          isSprite=true;
        }
        int chtId=0;
        if (tagObj instanceof CharacterTag) {
          chtId=((CharacterTag)tagObj).getCharacterId();
        }
        if (tagObj instanceof DefineBitsTag) {
          JPEGTablesTag jtt=swf.getJtt();
          if (jtt != null) {
            jtt.writeTag(sos2);
          }
        }
 else         if (tagObj instanceof AloneTag) {
        }
 else {
          Set<Integer> needed=new HashSet<>();
          ((Tag)tagObj).getNeededCharactersDeep(needed);
          for (          int n : needed) {
            if (isSprite && chtId == n) {
              continue;
            }
            CharacterTag characterTag=swf.getCharacter(n);
            if (characterTag instanceof DefineBitsTag) {
              JPEGTablesTag jtt=swf.getJtt();
              if (jtt != null) {
                jtt.writeTag(sos2);
              }
            }
            classicTag(characterTag).writeTag(sos2);
          }
        }
        classicTag((Tag)tagObj).writeTag(sos2);
        MATRIX mat=new MATRIX();
        mat.hasRotate=false;
        mat.hasScale=false;
        mat.translateX=0;
        mat.translateY=0;
        if (tagObj instanceof BoundedTag) {
          RECT r=((BoundedTag)tagObj).getRect();
          mat.translateX=-r.Xmin;
          mat.translateY=-r.Ymin;
          mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
          mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
        }
 else {
          mat.translateX=width / 4;
          mat.translateY=height / 4;
        }
        if (tagObj instanceof FontTag) {
          FontTag ft=(FontTag)classicTag((Tag)tagObj);
          int countGlyphsTotal=ft.getGlyphShapeTable().size();
          int countGlyphs=Math.min(SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW,countGlyphsTotal);
          int fontId=ft.getFontId();
          int cols=(int)Math.ceil(Math.sqrt(countGlyphs));
          int rows=(int)Math.ceil(((float)countGlyphs) / ((float)cols));
          if (rows == 0) {
            rows=1;
            cols=1;
          }
          int x=0;
          int y=0;
          int firstGlyphIndex=fontPageNum * SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW;
          countGlyphs=Math.min(SHAPERECORD.MAX_CHARACTERS_IN_FONT_PREVIEW,countGlyphsTotal - firstGlyphIndex);
          List<SHAPE> shapes=ft.getGlyphShapeTable();
          int maxw=0;
          for (int f=firstGlyphIndex; f < firstGlyphIndex + countGlyphs; f++) {
            RECT b=shapes.get(f).getBounds();
            if (b.Xmin == Integer.MAX_VALUE) {
              continue;
            }
            if (b.Ymin == Integer.MAX_VALUE) {
              continue;
            }
            int w=(int)(b.getWidth() / ft.getDivider());
            if (w > maxw) {
              maxw=w;
            }
            x++;
          }
          x=0;
          int BORDER=3 * 20;
          int textHeight=height / rows;
          while (maxw * textHeight / 1024.0 > width / cols - 2 * BORDER) {
            textHeight--;
          }
          MATRIX tmat=new MATRIX();
          for (int f=firstGlyphIndex; f < firstGlyphIndex + countGlyphs; f++) {
            if (x >= cols) {
              x=0;
              y++;
            }
            List<TEXTRECORD> rec=new ArrayList<>();
            TEXTRECORD tr=new TEXTRECORD();
            RECT b=shapes.get(f).getBounds();
            int xmin=b.Xmin == Integer.MAX_VALUE ? 0 : (int)(b.Xmin / ft.getDivider());
            xmin*=textHeight / 1024.0;
            int ymin=b.Ymin == Integer.MAX_VALUE ? 0 : (int)(b.Ymin / ft.getDivider());
            ymin*=textHeight / 1024.0;
            int w=(int)(b.getWidth() / ft.getDivider());
            w*=textHeight / 1024.0;
            int h=(int)(b.getHeight() / ft.getDivider());
            h*=textHeight / 1024.0;
            tr.fontId=fontId;
            tr.styleFlagsHasFont=true;
            tr.textHeight=textHeight;
            tr.xOffset=-xmin;
            tr.yOffset=0;
            tr.styleFlagsHasXOffset=true;
            tr.styleFlagsHasYOffset=true;
            tr.glyphEntries=new ArrayList<>(1);
            tr.styleFlagsHasColor=true;
            tr.textColor=new RGB(0,0,0);
            GLYPHENTRY ge=new GLYPHENTRY();
            double ga=ft.getGlyphAdvance(f);
            int cw=ga == -1 ? w : (int)(ga / ft.getDivider() * textHeight / 1024.0);
            ge.glyphAdvance=0;
            ge.glyphIndex=f;
            tr.glyphEntries.add(ge);
            rec.add(tr);
            tmat.translateX=x * width / cols + width / cols / 2 - w / 2;
            tmat.translateY=y * height / rows + height / rows / 2;
            new DefineTextTag(swf,999 + f,new RECT(0,cw,ymin,ymin + h),new MATRIX(),rec).writeTag(sos2);
            new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1 + f,999 + f,tmat,null,0,null,0,null).writeTag(sos2);
            x++;
          }
          new ShowFrameTag(swf).writeTag(sos2);
        }
 else         if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
          new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          for (int ratio=0; ratio < 65536; ratio+=65536 / frameCount) {
            new PlaceObject2Tag(swf,false,false,false,true,false,true,false,true,1,chtId,mat,null,ratio,null,0,null).writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else         if (tagObj instanceof SoundStreamHeadTypeTag) {
          for (          SoundStreamBlockTag blk : soundFrames) {
            blk.writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else         if (tagObj instanceof DefineSoundTag) {
          ExportAssetsTag ea=new ExportAssetsTag(swf);
          DefineSoundTag ds=(DefineSoundTag)tagObj;
          ea.tags.add(ds.soundId);
          ea.names.add(""String_Node_Str"");
          ea.writeTag(sos2);
          List<Action> actions;
          DoActionTag doa;
          doa=new DoActionTag(swf,null);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          actions=ASMParser.parse(0,false,""String_Node_Str"" + ""String_Node_Str"",swf.version,false);
          doa.setActions(actions);
          doa.writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
        }
 else         if (tagObj instanceof DefineVideoStreamTag) {
          new PlaceObject2Tag(swf,false,false,false,false,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          List<VideoFrameTag> frs=new ArrayList<>(videoFrames.values());
          Collections.sort(frs,new Comparator<VideoFrameTag>(){
            @Override public int compare(            VideoFrameTag o1,            VideoFrameTag o2){
              return o1.frameNum - o2.frameNum;
            }
          }
);
          boolean first=true;
          int ratio=0;
          for (          VideoFrameTag f : frs) {
            if (!first) {
              ratio++;
              new PlaceObject2Tag(swf,false,false,false,true,false,false,false,true,1,0,null,null,ratio,null,0,null).writeTag(sos2);
            }
            f.writeTag(sos2);
            new ShowFrameTag(swf).writeTag(sos2);
            first=false;
          }
        }
 else         if (tagObj instanceof DefineSpriteTag) {
          DefineSpriteTag s=(DefineSpriteTag)tagObj;
          Tag lastTag=null;
          for (          Tag t : s.subTags) {
            if (t instanceof EndTag) {
              break;
            }
 else             if (t instanceof PlaceObjectTypeTag) {
              PlaceObjectTypeTag pt=(PlaceObjectTypeTag)t;
              MATRIX m=pt.getMatrix();
              MATRIX m2=new Matrix(m).preConcatenate(new Matrix(mat)).toMATRIX();
              pt.writeTagWithMatrix(sos2,m2);
              lastTag=t;
            }
 else {
              t.writeTag(sos2);
              lastTag=t;
            }
          }
          if (!s.subTags.isEmpty() && (lastTag != null) && (!(lastTag instanceof ShowFrameTag))) {
            new ShowFrameTag(swf).writeTag(sos2);
          }
        }
 else {
          new PlaceObject2Tag(swf,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null).writeTag(sos2);
          new ShowFrameTag(swf).writeTag(sos2);
        }
      }
      new EndTag(swf).writeTag(sos2);
      data=baos.toByteArray();
    }
     try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
      SWFOutputStream sos=new SWFOutputStream(fos,Math.max(10,swf.version));
      sos.write(""String_Node_Str"".getBytes());
      sos.write(swf.version);
      sos.writeUI32(sos.getPos() + data.length + 4);
      sos.write(data);
      fos.flush();
    }
     if (flashPanel != null) {
      flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,frameRate);
    }
    showFlashViewerPanel();
  }
 catch (  IOException|ActionParseException ex) {
    Logger.getLogger(PreviewPanel.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.978655521169001
61483,"public void showSwf(SWF swf){
  Color backgroundColor=View.getDefaultBackgroundColor();
  for (  Tag t : swf.tags) {
    if (t instanceof SetBackgroundColorTag) {
      backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
      break;
    }
  }
  if (tempFile != null) {
    tempFile.delete();
  }
  try {
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
      swf.saveTo(fos);
    }
     if (swf.isAS3() && Configuration.autoOpenLoadedSWFs.get() && !Configuration.internalFlashViewer.get()&& !DebuggerTools.hasDebugger(swf)) {
      SWF instrSWF;
      try (FileInputStream fis=new FileInputStream(tempFile)){
        instrSWF=new SWF(fis,false,false);
      }
       DebuggerTools.switchDebugger(instrSWF);
      DebuggerTools.injectDebugLoader(instrSWF);
      try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
        instrSWF.saveTo(fos);
      }
     }
    flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,swf.frameRate);
  }
 catch (  IOException iex) {
    Logger.getLogger(PreviewPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",iex);
  }
catch (  InterruptedException ex) {
  }
}","public void showSwf(SWF swf){
  Color backgroundColor=View.getDefaultBackgroundColor();
  SetBackgroundColorTag setBgColorTag=swf.getBackgroundColor();
  if (setBgColorTag != null) {
    backgroundColor=setBgColorTag.backgroundColor.toColor();
  }
  if (tempFile != null) {
    tempFile.delete();
  }
  try {
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
      swf.saveTo(fos);
    }
     if (swf.isAS3() && Configuration.autoOpenLoadedSWFs.get() && !Configuration.internalFlashViewer.get()&& !DebuggerTools.hasDebugger(swf)) {
      SWF instrSWF;
      try (FileInputStream fis=new FileInputStream(tempFile)){
        instrSWF=new SWF(fis,false,false);
      }
       DebuggerTools.switchDebugger(instrSWF);
      DebuggerTools.injectDebugLoader(instrSWF);
      try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(tempFile))){
        instrSWF.saveTo(fos);
      }
     }
    flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,swf.frameRate);
  }
 catch (  IOException iex) {
    Logger.getLogger(PreviewPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",iex);
  }
catch (  InterruptedException ex) {
  }
}",0.9049128367670364
61484,"public String getBreakScriptName(){
  return breakScriptName;
}","public String getBreakScriptName(){
  if (!isPaused()) {
    return ""String_Node_Str"";
  }
  return breakScriptName;
}",0.6961325966850829
61485,"public int getBreakIp(){
  return breakIp;
}","public int getBreakIp(){
  if (!isPaused()) {
    return -1;
  }
  return breakIp;
}",0.6875
61486,"@Override public void connected(DebuggerConnection con){
  clearBreakPoints();
  Main.startWork(AppStrings.translate(""String_Node_Str""),null);
synchronized (this) {
    paused=false;
  }
  Main.getMainFrame().getPanel().updateMenu();
  try {
    con.getMessage(InVersion.class);
  }
 catch (  IOException ex) {
    Logger.getLogger(DebuggerHandler.class.getName()).log(Level.SEVERE,null,ex);
  }
  con.addMessageListener(new DebugMessageListener<InProcessTag>(){
    @Override public void message(    InProcessTag message){
      try {
        con.writeMessage(new OutProcessedTag(con));
      }
 catch (      IOException ex) {
      }
    }
  }
);
  Map<Integer,String> moduleNames=new HashMap<>();
  try {
    int numScript=con.getMessage(InNumScript.class).num;
    for (int i=0; i < numScript; i++) {
      InScript sc=con.getMessage(InScript.class);
      moduleNames.put(sc.module,sc.name);
    }
    modulePaths=new HashMap<>();
    classToModule=new HashMap<>();
    Pattern patAS3=Pattern.compile(""String_Node_Str"");
    for (    int file : moduleNames.keySet()) {
      String name=moduleNames.get(file);
      String[] parts=name.split(""String_Node_Str"");
      Matcher m;
      if ((m=patAS3.matcher(name)).matches()) {
        String clsName=m.group(3);
        String pkg=m.group(2).replace(""String_Node_Str"",""String_Node_Str"");
        name=DottedChain.parse(pkg).add(clsName).toString();
      }
      modulePaths.put(file,name);
      classToModule.put(name,file);
    }
    commands=new DebuggerCommands(con);
    commands.stopWarning();
    commands.setStopOnFault();
    commands.setEnumerateOverride();
    commands.setNotifyFailure();
    commands.setInvokeSetters();
    commands.setSwfLoadNotify();
    commands.setGetterTimeout(1500);
    commands.setSetterTimeout(5000);
    commands.squelch(true);
    swfs=commands.getSwfInfo(1);
    con.sendMessage(new OutGetSwf(con,0),InGetSwf.class);
    InGetSwd iswd=con.sendMessage(new OutGetSwd(con,0),InGetSwd.class);
    boolean isAS3=(Main.getMainFrame().getPanel().getCurrentSwf().isAS3());
    InSetBreakpoint isb=con.getMessage(InSetBreakpoint.class);
synchronized (this) {
      for (int i=0; i < isb.files.size(); i++) {
        String sname=moduleNames.get(isb.files.get(i));
        if (!confirmedPointMap.containsKey(sname)) {
          confirmedPointMap.put(sname,new TreeSet<>());
        }
        if (toAddBPointMap.containsKey(sname)) {
          toAddBPointMap.get(sname).remove(isb.lines.get(i));
          if (toAddBPointMap.get(sname).isEmpty()) {
            toAddBPointMap.remove(sname);
          }
        }
        confirmedPointMap.get(sname).add(isb.lines.get(i));
        Logger.getLogger(DebuggerHandler.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{sname,isb.lines.get(i)});
      }
    }
synchronized (this) {
      connected=true;
    }
    con.addMessageListener(new DebugMessageListener<InAskBreakpoints>(){
      @Override public void message(      InAskBreakpoints message){
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InContinue>(){
      @Override public void message(      InContinue msg){
synchronized (DebuggerHandler.this) {
          paused=false;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        for (        BreakListener bl : breakListeners) {
          bl.doContinue();
        }
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InBreakAt>(){
      @Override public void message(      InBreakAt message){
synchronized (DebuggerHandler.this) {
          paused=true;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        String newBreakScriptName=""String_Node_Str"";
        if (modulePaths.containsKey(message.file)) {
          newBreakScriptName=modulePaths.get(message.file);
        }
 else {
          Logger.getLogger(DebuggerCommands.class.getName()).log(Level.SEVERE,""String_Node_Str"" + message.file);
          return;
        }
        try {
          breakInfo=con.getMessage(InBreakAtExt.class);
          breakReason=con.sendMessage(new OutGetBreakReason(con),InBreakReason.class);
          final String[] reasonNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          String reason=breakReason.reason < reasonNames.length ? reasonNames[breakReason.reason] : reasonNames[0];
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"",new Object[]{newBreakScriptName,message.line,reason});
          sendBreakPoints(false);
synchronized (DebuggerHandler.this) {
            breakScriptName=newBreakScriptName;
            breakIp=message.line;
          }
          if (breakReason.reason == InBreakReason.REASON_SCRIPT_LOADED) {
            if (!Configuration.debugHalt.get()) {
              commands.sendContinue();
              return;
            }
            Main.startWork(AppStrings.translate(""String_Node_Str""),null);
          }
 else {
            Main.startWork(AppStrings.translate(""String_Node_Str"") + newBreakScriptName + ""String_Node_Str""+ message.line+ ""String_Node_Str""+ AppStrings.translate(""String_Node_Str"" + reason),null);
          }
          frame=commands.getFrame(0);
          for (          BreakListener l : breakListeners) {
            l.breakAt(newBreakScriptName,message.line);
          }
        }
 catch (        IOException ex) {
        }
      }
    }
);
    for (    ConnectionListener l : clisteners) {
      l.connected();
    }
    con.addMessageListener(new DebugMessageListener<InTrace>(){
      @Override public void message(      InTrace tr){
        for (        TraceListener l : traceListeners) {
          l.trace(tr.text);
        }
      }
    }
);
    if (!isAS3) {
      Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINER,""String_Node_Str"");
      commands.sendContinue();
    }
  }
 catch (  IOException ex) {
synchronized (this) {
      connected=false;
    }
  }
}","@Override public void connected(DebuggerConnection con){
  clearBreakPoints();
  Main.startWork(AppStrings.translate(""String_Node_Str""),null);
synchronized (this) {
    paused=false;
  }
  Main.getMainFrame().getPanel().updateMenu();
  try {
    con.getMessage(InVersion.class);
  }
 catch (  IOException ex) {
    Logger.getLogger(DebuggerHandler.class.getName()).log(Level.SEVERE,null,ex);
  }
  con.addMessageListener(new DebugMessageListener<InProcessTag>(){
    @Override public void message(    InProcessTag message){
      try {
        con.writeMessage(new OutProcessedTag(con));
      }
 catch (      IOException ex) {
      }
    }
  }
);
  Map<Integer,String> moduleNames=new HashMap<>();
  try {
    int numScript=con.getMessage(InNumScript.class).num;
    for (int i=0; i < numScript; i++) {
      InScript sc=con.getMessage(InScript.class);
      moduleNames.put(sc.module,sc.name);
    }
    modulePaths=new HashMap<>();
    classToModule=new HashMap<>();
    Pattern patAS3=Pattern.compile(""String_Node_Str"");
    for (    int file : moduleNames.keySet()) {
      String name=moduleNames.get(file);
      String[] parts=name.split(""String_Node_Str"");
      Matcher m;
      if ((m=patAS3.matcher(name)).matches()) {
        String clsName=m.group(3);
        String pkg=m.group(2).replace(""String_Node_Str"",""String_Node_Str"");
        name=DottedChain.parse(pkg).add(clsName).toString();
      }
      modulePaths.put(file,name);
      classToModule.put(name,file);
    }
    commands=new DebuggerCommands(con);
    commands.stopWarning();
    commands.setStopOnFault();
    commands.setEnumerateOverride();
    commands.setNotifyFailure();
    commands.setInvokeSetters();
    commands.setSwfLoadNotify();
    commands.setGetterTimeout(1500);
    commands.setSetterTimeout(5000);
    commands.squelch(true);
    swfs=commands.getSwfInfo(1);
    con.sendMessage(new OutGetSwf(con,0),InGetSwf.class);
    InGetSwd iswd=con.sendMessage(new OutGetSwd(con,0),InGetSwd.class);
    boolean isAS3=(Main.getMainFrame().getPanel().getCurrentSwf().isAS3());
    InSetBreakpoint isb=con.getMessage(InSetBreakpoint.class);
synchronized (this) {
      for (int i=0; i < isb.files.size(); i++) {
        String sname=moduleNames.get(isb.files.get(i));
        if (!confirmedPointMap.containsKey(sname)) {
          confirmedPointMap.put(sname,new TreeSet<>());
        }
        if (toAddBPointMap.containsKey(sname)) {
          toAddBPointMap.get(sname).remove(isb.lines.get(i));
          if (toAddBPointMap.get(sname).isEmpty()) {
            toAddBPointMap.remove(sname);
          }
        }
        confirmedPointMap.get(sname).add(isb.lines.get(i));
        Logger.getLogger(DebuggerHandler.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{sname,isb.lines.get(i)});
      }
    }
synchronized (this) {
      connected=true;
    }
    con.addMessageListener(new DebugMessageListener<InAskBreakpoints>(){
      @Override public void message(      InAskBreakpoints message){
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InContinue>(){
      @Override public void message(      InContinue msg){
synchronized (DebuggerHandler.this) {
          paused=false;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        for (        BreakListener bl : breakListeners) {
          bl.doContinue();
        }
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InBreakAt>(){
      @Override public void message(      InBreakAt message){
synchronized (DebuggerHandler.this) {
          paused=true;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        try {
          breakInfo=con.getMessage(InBreakAtExt.class);
          breakReason=con.sendMessage(new OutGetBreakReason(con),InBreakReason.class);
          String newBreakScriptName=""String_Node_Str"";
          if (modulePaths.containsKey(message.file)) {
            newBreakScriptName=modulePaths.get(message.file);
          }
 else           if (breakReason.reason != InBreakReason.REASON_SCRIPT_LOADED) {
            Logger.getLogger(DebuggerCommands.class.getName()).log(Level.SEVERE,""String_Node_Str"" + message.file);
            return;
          }
          final String[] reasonNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          String reason=breakReason.reason < reasonNames.length ? reasonNames[breakReason.reason] : reasonNames[0];
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"",new Object[]{newBreakScriptName,message.line,reason});
          sendBreakPoints(false);
synchronized (DebuggerHandler.this) {
            breakScriptName=newBreakScriptName;
            breakIp=message.line;
          }
          if (breakReason.reason == InBreakReason.REASON_SCRIPT_LOADED) {
            if (!Configuration.debugHalt.get()) {
              commands.sendContinue();
              return;
            }
            Main.startWork(AppStrings.translate(""String_Node_Str""),null);
          }
 else {
            Main.startWork(AppStrings.translate(""String_Node_Str"") + newBreakScriptName + ""String_Node_Str""+ message.line+ ""String_Node_Str""+ AppStrings.translate(""String_Node_Str"" + reason),null);
          }
          frame=commands.getFrame(0);
          for (          BreakListener l : breakListeners) {
            l.breakAt(newBreakScriptName,message.line);
          }
        }
 catch (        IOException ex) {
        }
      }
    }
);
    for (    ConnectionListener l : clisteners) {
      l.connected();
    }
    con.addMessageListener(new DebugMessageListener<InTrace>(){
      @Override public void message(      InTrace tr){
        for (        TraceListener l : traceListeners) {
          l.trace(tr.text);
        }
      }
    }
);
    if (!isAS3) {
      Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINER,""String_Node_Str"");
      con.writeMessage(new OutRewind(con));
      con.writeMessage(new OutPlay(con));
      commands.sendContinue();
    }
  }
 catch (  IOException ex) {
synchronized (this) {
      connected=false;
    }
  }
}",0.8329833629462122
61487,"public static void runDebug(SWF swf){
  String flashVars=""String_Node_Str"";
  String playerLocation=Configuration.playerDebugLocation.get();
  if (playerLocation.isEmpty() || (!new File(playerLocation).exists())) {
    View.showMessageDialog(null,AppStrings.translate(""String_Node_Str""),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    Main.advancedSettings(""String_Node_Str"");
    return;
  }
  if (swf == null) {
    return;
  }
  File tempFile=null;
  try {
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception ex) {
  }
  if (tempFile != null) {
    final File fTempFile=tempFile;
    CancellableWorker instrumentWorker=new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fTempFile))){
          swf.saveTo(fos);
        }
         SWF instrSWF=null;
        try (FileInputStream fis=new FileInputStream(fTempFile)){
          instrSWF=new SWF(fis,false,false);
        }
 catch (        InterruptedException ex) {
          Logger.getLogger(MainFrameMenu.class.getName()).log(Level.SEVERE,null,ex);
        }
        if (instrSWF != null) {
          if (instrSWF.isAS3()) {
            instrSWF.enableDebugging(true,new File(""String_Node_Str""));
          }
 else {
            instrSWF.enableDebugging(false,new File(""String_Node_Str""));
            File swdFile=new File(fTempFile.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
            instrSWF.generateSwdFile(swdFile,getPackBreakPoints(true));
          }
          try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fTempFile))){
            instrSWF.saveTo(fos);
          }
         }
        return null;
      }
      @Override public void workerCancelled(){
        Main.stopWork();
      }
      @Override protected void done(){
synchronized (Main.class) {
          runTempFile=fTempFile;
          runProcessDebug=true;
        }
        Main.stopWork();
        Main.startDebugger();
        runPlayer(AppStrings.translate(""String_Node_Str""),playerLocation,fTempFile.getAbsolutePath(),flashVars);
      }
    }
;
    Main.startWork(AppStrings.translate(""String_Node_Str""),instrumentWorker);
    instrumentWorker.execute();
  }
}","public static void runDebug(SWF swf){
  String flashVars=""String_Node_Str"";
  String playerLocation=Configuration.playerDebugLocation.get();
  if (playerLocation.isEmpty() || (!new File(playerLocation).exists())) {
    View.showMessageDialog(null,AppStrings.translate(""String_Node_Str""),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    Main.advancedSettings(""String_Node_Str"");
    return;
  }
  if (swf == null) {
    return;
  }
  File tempFile=null;
  try {
    tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception ex) {
  }
  if (tempFile != null) {
    final File fTempFile=tempFile;
    CancellableWorker instrumentWorker=new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fTempFile))){
          swf.saveTo(fos);
        }
         SWF instrSWF=null;
        try (FileInputStream fis=new FileInputStream(fTempFile)){
          instrSWF=new SWF(fis,false,false);
        }
 catch (        InterruptedException ex) {
          Logger.getLogger(MainFrameMenu.class.getName()).log(Level.SEVERE,null,ex);
        }
        if (instrSWF != null) {
          if (instrSWF.isAS3() && Configuration.autoOpenLoadedSWFs.get()) {
            DebuggerTools.injectDebugLoader(instrSWF);
          }
          instrSWF.enableDebugging(true,new File(""String_Node_Str""));
          try (OutputStream fos=new BufferedOutputStream(new FileOutputStream(fTempFile))){
            instrSWF.saveTo(fos);
          }
           if (!instrSWF.isAS3()) {
            instrSWF=null;
            try (FileInputStream fis=new FileInputStream(fTempFile)){
              instrSWF=new SWF(fis,false,false);
            }
 catch (            InterruptedException ex) {
              Logger.getLogger(MainFrameMenu.class.getName()).log(Level.SEVERE,null,ex);
            }
            if (instrSWF != null) {
              File swdFile=new File(fTempFile.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
              instrSWF.generateSwdFile(swdFile,getPackBreakPoints(true));
            }
          }
        }
        return null;
      }
      @Override public void workerCancelled(){
        Main.stopWork();
      }
      @Override protected void done(){
synchronized (Main.class) {
          runTempFile=fTempFile;
          runProcessDebug=true;
        }
        Main.stopWork();
        Main.startDebugger();
        runPlayer(AppStrings.translate(""String_Node_Str""),playerLocation,fTempFile.getAbsolutePath(),flashVars);
      }
    }
;
    Main.startWork(AppStrings.translate(""String_Node_Str""),instrumentWorker);
    instrumentWorker.execute();
  }
}",0.8462299623985751
61488,"public static void freeRun(){
synchronized (Main.class) {
    if (runTempFile != null) {
      runTempFile.delete();
      runTempFile=null;
    }
    runProcess=null;
  }
  mainFrame.getPanel().clearDebuggerColors();
  if (runProcessDebug) {
    Main.getDebugHandler().disconnect();
  }
}","public static void freeRun(){
synchronized (Main.class) {
    if (runTempFile != null) {
      runTempFile.delete();
      runTempFile=null;
    }
    runProcess=null;
  }
  if (mainFrame != null && mainFrame.getPanel() != null) {
    mainFrame.getPanel().clearDebuggerColors();
  }
  if (runProcessDebug) {
    Main.getDebugHandler().disconnect();
  }
}",0.8989113530326595
61489,"public void updateComponents(SWF swf){
  this.swf=swf;
  boolean isRunning=Main.isRunning();
  boolean isDebugRunning=Main.isDebugRunning();
  boolean isDebugPaused=Main.isDebugPaused();
  boolean isRunningOrDebugging=isRunning || isDebugRunning;
  boolean swfSelected=swf != null;
  boolean isWorking=Main.isWorking();
  List<ABCContainerTag> abcList=swf != null ? swf.getAbcList() : null;
  boolean hasAbc=swfSelected && abcList != null && !abcList.isEmpty();
  boolean hasDebugger=hasAbc && DebuggerTools.hasDebugger(swf);
  MainPanel mainPanel=mainFrame.getPanel();
  boolean swfLoaded=mainPanel != null ? !mainPanel.getSwfs().isEmpty() : false;
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfLoaded && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfLoaded && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",hasAbc);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",hasAbc);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",!isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",isRunningOrDebugging);
  setPathVisible(""String_Node_Str"",isDebugRunning);
  setMenuEnabled(""String_Node_Str"",isDebugRunning);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
}","public void updateComponents(SWF swf){
  this.swf=swf;
  boolean isRunning=Main.isRunning();
  boolean isDebugRunning=Main.isDebugRunning();
  boolean isDebugPaused=Main.isDebugPaused();
  boolean isRunningOrDebugging=isRunning || isDebugRunning;
  boolean swfSelected=swf != null;
  boolean isWorking=Main.isWorking();
  List<ABCContainerTag> abcList=swf != null ? swf.getAbcList() : null;
  boolean hasAbc=swfSelected && abcList != null && !abcList.isEmpty();
  boolean hasDebugger=hasAbc && DebuggerTools.hasDebugger(swf);
  MainPanel mainPanel=mainFrame.getPanel();
  boolean swfLoaded=mainPanel != null ? !mainPanel.getSwfs().isEmpty() : false;
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfLoaded && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfLoaded && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isWorking);
  setMenuEnabled(""String_Node_Str"",hasAbc);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",swfSelected);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",hasAbc);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",!isWorking);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",swfSelected && !isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",isRunningOrDebugging);
  setMenuEnabled(""String_Node_Str"",isRunningOrDebugging);
  setPathVisible(""String_Node_Str"",isDebugRunning);
  setMenuEnabled(""String_Node_Str"",isDebugRunning);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
  setMenuEnabled(""String_Node_Str"",isDebugPaused);
}",0.9978015535688114
61490,"@Override public void connected(DebuggerConnection con){
  clearBreakPoints();
  Main.startWork(AppStrings.translate(""String_Node_Str""),null);
synchronized (this) {
    paused=false;
  }
  Main.getMainFrame().getPanel().updateMenu();
  enlog(DebuggerHandler.class);
  try {
    con.getMessage(InVersion.class);
  }
 catch (  IOException ex) {
    Logger.getLogger(DebuggerHandler.class.getName()).log(Level.SEVERE,null,ex);
  }
  con.addMessageListener(new DebugMessageListener<InProcessTag>(){
    @Override public void message(    InProcessTag message){
      try {
        con.writeMessage(new OutProcessedTag(con));
      }
 catch (      IOException ex) {
      }
    }
  }
);
  Map<Integer,String> moduleNames=new HashMap<>();
  try {
    int numScript=con.getMessage(InNumScript.class).num;
    for (int i=0; i < numScript; i++) {
      InScript sc=con.getMessage(InScript.class);
      moduleNames.put(sc.module,sc.name);
    }
    modulePaths=new HashMap<>();
    classToModule=new HashMap<>();
    Pattern patAS3=Pattern.compile(""String_Node_Str"");
    for (    int file : moduleNames.keySet()) {
      String name=moduleNames.get(file);
      String[] parts=name.split(""String_Node_Str"");
      Matcher m;
      if ((m=patAS3.matcher(name)).matches()) {
        String clsName=m.group(3);
        String pkg=m.group(2).replace(""String_Node_Str"",""String_Node_Str"");
        name=DottedChain.parse(pkg).add(clsName).toString();
      }
      modulePaths.put(file,name);
      classToModule.put(name,file);
    }
    commands=new DebuggerCommands(con);
    commands.stopWarning();
    commands.setStopOnFault();
    commands.setEnumerateOverride();
    commands.setNotifyFailure();
    commands.setInvokeSetters();
    commands.setSwfLoadNotify();
    commands.setGetterTimeout(1500);
    commands.setSetterTimeout(5000);
    con.wideLines=commands.getOption(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"");
    if (con.wideLines) {
      commands.setOption(""String_Node_Str"",""String_Node_Str"");
    }
    commands.squelch(true);
    swfs=commands.getSwfInfo(1);
    con.sendMessage(new OutGetSwf(con,0),InGetSwf.class);
    InGetSwd iswd=con.sendMessage(new OutGetSwd(con,0),InGetSwd.class);
    boolean isAS3=(Main.getMainFrame().getPanel().getCurrentSwf().isAS3());
    InSetBreakpoint isb=con.getMessage(InSetBreakpoint.class);
synchronized (this) {
      for (int i=0; i < isb.files.size(); i++) {
        String sname=moduleNames.get(isb.files.get(i));
        if (!confirmedPointMap.containsKey(sname)) {
          confirmedPointMap.put(sname,new TreeSet<>());
        }
        if (toAddBPointMap.containsKey(sname)) {
          toAddBPointMap.get(sname).remove(isb.lines.get(i));
          if (toAddBPointMap.get(sname).isEmpty()) {
            toAddBPointMap.remove(sname);
          }
        }
        confirmedPointMap.get(sname).add(isb.lines.get(i));
        Logger.getLogger(DebuggerHandler.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{sname,isb.lines.get(i)});
      }
    }
synchronized (this) {
      connected=true;
    }
    con.addMessageListener(new DebugMessageListener<InAskBreakpoints>(){
      @Override public void message(      InAskBreakpoints message){
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InContinue>(){
      @Override public void message(      InContinue msg){
synchronized (DebuggerHandler.this) {
          paused=false;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        for (        BreakListener bl : breakListeners) {
          bl.doContinue();
        }
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InBreakAt>(){
      @Override public void message(      InBreakAt message){
synchronized (DebuggerHandler.this) {
          paused=true;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        String newBreakScriptName=""String_Node_Str"";
        if (modulePaths.containsKey(message.file)) {
          newBreakScriptName=modulePaths.get(message.file);
        }
        try {
          breakInfo=con.getMessage(InBreakAtExt.class);
          breakReason=con.sendMessage(new OutGetBreakReason(con),InBreakReason.class);
          final String[] reasonNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          String reason=breakReason.reason < reasonNames.length ? reasonNames[breakReason.reason] : reasonNames[0];
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"",new Object[]{newBreakScriptName,message.line,reason});
          sendBreakPoints(false);
synchronized (DebuggerHandler.this) {
            breakScriptName=newBreakScriptName;
            breakIp=message.line;
          }
          if (breakReason.reason == InBreakReason.REASON_SCRIPT_LOADED) {
            if (!Configuration.debugHalt.get()) {
              commands.sendContinue();
              return;
            }
            Main.startWork(AppStrings.translate(""String_Node_Str""),null);
          }
 else {
            Main.startWork(AppStrings.translate(""String_Node_Str"") + newBreakScriptName + ""String_Node_Str""+ message.line+ ""String_Node_Str""+ AppStrings.translate(""String_Node_Str"" + reason),null);
          }
          frame=commands.getFrame(0);
          for (          BreakListener l : breakListeners) {
            l.breakAt(newBreakScriptName,message.line);
          }
        }
 catch (        IOException ex) {
        }
      }
    }
);
    for (    ConnectionListener l : clisteners) {
      l.connected();
    }
    con.addMessageListener(new DebugMessageListener<InTrace>(){
      @Override public void message(      InTrace tr){
        for (        TraceListener l : traceListeners) {
          l.trace(tr.text);
        }
      }
    }
);
    if (!isAS3) {
      Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINER,""String_Node_Str"");
      commands.sendContinue();
    }
  }
 catch (  IOException ex) {
synchronized (this) {
      connected=false;
    }
  }
}","@Override public void connected(DebuggerConnection con){
  clearBreakPoints();
  Main.startWork(AppStrings.translate(""String_Node_Str""),null);
synchronized (this) {
    paused=false;
  }
  Main.getMainFrame().getPanel().updateMenu();
  enlog(DebuggerConnection.class);
  enlog(DebuggerCommands.class);
  enlog(DebuggerHandler.class);
  try {
    con.getMessage(InVersion.class);
  }
 catch (  IOException ex) {
    Logger.getLogger(DebuggerHandler.class.getName()).log(Level.SEVERE,null,ex);
  }
  con.addMessageListener(new DebugMessageListener<InProcessTag>(){
    @Override public void message(    InProcessTag message){
      try {
        con.writeMessage(new OutProcessedTag(con));
      }
 catch (      IOException ex) {
      }
    }
  }
);
  Map<Integer,String> moduleNames=new HashMap<>();
  try {
    int numScript=con.getMessage(InNumScript.class).num;
    for (int i=0; i < numScript; i++) {
      InScript sc=con.getMessage(InScript.class);
      moduleNames.put(sc.module,sc.name);
    }
    modulePaths=new HashMap<>();
    classToModule=new HashMap<>();
    Pattern patAS3=Pattern.compile(""String_Node_Str"");
    for (    int file : moduleNames.keySet()) {
      String name=moduleNames.get(file);
      String[] parts=name.split(""String_Node_Str"");
      Matcher m;
      if ((m=patAS3.matcher(name)).matches()) {
        String clsName=m.group(3);
        String pkg=m.group(2).replace(""String_Node_Str"",""String_Node_Str"");
        name=DottedChain.parse(pkg).add(clsName).toString();
      }
      modulePaths.put(file,name);
      classToModule.put(name,file);
    }
    commands=new DebuggerCommands(con);
    commands.stopWarning();
    commands.setStopOnFault();
    commands.setEnumerateOverride();
    commands.setNotifyFailure();
    commands.setInvokeSetters();
    commands.setSwfLoadNotify();
    commands.setGetterTimeout(1500);
    commands.setSetterTimeout(5000);
    commands.squelch(true);
    swfs=commands.getSwfInfo(1);
    con.sendMessage(new OutGetSwf(con,0),InGetSwf.class);
    InGetSwd iswd=con.sendMessage(new OutGetSwd(con,0),InGetSwd.class);
    boolean isAS3=(Main.getMainFrame().getPanel().getCurrentSwf().isAS3());
    InSetBreakpoint isb=con.getMessage(InSetBreakpoint.class);
synchronized (this) {
      for (int i=0; i < isb.files.size(); i++) {
        String sname=moduleNames.get(isb.files.get(i));
        if (!confirmedPointMap.containsKey(sname)) {
          confirmedPointMap.put(sname,new TreeSet<>());
        }
        if (toAddBPointMap.containsKey(sname)) {
          toAddBPointMap.get(sname).remove(isb.lines.get(i));
          if (toAddBPointMap.get(sname).isEmpty()) {
            toAddBPointMap.remove(sname);
          }
        }
        confirmedPointMap.get(sname).add(isb.lines.get(i));
        Logger.getLogger(DebuggerHandler.class.getName()).log(Level.INFO,""String_Node_Str"",new Object[]{sname,isb.lines.get(i)});
      }
    }
synchronized (this) {
      connected=true;
    }
    con.addMessageListener(new DebugMessageListener<InAskBreakpoints>(){
      @Override public void message(      InAskBreakpoints message){
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InContinue>(){
      @Override public void message(      InContinue msg){
synchronized (DebuggerHandler.this) {
          paused=false;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        for (        BreakListener bl : breakListeners) {
          bl.doContinue();
        }
      }
    }
);
    con.addMessageListener(new DebugMessageListener<InBreakAt>(){
      @Override public void message(      InBreakAt message){
synchronized (DebuggerHandler.this) {
          paused=true;
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"");
        }
        String newBreakScriptName=""String_Node_Str"";
        if (modulePaths.containsKey(message.file)) {
          newBreakScriptName=modulePaths.get(message.file);
        }
 else {
          Logger.getLogger(DebuggerCommands.class.getName()).log(Level.SEVERE,""String_Node_Str"" + message.file);
          return;
        }
        try {
          breakInfo=con.getMessage(InBreakAtExt.class);
          breakReason=con.sendMessage(new OutGetBreakReason(con),InBreakReason.class);
          final String[] reasonNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          String reason=breakReason.reason < reasonNames.length ? reasonNames[breakReason.reason] : reasonNames[0];
          Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINE,""String_Node_Str"",new Object[]{newBreakScriptName,message.line,reason});
          sendBreakPoints(false);
synchronized (DebuggerHandler.this) {
            breakScriptName=newBreakScriptName;
            breakIp=message.line;
          }
          if (breakReason.reason == InBreakReason.REASON_SCRIPT_LOADED) {
            if (!Configuration.debugHalt.get()) {
              commands.sendContinue();
              return;
            }
            Main.startWork(AppStrings.translate(""String_Node_Str""),null);
          }
 else {
            Main.startWork(AppStrings.translate(""String_Node_Str"") + newBreakScriptName + ""String_Node_Str""+ message.line+ ""String_Node_Str""+ AppStrings.translate(""String_Node_Str"" + reason),null);
          }
          frame=commands.getFrame(0);
          for (          BreakListener l : breakListeners) {
            l.breakAt(newBreakScriptName,message.line);
          }
        }
 catch (        IOException ex) {
        }
      }
    }
);
    for (    ConnectionListener l : clisteners) {
      l.connected();
    }
    con.addMessageListener(new DebugMessageListener<InTrace>(){
      @Override public void message(      InTrace tr){
        for (        TraceListener l : traceListeners) {
          l.trace(tr.text);
        }
      }
    }
);
    if (!isAS3) {
      Logger.getLogger(DebuggerHandler.class.getName()).log(Level.FINER,""String_Node_Str"");
      commands.sendContinue();
    }
  }
 catch (  IOException ex) {
synchronized (this) {
      connected=false;
    }
  }
}",0.9667420083952212
61491,"private static void enlog(Class<?> cls){
  Level level=Level.INFO;
  Logger mylog=Logger.getLogger(cls.getName());
  mylog.setLevel(level);
  ConsoleHandler ch=new ConsoleHandler();
  ch.setLevel(level);
  mylog.addHandler(ch);
}","private static void enlog(Class<?> cls){
  Level level=Level.FINEST;
  Logger mylog=Logger.getLogger(cls.getName());
  mylog.setLevel(level);
  ConsoleHandler ch=new ConsoleHandler();
  ch.setLevel(level);
  mylog.addHandler(ch);
}",0.9869565217391304
61492,"public byte[] exportMovie(DefineVideoStreamTag videoStream,MovieExportMode mode) throws IOException {
  SWF swf=videoStream.getSwf();
  HashMap<Integer,VideoFrameTag> frames=new HashMap<>();
  SWF.populateVideoFrames(videoStream.characterID,swf.tags,frames);
  if (frames.isEmpty()) {
    return SWFInputStream.BYTE_ARRAY_EMPTY;
  }
  ByteArrayOutputStream fos=new ByteArrayOutputStream();
  OutputStream tos=fos;
  FLVOutputStream flv=new FLVOutputStream(tos);
  flv.writeHeader(false,true);
  int horizontalAdjustment=0;
  int verticalAdjustment=0;
  for (int i=0; i < frames.size(); i++) {
    VideoFrameTag tag=frames.get(i);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    int frameType=1;
    if ((videoStream.codecID == DefineVideoStreamTag.CODEC_VP6) || (videoStream.codecID == DefineVideoStreamTag.CODEC_VP6_ALPHA)) {
      SWFInputStream sis=new SWFInputStream(swf,tag.videoData.getRangeData());
      if (videoStream.codecID == DefineVideoStreamTag.CODEC_VP6_ALPHA) {
        sis.readUI24(""String_Node_Str"");
      }
      int frameMode=(int)sis.readUB(1,""String_Node_Str"");
      if (frameMode == 0) {
        frameType=1;
      }
 else {
        frameType=2;
      }
      sis.readUB(6,""String_Node_Str"");
      int marker=(int)sis.readUB(1,""String_Node_Str"");
      if (frameMode == 0) {
        int version=(int)sis.readUB(5,""String_Node_Str"");
        int version2=(int)sis.readUB(2,""String_Node_Str"");
        sis.readUB(1,""String_Node_Str"");
        if (marker == 1 || version2 == 0) {
          sis.readUI16(""String_Node_Str"");
        }
        int dim_y=sis.readUI8(""String_Node_Str"");
        int dim_x=sis.readUI8(""String_Node_Str"");
        sis.readUI8(""String_Node_Str"");
        sis.readUI8(""String_Node_Str"");
        horizontalAdjustment=(int)(dim_x * Math.ceil(((double)videoStream.width) / (double)dim_x)) - videoStream.width;
        verticalAdjustment=(int)(dim_y * Math.ceil(((double)videoStream.height) / (double)dim_y)) - videoStream.height;
      }
      SWFOutputStream sos=new SWFOutputStream(baos,swf.version);
      sos.writeUB(4,horizontalAdjustment);
      sos.writeUB(4,verticalAdjustment);
    }
    if (videoStream.codecID == DefineVideoStreamTag.CODEC_SORENSON_H263) {
      SWFInputStream sis=new SWFInputStream(swf,tag.videoData.getRangeData());
      sis.readUB(17,""String_Node_Str"");
      sis.readUB(5,""String_Node_Str"");
      sis.readUB(8,""String_Node_Str"");
      int pictureSize=(int)sis.readUB(3,""String_Node_Str"");
      if (pictureSize == 0) {
        sis.readUB(8,""String_Node_Str"");
        sis.readUB(8,""String_Node_Str"");
      }
      if (pictureSize == 1) {
        sis.readUB(16,""String_Node_Str"");
        sis.readUB(16,""String_Node_Str"");
      }
      int pictureType=(int)sis.readUB(2,""String_Node_Str"");
switch (pictureType) {
case 0:
        frameType=1;
      break;
case 1:
    frameType=2;
  break;
case 2:
frameType=3;
break;
}
}
baos.write(tag.videoData.getRangeData());
flv.writeTag(new FLVTAG((int)Math.floor(i * 1000.0 / swf.frameRate),new VIDEODATA(frameType,videoStream.codecID,baos.toByteArray())));
}
return fos.toByteArray();
}","public byte[] exportMovie(DefineVideoStreamTag videoStream,MovieExportMode mode) throws IOException {
  SWF swf=videoStream.getSwf();
  HashMap<Integer,VideoFrameTag> frames=new HashMap<>();
  SWF.populateVideoFrames(videoStream.characterID,swf.tags,frames);
  if (frames.isEmpty()) {
    return SWFInputStream.BYTE_ARRAY_EMPTY;
  }
  ByteArrayOutputStream fos=new ByteArrayOutputStream();
  OutputStream tos=fos;
  FLVOutputStream flv=new FLVOutputStream(tos);
  flv.writeHeader(false,true);
  int horizontalAdjustment=0;
  int verticalAdjustment=0;
  int[] frameNumArray=Helper.toIntArray(frames.keySet());
  Arrays.sort(frameNumArray);
  for (int i=0; i < frameNumArray.length; i++) {
    VideoFrameTag tag=frames.get(frameNumArray[i]);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    int frameType=1;
    if ((videoStream.codecID == DefineVideoStreamTag.CODEC_VP6) || (videoStream.codecID == DefineVideoStreamTag.CODEC_VP6_ALPHA)) {
      SWFInputStream sis=new SWFInputStream(swf,tag.videoData.getRangeData());
      if (videoStream.codecID == DefineVideoStreamTag.CODEC_VP6_ALPHA) {
        sis.readUI24(""String_Node_Str"");
      }
      int frameMode=(int)sis.readUB(1,""String_Node_Str"");
      if (frameMode == 0) {
        frameType=1;
      }
 else {
        frameType=2;
      }
      sis.readUB(6,""String_Node_Str"");
      int marker=(int)sis.readUB(1,""String_Node_Str"");
      if (frameMode == 0) {
        int version=(int)sis.readUB(5,""String_Node_Str"");
        int version2=(int)sis.readUB(2,""String_Node_Str"");
        sis.readUB(1,""String_Node_Str"");
        if (marker == 1 || version2 == 0) {
          sis.readUI16(""String_Node_Str"");
        }
        int dim_y=sis.readUI8(""String_Node_Str"");
        int dim_x=sis.readUI8(""String_Node_Str"");
        sis.readUI8(""String_Node_Str"");
        sis.readUI8(""String_Node_Str"");
        horizontalAdjustment=(int)(dim_x * Math.ceil(((double)videoStream.width) / (double)dim_x)) - videoStream.width;
        verticalAdjustment=(int)(dim_y * Math.ceil(((double)videoStream.height) / (double)dim_y)) - videoStream.height;
      }
      SWFOutputStream sos=new SWFOutputStream(baos,swf.version);
      sos.writeUB(4,horizontalAdjustment);
      sos.writeUB(4,verticalAdjustment);
    }
    if (videoStream.codecID == DefineVideoStreamTag.CODEC_SORENSON_H263) {
      SWFInputStream sis=new SWFInputStream(swf,tag.videoData.getRangeData());
      sis.readUB(17,""String_Node_Str"");
      sis.readUB(5,""String_Node_Str"");
      sis.readUB(8,""String_Node_Str"");
      int pictureSize=(int)sis.readUB(3,""String_Node_Str"");
      if (pictureSize == 0) {
        sis.readUB(8,""String_Node_Str"");
        sis.readUB(8,""String_Node_Str"");
      }
      if (pictureSize == 1) {
        sis.readUB(16,""String_Node_Str"");
        sis.readUB(16,""String_Node_Str"");
      }
      int pictureType=(int)sis.readUB(2,""String_Node_Str"");
switch (pictureType) {
case 0:
        frameType=1;
      break;
case 1:
    frameType=2;
  break;
case 2:
frameType=3;
break;
}
}
baos.write(tag.videoData.getRangeData());
flv.writeTag(new FLVTAG((int)Math.floor(i * 1000.0 / swf.frameRate),new VIDEODATA(frameType,videoStream.codecID,baos.toByteArray())));
}
return fos.toByteArray();
}",0.979886863607794
61493,"public void generateTraitsPhase2(List<DottedChain> importedClasses,DottedChain pkg,List<GraphTargetItem> items,Trait[] traits,List<Integer> openedNamespaces,SourceGeneratorLocalData localData) throws CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
 else     if (item instanceof InterfaceAVM2Item) {
      traits[k].name_index=traitName(((InterfaceAVM2Item)item).namespace,((InterfaceAVM2Item)item).name);
    }
 else     if (item instanceof ClassAVM2Item) {
      traits[k].name_index=traitName(((ClassAVM2Item)item).namespace,((ClassAVM2Item)item).className);
    }
 else     if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((MethodAVM2Item)item).customNamespace,((MethodAVM2Item)item).namespace,openedNamespaces,localData,((MethodAVM2Item)item).line),((MethodAVM2Item)item).functionName);
    }
 else     if (item instanceof FunctionAVM2Item) {
      traits[k].name_index=traitName(((FunctionAVM2Item)item).namespace,((FunctionAVM2Item)item).functionName);
    }
 else     if (item instanceof ConstAVM2Item) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((ConstAVM2Item)item).customNamespace,((ConstAVM2Item)item).getNamespace(),openedNamespaces,localData,((ConstAVM2Item)item).line),((ConstAVM2Item)item).var);
    }
 else     if (item instanceof SlotAVM2Item) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((SlotAVM2Item)item).customNamespace,((SlotAVM2Item)item).getNamespace(),openedNamespaces,localData,((SlotAVM2Item)item).line),((SlotAVM2Item)item).var);
    }
  }
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof ClassAVM2Item) {
      InstanceInfo instanceInfo=abcIndex.getSelectedAbc().instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(((ClassAVM2Item)item).className,true),((ClassAVM2Item)item).namespace,0),true);
      if (((ClassAVM2Item)item).extendsOp != null) {
        instanceInfo.super_index=typeName(localData,((ClassAVM2Item)item).extendsOp);
      }
 else {
        instanceInfo.super_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,str(""String_Node_Str""),namespace(Namespace.KIND_PACKAGE,""String_Node_Str""),0),true);
      }
      instanceInfo.interfaces=new int[((ClassAVM2Item)item).implementsOp.size()];
      for (int i=0; i < ((ClassAVM2Item)item).implementsOp.size(); i++) {
        instanceInfo.interfaces[i]=superIntName(localData,((ClassAVM2Item)item).implementsOp.get(i));
      }
    }
    if (item instanceof InterfaceAVM2Item) {
      InstanceInfo instanceInfo=abcIndex.getSelectedAbc().instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(((InterfaceAVM2Item)item).name,true),abcIndex.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE,((InterfaceAVM2Item)item).pkg,0,true),0),true);
      instanceInfo.interfaces=new int[((InterfaceAVM2Item)item).superInterfaces.size()];
      for (int i=0; i < ((InterfaceAVM2Item)item).superInterfaces.size(); i++) {
        GraphTargetItem un=((InterfaceAVM2Item)item).superInterfaces.get(i);
        instanceInfo.interfaces[i]=superIntName(localData,un);
      }
    }
  }
}","public void generateTraitsPhase2(List<DottedChain> importedClasses,DottedChain pkg,List<GraphTargetItem> items,Trait[] traits,List<Integer> openedNamespaces,SourceGeneratorLocalData localData) throws CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
    }
 else     if (item instanceof InterfaceAVM2Item) {
      traits[k].name_index=traitName(((InterfaceAVM2Item)item).namespace,((InterfaceAVM2Item)item).name);
    }
 else     if (item instanceof ClassAVM2Item) {
      traits[k].name_index=traitName(((ClassAVM2Item)item).namespace,((ClassAVM2Item)item).className);
    }
 else     if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((MethodAVM2Item)item).customNamespace,((MethodAVM2Item)item).namespace,openedNamespaces,localData,((MethodAVM2Item)item).line),((MethodAVM2Item)item).functionName);
    }
 else     if (item instanceof FunctionAVM2Item) {
      traits[k].name_index=traitName(((FunctionAVM2Item)item).namespace,((FunctionAVM2Item)item).functionName);
    }
 else     if (item instanceof ConstAVM2Item) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((ConstAVM2Item)item).customNamespace,((ConstAVM2Item)item).getNamespace(),openedNamespaces,localData,((ConstAVM2Item)item).line),((ConstAVM2Item)item).var);
    }
 else     if (item instanceof SlotAVM2Item) {
      traits[k].name_index=traitName(genNs(importedClasses,pkg,((SlotAVM2Item)item).customNamespace,((SlotAVM2Item)item).getNamespace(),openedNamespaces,localData,((SlotAVM2Item)item).line),((SlotAVM2Item)item).var);
    }
  }
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof ClassAVM2Item) {
      InstanceInfo instanceInfo=abcIndex.getSelectedAbc().instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(((ClassAVM2Item)item).className,true),((ClassAVM2Item)item).namespace,0),true);
      if (((ClassAVM2Item)item).extendsOp != null) {
        instanceInfo.super_index=typeName(localData,((ClassAVM2Item)item).extendsOp);
      }
 else {
        instanceInfo.super_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,str(""String_Node_Str""),namespace(Namespace.KIND_PACKAGE,""String_Node_Str""),0),true);
      }
      instanceInfo.interfaces=new int[((ClassAVM2Item)item).implementsOp.size()];
      for (int i=0; i < ((ClassAVM2Item)item).implementsOp.size(); i++) {
        instanceInfo.interfaces[i]=superIntName(localData,((ClassAVM2Item)item).implementsOp.get(i));
      }
    }
    if (item instanceof InterfaceAVM2Item) {
      InstanceInfo instanceInfo=abcIndex.getSelectedAbc().instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(((InterfaceAVM2Item)item).name,true),abcIndex.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE,((InterfaceAVM2Item)item).pkg,0,true),0),true);
      instanceInfo.interfaces=new int[((InterfaceAVM2Item)item).superInterfaces.size()];
      for (int i=0; i < ((InterfaceAVM2Item)item).superInterfaces.size(); i++) {
        GraphTargetItem un=((InterfaceAVM2Item)item).superInterfaces.get(i);
        instanceInfo.interfaces[i]=superIntName(localData,un);
      }
    }
  }
}",0.997837837837838
61494,"public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Reference<Integer> classIndex) throws AVM2ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abcIndex.getSelectedAbc().addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
      traits[k].metadata=generateMetadata(((InterfaceAVM2Item)item).metadata);
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abcIndex.getSelectedAbc().addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
      traits[k].metadata=generateMetadata(((ClassAVM2Item)item).metadata);
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      int metadata[]=new int[0];
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
        metadata=generateMetadata(((SlotAVM2Item)item).metadata);
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
        metadata=generateMetadata(((ConstAVM2Item)item).metadata);
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
      traits[k].metadata=metadata;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : ((item instanceof SetterAVM2Item) ? Trait.TRAIT_SETTER : Trait.TRAIT_METHOD);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
      traits[k].metadata=generateMetadata(((MethodAVM2Item)item).metadata);
    }
 else     if (item instanceof FunctionAVM2Item) {
      TraitFunction tf=new TraitFunction();
      tf.slot_id=slot_id++;
      tf.kindType=Trait.TRAIT_FUNCTION;
      ts.traits.add(tf);
      traits[k]=tf;
      traits[k].metadata=generateMetadata(((FunctionAVM2Item)item).metadata);
    }
  }
  return traits;
}","public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Reference<Integer> classIndex) throws AVM2ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abcIndex.getSelectedAbc().addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
      traits[k].metadata=generateMetadata(((InterfaceAVM2Item)item).metadata);
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abcIndex.getSelectedAbc().addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
      traits[k].metadata=generateMetadata(((ClassAVM2Item)item).metadata);
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      int metadata[]=new int[0];
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
        metadata=generateMetadata(((SlotAVM2Item)item).metadata);
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
        metadata=generateMetadata(((ConstAVM2Item)item).metadata);
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
      traits[k].metadata=metadata;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : ((item instanceof SetterAVM2Item) ? Trait.TRAIT_SETTER : Trait.TRAIT_METHOD);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
      traits[k].metadata=generateMetadata(((MethodAVM2Item)item).metadata);
    }
  }
  return traits;
}",0.9610328082435152
61495,"public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,AbcIndexing abc) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<>(),new ArrayList<>(),abc,new ArrayList<>(),new ArrayList<>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item + ""String_Node_Str""+ item.getClass().getName()+ ""String_Node_Str"",0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<>(),new ArrayList<>(),abc,new ArrayList<>(),new ArrayList<>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  DottedChain dname=type.fullTypeName;
  String pkg=dname.getWithoutLast().toRawString();
  String name=dname.getLast();
  AbcIndexing.ClassIndex ci=abc.findClass(new TypeItem(dname));
  if (ci != null) {
    Multiname m=ci.abc.instance_info.get(ci.index).getName(ci.abc.constants);
    if (m != null) {
      Namespace ns=ci.abc.instance_info.get(ci.index).getName(ci.abc.constants).getNamespace(ci.abc.constants);
      String n=m.getName(ci.abc.constants,new ArrayList<DottedChain>(),true);
      String nsn=ns == null ? null : ns.getName(ci.abc.constants).toRawString();
      name_index=abc.getSelectedAbc().constants.getQnameId(n,ns == null ? Namespace.KIND_PACKAGE : ns.kind,nsn,true);
    }
  }
  for (int i=1; i < abc.getSelectedAbc().constants.getMultinameCount(); i++) {
    Multiname mname=abc.getSelectedAbc().constants.getMultiname(i);
    if (mname != null && name.equals(mname.getName(abc.getSelectedAbc().constants,null,true))) {
      if (mname.getNamespace(abc.getSelectedAbc().constants) != null && pkg.equals(mname.getNamespace(abc.getSelectedAbc().constants).getName(abc.getSelectedAbc().constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.isEmpty() && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc.getSelectedAbc()).getName(abc.getSelectedAbc().constants,null,true).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abc.getSelectedAbc().constants.getStringId(name,true),abc.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE,pkg,0,true),0),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    int[] params=new int[atype.params.size()];
    int i=0;
    for (    GraphTargetItem s : atype.params) {
      params[i++]=resolveType(localData,s,abc);
    }
    return abc.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}","public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,AbcIndexing abc) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<>(),new ArrayList<>(),abc,new ArrayList<>(),new ArrayList<>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item + ""String_Node_Str""+ item.getClass().getName()+ ""String_Node_Str"",0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<>(),new ArrayList<>(),abc,new ArrayList<>(),new ArrayList<>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  DottedChain dname=type.fullTypeName;
  DottedChain pkg=dname.getWithoutLast();
  String name=dname.getLast();
  AbcIndexing.ClassIndex ci=abc.findClass(new TypeItem(dname));
  if (ci != null) {
    Multiname m=ci.abc.instance_info.get(ci.index).getName(ci.abc.constants);
    if (m != null) {
      Namespace ns=ci.abc.instance_info.get(ci.index).getName(ci.abc.constants).getNamespace(ci.abc.constants);
      String n=m.getName(ci.abc.constants,new ArrayList<>(),true);
      String nsn=ns == null ? null : ns.getName(ci.abc.constants).toRawString();
      name_index=abc.getSelectedAbc().constants.getQnameId(n,ns == null ? Namespace.KIND_PACKAGE : ns.kind,nsn,true);
    }
  }
  for (int i=1; i < abc.getSelectedAbc().constants.getMultinameCount(); i++) {
    Multiname mname=abc.getSelectedAbc().constants.getMultiname(i);
    if (mname != null && name.equals(mname.getName(abc.getSelectedAbc().constants,null,true))) {
      if (mname.getNamespace(abc.getSelectedAbc().constants) != null && pkg.equals(mname.getNamespace(abc.getSelectedAbc().constants).getName(abc.getSelectedAbc().constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.isEmpty() && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc.getSelectedAbc()).getName(abc.getSelectedAbc().constants,null,true).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abc.getSelectedAbc().constants.getStringId(name,true),abc.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE,pkg,0,true),0),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    int[] params=new int[atype.params.size()];
    int i=0;
    for (    GraphTargetItem s : atype.params) {
      params[i++]=resolveType(localData,s,abc);
    }
    return abc.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}",0.8727327690447401
61496,"public int method(boolean isStatic,int name_index,boolean subMethod,boolean isInterface,List<MethodBody> callStack,DottedChain pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.privateNs=localData.privateNs;
  newlocalData.protectedNs=localData.protectedNs;
  newlocalData.isStatic=isStatic;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abcIndex,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abcIndex,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.add(className).toRawString();
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  String mask=Configuration.registerNameFormat.get();
  mask=mask.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern pat=Pattern.compile(mask);
  for (int round=1; round <= 2; round++) {
    for (    AssignableAVM2Item an : subvariables) {
      if (an instanceof NameAVM2Item) {
        NameAVM2Item n=(NameAVM2Item)an;
        if (n.isDefinition() && !registerNames.contains(n.getVariableName())) {
          if (!needsActivation || (n.getSlotScope() <= 0)) {
            String varName=n.getVariableName();
            Matcher m=pat.matcher(varName);
            if ((round == 1) && (m.matches())) {
              String regIndexStr=m.group(1);
              int regIndex=Integer.parseInt(regIndexStr);
              while (registerNames.size() <= regIndex + 1) {
                String standardName=String.format(mask,registerNames.size() - 1);
                registerNames.add(standardName);
                registerTypes.add(""String_Node_Str"");
                slotNames.add(standardName);
                slotTypes.add(""String_Node_Str"");
              }
              registerNames.set(regIndex,varName);
              registerTypes.set(regIndex,varName);
              slotNames.set(regIndex,varName);
              slotTypes.set(regIndex,varName);
            }
 else             if (round == 2 && !m.matches()) {
              registerNames.add(n.getVariableName());
              registerTypes.add(n.type.toString());
              slotNames.add(n.getVariableName());
              slotTypes.add(n.type.toString());
            }
          }
        }
      }
    }
  }
  int slotScope=subMethod ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      String variableName=n.getVariableName();
      if (variableName != null) {
        boolean isThisOrSuper=variableName.equals(""String_Node_Str"") || variableName.equals(""String_Node_Str"");
        if (!isThisOrSuper && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(variableName));
            n.setSlotScope(slotScope);
          }
        }
 else {
          if (isThisOrSuper) {
            n.setRegNumber(0);
          }
 else {
            n.setRegNumber(registerNames.indexOf(variableName));
          }
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      String variableName=n.getVariableName();
      if (""String_Node_Str"".equals(variableName) || ""String_Node_Str"".equals(variableName) || paramNames.contains(variableName)|| ""String_Node_Str"".equals(variableName)) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int[] param_types=new int[paramTypes.size()];
  ValueKind[] optional=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),name_index,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody(abcIndex.getSelectedAbc(),new Traits(),new byte[0],new ABCException[0]);
    if (needsActivation) {
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(slotNames.get(i),true),abcIndex.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE_INTERNAL,pkg,0,true),0),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<>() : generate(localData,body);
    mbody.method_info=abcIndex.getSelectedAbc().addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abcIndex.getSelectedAbc().constants.getMultiname(tsc.type_index).getNameWithNamespace(abcIndex.getSelectedAbc().constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abcIndex.getSelectedAbc()).getName(abcIndex.getSelectedAbc().constants,null,true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(AVM2Instructions.NewActivation));
      acts.add(ins(AVM2Instructions.Dup));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(AVM2Instructions.PushScope));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      int parentConstMinAC=0;
      AbcIndexing.ClassIndex ci=abcIndex.findClass(new TypeItem(superType));
      if (ci != null) {
        MethodInfo pmi=ci.abc.method_info.get(ci.abc.instance_info.get(ci.index).iinit_index);
        parentConstMinAC=pmi.param_types.length;
        if (pmi.flagHas_optional()) {
          parentConstMinAC-=pmi.optional.length;
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
          mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.ConstructSuper,new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
      mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.PushScope,null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnVoid,null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.PushUndefined,null));
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnValue,null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytesLength();
}
mbody.markOffsets();
mbody.autoFillStats(abcIndex.getSelectedAbc(),initScope,className != null);
abcIndex.getSelectedAbc().addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abcIndex.getSelectedAbc().addMethodInfo(mi);
}
return mindex;
}","public int method(boolean isStatic,int name_index,boolean subMethod,boolean isInterface,List<MethodBody> callStack,DottedChain pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.privateNs=localData.privateNs;
  newlocalData.protectedNs=localData.protectedNs;
  newlocalData.isStatic=isStatic;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abcIndex,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abcIndex,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.add(className).toRawString();
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    registerTypes.add(""String_Node_Str"");
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  String mask=Configuration.registerNameFormat.get();
  mask=mask.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern pat=Pattern.compile(mask);
  for (int round=1; round <= 2; round++) {
    for (    AssignableAVM2Item an : subvariables) {
      if (an instanceof NameAVM2Item) {
        NameAVM2Item n=(NameAVM2Item)an;
        if (n.isDefinition() && !registerNames.contains(n.getVariableName())) {
          if (!needsActivation || (n.getSlotScope() <= 0)) {
            String varName=n.getVariableName();
            Matcher m=pat.matcher(varName);
            if ((round == 1) && (m.matches())) {
              String regIndexStr=m.group(1);
              int regIndex=Integer.parseInt(regIndexStr);
              while (registerNames.size() <= regIndex + 1) {
                String standardName=String.format(mask,registerNames.size() - 1);
                registerNames.add(standardName);
                registerTypes.add(""String_Node_Str"");
                slotNames.add(standardName);
                slotTypes.add(""String_Node_Str"");
              }
              registerNames.set(regIndex,varName);
              registerTypes.set(regIndex,varName);
              slotNames.set(regIndex,varName);
              slotTypes.set(regIndex,varName);
            }
 else             if (round == 2 && !m.matches()) {
              registerNames.add(n.getVariableName());
              registerTypes.add(n.type.toString());
              slotNames.add(n.getVariableName());
              slotTypes.add(n.type.toString());
            }
          }
        }
      }
    }
  }
  int slotScope=subMethod ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      String variableName=n.getVariableName();
      if (variableName != null) {
        boolean isThisOrSuper=variableName.equals(""String_Node_Str"") || variableName.equals(""String_Node_Str"");
        if (!isThisOrSuper && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(variableName));
            n.setSlotScope(slotScope);
          }
        }
 else {
          if (isThisOrSuper) {
            n.setRegNumber(0);
          }
 else {
            n.setRegNumber(registerNames.indexOf(variableName));
          }
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      String variableName=n.getVariableName();
      if (""String_Node_Str"".equals(variableName) || ""String_Node_Str"".equals(variableName) || paramNames.contains(variableName)|| ""String_Node_Str"".equals(variableName)) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int[] param_types=new int[paramTypes.size()];
  ValueKind[] optional=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),name_index,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody(abcIndex.getSelectedAbc(),new Traits(),new byte[0],new ABCException[0]);
    if (needsActivation) {
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abcIndex.getSelectedAbc().constants.getMultinameId(new Multiname(Multiname.QNAME,abcIndex.getSelectedAbc().constants.getStringId(slotNames.get(i),true),abcIndex.getSelectedAbc().constants.getNamespaceId(Namespace.KIND_PACKAGE_INTERNAL,pkg,0,true),0),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<>() : generate(localData,body);
    mbody.method_info=abcIndex.getSelectedAbc().addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abcIndex.getSelectedAbc().constants.getMultiname(tsc.type_index).getNameWithNamespace(abcIndex.getSelectedAbc().constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abcIndex.getSelectedAbc()).getName(abcIndex.getSelectedAbc().constants,null,true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(AVM2Instructions.NewActivation));
      acts.add(ins(AVM2Instructions.Dup));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(AVM2Instructions.PushScope));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      int parentConstMinAC=0;
      AbcIndexing.ClassIndex ci=abcIndex.findClass(new TypeItem(superType));
      if (ci != null) {
        MethodInfo pmi=ci.abc.method_info.get(ci.abc.instance_info.get(ci.index).iinit_index);
        parentConstMinAC=pmi.param_types.length;
        if (pmi.flagHas_optional()) {
          parentConstMinAC-=pmi.optional.length;
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
          mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.ConstructSuper,new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (!subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
      mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.PushScope,null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnVoid,null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.PushUndefined,null));
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnValue,null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytesLength();
}
mbody.markOffsets();
mbody.autoFillStats(abcIndex.getSelectedAbc(),initScope,className != null);
abcIndex.getSelectedAbc().addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abcIndex.getSelectedAbc().addMethodInfo(mi);
}
return mindex;
}",0.9978675151474122
61497,"private List<GraphSourceItem> generateIf(SourceGeneratorLocalData localData,GraphTargetItem expression,List<GraphTargetItem> onTrueCmds,List<GraphTargetItem> onFalseCmds,boolean ternar) throws CompilationException {
  List<GraphSourceItem> ret=new ArrayList<>();
  List<AVM2Instruction> onTrue=null;
  List<AVM2Instruction> onFalse=null;
  if (ternar) {
    onTrue=toInsList(onTrueCmds.get(0).toSource(localData,this));
  }
 else {
    onTrue=generateToInsList(localData,onTrueCmds);
  }
  if (onFalseCmds != null && !onFalseCmds.isEmpty()) {
    if (ternar) {
      onFalse=toInsList(onFalseCmds.get(0).toSource(localData,this));
    }
 else {
      onFalse=generateToInsList(localData,onFalseCmds);
    }
  }
  AVM2Instruction ajmp=null;
  if (onFalse != null) {
    if (!((!nonempty(onTrue).isEmpty()) && ((onTrue.get(onTrue.size() - 1).definition instanceof ContinueJumpIns) || ((onTrue.get(onTrue.size() - 1).definition instanceof BreakJumpIns))))) {
      ajmp=ins(AVM2Instructions.Jump,0);
      onTrue.add(ajmp);
    }
  }
  byte[] onTrueBytes=insToBytes(onTrue);
  int onTrueLen=onTrueBytes.length;
  ret.addAll(notCondition(localData,expression,onTrueLen));
  ret.addAll(onTrue);
  if (onFalse != null) {
    byte[] onFalseBytes=insToBytes(onFalse);
    int onFalseLen=onFalseBytes.length;
    if (ajmp != null) {
      ajmp.operands[0]=onFalseLen;
    }
    ret.addAll(onFalse);
  }
  return ret;
}","private List<GraphSourceItem> generateIf(SourceGeneratorLocalData localData,GraphTargetItem expression,List<GraphTargetItem> onTrueCmds,List<GraphTargetItem> onFalseCmds,boolean ternar) throws CompilationException {
  List<GraphSourceItem> ret=new ArrayList<>();
  List<AVM2Instruction> onTrue;
  List<AVM2Instruction> onFalse=null;
  if (ternar) {
    onTrue=toInsList(onTrueCmds.get(0).toSource(localData,this));
  }
 else {
    onTrue=generateToInsList(localData,onTrueCmds);
  }
  if (onFalseCmds != null && !onFalseCmds.isEmpty()) {
    if (ternar) {
      onFalse=toInsList(onFalseCmds.get(0).toSource(localData,this));
    }
 else {
      onFalse=generateToInsList(localData,onFalseCmds);
    }
  }
  AVM2Instruction ajmp=null;
  if (onFalse != null) {
    if (!((!nonempty(onTrue).isEmpty()) && ((onTrue.get(onTrue.size() - 1).definition instanceof ContinueJumpIns) || ((onTrue.get(onTrue.size() - 1).definition instanceof BreakJumpIns))))) {
      ajmp=ins(AVM2Instructions.Jump,0);
      onTrue.add(ajmp);
    }
  }
  byte[] onTrueBytes=insToBytes(onTrue);
  int onTrueLen=onTrueBytes.length;
  ret.addAll(notCondition(localData,expression,onTrueLen));
  ret.addAll(onTrue);
  if (onFalse != null) {
    byte[] onFalseBytes=insToBytes(onFalse);
    int onFalseLen=onFalseBytes.length;
    if (ajmp != null) {
      ajmp.operands[0]=onFalseLen;
    }
    ret.addAll(onFalse);
  }
  return ret;
}",0.9982225382154284
61498,"protected void indexTraits(ABC abc,int name_index,Traits ts,Map<PropertyDef,TraitIndex> map,Map<PropertyNsDef,TraitIndex> mapNs){
  for (  Trait t : ts.traits) {
    ValueKind propValue=null;
    if (t instanceof TraitSlotConst) {
      TraitSlotConst tsc=(TraitSlotConst)t;
      propValue=new ValueKind(tsc.value_index,tsc.value_kind);
    }
    if (map != null) {
      PropertyDef dp=new PropertyDef(t.getName(abc).getName(abc.constants,new ArrayList<>(),true),multinameToType(name_index,abc.constants),abc,abc.constants.getMultiname(t.name_index).namespace_index);
      map.put(dp,new TraitIndex(t,abc,getTraitReturnType(abc,t),propValue,multinameToType(name_index,abc.constants)));
    }
    if (mapNs != null) {
      Multiname m=abc.constants.getMultiname(t.name_index);
      PropertyNsDef ndp=new PropertyNsDef(t.getName(abc).getName(abc.constants,new ArrayList<>(),true),m == null || m.namespace_index == 0 ? DottedChain.EMPTY : m.getNamespace(abc.constants).getName(abc.constants),abc,m.namespace_index);
      TraitIndex ti=new TraitIndex(t,abc,getTraitReturnType(abc,t),propValue,multinameToType(name_index,abc.constants));
      if (!mapNs.containsKey(ndp)) {
        mapNs.put(ndp,ti);
      }
    }
  }
}","protected void indexTraits(ABC abc,int name_index,Traits ts,Map<PropertyDef,TraitIndex> map,Map<PropertyNsDef,TraitIndex> mapNs){
  for (  Trait t : ts.traits) {
    ValueKind propValue=null;
    if (t instanceof TraitSlotConst) {
      TraitSlotConst tsc=(TraitSlotConst)t;
      propValue=new ValueKind(tsc.value_index,tsc.value_kind);
    }
    if (map != null) {
      PropertyDef dp=new PropertyDef(t.getName(abc).getName(abc.constants,new ArrayList<>(),true),multinameToType(name_index,abc.constants),abc,abc.constants.getMultiname(t.name_index).namespace_index);
      map.put(dp,new TraitIndex(t,abc,getTraitReturnType(abc,t),propValue,multinameToType(name_index,abc.constants)));
    }
    if (mapNs != null) {
      Multiname m=abc.constants.getMultiname(t.name_index);
      PropertyNsDef ndp=new PropertyNsDef(t.getName(abc).getName(abc.constants,new ArrayList<>(),true),m == null || m.namespace_index == 0 ? DottedChain.EMPTY : m.getNamespace(abc.constants).getName(abc.constants),abc,m == null ? 0 : m.namespace_index);
      TraitIndex ti=new TraitIndex(t,abc,getTraitReturnType(abc,t),propValue,multinameToType(name_index,abc.constants));
      if (!mapNs.containsKey(ndp)) {
        mapNs.put(ndp,ti);
      }
    }
  }
}",0.9934959349593496
61499,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final PropertyNsDef other=(PropertyNsDef)obj;
  if (!Objects.equals(this.propName,other.propName)) {
    return false;
  }
  if (!Objects.equals(this.ns,other.ns)) {
    return false;
  }
  if (this.propNsIndex != other.propNsIndex) {
    return false;
  }
  if (this.abc != other.abc) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final PropertyNsDef other=(PropertyNsDef)obj;
  if (!Objects.equals(this.propName,other.propName)) {
    return false;
  }
  if (!Objects.equals(this.ns,other.ns)) {
    return false;
  }
  if (this.propNsIndex != other.propNsIndex) {
    return false;
  }
  return (this.abc == other.abc);
}",0.8910675381263616
61500,"public void setPrivate(ABC abc,int propNsIndex){
  this.propNsIndex=propNsIndex;
  this.abc=abc;
}","private void setPrivate(ABC abc,int propNsIndex){
  this.propNsIndex=propNsIndex;
  this.abc=abc;
}",0.9543147208121828
61501,"public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item,class_index);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item,class_index);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(false,isInterface,new ArrayList<>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(false,isInterface,new ArrayList<>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}","public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item,class_index);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item,class_index);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(abc.constants.getStringId(mai.functionName,true),false,isInterface,new ArrayList<>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(abc.constants.getStringId(fai.functionName,true),false,isInterface,new ArrayList<>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}",0.9764649375600384
61502,"public int method(boolean subMethod,boolean isInterface,List<MethodBody> callStack,DottedChain pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg.toRawString() + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  String mask=Configuration.registerNameFormat.get();
  mask=mask.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern pat=Pattern.compile(mask);
  for (int round=1; round <= 2; round++) {
    for (    AssignableAVM2Item an : subvariables) {
      if (an instanceof NameAVM2Item) {
        NameAVM2Item n=(NameAVM2Item)an;
        if (n.isDefinition()) {
          if (!needsActivation || (n.getSlotScope() <= 0)) {
            String varName=n.getVariableName();
            Matcher m=pat.matcher(varName);
            if ((round == 1) && (m.matches())) {
              String regIndexStr=m.group(1);
              int regIndex=Integer.parseInt(regIndexStr);
              while (registerNames.size() <= regIndex + 1) {
                String standardName=String.format(mask,registerNames.size() - 1);
                registerNames.add(standardName);
                registerTypes.add(""String_Node_Str"");
                slotNames.add(standardName);
                slotTypes.add(""String_Node_Str"");
              }
              registerNames.set(regIndex,varName);
              registerTypes.set(regIndex,varName);
              slotNames.set(regIndex,varName);
              slotTypes.set(regIndex,varName);
            }
 else             if (round == 2 && !m.matches()) {
              registerNames.add(n.getVariableName());
              registerTypes.add(n.type.toString());
              slotNames.add(n.getVariableName());
              slotTypes.add(n.type.toString());
            }
          }
        }
      }
    }
  }
  int slotScope=subMethod ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      String variableName=n.getVariableName();
      if (variableName != null) {
        boolean isThisOrSuper=variableName.equals(""String_Node_Str"") || variableName.equals(""String_Node_Str"");
        if (!isThisOrSuper && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(variableName));
            n.setSlotScope(slotScope);
          }
        }
 else {
          if (isThisOrSuper) {
            n.setRegNumber(0);
          }
 else {
            n.setRegNumber(registerNames.indexOf(variableName));
          }
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      String variableName=n.getVariableName();
      if (""String_Node_Str"".equals(variableName) || ""String_Node_Str"".equals(variableName) || paramNames.contains(variableName)|| ""String_Node_Str"".equals(variableName)) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int[] param_types=new int[paramTypes.size()];
  ValueKind[] optional=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody(abc);
    if (needsActivation) {
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,null,true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(AVM2Instructions.NewActivation));
      acts.add(ins(AVM2Instructions.Dup));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(AVM2Instructions.PushScope));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
          mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.ConstructSuper,new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
      mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.PushScope,null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnVoid,null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.PushUndefined,null));
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnValue,null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytesLength();
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}","public int method(int name_index,boolean subMethod,boolean isInterface,List<MethodBody> callStack,DottedChain pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg.toRawString() + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  String mask=Configuration.registerNameFormat.get();
  mask=mask.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern pat=Pattern.compile(mask);
  for (int round=1; round <= 2; round++) {
    for (    AssignableAVM2Item an : subvariables) {
      if (an instanceof NameAVM2Item) {
        NameAVM2Item n=(NameAVM2Item)an;
        if (n.isDefinition()) {
          if (!needsActivation || (n.getSlotScope() <= 0)) {
            String varName=n.getVariableName();
            Matcher m=pat.matcher(varName);
            if ((round == 1) && (m.matches())) {
              String regIndexStr=m.group(1);
              int regIndex=Integer.parseInt(regIndexStr);
              while (registerNames.size() <= regIndex + 1) {
                String standardName=String.format(mask,registerNames.size() - 1);
                registerNames.add(standardName);
                registerTypes.add(""String_Node_Str"");
                slotNames.add(standardName);
                slotTypes.add(""String_Node_Str"");
              }
              registerNames.set(regIndex,varName);
              registerTypes.set(regIndex,varName);
              slotNames.set(regIndex,varName);
              slotTypes.set(regIndex,varName);
            }
 else             if (round == 2 && !m.matches()) {
              registerNames.add(n.getVariableName());
              registerTypes.add(n.type.toString());
              slotNames.add(n.getVariableName());
              slotTypes.add(n.type.toString());
            }
          }
        }
      }
    }
  }
  int slotScope=subMethod ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      String variableName=n.getVariableName();
      if (variableName != null) {
        boolean isThisOrSuper=variableName.equals(""String_Node_Str"") || variableName.equals(""String_Node_Str"");
        if (!isThisOrSuper && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(variableName));
            n.setSlotScope(slotScope);
          }
        }
 else {
          if (isThisOrSuper) {
            n.setRegNumber(0);
          }
 else {
            n.setRegNumber(registerNames.indexOf(variableName));
          }
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      String variableName=n.getVariableName();
      if (""String_Node_Str"".equals(variableName) || ""String_Node_Str"".equals(variableName) || paramNames.contains(variableName)|| ""String_Node_Str"".equals(variableName)) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int[] param_types=new int[paramTypes.size()];
  ValueKind[] optional=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),name_index,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody(abc,new Traits(),new byte[0],new ABCException[0]);
    if (needsActivation) {
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,null,true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(AVM2Instructions.NewActivation));
      acts.add(ins(AVM2Instructions.Dup));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(AVM2Instructions.PushScope));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
          mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.ConstructSuper,new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,AVM2Instructions.GetLocal0,null));
      mbodyCode.add(1,new AVM2Instruction(0,AVM2Instructions.PushScope,null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnVoid,null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.PushUndefined,null));
        mbodyCode.add(new AVM2Instruction(0,AVM2Instructions.ReturnValue,null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytesLength();
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}",0.9975523149584584
61503,"public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands,int classPos) throws AVM2ParseException, CompilationException {
  Reference<Integer> class_index=new Reference<>(classPos);
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,true,localData,commands,si.traits,class_index);
  generateTraitsPhase2(new ArrayList<>(),null,commands,traitArr,new ArrayList<>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody(abc);
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(AVM2Instructions.GetLocal0));
  mbCode.add(ins(AVM2Instructions.PushScope));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(AVM2Instructions.GetScopeObject,0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(AVM2Instructions.FindPropertyStrict,abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(AVM2Instructions.PushNull));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<>(),new ArrayList<>());
        for (int i=parents.size() - 1; i >= 0; i--) {
          mbCode.add(ins(AVM2Instructions.GetLex,parents.get(i)));
          mbCode.add(ins(AVM2Instructions.PushScope));
          traitScope++;
        }
        mbCode.add(ins(AVM2Instructions.GetLex,parents.get(0)));
      }
      mbCode.add(ins(AVM2Instructions.NewClass,tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(AVM2Instructions.PopScope));
        }
      }
      mbCode.add(ins(AVM2Instructions.InitProperty,tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(AVM2Instructions.ReturnVoid));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,true,localData,commands,si.traits,traitArr,initScopes,class_index);
  return si;
}","public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands,int classPos) throws AVM2ParseException, CompilationException {
  Reference<Integer> class_index=new Reference<>(classPos);
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,true,localData,commands,si.traits,class_index);
  generateTraitsPhase2(new ArrayList<>(),null,commands,traitArr,new ArrayList<>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody(abc,new Traits(),new byte[0],new ABCException[0]);
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(AVM2Instructions.GetLocal0));
  mbCode.add(ins(AVM2Instructions.PushScope));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(AVM2Instructions.GetScopeObject,0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(AVM2Instructions.FindPropertyStrict,abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(AVM2Instructions.PushNull));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<>(),new ArrayList<>());
        parents.remove(0);
        for (int i=parents.size() - 1; i >= 0; i--) {
          mbCode.add(ins(AVM2Instructions.GetLex,parents.get(i)));
          mbCode.add(ins(AVM2Instructions.PushScope));
          traitScope++;
        }
        mbCode.add(ins(AVM2Instructions.GetLex,parents.get(0)));
      }
      mbCode.add(ins(AVM2Instructions.NewClass,tc.class_info));
      for (int i=0; i < parents.size(); i++) {
        mbCode.add(ins(AVM2Instructions.PopScope));
      }
      mbCode.add(ins(AVM2Instructions.InitProperty,tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(AVM2Instructions.ReturnVoid));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,true,localData,commands,si.traits,traitArr,initScopes,class_index);
  return si;
}",0.9590075512405608
61504,"public Multiname getName(ABC abc){
  if (name_index == 0) {
    return null;
  }
 else {
    return abc.constants.getMultiname(name_index);
  }
}","public final Multiname getName(ABC abc){
  if (name_index == 0) {
    return null;
  }
 else {
    return abc.constants.getMultiname(name_index);
  }
}",0.9797297297297296
61505,"public List<Entry<String,Map<String,String>>> getMetaDataTable(ABC abc){
  List<Entry<String,Map<String,String>>> ret=new ArrayList<>();
  for (  int m : metadata) {
    if (m >= 0 && m < abc.metadata_info.size()) {
      String name=abc.constants.getString(abc.metadata_info.get(m).name_index);
      Map<String,String> data=new HashMap<>();
      for (int i=0; i < abc.metadata_info.get(m).keys.length; i++) {
        data.put(abc.constants.getString(abc.metadata_info.get(m).keys[i]),abc.constants.getString(abc.metadata_info.get(m).values[i]));
      }
      ret.add(new SimpleEntry<>(name,data));
    }
  }
  return ret;
}","public final List<Entry<String,Map<String,String>>> getMetaDataTable(ABC abc){
  List<Entry<String,Map<String,String>>> ret=new ArrayList<>();
  for (  int m : metadata) {
    if (m >= 0 && m < abc.metadata_info.size()) {
      String name=abc.constants.getString(abc.metadata_info.get(m).name_index);
      Map<String,String> data=new HashMap<>();
      for (int i=0; i < abc.metadata_info.get(m).keys.length; i++) {
        data.put(abc.constants.getString(abc.metadata_info.get(m).keys[i]),abc.constants.getString(abc.metadata_info.get(m).values[i]));
      }
      ret.add(new SimpleEntry<>(name,data));
    }
  }
  return ret;
}",0.9952380952380953
61506,"protected DottedChain findCustomNs(int link_ns_index,ABC abc){
  String nsname=""String_Node_Str"";
  if (link_ns_index <= 0) {
    return null;
  }
  DottedChain name=abc.constants.getNamespace(link_ns_index).getName(abc.constants);
  for (  ABCContainerTag abcTag : abc.getAbcTags()) {
    DottedChain dc=abcTag.getABC().nsValueToName(name);
    nsname=dc.getLast();
    if (nsname == null) {
      break;
    }
    if (!nsname.isEmpty()) {
      return dc;
    }
  }
  return null;
}","protected final DottedChain findCustomNs(int link_ns_index,ABC abc){
  String nsname=""String_Node_Str"";
  if (link_ns_index <= 0) {
    return null;
  }
  DottedChain name=abc.constants.getNamespace(link_ns_index).getName(abc.constants);
  for (  ABCContainerTag abcTag : abc.getAbcTags()) {
    DottedChain dc=abcTag.getABC().nsValueToName(name);
    nsname=dc.getLast();
    if (nsname == null) {
      break;
    }
    if (!nsname.isEmpty()) {
      return dc;
    }
  }
  return null;
}",0.9938398357289528
61507,"public ClassPath getPath(ABC abc){
  Multiname name=getName(abc);
  Namespace ns=name.getNamespace(abc.constants);
  DottedChain packageName=ns.getName(abc.constants);
  String objectName=name.getName(abc.constants,null,true);
  return new ClassPath(packageName,objectName);
}","public final ClassPath getPath(ABC abc){
  Multiname name=getName(abc);
  Namespace ns=name.getNamespace(abc.constants);
  DottedChain packageName=ns.getName(abc.constants);
  String objectName=name.getName(abc.constants,null,true);
  return new ClassPath(packageName,objectName);
}",0.989247311827957
61508,"public GraphTextWriter getModifiers(ABC abc,boolean isStatic,GraphTextWriter writer){
  if ((kindFlags & ATTR_Override) > 0) {
    writer.appendNoHilight(""String_Node_Str"");
  }
  Multiname m=getName(abc);
  if (m != null) {
    DottedChain dc=findCustomNs(m.namespace_index,abc);
    String nsname=dc != null ? dc.getLast() : null;
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname != null) {
      String identifier=IdentifiersDeobfuscation.printIdentifier(true,nsname);
      if (identifier != null && !identifier.isEmpty()) {
        writer.appendNoHilight(identifier).appendNoHilight(""String_Node_Str"");
      }
    }
    if (ns != null) {
      String nsPrefix=ns.getPrefix(abc);
      if (nsPrefix != null && !nsPrefix.isEmpty()) {
        writer.appendNoHilight(nsPrefix).appendNoHilight(""String_Node_Str"");
      }
    }
  }
  if (isStatic) {
    if ((this instanceof TraitSlotConst) && ((TraitSlotConst)this).isNamespace()) {
    }
 else {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  return writer;
}","public final GraphTextWriter getModifiers(ABC abc,boolean isStatic,GraphTextWriter writer){
  if ((kindFlags & ATTR_Override) > 0) {
    writer.appendNoHilight(""String_Node_Str"");
  }
  Multiname m=getName(abc);
  if (m != null) {
    DottedChain dc=findCustomNs(m.namespace_index,abc);
    String nsname=dc != null ? dc.getLast() : null;
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname != null) {
      String identifier=IdentifiersDeobfuscation.printIdentifier(true,nsname);
      if (identifier != null && !identifier.isEmpty()) {
        writer.appendNoHilight(identifier).appendNoHilight(""String_Node_Str"");
      }
    }
    if (ns != null) {
      String nsPrefix=ns.getPrefix(abc);
      if (nsPrefix != null && !nsPrefix.isEmpty()) {
        writer.appendNoHilight(nsPrefix).appendNoHilight(""String_Node_Str"");
      }
    }
  }
  if (isStatic) {
    if ((this instanceof TraitSlotConst) && ((TraitSlotConst)this).isNamespace()) {
    }
 else {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  return writer;
}",0.9974160206718348
61509,"public GraphTextWriter getMetaData(ABC abc,GraphTextWriter writer){
  List<Entry<String,Map<String,String>>> md=getMetaDataTable(abc);
  for (  Entry<String,Map<String,String>> en : md) {
    String name=en.getKey();
    if (METADATA_DEFINITION.equals(name) || METADATA_CTOR_DEFINITION.equals(name)) {
      continue;
    }
    writer.append(""String_Node_Str"").append(name);
    if (!en.getValue().isEmpty()) {
      writer.append(""String_Node_Str"");
      boolean first=true;
      for (      String key : en.getValue().keySet()) {
        if (!first) {
          writer.append(""String_Node_Str"");
        }
        first=false;
        if (!key.isEmpty()) {
          writer.append(IdentifiersDeobfuscation.printIdentifier(true,key)).append(""String_Node_Str"");
        }
        writer.append(""String_Node_Str"");
        String val=en.getValue().get(key);
        writer.append(Helper.escapeString(val));
        writer.append(""String_Node_Str"");
      }
      writer.append(""String_Node_Str"");
    }
    writer.append(""String_Node_Str"");
    writer.newLine();
  }
  return writer;
}","public final GraphTextWriter getMetaData(ABC abc,GraphTextWriter writer){
  List<Entry<String,Map<String,String>>> md=getMetaDataTable(abc);
  for (  Entry<String,Map<String,String>> en : md) {
    String name=en.getKey();
    if (METADATA_DEFINITION.equals(name) || METADATA_CTOR_DEFINITION.equals(name)) {
      continue;
    }
    writer.append(""String_Node_Str"").append(name);
    if (!en.getValue().isEmpty()) {
      writer.append(""String_Node_Str"");
      boolean first=true;
      for (      String key : en.getValue().keySet()) {
        if (!first) {
          writer.append(""String_Node_Str"");
        }
        first=false;
        if (!key.isEmpty()) {
          writer.append(IdentifiersDeobfuscation.printIdentifier(true,key)).append(""String_Node_Str"");
        }
        writer.append(""String_Node_Str"");
        String val=en.getValue().get(key);
        writer.append(Helper.escapeString(val));
        writer.append(""String_Node_Str"");
      }
      writer.append(""String_Node_Str"");
    }
    writer.append(""String_Node_Str"");
    writer.newLine();
  }
  return writer;
}",0.9972426470588236
61510,"public void setScript(ScriptPack scriptLeaf){
  abcPanel.scriptNameLabel.setText(scriptLeaf.getClassPath().toString());
  int scriptIndex=scriptLeaf.scriptIndex;
  ScriptInfo script=null;
  ABC abc=scriptLeaf.abc;
  if (scriptIndex > -1) {
    script=abc.script_info.get(scriptIndex);
  }
  if (script == null) {
    highlights=new ArrayList<>();
    specialHighlights=new ArrayList<>();
    traitHighlights=new ArrayList<>();
    methodHighlights=new ArrayList<>();
    this.script=scriptLeaf;
    return;
  }
  setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  this.script=scriptLeaf;
  CachedDecompilation cd=null;
  try {
    cd=SWF.getCached(scriptLeaf);
  }
 catch (  InterruptedException ex) {
  }
  if (cd != null) {
    String hilightedCode=cd.text;
    highlights=cd.getInstructionHighlights();
    specialHighlights=cd.getSpecialHighligths();
    traitHighlights=cd.getTraitHighlights();
    methodHighlights=cd.getMethodHighlights();
    classHighlights=cd.getClassHighlights();
    setText(hilightedCode);
    if (classHighlights.size() > 0) {
      setCaretPosition(classHighlights.get(0).startPos);
    }
  }
  fireScript();
}","public void setScript(ScriptPack scriptLeaf){
  abcPanel.scriptNameLabel.setText(scriptLeaf.getClassPath().toString());
  int scriptIndex=scriptLeaf.scriptIndex;
  ScriptInfo script=null;
  ABC abc=scriptLeaf.abc;
  if (scriptIndex > -1) {
    script=abc.script_info.get(scriptIndex);
  }
  if (script == null) {
    highlights=new ArrayList<>();
    specialHighlights=new ArrayList<>();
    traitHighlights=new ArrayList<>();
    methodHighlights=new ArrayList<>();
    this.script=scriptLeaf;
    return;
  }
  setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  this.script=scriptLeaf;
  CachedDecompilation cd=null;
  try {
    cd=SWF.getCached(scriptLeaf);
  }
 catch (  InterruptedException ex) {
  }
  if (cd != null) {
    String hilightedCode=cd.text;
    highlights=cd.getInstructionHighlights();
    specialHighlights=cd.getSpecialHighligths();
    traitHighlights=cd.getTraitHighlights();
    methodHighlights=cd.getMethodHighlights();
    classHighlights=cd.getClassHighlights();
    setText(hilightedCode);
    if (classHighlights.size() > 0) {
      try {
        setCaretPosition(classHighlights.get(0).startPos);
      }
 catch (      Exception ex) {
      }
    }
  }
  fireScript();
}",0.9637262984336356
61511,"public AVM2Code(ABCInputStream ais,MethodBody body) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new HashMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  List<Long> unAdresses=new ArrayList<>();
  List<Long> switchAddresses=new ArrayList<>();
  int availableBytes=ais.available();
  for (int i=0; i < availableBytes; i++) {
    codeMap.put((long)i,new AVM2Instruction(i,AVM2Instructions.Nop,null));
  }
  long startPos=ais.getPosition();
  addresses.add(startPos);
  if (body != null) {
    for (    ABCException e : body.exceptions) {
      addresses.add((long)e.start);
      addresses.add((long)e.end);
      addresses.add((long)e.target);
    }
  }
  loopaddr:   while (!addresses.isEmpty() || !switchAddresses.isEmpty() || !unAdresses.isEmpty()) {
    long address;
    boolean isSwitch=false;
    boolean handleJumps=true;
    if (!addresses.isEmpty()) {
      address=addresses.remove(0);
    }
 else     if (!switchAddresses.isEmpty()) {
      address=switchAddresses.remove(0);
      isSwitch=true;
    }
 else {
      address=unAdresses.remove(0);
      handleJumps=false;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        if (codeMap.containsKey(startOffset) && !(codeMap.get(startOffset).definition instanceof NopIns)) {
          continue loopaddr;
        }
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (instructionCode == AVM2Instructions.LookupSwitch) {
          if (!isSwitch) {
            switchAddresses.add(startOffset);
            continue loopaddr;
          }
 else {
            isSwitch=false;
          }
        }
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == AVM2Instructions.LookupSwitch) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            long afterCasePos=ais.getPosition() + 3 * (case_count + 1);
            boolean invalidSwitch=false;
            for (long a=startOffset; a < afterCasePos; a++) {
              if (codeMap.containsKey(a) && (!(codeMap.get(a).definition instanceof NopIns))) {
                invalidSwitch=true;
                break;
              }
            }
            long totalBytes=ais.getPosition() + ais.available();
            if (afterCasePos > totalBytes) {
              invalidSwitch=true;
            }
            if (invalidSwitch) {
              continue loopaddr;
            }
 else {
              actualOperands=new int[case_count + 3];
              actualOperands[0]=firstOperand;
              actualOperands[1]=case_count;
              for (int c=0; c < case_count + 1; c++) {
                actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
              }
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
AVM2Instruction ai=new AVM2Instruction(startOffset,instr,actualOperands);
long endOffset=ais.getPosition();
boolean hasRoom=true;
for (long p=startOffset; p < endOffset; p++) {
if (codeMap.containsKey(p) && !(codeMap.get(p).definition instanceof NopIns)) {
hasRoom=false;
}
}
if (!hasRoom) {
continue loopaddr;
}
for (long p=startOffset; p < endOffset; p++) {
codeMap.put(p,ai);
}
ais.endDumpLevel(instr.instructionCode);
if ((instr instanceof IfTypeIns)) {
if (handleJumps) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
 else {
actualOperands[0]=0;
}
}
if (instr instanceof JumpIns) {
if (handleJumps) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
unAdresses.add(ais.getPosition());
continue loopaddr;
}
 else {
actualOperands[0]=0;
}
}
if (instr.isExitInstruction()) {
if (handleJumps) {
unAdresses.add(ais.getPosition());
continue loopaddr;
}
}
if (instr instanceof LookupSwitchIns) {
if (handleJumps) {
addresses.add(startOffset + actualOperands[0]);
for (int c=2; c < actualOperands.length; c++) {
addresses.add(startOffset + actualOperands[c]);
}
unAdresses.add(ais.getPosition());
continue loopaddr;
}
 else {
int swlen=(int)(endOffset - startOffset);
actualOperands[0]=swlen;
for (int c=2; c < actualOperands.length; c++) {
actualOperands[c]=swlen;
}
}
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
AVM2Instruction prev=null;
for (int i=0; i < availableBytes; i++) {
AVM2Instruction ins=codeMap.get((long)i);
if (prev != ins) {
code.add(ins);
}
prev=ins;
}
}","public AVM2Code(ABCInputStream ais,MethodBody body) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new HashMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  List<Long> unAdresses=new ArrayList<>();
  List<Long> switchAddresses=new ArrayList<>();
  int availableBytes=ais.available();
  for (int i=0; i < availableBytes; i++) {
    codeMap.put((long)i,new AVM2Instruction(i,AVM2Instructions.Nop,null));
  }
  long startPos=ais.getPosition();
  addresses.add(startPos);
  if (body != null) {
    for (    ABCException e : body.exceptions) {
      addresses.add((long)e.start);
      addresses.add((long)e.end);
      addresses.add((long)e.target);
    }
  }
  loopaddr:   while (!addresses.isEmpty() || !switchAddresses.isEmpty() || !unAdresses.isEmpty()) {
    long address;
    boolean isSwitch=false;
    boolean handleJumps=true;
    if (!addresses.isEmpty()) {
      address=addresses.remove(0);
    }
 else     if (!switchAddresses.isEmpty()) {
      address=switchAddresses.remove(0);
      isSwitch=true;
    }
 else {
      address=unAdresses.remove(0);
      handleJumps=false;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        if (codeMap.containsKey(startOffset) && !(codeMap.get(startOffset).definition instanceof NopIns)) {
          continue loopaddr;
        }
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (instructionCode == AVM2Instructions.LookupSwitch) {
          if (!isSwitch) {
            switchAddresses.add(startOffset);
            continue loopaddr;
          }
 else {
            isSwitch=false;
          }
        }
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == AVM2Instructions.LookupSwitch) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            long afterCasePos=ais.getPosition() + 3 * (case_count + 1);
            boolean invalidSwitch=false;
            for (long a=startOffset; a < afterCasePos; a++) {
              if (codeMap.containsKey(a) && (!(codeMap.get(a).definition instanceof NopIns))) {
                invalidSwitch=true;
                break;
              }
            }
            long totalBytes=ais.getPosition() + ais.available();
            if (afterCasePos > totalBytes) {
              invalidSwitch=true;
            }
            if (invalidSwitch) {
              continue loopaddr;
            }
 else {
              actualOperands=new int[case_count + 3];
              actualOperands[0]=firstOperand;
              actualOperands[1]=case_count;
              for (int c=0; c < case_count + 1; c++) {
                actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
              }
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U30_SHORT:
              actualOperands[op]=(short)ais.readU30(""String_Node_Str"");
            break;
case OPT_U8:
          actualOperands[op]=ais.read(""String_Node_Str"");
        break;
case OPT_BYTE:
      actualOperands[op]=(byte)ais.read(""String_Node_Str"");
    break;
case OPT_S24:
  actualOperands[op]=ais.readS24(""String_Node_Str"");
break;
}
}
}
}
AVM2Instruction ai=new AVM2Instruction(startOffset,instr,actualOperands);
long endOffset=ais.getPosition();
boolean hasRoom=true;
for (long p=startOffset; p < endOffset; p++) {
if (codeMap.containsKey(p) && !(codeMap.get(p).definition instanceof NopIns)) {
hasRoom=false;
}
}
if (!hasRoom) {
continue loopaddr;
}
for (long p=startOffset; p < endOffset; p++) {
codeMap.put(p,ai);
}
ais.endDumpLevel(instr.instructionCode);
if ((instr instanceof IfTypeIns)) {
if (handleJumps) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
 else {
actualOperands[0]=0;
}
}
if (instr instanceof JumpIns) {
if (handleJumps) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
unAdresses.add(ais.getPosition());
continue loopaddr;
}
 else {
actualOperands[0]=0;
}
}
if (instr.isExitInstruction()) {
if (handleJumps) {
unAdresses.add(ais.getPosition());
continue loopaddr;
}
}
if (instr instanceof LookupSwitchIns) {
if (handleJumps) {
addresses.add(startOffset + actualOperands[0]);
for (int c=2; c < actualOperands.length; c++) {
addresses.add(startOffset + actualOperands[c]);
}
unAdresses.add(ais.getPosition());
continue loopaddr;
}
 else {
int swlen=(int)(endOffset - startOffset);
actualOperands[0]=swlen;
for (int c=2; c < actualOperands.length; c++) {
actualOperands[c]=swlen;
}
}
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
AVM2Instruction prev=null;
for (int i=0; i < availableBytes; i++) {
AVM2Instruction ins=codeMap.get((long)i);
if (prev != ins) {
code.add(ins);
}
prev=ins;
}
}",0.9872735717603344
61512,"public byte[] getBytes(){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  try {
    ABCOutputStream aos=new ABCOutputStream(bos);
    aos.write(definition.instructionCode);
    for (int i=0; i < definition.operands.length; i++) {
      int opt=definition.operands[i] & 0xff00;
switch (opt) {
case AVM2Code.OPT_S24:
        aos.writeS24(operands[i]);
      break;
case AVM2Code.OPT_U30:
    aos.writeU30(operands[i]);
  break;
case AVM2Code.OPT_U8:
aos.writeU8(operands[i]);
break;
case AVM2Code.OPT_BYTE:
aos.writeU8(0xff & operands[i]);
break;
case AVM2Code.OPT_CASE_OFFSETS:
aos.writeU30(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
aos.writeS24(operands[j]);
}
break;
}
}
}
 catch (IOException ex) {
}
return bos.toByteArray();
}","public byte[] getBytes(){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  try {
    ABCOutputStream aos=new ABCOutputStream(bos);
    aos.write(definition.instructionCode);
    for (int i=0; i < definition.operands.length; i++) {
      int opt=definition.operands[i] & 0xff00;
switch (opt) {
case AVM2Code.OPT_S24:
        aos.writeS24(operands[i]);
      break;
case AVM2Code.OPT_U30:
case AVM2Code.OPT_U30_SHORT:
    aos.writeU30(operands[i]);
  break;
case AVM2Code.OPT_U8:
aos.writeU8(operands[i]);
break;
case AVM2Code.OPT_BYTE:
aos.writeU8(0xff & operands[i]);
break;
case AVM2Code.OPT_CASE_OFFSETS:
aos.writeU30(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
aos.writeS24(operands[j]);
}
break;
}
}
}
 catch (IOException ex) {
}
return bos.toByteArray();
}",0.9812297734627832
61513,"public int getBytesLength(){
  int cnt=1;
  for (int i=0; i < definition.operands.length; i++) {
    int opt=definition.operands[i] & 0xff00;
switch (opt) {
case AVM2Code.OPT_S24:
      cnt+=3;
    break;
case AVM2Code.OPT_U30:
  cnt+=ABCOutputStream.getU30ByteLength(operands[i]);
break;
case AVM2Code.OPT_U8:
cnt++;
break;
case AVM2Code.OPT_BYTE:
cnt++;
break;
case AVM2Code.OPT_CASE_OFFSETS:
cnt+=ABCOutputStream.getU30ByteLength(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
cnt+=3;
}
break;
}
}
return cnt;
}","public int getBytesLength(){
  int cnt=1;
  for (int i=0; i < definition.operands.length; i++) {
    int opt=definition.operands[i] & 0xff00;
switch (opt) {
case AVM2Code.OPT_S24:
      cnt+=3;
    break;
case AVM2Code.OPT_U30:
case AVM2Code.OPT_U30_SHORT:
  cnt+=ABCOutputStream.getU30ByteLength(operands[i]);
break;
case AVM2Code.OPT_U8:
cnt++;
break;
case AVM2Code.OPT_BYTE:
cnt++;
break;
case AVM2Code.OPT_CASE_OFFSETS:
cnt+=ABCOutputStream.getU30ByteLength(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
cnt+=3;
}
break;
}
}
return cnt;
}",0.9732225300092336
61514,"@Override public String toString(){
  StringBuilder s=new StringBuilder();
  s.append(instructionName);
  for (int i=0; i < operands.length; i++) {
    if ((operands[i] & 0xff00) == AVM2Code.OPT_U30) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_U8) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_BYTE) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_S24) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_CASE_OFFSETS) {
      s.append(""String_Node_Str"");
    }
  }
  return s.toString();
}","@Override public String toString(){
  StringBuilder s=new StringBuilder();
  s.append(instructionName);
  for (int i=0; i < operands.length; i++) {
    if ((operands[i] & 0xff00) == AVM2Code.OPT_U30) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_U30_SHORT) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_U8) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_BYTE) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_S24) {
      s.append(""String_Node_Str"");
    }
    if ((operands[i] & 0xff00) == AVM2Code.OPT_CASE_OFFSETS) {
      s.append(""String_Node_Str"");
    }
  }
  return s.toString();
}",0.9176636171710064
61515,"public PushShortIns(){
  super(0x25,""String_Node_Str"",new int[]{AVM2Code.OPT_U30},false);
}","public PushShortIns(){
  super(0x25,""String_Node_Str"",new int[]{AVM2Code.OPT_U30_SHORT},false);
}",0.9680851063829788
61516,"public GraphTextWriter getModifiers(ABC abc,boolean isStatic,GraphTextWriter writer){
  if ((kindFlags & ATTR_Override) > 0) {
    writer.appendNoHilight(""String_Node_Str"");
  }
  Multiname m=getName(abc);
  if (m != null) {
    String nsname=""String_Node_Str"";
    for (    ABCContainerTag abcTag : abc.getAbcTags()) {
      if (m.namespace_index == -1) {
        break;
      }
      DottedChain dc=abcTag.getABC().nsValueToName(abc.constants.getNamespace(m.namespace_index).getName(abc.constants));
      nsname=dc.getLast();
      if (nsname == null) {
        break;
      }
      if (!nsname.isEmpty()) {
        break;
      }
    }
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname != null) {
      String identifier=IdentifiersDeobfuscation.printIdentifier(true,nsname);
      if (identifier != null && !identifier.isEmpty()) {
        writer.appendNoHilight(identifier).appendNoHilight(""String_Node_Str"");
      }
    }
    if (ns != null) {
      String nsPrefix=ns.getPrefix(abc);
      if (nsPrefix != null && !nsPrefix.isEmpty()) {
        writer.appendNoHilight(nsPrefix).appendNoHilight(""String_Node_Str"");
      }
    }
  }
  if (isStatic) {
    if ((this instanceof TraitSlotConst) && ((TraitSlotConst)this).isNamespace()) {
    }
 else {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  return writer;
}","public GraphTextWriter getModifiers(ABC abc,boolean isStatic,GraphTextWriter writer){
  if ((kindFlags & ATTR_Override) > 0) {
    writer.appendNoHilight(""String_Node_Str"");
  }
  Multiname m=getName(abc);
  if (m != null) {
    DottedChain dc=findCustomNs(m.namespace_index,abc);
    String nsname=dc != null ? dc.getLast() : null;
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname != null) {
      String identifier=IdentifiersDeobfuscation.printIdentifier(true,nsname);
      if (identifier != null && !identifier.isEmpty()) {
        writer.appendNoHilight(identifier).appendNoHilight(""String_Node_Str"");
      }
    }
    if (ns != null) {
      String nsPrefix=ns.getPrefix(abc);
      if (nsPrefix != null && !nsPrefix.isEmpty()) {
        writer.appendNoHilight(nsPrefix).appendNoHilight(""String_Node_Str"");
      }
    }
  }
  if (isStatic) {
    if ((this instanceof TraitSlotConst) && ((TraitSlotConst)this).isNamespace()) {
    }
 else {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      writer.appendNoHilight(""String_Node_Str"");
    }
  }
  return writer;
}",0.8394967594357606
61517,"protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (onTrue.isEmpty() && !onFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
          }
          if (!stack.isEmpty() && onFalse.isEmpty() && ((onTrue.size() == 1 && (onTrue.get(0) instanceof PopItem)) || ((onTrue.size() == 2) && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)))) {
            if (onTrue.size() == 2) {
              GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr;
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null) instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                stack.push(new AndItem(null,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (onTrue.isEmpty() && !onFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
          }
          if (!stack.isEmpty() && onFalse.isEmpty() && ((onTrue.size() == 1 && (onTrue.get(0) instanceof PopItem)) || ((onTrue.size() == 2) && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)))) {
            if (onTrue.size() == 2) {
              GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr;
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null) instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                leftSide=leftSide.invert(null);
                stack.push(new AndItem(null,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}",0.9989283322170128
61518,"@Override public void translate(AVM2LocalData localData,TranslateStack stack,AVM2Instruction ins,List<GraphTargetItem> output,String path) throws InterruptedException {
  int argCount=ins.operands[0];
  List<GraphTargetItem> args=new ArrayList<>();
  for (int a=0; a < argCount; a++) {
    args.add(0,stack.pop());
  }
  GraphTargetItem obj=stack.pop();
  FullMultinameAVM2Item xmlMult=null;
  boolean isXML=false;
  if (obj instanceof GetPropertyAVM2Item) {
    GetPropertyAVM2Item gpt=(GetPropertyAVM2Item)obj;
    if (gpt.object instanceof FindPropertyAVM2Item) {
      FindPropertyAVM2Item fpt=(FindPropertyAVM2Item)gpt.object;
      xmlMult=(FullMultinameAVM2Item)fpt.propertyName;
      isXML=xmlMult.isXML(localData.constants,localData.localRegNames,localData.fullyQualifiedNames) && xmlMult.isXML(localData.constants,localData.localRegNames,localData.fullyQualifiedNames);
    }
  }
  if (obj instanceof GetLexAVM2Item) {
    GetLexAVM2Item glt=(GetLexAVM2Item)obj;
    isXML=glt.propertyName.getName(localData.constants,localData.fullyQualifiedNames,true).equals(""String_Node_Str"");
  }
  if (isXML) {
    if (args.size() == 1) {
      GraphTargetItem arg=args.get(0);
      List<GraphTargetItem> xmlLines=new ArrayList<>();
      if (walkXML(arg,xmlLines)) {
        stack.push(new XMLAVM2Item(ins,xmlLines));
        return;
      }
    }
  }
  stack.push(new ConstructAVM2Item(ins,obj,args));
}","@Override public void translate(AVM2LocalData localData,TranslateStack stack,AVM2Instruction ins,List<GraphTargetItem> output,String path) throws InterruptedException {
  int argCount=ins.operands[0];
  List<GraphTargetItem> args=new ArrayList<>();
  for (int a=0; a < argCount; a++) {
    args.add(0,stack.pop());
  }
  GraphTargetItem obj=stack.pop();
  boolean isXML=false;
  if (obj instanceof GetPropertyAVM2Item) {
    GetPropertyAVM2Item gpt=(GetPropertyAVM2Item)obj;
    if (gpt.object instanceof FindPropertyAVM2Item) {
      FindPropertyAVM2Item fpt=(FindPropertyAVM2Item)gpt.object;
      FullMultinameAVM2Item fptXmlMult=(FullMultinameAVM2Item)fpt.propertyName;
      FullMultinameAVM2Item gptXmlMult=(FullMultinameAVM2Item)gpt.propertyName;
      isXML=fptXmlMult.isXML(localData.constants,localData.localRegNames,localData.fullyQualifiedNames) && gptXmlMult.isXML(localData.constants,localData.localRegNames,localData.fullyQualifiedNames);
    }
  }
  if (obj instanceof GetLexAVM2Item) {
    GetLexAVM2Item glt=(GetLexAVM2Item)obj;
    isXML=glt.propertyName.getName(localData.constants,localData.fullyQualifiedNames,true).equals(""String_Node_Str"");
  }
  if (isXML) {
    if (args.size() == 1) {
      GraphTargetItem arg=args.get(0);
      List<GraphTargetItem> xmlLines=new ArrayList<>();
      if (walkXML(arg,xmlLines)) {
        stack.push(new XMLAVM2Item(ins,xmlLines));
        return;
      }
    }
  }
  stack.push(new ConstructAVM2Item(ins,obj,args));
}",0.9428076256499134
61519,"protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (onTrue.isEmpty() && !onFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
          }
          if (!stack.isEmpty() && onFalse.isEmpty() && ((onTrue.size() == 1 && (onTrue.get(0) instanceof PopItem)) || ((onTrue.size() == 2) && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)))) {
            if (onTrue.size() == 2) {
              GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr;
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null) instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                leftSide=leftSide.invert(null);
                stack.push(new AndItem(null,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,Set<GraphPart> visited,BaseLocalData localData,TranslateStack stack,Set<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (onTrue.isEmpty() && !onFalse.isEmpty()) {
            expr=expr.invert(null);
            List<GraphTargetItem> tmp=onTrue;
            onTrue=onFalse;
            onFalse=tmp;
          }
          if (!stack.isEmpty() && onFalse.isEmpty() && ((onTrue.size() == 1 && (onTrue.get(0) instanceof PopItem)) || ((onTrue.size() == 2) && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)))) {
            if (onTrue.size() == 2) {
              GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
              GraphTargetItem prevExpr=stack.pop();
              GraphTargetItem leftSide=expr.getNotCoercedNoDup();
              if (leftSide instanceof DuplicateItem) {
                isIf=false;
                stack.push(new OrItem(null,prevExpr,rightSide));
              }
 else               if (leftSide.invert(null).getNotCoercedNoDup() instanceof DuplicateItem) {
                isIf=false;
                stack.push(new AndItem(null,prevExpr,rightSide));
              }
 else               if (prevExpr instanceof FalseItem) {
                isIf=false;
                leftSide=leftSide.invert(null);
                stack.push(new AndItem(null,leftSide,rightSide));
              }
 else               if (prevExpr instanceof TrueItem) {
                isIf=false;
                stack.push(new OrItem(null,leftSide,rightSide));
              }
 else {
              }
            }
 else {
              isIf=false;
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.getSrc(),currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.getSrc(),currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}",0.9990641711229946
61520,"@Override public SerializableImage getImage(){
  if (cachedImage != null) {
    return cachedImage;
  }
  try {
    int errorLength=hasErrorHeader(imageData) ? 4 : 0;
    ByteArrayInputStream bis=new ByteArrayInputStream(imageData.getArray(),imageData.getPos() + errorLength,imageData.getLength() - errorLength);
    BufferedImage image=ImageHelper.read(bis);
    if (image == null) {
      Logger.getLogger(DefineBitsJPEG3Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"");
      return null;
    }
    SerializableImage img=new SerializableImage(image);
    if (bitmapAlphaData.getLength() == 0) {
      if (Configuration.cacheImages.get()) {
        cachedImage=img;
      }
      return img;
    }
    byte[] alphaData=SWFInputStream.uncompressByteArray(bitmapAlphaData.getRangeData());
    int[] pixels=((DataBufferInt)img.getRaster().getDataBuffer()).getData();
    for (int i=0; i < pixels.length; i++) {
      int a=alphaData[i] & 0xff;
      pixels[i]=multiplyAlpha((pixels[i] & 0xffffff) | (a << 24));
    }
    if (Configuration.cacheImages.get()) {
      cachedImage=img;
    }
    return img;
  }
 catch (  IOException ex) {
    Logger.getLogger(DefineBitsJPEG3Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
  return null;
}","@Override public SerializableImage getImage(){
  if (cachedImage != null) {
    return cachedImage;
  }
  try {
    int errorLength=hasErrorHeader(imageData) ? 4 : 0;
    ByteArrayInputStream bis=new ByteArrayInputStream(imageData.getArray(),imageData.getPos() + errorLength,imageData.getLength() - errorLength);
    BufferedImage image=ImageHelper.read(bis);
    if (image == null) {
      Logger.getLogger(DefineBitsJPEG3Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"");
      return null;
    }
    SerializableImage img=new SerializableImage(image);
    if (bitmapAlphaData.getLength() == 0) {
      if (Configuration.cacheImages.get()) {
        cachedImage=img;
      }
      return img;
    }
    byte[] alphaData=getImageAlpha();
    int[] pixels=((DataBufferInt)img.getRaster().getDataBuffer()).getData();
    for (int i=0; i < pixels.length; i++) {
      int a=alphaData[i] & 0xff;
      pixels[i]=multiplyAlpha((pixels[i] & 0xffffff) | (a << 24));
    }
    if (Configuration.cacheImages.get()) {
      cachedImage=img;
    }
    return img;
  }
 catch (  IOException ex) {
    Logger.getLogger(DefineBitsJPEG3Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
  return null;
}",0.9696479158235533
61521,"@Override public SerializableImage getImage(){
  if (cachedImage != null) {
    return cachedImage;
  }
  try {
    BufferedImage image=ImageHelper.read(new ByteArrayInputStream(imageData.getArray(),imageData.getPos(),imageData.getLength()));
    if (image == null) {
      Logger.getLogger(DefineBitsJPEG4Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"");
      return null;
    }
    SerializableImage img=new SerializableImage(image);
    if (bitmapAlphaData.getLength() == 0) {
      if (Configuration.cacheImages.get()) {
        cachedImage=img;
      }
      return img;
    }
    byte[] alphaData=SWFInputStream.uncompressByteArray(bitmapAlphaData.getRangeData());
    int[] pixels=((DataBufferInt)img.getRaster().getDataBuffer()).getData();
    for (int i=0; i < pixels.length; i++) {
      int a=alphaData[i] & 0xff;
      pixels[i]=multiplyAlpha((pixels[i] & 0xffffff) | (a << 24));
    }
    if (Configuration.cacheImages.get()) {
      cachedImage=img;
    }
    return img;
  }
 catch (  IOException ex) {
    Logger.getLogger(DefineBitsJPEG4Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
  return null;
}","@Override public SerializableImage getImage(){
  if (cachedImage != null) {
    return cachedImage;
  }
  try {
    BufferedImage image=ImageHelper.read(new ByteArrayInputStream(imageData.getArray(),imageData.getPos(),imageData.getLength()));
    if (image == null) {
      Logger.getLogger(DefineBitsJPEG4Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"");
      return null;
    }
    SerializableImage img=new SerializableImage(image);
    if (bitmapAlphaData.getLength() == 0) {
      if (Configuration.cacheImages.get()) {
        cachedImage=img;
      }
      return img;
    }
    byte[] alphaData=getImageAlpha();
    int[] pixels=((DataBufferInt)img.getRaster().getDataBuffer()).getData();
    for (int i=0; i < pixels.length; i++) {
      int a=alphaData[i] & 0xff;
      pixels[i]=multiplyAlpha((pixels[i] & 0xffffff) | (a << 24));
    }
    if (Configuration.cacheImages.get()) {
      cachedImage=img;
    }
    return img;
  }
 catch (  IOException ex) {
    Logger.getLogger(DefineBitsJPEG4Tag.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
  return null;
}",0.966472954850246
61522,"@Override public void setText(String t){
  lastLine=-1;
  error=false;
  if (Configuration.debugMode.get() && t.length() > truncateLimit) {
    t=t.substring(0,truncateLimit) + ""String_Node_Str"" + AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(truncateLimit));
  }
  super.setText(t);
  setCaretPosition(0);
}","@Override public void setText(String t){
  lastLine=-1;
  error=false;
  if (Configuration.debugMode.get() && t != null && t.length() > truncateLimit) {
    t=t.substring(0,truncateLimit) + ""String_Node_Str"" + AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(truncateLimit));
  }
  super.setText(t);
  setCaretPosition(0);
}",0.9815078236130867
61523,"protected void finalProcess(List<GraphTargetItem> list,int level,FinalProcessLocalData localData) throws InterruptedException {
  Set<Integer> removeFromList=new HashSet<>();
  for (int i=0; i < list.size(); i++) {
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    if (list.get(i) instanceof ForItem) {
      ForItem fori=(ForItem)list.get(i);
      int exprLine=fori.getLine();
      if (exprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == exprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            removeFromList.add(j);
          }
 else {
            break;
          }
        }
        fori.firstCommands.addAll(0,forFirstCommands);
      }
    }
    if (list.get(i) instanceof WhileItem) {
      WhileItem whi=(WhileItem)list.get(i);
      int whileExprLine=whi.getLine();
      if (whileExprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        List<GraphTargetItem> forFinalCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == whileExprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            removeFromList.add(j);
          }
 else {
            break;
          }
        }
        for (int j=whi.commands.size() - 1; j >= 0; j--) {
          if (whi.commands.get(j).getLine() == whileExprLine && !(whi.commands.get(j) instanceof LoopItem)) {
            forFinalCommands.add(0,whi.commands.remove(j));
          }
 else {
            break;
          }
        }
        if (!forFirstCommands.isEmpty() || !forFinalCommands.isEmpty()) {
          if (forFirstCommands.size() > 2 || forFinalCommands.size() > 2) {
            removeFromList.clear();
            whi.commands.addAll(forFinalCommands);
          }
          if (whi.commands.isEmpty() && forFirstCommands.isEmpty()) {
            whi.commands.addAll(forFinalCommands);
          }
 else {
            GraphTargetItem lastExpr=whi.expression.remove(whi.expression.size() - 1);
            forFirstCommands.addAll(whi.expression);
            list.set(i,new ForItem(whi.getSrc(),whi.loop,forFirstCommands,lastExpr,forFinalCommands,whi.commands));
          }
        }
      }
    }
  }
  for (int i=list.size() - 1; i >= 0; i--) {
    if (removeFromList.contains(i)) {
      list.remove(i);
    }
  }
}","protected void finalProcess(List<GraphTargetItem> list,int level,FinalProcessLocalData localData) throws InterruptedException {
  boolean todelete[]=new boolean[list.size()];
  for (int i=0; i < list.size(); i++) {
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    if (list.get(i) instanceof ForItem) {
      ForItem fori=(ForItem)list.get(i);
      int exprLine=fori.getLine();
      if (exprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == exprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            todelete[j]=true;
          }
 else {
            break;
          }
        }
        fori.firstCommands.addAll(0,forFirstCommands);
      }
    }
    if (list.get(i) instanceof WhileItem) {
      WhileItem whi=(WhileItem)list.get(i);
      int whileExprLine=whi.getLine();
      if (whileExprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        List<GraphTargetItem> forFinalCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == whileExprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            todelete[j]=true;
          }
 else {
            break;
          }
        }
        for (int j=whi.commands.size() - 1; j >= 0; j--) {
          if (whi.commands.get(j).getLine() == whileExprLine && !(whi.commands.get(j) instanceof LoopItem)) {
            forFinalCommands.add(0,whi.commands.remove(j));
          }
 else {
            break;
          }
        }
        if (!forFirstCommands.isEmpty() || !forFinalCommands.isEmpty()) {
          if (forFirstCommands.size() > 2 || forFinalCommands.size() > 2) {
            for (int k=0; k < forFirstCommands.size(); k++) {
              todelete[i - 1 - k]=false;
            }
            whi.commands.addAll(forFinalCommands);
          }
 else           if (whi.commands.isEmpty() && forFirstCommands.isEmpty()) {
            whi.commands.addAll(forFinalCommands);
          }
 else {
            GraphTargetItem lastExpr=whi.expression.remove(whi.expression.size() - 1);
            forFirstCommands.addAll(whi.expression);
            list.set(i,new ForItem(whi.getSrc(),whi.loop,forFirstCommands,lastExpr,forFinalCommands,whi.commands));
          }
        }
      }
    }
  }
  for (int i=todelete.length - 1; i >= 0; i--) {
    if (todelete[i]) {
      list.remove(i);
    }
  }
}",0.91953125
61524,"private boolean calculateDebugFileLine(String debugFile,int debugLine,int pos,ABC abc,Set<Integer> seen){
  while (pos < code.size()) {
    AVM2Instruction ins=code.get(pos);
    if (seen.contains(pos)) {
      return true;
    }
    seen.add(pos);
    if (ins.definition instanceof DebugFileIns) {
      debugFile=abc.constants.getString(ins.operands[0]);
    }
    if (ins.definition instanceof DebugLineIns) {
      debugLine=ins.operands[0];
    }
    ins.setFileLine(debugFile,debugLine);
    if (ins.definition instanceof NewFunctionIns) {
      if ((pos + 1 < code.size()) && !(code.get(pos + 1).definition instanceof PopIns)) {
        MethodBody innerBody=abc.findBody(ins.operands[0]);
        innerBody.getCode().calculateDebugFileLine(debugFile,debugLine,0,abc,new HashSet<>());
      }
    }
    if (ins.definition instanceof ReturnValueIns) {
      return true;
    }
    if (ins.definition instanceof ReturnVoidIns) {
      return true;
    }
    if (ins.definition instanceof JumpIns) {
      try {
        pos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        continue;
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
 else     if (ins.definition instanceof IfTypeIns) {
      try {
        int newpos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen);
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
    if (ins.definition instanceof LookupSwitchIns) {
      for (int i=0; i < ins.operands.length; i++) {
        if (i == 1) {
          continue;
        }
        try {
          int newpos=adr2pos(pos2adr(pos) + ins.operands[i]);
          if (!calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen)) {
            return false;
          }
        }
 catch (        ConvertException ex) {
          return false;
        }
      }
    }
    pos++;
  }
  return true;
}","private boolean calculateDebugFileLine(String debugFile,int debugLine,int pos,ABC abc,Set<Integer> seen){
  while (pos < code.size()) {
    AVM2Instruction ins=code.get(pos);
    if (seen.contains(pos)) {
      return true;
    }
    seen.add(pos);
    if (ins.definition instanceof DebugFileIns) {
      debugFile=abc.constants.getString(ins.operands[0]);
    }
    if (ins.definition instanceof DebugLineIns) {
      debugLine=ins.operands[0];
    }
    ins.setFileLine(debugFile,debugLine);
    if (ins.definition instanceof NewFunctionIns) {
      if ((pos + 1 < code.size()) && !(code.get(pos + 1).definition instanceof PopIns)) {
        MethodBody innerBody=abc.findBody(ins.operands[0]);
        if (innerBody != null) {
          innerBody.getCode().calculateDebugFileLine(debugFile,debugLine,0,abc,new HashSet<>());
        }
      }
    }
    if (ins.definition instanceof ReturnValueIns) {
      return true;
    }
    if (ins.definition instanceof ReturnVoidIns) {
      return true;
    }
    if (ins.definition instanceof JumpIns) {
      try {
        pos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        continue;
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
 else     if (ins.definition instanceof IfTypeIns) {
      try {
        int newpos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen);
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
    if (ins.definition instanceof LookupSwitchIns) {
      for (int i=0; i < ins.operands.length; i++) {
        if (i == 1) {
          continue;
        }
        try {
          int newpos=adr2pos(pos2adr(pos) + ins.operands[i]);
          if (!calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen)) {
            return false;
          }
        }
 catch (        ConvertException ex) {
          return false;
        }
      }
    }
    pos++;
  }
  return true;
}",0.9886792452830188
61525,"private int visitCode(Reference<AVM2Instruction> assignment,Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result,Set<Integer> ignored,Set<Integer> ignoredGets) throws InterruptedException {
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  List<Integer> toVisit=new ArrayList<>();
  toVisit.add(idx);
  List<TranslateStack> toVisitStacks=new ArrayList<>();
  toVisitStacks.add(stack);
  while (!toVisit.isEmpty()) {
    idx=toVisit.remove(0);
    stack=toVisitStacks.remove(0);
    try {
      while (true) {
        if (idx > endIdx) {
          break;
        }
        if (visited.contains(idx)) {
          break;
        }
        visited.add(idx);
        AVM2Instruction ins=code.code.get(idx);
        InstructionDefinition def=ins.definition;
        ins.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
        if (def instanceof SetLocalTypeIns) {
          int regId=((SetLocalTypeIns)def).getRegisterId(ins);
          if (!ignored.contains(regId)) {
            assignment.setVal(ins);
            return regId;
          }
        }
 else         if (def instanceof GetLocalTypeIns) {
          int regId=((GetLocalTypeIns)def).getRegisterId(ins);
          if (!ignored.contains(regId) && !ignoredGets.contains(regId)) {
            assignment.setVal(ins);
            return regId;
          }
        }
 else {
          for (int p=0; p < ins.definition.operands.length; p++) {
            int op=ins.definition.operands[p];
            if (op == AVM2Code.DAT_REGISTER_INDEX) {
              int regId=ins.operands[p];
              if (!ignored.contains(regId)) {
                assignment.setVal(ins);
                return regId;
              }
            }
          }
        }
        idx++;
        if (ins.definition instanceof JumpIns) {
          long address=ins.offset + ins.getBytesLength() + ins.operands[0];
          idx=code.adr2pos(address);
          if (idx == -1) {
            throw new TranslateException(""String_Node_Str"" + address);
          }
        }
        if (ins.isBranch()) {
          List<Integer> branches=ins.getBranches(new GraphSource(){
            @Override public int size(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public GraphSourceItem get(            int pos){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public boolean isEmpty(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public List<GraphTargetItem> translatePart(            GraphPart part,            BaseLocalData localData,            TranslateStack stack,            int start,            int end,            int staticOperation,            String path) throws InterruptedException {
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public int adr2pos(            long adr){
              return code.adr2pos(adr);
            }
            @Override public long pos2adr(            int pos){
              return code.pos2adr(pos);
            }
          }
);
          idx=branches.get(0);
          for (int n=1; n < branches.size(); n++) {
            int nidx=branches.get(n);
            if (visited.contains(nidx)) {
              continue;
            }
            toVisit.add(nidx);
            toVisitStacks.add((TranslateStack)stack.clone());
          }
        }
        if (ins.definition instanceof ReturnValueIns) {
          break;
        }
        if (ins.definition instanceof ThrowIns) {
          break;
        }
        if (ins.definition instanceof ReturnVoidIns) {
          break;
        }
      }
    }
 catch (    InterruptedException ex) {
      throw ex;
    }
catch (    Throwable ex) {
    }
  }
  return -1;
}","private int visitCode(Reference<AVM2Instruction> assignment,Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result,Set<Integer> ignored,Set<Integer> ignoredGets) throws InterruptedException {
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  List<Integer> toVisit=new ArrayList<>();
  toVisit.add(idx);
  List<TranslateStack> toVisitStacks=new ArrayList<>();
  toVisitStacks.add(stack);
  while (!toVisit.isEmpty()) {
    idx=toVisit.remove(0);
    stack=toVisitStacks.remove(0);
    try {
      while (true) {
        if (idx > endIdx) {
          break;
        }
        if (visited.contains(idx)) {
          break;
        }
        visited.add(idx);
        AVM2Instruction ins=code.code.get(idx);
        InstructionDefinition def=ins.definition;
        ins.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
        if (def instanceof SetLocalTypeIns) {
          int regId=((SetLocalTypeIns)def).getRegisterId(ins);
          if (!ignored.contains(regId)) {
            assignment.setVal(ins);
            return regId;
          }
        }
 else         if (def instanceof GetLocalTypeIns) {
          int regId=((GetLocalTypeIns)def).getRegisterId(ins);
          if (!ignored.contains(regId) && !ignoredGets.contains(regId)) {
            assignment.setVal(ins);
            return regId;
          }
        }
 else {
          for (int p=0; p < ins.definition.operands.length; p++) {
            int op=ins.definition.operands[p];
            if (op == AVM2Code.DAT_REGISTER_INDEX) {
              int regId=ins.operands[p];
              if (!ignored.contains(regId)) {
                assignment.setVal(ins);
                return regId;
              }
            }
          }
        }
        idx++;
        if (ins.definition instanceof JumpIns) {
          long address=ins.offset + ins.getBytesLength() + ins.operands[0];
          idx=code.adr2pos(address);
          if (idx == -1) {
            throw new TranslateException(""String_Node_Str"" + address);
          }
        }
        if (ins.isBranch()) {
          List<Integer> branches=ins.getBranches(new GraphSource(){
            @Override public int size(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public GraphSourceItem get(            int pos){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public boolean isEmpty(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public List<GraphTargetItem> translatePart(            GraphPart part,            BaseLocalData localData,            TranslateStack stack,            int start,            int end,            int staticOperation,            String path) throws InterruptedException {
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public int adr2pos(            long adr){
              return code.adr2pos(adr);
            }
            @Override public long pos2adr(            int pos){
              return code.pos2adr(pos);
            }
          }
);
          idx=branches.get(0);
          for (int n=1; n < branches.size(); n++) {
            int nidx=branches.get(n);
            if (visited.contains(nidx)) {
              continue;
            }
            toVisit.add(nidx);
            toVisitStacks.add((TranslateStack)stack.clone());
          }
        }
        if (ins.definition instanceof ReturnValueIns) {
          break;
        }
        if (ins.definition instanceof ThrowIns) {
          break;
        }
        if (ins.definition instanceof ReturnVoidIns) {
          break;
        }
      }
    }
 catch (    ThreadDeath|InterruptedException ex) {
      throw ex;
    }
catch (    Throwable ex) {
    }
  }
  return -1;
}",0.9985493230174082
61526,"public MethodBody convertMethodBody(String path,boolean isStatic,int scriptIndex,int classIndex,ABC abc,Trait trait,AVM2ConstantPool constants,List<MethodInfo> method_info,ScopeStack scopeStack,boolean isStaticInitializer,List<String> fullyQualifiedNames,Traits initTraits) throws InterruptedException {
  MethodBody body=clone();
  AVM2Code code=body.getCode();
  code.markMappedOffsets();
  code.fixJumps(path,body);
  if (Configuration.autoDeobfuscate.get()) {
    try {
      code.removeTraps(constants,trait,method_info.get(this.method_info),body,abc,scriptIndex,classIndex,isStatic,path);
    }
 catch (    InterruptedException ex) {
      throw ex;
    }
catch (    Throwable ex) {
      return this;
    }
  }
  return body;
}","public MethodBody convertMethodBody(String path,boolean isStatic,int scriptIndex,int classIndex,ABC abc,Trait trait,AVM2ConstantPool constants,List<MethodInfo> method_info,ScopeStack scopeStack,boolean isStaticInitializer,List<String> fullyQualifiedNames,Traits initTraits) throws InterruptedException {
  MethodBody body=clone();
  AVM2Code code=body.getCode();
  code.markMappedOffsets();
  code.fixJumps(path,body);
  if (Configuration.autoDeobfuscate.get()) {
    try {
      code.removeTraps(constants,trait,method_info.get(this.method_info),body,abc,scriptIndex,classIndex,isStatic,path);
    }
 catch (    ThreadDeath|InterruptedException ex) {
      throw ex;
    }
catch (    Throwable ex) {
      return this;
    }
  }
  return body;
}",0.991891891891892
61527,"protected void finalProcess(List<GraphTargetItem> list,int level,FinalProcessLocalData localData) throws InterruptedException {
  boolean toDelete[]=new boolean[list.size()];
  for (int i=0; i < list.size(); i++) {
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    GraphTargetItem itemI=list.get(i);
    if (itemI instanceof ForItem) {
      ForItem fori=(ForItem)itemI;
      int exprLine=fori.getLine();
      if (exprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == exprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            toDelete[j]=true;
          }
 else {
            break;
          }
        }
        fori.firstCommands.addAll(0,forFirstCommands);
      }
    }
    if (itemI instanceof WhileItem) {
      WhileItem whi=(WhileItem)itemI;
      int whileExprLine=whi.getLine();
      if (whileExprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        List<GraphTargetItem> forFinalCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          GraphTargetItem itemJ=list.get(i);
          if (itemJ.getLine() == whileExprLine && !(itemJ instanceof LoopItem)) {
            forFirstCommands.add(0,itemJ);
            toDelete[j]=true;
          }
 else {
            break;
          }
        }
        for (int j=whi.commands.size() - 1; j >= 0; j--) {
          if (whi.commands.get(j).getLine() == whileExprLine && !(whi.commands.get(j) instanceof LoopItem)) {
            forFinalCommands.add(0,whi.commands.remove(j));
          }
 else {
            break;
          }
        }
        if (!forFirstCommands.isEmpty() || !forFinalCommands.isEmpty()) {
          if (forFirstCommands.size() > 2 || forFinalCommands.size() > 2) {
            for (int k=0; k < forFirstCommands.size(); k++) {
              toDelete[i - 1 - k]=false;
            }
            whi.commands.addAll(forFinalCommands);
          }
 else           if (whi.commands.isEmpty() && forFirstCommands.isEmpty()) {
            whi.commands.addAll(forFinalCommands);
          }
 else {
            GraphTargetItem lastExpr=whi.expression.remove(whi.expression.size() - 1);
            forFirstCommands.addAll(whi.expression);
            list.set(i,new ForItem(whi.getSrc(),whi.loop,forFirstCommands,lastExpr,forFinalCommands,whi.commands));
          }
        }
      }
    }
  }
  for (int i=toDelete.length - 1; i >= 0; i--) {
    if (toDelete[i]) {
      list.remove(i);
    }
  }
}","protected void finalProcess(List<GraphTargetItem> list,int level,FinalProcessLocalData localData) throws InterruptedException {
  boolean toDelete[]=new boolean[list.size()];
  for (int i=0; i < list.size(); i++) {
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    GraphTargetItem itemI=list.get(i);
    if (itemI instanceof ForItem) {
      ForItem fori=(ForItem)itemI;
      int exprLine=fori.getLine();
      if (exprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          if (list.get(j).getLine() == exprLine && !(list.get(j) instanceof LoopItem)) {
            forFirstCommands.add(0,list.get(j));
            toDelete[j]=true;
          }
 else {
            break;
          }
        }
        fori.firstCommands.addAll(0,forFirstCommands);
      }
    }
    if (itemI instanceof WhileItem) {
      WhileItem whi=(WhileItem)itemI;
      int whileExprLine=whi.getLine();
      if (whileExprLine > 0) {
        List<GraphTargetItem> forFirstCommands=new ArrayList<>();
        List<GraphTargetItem> forFinalCommands=new ArrayList<>();
        for (int j=i - 1; j >= 0; j--) {
          GraphTargetItem itemJ=list.get(j);
          if (itemJ.getLine() == whileExprLine && !(itemJ instanceof LoopItem)) {
            forFirstCommands.add(0,itemJ);
            toDelete[j]=true;
          }
 else {
            break;
          }
        }
        for (int j=whi.commands.size() - 1; j >= 0; j--) {
          if (whi.commands.get(j).getLine() == whileExprLine && !(whi.commands.get(j) instanceof LoopItem)) {
            forFinalCommands.add(0,whi.commands.remove(j));
          }
 else {
            break;
          }
        }
        if (!forFirstCommands.isEmpty() || !forFinalCommands.isEmpty()) {
          if (forFirstCommands.size() > 2 || forFinalCommands.size() > 2) {
            for (int k=0; k < forFirstCommands.size(); k++) {
              toDelete[i - 1 - k]=false;
            }
            whi.commands.addAll(forFinalCommands);
          }
 else           if (whi.commands.isEmpty() && forFirstCommands.isEmpty()) {
            whi.commands.addAll(forFinalCommands);
          }
 else {
            GraphTargetItem lastExpr=whi.expression.remove(whi.expression.size() - 1);
            forFirstCommands.addAll(whi.expression);
            list.set(i,new ForItem(whi.getSrc(),whi.loop,forFirstCommands,lastExpr,forFinalCommands,whi.commands));
          }
        }
      }
    }
  }
  for (int i=toDelete.length - 1; i >= 0; i--) {
    if (toDelete[i]) {
      list.remove(i);
    }
  }
}",0.9996204933586338
61528,"private void getPrecontinues(String path,BaseLocalData localData,GraphPart parent,GraphPart part,List<GraphPart> allParts,List<Loop> loops,List<GraphPart> stopPart) throws InterruptedException {
  try {
    markLevels(path,localData,part,allParts,loops);
  }
 catch (  InterruptedException iex) {
    throw iex;
  }
catch (  Throwable ex) {
  }
  looploops:   for (  Loop l : loops) {
    if (l.loopContinue != null) {
      Set<GraphPart> uniqueRefs=new HashSet<>();
      uniqueRefs.addAll(l.loopContinue.refs);
      if (uniqueRefs.size() == 2) {
        List<GraphPart> uniqueRefsList=new ArrayList<>(uniqueRefs);
        if (uniqueRefsList.get(0).discoveredTime > uniqueRefsList.get(1).discoveredTime) {
          part=uniqueRefsList.get(0);
        }
 else {
          part=uniqueRefsList.get(1);
        }
        if (part == l.loopContinue) {
          continue looploops;
        }
        while (part.refs.size() == 1) {
          if (part.refs.get(0).nextParts.size() != 1) {
            continue looploops;
          }
          part=part.refs.get(0);
          if (part == l.loopContinue) {
            break;
          }
        }
        if (part.level == 0 && part != l.loopContinue) {
          l.loopPreContinue=part;
        }
      }
    }
  }
}","private void getPrecontinues(String path,BaseLocalData localData,GraphPart parent,GraphPart part,List<GraphPart> allParts,List<Loop> loops,List<GraphPart> stopPart) throws InterruptedException {
  try {
    markLevels(path,localData,part,allParts,loops);
  }
 catch (  ThreadDeath|InterruptedException iex) {
    throw iex;
  }
catch (  Throwable ex) {
  }
  looploops:   for (  Loop l : loops) {
    if (l.loopContinue != null) {
      Set<GraphPart> uniqueRefs=new HashSet<>();
      uniqueRefs.addAll(l.loopContinue.refs);
      if (uniqueRefs.size() == 2) {
        List<GraphPart> uniqueRefsList=new ArrayList<>(uniqueRefs);
        if (uniqueRefsList.get(0).discoveredTime > uniqueRefsList.get(1).discoveredTime) {
          part=uniqueRefsList.get(0);
        }
 else {
          part=uniqueRefsList.get(1);
        }
        if (part == l.loopContinue) {
          continue looploops;
        }
        while (part.refs.size() == 1) {
          if (part.refs.get(0).nextParts.size() != 1) {
            continue looploops;
          }
          part=part.refs.get(0);
          if (part == l.loopContinue) {
            break;
          }
        }
        if (part.level == 0 && part != l.loopContinue) {
          l.loopPreContinue=part;
        }
      }
    }
  }
}",0.995279307631786
61529,"private boolean calculateDebugFileLine(String debugFile,int debugLine,int pos,ABC abc,Set<Integer> seen){
  while (pos < code.size()) {
    AVM2Instruction ins=code.get(pos);
    if (seen.contains(pos)) {
      return true;
    }
    seen.add(pos);
    if (ins.definition instanceof DebugFileIns) {
      debugFile=abc.constants.getString(ins.operands[0]);
    }
    if (ins.definition instanceof DebugLineIns) {
      debugLine=ins.operands[0];
    }
    ins.setFileLine(debugFile,debugLine);
    if (ins.definition instanceof NewFunctionIns) {
      if ((pos + 1 < code.size()) && !(code.get(pos + 1).definition instanceof PopIns)) {
        MethodBody innerBody=abc.findBody(ins.operands[0]);
        innerBody.getCode().calculateDebugFileLine(debugFile,debugLine,0,abc,new HashSet<>());
      }
    }
    if (ins.definition instanceof ReturnValueIns) {
      return true;
    }
    if (ins.definition instanceof ReturnVoidIns) {
      return true;
    }
    if (ins.definition instanceof JumpIns) {
      try {
        pos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        continue;
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
 else     if (ins.definition instanceof IfTypeIns) {
      try {
        int newpos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen);
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
    if (ins.definition instanceof LookupSwitchIns) {
      for (int i=0; i < ins.operands.length; i++) {
        if (i == 1) {
          continue;
        }
        try {
          int newpos=adr2pos(pos2adr(pos) + ins.operands[i]);
          if (!calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen)) {
            return false;
          }
        }
 catch (        ConvertException ex) {
          return false;
        }
      }
    }
    pos++;
  }
  return true;
}","private boolean calculateDebugFileLine(String debugFile,int debugLine,int pos,ABC abc,Set<Integer> seen){
  while (pos < code.size()) {
    AVM2Instruction ins=code.get(pos);
    if (seen.contains(pos)) {
      return true;
    }
    seen.add(pos);
    if (ins.definition instanceof DebugFileIns) {
      debugFile=abc.constants.getString(ins.operands[0]);
    }
    if (ins.definition instanceof DebugLineIns) {
      debugLine=ins.operands[0];
    }
    ins.setFileLine(debugFile,debugLine);
    if (ins.definition instanceof NewFunctionIns) {
      if ((pos + 1 < code.size()) && !(code.get(pos + 1).definition instanceof PopIns)) {
        MethodBody innerBody=abc.findBody(ins.operands[0]);
        if (innerBody != null) {
          innerBody.getCode().calculateDebugFileLine(debugFile,debugLine,0,abc,new HashSet<>());
        }
      }
    }
    if (ins.definition instanceof ReturnValueIns) {
      return true;
    }
    if (ins.definition instanceof ReturnVoidIns) {
      return true;
    }
    if (ins.definition instanceof JumpIns) {
      try {
        pos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        continue;
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
 else     if (ins.definition instanceof IfTypeIns) {
      try {
        int newpos=adr2pos(pos2adr(pos) + ins.getBytesLength() + ins.operands[0]);
        calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen);
      }
 catch (      ConvertException ex) {
        return false;
      }
    }
    if (ins.definition instanceof LookupSwitchIns) {
      for (int i=0; i < ins.operands.length; i++) {
        if (i == 1) {
          continue;
        }
        try {
          int newpos=adr2pos(pos2adr(pos) + ins.operands[i]);
          if (!calculateDebugFileLine(debugFile,debugLine,newpos,abc,seen)) {
            return false;
          }
        }
 catch (        ConvertException ex) {
          return false;
        }
      }
    }
    pos++;
  }
  return true;
}",0.9886792452830188
61530,"@Override protected int checkIp(int ip){
  int oldIp=ip;
  GraphSourceItem action=code.get(ip);
  if ((action instanceof ActionPush) && (((ActionPush)action).values.size() == 1) && (((ActionPush)action).values.get(0) instanceof Null)) {
    if (ip + 3 < code.size()) {
      if ((code.get(ip + 1) instanceof ActionEquals) || (code.get(ip + 1) instanceof ActionEquals2)) {
        if (code.get(ip + 2) instanceof ActionNot) {
          if (code.get(ip + 3) instanceof ActionIf) {
            ActionIf aif=(ActionIf)code.get(ip + 3);
            if (code.adr2pos(code.pos2adr(ip + 4) + aif.getJumpOffset()) == ip) {
              ip+=4;
            }
          }
        }
      }
    }
  }
  if (oldIp != ip) {
    return checkIp(ip);
  }
  return ip;
}","@Override protected int checkIp(int ip){
  int oldIp=ip;
  GraphSourceItem action=code.get(ip);
  if ((action instanceof ActionPush) && (((ActionPush)action).values.size() == 1) && (((ActionPush)action).values.get(0) instanceof Null)) {
    if (ip + 4 < code.size()) {
      if ((code.get(ip + 1) instanceof ActionEquals) || (code.get(ip + 1) instanceof ActionEquals2)) {
        if (code.get(ip + 2) instanceof ActionNot) {
          if (code.get(ip + 3) instanceof ActionIf) {
            ActionIf aif=(ActionIf)code.get(ip + 3);
            if (code.adr2pos(code.pos2adr(ip + 4) + aif.getJumpOffset()) == ip) {
              ip+=4;
            }
          }
        }
      }
    }
  }
  if (oldIp != ip) {
    return checkIp(ip);
  }
  return ip;
}",0.9986702127659576
61531,"private GraphTargetItem type(List<VariableActionItem> variables) throws IOException, ActionParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING_OP);
  ret=new VariableActionItem(s.value.toString(),null,false);
  variables.add((VariableActionItem)ret);
  s=lex();
  while (s.type == SymbolType.DOT) {
    s=lex();
    expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING_OP);
    ret=new GetMemberActionItem(null,ret,pushConst(s.value.toString()));
    s=lex();
  }
  lexer.pushback(s);
  return ret;
}","private GraphTargetItem type(List<VariableActionItem> variables) throws IOException, ActionParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING_OP);
  ret=new VariableActionItem(s.value.toString(),null,false);
  variables.add((VariableActionItem)ret);
  s=lex();
  while (s.type == SymbolType.DOT) {
    s=lex();
    expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING_OP,SymbolGroup.GLOBALFUNC);
    ret=new GetMemberActionItem(null,ret,pushConst(s.value.toString()));
    s=lex();
  }
  lexer.pushback(s);
  return ret;
}",0.981132075471698
61532,"private GraphTargetItem memberOrCall(GraphTargetItem ret,boolean inFunction,boolean inMethod,List<VariableActionItem> variables) throws IOException, ActionParseException {
  ParsedSymbol op=lex();
  while (op.isType(SymbolType.PARENT_OPEN,SymbolType.BRACKET_OPEN,SymbolType.DOT)) {
    if (op.type == SymbolType.PARENT_OPEN) {
      List<GraphTargetItem> args=call(inFunction,inMethod,variables);
      if (ret instanceof GetMemberActionItem) {
        GetMemberActionItem mem=(GetMemberActionItem)ret;
        ret=new CallMethodActionItem(null,mem.object,mem.memberName,args);
      }
 else       if (ret instanceof VariableActionItem) {
        VariableActionItem var=(VariableActionItem)ret;
        ret=new CallFunctionActionItem(null,pushConst(var.getVariableName()),args);
      }
 else {
        ret=new CallFunctionActionItem(null,ret,args);
      }
    }
    if (op.type == SymbolType.BRACKET_OPEN) {
      GraphTargetItem rhs=expression(inFunction,inMethod,false,variables);
      ret=new GetMemberActionItem(null,ret,rhs);
      expectedType(SymbolType.BRACKET_CLOSE);
    }
    if (op.type == SymbolType.DOT) {
      ParsedSymbol s=lex();
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
      ret=new GetMemberActionItem(null,ret,pushConst(s.value.toString()));
    }
    op=lex();
  }
  lexer.pushback(op);
  return ret;
}","private GraphTargetItem memberOrCall(GraphTargetItem ret,boolean inFunction,boolean inMethod,List<VariableActionItem> variables) throws IOException, ActionParseException {
  ParsedSymbol op=lex();
  while (op.isType(SymbolType.PARENT_OPEN,SymbolType.BRACKET_OPEN,SymbolType.DOT)) {
    if (op.type == SymbolType.PARENT_OPEN) {
      List<GraphTargetItem> args=call(inFunction,inMethod,variables);
      if (ret instanceof GetMemberActionItem) {
        GetMemberActionItem mem=(GetMemberActionItem)ret;
        ret=new CallMethodActionItem(null,mem.object,mem.memberName,args);
      }
 else       if (ret instanceof VariableActionItem) {
        VariableActionItem var=(VariableActionItem)ret;
        ret=new CallFunctionActionItem(null,pushConst(var.getVariableName()),args);
      }
 else {
        ret=new CallFunctionActionItem(null,ret,args);
      }
    }
    if (op.type == SymbolType.BRACKET_OPEN) {
      GraphTargetItem rhs=expression(inFunction,inMethod,false,variables);
      ret=new GetMemberActionItem(null,ret,rhs);
      expectedType(SymbolType.BRACKET_CLOSE);
    }
    if (op.type == SymbolType.DOT) {
      ParsedSymbol s=lex();
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP,SymbolGroup.GLOBALFUNC);
      ret=new GetMemberActionItem(null,ret,pushConst(s.value.toString()));
    }
    op=lex();
  }
  lexer.pushback(op);
  return ret;
}",0.9918352857649982
61533,"protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (!stack.isEmpty() && onFalse.isEmpty() && onTrue.size() == 2 && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)) {
            GraphTargetItem prevExpr=stack.pop();
            GraphTargetItem leftSide=expr;
            GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
            if (leftSide instanceof DuplicateItem) {
              isIf=false;
              stack.push(new OrItem(null,prevExpr,rightSide));
            }
 else             if (leftSide.invert(null) instanceof DuplicateItem) {
              isIf=false;
              stack.push(new AndItem(null,prevExpr,rightSide));
            }
 else             if (prevExpr instanceof FalseItem) {
              isIf=false;
              stack.push(new OrItem(null,leftSide,rightSide));
            }
 else             if (prevExpr instanceof TrueItem) {
              isIf=false;
              stack.push(new AndItem(null,leftSide,rightSide));
            }
 else {
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.src,currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.src,currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(Map<GraphPart,List<GraphTargetItem>> partCodes,Map<GraphPart,Integer> partCodePos,List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    if (debugMode) {
      System.err.println(""String_Node_Str"" + part);
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  if (visited.contains(part)) {
    String labelName=""String_Node_Str"" + part.start;
    List<GraphTargetItem> firstCode=partCodes.get(part);
    int firstCodePos=partCodePos.get(part);
    if (firstCodePos > firstCode.size()) {
      firstCodePos=firstCode.size();
    }
    if (firstCode.size() > firstCodePos && (firstCode.get(firstCodePos) instanceof LabelItem)) {
      labelName=((LabelItem)firstCode.get(firstCodePos)).labelName;
    }
 else {
      firstCode.add(firstCodePos,new LabelItem(null,labelName));
    }
    ret.add(new GotoItem(null,labelName));
    return ret;
  }
 else {
    visited.add(part);
    partCodes.put(part,ret);
    partCodePos.put(part,ret.size());
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  TranslateStack sPreLoop=stack;
  if (isLoop) {
    stack=(TranslateStack)stack.clone();
    stack.clear();
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(partCodes,partCodePos,code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext) {
    if (part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      makeAllCommands(currentRet,stack);
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      Map<Integer,GraphTargetItem> caseExpressions=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionLeftSides=new HashMap<>();
      Map<Integer,GraphTargetItem> caseExpressionRightSides=new HashMap<>();
      GraphTargetItem it=switchedItem;
      int defaultBranch=0;
      boolean hasExpr=false;
      while (it instanceof TernarOpItem) {
        TernarOpItem to=(TernarOpItem)it;
        if (to.expression instanceof EqualsTypeItem) {
          if (to.onTrue instanceof IntegerValueTypeItem) {
            int cpos=((IntegerValueTypeItem)to.onTrue).intValue();
            caseExpressionLeftSides.put(cpos,((EqualsTypeItem)to.expression).getLeftSide());
            caseExpressionRightSides.put(cpos,((EqualsTypeItem)to.expression).getRightSide());
            it=to.onFalse;
          }
 else {
            break;
          }
        }
 else {
          break;
        }
      }
      if (it instanceof IntegerValueTypeItem) {
        defaultBranch=((IntegerValueTypeItem)it).intValue();
      }
      if (!caseExpressionRightSides.isEmpty()) {
        GraphTargetItem firstItem;
        firstItem=(GraphTargetItem)caseExpressionRightSides.values().toArray()[0];
        boolean sameRight=true;
        for (        GraphTargetItem cit : caseExpressionRightSides.values()) {
          if (!cit.equals(firstItem)) {
            sameRight=false;
            break;
          }
        }
        if (sameRight) {
          caseExpressions=caseExpressionLeftSides;
          switchedItem=firstItem;
          hasExpr=true;
        }
 else {
          firstItem=(GraphTargetItem)caseExpressionLeftSides.values().toArray()[0];
          boolean sameLeft=true;
          for (          GraphTargetItem cit : caseExpressionLeftSides.values()) {
            if (!cit.equals(firstItem)) {
              sameLeft=false;
              break;
            }
          }
          if (sameLeft) {
            caseExpressions=caseExpressionRightSides;
            switchedItem=firstItem;
            hasExpr=true;
          }
        }
      }
      first=true;
      pos=0;
      GraphPart defaultPart=hasExpr ? part.nextParts.get(1 + defaultBranch) : part.nextParts.get(0);
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (caseExpressions.containsKey(pos)) {
            caseValues.add(caseExpressions.get(pos));
          }
 else {
            caseValues.add(new IntegerValueItem(null,pos));
          }
          pos++;
        }
      }
      first=true;
      pos=0;
      List<GraphTargetItem> nextCommands=new ArrayList<>();
      for (      GraphPart p : part.nextParts) {
        if (p != defaultPart) {
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (p == defaultPart && !defaultCommands.isEmpty()) {
          }
 else {
            TranslateStack s2=(TranslateStack)stack.clone();
            s2.clear();
            nextCommands=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),s2,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            makeAllCommands(nextCommands,s2);
            if (p == defaultPart) {
              defaultCommands=nextCommands;
            }
 else {
              caseCommands.add(nextCommands);
            }
            vis.add(p);
          }
        }
 else {
          if (p == defaultPart) {
            defaultCommands=nextCommands;
          }
 else {
            caseCommands.add(nextCommands);
          }
        }
        first=false;
        pos++;
      }
      if (!defaultCommands.isEmpty() && (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem)) {
        BreakItem bi=(BreakItem)defaultCommands.get(defaultCommands.size() - 1);
        if (bi.loopId == swLoop.id) {
          defaultCommands.remove(defaultCommands.size() - 1);
        }
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
      pos++;
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        boolean isEmpty=nps.get(0) == nps.get(1);
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        trueStack.clear();
        falseStack.clear();
        if (isEmpty) {
          next=nps.get(0);
        }
        boolean hasOntrue=nps.get(1) != next;
        boolean hasOnFalse=nps.get(0) != next;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if ((!isEmpty) && (next != null)) {
          stopPart2.add(next);
        }
        List<GraphTargetItem> onTrue=new ArrayList<>();
        if (!isEmpty && hasOntrue) {
          onTrue=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty && hasOnFalse) {
          onFalse=printGraph(partCodes,partCodePos,visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        makeAllCommands(onTrue,trueStack);
        makeAllCommands(onFalse,falseStack);
        if (!isEmpty(onTrue) && !isEmpty(onFalse) && onTrue.size() == 1 && onFalse.size() == 1 && (onTrue.get(0) instanceof PushItem) && (onFalse.get(0) instanceof PushItem)) {
          stack.push(new TernarOpItem(null,expr.invert(null),((PushItem)onTrue.get(0)).value,((PushItem)onFalse.get(0)).value));
        }
 else {
          boolean isIf=true;
          if (!stack.isEmpty() && onFalse.isEmpty() && onTrue.size() == 2 && (onTrue.get(0) instanceof PopItem) && (onTrue.get(1) instanceof PushItem)) {
            GraphTargetItem prevExpr=stack.pop();
            GraphTargetItem leftSide=expr;
            GraphTargetItem rightSide=((PushItem)onTrue.get(1)).value;
            if (leftSide instanceof DuplicateItem) {
              isIf=false;
              stack.push(new OrItem(null,prevExpr,rightSide));
            }
 else             if (leftSide.invert(null) instanceof DuplicateItem) {
              isIf=false;
              stack.push(new AndItem(null,prevExpr,rightSide));
            }
 else             if (prevExpr instanceof FalseItem) {
              isIf=false;
              stack.push(new OrItem(null,leftSide,rightSide));
            }
 else             if (prevExpr instanceof TrueItem) {
              isIf=false;
              stack.push(new AndItem(null,leftSide,rightSide));
            }
 else {
            }
          }
          if (isIf) {
            makeAllCommands(currentRet,stack);
            IfItem b=new IfItem(null,expr.invert(null),onTrue,onFalse);
            currentRet.add(b);
            if (processSubBlk(b,null)) {
              stack.push(new PopItem(null));
            }
          }
        }
        if (next != null) {
          printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(partCodes,partCodePos,visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            if (ifi.onTrue.isEmpty()) {
              inverted=true;
            }
            bodyBranch=inverted ? ifi.onFalse : ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert(null);
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(expr.src,currentLoop,new ArrayList<>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(expr.src,currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            expr=expr.invert(null);
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(partCodes,partCodePos,visited,localData,new TranslateStack(path),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                expr=expr.invert(null);
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(partCodes,partCodePos,visited,localData,sPreLoop,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}",0.9996819482938798
61534,"private void addTraitButtonActionPerformed(ActionEvent evt){
  int class_index=decompiledTextArea.getClassIndex();
  if (class_index < 0) {
    return;
  }
  if (newTraitDialog == null) {
    newTraitDialog=new NewTraitDialog();
  }
  int void_type=abc.constants.getPublicQnameId(""String_Node_Str"",true);
  int int_type=abc.constants.getPublicQnameId(""String_Node_Str"",true);
  Trait t=null;
  int kind;
  int nskind;
  String name=null;
  boolean isStatic;
  Multiname m;
  boolean again=false;
  loopm:   do {
    if (again) {
      View.showMessageDialog(null,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",name),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    }
    again=false;
    if (newTraitDialog.showDialog() != AppDialog.OK_OPTION) {
      return;
    }
    kind=newTraitDialog.getTraitType();
    nskind=newTraitDialog.getNamespaceKind();
    name=newTraitDialog.getTraitName();
    isStatic=newTraitDialog.getStatic();
    m=new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(nskind,abc.constants.getStringId(""String_Node_Str"",true)),0,true),0,0,new ArrayList<>());
    int mid=abc.constants.getMultinameId(m);
    if (mid == 0) {
      break;
    }
    for (    Trait tr : abc.class_info.get(class_index).static_traits.traits) {
      if (tr.name_index == mid) {
        again=true;
        break;
      }
    }
    for (    Trait tr : abc.instance_info.get(class_index).instance_traits.traits) {
      if (tr.name_index == mid) {
        again=true;
        break;
      }
    }
  }
 while (again);
switch (kind) {
case Trait.TRAIT_GETTER:
case Trait.TRAIT_SETTER:
case Trait.TRAIT_METHOD:
    TraitMethodGetterSetter tm=new TraitMethodGetterSetter();
  MethodInfo mi=new MethodInfo(new int[0],void_type,abc.constants.getStringId(name,true),0,new ValueKind[0],new int[0]);
int method_info=abc.addMethodInfo(mi);
tm.method_info=method_info;
MethodBody body=new MethodBody(abc);
body.method_info=method_info;
body.init_scope_depth=1;
body.max_regs=1;
body.max_scope_depth=1;
body.max_stack=1;
body.exceptions=new ABCException[0];
AVM2Code code=new AVM2Code();
code.code.add(new AVM2Instruction(0,new GetLocal0Ins(),new int[0]));
code.code.add(new AVM2Instruction(0,new PushScopeIns(),new int[0]));
code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[0]));
body.setCode(code);
Traits traits=new Traits();
traits.traits=new ArrayList<>();
body.traits=traits;
abc.addMethodBody(body);
mi.setBody(body);
t=tm;
break;
case Trait.TRAIT_SLOT:
case Trait.TRAIT_CONST:
TraitSlotConst ts=new TraitSlotConst();
ts.type_index=int_type;
ts.value_kind=ValueKind.CONSTANT_Int;
ts.value_index=abc.constants.getIntId(0,true);
t=ts;
break;
}
if (t != null) {
t.kindType=kind;
t.name_index=abc.constants.getMultinameId(m,true);
int traitId;
if (isStatic) {
traitId=abc.class_info.get(class_index).static_traits.addTrait(t);
}
 else {
traitId=abc.class_info.get(class_index).static_traits.traits.size() + abc.instance_info.get(class_index).instance_traits.addTrait(t);
}
reload();
decompiledTextArea.gotoTrait(traitId);
}
}","private void addTraitButtonActionPerformed(ActionEvent evt){
  int class_index=decompiledTextArea.getClassIndex();
  if (class_index < 0) {
    return;
  }
  if (newTraitDialog == null) {
    newTraitDialog=new NewTraitDialog();
  }
  int void_type=abc.constants.getPublicQnameId(""String_Node_Str"",true);
  int int_type=abc.constants.getPublicQnameId(""String_Node_Str"",true);
  Trait t=null;
  int kind;
  int nskind;
  String name=null;
  boolean isStatic;
  Multiname m;
  boolean again=false;
  loopm:   do {
    if (again) {
      View.showMessageDialog(null,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",name),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    }
    again=false;
    if (newTraitDialog.showDialog() != AppDialog.OK_OPTION) {
      return;
    }
    kind=newTraitDialog.getTraitType();
    nskind=newTraitDialog.getNamespaceKind();
    name=newTraitDialog.getTraitName();
    isStatic=newTraitDialog.getStatic();
    m=new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(nskind,abc.constants.getStringId(""String_Node_Str"",true)),0,true),0,0,new ArrayList<>());
    int mid=abc.constants.getMultinameId(m);
    if (mid == 0) {
      break;
    }
    for (    Trait tr : abc.class_info.get(class_index).static_traits.traits) {
      if (tr.name_index == mid) {
        again=true;
        break;
      }
    }
    for (    Trait tr : abc.instance_info.get(class_index).instance_traits.traits) {
      if (tr.name_index == mid) {
        again=true;
        break;
      }
    }
  }
 while (again);
switch (kind) {
case Trait.TRAIT_GETTER:
case Trait.TRAIT_SETTER:
case Trait.TRAIT_METHOD:
    TraitMethodGetterSetter tm=new TraitMethodGetterSetter();
  MethodInfo mi=new MethodInfo(new int[0],void_type,abc.constants.getStringId(name,true),0,new ValueKind[0],new int[0]);
int method_info=abc.addMethodInfo(mi);
tm.method_info=method_info;
MethodBody body=new MethodBody(abc);
body.method_info=method_info;
body.init_scope_depth=1;
body.max_regs=1;
body.max_scope_depth=1;
body.max_stack=1;
body.exceptions=new ABCException[0];
AVM2Code code=new AVM2Code();
code.code.add(new AVM2Instruction(0,new GetLocal0Ins(),new int[0]));
code.code.add(new AVM2Instruction(0,new PushScopeIns(),new int[0]));
code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[0]));
body.setCode(code);
Traits traits=new Traits();
traits.traits=new ArrayList<>();
body.traits=traits;
abc.addMethodBody(body);
mi.setBody(body);
t=tm;
break;
case Trait.TRAIT_SLOT:
case Trait.TRAIT_CONST:
TraitSlotConst ts=new TraitSlotConst();
ts.type_index=int_type;
ts.value_kind=ValueKind.CONSTANT_Int;
ts.value_index=abc.constants.getIntId(0,true);
t=ts;
break;
}
if (t != null) {
t.kindType=kind;
t.name_index=abc.constants.getMultinameId(m,true);
int traitId;
if (isStatic) {
traitId=abc.class_info.get(class_index).static_traits.addTrait(t);
}
 else {
traitId=abc.class_info.get(class_index).static_traits.traits.size() + abc.instance_info.get(class_index).instance_traits.addTrait(t);
}
int scriptIndex=decompiledTextArea.getScriptLeaf().scriptIndex;
if (scriptIndex >= 0 && scriptIndex < abc.script_info.size()) {
abc.script_info.get(scriptIndex).setModified(true);
}
((Tag)abc.parentTag).setModified(true);
reload();
decompiledTextArea.gotoTrait(traitId);
}
}",0.9543350817648872
61535,"private void visitCode(Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      if (visited.contains(idx)) {
        break;
      }
      visited.add(idx);
      AVM2Instruction action=code.code.get(idx);
      instructionsProcessed++;
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      InstructionDefinition def=action.definition;
      if (def instanceof SetLocalTypeIns) {
        SetLocalTypeIns slt=(SetLocalTypeIns)def;
        int regId=slt.getRegisterId(action);
        if (!result.assignCount.containsKey(regId)) {
          result.assignCount.put(regId,0);
        }
        result.assignCount.put(regId,result.assignCount.get(regId) + 1);
        GraphTargetItem regVal=localData.localRegs.get(regId);
        if (regVal == null || !regVal.getNotCoerced().isCompileTime()) {
          result.assignCount.put(regId,Integer.MAX_VALUE);
        }
 else {
          result.lastAssigned.put(regId,regVal.getNotCoerced());
        }
      }
      idx++;
      if (action.definition instanceof JumpIns) {
        long address=action.offset + action.getBytesLength() + action.operands[0];
        idx=code.adr2pos(address);
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
      if (action.isBranch()) {
        List<Integer> branches=action.getBranches(new GraphSource(){
          @Override public int size(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public GraphSourceItem get(          int pos){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public boolean isEmpty(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public List<GraphTargetItem> translatePart(          GraphPart part,          BaseLocalData localData,          TranslateStack stack,          int start,          int end,          int staticOperation,          String path) throws InterruptedException {
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public int adr2pos(          long adr){
            return code.adr2pos(adr);
          }
          @Override public long pos2adr(          int pos){
            return code.pos2adr(pos);
          }
        }
);
        idx=branches.get(0);
        for (int n=1; n < branches.size(); n++) {
          visitCode(visited,(TranslateStack)stack.clone(),classIndex,isStatic,body,scriptIndex,abc,code,branches.get(n),endIdx,result);
        }
      }
      if (action.definition instanceof ReturnValueIns) {
        break;
      }
      if (action.definition instanceof ThrowIns) {
        break;
      }
      if (action.definition instanceof ReturnVoidIns) {
        break;
      }
    }
  }
 catch (  Exception ex) {
  }
}","private void visitCode(Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  int instructionsProcessed=0;
  List<Integer> toVisit=new ArrayList<>();
  toVisit.add(idx);
  List<TranslateStack> toVisitStacks=new ArrayList<>();
  toVisitStacks.add(stack);
  while (!toVisit.isEmpty()) {
    idx=toVisit.remove(0);
    stack=toVisitStacks.remove(0);
    try {
      while (true) {
        if (idx > endIdx) {
          break;
        }
        if (visited.contains(idx)) {
          break;
        }
        visited.add(idx);
        AVM2Instruction action=code.code.get(idx);
        instructionsProcessed++;
        action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
        InstructionDefinition def=action.definition;
        if (def instanceof SetLocalTypeIns) {
          SetLocalTypeIns slt=(SetLocalTypeIns)def;
          int regId=slt.getRegisterId(action);
          if (!result.assignCount.containsKey(regId)) {
            result.assignCount.put(regId,0);
          }
          result.assignCount.put(regId,result.assignCount.get(regId) + 1);
          GraphTargetItem regVal=localData.localRegs.get(regId);
          if (regVal == null || !regVal.getNotCoerced().isCompileTime()) {
            result.assignCount.put(regId,Integer.MAX_VALUE);
          }
 else {
            result.lastAssigned.put(regId,regVal.getNotCoerced());
          }
        }
        idx++;
        if (action.definition instanceof JumpIns) {
          long address=action.offset + action.getBytesLength() + action.operands[0];
          idx=code.adr2pos(address);
          if (idx == -1) {
            throw new TranslateException(""String_Node_Str"" + address);
          }
        }
        if (action.isBranch()) {
          List<Integer> branches=action.getBranches(new GraphSource(){
            @Override public int size(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public GraphSourceItem get(            int pos){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public boolean isEmpty(){
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public List<GraphTargetItem> translatePart(            GraphPart part,            BaseLocalData localData,            TranslateStack stack,            int start,            int end,            int staticOperation,            String path) throws InterruptedException {
              throw new UnsupportedOperationException(""String_Node_Str"");
            }
            @Override public int adr2pos(            long adr){
              return code.adr2pos(adr);
            }
            @Override public long pos2adr(            int pos){
              return code.pos2adr(pos);
            }
          }
);
          idx=branches.get(0);
          for (int n=1; n < branches.size(); n++) {
            int nidx=branches.get(n);
            if (visited.contains(nidx)) {
              continue;
            }
            toVisit.add(nidx);
            toVisitStacks.add((TranslateStack)stack.clone());
          }
        }
        if (action.definition instanceof ReturnValueIns) {
          break;
        }
        if (action.definition instanceof ThrowIns) {
          break;
        }
        if (action.definition instanceof ReturnVoidIns) {
          break;
        }
      }
    }
 catch (    Exception ex) {
    }
  }
}",0.879977486984663
61536,"public ABC(ABCInputStream ais,SWF swf,ABCContainerTag tag) throws IOException {
  this.parentTag=tag;
  minor_version=ais.readU16(""String_Node_Str"");
  major_version=ais.readU16(""String_Node_Str"");
  logger.log(Level.FINE,""String_Node_Str"",new Object[]{minor_version,major_version});
  constants=new AVM2ConstantPool();
  ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
  int constant_int_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_int=new ArrayList<>(constant_int_pool_count);
  if (constant_int_pool_count > 0) {
    constants.addInt(0);
  }
  if (constant_int_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_int_pool_count; i++) {
      constants.addInt(ais.readS32(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_uint_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_uint=new ArrayList<>(constant_uint_pool_count);
  if (constant_uint_pool_count > 0) {
    constants.addUInt(0);
  }
  if (constant_uint_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_uint_pool_count; i++) {
      constants.addUInt(ais.readU32(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_double_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_double=new ArrayList<>(constant_double_pool_count);
  if (constant_double_pool_count > 0) {
    constants.addDouble(0);
  }
  if (constant_double_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_double_pool_count; i++) {
      constants.addDouble(ais.readDouble(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  if (minor_version >= MINORwithDECIMAL) {
    int constant_decimal_pool_count=ais.readU30(""String_Node_Str"");
    constants.constant_decimal=new ArrayList<>(constant_decimal_pool_count);
    if (constant_decimal_pool_count > 0) {
      constants.addDecimal(null);
    }
    if (constant_decimal_pool_count > 1) {
      ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
      for (int i=1; i < constant_decimal_pool_count; i++) {
        constants.addDecimal(ais.readDecimal(""String_Node_Str""));
      }
      ais.endDumpLevel();
    }
  }
 else {
    constants.constant_decimal=new ArrayList<>(0);
  }
  int constant_string_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_string=new ArrayList<>(constant_string_pool_count);
  stringOffsets=new long[constant_string_pool_count];
  if (constant_string_pool_count > 0) {
    constants.addString(""String_Node_Str"");
  }
  if (constant_string_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_string_pool_count; i++) {
      long pos=ais.getPosition();
      constants.addString(ais.readString(""String_Node_Str""));
      stringOffsets[i]=pos;
    }
    ais.endDumpLevel();
  }
  int constant_namespace_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_namespace=new ArrayList<>(constant_namespace_pool_count);
  if (constant_namespace_pool_count > 0) {
    constants.addNamespace(null);
  }
  if (constant_namespace_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_namespace_pool_count; i++) {
      constants.addNamespace(ais.readNamespace(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_namespace_set_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_namespace_set=new ArrayList<>(constant_namespace_set_pool_count);
  if (constant_namespace_set_pool_count > 0) {
    constants.addNamespaceSet(null);
  }
  if (constant_namespace_set_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_namespace_set_pool_count; i++) {
      ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
      constants.addNamespaceSet(new NamespaceSet());
      int namespace_count=ais.readU30(""String_Node_Str"");
      constants.getNamespaceSet(i).namespaces=new int[namespace_count];
      for (int j=0; j < namespace_count; j++) {
        constants.getNamespaceSet(i).namespaces[j]=ais.readU30(""String_Node_Str"");
      }
      ais.endDumpLevel();
    }
    ais.endDumpLevel();
  }
  int constant_multiname_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_multiname=new ArrayList<>(constant_multiname_pool_count);
  if (constant_multiname_pool_count > 0) {
    constants.addMultiname(null);
  }
  if (constant_multiname_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_multiname_pool_count; i++) {
      constants.addMultiname(ais.readMultiname(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  ais.endDumpLevel();
  int methods_count=ais.readU30(""String_Node_Str"");
  method_info=new ArrayList<>(methods_count);
  for (int i=0; i < methods_count; i++) {
    method_info.add(ais.readMethodInfo(""String_Node_Str""));
  }
  int metadata_count=ais.readU30(""String_Node_Str"");
  metadata_info=new ArrayList<>(metadata_count);
  for (int i=0; i < metadata_count; i++) {
    int name_index=ais.readU30(""String_Node_Str"");
    int values_count=ais.readU30(""String_Node_Str"");
    int[] keys=new int[values_count];
    for (int v=0; v < values_count; v++) {
      keys[v]=ais.readU30(""String_Node_Str"");
    }
    int[] values=new int[values_count];
    for (int v=0; v < values_count; v++) {
      values[v]=ais.readU30(""String_Node_Str"");
    }
    metadata_info.add(new MetadataInfo(name_index,keys,values));
  }
  int class_count=ais.readU30(""String_Node_Str"");
  instance_info=new ArrayList<>(class_count);
  for (int i=0; i < class_count; i++) {
    instance_info.add(ais.readInstanceInfo(""String_Node_Str""));
  }
  class_info=new ArrayList<>(class_count);
  for (int i=0; i < class_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    ClassInfo ci=new ClassInfo(null);
    ci.cinit_index=ais.readU30(""String_Node_Str"");
    ci.static_traits=ais.readTraits(""String_Node_Str"");
    class_info.add(ci);
    ais.endDumpLevel();
  }
  int script_count=ais.readU30(""String_Node_Str"");
  script_info=new ArrayList<>(script_count);
  for (int i=0; i < script_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    ScriptInfo si=new ScriptInfo(null);
    si.init_index=ais.readU30(""String_Node_Str"");
    si.traits=ais.readTraits(""String_Node_Str"");
    script_info.add(si);
    ais.endDumpLevel();
    si.setModified(false);
  }
  int bodies_count=ais.readU30(""String_Node_Str"");
  bodies=new ArrayList<>(bodies_count);
  for (int i=0; i < bodies_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    MethodBody mb=new MethodBody(null,null,null);
    mb.method_info=ais.readU30(""String_Node_Str"");
    mb.max_stack=ais.readU30(""String_Node_Str"");
    mb.max_regs=ais.readU30(""String_Node_Str"");
    mb.init_scope_depth=ais.readU30(""String_Node_Str"");
    mb.max_scope_depth=ais.readU30(""String_Node_Str"");
    int code_length=ais.readU30(""String_Node_Str"");
    mb.setCodeBytes(ais.readBytes(code_length,""String_Node_Str""));
    int ex_count=ais.readU30(""String_Node_Str"");
    mb.exceptions=new ABCException[ex_count];
    for (int j=0; j < ex_count; j++) {
      ABCException abce=new ABCException();
      abce.start=ais.readU30(""String_Node_Str"");
      abce.end=ais.readU30(""String_Node_Str"");
      abce.target=ais.readU30(""String_Node_Str"");
      abce.type_index=ais.readU30(""String_Node_Str"");
      abce.name_index=ais.readU30(""String_Node_Str"");
      mb.exceptions[j]=abce;
    }
    mb.traits=ais.readTraits(""String_Node_Str"");
    bodies.add(mb);
    method_info.get(mb.method_info).setBody(mb);
    ais.endDumpLevel();
    SWFDecompilerPlugin.fireMethodBodyParsed(mb,swf);
  }
  SWFDecompilerPlugin.fireAbcParsed(this,swf);
}","public ABC(ABCInputStream ais,SWF swf,ABCContainerTag tag) throws IOException {
  this.parentTag=tag;
  minor_version=ais.readU16(""String_Node_Str"");
  major_version=ais.readU16(""String_Node_Str"");
  logger.log(Level.FINE,""String_Node_Str"",new Object[]{minor_version,major_version});
  constants=new AVM2ConstantPool();
  ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
  int constant_int_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_int=new ArrayList<>(constant_int_pool_count);
  if (constant_int_pool_count > 0) {
    constants.addInt(0);
  }
  if (constant_int_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_int_pool_count; i++) {
      constants.addInt(ais.readS32(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_uint_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_uint=new ArrayList<>(constant_uint_pool_count);
  if (constant_uint_pool_count > 0) {
    constants.addUInt(0);
  }
  if (constant_uint_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_uint_pool_count; i++) {
      constants.addUInt(ais.readU32(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_double_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_double=new ArrayList<>(constant_double_pool_count);
  if (constant_double_pool_count > 0) {
    constants.addDouble(0);
  }
  if (constant_double_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_double_pool_count; i++) {
      constants.addDouble(ais.readDouble(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  if (minor_version >= MINORwithDECIMAL) {
    int constant_decimal_pool_count=ais.readU30(""String_Node_Str"");
    constants.constant_decimal=new ArrayList<>(constant_decimal_pool_count);
    if (constant_decimal_pool_count > 0) {
      constants.addDecimal(null);
    }
    if (constant_decimal_pool_count > 1) {
      ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
      for (int i=1; i < constant_decimal_pool_count; i++) {
        constants.addDecimal(ais.readDecimal(""String_Node_Str""));
      }
      ais.endDumpLevel();
    }
  }
 else {
    constants.constant_decimal=new ArrayList<>(0);
  }
  int constant_string_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_string=new ArrayList<>(constant_string_pool_count);
  stringOffsets=new long[constant_string_pool_count];
  if (constant_string_pool_count > 0) {
    constants.addString(""String_Node_Str"");
  }
  if (constant_string_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_string_pool_count; i++) {
      long pos=ais.getPosition();
      constants.addString(ais.readString(""String_Node_Str""));
      stringOffsets[i]=pos;
    }
    ais.endDumpLevel();
  }
  int constant_namespace_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_namespace=new ArrayList<>(constant_namespace_pool_count);
  if (constant_namespace_pool_count > 0) {
    constants.addNamespace(null);
  }
  if (constant_namespace_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_namespace_pool_count; i++) {
      constants.addNamespace(ais.readNamespace(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  int constant_namespace_set_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_namespace_set=new ArrayList<>(constant_namespace_set_pool_count);
  if (constant_namespace_set_pool_count > 0) {
    constants.addNamespaceSet(null);
  }
  if (constant_namespace_set_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_namespace_set_pool_count; i++) {
      ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
      constants.addNamespaceSet(new NamespaceSet());
      int namespace_count=ais.readU30(""String_Node_Str"");
      constants.getNamespaceSet(i).namespaces=new int[namespace_count];
      for (int j=0; j < namespace_count; j++) {
        constants.getNamespaceSet(i).namespaces[j]=ais.readU30(""String_Node_Str"");
      }
      ais.endDumpLevel();
    }
    ais.endDumpLevel();
  }
  int constant_multiname_pool_count=ais.readU30(""String_Node_Str"");
  constants.constant_multiname=new ArrayList<>(constant_multiname_pool_count);
  if (constant_multiname_pool_count > 0) {
    constants.addMultiname(null);
  }
  if (constant_multiname_pool_count > 1) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    for (int i=1; i < constant_multiname_pool_count; i++) {
      constants.addMultiname(ais.readMultiname(""String_Node_Str""));
    }
    ais.endDumpLevel();
  }
  ais.endDumpLevel();
  int methods_count=ais.readU30(""String_Node_Str"");
  method_info=new ArrayList<>(methods_count);
  for (int i=0; i < methods_count; i++) {
    method_info.add(ais.readMethodInfo(""String_Node_Str""));
  }
  int metadata_count=ais.readU30(""String_Node_Str"");
  metadata_info=new ArrayList<>(metadata_count);
  for (int i=0; i < metadata_count; i++) {
    int name_index=ais.readU30(""String_Node_Str"");
    int values_count=ais.readU30(""String_Node_Str"");
    int[] keys=new int[values_count];
    for (int v=0; v < values_count; v++) {
      keys[v]=ais.readU30(""String_Node_Str"");
    }
    int[] values=new int[values_count];
    for (int v=0; v < values_count; v++) {
      values[v]=ais.readU30(""String_Node_Str"");
    }
    metadata_info.add(new MetadataInfo(name_index,keys,values));
  }
  int class_count=ais.readU30(""String_Node_Str"");
  instance_info=new ArrayList<>(class_count);
  for (int i=0; i < class_count; i++) {
    instance_info.add(ais.readInstanceInfo(""String_Node_Str""));
  }
  class_info=new ArrayList<>(class_count);
  for (int i=0; i < class_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    ClassInfo ci=new ClassInfo(null);
    ci.cinit_index=ais.readU30(""String_Node_Str"");
    ci.static_traits=ais.readTraits(""String_Node_Str"");
    class_info.add(ci);
    ais.endDumpLevel();
  }
  int script_count=ais.readU30(""String_Node_Str"");
  script_info=new ArrayList<>(script_count);
  for (int i=0; i < script_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    ScriptInfo si=new ScriptInfo(null);
    si.init_index=ais.readU30(""String_Node_Str"");
    si.traits=ais.readTraits(""String_Node_Str"");
    script_info.add(si);
    ais.endDumpLevel();
    si.setModified(false);
  }
  int bodies_count=ais.readU30(""String_Node_Str"");
  bodies=new ArrayList<>(bodies_count);
  for (int i=0; i < bodies_count; i++) {
    ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    MethodBody mb=new MethodBody(this,null,null,null);
    mb.method_info=ais.readU30(""String_Node_Str"");
    mb.max_stack=ais.readU30(""String_Node_Str"");
    mb.max_regs=ais.readU30(""String_Node_Str"");
    mb.init_scope_depth=ais.readU30(""String_Node_Str"");
    mb.max_scope_depth=ais.readU30(""String_Node_Str"");
    int code_length=ais.readU30(""String_Node_Str"");
    mb.setCodeBytes(ais.readBytes(code_length,""String_Node_Str""));
    int ex_count=ais.readU30(""String_Node_Str"");
    mb.exceptions=new ABCException[ex_count];
    for (int j=0; j < ex_count; j++) {
      ABCException abce=new ABCException();
      abce.start=ais.readU30(""String_Node_Str"");
      abce.end=ais.readU30(""String_Node_Str"");
      abce.target=ais.readU30(""String_Node_Str"");
      abce.type_index=ais.readU30(""String_Node_Str"");
      abce.name_index=ais.readU30(""String_Node_Str"");
      mb.exceptions[j]=abce;
    }
    mb.traits=ais.readTraits(""String_Node_Str"");
    bodies.add(mb);
    method_info.get(mb.method_info).setBody(mb);
    ais.endDumpLevel();
    SWFDecompilerPlugin.fireMethodBodyParsed(mb,swf);
  }
  SWFDecompilerPlugin.fireAbcParsed(this,swf);
}",0.9996823985263292
61537,"private int readU30Internal() throws IOException {
  return (int)readU32Internal();
}","private int readU30Internal() throws IOException {
  long u32=readU32Internal();
  return (int)(u32 & 0x3FFFFFFF);
}",0.736318407960199
61538,"public void fixJumps(MethodBody body){
  buildCache();
  AVM2Instruction lastInstuction=code.get(code.size() - 1);
  final long endOffset=lastInstuction.offset + lastInstuction.getBytesLength();
  updateOffsets(new OffsetUpdater(){
    @Override public long updateInstructionOffset(    long address){
      return address;
    }
    @Override public int updateOperandOffset(    long insAddr,    long targetAddress,    int offset){
      if (targetAddress > endOffset) {
        return (int)(offset - targetAddress + endOffset);
      }
      if (targetAddress < 0) {
        return (int)(offset - targetAddress);
      }
      int targetPos=posCache.indexOf(targetAddress);
      if (targetPos == -1) {
        return (int)(offset - targetAddress + endOffset);
      }
      return offset;
    }
  }
,body);
}","public void fixJumps(MethodBody body){
  buildCache();
  if (code.isEmpty()) {
    return;
  }
  AVM2Instruction lastInstuction=code.get(code.size() - 1);
  final long endOffset=lastInstuction.offset + lastInstuction.getBytesLength();
  updateOffsets(new OffsetUpdater(){
    @Override public long updateInstructionOffset(    long address){
      return address;
    }
    @Override public int updateOperandOffset(    long insAddr,    long targetAddress,    int offset){
      if (targetAddress > endOffset) {
        return (int)(offset - targetAddress + endOffset);
      }
      if (targetAddress < 0) {
        return (int)(offset - targetAddress);
      }
      int targetPos=posCache.indexOf(targetAddress);
      if (targetPos == -1) {
        return (int)(offset - targetAddress + endOffset);
      }
      return offset;
    }
  }
,body);
}",0.9758745476477684
61539,"public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  long startPos=ais.getPosition();
  addresses.add(startPos);
  while (!addresses.isEmpty()) {
    long address=addresses.remove(0);
    boolean afterExit=false;
    if (codeMap.containsKey(address)) {
      continue;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == 0x1b) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            actualOperands=new int[case_count + 3];
            actualOperands[0]=firstOperand;
            actualOperands[1]=case_count;
            for (int c=0; c < case_count + 1; c++) {
              actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
if (!afterExit && (instr instanceof IfTypeIns)) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
codeMap.put(startOffset,new AVM2Instruction(startOffset,instr,actualOperands));
ais.endDumpLevel(instr.instructionCode);
if (instr.isExitInstruction()) {
afterExit=true;
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
code.addAll(codeMap.values());
}","public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  List<Long> switchAddresses=new ArrayList<>();
  int availableBytes=ais.available();
  for (int i=0; i < availableBytes; i++) {
    codeMap.put((long)i,new AVM2Instruction(i,new NopIns(),new int[]{}));
  }
  long startPos=ais.getPosition();
  addresses.add(startPos);
  loopaddr:   while (!addresses.isEmpty() || !switchAddresses.isEmpty()) {
    long address;
    boolean isSwitch=false;
    if (!addresses.isEmpty()) {
      address=addresses.remove(0);
    }
 else {
      address=switchAddresses.remove(0);
      isSwitch=true;
    }
    if (codeMap.containsKey(address) && !(codeMap.get(address).definition instanceof NopIns)) {
      continue;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (instr instanceof LookupSwitchIns) {
          if (!isSwitch) {
            switchAddresses.add(startOffset);
            continue loopaddr;
          }
 else {
            isSwitch=false;
          }
        }
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          long beforeSwitchPos=ais.getPosition();
          if (instructionCode == 0x1b) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            long afterCasePos=ais.getPosition() + 3 * (case_count + 1);
            boolean invalidSwitch=false;
            for (long a=beforeSwitchPos; a < afterCasePos; a++) {
              if (codeMap.containsKey(a) && (!(codeMap.get(a).definition instanceof NopIns))) {
                invalidSwitch=true;
                break;
              }
            }
            long totalBytes=ais.getPosition() + ais.available();
            if (afterCasePos > totalBytes) {
              invalidSwitch=true;
            }
            if (invalidSwitch) {
              continue loopaddr;
            }
 else {
              actualOperands=new int[case_count + 3];
              actualOperands[0]=firstOperand;
              actualOperands[1]=case_count;
              for (int c=0; c < case_count + 1; c++) {
                actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
              }
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
AVM2Instruction ai=new AVM2Instruction(startOffset,instr,actualOperands);
long endOffset=ais.getPosition();
for (long p=startOffset; p < endOffset; p++) {
codeMap.put(p,ai);
}
ais.endDumpLevel(instr.instructionCode);
if ((instr instanceof IfTypeIns)) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
AVM2Instruction prev=null;
for (AVM2Instruction ins : codeMap.values()) {
if (prev != ins) {
code.add(ins);
}
prev=ins;
}
}",0.6860594500079479
61540,"private void visitCode(Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      if (visited.contains(idx)) {
        break;
      }
      visited.add(idx);
      AVM2Instruction action=code.code.get(idx);
      instructionsProcessed++;
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      InstructionDefinition def=action.definition;
      if (def instanceof SetLocalTypeIns) {
        SetLocalTypeIns slt=(SetLocalTypeIns)def;
        int regId=slt.getRegisterId(action);
        if (!result.assignCount.containsKey(regId)) {
          result.assignCount.put(regId,0);
        }
        result.assignCount.put(regId,result.assignCount.get(regId) + 1);
        GraphTargetItem regVal=localData.localRegs.get(regId);
        if (regVal == null || !regVal.getNotCoerced().isCompileTime()) {
          result.assignCount.put(regId,Integer.MAX_VALUE);
        }
 else {
          result.lastAssigned.put(regId,regVal.getNotCoerced());
        }
      }
      idx++;
      if (action.definition instanceof JumpIns) {
        long address=action.offset + action.getBytesLength() + action.operands[0];
        idx=code.adr2pos(address);
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
      if (action.isBranch()) {
        List<Integer> branches=action.getBranches(new GraphSource(){
          @Override public int size(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public GraphSourceItem get(          int pos){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public boolean isEmpty(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public List<GraphTargetItem> translatePart(          GraphPart part,          BaseLocalData localData,          TranslateStack stack,          int start,          int end,          int staticOperation,          String path) throws InterruptedException {
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public int adr2pos(          long adr){
            return code.adr2pos(adr);
          }
          @Override public long pos2adr(          int pos){
            return code.pos2adr(pos);
          }
        }
);
        idx=branches.get(0);
        for (int n=1; n < branches.size(); n++) {
          visitCode(visited,(TranslateStack)stack.clone(),classIndex,isStatic,body,scriptIndex,abc,code,branches.get(n),endIdx,result);
        }
      }
      if (action.definition instanceof ReturnValueIns) {
        break;
      }
      if (action.definition instanceof ThrowIns) {
        break;
      }
      if (action.definition instanceof ReturnVoidIns) {
        break;
      }
    }
  }
 catch (  EmptyStackException|TranslateException|InterruptedException ex) {
  }
}","private void visitCode(Set<Integer> visited,TranslateStack stack,int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  localData.localRegs.put(0,new NullAVM2Item(null));
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      if (visited.contains(idx)) {
        break;
      }
      visited.add(idx);
      AVM2Instruction action=code.code.get(idx);
      instructionsProcessed++;
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      InstructionDefinition def=action.definition;
      if (def instanceof SetLocalTypeIns) {
        SetLocalTypeIns slt=(SetLocalTypeIns)def;
        int regId=slt.getRegisterId(action);
        if (!result.assignCount.containsKey(regId)) {
          result.assignCount.put(regId,0);
        }
        result.assignCount.put(regId,result.assignCount.get(regId) + 1);
        GraphTargetItem regVal=localData.localRegs.get(regId);
        if (regVal == null || !regVal.getNotCoerced().isCompileTime()) {
          result.assignCount.put(regId,Integer.MAX_VALUE);
        }
 else {
          result.lastAssigned.put(regId,regVal.getNotCoerced());
        }
      }
      idx++;
      if (action.definition instanceof JumpIns) {
        long address=action.offset + action.getBytesLength() + action.operands[0];
        idx=code.adr2pos(address);
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
      if (action.isBranch()) {
        List<Integer> branches=action.getBranches(new GraphSource(){
          @Override public int size(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public GraphSourceItem get(          int pos){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public boolean isEmpty(){
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public List<GraphTargetItem> translatePart(          GraphPart part,          BaseLocalData localData,          TranslateStack stack,          int start,          int end,          int staticOperation,          String path) throws InterruptedException {
            throw new UnsupportedOperationException(""String_Node_Str"");
          }
          @Override public int adr2pos(          long adr){
            return code.adr2pos(adr);
          }
          @Override public long pos2adr(          int pos){
            return code.pos2adr(pos);
          }
        }
);
        idx=branches.get(0);
        for (int n=1; n < branches.size(); n++) {
          visitCode(visited,(TranslateStack)stack.clone(),classIndex,isStatic,body,scriptIndex,abc,code,branches.get(n),endIdx,result);
        }
      }
      if (action.definition instanceof ReturnValueIns) {
        break;
      }
      if (action.definition instanceof ThrowIns) {
        break;
      }
      if (action.definition instanceof ReturnVoidIns) {
        break;
      }
    }
  }
 catch (  Exception ex) {
  }
}",0.991906474820144
61541,"private void executeActions(int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  FixItemCounterTranslateStack stack=new FixItemCounterTranslateStack(""String_Node_Str"");
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      if (instructionsProcessed > executionLimit) {
        break;
      }
      AVM2Instruction action=code.code.get(idx);
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      InstructionDefinition def=action.definition;
      Class allowedDefs[]=new Class[]{PushByteIns.class,PushShortIns.class,PushIntIns.class,PushDoubleIns.class,PushStringIns.class,PushNullIns.class,PushUndefinedIns.class,PushFalseIns.class,PushTrueIns.class,DupIns.class,SwapIns.class,AddIns.class,AddIIns.class,SubtractIns.class,SubtractIIns.class,ModuloIns.class,MultiplyIns.class,BitAndIns.class,BitXorIns.class,BitOrIns.class,LShiftIns.class,RShiftIns.class,URShiftIns.class,EqualsIns.class,NotIns.class,IfTypeIns.class,JumpIns.class,EqualsIns.class,LessEqualsIns.class,GreaterEqualsIns.class,GreaterThanIns.class,LessThanIns.class,StrictEqualsIns.class,PopIns.class};
      boolean ok=false;
      for (      Class<?> s : allowedDefs) {
        if (s.isAssignableFrom(def.getClass())) {
          ok=true;
          break;
        }
      }
      if (!ok) {
        break;
      }
      boolean ifed=false;
      if (def instanceof JumpIns) {
        long address=action.offset + action.getBytesLength() + action.operands[0];
        idx=code.adr2pos(address);
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
 else       if (def instanceof IfTypeIns) {
        GraphTargetItem top=stack.pop();
        Object res=top.getResult();
        long address=action.offset + action.getBytesLength() + action.operands[0];
        int nidx=code.adr2pos(address);
        AVM2Instruction tarIns=code.code.get(nidx);
        if (EcmaScript.toBoolean(res)) {
          AVM2Instruction jumpIns=new AVM2Instruction(0,new JumpIns(),new int[]{0});
          code.replaceInstruction(idx,jumpIns,body);
          jumpIns.operands[0]=(int)(tarIns.offset - jumpIns.offset - jumpIns.getBytesLength());
          code.insertInstruction(idx,new AVM2Instruction(action.offset,new DeobfuscatePopIns(),new int[]{}),true,body);
          idx=code.adr2pos(jumpIns.offset + jumpIns.getBytesLength() + jumpIns.operands[0]);
        }
 else {
          code.replaceInstruction(idx,new AVM2Instruction(action.offset,new DeobfuscatePopIns(),new int[]{}),body);
          idx++;
        }
        ifed=true;
      }
 else {
        idx++;
      }
      instructionsProcessed++;
      if (stack.allItemsFixed()) {
        result.idx=idx == code.code.size() ? idx - 1 : idx;
        result.instructionsProcessed=instructionsProcessed;
        result.stack.clear();
        result.stack.addAll(stack);
      }
      if (ifed) {
        break;
      }
    }
  }
 catch (  EmptyStackException|TranslateException|InterruptedException ex) {
  }
}","private void executeActions(int classIndex,boolean isStatic,MethodBody body,int scriptIndex,ABC abc,AVM2Code code,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  AVM2LocalData localData=newLocalData(scriptIndex,abc,abc.constants,body,isStatic,classIndex);
  FixItemCounterTranslateStack stack=new FixItemCounterTranslateStack(""String_Node_Str"");
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      if (instructionsProcessed > executionLimit) {
        break;
      }
      AVM2Instruction action=code.code.get(idx);
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      InstructionDefinition def=action.definition;
      Class allowedDefs[]=new Class[]{PushByteIns.class,PushShortIns.class,PushIntIns.class,PushDoubleIns.class,PushStringIns.class,PushNullIns.class,PushUndefinedIns.class,PushFalseIns.class,PushTrueIns.class,DupIns.class,SwapIns.class,AddIns.class,AddIIns.class,SubtractIns.class,SubtractIIns.class,ModuloIns.class,MultiplyIns.class,BitAndIns.class,BitXorIns.class,BitOrIns.class,LShiftIns.class,RShiftIns.class,URShiftIns.class,EqualsIns.class,NotIns.class,IfTypeIns.class,JumpIns.class,EqualsIns.class,LessEqualsIns.class,GreaterEqualsIns.class,GreaterThanIns.class,LessThanIns.class,StrictEqualsIns.class,PopIns.class};
      boolean ok=false;
      for (      Class<?> s : allowedDefs) {
        if (s.isAssignableFrom(def.getClass())) {
          ok=true;
          break;
        }
      }
      if (!ok) {
        break;
      }
      boolean ifed=false;
      if (def instanceof JumpIns) {
        long address=action.offset + action.getBytesLength() + action.operands[0];
        idx=code.adr2pos(address);
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
 else       if (def instanceof IfTypeIns) {
        GraphTargetItem top=stack.pop();
        Object res=top.getResult();
        long address=action.offset + action.getBytesLength() + action.operands[0];
        int nidx=code.adr2pos(address);
        AVM2Instruction tarIns=code.code.get(nidx);
        if (EcmaScript.toBoolean(res)) {
          AVM2Instruction jumpIns=new AVM2Instruction(0,new JumpIns(),new int[]{0});
          code.replaceInstruction(idx,jumpIns,body);
          jumpIns.operands[0]=(int)(tarIns.offset - jumpIns.offset - jumpIns.getBytesLength());
          code.insertInstruction(idx,new AVM2Instruction(action.offset,new DeobfuscatePopIns(),new int[]{}),true,body);
          idx=code.adr2pos(jumpIns.offset + jumpIns.getBytesLength() + jumpIns.operands[0]);
        }
 else {
          code.replaceInstruction(idx,new AVM2Instruction(action.offset,new DeobfuscatePopIns(),new int[]{}),body);
          idx++;
        }
        ifed=true;
      }
 else {
        idx++;
      }
      instructionsProcessed++;
      if (stack.allItemsFixed()) {
        result.idx=idx == code.code.size() ? idx - 1 : idx;
        result.instructionsProcessed=instructionsProcessed;
        result.stack.clear();
        result.stack.addAll(stack);
      }
      if (ifed) {
        break;
      }
    }
  }
 catch (  Exception ex) {
  }
}",0.9917254060680356
61542,"protected FullMultinameAVM2Item resolveMultiname(TranslateStack stack,AVM2ConstantPool constants,int multinameIndex,AVM2Instruction ins){
  GraphTargetItem ns=null;
  GraphTargetItem name=null;
  if (constants.getMultiname(multinameIndex).needsName()) {
    name=stack.pop();
  }
  if (constants.getMultiname(multinameIndex).needsNs()) {
    ns=stack.pop();
  }
  return new FullMultinameAVM2Item(ins,multinameIndex,name,ns);
}","protected FullMultinameAVM2Item resolveMultiname(TranslateStack stack,AVM2ConstantPool constants,int multinameIndex,AVM2Instruction ins){
  GraphTargetItem ns=null;
  GraphTargetItem name=null;
  if (multinameIndex < constants.constant_multiname.size()) {
    if (constants.getMultiname(multinameIndex).needsName()) {
      name=stack.pop();
    }
    if (constants.getMultiname(multinameIndex).needsNs()) {
      ns=stack.pop();
    }
  }
  return new FullMultinameAVM2Item(ins,multinameIndex,name,ns);
}",0.9163090128755365
61543,"public MethodBody(Traits traits,byte[] codeBytes,ABCException[] exceptions){
  this.traits=traits;
  this.codeBytes=codeBytes;
  this.exceptions=exceptions;
}","public MethodBody(ABC abc,Traits traits,byte[] codeBytes,ABCException[] exceptions){
  this.traits=traits;
  this.codeBytes=codeBytes;
  this.exceptions=exceptions;
  this.abc=abc;
}",0.9294117647058824
61544,"public synchronized AVM2Code getCode(){
  if (code == null) {
    AVM2Code avm2Code;
    try {
      ABCInputStream ais=new ABCInputStream(new MemoryInputStream(codeBytes));
      avm2Code=new AVM2Code(ais);
    }
 catch (    UnknownInstructionCode|IOException ex) {
      avm2Code=new AVM2Code();
      logger.log(Level.SEVERE,null,ex);
    }
    avm2Code.compact();
    code=avm2Code;
  }
  return code;
}","public synchronized AVM2Code getCode(){
  if (code == null) {
    AVM2Code avm2Code;
    try {
      ABCInputStream ais=new ABCInputStream(new MemoryInputStream(codeBytes));
      avm2Code=new AVM2Code(ais);
      avm2Code.removeWrongIndices(abc.constants);
    }
 catch (    UnknownInstructionCode|IOException ex) {
      avm2Code=new AVM2Code();
      logger.log(Level.SEVERE,null,ex);
    }
    avm2Code.compact();
    code=avm2Code;
  }
  return code;
}",0.9421296296296297
61545,"private void parseImportsUsagesFromMethodInfo(ABC abc,int method_index,List<DottedChain> imports,List<String> uses,String ignorePackage,List<String> fullyQualifiedNames,List<Integer> visitedMethods){
  if ((method_index < 0) || (method_index >= abc.method_info.size())) {
    return;
  }
  visitedMethods.add(method_index);
  if (abc.method_info.get(method_index).ret_type != 0) {
    parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(abc.method_info.get(method_index).ret_type),ignorePackage,fullyQualifiedNames);
  }
  for (  int t : abc.method_info.get(method_index).param_types) {
    if (t != 0) {
      parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(t),ignorePackage,fullyQualifiedNames);
    }
  }
  MethodBody body=abc.findBody(method_index);
  if (body != null) {
    parseImportsUsagesFromTraits(abc,body.traits,imports,uses,ignorePackage,fullyQualifiedNames);
    for (    ABCException ex : body.exceptions) {
      parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(ex.type_index),ignorePackage,fullyQualifiedNames);
    }
    for (    AVM2Instruction ins : body.getCode().code) {
      if (ins.definition instanceof AlchemyTypeIns) {
        DottedChain nimport=new DottedChain((AlchemyTypeIns.ALCHEMY_PACKAGE + ""String_Node_Str"" + ins.definition.instructionName).split(""String_Node_Str""));
        if (!imports.contains(nimport)) {
          imports.add(nimport);
        }
      }
      if (ins.definition instanceof NewFunctionIns) {
        if (ins.operands[0] != method_index) {
          if (!visitedMethods.contains(ins.operands[0])) {
            parseImportsUsagesFromMethodInfo(abc,ins.operands[0],imports,uses,ignorePackage,fullyQualifiedNames,visitedMethods);
          }
        }
      }
      if ((ins.definition instanceof FindPropertyStrictIns) || (ins.definition instanceof FindPropertyIns) || (ins.definition instanceof GetLexIns)|| (ins.definition instanceof CoerceIns)|| (ins.definition instanceof AsTypeIns)) {
        int m=ins.operands[0];
        if (m != 0) {
          parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(m),ignorePackage,fullyQualifiedNames);
        }
      }
 else {
        for (int k=0; k < ins.definition.operands.length; k++) {
          if (ins.definition.operands[k] == AVM2Code.DAT_MULTINAME_INDEX) {
            int multinameIndex=ins.operands[k];
            parseUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(multinameIndex),ignorePackage,fullyQualifiedNames);
          }
        }
      }
    }
  }
}","private void parseImportsUsagesFromMethodInfo(ABC abc,int method_index,List<DottedChain> imports,List<String> uses,String ignorePackage,List<String> fullyQualifiedNames,List<Integer> visitedMethods){
  if ((method_index < 0) || (method_index >= abc.method_info.size())) {
    return;
  }
  visitedMethods.add(method_index);
  if (abc.method_info.get(method_index).ret_type != 0) {
    parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(abc.method_info.get(method_index).ret_type),ignorePackage,fullyQualifiedNames);
  }
  for (  int t : abc.method_info.get(method_index).param_types) {
    if (t != 0) {
      parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(t),ignorePackage,fullyQualifiedNames);
    }
  }
  MethodBody body=abc.findBody(method_index);
  if (body != null) {
    parseImportsUsagesFromTraits(abc,body.traits,imports,uses,ignorePackage,fullyQualifiedNames);
    for (    ABCException ex : body.exceptions) {
      parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(ex.type_index),ignorePackage,fullyQualifiedNames);
    }
    for (    AVM2Instruction ins : body.getCode().code) {
      if (ins.definition instanceof AlchemyTypeIns) {
        DottedChain nimport=new DottedChain((AlchemyTypeIns.ALCHEMY_PACKAGE + ""String_Node_Str"" + ins.definition.instructionName).split(""String_Node_Str""));
        if (!imports.contains(nimport)) {
          imports.add(nimport);
        }
      }
      if (ins.definition instanceof NewFunctionIns) {
        if (ins.operands[0] != method_index) {
          if (!visitedMethods.contains(ins.operands[0])) {
            parseImportsUsagesFromMethodInfo(abc,ins.operands[0],imports,uses,ignorePackage,fullyQualifiedNames,visitedMethods);
          }
        }
      }
      if ((ins.definition instanceof FindPropertyStrictIns) || (ins.definition instanceof FindPropertyIns) || (ins.definition instanceof GetLexIns)|| (ins.definition instanceof CoerceIns)|| (ins.definition instanceof AsTypeIns)) {
        int m=ins.operands[0];
        if (m != 0) {
          if (m < abc.constants.constant_multiname.size()) {
            parseImportsUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(m),ignorePackage,fullyQualifiedNames);
          }
        }
      }
 else {
        for (int k=0; k < ins.definition.operands.length; k++) {
          if (ins.definition.operands[k] == AVM2Code.DAT_MULTINAME_INDEX) {
            int multinameIndex=ins.operands[k];
            if (multinameIndex < abc.constants.constant_multiname.size()) {
              parseUsagesFromMultiname(abc,imports,uses,abc.constants.getMultiname(multinameIndex),ignorePackage,fullyQualifiedNames);
            }
          }
        }
      }
    }
  }
}",0.9688025406314216
61546,"private MethodBody compilePCode(String str) throws IOException, AVM2ParseException, InterruptedException {
  str=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + str + ""String_Node_Str"";
  MethodBody b=new MethodBody();
  AVM2Code code=ASM3Parser.parse(new StringReader(str),getABC().constants,null,b,new MethodInfo());
  b.setCode(code);
  return b;
}","private MethodBody compilePCode(String str) throws IOException, AVM2ParseException, InterruptedException {
  str=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + str + ""String_Node_Str"";
  MethodBody b=new MethodBody(getABC());
  AVM2Code code=ASM3Parser.parse(new StringReader(str),getABC().constants,null,b,new MethodInfo());
  b.setCode(code);
  return b;
}",0.989100817438692
61547,"private String recompilePCode(String str) throws IOException, AVM2ParseException, InterruptedException {
  str=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + str + ""String_Node_Str"";
  final ABC abc=new ABC(new ABCContainerTag(){
    @Override public ABC getABC(){
      return null;
    }
    @Override public SWF getSwf(){
      return swf;
    }
    @Override public int compareTo(    ABCContainerTag o){
      return 0;
    }
  }
);
  MethodBody b=new MethodBody();
  AVM2Code code=ASM3Parser.parse(new StringReader(str),abc.constants,null,b,new MethodInfo());
  b.setCode(code);
  new AVM2DeobfuscatorJumps().deobfuscate(""String_Node_Str"",0,true,0,abc,abc.constants,null,new MethodInfo(),b);
  HighlightedTextWriter writer=new HighlightedTextWriter(new CodeFormatting(),false);
  code.toASMSource(abc.constants,null,new MethodInfo(),new MethodBody(),ScriptExportMode.PCODE,writer);
  String ret=writer.toString();
  return ret.substring(ret.lastIndexOf(""String_Node_Str"") + 6);
}","private String recompilePCode(String str) throws IOException, AVM2ParseException, InterruptedException {
  str=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + str + ""String_Node_Str"";
  final ABC abc=new ABC(new ABCContainerTag(){
    @Override public ABC getABC(){
      return null;
    }
    @Override public SWF getSwf(){
      return swf;
    }
    @Override public int compareTo(    ABCContainerTag o){
      return 0;
    }
  }
);
  MethodBody b=new MethodBody(abc);
  AVM2Code code=ASM3Parser.parse(new StringReader(str),abc.constants,null,b,new MethodInfo());
  b.setCode(code);
  new AVM2DeobfuscatorJumps().deobfuscate(""String_Node_Str"",0,true,0,abc,abc.constants,null,new MethodInfo(),b);
  HighlightedTextWriter writer=new HighlightedTextWriter(new CodeFormatting(),false);
  code.toASMSource(abc.constants,null,new MethodInfo(),new MethodBody(abc),ScriptExportMode.PCODE,writer);
  String ret=writer.toString();
  return ret.substring(ret.lastIndexOf(""String_Node_Str"") + 6);
}",0.997
61548,"public static int getParallelThreadCount(){
  int count=parallelThreadCount.get();
  if (count < 2) {
    count=2;
  }
  return count;
}","public static int getParallelThreadCount(){
  int count=parallelSpeedUpThreadCount.get();
  if (count < 2) {
    count=2;
  }
  return count;
}",0.974910394265233
61549,"public HTMLTextParser(List<Tag> tags,DefineEditTextTag det){
  if (det.hasFont) {
    String fontName=null;
    FontTag ft=null;
    for (    Tag u : tags) {
      if (u instanceof DefineFontNameTag) {
        if (((DefineFontNameTag)u).fontId == det.fontId) {
          fontName=((DefineFontNameTag)u).fontName;
        }
      }
      if (u instanceof FontTag) {
        if (((FontTag)u).getFontId() == det.fontId) {
          ft=(FontTag)u;
        }
      }
      if (fontName != null && ft != null) {
        break;
      }
    }
    if (ft != null) {
      if (fontName == null) {
        fontName=ft.getFontNameIntag();
      }
      italic=ft.isItalic();
      bold=ft.isBold();
      size=det.fontHeight;
      fontFace=new Font(fontName,(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0) | (!italic && !bold ? Font.PLAIN : 0),size < 0 ? 10 : size).getPSName();
    }
  }
  if (det.hasLayout) {
    leftMargin=det.leftMargin;
    rightMargin=det.rightMargin;
    indent=det.indent;
    lineSpacing=det.leading;
    String[] alignNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    if (det.align < alignNames.length) {
      alignment=alignNames[det.align];
    }
 else {
      alignment=""String_Node_Str"";
    }
  }
  this.tags=tags;
}","public HTMLTextParser(List<Tag> tags,DefineEditTextTag det){
  if (det.hasFont) {
    String fontName=null;
    FontTag ft=null;
    for (    Tag u : tags) {
      if (u instanceof DefineFontNameTag) {
        if (((DefineFontNameTag)u).fontId == det.fontId) {
          fontName=((DefineFontNameTag)u).fontName;
        }
      }
      if (u instanceof FontTag) {
        if (((FontTag)u).getFontId() == det.fontId) {
          ft=(FontTag)u;
        }
      }
      if (fontName != null && ft != null) {
        break;
      }
    }
    if (ft != null) {
      if (fontName == null) {
        fontName=ft.getFontNameIntag();
      }
      if (fontName == null) {
        fontName=FontTag.defaultFontName;
      }
      italic=ft.isItalic();
      bold=ft.isBold();
      size=det.fontHeight;
      fontFace=new Font(fontName,(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0) | (!italic && !bold ? Font.PLAIN : 0),size < 0 ? 10 : size).getPSName();
    }
  }
  if (det.hasLayout) {
    leftMargin=det.leftMargin;
    rightMargin=det.rightMargin;
    indent=det.indent;
    lineSpacing=det.leading;
    String[] alignNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    if (det.align < alignNames.length) {
      alignment=alignNames[det.align];
    }
 else {
      alignment=""String_Node_Str"";
    }
  }
  this.tags=tags;
}",0.969650986342944
61550,"private static void convertFonts(List<Tag> tags,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      FontTag font=(FontTag)t;
      int fontId=font.getFontId();
      String fontName=null;
      for (      Tag t2 : tags) {
        if (t2 instanceof DefineFontNameTag) {
          if (((DefineFontNameTag)t2).fontId == fontId) {
            fontName=((DefineFontNameTag)t2).fontName;
          }
        }
      }
      if (fontName == null) {
        fontName=font.getFontNameIntag();
      }
      int fontStyle=font.getFontStyle();
      String installedFont;
      if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
        fontName=new Font(installedFont,fontStyle,10).getPSName();
      }
      String embedRanges=""String_Node_Str"";
      String fontChars=font.getCharacters(tags);
      if (""String_Node_Str"".equals(fontChars)) {
        continue;
      }
      String embeddedCharacters=fontChars;
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      boolean hasAllRanges=false;
      for (int r=0; r < CharacterRanges.rangeCount(); r++) {
        int[] codes=CharacterRanges.rangeCodes(r);
        boolean hasAllInRange=true;
        for (int i=0; i < codes.length; i++) {
          if (!fontChars.contains(""String_Node_Str"" + (char)codes[i])) {
            hasAllInRange=false;
            break;
          }
        }
        if (hasAllInRange) {
          for (int i=0; i < codes.length; i++) {
            embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"" + (char)codes[i],""String_Node_Str"");
          }
          if (!""String_Node_Str"".equals(embedRanges)) {
            embedRanges+=""String_Node_Str"";
          }
          embedRanges+=(r + 1);
        }
 else {
          hasAllRanges=false;
        }
      }
      if (hasAllRanges) {
        embedRanges=""String_Node_Str"";
      }
      ret2.append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(xmlString(fontName)).append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(embedRanges).append(""String_Node_Str"").append(!""String_Node_Str"".equals(embeddedCharacters) ? ""String_Node_Str"" + xmlString(embeddedCharacters) + ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(ret2).append(""String_Node_Str"");
  }
}","private static void convertFonts(List<Tag> tags,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      FontTag font=(FontTag)t;
      int fontId=font.getFontId();
      String fontName=null;
      for (      Tag t2 : tags) {
        if (t2 instanceof DefineFontNameTag) {
          if (((DefineFontNameTag)t2).fontId == fontId) {
            fontName=((DefineFontNameTag)t2).fontName;
          }
        }
      }
      if (fontName == null) {
        fontName=font.getFontNameIntag();
      }
      if (fontName == null) {
        fontName=FontTag.defaultFontName;
      }
      int fontStyle=font.getFontStyle();
      String installedFont;
      if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
        fontName=new Font(installedFont,fontStyle,10).getPSName();
      }
      String embedRanges=""String_Node_Str"";
      String fontChars=font.getCharacters(tags);
      if (""String_Node_Str"".equals(fontChars)) {
        continue;
      }
      String embeddedCharacters=fontChars;
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"",""String_Node_Str"");
      boolean hasAllRanges=false;
      for (int r=0; r < CharacterRanges.rangeCount(); r++) {
        int[] codes=CharacterRanges.rangeCodes(r);
        boolean hasAllInRange=true;
        for (int i=0; i < codes.length; i++) {
          if (!fontChars.contains(""String_Node_Str"" + (char)codes[i])) {
            hasAllInRange=false;
            break;
          }
        }
        if (hasAllInRange) {
          for (int i=0; i < codes.length; i++) {
            embeddedCharacters=embeddedCharacters.replace(""String_Node_Str"" + (char)codes[i],""String_Node_Str"");
          }
          if (!""String_Node_Str"".equals(embedRanges)) {
            embedRanges+=""String_Node_Str"";
          }
          embedRanges+=(r + 1);
        }
 else {
          hasAllRanges=false;
        }
      }
      if (hasAllRanges) {
        embedRanges=""String_Node_Str"";
      }
      ret2.append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(xmlString(fontName)).append(""String_Node_Str"").append(fontId).append(""String_Node_Str"").append(embedRanges).append(""String_Node_Str"").append(!""String_Node_Str"".equals(embeddedCharacters) ? ""String_Node_Str"" + xmlString(embeddedCharacters) + ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    }
  }
  if (ret2.length() > 0) {
    ret.append(""String_Node_Str"").append(ret2).append(""String_Node_Str"");
  }
}",0.9845380749903364
61551,"private static String convertText(String instanceName,TextTag tag,MATRIX m,List<FILTER> filters,CLIPACTIONS clipActions){
  StringBuilder ret=new StringBuilder();
  MATRIX matrix=new MATRIX(m);
  CSMTextSettingsTag csmts=null;
  StringBuilder filterStr=new StringBuilder();
  if (filters != null) {
    filterStr.append(""String_Node_Str"");
    for (    FILTER f : filters) {
      convertFilter(f,ret);
    }
    filterStr.append(""String_Node_Str"");
  }
  SWF swf=tag.getSwf();
  for (  Tag t : swf.tags) {
    if (t instanceof CSMTextSettingsTag) {
      CSMTextSettingsTag c=(CSMTextSettingsTag)t;
      if (c.textID == tag.getCharacterId()) {
        csmts=c;
        break;
      }
    }
  }
  String fontRenderingMode=""String_Node_Str"";
  String antiAlias=""String_Node_Str"";
  if (csmts != null) {
    if (csmts.thickness == 0 & csmts.sharpness == 0) {
      fontRenderingMode=null;
    }
 else {
      fontRenderingMode=""String_Node_Str"";
    }
    antiAlias=""String_Node_Str"" + doubleToString(csmts.sharpness) + ""String_Node_Str""+ doubleToString(csmts.thickness)+ ""String_Node_Str"";
  }
  String left=""String_Node_Str"";
  RECT bounds=tag.getBounds();
  if ((tag instanceof DefineTextTag) || (tag instanceof DefineText2Tag)) {
    MATRIX textMatrix=tag.getTextMatrix();
    left=""String_Node_Str"" + doubleToString((textMatrix.translateX) / SWF.unitDivisor) + ""String_Node_Str"";
  }
  StringBuilder matStr=new StringBuilder();
  matStr.append(""String_Node_Str"");
  convertMatrix(matrix,matStr);
  matStr.append(""String_Node_Str"");
  if ((tag instanceof DefineTextTag) || (tag instanceof DefineText2Tag)) {
    List<TEXTRECORD> textRecords=new ArrayList<>();
    if (tag instanceof DefineTextTag) {
      textRecords=((DefineTextTag)tag).textRecords;
    }
 else     if (tag instanceof DefineText2Tag) {
      textRecords=((DefineText2Tag)tag).textRecords;
    }
    for (    TEXTRECORD rec : textRecords) {
      if (rec.styleFlagsHasFont) {
        FontTag ft=swf.getFont(rec.fontId);
        if (ft != null && ft.isSmall()) {
          fontRenderingMode=""String_Node_Str"";
          break;
        }
      }
    }
    ret.append(""String_Node_Str"");
    ret.append(left);
    if (fontRenderingMode != null) {
      ret.append(""String_Node_Str"").append(fontRenderingMode).append(""String_Node_Str"");
    }
    if (instanceName != null) {
      ret.append(""String_Node_Str"").append(xmlString(instanceName)).append(""String_Node_Str"");
    }
    ret.append(antiAlias);
    Map<String,Object> attrs=TextTag.getTextRecordsAttributes(textRecords,swf);
    ret.append(""String_Node_Str"").append(tag.getBounds().getWidth() / 2).append(""String_Node_Str"").append(tag.getBounds().getHeight()).append(""String_Node_Str"");
    ret.append(matStr);
    ret.append(""String_Node_Str"");
    int fontId=-1;
    FontTag font=null;
    String fontName=null;
    String psFontName=null;
    int textHeight=-1;
    RGB textColor=null;
    RGBA textColorA=null;
    boolean newline=false;
    boolean firstRun=true;
    @SuppressWarnings(""String_Node_Str"") List<Integer> leftMargins=(List<Integer>)attrs.get(""String_Node_Str"");
    @SuppressWarnings(""String_Node_Str"") List<Integer> letterSpacings=(List<Integer>)attrs.get(""String_Node_Str"");
    for (int r=0; r < textRecords.size(); r++) {
      TEXTRECORD rec=textRecords.get(r);
      if (rec.styleFlagsHasColor) {
        if (tag instanceof DefineTextTag) {
          textColor=rec.textColor;
        }
 else {
          textColorA=rec.textColorA;
        }
      }
      if (rec.styleFlagsHasFont) {
        fontId=rec.fontId;
        fontName=null;
        textHeight=rec.textHeight;
        font=swf.getFont(fontId);
        for (        Tag t : swf.tags) {
          if (t instanceof DefineFontNameTag) {
            if (((DefineFontNameTag)t).fontId == fontId) {
              fontName=((DefineFontNameTag)t).fontName;
            }
          }
        }
        if ((fontName == null) && (font != null)) {
          fontName=font.getFontNameIntag();
        }
        int fontStyle=0;
        if (font != null) {
          fontStyle=font.getFontStyle();
        }
        String installedFont;
        if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
          psFontName=new Font(installedFont,fontStyle,10).getPSName();
        }
 else {
          psFontName=fontName;
        }
      }
      newline=false;
      if (!firstRun && rec.styleFlagsHasYOffset) {
        newline=true;
      }
      firstRun=false;
      if (font != null) {
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(xmlString((newline ? ""String_Node_Str"" : ""String_Node_Str"") + rec.getText(font))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(twipToPixel(textHeight)).append(""String_Node_Str"").append(textHeight).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel(letterSpacings.get(r)))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel(leftMargins.get(r)))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        if (textColor != null) {
          ret.append(""String_Node_Str"").append(textColor.toHexRGB()).append(""String_Node_Str"");
        }
 else         if (textColorA != null) {
          ret.append(""String_Node_Str"").append(textColorA.toHexRGB()).append(""String_Node_Str"").append(textColorA.getAlphaFloat()).append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(psFontName).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
      }
    }
    ret.append(""String_Node_Str"");
    ret.append(filterStr);
    ret.append(""String_Node_Str"");
  }
 else   if (tag instanceof DefineEditTextTag) {
    DefineEditTextTag det=(DefineEditTextTag)tag;
    String tagName;
    FontTag ft=swf.getFont(det.fontId);
    if (ft != null && ft.isSmall()) {
      fontRenderingMode=""String_Node_Str"";
    }
    if (!det.useOutlines) {
      fontRenderingMode=""String_Node_Str"";
    }
    if (det.wasStatic) {
      tagName=""String_Node_Str"";
    }
 else     if (det.readOnly) {
      tagName=""String_Node_Str"";
    }
 else {
      tagName=""String_Node_Str"";
    }
    ret.append(""String_Node_Str"").append(tagName);
    if (fontRenderingMode != null) {
      ret.append(""String_Node_Str"").append(fontRenderingMode).append(""String_Node_Str"");
    }
    if (instanceName != null) {
      ret.append(""String_Node_Str"").append(xmlString(instanceName)).append(""String_Node_Str"");
    }
    ret.append(antiAlias);
    double width=twipToPixel(bounds.getWidth());
    double height=twipToPixel(bounds.getHeight());
    double padding=2;
    width-=2 * padding;
    height-=2 * padding;
    if (det.hasLayout) {
      width-=twipToPixel(det.rightMargin);
      width-=twipToPixel(det.leftMargin);
    }
    ret.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
    ret.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
    if (det.border) {
      ret.append(""String_Node_Str"");
    }
    if (det.html) {
      ret.append(""String_Node_Str"");
    }
    if (det.noSelect) {
      ret.append(""String_Node_Str"");
    }
    if (det.multiline && det.wordWrap) {
      ret.append(""String_Node_Str"");
    }
 else     if (det.multiline && (!det.wordWrap)) {
      ret.append(""String_Node_Str"");
    }
 else     if (det.password) {
      ret.append(""String_Node_Str"");
    }
    if (det.hasMaxLength) {
      ret.append(""String_Node_Str"").append(det.maxLength).append(""String_Node_Str"");
    }
    if (!det.variableName.isEmpty()) {
      ret.append(""String_Node_Str"").append(det.variableName).append(""String_Node_Str"");
    }
    ret.append(""String_Node_Str"");
    ret.append(matStr);
    ret.append(""String_Node_Str"");
    String txt=""String_Node_Str"";
    if (det.hasText) {
      txt=det.initialText;
    }
    if (det.html) {
      ret.append(convertHTMLText(swf.tags,det,txt));
    }
 else {
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"").append(xmlString(txt)).append(""String_Node_Str"");
      int leftMargin=-1;
      int rightMargin=-1;
      int indent=-1;
      int lineSpacing=-1;
      String alignment=null;
      boolean italic=false;
      boolean bold=false;
      String fontFace=null;
      int size=-1;
      RGBA textColor=null;
      if (det.hasTextColor) {
        textColor=det.textColor;
      }
      if (det.hasFont) {
        String fontName=null;
        for (        Tag u : swf.tags) {
          if (u instanceof DefineFontNameTag) {
            if (((DefineFontNameTag)u).fontId == det.fontId) {
              fontName=((DefineFontNameTag)u).fontName;
            }
          }
          if (fontName != null && ft != null) {
            break;
          }
        }
        if (ft != null) {
          if (fontName == null) {
            fontName=ft.getFontNameIntag();
          }
          italic=ft.isItalic();
          bold=ft.isBold();
          size=det.fontHeight;
          fontFace=fontName;
          String installedFont=null;
          if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
            fontName=installedFont;
            fontFace=new Font(installedFont,(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0) | (!italic && !bold ? Font.PLAIN : 0),size < 0 ? 10 : size).getPSName();
          }
        }
      }
      if (det.hasLayout) {
        leftMargin=det.leftMargin;
        rightMargin=det.rightMargin;
        indent=det.indent;
        lineSpacing=det.leading;
        String[] alignNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        if (det.align < alignNames.length) {
          alignment=alignNames[det.align];
        }
 else {
          alignment=""String_Node_Str"";
        }
      }
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
      if (alignment != null) {
        ret.append(""String_Node_Str"").append(alignment).append(""String_Node_Str"");
      }
      ret.append(""String_Node_Str"");
      if (indent > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(indent)).append(""String_Node_Str"");
      }
      if (leftMargin > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(leftMargin)).append(""String_Node_Str"");
      }
      if (lineSpacing > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(lineSpacing)).append(""String_Node_Str"");
      }
      if (rightMargin > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(rightMargin)).append(""String_Node_Str"");
      }
      if (size > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(size)).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(size).append(""String_Node_Str"");
      }
      if (fontFace != null) {
        ret.append(""String_Node_Str"").append(fontFace).append(""String_Node_Str"");
      }
      if (textColor != null) {
        ret.append(""String_Node_Str"").append(textColor.toHexRGB()).append(""String_Node_Str"").append(textColor.getAlphaFloat()).append(""String_Node_Str"");
      }
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
    }
    ret.append(""String_Node_Str"");
    ret.append(filterStr);
    ret.append(""String_Node_Str"").append(tagName).append(""String_Node_Str"");
  }
  return ret.toString();
}","private static String convertText(String instanceName,TextTag tag,MATRIX m,List<FILTER> filters,CLIPACTIONS clipActions){
  StringBuilder ret=new StringBuilder();
  MATRIX matrix=new MATRIX(m);
  CSMTextSettingsTag csmts=null;
  StringBuilder filterStr=new StringBuilder();
  if (filters != null) {
    filterStr.append(""String_Node_Str"");
    for (    FILTER f : filters) {
      convertFilter(f,ret);
    }
    filterStr.append(""String_Node_Str"");
  }
  SWF swf=tag.getSwf();
  for (  Tag t : swf.tags) {
    if (t instanceof CSMTextSettingsTag) {
      CSMTextSettingsTag c=(CSMTextSettingsTag)t;
      if (c.textID == tag.getCharacterId()) {
        csmts=c;
        break;
      }
    }
  }
  String fontRenderingMode=""String_Node_Str"";
  String antiAlias=""String_Node_Str"";
  if (csmts != null) {
    if (csmts.thickness == 0 & csmts.sharpness == 0) {
      fontRenderingMode=null;
    }
 else {
      fontRenderingMode=""String_Node_Str"";
    }
    antiAlias=""String_Node_Str"" + doubleToString(csmts.sharpness) + ""String_Node_Str""+ doubleToString(csmts.thickness)+ ""String_Node_Str"";
  }
  String left=""String_Node_Str"";
  RECT bounds=tag.getBounds();
  if ((tag instanceof DefineTextTag) || (tag instanceof DefineText2Tag)) {
    MATRIX textMatrix=tag.getTextMatrix();
    left=""String_Node_Str"" + doubleToString((textMatrix.translateX) / SWF.unitDivisor) + ""String_Node_Str"";
  }
  StringBuilder matStr=new StringBuilder();
  matStr.append(""String_Node_Str"");
  convertMatrix(matrix,matStr);
  matStr.append(""String_Node_Str"");
  if ((tag instanceof DefineTextTag) || (tag instanceof DefineText2Tag)) {
    List<TEXTRECORD> textRecords=new ArrayList<>();
    if (tag instanceof DefineTextTag) {
      textRecords=((DefineTextTag)tag).textRecords;
    }
 else     if (tag instanceof DefineText2Tag) {
      textRecords=((DefineText2Tag)tag).textRecords;
    }
    for (    TEXTRECORD rec : textRecords) {
      if (rec.styleFlagsHasFont) {
        FontTag ft=swf.getFont(rec.fontId);
        if (ft != null && ft.isSmall()) {
          fontRenderingMode=""String_Node_Str"";
          break;
        }
      }
    }
    ret.append(""String_Node_Str"");
    ret.append(left);
    if (fontRenderingMode != null) {
      ret.append(""String_Node_Str"").append(fontRenderingMode).append(""String_Node_Str"");
    }
    if (instanceName != null) {
      ret.append(""String_Node_Str"").append(xmlString(instanceName)).append(""String_Node_Str"");
    }
    ret.append(antiAlias);
    Map<String,Object> attrs=TextTag.getTextRecordsAttributes(textRecords,swf);
    ret.append(""String_Node_Str"").append(tag.getBounds().getWidth() / 2).append(""String_Node_Str"").append(tag.getBounds().getHeight()).append(""String_Node_Str"");
    ret.append(matStr);
    ret.append(""String_Node_Str"");
    int fontId=-1;
    FontTag font=null;
    String fontName=null;
    String psFontName=null;
    int textHeight=-1;
    RGB textColor=null;
    RGBA textColorA=null;
    boolean newline=false;
    boolean firstRun=true;
    @SuppressWarnings(""String_Node_Str"") List<Integer> leftMargins=(List<Integer>)attrs.get(""String_Node_Str"");
    @SuppressWarnings(""String_Node_Str"") List<Integer> letterSpacings=(List<Integer>)attrs.get(""String_Node_Str"");
    for (int r=0; r < textRecords.size(); r++) {
      TEXTRECORD rec=textRecords.get(r);
      if (rec.styleFlagsHasColor) {
        if (tag instanceof DefineTextTag) {
          textColor=rec.textColor;
        }
 else {
          textColorA=rec.textColorA;
        }
      }
      if (rec.styleFlagsHasFont) {
        fontId=rec.fontId;
        fontName=null;
        textHeight=rec.textHeight;
        font=swf.getFont(fontId);
        for (        Tag t : swf.tags) {
          if (t instanceof DefineFontNameTag) {
            if (((DefineFontNameTag)t).fontId == fontId) {
              fontName=((DefineFontNameTag)t).fontName;
            }
          }
        }
        if ((fontName == null) && (font != null)) {
          fontName=font.getFontNameIntag();
        }
        if (fontName == null) {
          fontName=FontTag.defaultFontName;
        }
        int fontStyle=0;
        if (font != null) {
          fontStyle=font.getFontStyle();
        }
        String installedFont;
        if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
          psFontName=new Font(installedFont,fontStyle,10).getPSName();
        }
 else {
          psFontName=fontName;
        }
      }
      newline=false;
      if (!firstRun && rec.styleFlagsHasYOffset) {
        newline=true;
      }
      firstRun=false;
      if (font != null) {
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(xmlString((newline ? ""String_Node_Str"" : ""String_Node_Str"") + rec.getText(font))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(twipToPixel(textHeight)).append(""String_Node_Str"").append(textHeight).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel(letterSpacings.get(r)))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel(leftMargins.get(r)))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(doubleToString(twipToPixel((int)attrs.get(""String_Node_Str"")))).append(""String_Node_Str"");
        if (textColor != null) {
          ret.append(""String_Node_Str"").append(textColor.toHexRGB()).append(""String_Node_Str"");
        }
 else         if (textColorA != null) {
          ret.append(""String_Node_Str"").append(textColorA.toHexRGB()).append(""String_Node_Str"").append(textColorA.getAlphaFloat()).append(""String_Node_Str"");
        }
        ret.append(""String_Node_Str"").append(psFontName).append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
        ret.append(""String_Node_Str"");
      }
    }
    ret.append(""String_Node_Str"");
    ret.append(filterStr);
    ret.append(""String_Node_Str"");
  }
 else   if (tag instanceof DefineEditTextTag) {
    DefineEditTextTag det=(DefineEditTextTag)tag;
    String tagName;
    FontTag ft=swf.getFont(det.fontId);
    if (ft != null && ft.isSmall()) {
      fontRenderingMode=""String_Node_Str"";
    }
    if (!det.useOutlines) {
      fontRenderingMode=""String_Node_Str"";
    }
    if (det.wasStatic) {
      tagName=""String_Node_Str"";
    }
 else     if (det.readOnly) {
      tagName=""String_Node_Str"";
    }
 else {
      tagName=""String_Node_Str"";
    }
    ret.append(""String_Node_Str"").append(tagName);
    if (fontRenderingMode != null) {
      ret.append(""String_Node_Str"").append(fontRenderingMode).append(""String_Node_Str"");
    }
    if (instanceName != null) {
      ret.append(""String_Node_Str"").append(xmlString(instanceName)).append(""String_Node_Str"");
    }
    ret.append(antiAlias);
    double width=twipToPixel(bounds.getWidth());
    double height=twipToPixel(bounds.getHeight());
    double padding=2;
    width-=2 * padding;
    height-=2 * padding;
    if (det.hasLayout) {
      width-=twipToPixel(det.rightMargin);
      width-=twipToPixel(det.leftMargin);
    }
    ret.append(""String_Node_Str"").append(width).append(""String_Node_Str"");
    ret.append(""String_Node_Str"").append(height).append(""String_Node_Str"");
    if (det.border) {
      ret.append(""String_Node_Str"");
    }
    if (det.html) {
      ret.append(""String_Node_Str"");
    }
    if (det.noSelect) {
      ret.append(""String_Node_Str"");
    }
    if (det.multiline && det.wordWrap) {
      ret.append(""String_Node_Str"");
    }
 else     if (det.multiline && (!det.wordWrap)) {
      ret.append(""String_Node_Str"");
    }
 else     if (det.password) {
      ret.append(""String_Node_Str"");
    }
    if (det.hasMaxLength) {
      ret.append(""String_Node_Str"").append(det.maxLength).append(""String_Node_Str"");
    }
    if (!det.variableName.isEmpty()) {
      ret.append(""String_Node_Str"").append(det.variableName).append(""String_Node_Str"");
    }
    ret.append(""String_Node_Str"");
    ret.append(matStr);
    ret.append(""String_Node_Str"");
    String txt=""String_Node_Str"";
    if (det.hasText) {
      txt=det.initialText;
    }
    if (det.html) {
      ret.append(convertHTMLText(swf.tags,det,txt));
    }
 else {
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"").append(xmlString(txt)).append(""String_Node_Str"");
      int leftMargin=-1;
      int rightMargin=-1;
      int indent=-1;
      int lineSpacing=-1;
      String alignment=null;
      boolean italic=false;
      boolean bold=false;
      String fontFace=null;
      int size=-1;
      RGBA textColor=null;
      if (det.hasTextColor) {
        textColor=det.textColor;
      }
      if (det.hasFont) {
        String fontName=null;
        for (        Tag u : swf.tags) {
          if (u instanceof DefineFontNameTag) {
            if (((DefineFontNameTag)u).fontId == det.fontId) {
              fontName=((DefineFontNameTag)u).fontName;
            }
          }
          if (fontName != null && ft != null) {
            break;
          }
        }
        if (ft != null) {
          if (fontName == null) {
            fontName=ft.getFontNameIntag();
          }
          if (fontName == null) {
            fontName=FontTag.defaultFontName;
          }
          italic=ft.isItalic();
          bold=ft.isBold();
          size=det.fontHeight;
          fontFace=fontName;
          String installedFont=null;
          if ((installedFont=FontTag.isFontFamilyInstalled(fontName)) != null) {
            fontName=installedFont;
            fontFace=new Font(installedFont,(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0) | (!italic && !bold ? Font.PLAIN : 0),size < 0 ? 10 : size).getPSName();
          }
        }
      }
      if (det.hasLayout) {
        leftMargin=det.leftMargin;
        rightMargin=det.rightMargin;
        indent=det.indent;
        lineSpacing=det.leading;
        String[] alignNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        if (det.align < alignNames.length) {
          alignment=alignNames[det.align];
        }
 else {
          alignment=""String_Node_Str"";
        }
      }
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
      if (alignment != null) {
        ret.append(""String_Node_Str"").append(alignment).append(""String_Node_Str"");
      }
      ret.append(""String_Node_Str"");
      if (indent > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(indent)).append(""String_Node_Str"");
      }
      if (leftMargin > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(leftMargin)).append(""String_Node_Str"");
      }
      if (lineSpacing > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(lineSpacing)).append(""String_Node_Str"");
      }
      if (rightMargin > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(rightMargin)).append(""String_Node_Str"");
      }
      if (size > -1) {
        ret.append(""String_Node_Str"").append(twipToPixel(size)).append(""String_Node_Str"");
        ret.append(""String_Node_Str"").append(size).append(""String_Node_Str"");
      }
      if (fontFace != null) {
        ret.append(""String_Node_Str"").append(fontFace).append(""String_Node_Str"");
      }
      if (textColor != null) {
        ret.append(""String_Node_Str"").append(textColor.toHexRGB()).append(""String_Node_Str"").append(textColor.getAlphaFloat()).append(""String_Node_Str"");
      }
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
      ret.append(""String_Node_Str"");
    }
    ret.append(""String_Node_Str"");
    ret.append(filterStr);
    ret.append(""String_Node_Str"").append(tagName).append(""String_Node_Str"");
  }
  return ret.toString();
}",0.9925429409300376
61552,"private static void convertFrames(String prevStr,String afterStr,List<Integer> nonLibraryShapes,List<Tag> tags,List<Tag> timelineTags,HashMap<Integer,CharacterTag> characters,int depth,FLAVersion flaVersion,HashMap<String,byte[]> files,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  prevStr+=""String_Node_Str"";
  int frame=-1;
  String elements;
  String lastElements=""String_Node_Str"";
  int duration=1;
  CharacterTag character=null;
  MATRIX matrix=null;
  String instanceName=null;
  ColorTransform colorTransForm=null;
  boolean cacheAsBitmap=false;
  int blendMode=0;
  List<FILTER> filters=new ArrayList<>();
  boolean isVisible=true;
  RGBA backGroundColor=null;
  CLIPACTIONS clipActions=null;
  int characterId=-1;
  int ratio=-1;
  boolean shapeTween=false;
  boolean lastShapeTween=false;
  MorphShapeTag shapeTweener=null;
  for (  Tag t : timelineTags) {
    if (t instanceof PlaceObjectTypeTag) {
      PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
      if (po.getDepth() == depth) {
        int newCharId=po.getCharacterId();
        if (newCharId == -1) {
          newCharId=characterId;
        }
        characterId=newCharId;
        if (characters.containsKey(characterId)) {
          character=characters.get(characterId);
          if (po.flagMove()) {
            MATRIX matrix2=po.getMatrix();
            if (matrix2 != null) {
              matrix=matrix2;
            }
            String instanceName2=po.getInstanceName();
            if (instanceName2 != null) {
              instanceName=instanceName2;
            }
            ColorTransform colorTransForm2=po.getColorTransform();
            if (colorTransForm2 != null) {
              colorTransForm=colorTransForm2;
            }
            CLIPACTIONS clipActions2=po.getClipActions();
            if (clipActions2 != null) {
              clipActions=clipActions2;
            }
            if (po.cacheAsBitmap()) {
              cacheAsBitmap=true;
            }
            int blendMode2=po.getBlendMode();
            if (blendMode2 > 0) {
              blendMode=blendMode2;
            }
            List<FILTER> filters2=po.getFilters();
            if (filters2 != null) {
              filters=filters2;
            }
            int ratio2=po.getRatio();
            if (ratio2 > -1) {
              ratio=ratio2;
            }
          }
 else {
            matrix=po.getMatrix();
            instanceName=po.getInstanceName();
            colorTransForm=po.getColorTransform();
            cacheAsBitmap=po.cacheAsBitmap();
            blendMode=po.getBlendMode();
            filters=po.getFilters();
            ratio=po.getRatio();
            clipActions=po.getClipActions();
          }
        }
      }
    }
    if (t instanceof RemoveTag) {
      RemoveTag rt=(RemoveTag)t;
      if (rt.getDepth() == depth) {
        if (shapeTween && character != null) {
          MorphShapeTag m=(MorphShapeTag)character;
          shapeTweener=m;
          shapeTween=false;
        }
        character=null;
        matrix=null;
        instanceName=null;
        colorTransForm=null;
        cacheAsBitmap=false;
        blendMode=0;
        filters=new ArrayList<>();
        isVisible=true;
        backGroundColor=null;
        characterId=-1;
        clipActions=null;
      }
    }
    if (t instanceof ShowFrameTag) {
      if ((character instanceof ShapeTag) && (nonLibraryShapes.contains(characterId) || shapeTweener != null)) {
        ShapeTag shape=(ShapeTag)character;
        elements=convertShape(characters,matrix,shape.getShapeNum(),shape.getShapes().shapeRecords,shape.getShapes().fillStyles,shape.getShapes().lineStyles,false,false);
        shapeTween=false;
        shapeTweener=null;
      }
 else       if (character != null) {
        if (character instanceof MorphShapeTag) {
          MorphShapeTag m=(MorphShapeTag)character;
          elements=convertShape(characters,matrix,3,m.getStartEdges().shapeRecords,m.getFillStyles().getStartFillStyles(),m.getLineStyles().getStartLineStyles(m.getShapeNum()),true,false);
          shapeTween=true;
        }
 else {
          shapeTween=false;
          if (character instanceof TextTag) {
            elements=convertText(instanceName,(TextTag)character,matrix,filters,clipActions);
          }
 else           if (character instanceof DefineVideoStreamTag) {
            elements=convertVideoInstance(instanceName,matrix,(DefineVideoStreamTag)character,clipActions);
          }
 else {
            elements=convertSymbolInstance(instanceName,matrix,colorTransForm,cacheAsBitmap,blendMode,filters,isVisible,backGroundColor,clipActions,character,characters,tags,flaVersion);
          }
        }
      }
 else {
        elements=""String_Node_Str"";
      }
      frame++;
      if (!elements.equals(lastElements) && frame > 0) {
        convertFrame(lastShapeTween,characters,tags,null,null,frame - duration,duration,""String_Node_Str"",lastElements,files,ret2);
        duration=1;
      }
 else       if (frame == 0) {
        duration=1;
      }
 else {
        duration++;
      }
      lastShapeTween=shapeTween;
      lastElements=elements;
    }
  }
  if (!lastElements.isEmpty()) {
    frame++;
    convertFrame(lastShapeTween,characters,tags,null,null,(frame - duration < 0 ? 0 : frame - duration),duration,""String_Node_Str"",lastElements,files,ret2);
  }
  afterStr=""String_Node_Str"" + afterStr;
  if (ret2.length() > 0) {
    ret.append(prevStr).append(ret2).append(afterStr);
  }
}","private static void convertFrames(String prevStr,String afterStr,List<Integer> nonLibraryShapes,List<Tag> tags,List<Tag> timelineTags,HashMap<Integer,CharacterTag> characters,int depth,FLAVersion flaVersion,HashMap<String,byte[]> files,StringBuilder ret){
  StringBuilder ret2=new StringBuilder();
  prevStr+=""String_Node_Str"";
  int frame=-1;
  String elements;
  String lastElements=""String_Node_Str"";
  int duration=1;
  CharacterTag character=null;
  MATRIX matrix=null;
  String instanceName=null;
  ColorTransform colorTransForm=null;
  boolean cacheAsBitmap=false;
  int blendMode=0;
  List<FILTER> filters=new ArrayList<>();
  boolean isVisible=true;
  RGBA backGroundColor=null;
  CLIPACTIONS clipActions=null;
  int characterId=-1;
  int ratio=-1;
  boolean shapeTween=false;
  boolean lastShapeTween=false;
  MorphShapeTag shapeTweener=null;
  List<Tag> timTags=new ArrayList<>(timelineTags);
  boolean needsFrameAdd=false;
  SWF swf=null;
  for (int i=timTags.size() - 1; i >= 0; i--) {
    if (timTags.get(i) instanceof ShowFrameTag) {
      break;
    }
    if (timTags.get(i) instanceof PlaceObjectTypeTag) {
      needsFrameAdd=true;
      swf=timTags.get(i).getSwf();
      break;
    }
  }
  if (needsFrameAdd) {
    timTags.add(new ShowFrameTag(swf));
  }
  for (  Tag t : timTags) {
    if (t instanceof PlaceObjectTypeTag) {
      PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
      if (po.getDepth() == depth) {
        int newCharId=po.getCharacterId();
        if (newCharId == -1) {
          newCharId=characterId;
        }
        characterId=newCharId;
        if (characters.containsKey(characterId)) {
          character=characters.get(characterId);
          if (po.flagMove()) {
            MATRIX matrix2=po.getMatrix();
            if (matrix2 != null) {
              matrix=matrix2;
            }
            String instanceName2=po.getInstanceName();
            if (instanceName2 != null) {
              instanceName=instanceName2;
            }
            ColorTransform colorTransForm2=po.getColorTransform();
            if (colorTransForm2 != null) {
              colorTransForm=colorTransForm2;
            }
            CLIPACTIONS clipActions2=po.getClipActions();
            if (clipActions2 != null) {
              clipActions=clipActions2;
            }
            if (po.cacheAsBitmap()) {
              cacheAsBitmap=true;
            }
            int blendMode2=po.getBlendMode();
            if (blendMode2 > 0) {
              blendMode=blendMode2;
            }
            List<FILTER> filters2=po.getFilters();
            if (filters2 != null) {
              filters=filters2;
            }
            int ratio2=po.getRatio();
            if (ratio2 > -1) {
              ratio=ratio2;
            }
          }
 else {
            matrix=po.getMatrix();
            instanceName=po.getInstanceName();
            colorTransForm=po.getColorTransform();
            cacheAsBitmap=po.cacheAsBitmap();
            blendMode=po.getBlendMode();
            filters=po.getFilters();
            ratio=po.getRatio();
            clipActions=po.getClipActions();
          }
        }
      }
    }
    if (t instanceof RemoveTag) {
      RemoveTag rt=(RemoveTag)t;
      if (rt.getDepth() == depth) {
        if (shapeTween && character != null) {
          MorphShapeTag m=(MorphShapeTag)character;
          shapeTweener=m;
          shapeTween=false;
        }
        character=null;
        matrix=null;
        instanceName=null;
        colorTransForm=null;
        cacheAsBitmap=false;
        blendMode=0;
        filters=new ArrayList<>();
        isVisible=true;
        backGroundColor=null;
        characterId=-1;
        clipActions=null;
      }
    }
    if (t instanceof ShowFrameTag) {
      if ((character instanceof ShapeTag) && (nonLibraryShapes.contains(characterId) || shapeTweener != null)) {
        ShapeTag shape=(ShapeTag)character;
        elements=convertShape(characters,matrix,shape.getShapeNum(),shape.getShapes().shapeRecords,shape.getShapes().fillStyles,shape.getShapes().lineStyles,false,false);
        shapeTween=false;
        shapeTweener=null;
      }
 else       if (character != null) {
        if (character instanceof MorphShapeTag) {
          MorphShapeTag m=(MorphShapeTag)character;
          elements=convertShape(characters,matrix,3,m.getStartEdges().shapeRecords,m.getFillStyles().getStartFillStyles(),m.getLineStyles().getStartLineStyles(m.getShapeNum()),true,false);
          shapeTween=true;
        }
 else {
          shapeTween=false;
          if (character instanceof TextTag) {
            elements=convertText(instanceName,(TextTag)character,matrix,filters,clipActions);
          }
 else           if (character instanceof DefineVideoStreamTag) {
            elements=convertVideoInstance(instanceName,matrix,(DefineVideoStreamTag)character,clipActions);
          }
 else {
            elements=convertSymbolInstance(instanceName,matrix,colorTransForm,cacheAsBitmap,blendMode,filters,isVisible,backGroundColor,clipActions,character,characters,tags,flaVersion);
          }
        }
      }
 else {
        elements=""String_Node_Str"";
      }
      frame++;
      if (!elements.equals(lastElements) && frame > 0) {
        convertFrame(lastShapeTween,characters,tags,null,null,frame - duration,duration,""String_Node_Str"",lastElements,files,ret2);
        duration=1;
      }
 else       if (frame == 0) {
        duration=1;
      }
 else {
        duration++;
      }
      lastShapeTween=shapeTween;
      lastElements=elements;
    }
  }
  if (!lastElements.isEmpty()) {
    frame++;
    convertFrame(lastShapeTween,characters,tags,null,null,(frame - duration < 0 ? 0 : frame - duration),duration,""String_Node_Str"",lastElements,files,ret2);
  }
  afterStr=""String_Node_Str"" + afterStr;
  if (ret2.length() > 0) {
    ret.append(prevStr).append(ret2).append(afterStr);
  }
}",0.9625076828518746
61553,"public void exportFla(final SWF swf){
  if (swf == null) {
    return;
  }
  JFileChooser fc=new JFileChooser();
  String selDir=Configuration.lastOpenDir.get();
  fc.setCurrentDirectory(new File(selDir));
  if (!selDir.endsWith(File.separator)) {
    selDir+=File.separator;
  }
  String fileName=new File(swf.getFile()).getName();
  fileName=fileName.substring(0,fileName.length() - 4) + ""String_Node_Str"";
  fc.setSelectedFile(new File(selDir + fileName));
  List<FileFilter> flaFilters=new ArrayList<>();
  List<FileFilter> xflFilters=new ArrayList<>();
  List<FLAVersion> versions=new ArrayList<>();
  boolean isAS3=swf.isAS3();
  for (int i=FLAVersion.values().length - 1; i >= 0; i--) {
    final FLAVersion v=FLAVersion.values()[i];
    if (!isAS3 && v.minASVersion() > 2) {
    }
 else {
      versions.add(v);
      FileFilter f=new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
        }
        @Override public String getDescription(){
          return translate(""String_Node_Str"").replace(""String_Node_Str"",v.applicationName());
        }
      }
;
      if (v == FLAVersion.CS6) {
        fc.setFileFilter(f);
      }
 else {
        fc.addChoosableFileFilter(f);
      }
      flaFilters.add(f);
      f=new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
        }
        @Override public String getDescription(){
          return translate(""String_Node_Str"").replace(""String_Node_Str"",v.applicationName());
        }
      }
;
      fc.addChoosableFileFilter(f);
      xflFilters.add(f);
    }
  }
  fc.setAcceptAllFileFilterUsed(false);
  JFrame f=new JFrame();
  View.setWindowIcon(f);
  if (fc.showSaveDialog(f) == JFileChooser.APPROVE_OPTION) {
    Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
    File sf=Helper.fixDialogFile(fc.getSelectedFile());
    Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
    final boolean compressed=flaFilters.contains(fc.getFileFilter());
    if (!compressed) {
      if (sf.getName().endsWith(""String_Node_Str"")) {
        sf=new File(sf.getAbsolutePath().substring(0,sf.getAbsolutePath().length() - 4) + ""String_Node_Str"");
      }
    }
    final FLAVersion selectedVersion=versions.get(compressed ? flaFilters.indexOf(fc.getFileFilter()) : xflFilters.indexOf(fc.getFileFilter()));
    final File selfile=sf;
    new CancellableWorker(){
      @Override protected Void doInBackground() throws Exception {
        Helper.freeMem();
        try {
          AbortRetryIgnoreHandler errorHandler=new GuiAbortRetryIgnoreHandler();
          if (compressed) {
            swf.exportFla(errorHandler,selfile.getAbsolutePath(),new File(swf.getFile()).getName(),ApplicationInfo.APPLICATION_NAME,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get(),selectedVersion);
          }
 else {
            swf.exportXfl(errorHandler,selfile.getAbsolutePath(),new File(swf.getFile()).getName(),ApplicationInfo.APPLICATION_NAME,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get(),selectedVersion);
          }
        }
 catch (        IOException ex) {
          View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage(),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        }
        Helper.freeMem();
        return null;
      }
      @Override protected void done(){
        Main.stopWork();
        if (Configuration.openFolderAfterFlaExport.get()) {
          try {
            Desktop.getDesktop().open(selfile.getAbsoluteFile().getParentFile());
          }
 catch (          IOException ex) {
            logger.log(Level.SEVERE,null,ex);
          }
        }
      }
    }
.execute();
  }
}","public void exportFla(final SWF swf){
  if (swf == null) {
    return;
  }
  JFileChooser fc=new JFileChooser();
  String selDir=Configuration.lastOpenDir.get();
  fc.setCurrentDirectory(new File(selDir));
  if (!selDir.endsWith(File.separator)) {
    selDir+=File.separator;
  }
  String fileName=new File(swf.getFile()).getName();
  fileName=fileName.substring(0,fileName.length() - 4) + ""String_Node_Str"";
  fc.setSelectedFile(new File(selDir + fileName));
  List<FileFilter> flaFilters=new ArrayList<>();
  List<FileFilter> xflFilters=new ArrayList<>();
  List<FLAVersion> versions=new ArrayList<>();
  boolean isAS3=swf.isAS3();
  for (int i=FLAVersion.values().length - 1; i >= 0; i--) {
    final FLAVersion v=FLAVersion.values()[i];
    if (!isAS3 && v.minASVersion() > 2) {
    }
 else {
      versions.add(v);
      FileFilter f=new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
        }
        @Override public String getDescription(){
          return translate(""String_Node_Str"").replace(""String_Node_Str"",v.applicationName());
        }
      }
;
      if (v == FLAVersion.CS6) {
        fc.setFileFilter(f);
      }
 else {
        fc.addChoosableFileFilter(f);
      }
      flaFilters.add(f);
      f=new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
        }
        @Override public String getDescription(){
          return translate(""String_Node_Str"").replace(""String_Node_Str"",v.applicationName());
        }
      }
;
      fc.addChoosableFileFilter(f);
      xflFilters.add(f);
    }
  }
  fc.setAcceptAllFileFilterUsed(false);
  JFrame f=new JFrame();
  View.setWindowIcon(f);
  if (fc.showSaveDialog(f) == JFileChooser.APPROVE_OPTION) {
    Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
    File sf=Helper.fixDialogFile(fc.getSelectedFile());
    Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
    final boolean compressed=flaFilters.contains(fc.getFileFilter());
    if (!compressed) {
      if (sf.getName().endsWith(""String_Node_Str"")) {
        sf=new File(sf.getAbsolutePath().substring(0,sf.getAbsolutePath().length() - 4) + ""String_Node_Str"");
      }
    }
    final FLAVersion selectedVersion=versions.get(compressed ? flaFilters.indexOf(fc.getFileFilter()) : xflFilters.indexOf(fc.getFileFilter()));
    final File selfile=sf;
    new CancellableWorker(){
      @Override protected Void doInBackground() throws Exception {
        Helper.freeMem();
        try {
          AbortRetryIgnoreHandler errorHandler=new GuiAbortRetryIgnoreHandler();
          if (compressed) {
            swf.exportFla(errorHandler,selfile.getAbsolutePath(),new File(swf.getFile()).getName(),ApplicationInfo.APPLICATION_NAME,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get(),selectedVersion);
          }
 else {
            swf.exportXfl(errorHandler,selfile.getAbsolutePath(),new File(swf.getFile()).getName(),ApplicationInfo.APPLICATION_NAME,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get(),selectedVersion);
          }
        }
 catch (        Exception ex) {
          View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage(),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        }
        Helper.freeMem();
        return null;
      }
      @Override protected void done(){
        Main.stopWork();
        if (Configuration.openFolderAfterFlaExport.get()) {
          try {
            Desktop.getDesktop().open(selfile.getAbsoluteFile().getParentFile());
          }
 catch (          IOException ex) {
            logger.log(Level.SEVERE,null,ex);
          }
        }
      }
    }
.execute();
  }
}",0.999752658916646
61554,"private GraphTargetItem expressionPrimary(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean allowMemberOrCall=false;
switch (s.type) {
case XML_STARTTAG_BEGIN:
    lexer.pushback(s);
  ret=xml(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
break;
case STRING:
ret=new StringAVM2Item(null,s.value.toString());
allowMemberOrCall=true;
break;
case NEGATE:
ret=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,false,variables);
ret=new NegAVM2Item(null,ret);
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new FloatValueAVM2Item(null,-(Double)s.value);
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new IntegerValueAVM2Item(null,-(Long)s.value);
}
 else {
lexer.pushback(s);
GraphTargetItem num=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (num instanceof IntegerValueAVM2Item) {
((IntegerValueAVM2Item)num).value=-((IntegerValueAVM2Item)num).value;
ret=num;
}
 else if (num instanceof FloatValueAVM2Item) {
Double d=((FloatValueAVM2Item)num).value;
if (d.isInfinite()) {
((FloatValueAVM2Item)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((FloatValueAVM2Item)num).value=-d;
}
ret=(num);
}
 else {
ret=(new SubtractAVM2Item(null,new IntegerValueAVM2Item(null,0L),num));
}
}
break;
case TYPEOF:
ret=new TypeOfAVM2Item(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,false,variables));
break;
case TRUE:
ret=new BooleanAVM2Item(null,true);
break;
case NULL:
ret=new NullAVM2Item(null);
break;
case UNDEFINED:
ret=new UndefinedAVM2Item(null);
break;
case FALSE:
ret=new BooleanAVM2Item(null,false);
break;
case CURLY_OPEN:
s=lex();
List<NameValuePair> nvs=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.STRING);
GraphTargetItem n=new StringAVM2Item(null,s.value.toString());
expectedType(SymbolType.COLON);
GraphTargetItem v=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,allowRemainder,variables);
NameValuePair nv=new NameValuePair(n,v);
nvs.add(nv);
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new NewObjectAVM2Item(null,nvs);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,inBrackets,registerVars,inFunction,inMethod,variables);
ret=new NewArrayAVM2Item(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,fname,false,variables);
allowMemberOrCall=true;
break;
case NAN:
ret=new NanAVM2Item(null);
break;
case INFINITY:
ret=new FloatValueAVM2Item(null,Double.POSITIVE_INFINITY);
break;
case INTEGER:
ret=new IntegerValueAVM2Item(null,(Long)s.value);
break;
case DOUBLE:
ret=new FloatValueAVM2Item(null,(Double)s.value);
break;
case DELETE:
GraphTargetItem varDel=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(varDel)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new DeletePropertyAVM2Item(varDel,lexer.yyline());
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
if (!isNameOrProp(varincdec)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementAVM2Item(null,varincdec);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementAVM2Item(null,varincdec);
}
break;
case NOT:
ret=new NotItem(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
s=lex();
if (s.type == SymbolType.XML_STARTTAG_BEGIN) {
lexer.yypushbackstr(s.value.toString().substring(1),ActionScriptLexer.YYINITIAL);
s=new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.LOWER_THAN);
}
if (s.type == SymbolType.FUNCTION) {
s=lexer.lex();
String ffname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
ffname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,ffname,false,variables);
}
 else if (s.type == SymbolType.LOWER_THAN) {
GraphTargetItem subtype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
expectedType(SymbolType.GREATER_THAN);
s=lex();
expected(s,lexer.yyline(),SymbolType.BRACKET_OPEN);
lexer.pushback(s);
List<GraphTargetItem> params=new ArrayList<>();
brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,params,registerVars,inFunction,inMethod,variables);
ret=new InitVectorAVM2Item(subtype,params,openedNamespaces);
}
 else if (s.type == SymbolType.PARENT_OPEN) {
GraphTargetItem newvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
 else {
lexer.pushback(s);
GraphTargetItem newvar=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case ATTRIBUTE:
lexer.pushback(s);
ret=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
allowMemberOrCall=true;
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}","private GraphTargetItem expressionPrimary(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean allowMemberOrCall=false;
switch (s.type) {
case XML_STARTTAG_BEGIN:
    lexer.pushback(s);
  ret=xml(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
break;
case STRING:
ret=new StringAVM2Item(null,s.value.toString());
allowMemberOrCall=true;
break;
case NEGATE:
ret=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
ret=new NegAVM2Item(null,ret);
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new FloatValueAVM2Item(null,-(Double)s.value);
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new IntegerValueAVM2Item(null,-(Long)s.value);
}
 else {
lexer.pushback(s);
GraphTargetItem num=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (num instanceof IntegerValueAVM2Item) {
((IntegerValueAVM2Item)num).value=-((IntegerValueAVM2Item)num).value;
ret=num;
}
 else if (num instanceof FloatValueAVM2Item) {
Double d=((FloatValueAVM2Item)num).value;
if (d.isInfinite()) {
((FloatValueAVM2Item)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((FloatValueAVM2Item)num).value=-d;
}
ret=(num);
}
 else {
ret=(new SubtractAVM2Item(null,new IntegerValueAVM2Item(null,0L),num));
}
}
break;
case TYPEOF:
ret=new TypeOfAVM2Item(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case TRUE:
ret=new BooleanAVM2Item(null,true);
break;
case NULL:
ret=new NullAVM2Item(null);
break;
case UNDEFINED:
ret=new UndefinedAVM2Item(null);
break;
case FALSE:
ret=new BooleanAVM2Item(null,false);
break;
case CURLY_OPEN:
s=lex();
List<NameValuePair> nvs=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.STRING);
GraphTargetItem n=new StringAVM2Item(null,s.value.toString());
expectedType(SymbolType.COLON);
GraphTargetItem v=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,allowRemainder,variables);
NameValuePair nv=new NameValuePair(n,v);
nvs.add(nv);
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new NewObjectAVM2Item(null,nvs);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,inBrackets,registerVars,inFunction,inMethod,variables);
ret=new NewArrayAVM2Item(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,fname,false,variables);
allowMemberOrCall=true;
break;
case NAN:
ret=new NanAVM2Item(null);
break;
case INFINITY:
ret=new FloatValueAVM2Item(null,Double.POSITIVE_INFINITY);
break;
case INTEGER:
ret=new IntegerValueAVM2Item(null,(Long)s.value);
break;
case DOUBLE:
ret=new FloatValueAVM2Item(null,(Double)s.value);
break;
case DELETE:
GraphTargetItem varDel=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(varDel)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new DeletePropertyAVM2Item(varDel,lexer.yyline());
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
if (!isNameOrProp(varincdec)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementAVM2Item(null,varincdec);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementAVM2Item(null,varincdec);
}
break;
case NOT:
ret=new NotItem(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
s=lex();
if (s.type == SymbolType.XML_STARTTAG_BEGIN) {
lexer.yypushbackstr(s.value.toString().substring(1),ActionScriptLexer.YYINITIAL);
s=new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.LOWER_THAN);
}
if (s.type == SymbolType.FUNCTION) {
s=lexer.lex();
String ffname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
ffname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,ffname,false,variables);
}
 else if (s.type == SymbolType.LOWER_THAN) {
GraphTargetItem subtype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
expectedType(SymbolType.GREATER_THAN);
s=lex();
expected(s,lexer.yyline(),SymbolType.BRACKET_OPEN);
lexer.pushback(s);
List<GraphTargetItem> params=new ArrayList<>();
brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,params,registerVars,inFunction,inMethod,variables);
ret=new InitVectorAVM2Item(subtype,params,openedNamespaces);
}
 else if (s.type == SymbolType.PARENT_OPEN) {
GraphTargetItem newvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
 else {
lexer.pushback(s);
GraphTargetItem newvar=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case ATTRIBUTE:
lexer.pushback(s);
ret=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
allowMemberOrCall=true;
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}",0.9958548561953956
61555,"private GraphTargetItem expressionPrimary(boolean allowEmpty,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ActionParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  boolean allowMemberOrCall=false;
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
switch (s.type) {
case NEGATE:
    versionRequired(s,5);
  ret=expression(inFunction,inMethod,false,variables);
ret=new BitXorActionItem(null,ret,new DirectValueActionItem(4.294967295E9));
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new DirectValueActionItem(null,0,-(double)(Double)s.value,new ArrayList<String>());
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new DirectValueActionItem(null,0,-(long)(Long)s.value,new ArrayList<String>());
}
 else {
lexer.pushback(s);
GraphTargetItem num=expression(inFunction,inMethod,true,variables);
if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Long)) {
((DirectValueActionItem)num).value=-(Long)((DirectValueActionItem)num).value;
ret=num;
}
 else if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Double)) {
Double d=(Double)((DirectValueActionItem)num).value;
if (d.isInfinite()) {
((DirectValueActionItem)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((DirectValueActionItem)num).value=-d;
}
ret=(num);
}
 else if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Float)) {
((DirectValueActionItem)num).value=-(Float)((DirectValueActionItem)num).value;
ret=(num);
}
 else {
;
ret=(new SubtractActionItem(null,new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>()),num));
}
}
break;
case TYPEOF:
ret=new TypeOfActionItem(null,expression(inFunction,inMethod,false,variables));
allowMemberOrCall=true;
break;
case TRUE:
ret=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
break;
case NULL:
ret=new DirectValueActionItem(null,0,new Null(),new ArrayList<String>());
break;
case UNDEFINED:
ret=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
break;
case FALSE:
ret=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
break;
case CURLY_OPEN:
s=lex();
List<GraphTargetItem> objectNames=new ArrayList<>();
List<GraphTargetItem> objectValues=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
objectNames.add(0,pushConst((String)s.value));
expectedType(SymbolType.COLON);
objectValues.add(0,expression(inFunction,inMethod,true,variables));
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new InitObjectActionItem(null,objectNames,objectValues);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(inBrackets,inFunction,inMethod,variables);
ret=new InitArrayActionItem(null,inBrackets);
allowMemberOrCall=true;
break;
case FUNCTION:
s=lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolType.IDENTIFIER,SymbolGroup.GLOBALFUNC)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
ret=function(true,fname,false,variables);
allowMemberOrCall=true;
break;
case STRING:
ret=pushConst(s.value.toString());
allowMemberOrCall=true;
break;
case NEWLINE:
ret=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
allowMemberOrCall=true;
break;
case NAN:
ret=new DirectValueActionItem(null,0,Double.NaN,new ArrayList<String>());
break;
case INFINITY:
ret=new DirectValueActionItem(null,0,Double.POSITIVE_INFINITY,new ArrayList<String>());
break;
case INTEGER:
case DOUBLE:
ret=new DirectValueActionItem(null,0,s.value,new ArrayList<String>());
break;
case DELETE:
GraphTargetItem varDel=expression(inFunction,inMethod,false,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ActionParseException(""String_Node_Str"",lexer.yyline());
}
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem prevar=expressionPrimary(false,inFunction,inMethod,false,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,prevar);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,prevar);
}
break;
case NOT:
ret=new NotItem(null,expression(inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
GraphTargetItem newvar=expressionPrimary(false,inFunction,inMethod,false,variables);
if (newvar instanceof CallMethodActionItem) {
CallMethodActionItem ca=(CallMethodActionItem)newvar;
ret=new NewMethodActionItem(null,ca.scriptObject,ca.methodName,ca.arguments);
}
 else if (newvar instanceof CallFunctionActionItem) {
CallFunctionActionItem cf=(CallFunctionActionItem)newvar;
ret=new NewObjectActionItem(null,cf.functionName,cf.arguments);
}
 else {
throw new ActionParseException(""String_Node_Str"",lexer.yyline());
}
break;
case EVAL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem evar=new EvalActionItem(null,expression(inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=evar;
allowMemberOrCall=true;
break;
case IDENTIFIER:
case THIS:
case SUPER:
if (s.value.equals(""String_Node_Str"")) {
ret=new NotItem(null,expression(inFunction,inMethod,false,variables));
}
 else {
ret=new VariableActionItem(s.value.toString(),null,false);
variables.add((VariableActionItem)ret);
allowMemberOrCall=true;
}
break;
default :
GraphTargetItem excmd=expressionCommands(s,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(ret,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}","private GraphTargetItem expressionPrimary(boolean allowEmpty,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ActionParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  boolean allowMemberOrCall=false;
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
switch (s.type) {
case NEGATE:
    versionRequired(s,5);
  ret=expressionPrimary(false,inFunction,inMethod,false,variables);
ret=new BitXorActionItem(null,ret,new DirectValueActionItem(4.294967295E9));
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new DirectValueActionItem(null,0,-(double)(Double)s.value,new ArrayList<String>());
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new DirectValueActionItem(null,0,-(long)(Long)s.value,new ArrayList<String>());
}
 else {
lexer.pushback(s);
GraphTargetItem num=expressionPrimary(false,inFunction,inMethod,true,variables);
if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Long)) {
((DirectValueActionItem)num).value=-(Long)((DirectValueActionItem)num).value;
ret=num;
}
 else if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Double)) {
Double d=(Double)((DirectValueActionItem)num).value;
if (d.isInfinite()) {
((DirectValueActionItem)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((DirectValueActionItem)num).value=-d;
}
ret=(num);
}
 else if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Float)) {
((DirectValueActionItem)num).value=-(Float)((DirectValueActionItem)num).value;
ret=(num);
}
 else {
;
ret=(new SubtractActionItem(null,new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>()),num));
}
}
break;
case TYPEOF:
ret=new TypeOfActionItem(null,expressionPrimary(false,inFunction,inMethod,false,variables));
allowMemberOrCall=true;
break;
case TRUE:
ret=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
break;
case NULL:
ret=new DirectValueActionItem(null,0,new Null(),new ArrayList<String>());
break;
case UNDEFINED:
ret=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
break;
case FALSE:
ret=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
break;
case CURLY_OPEN:
s=lex();
List<GraphTargetItem> objectNames=new ArrayList<>();
List<GraphTargetItem> objectValues=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
objectNames.add(0,pushConst((String)s.value));
expectedType(SymbolType.COLON);
objectValues.add(0,expression(inFunction,inMethod,true,variables));
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new InitObjectActionItem(null,objectNames,objectValues);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(inBrackets,inFunction,inMethod,variables);
ret=new InitArrayActionItem(null,inBrackets);
allowMemberOrCall=true;
break;
case FUNCTION:
s=lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolType.IDENTIFIER,SymbolGroup.GLOBALFUNC)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
ret=function(true,fname,false,variables);
allowMemberOrCall=true;
break;
case STRING:
ret=pushConst(s.value.toString());
allowMemberOrCall=true;
break;
case NEWLINE:
ret=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
allowMemberOrCall=true;
break;
case NAN:
ret=new DirectValueActionItem(null,0,Double.NaN,new ArrayList<String>());
break;
case INFINITY:
ret=new DirectValueActionItem(null,0,Double.POSITIVE_INFINITY,new ArrayList<String>());
break;
case INTEGER:
case DOUBLE:
ret=new DirectValueActionItem(null,0,s.value,new ArrayList<String>());
break;
case DELETE:
GraphTargetItem varDel=expressionPrimary(false,inFunction,inMethod,false,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ActionParseException(""String_Node_Str"",lexer.yyline());
}
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem prevar=expressionPrimary(false,inFunction,inMethod,false,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,prevar);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,prevar);
}
break;
case NOT:
ret=new NotItem(null,expressionPrimary(false,inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
GraphTargetItem newvar=expressionPrimary(false,inFunction,inMethod,false,variables);
if (newvar instanceof CallMethodActionItem) {
CallMethodActionItem ca=(CallMethodActionItem)newvar;
ret=new NewMethodActionItem(null,ca.scriptObject,ca.methodName,ca.arguments);
}
 else if (newvar instanceof CallFunctionActionItem) {
CallFunctionActionItem cf=(CallFunctionActionItem)newvar;
ret=new NewObjectActionItem(null,cf.functionName,cf.arguments);
}
 else {
throw new ActionParseException(""String_Node_Str"",lexer.yyline());
}
break;
case EVAL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem evar=new EvalActionItem(null,expression(inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=evar;
allowMemberOrCall=true;
break;
case IDENTIFIER:
case THIS:
case SUPER:
if (s.value.equals(""String_Node_Str"")) {
ret=new NotItem(null,expressionPrimary(false,inFunction,inMethod,false,variables));
}
 else {
ret=new VariableActionItem(s.value.toString(),null,false);
variables.add((VariableActionItem)ret);
allowMemberOrCall=true;
}
break;
default :
GraphTargetItem excmd=expressionCommands(s,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(ret,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}",0.992759452936444
61556,"private GraphTargetItem command(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,Stack<Loop> loops,Map<Loop,String> loopLabels,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
  String loopLabel=null;
  if (s.group == SymbolGroup.IDENTIFIER) {
    ParsedSymbol sc=lex();
    if (sc.type == SymbolType.COLON) {
      loopLabel=s.value.toString();
      s=lex();
    }
 else {
      lexer.pushback(sc);
    }
  }
  if (s.type == SymbolType.DEFAULT) {
    ParsedSymbol sx=lex();
    if (sx.group != SymbolGroup.IDENTIFIER) {
      lexer.pushback(sx);
    }
 else {
      if (!sx.value.equals(""String_Node_Str"")) {
        lexer.pushback(sx);
      }
 else {
        expectedType(SymbolType.NAMESPACE);
        expectedType(SymbolType.ASSIGN);
        GraphTargetItem ns=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
        ret=new DefaultXMLNamespace(null,ns);
      }
    }
  }
  if (ret == null) {
switch (s.type) {
case USE:
      expectedType(SymbolType.NAMESPACE);
    GraphTargetItem ns=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
  openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(ns.toString(),true)),0,true));
break;
case WITH:
needsActivation.setVal(true);
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(wvar)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<AssignableAVM2Item> withVars=new ArrayList<>();
List<GraphTargetItem> wcmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,withVars);
variables.addAll(withVars);
for (AssignableAVM2Item a : withVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ua=(UnresolvedAVM2Item)a;
ua.scopeStack.add(0,wvar);
}
}
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithAVM2Item(null,wvar,wcmd);
((WithAVM2Item)ret).subvariables=withVars;
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
needsActivation.setVal(true);
ret=(function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
GraphTargetItem type;
if (s.type == SymbolType.COLON) {
type=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
s=lex();
}
 else {
type=new UnboundedTypeItem();
}
if (s.type == SymbolType.ASSIGN) {
GraphTargetItem varval=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,varval,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
}
 else {
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,null,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case SUPER:
ParsedSymbol ss2=lex();
if (ss2.type == SymbolType.PARENT_OPEN) {
List<GraphTargetItem> args=call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
ret=new ConstructSuperAVM2Item(null,new LocalRegAVM2Item(null,0,null),args);
}
 else {
lexer.pushback(ss2);
lexer.pushback(s);
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
Loop wloop=new Loop(uniqId(),null,null);
if (loopLabel != null) {
loopLabels.put(wloop,loopLabel);
}
loops.push(wloop);
whileBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,wloop,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
Loop dloop=new Loop(uniqId(),null,null);
loops.push(dloop);
if (loopLabel != null) {
loopLabels.put(dloop,loopLabel);
}
doBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,dloop,doBody,doExpr);
break;
case FOR:
s=lex();
boolean forin=false;
boolean each=false;
GraphTargetItem collection=null;
if (s.type == SymbolType.EACH) {
each=true;
forin=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolType.PARENT_OPEN);
GraphTargetItem firstCommand=command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,false,variables);
if (firstCommand instanceof NameAVM2Item) {
NameAVM2Item nai=(NameAVM2Item)firstCommand;
if (nai.isDefinition() && nai.getAssignedValue() == null) {
firstCommand=expression1(firstCommand,firstCommand.getPrecedence(),thisType,pkg,needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
}
}
InAVM2Item inexpr=null;
if (firstCommand instanceof InAVM2Item) {
forin=true;
inexpr=(InAVM2Item)firstCommand;
}
 else {
if (forin) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
Loop floop=new Loop(uniqId(),null,null);
loops.push(floop);
if (loopLabel != null) {
loopLabels.put(floop,loopLabel);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
if (firstCommand != null) {
forFirstCommands.add(firstCommand);
}
forExpr=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
if (each) {
ret=new ForEachInAVM2Item(null,floop,inexpr,forBody);
}
 else {
ret=new ForInAVM2Item(null,floop,inexpr,forBody);
}
}
 else {
ret=new ForItem(null,floop,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
Loop sloop=new Loop(-uniqId(),null,null);
loops.push(sloop);
if (loopLabel != null) {
loopLabels.put(sloop,loopLabel);
}
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,sloop,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
s=lex();
long bloopId=0;
if (loops.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.group == SymbolGroup.IDENTIFIER) {
String breakLabel=s.value.toString();
for (Loop l : loops) {
if (breakLabel.equals(loopLabels.get(l))) {
bloopId=l.id;
break;
}
}
if (bloopId == 0) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
bloopId=loops.peek().id;
}
ret=new BreakItem(null,bloopId);
break;
case CONTINUE:
s=lex();
long cloopId=0;
if (loops.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.group == SymbolGroup.IDENTIFIER) {
String continueLabel=s.value.toString();
for (Loop l : loops) {
if (l.id < 0) {
continue;
}
if (continueLabel.equals(loopLabels.get(l))) {
cloopId=l.id;
break;
}
}
if (cloopId == -1) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
for (int i=loops.size() - 1; i >= 0; i--) {
if (loops.get(i).id >= 0) {
cloopId=loops.get(i).id;
break;
}
}
if (cloopId <= 0) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
ret=new ContinueItem(null,cloopId);
break;
case RETURN:
GraphTargetItem retexpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
ret=new ReturnVoidAVM2Item(null);
}
 else {
ret=new ReturnValueAVM2Item(null,retexpr);
}
break;
case TRY:
needsActivation.setVal(true);
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=new ArrayList<>();
List<NameAVM2Item> catchExceptions=new ArrayList<>();
int varCnt=variables.size();
List<List<AssignableAVM2Item>> catchesVars=new ArrayList<>();
while (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
String enamestr=s.value.toString();
expectedType(SymbolType.COLON);
GraphTargetItem etype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
NameAVM2Item e=new NameAVM2Item(etype,lexer.yyline(),enamestr,new ExceptionAVM2Item(null),true,openedNamespaces);
variables.add(e);
catchExceptions.add(e);
e.setSlotNumber(1);
e.setSlotScope(Integer.MAX_VALUE);
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> cc=new ArrayList<>();
List<AssignableAVM2Item> catchVars=new ArrayList<>();
cc.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,catchVars));
catchesVars.add(catchVars);
variables.addAll(catchVars);
for (AssignableAVM2Item a : catchVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)a;
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
catchCommands.add(cc);
s=lex();
found=true;
}
for (int i=varCnt; i < variables.size(); i++) {
AssignableAVM2Item av=variables.get(i);
if (av instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)av;
for (NameAVM2Item e : catchExceptions) {
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
TryAVM2Item tai=new TryAVM2Item(tryCommands,null,catchCommands,finallyCommands);
tai.catchVariables=catchesVars;
tai.catchExceptions2=catchExceptions;
ret=tai;
break;
case THROW:
ret=new ThrowAVM2Item(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type == SymbolType.SEMICOLON) {
return null;
}
lexer.pushback(s);
ret=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (debugMode) {
System.out.println(""String_Node_Str"");
}
}
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}","private GraphTargetItem command(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,Stack<Loop> loops,Map<Loop,String> loopLabels,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
  String loopLabel=null;
  if (s.group == SymbolGroup.IDENTIFIER) {
    ParsedSymbol sc=lex();
    if (sc.type == SymbolType.COLON) {
      loopLabel=s.value.toString();
      s=lex();
    }
 else {
      lexer.pushback(sc);
    }
  }
  if (s.type == SymbolType.DEFAULT) {
    ParsedSymbol sx=lex();
    if (sx.group != SymbolGroup.IDENTIFIER) {
      lexer.pushback(sx);
    }
 else {
      if (!sx.value.equals(""String_Node_Str"")) {
        lexer.pushback(sx);
      }
 else {
        expectedType(SymbolType.NAMESPACE);
        expectedType(SymbolType.ASSIGN);
        GraphTargetItem ns=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
        ret=new DefaultXMLNamespace(null,ns);
      }
    }
  }
  if (ret == null) {
switch (s.type) {
case USE:
      expectedType(SymbolType.NAMESPACE);
    GraphTargetItem ns=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
  openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(ns.toString(),true)),0,true));
break;
case WITH:
needsActivation.setVal(true);
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(wvar)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<AssignableAVM2Item> withVars=new ArrayList<>();
List<GraphTargetItem> wcmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,withVars);
variables.addAll(withVars);
for (AssignableAVM2Item a : withVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ua=(UnresolvedAVM2Item)a;
ua.scopeStack.add(0,wvar);
}
}
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithAVM2Item(null,wvar,wcmd);
((WithAVM2Item)ret).subvariables=withVars;
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
needsActivation.setVal(true);
ret=(function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
GraphTargetItem type;
if (s.type == SymbolType.COLON) {
type=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
s=lex();
}
 else {
type=new UnboundedTypeItem();
}
if (s.type == SymbolType.ASSIGN) {
GraphTargetItem varval=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,varval,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
}
 else {
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,null,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case SUPER:
ParsedSymbol ss2=lex();
if (ss2.type == SymbolType.PARENT_OPEN) {
List<GraphTargetItem> args=call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
ret=new ConstructSuperAVM2Item(null,new LocalRegAVM2Item(null,0,null),args);
}
 else {
lexer.pushback(ss2);
lexer.pushback(s);
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
Loop wloop=new Loop(uniqId(),null,null);
if (loopLabel != null) {
loopLabels.put(wloop,loopLabel);
}
loops.push(wloop);
whileBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,wloop,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
Loop dloop=new Loop(uniqId(),null,null);
loops.push(dloop);
if (loopLabel != null) {
loopLabels.put(dloop,loopLabel);
}
doBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,dloop,doBody,doExpr);
break;
case FOR:
s=lex();
boolean forin=false;
boolean each=false;
GraphTargetItem collection=null;
if (s.type == SymbolType.EACH) {
each=true;
forin=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolType.PARENT_OPEN);
GraphTargetItem firstCommand=command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,false,variables);
if (firstCommand instanceof NameAVM2Item) {
NameAVM2Item nai=(NameAVM2Item)firstCommand;
if (nai.isDefinition() && nai.getAssignedValue() == null) {
firstCommand=expression1(firstCommand,GraphTargetItem.NOPRECEDENCE,thisType,pkg,needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
}
}
InAVM2Item inexpr=null;
if (firstCommand instanceof InAVM2Item) {
forin=true;
inexpr=(InAVM2Item)firstCommand;
}
 else {
if (forin) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
Loop floop=new Loop(uniqId(),null,null);
loops.push(floop);
if (loopLabel != null) {
loopLabels.put(floop,loopLabel);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
if (firstCommand != null) {
forFirstCommands.add(firstCommand);
}
forExpr=(expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
if (each) {
ret=new ForEachInAVM2Item(null,floop,inexpr,forBody);
}
 else {
ret=new ForInAVM2Item(null,floop,inexpr,forBody);
}
}
 else {
ret=new ForItem(null,floop,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
Loop sloop=new Loop(-uniqId(),null,null);
loops.push(sloop);
if (loopLabel != null) {
loopLabels.put(sloop,loopLabel);
}
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,sloop,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
s=lex();
long bloopId=0;
if (loops.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.group == SymbolGroup.IDENTIFIER) {
String breakLabel=s.value.toString();
for (Loop l : loops) {
if (breakLabel.equals(loopLabels.get(l))) {
bloopId=l.id;
break;
}
}
if (bloopId == 0) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
bloopId=loops.peek().id;
}
ret=new BreakItem(null,bloopId);
break;
case CONTINUE:
s=lex();
long cloopId=0;
if (loops.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.group == SymbolGroup.IDENTIFIER) {
String continueLabel=s.value.toString();
for (Loop l : loops) {
if (l.id < 0) {
continue;
}
if (continueLabel.equals(loopLabels.get(l))) {
cloopId=l.id;
break;
}
}
if (cloopId == -1) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
for (int i=loops.size() - 1; i >= 0; i--) {
if (loops.get(i).id >= 0) {
cloopId=loops.get(i).id;
break;
}
}
if (cloopId <= 0) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
ret=new ContinueItem(null,cloopId);
break;
case RETURN:
GraphTargetItem retexpr=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
ret=new ReturnVoidAVM2Item(null);
}
 else {
ret=new ReturnValueAVM2Item(null,retexpr);
}
break;
case TRY:
needsActivation.setVal(true);
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=new ArrayList<>();
List<NameAVM2Item> catchExceptions=new ArrayList<>();
int varCnt=variables.size();
List<List<AssignableAVM2Item>> catchesVars=new ArrayList<>();
while (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
String enamestr=s.value.toString();
expectedType(SymbolType.COLON);
GraphTargetItem etype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
NameAVM2Item e=new NameAVM2Item(etype,lexer.yyline(),enamestr,new ExceptionAVM2Item(null),true,openedNamespaces);
variables.add(e);
catchExceptions.add(e);
e.setSlotNumber(1);
e.setSlotScope(Integer.MAX_VALUE);
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> cc=new ArrayList<>();
List<AssignableAVM2Item> catchVars=new ArrayList<>();
cc.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,catchVars));
catchesVars.add(catchVars);
variables.addAll(catchVars);
for (AssignableAVM2Item a : catchVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)a;
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
catchCommands.add(cc);
s=lex();
found=true;
}
for (int i=varCnt; i < variables.size(); i++) {
AssignableAVM2Item av=variables.get(i);
if (av instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)av;
for (NameAVM2Item e : catchExceptions) {
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(thisType,pkg,needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
TryAVM2Item tai=new TryAVM2Item(tryCommands,null,catchCommands,finallyCommands);
tai.catchVariables=catchesVars;
tai.catchExceptions2=catchExceptions;
ret=tai;
break;
case THROW:
ret=new ThrowAVM2Item(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type == SymbolType.SEMICOLON) {
return null;
}
lexer.pushback(s);
ret=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (debugMode) {
System.out.println(""String_Node_Str"");
}
}
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}",0.9982982478255388
61557,"public boolean exportAS3Class(String className,String outdir,ScriptExportSettings exportSettings,boolean parallel,EventListener evl) throws Exception {
  boolean exported=false;
  List<ABCContainerTag> abcList=getAbcList();
  for (int i=0; i < abcList.size(); i++) {
    ABC abc=abcList.get(i).getABC();
    List<ScriptPack> scrs=abc.findScriptPacksByPath(className);
    for (int j=0; j < scrs.size(); j++) {
      ScriptPack scr=scrs.get(j);
      String cnt=""String_Node_Str"";
      if (scrs.size() > 1) {
        cnt=""String_Node_Str"" + (j + 1) + ""String_Node_Str""+ scrs.size()+ ""String_Node_Str"";
      }
      String eventData=cnt + scr.getPath() + ""String_Node_Str"";
      evl.handleExportingEvent(""String_Node_Str"",i + 1,abcList.size(),eventData);
      scr.export(outdir,exportSettings,parallel);
      evl.handleExportedEvent(""String_Node_Str"",i + 1,abcList.size(),eventData);
      exported=true;
    }
  }
  return exported;
}","public boolean exportAS3Class(String className,String outdir,ScriptExportSettings exportSettings,boolean parallel,EventListener evl) throws Exception {
  boolean exported=false;
  List<ABCContainerTag> abcList=getAbcList();
  List<ABC> allAbcList=new ArrayList<>();
  for (int i=0; i < abcList.size(); i++) {
    allAbcList.add(abcList.get(i).getABC());
  }
  for (int i=0; i < abcList.size(); i++) {
    ABC abc=abcList.get(i).getABC();
    List<ScriptPack> scrs=abc.findScriptPacksByPath(className,allAbcList);
    for (int j=0; j < scrs.size(); j++) {
      ScriptPack scr=scrs.get(j);
      String cnt=""String_Node_Str"";
      if (scrs.size() > 1) {
        cnt=""String_Node_Str"" + (j + 1) + ""String_Node_Str""+ scrs.size()+ ""String_Node_Str"";
      }
      String eventData=cnt + scr.getPath() + ""String_Node_Str"";
      evl.handleExportingEvent(""String_Node_Str"",i + 1,abcList.size(),eventData);
      scr.export(outdir,exportSettings,parallel);
      evl.handleExportedEvent(""String_Node_Str"",i + 1,abcList.size(),eventData);
      exported=true;
    }
  }
  return exported;
}",0.8797624938149431
61558,"public List<ScriptPack> getAS3Packs(){
  List<ScriptPack> packs=new ArrayList<>();
  for (  ABCContainerTag abcTag : getAbcList()) {
    packs.addAll(abcTag.getABC().getScriptPacks(null));
  }
  return uniqueAS3Packs(packs);
}","public List<ScriptPack> getAS3Packs(){
  List<ScriptPack> packs=new ArrayList<>();
  List<ABCContainerTag> abcList=getAbcList();
  List<ABC> allAbcList=new ArrayList<>();
  for (int i=0; i < abcList.size(); i++) {
    allAbcList.add(abcList.get(i).getABC());
  }
  for (  ABCContainerTag abcTag : abcList) {
    packs.addAll(abcTag.getABC().getScriptPacks(null,allAbcList));
  }
  return uniqueAS3Packs(packs);
}",0.54858934169279
61559,"public List<ScriptPack> findScriptPacksByPath(String name){
  List<ScriptPack> ret=new ArrayList<>();
  List<ScriptPack> allPacks=getScriptPacks(null);
  if (name.endsWith(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.endsWith(""String_Node_Str"")|| name.equals(""String_Node_Str"")) {
    name=name.substring(0,name.length() - 2);
    for (    ScriptPack en : allPacks) {
      if (en.getClassPath().toString().startsWith(name)) {
        ret.add(en);
      }
    }
  }
 else   if (name.endsWith(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.endsWith(""String_Node_Str"")|| name.equals(""String_Node_Str"")) {
    name=name.substring(0,name.length() - 1);
    for (    ScriptPack en : allPacks) {
      String classPathStr=en.getClassPath().toString();
      if (classPathStr.startsWith(name)) {
        String rem=name.isEmpty() ? classPathStr : classPathStr.substring(name.length());
        if (!rem.contains(""String_Node_Str"")) {
          ret.add(en);
        }
      }
    }
  }
 else {
    ScriptPack p=findScriptPackByPath(name);
    if (p != null) {
      ret.add(p);
    }
  }
  return ret;
}","public List<ScriptPack> findScriptPacksByPath(String name,List<ABC> allAbcs){
  List<ScriptPack> ret=new ArrayList<>();
  List<ScriptPack> allPacks=getScriptPacks(null,allAbcs);
  if (name.endsWith(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.endsWith(""String_Node_Str"")|| name.equals(""String_Node_Str"")) {
    name=name.substring(0,name.length() - 2);
    for (    ScriptPack en : allPacks) {
      if (en.getClassPath().toString().startsWith(name)) {
        ret.add(en);
      }
    }
  }
 else   if (name.endsWith(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.endsWith(""String_Node_Str"")|| name.equals(""String_Node_Str"")) {
    name=name.substring(0,name.length() - 1);
    for (    ScriptPack en : allPacks) {
      String classPathStr=en.getClassPath().toString();
      if (classPathStr.startsWith(name)) {
        String rem=name.isEmpty() ? classPathStr : classPathStr.substring(name.length());
        if (!rem.contains(""String_Node_Str"")) {
          ret.add(en);
        }
      }
    }
  }
 else {
    ScriptPack p=findScriptPackByPath(name,allAbcs);
    if (p != null) {
      ret.add(p);
    }
  }
  return ret;
}",0.9851138353765324
61560,"public ScriptPack findScriptPackByPath(String name){
  List<ScriptPack> packs=getScriptPacks(null);
  for (  ScriptPack en : packs) {
    if (en.getClassPath().toString().equals(name)) {
      return en;
    }
  }
  return null;
}","public ScriptPack findScriptPackByPath(String name,List<ABC> allAbcs){
  List<ScriptPack> packs=getScriptPacks(null,allAbcs);
  for (  ScriptPack en : packs) {
    if (en.getClassPath().toString().equals(name)) {
      return en;
    }
  }
  return null;
}",0.9465020576131687
61561,"public void replaceScriptPack(ScriptPack pack,String as) throws AVM2ParseException, CompilationException, IOException, InterruptedException {
  String scriptName=pack.getPathScriptName() + ""String_Node_Str"";
  int oldIndex=pack.scriptIndex;
  int newIndex=script_info.size();
  String documentClass=getSwf().getDocumentClass();
  boolean isDocumentClass=documentClass != null && documentClass.equals(pack.getClassPath().toString());
  ScriptInfo si=script_info.get(oldIndex);
  si.delete(this,true);
  int newClassIndex=instance_info.size();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      newClassIndex=tc.class_info + 1;
    }
  }
  ActionScriptParser.compile(as,this,new ArrayList<ABC>(),isDocumentClass,scriptName,newClassIndex);
  script_info.set(oldIndex,script_info.get(newIndex));
  script_info.remove(newIndex);
  script_info.get(oldIndex).setModified(true);
  pack();
  ((Tag)parentTag).setModified(true);
}","public void replaceScriptPack(ScriptPack pack,String as) throws AVM2ParseException, CompilationException, IOException, InterruptedException {
  String scriptName=pack.getPathScriptName() + ""String_Node_Str"";
  int oldIndex=pack.scriptIndex;
  int newIndex=script_info.size();
  String documentClass=getSwf().getDocumentClass();
  boolean isDocumentClass=documentClass != null && documentClass.equals(pack.getClassPath().toString());
  ScriptInfo si=script_info.get(oldIndex);
  si.delete(this,true);
  int newClassIndex=instance_info.size();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      newClassIndex=tc.class_info + 1;
    }
  }
  List<ABC> otherAbcs=new ArrayList<>(pack.allABCs);
  otherAbcs.remove(this);
  ActionScriptParser.compile(as,this,otherAbcs,isDocumentClass,scriptName,newClassIndex);
  script_info.set(oldIndex,script_info.get(newIndex));
  script_info.remove(newIndex);
  script_info.get(oldIndex).setModified(true);
  pack();
  ((Tag)parentTag).setModified(true);
}",0.9214145383104124
61562,"public List<ScriptPack> getScriptPacks(String packagePrefix){
  List<ScriptPack> ret=new ArrayList<>();
  for (int i=0; i < script_info.size(); i++) {
    ret.addAll(script_info.get(i).getPacks(this,i,packagePrefix));
  }
  return ret;
}","public List<ScriptPack> getScriptPacks(String packagePrefix,List<ABC> allAbcs){
  List<ScriptPack> ret=new ArrayList<>();
  for (int i=0; i < script_info.size(); i++) {
    ret.addAll(script_info.get(i).getPacks(this,i,packagePrefix,allAbcs));
  }
  return ret;
}",0.948
61563,"public ScriptPack(ClassPath path,ABC abc,int scriptIndex,List<Integer> traitIndices){
  super(path.className,path);
  this.abc=abc;
  this.scriptIndex=scriptIndex;
  this.traitIndices=traitIndices;
  this.path=path;
}","public ScriptPack(ClassPath path,ABC abc,List<ABC> allAbcs,int scriptIndex,List<Integer> traitIndices){
  super(path.className,path);
  this.abc=abc;
  this.scriptIndex=scriptIndex;
  this.traitIndices=traitIndices;
  this.path=path;
  this.allABCs=allAbcs;
}",0.9117647058823528
61564,"public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,ABC abc,List<ABC> allABCs) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item.getClass().getName(),0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>(),true))) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>(),true))) {
      if (mname.getNamespace(abc.constants) != null && pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants,true))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.isEmpty() && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc).getName(abc.constants,new ArrayList<String>(),true).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    List<Integer> params=new ArrayList<>();
    for (    GraphTargetItem s : atype.params) {
      params.add(resolveType(localData,s,abc,allABCs));
    }
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}","public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,ABC abc,List<ABC> allABCs) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item + ""String_Node_Str""+ item.getClass().getName()+ ""String_Node_Str"",0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>(),true))) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>(),true))) {
      if (mname.getNamespace(abc.constants) != null && pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants,true))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.isEmpty() && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc).getName(abc.constants,new ArrayList<String>(),true).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    List<Integer> params=new ArrayList<>();
    for (    GraphTargetItem s : atype.params) {
      params.add(resolveType(localData,s,abc,allABCs));
    }
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}",0.9929917458339822
61565,"private GraphTargetItem expressionPrimary(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean allowMemberOrCall=false;
switch (s.type) {
case XML_STARTTAG_BEGIN:
    lexer.pushback(s);
  ret=xml(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
break;
case STRING:
ret=new StringAVM2Item(null,s.value.toString());
allowMemberOrCall=true;
break;
case NEGATE:
ret=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
ret=new NegAVM2Item(null,ret);
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new FloatValueAVM2Item(null,-(Double)s.value);
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new IntegerValueAVM2Item(null,-(Long)s.value);
}
 else {
lexer.pushback(s);
GraphTargetItem num=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (num instanceof IntegerValueAVM2Item) {
((IntegerValueAVM2Item)num).value=-((IntegerValueAVM2Item)num).value;
ret=num;
}
 else if (num instanceof FloatValueAVM2Item) {
Double d=((FloatValueAVM2Item)num).value;
if (d.isInfinite()) {
((FloatValueAVM2Item)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((FloatValueAVM2Item)num).value=-d;
}
ret=(num);
}
 else {
ret=(new SubtractAVM2Item(null,new IntegerValueAVM2Item(null,0L),num));
}
}
break;
case TYPEOF:
ret=new TypeOfAVM2Item(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case TRUE:
ret=new BooleanAVM2Item(null,true);
break;
case NULL:
ret=new NullAVM2Item(null);
break;
case UNDEFINED:
ret=new UndefinedAVM2Item(null);
break;
case FALSE:
ret=new BooleanAVM2Item(null,false);
break;
case CURLY_OPEN:
s=lex();
List<NameValuePair> nvs=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.STRING);
GraphTargetItem n=new StringAVM2Item(null,s.value.toString());
expectedType(SymbolType.COLON);
GraphTargetItem v=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,allowRemainder,variables);
NameValuePair nv=new NameValuePair(n,v);
nvs.add(nv);
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new NewObjectAVM2Item(null,nvs);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,inBrackets,registerVars,inFunction,inMethod,variables);
ret=new NewArrayAVM2Item(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,fname,false,variables);
allowMemberOrCall=true;
break;
case NAN:
ret=new NanAVM2Item(null);
break;
case INFINITY:
ret=new FloatValueAVM2Item(null,Double.POSITIVE_INFINITY);
break;
case INTEGER:
ret=new IntegerValueAVM2Item(null,(Long)s.value);
break;
case DOUBLE:
ret=new FloatValueAVM2Item(null,(Double)s.value);
break;
case DELETE:
GraphTargetItem varDel=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(varDel)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new DeletePropertyAVM2Item(varDel,lexer.yyline());
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
if (!isNameOrProp(varincdec)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementAVM2Item(null,varincdec);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementAVM2Item(null,varincdec);
}
break;
case NOT:
ret=new NotItem(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
s=lex();
if (s.type == SymbolType.XML_STARTTAG_BEGIN) {
lexer.yypushbackstr(s.value.toString().substring(1),ActionScriptLexer.YYINITIAL);
s=new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.LOWER_THAN);
}
if (s.type == SymbolType.FUNCTION) {
s=lexer.lex();
String ffname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
ffname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,ffname,false,variables);
}
 else if (s.type == SymbolType.LOWER_THAN) {
GraphTargetItem subtype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
expectedType(SymbolType.GREATER_THAN);
s=lex();
expected(s,lexer.yyline(),SymbolType.BRACKET_OPEN);
lexer.pushback(s);
List<GraphTargetItem> params=new ArrayList<>();
brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,params,registerVars,inFunction,inMethod,variables);
ret=new InitVectorAVM2Item(subtype,params,openedNamespaces);
}
 else if (s.type == SymbolType.PARENT_OPEN) {
GraphTargetItem newvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
 else {
lexer.pushback(s);
GraphTargetItem newvar=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case ATTRIBUTE:
lexer.pushback(s);
ret=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
allowMemberOrCall=true;
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}","private GraphTargetItem expressionPrimary(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean allowMemberOrCall=false;
switch (s.type) {
case XML_STARTTAG_BEGIN:
    lexer.pushback(s);
  ret=xml(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
break;
case STRING:
ret=new StringAVM2Item(null,s.value.toString());
allowMemberOrCall=true;
break;
case NEGATE:
ret=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
ret=new NegAVM2Item(null,ret);
break;
case MINUS:
s=lex();
if (s.isType(SymbolType.DOUBLE)) {
ret=new FloatValueAVM2Item(null,-(Double)s.value);
}
 else if (s.isType(SymbolType.INTEGER)) {
ret=new IntegerValueAVM2Item(null,-(Long)s.value);
}
 else {
lexer.pushback(s);
GraphTargetItem num=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (num instanceof IntegerValueAVM2Item) {
((IntegerValueAVM2Item)num).value=-((IntegerValueAVM2Item)num).value;
ret=num;
}
 else if (num instanceof FloatValueAVM2Item) {
Double d=((FloatValueAVM2Item)num).value;
if (d.isInfinite()) {
((FloatValueAVM2Item)num).value=Double.NEGATIVE_INFINITY;
}
 else {
((FloatValueAVM2Item)num).value=-d;
}
ret=(num);
}
 else {
ret=(new SubtractAVM2Item(null,new IntegerValueAVM2Item(null,0L),num));
}
}
break;
case TYPEOF:
ret=new TypeOfAVM2Item(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case TRUE:
ret=new BooleanAVM2Item(null,true);
break;
case NULL:
ret=new NullAVM2Item(null);
break;
case UNDEFINED:
ret=new UndefinedAVM2Item(null);
break;
case FALSE:
ret=new BooleanAVM2Item(null,false);
break;
case CURLY_OPEN:
s=lex();
List<NameValuePair> nvs=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER,SymbolType.STRING);
GraphTargetItem n=new StringAVM2Item(null,s.value.toString());
expectedType(SymbolType.COLON);
GraphTargetItem v=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,allowRemainder,variables);
NameValuePair nv=new NameValuePair(n,v);
nvs.add(nv);
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new NewObjectAVM2Item(null,nvs);
allowMemberOrCall=true;
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,inBrackets,registerVars,inFunction,inMethod,variables);
ret=new NewArrayAVM2Item(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,fname,false,variables);
allowMemberOrCall=true;
break;
case NAN:
ret=new NanAVM2Item(null);
break;
case INFINITY:
ret=new FloatValueAVM2Item(null,Double.POSITIVE_INFINITY);
break;
case INTEGER:
ret=new IntegerValueAVM2Item(null,(Long)s.value);
break;
case DOUBLE:
ret=new FloatValueAVM2Item(null,(Double)s.value);
break;
case DELETE:
GraphTargetItem varDel=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(varDel)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new DeletePropertyAVM2Item(varDel,lexer.yyline());
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables);
if (!isNameOrProp(varincdec)) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementAVM2Item(null,varincdec);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementAVM2Item(null,varincdec);
}
break;
case NOT:
ret=new NotItem(null,expressionPrimary(thisType,pkg,needsActivation,importedClasses,openedNamespaces,false,registerVars,inFunction,inMethod,false,variables));
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
allowMemberOrCall=true;
break;
case NEW:
s=lex();
if (s.type == SymbolType.XML_STARTTAG_BEGIN) {
lexer.yypushbackstr(s.value.toString().substring(1),ActionScriptLexer.YYINITIAL);
s=new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.LOWER_THAN);
}
if (s.type == SymbolType.FUNCTION) {
s=lexer.lex();
String ffname=""String_Node_Str"";
if (s.isType(SymbolGroup.IDENTIFIER)) {
ffname=s.value.toString();
}
 else {
lexer.pushback(s);
}
needsActivation.setVal(true);
ret=function(pkg,false,needsActivation,importedClasses,0,thisType,openedNamespaces,ffname,false,variables);
}
 else if (s.type == SymbolType.LOWER_THAN) {
GraphTargetItem subtype=type(thisType,pkg,needsActivation,importedClasses,openedNamespaces,variables);
expectedType(SymbolType.GREATER_THAN);
s=lex();
expected(s,lexer.yyline(),SymbolType.BRACKET_OPEN);
lexer.pushback(s);
List<GraphTargetItem> params=new ArrayList<>();
brackets(thisType,pkg,needsActivation,importedClasses,openedNamespaces,params,registerVars,inFunction,inMethod,variables);
ret=new InitVectorAVM2Item(subtype,params,openedNamespaces);
}
 else if (s.type == SymbolType.PARENT_OPEN) {
GraphTargetItem newvar=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
 else {
lexer.pushback(s);
GraphTargetItem newvar=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
newvar=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,newvar,registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
ret=new ConstructSomethingAVM2Item(lexer.yyline(),openedNamespaces,newvar,call(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables));
}
allowMemberOrCall=true;
break;
case IDENTIFIER:
case THIS:
case SUPER:
case ATTRIBUTE:
lexer.pushback(s);
ret=name(thisType,pkg,needsActivation,false,openedNamespaces,registerVars,inFunction,inMethod,variables,importedClasses);
allowMemberOrCall=true;
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
ret=excmd;
allowMemberOrCall=true;
break;
}
lexer.pushback(s);
}
if (allowMemberOrCall && ret != null) {
ret=memberOrCall(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}",0.9984781230183892
61566,"public List<ScriptPack> getPacks(ABC abc,int scriptIndex,String packagePrefix){
  List<ScriptPack> ret=new ArrayList<>();
  List<Integer> otherTraits=new ArrayList<>();
  for (int j=0; j < traits.traits.size(); j++) {
    Trait t=traits.traits.get(j);
    Multiname name=t.getName(abc);
    Namespace ns=name.getNamespace(abc.constants);
    if (!((ns.kind == Namespace.KIND_PACKAGE_INTERNAL) || (ns.kind == Namespace.KIND_PACKAGE))) {
      otherTraits.add(j);
    }
  }
  for (int j=0; j < traits.traits.size(); j++) {
    Trait t=traits.traits.get(j);
    Multiname name=t.getName(abc);
    Namespace ns=name.getNamespace(abc.constants);
    if ((ns.kind == Namespace.KIND_PACKAGE_INTERNAL) || (ns.kind == Namespace.KIND_PACKAGE)) {
      String packageName=ns.getName(abc.constants,false);
      String objectName=name.getName(abc.constants,null,false);
      List<Integer> traitIndices=new ArrayList<>();
      traitIndices.add(j);
      if (!otherTraits.isEmpty()) {
        traitIndices.addAll(otherTraits);
        otherTraits.clear();
      }
      if (packagePrefix == null || packageName.startsWith(packagePrefix)) {
        ClassPath cp=new ClassPath(packageName,objectName);
        ret.add(new ScriptPack(cp,abc,scriptIndex,traitIndices));
      }
    }
  }
  return ret;
}","public List<ScriptPack> getPacks(ABC abc,int scriptIndex,String packagePrefix,List<ABC> allAbcs){
  List<ScriptPack> ret=new ArrayList<>();
  List<Integer> otherTraits=new ArrayList<>();
  for (int j=0; j < traits.traits.size(); j++) {
    Trait t=traits.traits.get(j);
    Multiname name=t.getName(abc);
    Namespace ns=name.getNamespace(abc.constants);
    if (!((ns.kind == Namespace.KIND_PACKAGE_INTERNAL) || (ns.kind == Namespace.KIND_PACKAGE))) {
      otherTraits.add(j);
    }
  }
  for (int j=0; j < traits.traits.size(); j++) {
    Trait t=traits.traits.get(j);
    Multiname name=t.getName(abc);
    Namespace ns=name.getNamespace(abc.constants);
    if ((ns.kind == Namespace.KIND_PACKAGE_INTERNAL) || (ns.kind == Namespace.KIND_PACKAGE)) {
      String packageName=ns.getName(abc.constants,false);
      String objectName=name.getName(abc.constants,null,false);
      List<Integer> traitIndices=new ArrayList<>();
      traitIndices.add(j);
      if (!otherTraits.isEmpty()) {
        traitIndices.addAll(otherTraits);
        otherTraits.clear();
      }
      if (packagePrefix == null || packageName.startsWith(packagePrefix)) {
        ClassPath cp=new ClassPath(packageName,objectName);
        ret.add(new ScriptPack(cp,abc,allAbcs,scriptIndex,traitIndices));
      }
    }
  }
  return ret;
}",0.99
61567,"private static void loadProperties(){
  Properties prop=new Properties();
  try {
    prop.load(ApplicationInfo.class.getResourceAsStream(""String_Node_Str""));
    version=prop.getProperty(""String_Node_Str"");
    revision=prop.getProperty(""String_Node_Str"");
    version_major=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_minor=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_release=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_build=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    nightly=prop.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
    if (nightly) {
      version=version + ""String_Node_Str"" + version_build;
    }
  }
 catch (  IOException|NullPointerException|NumberFormatException ex) {
    version=""String_Node_Str"";
  }
  updateCheckUrl=updateCheckUrl.replace(""String_Node_Str"",revision).replace(""String_Node_Str"",version).replace(""String_Node_Str"",""String_Node_Str"" + version_major).replace(""String_Node_Str"",""String_Node_Str"" + version_minor).replace(""String_Node_Str"",""String_Node_Str"" + version_release).replace(""String_Node_Str"",""String_Node_Str"" + version_build).replace(""String_Node_Str"",nightly ? ""String_Node_Str"" : ""String_Node_Str"");
  updateUrl=updateUrl.replace(""String_Node_Str"",revision).replace(""String_Node_Str"",version).replace(""String_Node_Str"",""String_Node_Str"" + version_major).replace(""String_Node_Str"",""String_Node_Str"" + version_minor).replace(""String_Node_Str"",""String_Node_Str"" + version_release).replace(""String_Node_Str"",""String_Node_Str"" + version_build).replace(""String_Node_Str"",nightly ? ""String_Node_Str"" : ""String_Node_Str"");
  applicationVerName=APPLICATION_NAME + ""String_Node_Str"" + version;
  shortApplicationVerName=SHORT_APPLICATION_NAME + ""String_Node_Str"" + version;
}","private static void loadProperties(){
  Properties prop=new Properties();
  try {
    prop.load(ApplicationInfo.class.getResourceAsStream(""String_Node_Str""));
    version=prop.getProperty(""String_Node_Str"");
    revision=prop.getProperty(""String_Node_Str"");
    version_major=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_minor=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_release=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    version_build=Integer.parseInt(prop.getProperty(""String_Node_Str""));
    nightly=prop.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
    if (nightly) {
      version=version + ""String_Node_Str"" + version_build;
    }
  }
 catch (  IOException|NullPointerException|NumberFormatException ex) {
    version=""String_Node_Str"";
  }
  try {
    updateCheckUrl=updateCheckUrl.replace(""String_Node_Str"",URLEncoder.encode(revision,""String_Node_Str"")).replace(""String_Node_Str"",URLEncoder.encode(version,""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"" + version_major).replace(""String_Node_Str"",""String_Node_Str"" + version_minor).replace(""String_Node_Str"",""String_Node_Str"" + version_release).replace(""String_Node_Str"",""String_Node_Str"" + version_build).replace(""String_Node_Str"",nightly ? ""String_Node_Str"" : ""String_Node_Str"");
    updateUrl=updateUrl.replace(""String_Node_Str"",URLEncoder.encode(revision,""String_Node_Str"")).replace(""String_Node_Str"",URLEncoder.encode(version,""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"" + version_major).replace(""String_Node_Str"",""String_Node_Str"" + version_minor).replace(""String_Node_Str"",""String_Node_Str"" + version_release).replace(""String_Node_Str"",""String_Node_Str"" + version_build).replace(""String_Node_Str"",nightly ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
  }
  applicationVerName=APPLICATION_NAME + ""String_Node_Str"" + version;
  shortApplicationVerName=SHORT_APPLICATION_NAME + ""String_Node_Str"" + version;
}",0.900886802295253
61568,"public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  Map<Long,Long> endOffsets=new HashMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  long startPos=ais.getPosition();
  addresses.add(startPos);
  while (!addresses.isEmpty()) {
    long address=addresses.remove(0);
    if (codeMap.containsKey(address)) {
      continue;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == 0x1b) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            actualOperands=new int[case_count + 3];
            actualOperands[0]=firstOperand;
            actualOperands[1]=case_count;
            for (int c=0; c < case_count + 1; c++) {
              actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
if (instr instanceof IfTypeIns) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
codeMap.put(startOffset,new AVM2Instruction(startOffset,instr,actualOperands));
ais.endDumpLevel(instr.instructionCode);
long endOffset=ais.getPosition();
endOffsets.put(startOffset,endOffset);
if (instr.isExitInstruction()) {
break;
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
List<Long> starts=new ArrayList<>(new TreeSet<>(codeMap.keySet()));
for (int s=0; s < starts.size() - 1; s++) {
long curEnd=endOffsets.get(starts.get(s));
if (!codeMap.containsKey(curEnd)) {
long nextStart=starts.get(s + 1);
for (long off=curEnd; off < nextStart; off++) {
codeMap.put(off,new AVM2Instruction(off,new NopIns(),new int[]{}));
}
}
}
code.addAll(codeMap.values());
}","public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  Map<Long,Long> endOffsets=new HashMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  long startPos=ais.getPosition();
  addresses.add(startPos);
  while (!addresses.isEmpty()) {
    long address=addresses.remove(0);
    boolean afterExit=false;
    if (codeMap.containsKey(address)) {
      continue;
    }
    if (address < startPos) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSet[instructionCode];
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == 0x1b) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            actualOperands=new int[case_count + 3];
            actualOperands[0]=firstOperand;
            actualOperands[1]=case_count;
            for (int c=0; c < case_count + 1; c++) {
              actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
if (!afterExit && (instr instanceof IfTypeIns)) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
codeMap.put(startOffset,new AVM2Instruction(startOffset,instr,actualOperands));
ais.endDumpLevel(instr.instructionCode);
long endOffset=ais.getPosition();
endOffsets.put(startOffset,endOffset);
if (instr.isExitInstruction()) {
afterExit=true;
}
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
code.addAll(codeMap.values());
}",0.9154377450065336
61569,"private static void initPlayer() throws IOException, InterruptedException {
  if (playerABCs.isEmpty()) {
    if (Configuration.getPlayerSWC() == null) {
      throw new IOException(""String_Node_Str"" + Configuration.getPlayerSWC());
    }
    SWC swc=new SWC(new FileInputStream(Configuration.getPlayerSWC()));
    SWF swf=new SWF(swc.getSWF(""String_Node_Str""),true);
    for (    Tag t : swf.tags) {
      if (t instanceof ABCContainerTag) {
        playerABCs.add(((ABCContainerTag)t).getABC());
      }
    }
  }
}","private static void initPlayer() throws IOException, InterruptedException {
  if (playerABCs.isEmpty()) {
    if (Configuration.getPlayerSWC() == null) {
      throw new IOException(""String_Node_Str"" + Configuration.getFlashLibPath());
    }
    SWC swc=new SWC(new FileInputStream(Configuration.getPlayerSWC()));
    SWF swf=new SWF(swc.getSWF(""String_Node_Str""),true);
    for (    Tag t : swf.tags) {
      if (t instanceof ABCContainerTag) {
        playerABCs.add(((ABCContainerTag)t).getABC());
      }
    }
  }
}",0.9816779170684669
61570,"@Test(dataProvider=""String_Node_Str"") public void testDirectEditing(String filePath) throws IOException, InterruptedException, AVM2ParseException, CompilationException {
  File playerSWC=Configuration.getPlayerSWC();
  if (playerSWC == null) {
    throw new IOException(""String_Node_Str"" + Configuration.getPlayerSWC());
  }
  try {
    SWF swf=new SWF(new BufferedInputStream(new FileInputStream(filePath)),false);
    if (swf.isAS3()) {
      boolean dotest=false;
      List<ABC> allAbcs=new ArrayList<>();
      for (      ABCContainerTag ct : swf.getAbcList()) {
        allAbcs.add(ct.getABC());
      }
      for (      ABC abc : allAbcs) {
        for (int s=0; s < abc.script_info.size(); s++) {
          String startAfter=null;
          HighlightedTextWriter htw=new HighlightedTextWriter(new CodeFormatting(),false);
          ScriptPack en=abc.script_info.get(s).getPacks(abc,s,null).get(0);
          String classPathString=en.getClassPath().toString();
          if (startAfter == null || classPathString.equals(startAfter)) {
            dotest=true;
          }
          if (!dotest) {
            System.out.println(""String_Node_Str"" + classPathString);
            continue;
          }
          System.out.println(""String_Node_Str"" + classPathString + ""String_Node_Str"");
          en.toSource(htw,abc.script_info.get(s).traits.traits,ScriptExportMode.AS,false);
          String original=htw.toString();
          com.jpexs.decompiler.flash.abc.avm2.parser.script.ActionScriptParser.compile(original,abc,allAbcs,false,en.getClassPath().className + ""String_Node_Str"",abc.instance_info.size());
          abc.script_info.remove(abc.script_info.size() - 1);
        }
      }
    }
 else {
      Map<String,ASMSource> asms=swf.getASMs(false);
      for (      ASMSource asm : asms.values()) {
        try {
          HighlightedTextWriter writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as=writer.toString();
          as=asm.removePrefixAndSuffix(as);
          ActionScriptParser par=new ActionScriptParser(swf.version);
          try {
            asm.setActions(par.actionsFromString(as));
          }
 catch (          ActionParseException|CompilationException ex) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
          writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as2=writer.toString();
          as2=asm.removePrefixAndSuffix(as2);
          try {
            asm.setActions(par.actionsFromString(as2));
          }
 catch (          ActionParseException|CompilationException ex) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
          writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as3=writer.toString();
          as3=asm.removePrefixAndSuffix(as3);
          if (!as3.equals(as2)) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
        }
 catch (        InterruptedException|IOException|OutOfMemoryError|TranslateException|StackOverflowError ex) {
        }
      }
    }
  }
 catch (  Exception ex) {
    fail(""String_Node_Str"" + filePath,ex);
  }
}","@Test(dataProvider=""String_Node_Str"") public void testDirectEditing(String filePath) throws IOException, InterruptedException, AVM2ParseException, CompilationException {
  File playerSWC=Configuration.getPlayerSWC();
  if (playerSWC == null) {
    throw new IOException(""String_Node_Str"" + Configuration.getFlashLibPath());
  }
  try {
    SWF swf=new SWF(new BufferedInputStream(new FileInputStream(filePath)),false);
    if (swf.isAS3()) {
      boolean dotest=false;
      List<ABC> allAbcs=new ArrayList<>();
      for (      ABCContainerTag ct : swf.getAbcList()) {
        allAbcs.add(ct.getABC());
      }
      for (      ABC abc : allAbcs) {
        for (int s=0; s < abc.script_info.size(); s++) {
          String startAfter=null;
          HighlightedTextWriter htw=new HighlightedTextWriter(new CodeFormatting(),false);
          ScriptPack en=abc.script_info.get(s).getPacks(abc,s,null).get(0);
          String classPathString=en.getClassPath().toString();
          if (startAfter == null || classPathString.equals(startAfter)) {
            dotest=true;
          }
          if (!dotest) {
            System.out.println(""String_Node_Str"" + classPathString);
            continue;
          }
          System.out.println(""String_Node_Str"" + classPathString + ""String_Node_Str"");
          en.toSource(htw,abc.script_info.get(s).traits.traits,ScriptExportMode.AS,false);
          String original=htw.toString();
          com.jpexs.decompiler.flash.abc.avm2.parser.script.ActionScriptParser.compile(original,abc,allAbcs,false,en.getClassPath().className + ""String_Node_Str"",abc.instance_info.size());
          abc.script_info.remove(abc.script_info.size() - 1);
        }
      }
    }
 else {
      Map<String,ASMSource> asms=swf.getASMs(false);
      for (      ASMSource asm : asms.values()) {
        try {
          HighlightedTextWriter writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as=writer.toString();
          as=asm.removePrefixAndSuffix(as);
          ActionScriptParser par=new ActionScriptParser(swf.version);
          try {
            asm.setActions(par.actionsFromString(as));
          }
 catch (          ActionParseException|CompilationException ex) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
          writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as2=writer.toString();
          as2=asm.removePrefixAndSuffix(as2);
          try {
            asm.setActions(par.actionsFromString(as2));
          }
 catch (          ActionParseException|CompilationException ex) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
          writer=new HighlightedTextWriter(new CodeFormatting(),false);
          Action.actionsToSource(asm,asm.getActions(),asm.toString(),writer);
          String as3=writer.toString();
          as3=asm.removePrefixAndSuffix(as3);
          if (!as3.equals(as2)) {
            fail(""String_Node_Str"" + asm.getSwf().getShortFileName() + ""String_Node_Str""+ asm.toString());
          }
        }
 catch (        InterruptedException|IOException|OutOfMemoryError|TranslateException|StackOverflowError ex) {
        }
      }
    }
  }
 catch (  Exception ex) {
    fail(""String_Node_Str"" + filePath,ex);
  }
}",0.9973152465734068
61571,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  Set<String> usedNames=new HashSet<>();
  for (  VariableActionItem v : variables) {
    usedNames.add(v.getVariableName());
  }
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<Integer> paramRegs=new ArrayList<>();
  SourceGeneratorLocalData localDataCopy=Helper.deepCopy(localData);
  localDataCopy.inFunction++;
  boolean preloadParentFlag=false;
  boolean preloadRootFlag=false;
  boolean preloadSuperFlag=false;
  boolean preloadArgumentsFlag=false;
  boolean preloadThisFlag=false;
  boolean preloadGlobalFlag=false;
  boolean suppressParentFlag=false;
  boolean suppressArgumentsFlag=false;
  boolean suppressThisFlag=false;
  boolean needsFun2=false;
  List<String> registerNames=new ArrayList<>();
  registerNames.add(""String_Node_Str"");
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadThisFlag=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressThisFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadArgumentsFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressArgumentsFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadSuperFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadRootFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadParentFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressParentFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadGlobalFlag=true;
    registerNames.add(""String_Node_Str"");
  }
  int preloadedNumber=registerNames.size();
  if (!paramNames.isEmpty()) {
    needsFun2=true;
  }
  if (localData.inMethod) {
    needsFun2=true;
  }
  if (localData.inFunction > 1) {
    needsFun2=true;
  }
  if (needsFun2) {
    for (int i=0; i < paramNames.size(); i++) {
      paramRegs.add(registerNames.size());
      registerNames.add(paramNames.get(i));
    }
  }
  if (actions != null && !actions.isEmpty()) {
    localDataCopy.inFunction++;
    for (    VariableActionItem v : variables) {
      String varName=v.getVariableName();
      GraphTargetItem stored=v.getStoreValue();
      if (needsFun2) {
        if (v.isDefinition() && !registerNames.contains(varName)) {
          registerNames.add(varName);
        }
      }
      if (registerNames.contains(varName)) {
        if (stored != null) {
          v.setBoxedValue(new StoreRegisterActionItem(null,new RegisterNumber(registerNames.indexOf(varName),varName),stored,false));
        }
 else {
          v.setBoxedValue(new DirectValueActionItem(new RegisterNumber(registerNames.indexOf(varName),varName)));
        }
      }
 else {
        if (v.isDefinition()) {
          v.setBoxedValue(new DefineLocalActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
        }
 else {
          if (stored != null) {
            v.setBoxedValue(new SetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
          }
 else {
            v.setBoxedValue(new GetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName)));
          }
        }
      }
    }
    ret.addAll(asGenerator.toActionList(asGenerator.generate(localDataCopy,actions)));
  }
  int len=Action.actionsToBytes(asGenerator.toActionList(ret),false,SWF.DEFAULT_VERSION).length;
  if (!needsFun2 && paramNames.isEmpty()) {
    ret.add(0,new ActionDefineFunction(functionName,paramNames,len,SWF.DEFAULT_VERSION));
  }
 else {
    ret.add(0,new ActionDefineFunction2(functionName,preloadParentFlag,preloadRootFlag,suppressParentFlag,preloadSuperFlag,suppressArgumentsFlag,preloadArgumentsFlag,suppressThisFlag,preloadThisFlag,preloadGlobalFlag,registerNames.size(),len,SWF.DEFAULT_VERSION,paramNames,paramRegs));
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  Set<String> usedNames=new HashSet<>();
  for (  VariableActionItem v : variables) {
    usedNames.add(v.getVariableName());
  }
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<Integer> paramRegs=new ArrayList<>();
  SourceGeneratorLocalData localDataCopy=Helper.deepCopy(localData);
  localDataCopy.inFunction++;
  boolean preloadParentFlag=false;
  boolean preloadRootFlag=false;
  boolean preloadSuperFlag=false;
  boolean preloadArgumentsFlag=false;
  boolean preloadThisFlag=false;
  boolean preloadGlobalFlag=false;
  boolean suppressParentFlag=false;
  boolean suppressArgumentsFlag=false;
  boolean suppressThisFlag=false;
  boolean needsFun2=false;
  List<String> registerNames=new ArrayList<>();
  registerNames.add(""String_Node_Str"");
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadThisFlag=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressThisFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadArgumentsFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressArgumentsFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadSuperFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadRootFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadParentFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressParentFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadGlobalFlag=true;
    registerNames.add(""String_Node_Str"");
  }
  int preloadedNumber=registerNames.size();
  if (!paramNames.isEmpty()) {
    needsFun2=true;
  }
  if (localData.inMethod) {
    needsFun2=true;
  }
  if (localData.inFunction > 1) {
    needsFun2=true;
  }
  if (needsFun2) {
    for (int i=0; i < paramNames.size(); i++) {
      paramRegs.add(registerNames.size());
      registerNames.add(paramNames.get(i));
    }
  }
  int regCount=0;
  if (actions != null && !actions.isEmpty()) {
    localDataCopy.inFunction++;
    for (    VariableActionItem v : variables) {
      String varName=v.getVariableName();
      GraphTargetItem stored=v.getStoreValue();
      if (needsFun2) {
        if (v.isDefinition() && !registerNames.contains(varName)) {
          registerNames.add(varName);
        }
      }
      if (registerNames.contains(varName)) {
        if (stored != null) {
          v.setBoxedValue(new StoreRegisterActionItem(null,new RegisterNumber(registerNames.indexOf(varName),varName),stored,false));
        }
 else {
          v.setBoxedValue(new DirectValueActionItem(new RegisterNumber(registerNames.indexOf(varName),varName)));
        }
      }
 else {
        if (v.isDefinition()) {
          v.setBoxedValue(new DefineLocalActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
        }
 else {
          if (stored != null) {
            v.setBoxedValue(new SetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
          }
 else {
            v.setBoxedValue(new GetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName)));
          }
        }
      }
    }
    for (int i=1; i < registerNames.size(); i++) {
      localDataCopy.registerVars.put(registerNames.get(i),i);
    }
    ret.addAll(asGenerator.toActionList(asGenerator.generate(localDataCopy,actions)));
    regCount=registerNames.size();
    for (    GraphSourceItem a : ret) {
      if (a instanceof ActionPush) {
        ActionPush apu=(ActionPush)a;
        for (        Object o : apu.values) {
          if (o instanceof RegisterNumber) {
            RegisterNumber rn=(RegisterNumber)o;
            if (rn.number >= regCount) {
              regCount++;
            }
          }
        }
      }
    }
  }
  int len=Action.actionsToBytes(asGenerator.toActionList(ret),false,SWF.DEFAULT_VERSION).length;
  if (!needsFun2 && paramNames.isEmpty()) {
    ret.add(0,new ActionDefineFunction(functionName,paramNames,len,SWF.DEFAULT_VERSION));
  }
 else {
    ret.add(0,new ActionDefineFunction2(functionName,preloadParentFlag,preloadRootFlag,suppressParentFlag,preloadSuperFlag,suppressArgumentsFlag,preloadArgumentsFlag,suppressThisFlag,preloadThisFlag,preloadGlobalFlag,regCount,len,SWF.DEFAULT_VERSION,paramNames,paramRegs));
  }
  return ret;
}",0.9366748713358694
61572,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  return toSourceMerge(localData,generator,object,objectName,value,new ActionStoreRegister(tmpReg),new ActionSetMember(),new ActionPush(new RegisterNumber(tmpReg)));
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  try {
    return toSourceMerge(localData,generator,object,objectName,value,new ActionStoreRegister(tmpReg),new ActionSetMember(),new ActionPush(new RegisterNumber(tmpReg)));
  }
  finally {
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
}",0.91005291005291
61573,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  return toSourceMerge(localData,generator,target,new ActionPush((Long)(long)propertyIndex),value,new ActionStoreRegister(tmpReg),new ActionSetProperty(),new ActionPush(new RegisterNumber(tmpReg)));
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  try {
    return toSourceMerge(localData,generator,target,new ActionPush((Long)(long)propertyIndex),value,new ActionStoreRegister(tmpReg),new ActionSetProperty(),new ActionPush(new RegisterNumber(tmpReg)));
  }
  finally {
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
}",0.9159248269040554
61574,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  return toSourceMerge(localData,generator,name,value,new ActionStoreRegister(tmpReg),new ActionSetVariable(),new ActionPush(new RegisterNumber(tmpReg)));
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  int tmpReg=asGenerator.getTempRegister(localData);
  try {
    return toSourceMerge(localData,generator,name,value,new ActionStoreRegister(tmpReg),new ActionSetVariable(),new ActionPush(new RegisterNumber(tmpReg)));
  }
  finally {
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
}",0.9079089924160346
61575,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  HashMap<String,Integer> registerVars=asGenerator.getRegisterVars(localData);
  ret.addAll(enumVariable.toSource(localData,generator));
  ret.add(new ActionEnumerate2());
  List<Action> loopExpr=new ArrayList<>();
  int exprReg=0;
  for (int i=0; i < 256; i++) {
    if (!registerVars.containsValue(i)) {
      registerVars.put(""String_Node_Str"" + asGenerator.uniqId(),i);
      exprReg=i;
      break;
    }
  }
  int innerExprReg=asGenerator.getTempRegister(localData);
  loopExpr.add(new ActionStoreRegister(exprReg));
  loopExpr.add(new ActionPush(new Null()));
  loopExpr.add(new ActionEquals2());
  ActionIf forInEndIf=new ActionIf(0);
  loopExpr.add(forInEndIf);
  List<Action> loopBody=new ArrayList<>();
  loopBody.add(new ActionPush(new RegisterNumber(exprReg)));
  if (asGenerator.isInFunction(localData) == 2) {
    loopBody.add(new ActionStoreRegister(innerExprReg));
    loopBody.add(new ActionPop());
  }
 else {
    loopBody.addAll(0,asGenerator.toActionList(variableName.toSource(localData,generator)));
    loopBody.add(new ActionSetVariable());
  }
  int oldForIn=asGenerator.getForInLevel(localData);
  asGenerator.setForInLevel(localData,oldForIn + 1);
  loopBody.addAll(asGenerator.toActionList(asGenerator.generate(localData,commands)));
  asGenerator.setForInLevel(localData,oldForIn);
  ActionJump forinJmpBack=new ActionJump(0);
  loopBody.add(forinJmpBack);
  int bodyLen=Action.actionsToBytes(loopBody,false,SWF.DEFAULT_VERSION).length;
  int exprLen=Action.actionsToBytes(loopExpr,false,SWF.DEFAULT_VERSION).length;
  forinJmpBack.setJumpOffset(-bodyLen - exprLen);
  forInEndIf.setJumpOffset(bodyLen);
  ret.addAll(loopExpr);
  ret.addAll(loopBody);
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  HashMap<String,Integer> registerVars=asGenerator.getRegisterVars(localData);
  ret.addAll(enumVariable.toSource(localData,generator));
  ret.add(new ActionEnumerate2());
  List<Action> loopExpr=new ArrayList<>();
  int exprReg=asGenerator.getTempRegister(localData);
  loopExpr.add(new ActionStoreRegister(exprReg));
  loopExpr.add(new ActionPush(new Null()));
  loopExpr.add(new ActionEquals2());
  ActionIf forInEndIf=new ActionIf(0);
  loopExpr.add(forInEndIf);
  List<Action> loopBody=new ArrayList<>();
  loopBody.add(new ActionPush(new RegisterNumber(exprReg)));
  loopBody.addAll(asGenerator.toActionList(variableName.toSourceIgnoreReturnValue(localData,generator)));
  int oldForIn=asGenerator.getForInLevel(localData);
  asGenerator.setForInLevel(localData,oldForIn + 1);
  loopBody.addAll(asGenerator.toActionList(asGenerator.generate(localData,commands)));
  asGenerator.setForInLevel(localData,oldForIn);
  ActionJump forinJmpBack=new ActionJump(0);
  loopBody.add(forinJmpBack);
  int bodyLen=Action.actionsToBytes(loopBody,false,SWF.DEFAULT_VERSION).length;
  int exprLen=Action.actionsToBytes(loopExpr,false,SWF.DEFAULT_VERSION).length;
  forinJmpBack.setJumpOffset(-bodyLen - exprLen);
  forInEndIf.setJumpOffset(bodyLen);
  ret.addAll(loopExpr);
  ret.addAll(loopBody);
  asGenerator.releaseTempRegister(localData,exprReg);
  return ret;
}",0.7628923766816144
61576,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9738965353583294
61577,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
    asGenerator.releaseTempRegister(localData,tmpReg);
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9738965353583294
61578,"@Override public int getPreferredWidth(int i,int i1){
  return 105;
}","@Override public int getPreferredWidth(int i,int i1){
  return width;
}",0.9428571428571428
61579,"private List<RibbonBandResizePolicy> getIconBandResizePolicies(JRibbonBand ribbonBand){
  List<RibbonBandResizePolicy> resizePolicies=new ArrayList<>();
  resizePolicies.add(new BaseRibbonBandResizePolicy<AbstractBandControlPanel>(ribbonBand.getControlPanel()){
    @Override public int getPreferredWidth(    int i,    int i1){
      return 105;
    }
    @Override public void install(    int i,    int i1){
    }
  }
);
  resizePolicies.add(new IconRibbonBandResizePolicy(ribbonBand.getControlPanel()));
  return resizePolicies;
}","private List<RibbonBandResizePolicy> getIconBandResizePolicies(JRibbonBand ribbonBand){
  List<RibbonBandResizePolicy> resizePolicies=new ArrayList<>();
  IconRibbonBandResizePolicy iconBandResizePolicy=new IconRibbonBandResizePolicy(ribbonBand.getControlPanel());
  final int width=Math.max(105,iconBandResizePolicy.getPreferredWidth(0,0));
  resizePolicies.add(new BaseRibbonBandResizePolicy<AbstractBandControlPanel>(ribbonBand.getControlPanel()){
    @Override public int getPreferredWidth(    int i,    int i1){
      return width;
    }
    @Override public void install(    int i,    int i1){
    }
  }
);
  resizePolicies.add(iconBandResizePolicy);
  return resizePolicies;
}",0.7720164609053498
61580,"@Override protected List<GraphTargetItem> check(GraphSource code,BaseLocalData localData,List<GraphPart> allParts,TranslateStack stack,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> output,Loop currentLoop,int staticOperation,String path) throws InterruptedException {
  List<GraphTargetItem> ret=null;
  AVM2LocalData aLocalData=(AVM2LocalData)localData;
  List<ABCException> parsedExceptions=aLocalData.parsedExceptions;
  List<Integer> finallyJumps=aLocalData.finallyJumps;
  List<Integer> ignoredSwitches=aLocalData.ignoredSwitches;
  int ip=part.start;
  int addr=this.avm2code.fixAddrAfterDebugLine(this.avm2code.pos2adr(part.start));
  int maxend=-1;
  List<ABCException> catchedExceptions=new ArrayList<>();
  for (int e=0; e < body.exceptions.length; e++) {
    if (addr == this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].start)) {
      if (!body.exceptions[e].isFinally()) {
        if (((body.exceptions[e].end) > maxend) && (!parsedExceptions.contains(body.exceptions[e]))) {
          catchedExceptions.clear();
          maxend=this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end);
          catchedExceptions.add(body.exceptions[e]);
        }
 else         if (this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end) == maxend) {
          catchedExceptions.add(body.exceptions[e]);
        }
      }
    }
  }
  if (catchedExceptions.size() > 0) {
    parsedExceptions.addAll(catchedExceptions);
    int endpos=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(catchedExceptions.get(0).end));
    int endposStartBlock=code.adr2pos(catchedExceptions.get(0).end);
    List<List<GraphTargetItem>> catchedCommands=new ArrayList<>();
    if (this.avm2code.code.get(endpos).definition instanceof JumpIns) {
      int afterCatchAddr=this.avm2code.pos2adr(endpos + 1) + this.avm2code.code.get(endpos).operands[0];
      int afterCatchPos=this.avm2code.adr2pos(afterCatchAddr);
      final AVM2Graph t=this;
      Collections.sort(catchedExceptions,new Comparator<ABCException>(){
        @Override public int compare(        ABCException o1,        ABCException o2){
          return t.avm2code.fixAddrAfterDebugLine(o1.target) - t.avm2code.fixAddrAfterDebugLine(o2.target);
        }
      }
);
      List<GraphTargetItem> finallyCommands=new ArrayList<>();
      int returnPos=afterCatchPos;
      for (int e=0; e < body.exceptions.length; e++) {
        if (body.exceptions[e].isFinally()) {
          if (addr == this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].start)) {
            if (afterCatchPos + 1 == code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end))) {
              AVM2Instruction jmpIns=this.avm2code.code.get(code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end)));
              if (jmpIns.definition instanceof JumpIns) {
                int finStart=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end) + jmpIns.getBytes().length + jmpIns.operands[0]);
                GraphPart fpart=null;
                for (                GraphPart p : allParts) {
                  if (p.start == finStart) {
                    fpart=p;
                    break;
                  }
                }
                int swPos=-1;
                for (int f=finStart; f < this.avm2code.code.size(); f++) {
                  if (this.avm2code.code.get(f).definition instanceof LookupSwitchIns) {
                    AVM2Instruction swins=this.avm2code.code.get(f);
                    if (swins.operands.length >= 3) {
                      if (swins.operands[0] == swins.getBytes().length) {
                        if (code.adr2pos(code.pos2adr(f) + swins.operands[2]) < finStart) {
                          stack.push(new ExceptionAVM2Item(body.exceptions[e]));
                          GraphPart fepart=null;
                          for (                          GraphPart p : allParts) {
                            if (p.start == f + 1) {
                              fepart=p;
                              break;
                            }
                          }
                          swPos=f;
                          List<GraphPart> stopPart2=new ArrayList<>(stopPart);
                          stopPart2.add(fepart);
                          returnPos=f + 1;
                          break;
                        }
                      }
                    }
                  }
                }
                List<Integer> oldFinallyJumps=new ArrayList<>(finallyJumps);
                finallyJumps.clear();
                ignoredSwitches.add(swPos);
                finallyCommands=printGraph(localData,stack,allParts,parent,fpart,null,loops,staticOperation,path);
                finallyJumps.addAll(oldFinallyJumps);
                finallyJumps.add(finStart);
                break;
              }
            }
          }
        }
      }
      GraphPart retPart=null;
      for (      GraphPart p : allParts) {
        if (p.start == returnPos) {
          retPart=p;
          break;
        }
      }
      List<GraphPart> catchParts=new ArrayList<>();
      for (int e=0; e < catchedExceptions.size(); e++) {
        int eendpos;
        if (e < catchedExceptions.size() - 1) {
          eendpos=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(catchedExceptions.get(e + 1).target)) - 2;
        }
 else {
          eendpos=afterCatchPos - 1;
        }
        GraphPart npart=null;
        int findpos=code.adr2pos(catchedExceptions.get(e).target);
        for (        GraphPart p : allParts) {
          if (p.start == findpos) {
            npart=p;
            catchParts.add(p);
            break;
          }
        }
        GraphPart nepart=null;
        for (        GraphPart p : allParts) {
          if (p.start == eendpos + 1) {
            nepart=p;
            break;
          }
        }
        stack.add(new ExceptionAVM2Item(catchedExceptions.get(e)));
        AVM2LocalData localData2=new AVM2LocalData(aLocalData);
        localData2.scopeStack=new ScopeStack();
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(nepart);
        if (retPart != null) {
          stopPart2.add(retPart);
        }
        catchedCommands.add(printGraph(localData2,stack,allParts,parent,npart,stopPart2,loops,staticOperation,path));
      }
      GraphPart nepart=null;
      for (      GraphPart p : allParts) {
        if (p.start == endposStartBlock) {
          nepart=p;
          break;
        }
      }
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      stopPart2.add(nepart);
      stopPart2.addAll(catchParts);
      if (retPart != null) {
        stopPart2.add(retPart);
      }
      List<GraphTargetItem> tryCommands=printGraph(localData,stack,allParts,parent,part,stopPart2,loops,staticOperation,path);
      output.clear();
      output.add(new TryAVM2Item(tryCommands,catchedExceptions,catchedCommands,finallyCommands));
      ip=returnPos;
    }
  }
  if (ip != part.start) {
    part=null;
    for (    GraphPart p : allParts) {
      List<GraphPart> ps=p.getSubParts();
      for (      GraphPart p2 : ps) {
        if (p2.start == ip) {
          part=p2;
          break;
        }
      }
    }
    ret=new ArrayList<>();
    ret.addAll(output);
    GraphTargetItem lop=checkLoop(part,stopPart,loops);
    if (lop == null) {
      ret.addAll(printGraph(localData,stack,allParts,null,part,stopPart,loops,staticOperation,path));
    }
 else {
      ret.add(lop);
    }
    return ret;
  }
  if (part.nextParts.isEmpty()) {
    if (this.avm2code.code.get(part.end).definition instanceof ReturnValueIns) {
      if (part.getHeight() >= 3) {
        if (this.avm2code.code.get(part.getPosAt(part.getHeight() - 2)).definition instanceof KillIns) {
          if (this.avm2code.code.get(part.getPosAt(part.getHeight() - 3)).definition instanceof GetLocalTypeIns) {
            if (output.size() >= 2) {
              if (output.get(output.size() - 2) instanceof SetLocalAVM2Item) {
                ret=new ArrayList<>();
                ret.addAll(output);
                ret.remove(ret.size() - 1);
                ret.add(new ReturnValueAVM2Item(this.avm2code.code.get(part.end),((SetLocalAVM2Item)output.get(output.size() - 2)).value));
                return ret;
              }
            }
          }
        }
      }
    }
  }
  if ((this.avm2code.code.get(part.end).definition instanceof LookupSwitchIns) && ignoredSwitches.contains(part.end)) {
    ret=new ArrayList<>();
    ret.addAll(output);
    return ret;
  }
  if (((part.nextParts.size() == 2) && (!stack.isEmpty()) && (stack.peek() instanceof StrictEqAVM2Item)&& (part.nextParts.get(0).getHeight() >= 2)&& (this.avm2code.code.get(this.avm2code.fixIPAfterDebugLine(part.nextParts.get(0).start)).definition instanceof PushIntegerTypeIns)&& (!part.nextParts.get(0).nextParts.isEmpty())&& (this.avm2code.code.get(part.nextParts.get(0).nextParts.get(0).end).definition instanceof LookupSwitchIns)) || ((part.nextParts.size() == 2) && (!stack.isEmpty()) && (stack.peek() instanceof StrictNeqAVM2Item)&& (part.nextParts.get(1).getHeight() >= 2)&& (this.avm2code.code.get(this.avm2code.fixIPAfterDebugLine(part.nextParts.get(1).start)).definition instanceof PushIntegerTypeIns)&& (!part.nextParts.get(1).nextParts.isEmpty())&& (this.avm2code.code.get(part.nextParts.get(1).nextParts.get(0).end).definition instanceof LookupSwitchIns))) {
    if (stack.peek() instanceof StrictEqAVM2Item) {
      ignoredSwitches.add(part.nextParts.get(0).nextParts.get(0).end);
    }
 else {
      ignoredSwitches.add(part.nextParts.get(1).nextParts.get(0).end);
    }
    ret=new ArrayList<>();
    ret.addAll(output);
    boolean reversed=false;
    if (stack.peek() instanceof StrictEqAVM2Item) {
      reversed=true;
    }
    GraphTargetItem switchedObject=null;
    if (!output.isEmpty()) {
      if (output.get(output.size() - 1) instanceof SetLocalAVM2Item) {
        switchedObject=((SetLocalAVM2Item)output.get(output.size() - 1)).value;
      }
    }
    if (switchedObject == null) {
      switchedObject=new NullAVM2Item(null);
    }
    HashMap<Integer,GraphTargetItem> caseValuesMap=new HashMap<>();
    GraphTargetItem tar=stack.pop();
    if (tar instanceof StrictEqAVM2Item) {
      tar=((StrictEqAVM2Item)tar).leftSide;
    }
    if (tar instanceof StrictNeqAVM2Item) {
      tar=((StrictNeqAVM2Item)tar).leftSide;
    }
    caseValuesMap.put(this.avm2code.code.get(part.nextParts.get(reversed ? 0 : 1).start).operands[0],tar);
    GraphPart switchLoc=part.nextParts.get(reversed ? 0 : 1).nextParts.get(0);
    while ((this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).end).definition instanceof IfStrictNeIns) || (this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).end).definition instanceof IfStrictEqIns)) {
      part=part.nextParts.get(reversed ? 1 : 0);
      translatePart(localData,part,stack,staticOperation,null);
      tar=stack.pop();
      if (tar instanceof StrictEqAVM2Item) {
        tar=((StrictEqAVM2Item)tar).leftSide;
      }
      if (tar instanceof StrictNeqAVM2Item) {
        tar=((StrictNeqAVM2Item)tar).leftSide;
      }
      if (this.avm2code.code.get(part.end).definition instanceof IfStrictNeIns) {
        reversed=false;
      }
 else {
        reversed=true;
      }
      GraphPart numPart=part.nextParts.get(reversed ? 0 : 1);
      AVM2Instruction ins=null;
      TranslateStack sstack=new TranslateStack();
      do {
        for (int n=0; n < numPart.getHeight(); n++) {
          ins=this.avm2code.code.get(numPart.getPosAt(n));
          if (ins.definition instanceof LookupSwitchIns) {
            break;
          }
          ins.translate(localData,sstack,new ArrayList<GraphTargetItem>(),staticOperation,path);
        }
        if (numPart.nextParts.size() > 1) {
          break;
        }
 else {
          numPart=numPart.nextParts.get(0);
        }
      }
 while (!(this.avm2code.code.get(numPart.end).definition instanceof LookupSwitchIns));
      GraphTargetItem nt=sstack.peek();
      if (!(nt instanceof IntegerValueAVM2Item)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      IntegerValueAVM2Item iv=(IntegerValueAVM2Item)nt;
      caseValuesMap.put((int)(long)iv.value,tar);
      while (this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).start).definition instanceof JumpIns) {
        reversed=false;
        part=part.nextParts.get(reversed ? 1 : 0);
        if (part instanceof GraphPartMulti) {
          part=((GraphPartMulti)part).parts.get(0);
        }
      }
    }
    boolean hasDefault=false;
    GraphPart dp=part.nextParts.get(reversed ? 1 : 0);
    while (this.avm2code.code.get(dp.start).definition instanceof JumpIns) {
      if (dp instanceof GraphPartMulti) {
        dp=((GraphPartMulti)dp).parts.get(0);
      }
      dp=dp.nextParts.get(0);
    }
    GraphPart numPart=dp;
    AVM2Instruction ins=null;
    TranslateStack sstack=new TranslateStack();
    do {
      for (int n=0; n < numPart.getHeight(); n++) {
        ins=this.avm2code.code.get(numPart.getPosAt(n));
        if (ins.definition instanceof LookupSwitchIns) {
          break;
        }
        ins.translate(localData,sstack,new ArrayList<GraphTargetItem>(),staticOperation,path);
      }
      if (numPart.nextParts.size() > 1) {
        break;
      }
 else {
        numPart=numPart.nextParts.get(0);
      }
    }
 while (!(this.avm2code.code.get(numPart.end).definition instanceof LookupSwitchIns));
    GraphTargetItem nt=sstack.peek();
    if (nt instanceof IntegerValueAVM2Item) {
      hasDefault=true;
    }
    List<GraphTargetItem> caseValues=new ArrayList<>();
    for (int i=0; i < switchLoc.nextParts.size() - 1; i++) {
      if (caseValuesMap.containsKey(i)) {
        caseValues.add(caseValuesMap.get(i));
      }
 else {
        continue;
      }
    }
    List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
    GraphPart next=null;
    next=getMostCommonPart(localData,switchLoc.nextParts,loops);
    currentLoop=new Loop(loops.size(),null,next);
    currentLoop.phase=1;
    loops.add(currentLoop);
    List<Integer> valuesMapping=new ArrayList<>();
    List<GraphPart> caseBodies=new ArrayList<>();
    for (int i=0; i < caseValues.size(); i++) {
      GraphPart cur=switchLoc.nextParts.get(1 + i);
      if (!caseBodies.contains(cur)) {
        caseBodies.add(cur);
      }
      valuesMapping.add(caseBodies.indexOf(cur));
    }
    List<GraphTargetItem> defaultCommands=new ArrayList<>();
    GraphPart defaultPart=null;
    if (hasDefault) {
      defaultPart=switchLoc.nextParts.get(switchLoc.nextParts.size() - 1);
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      stopPart2.add(next);
      defaultCommands=printGraph(localData,stack,allParts,switchLoc,defaultPart,stopPart2,loops,staticOperation,path);
      if (!defaultCommands.isEmpty()) {
        if (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem) {
          if (((BreakItem)defaultCommands.get(defaultCommands.size() - 1)).loopId == currentLoop.id) {
            defaultCommands.remove(defaultCommands.size() - 1);
          }
        }
      }
    }
    List<GraphPart> ignored=new ArrayList<>();
    for (    Loop l : loops) {
      ignored.add(l.loopContinue);
    }
    for (int i=0; i < caseBodies.size(); i++) {
      List<GraphTargetItem> cc=new ArrayList<>();
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      for (int j=0; j < caseBodies.size(); j++) {
        if (caseBodies.get(j) != caseBodies.get(i)) {
          stopPart2.add(caseBodies.get(j));
        }
      }
      if (hasDefault) {
        stopPart2.add(defaultPart);
      }
      cc.addAll(0,printGraph(localData,stack,allParts,switchLoc,caseBodies.get(i),stopPart2,loops,staticOperation,path));
      caseCommands.add(cc);
    }
    SwitchItem sti=new SwitchItem(null,currentLoop,switchedObject,caseValues,caseCommands,defaultCommands,valuesMapping);
    ret.add(sti);
    if (next != null) {
      currentLoop.phase=2;
      ret.addAll(printGraph(localData,stack,allParts,null,next,stopPart,loops,staticOperation,path));
    }
  }
  return ret;
}","@Override protected List<GraphTargetItem> check(GraphSource code,BaseLocalData localData,List<GraphPart> allParts,TranslateStack stack,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> output,Loop currentLoop,int staticOperation,String path) throws InterruptedException {
  List<GraphTargetItem> ret=null;
  AVM2LocalData aLocalData=(AVM2LocalData)localData;
  List<ABCException> parsedExceptions=aLocalData.parsedExceptions;
  List<Integer> finallyJumps=aLocalData.finallyJumps;
  List<Integer> ignoredSwitches=aLocalData.ignoredSwitches;
  int ip=part.start;
  int addr=this.avm2code.fixAddrAfterDebugLine(this.avm2code.pos2adr(part.start));
  int maxend=-1;
  List<ABCException> catchedExceptions=new ArrayList<>();
  for (int e=0; e < body.exceptions.length; e++) {
    if (addr == this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].start)) {
      if (!body.exceptions[e].isFinally() || catchedExceptions.isEmpty()) {
        if (!parsedExceptions.contains(body.exceptions[e])) {
          if (((body.exceptions[e].end) > maxend)) {
            catchedExceptions.clear();
            maxend=this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end);
            catchedExceptions.add(body.exceptions[e]);
          }
 else           if (this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end) == maxend) {
            catchedExceptions.add(body.exceptions[e]);
          }
        }
      }
 else       if (body.exceptions[e].isFinally()) {
        parsedExceptions.add(body.exceptions[e]);
      }
    }
  }
  if (catchedExceptions.size() > 0) {
    parsedExceptions.addAll(catchedExceptions);
    int endpos=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(catchedExceptions.get(0).end));
    int endposStartBlock=code.adr2pos(catchedExceptions.get(0).end);
    List<List<GraphTargetItem>> catchedCommands=new ArrayList<>();
    if (this.avm2code.code.get(endpos).definition instanceof JumpIns) {
      int afterCatchAddr=this.avm2code.pos2adr(endpos + 1) + this.avm2code.code.get(endpos).operands[0];
      int afterCatchPos=this.avm2code.adr2pos(afterCatchAddr);
      final AVM2Graph t=this;
      Collections.sort(catchedExceptions,new Comparator<ABCException>(){
        @Override public int compare(        ABCException o1,        ABCException o2){
          return t.avm2code.fixAddrAfterDebugLine(o1.target) - t.avm2code.fixAddrAfterDebugLine(o2.target);
        }
      }
);
      List<GraphTargetItem> finallyCommands=new ArrayList<>();
      int returnPos=afterCatchPos;
      for (int e=0; e < body.exceptions.length; e++) {
        if (body.exceptions[e].isFinally()) {
          if (addr == this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].start)) {
            if (afterCatchPos + 1 == code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end))) {
              AVM2Instruction jmpIns=this.avm2code.code.get(code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end)));
              if (jmpIns.definition instanceof JumpIns) {
                int finStart=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(body.exceptions[e].end) + jmpIns.getBytes().length + jmpIns.operands[0]);
                GraphPart fpart=null;
                for (                GraphPart p : allParts) {
                  if (p.start == finStart) {
                    fpart=p;
                    break;
                  }
                }
                int swPos=-1;
                for (int f=finStart; f < this.avm2code.code.size(); f++) {
                  if (this.avm2code.code.get(f).definition instanceof LookupSwitchIns) {
                    AVM2Instruction swins=this.avm2code.code.get(f);
                    if (swins.operands.length >= 3) {
                      if (swins.operands[0] == swins.getBytes().length) {
                        if (code.adr2pos(code.pos2adr(f) + swins.operands[2]) < finStart) {
                          stack.push(new ExceptionAVM2Item(body.exceptions[e]));
                          GraphPart fepart=null;
                          for (                          GraphPart p : allParts) {
                            if (p.start == f + 1) {
                              fepart=p;
                              break;
                            }
                          }
                          swPos=f;
                          List<GraphPart> stopPart2=new ArrayList<>(stopPart);
                          stopPart2.add(fepart);
                          returnPos=f + 1;
                          break;
                        }
                      }
                    }
                  }
                }
                List<Integer> oldFinallyJumps=new ArrayList<>(finallyJumps);
                finallyJumps.clear();
                ignoredSwitches.add(swPos);
                finallyCommands=printGraph(localData,stack,allParts,parent,fpart,null,loops,staticOperation,path);
                finallyJumps.addAll(oldFinallyJumps);
                finallyJumps.add(finStart);
                break;
              }
            }
          }
        }
      }
      GraphPart retPart=null;
      for (      GraphPart p : allParts) {
        if (p.start == returnPos) {
          retPart=p;
          break;
        }
      }
      List<GraphPart> catchParts=new ArrayList<>();
      for (int e=0; e < catchedExceptions.size(); e++) {
        int eendpos;
        if (e < catchedExceptions.size() - 1) {
          eendpos=code.adr2pos(this.avm2code.fixAddrAfterDebugLine(catchedExceptions.get(e + 1).target)) - 2;
        }
 else {
          eendpos=afterCatchPos - 1;
        }
        GraphPart npart=null;
        int findpos=code.adr2pos(catchedExceptions.get(e).target);
        for (        GraphPart p : allParts) {
          if (p.start == findpos) {
            npart=p;
            catchParts.add(p);
            break;
          }
        }
        GraphPart nepart=null;
        for (        GraphPart p : allParts) {
          if (p.start == eendpos + 1) {
            nepart=p;
            break;
          }
        }
        stack.add(new ExceptionAVM2Item(catchedExceptions.get(e)));
        AVM2LocalData localData2=new AVM2LocalData(aLocalData);
        localData2.scopeStack=new ScopeStack();
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(nepart);
        if (retPart != null) {
          stopPart2.add(retPart);
        }
        catchedCommands.add(printGraph(localData2,stack,allParts,parent,npart,stopPart2,loops,staticOperation,path));
        if (catchedExceptions.get(e).isFinally()) {
          catchedCommands.remove(catchedCommands.size() - 1);
          catchedExceptions.remove(e);
          e--;
        }
      }
      GraphPart nepart=null;
      for (      GraphPart p : allParts) {
        if (p.start == endposStartBlock) {
          nepart=p;
          break;
        }
      }
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      stopPart2.add(nepart);
      stopPart2.addAll(catchParts);
      if (retPart != null) {
        stopPart2.add(retPart);
      }
      List<GraphTargetItem> tryCommands=printGraph(localData,stack,allParts,parent,part,stopPart2,loops,staticOperation,path);
      output.clear();
      output.add(new TryAVM2Item(tryCommands,catchedExceptions,catchedCommands,finallyCommands));
      ip=returnPos;
    }
  }
  if (ip != part.start) {
    part=null;
    for (    GraphPart p : allParts) {
      List<GraphPart> ps=p.getSubParts();
      for (      GraphPart p2 : ps) {
        if (p2.start == ip) {
          part=p2;
          break;
        }
      }
    }
    ret=new ArrayList<>();
    ret.addAll(output);
    GraphTargetItem lop=checkLoop(part,stopPart,loops);
    if (lop == null) {
      ret.addAll(printGraph(localData,stack,allParts,null,part,stopPart,loops,staticOperation,path));
    }
 else {
      ret.add(lop);
    }
    return ret;
  }
  if (part.nextParts.isEmpty()) {
    if (this.avm2code.code.get(part.end).definition instanceof ReturnValueIns) {
      if (part.getHeight() >= 3) {
        if (this.avm2code.code.get(part.getPosAt(part.getHeight() - 2)).definition instanceof KillIns) {
          if (this.avm2code.code.get(part.getPosAt(part.getHeight() - 3)).definition instanceof GetLocalTypeIns) {
            if (output.size() >= 2) {
              if (output.get(output.size() - 2) instanceof SetLocalAVM2Item) {
                ret=new ArrayList<>();
                ret.addAll(output);
                ret.remove(ret.size() - 1);
                ret.add(new ReturnValueAVM2Item(this.avm2code.code.get(part.end),((SetLocalAVM2Item)output.get(output.size() - 2)).value));
                return ret;
              }
            }
          }
        }
      }
    }
  }
  if ((this.avm2code.code.get(part.end).definition instanceof LookupSwitchIns) && ignoredSwitches.contains(part.end)) {
    ret=new ArrayList<>();
    ret.addAll(output);
    return ret;
  }
  if (((part.nextParts.size() == 2) && (!stack.isEmpty()) && (stack.peek() instanceof StrictEqAVM2Item)&& (part.nextParts.get(0).getHeight() >= 2)&& (this.avm2code.code.get(this.avm2code.fixIPAfterDebugLine(part.nextParts.get(0).start)).definition instanceof PushIntegerTypeIns)&& (!part.nextParts.get(0).nextParts.isEmpty())&& (this.avm2code.code.get(part.nextParts.get(0).nextParts.get(0).end).definition instanceof LookupSwitchIns)) || ((part.nextParts.size() == 2) && (!stack.isEmpty()) && (stack.peek() instanceof StrictNeqAVM2Item)&& (part.nextParts.get(1).getHeight() >= 2)&& (this.avm2code.code.get(this.avm2code.fixIPAfterDebugLine(part.nextParts.get(1).start)).definition instanceof PushIntegerTypeIns)&& (!part.nextParts.get(1).nextParts.isEmpty())&& (this.avm2code.code.get(part.nextParts.get(1).nextParts.get(0).end).definition instanceof LookupSwitchIns))) {
    if (stack.peek() instanceof StrictEqAVM2Item) {
      ignoredSwitches.add(part.nextParts.get(0).nextParts.get(0).end);
    }
 else {
      ignoredSwitches.add(part.nextParts.get(1).nextParts.get(0).end);
    }
    ret=new ArrayList<>();
    ret.addAll(output);
    boolean reversed=false;
    if (stack.peek() instanceof StrictEqAVM2Item) {
      reversed=true;
    }
    GraphTargetItem switchedObject=null;
    if (!output.isEmpty()) {
      if (output.get(output.size() - 1) instanceof SetLocalAVM2Item) {
        switchedObject=((SetLocalAVM2Item)output.get(output.size() - 1)).value;
      }
    }
    if (switchedObject == null) {
      switchedObject=new NullAVM2Item(null);
    }
    HashMap<Integer,GraphTargetItem> caseValuesMap=new HashMap<>();
    GraphTargetItem tar=stack.pop();
    if (tar instanceof StrictEqAVM2Item) {
      tar=((StrictEqAVM2Item)tar).leftSide;
    }
    if (tar instanceof StrictNeqAVM2Item) {
      tar=((StrictNeqAVM2Item)tar).leftSide;
    }
    caseValuesMap.put(this.avm2code.code.get(part.nextParts.get(reversed ? 0 : 1).start).operands[0],tar);
    GraphPart switchLoc=part.nextParts.get(reversed ? 0 : 1).nextParts.get(0);
    while ((this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).end).definition instanceof IfStrictNeIns) || (this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).end).definition instanceof IfStrictEqIns)) {
      part=part.nextParts.get(reversed ? 1 : 0);
      translatePart(localData,part,stack,staticOperation,null);
      tar=stack.pop();
      if (tar instanceof StrictEqAVM2Item) {
        tar=((StrictEqAVM2Item)tar).leftSide;
      }
      if (tar instanceof StrictNeqAVM2Item) {
        tar=((StrictNeqAVM2Item)tar).leftSide;
      }
      if (this.avm2code.code.get(part.end).definition instanceof IfStrictNeIns) {
        reversed=false;
      }
 else {
        reversed=true;
      }
      GraphPart numPart=part.nextParts.get(reversed ? 0 : 1);
      AVM2Instruction ins=null;
      TranslateStack sstack=new TranslateStack();
      do {
        for (int n=0; n < numPart.getHeight(); n++) {
          ins=this.avm2code.code.get(numPart.getPosAt(n));
          if (ins.definition instanceof LookupSwitchIns) {
            break;
          }
          ins.translate(localData,sstack,new ArrayList<GraphTargetItem>(),staticOperation,path);
        }
        if (numPart.nextParts.size() > 1) {
          break;
        }
 else {
          numPart=numPart.nextParts.get(0);
        }
      }
 while (!(this.avm2code.code.get(numPart.end).definition instanceof LookupSwitchIns));
      GraphTargetItem nt=sstack.peek();
      if (!(nt instanceof IntegerValueAVM2Item)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      IntegerValueAVM2Item iv=(IntegerValueAVM2Item)nt;
      caseValuesMap.put((int)(long)iv.value,tar);
      while (this.avm2code.code.get(part.nextParts.get(reversed ? 1 : 0).start).definition instanceof JumpIns) {
        reversed=false;
        part=part.nextParts.get(reversed ? 1 : 0);
        if (part instanceof GraphPartMulti) {
          part=((GraphPartMulti)part).parts.get(0);
        }
      }
    }
    boolean hasDefault=false;
    GraphPart dp=part.nextParts.get(reversed ? 1 : 0);
    while (this.avm2code.code.get(dp.start).definition instanceof JumpIns) {
      if (dp instanceof GraphPartMulti) {
        dp=((GraphPartMulti)dp).parts.get(0);
      }
      dp=dp.nextParts.get(0);
    }
    GraphPart numPart=dp;
    AVM2Instruction ins=null;
    TranslateStack sstack=new TranslateStack();
    do {
      for (int n=0; n < numPart.getHeight(); n++) {
        ins=this.avm2code.code.get(numPart.getPosAt(n));
        if (ins.definition instanceof LookupSwitchIns) {
          break;
        }
        ins.translate(localData,sstack,new ArrayList<GraphTargetItem>(),staticOperation,path);
      }
      if (numPart.nextParts.size() > 1) {
        break;
      }
 else {
        numPart=numPart.nextParts.get(0);
      }
    }
 while (!(this.avm2code.code.get(numPart.end).definition instanceof LookupSwitchIns));
    GraphTargetItem nt=sstack.peek();
    if (nt instanceof IntegerValueAVM2Item) {
      hasDefault=true;
    }
    List<GraphTargetItem> caseValues=new ArrayList<>();
    for (int i=0; i < switchLoc.nextParts.size() - 1; i++) {
      if (caseValuesMap.containsKey(i)) {
        caseValues.add(caseValuesMap.get(i));
      }
 else {
        continue;
      }
    }
    List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
    GraphPart next=null;
    next=getMostCommonPart(localData,switchLoc.nextParts,loops);
    currentLoop=new Loop(loops.size(),null,next);
    currentLoop.phase=1;
    loops.add(currentLoop);
    List<Integer> valuesMapping=new ArrayList<>();
    List<GraphPart> caseBodies=new ArrayList<>();
    for (int i=0; i < caseValues.size(); i++) {
      GraphPart cur=switchLoc.nextParts.get(1 + i);
      if (!caseBodies.contains(cur)) {
        caseBodies.add(cur);
      }
      valuesMapping.add(caseBodies.indexOf(cur));
    }
    List<GraphTargetItem> defaultCommands=new ArrayList<>();
    GraphPart defaultPart=null;
    if (hasDefault) {
      defaultPart=switchLoc.nextParts.get(switchLoc.nextParts.size() - 1);
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      stopPart2.add(next);
      defaultCommands=printGraph(localData,stack,allParts,switchLoc,defaultPart,stopPart2,loops,staticOperation,path);
      if (!defaultCommands.isEmpty()) {
        if (defaultCommands.get(defaultCommands.size() - 1) instanceof BreakItem) {
          if (((BreakItem)defaultCommands.get(defaultCommands.size() - 1)).loopId == currentLoop.id) {
            defaultCommands.remove(defaultCommands.size() - 1);
          }
        }
      }
    }
    List<GraphPart> ignored=new ArrayList<>();
    for (    Loop l : loops) {
      ignored.add(l.loopContinue);
    }
    for (int i=0; i < caseBodies.size(); i++) {
      List<GraphTargetItem> cc=new ArrayList<>();
      List<GraphPart> stopPart2=new ArrayList<>(stopPart);
      for (int j=0; j < caseBodies.size(); j++) {
        if (caseBodies.get(j) != caseBodies.get(i)) {
          stopPart2.add(caseBodies.get(j));
        }
      }
      if (hasDefault) {
        stopPart2.add(defaultPart);
      }
      cc.addAll(0,printGraph(localData,stack,allParts,switchLoc,caseBodies.get(i),stopPart2,loops,staticOperation,path));
      caseCommands.add(cc);
    }
    SwitchItem sti=new SwitchItem(null,currentLoop,switchedObject,caseValues,caseCommands,defaultCommands,valuesMapping);
    ret.add(sti);
    if (next != null) {
      currentLoop.phase=2;
      ret.addAll(printGraph(localData,stack,allParts,null,next,stopPart,loops,staticOperation,path));
    }
  }
  return ret;
}",0.9829401532029176
61581,"private GraphTargetItem member(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,GraphTargetItem obj,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=obj;
  ParsedSymbol s=lex();
  while (s.isType(SymbolType.DOT,SymbolType.BRACKET_OPEN,SymbolType.TYPENAME)) {
    ParsedSymbol s2=lex();
    boolean attr=false;
    if (s.type == SymbolType.DOT) {
      if (s2.type == SymbolType.ATTRIBUTE) {
        attr=true;
        s=lex();
      }
 else {
        lexer.pushback(s2);
      }
    }
 else {
      lexer.pushback(s2);
    }
    if (s.type == SymbolType.TYPENAME) {
      lexer.pushback(s);
      ret=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
      s=lex();
    }
 else     if (s.type == SymbolType.BRACKET_OPEN) {
      GraphTargetItem index=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
      expectedType(SymbolType.BRACKET_CLOSE);
      ret=new IndexAVM2Item(attr,ret,index,null,openedNamespaces);
      s=lex();
    }
 else {
      s=lex();
      expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
      String propName=s.value.toString();
      GraphTargetItem propItem=null;
      s=lex();
      GraphTargetItem ns=null;
      if (s.type == SymbolType.NAMESPACE_OP) {
        ns=new UnresolvedAVM2Item(new ArrayList<GraphTargetItem>(),importedClasses,false,null,lexer.yyline(),propName,null,openedNamespaces);
        variables.add((UnresolvedAVM2Item)ns);
        s=lex();
        if (s.type == SymbolType.BRACKET_OPEN) {
          propItem=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
          expectedType(SymbolType.BRACKET_CLOSE);
          propName=null;
        }
 else {
          expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
          propName=s.value.toString();
          propItem=null;
        }
      }
 else {
        lexer.pushback(s);
      }
      if (ns != null) {
        ret=new NamespacedAVM2Item(ns,propName,propItem,ret,attr,openedNamespaces,null);
      }
 else {
        ret=new PropertyAVM2Item(ret,(attr ? ""String_Node_Str"" : ""String_Node_Str"") + propName,abc,otherABCs,openedNamespaces,new ArrayList<MethodBody>());
      }
      s=lex();
    }
  }
  if (s.type.getPrecedence() == GraphTargetItem.PRECEDENCE_ASSIGMENT) {
    ret=expression1(ret,s.type.getPrecedence(),thisType,pkg,needsActivation,importedClasses,openedNamespaces,inMethod,registerVars,inFunction,inMethod,false,variables);
  }
 else {
    lexer.pushback(s);
  }
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  return ret;
}","private GraphTargetItem member(TypeItem thisType,String pkg,Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,GraphTargetItem obj,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables) throws IOException, AVM2ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=obj;
  ParsedSymbol s=lex();
  while (s.isType(SymbolType.DOT,SymbolType.BRACKET_OPEN,SymbolType.TYPENAME)) {
    ParsedSymbol s2=lex();
    boolean attr=false;
    if (s.type == SymbolType.DOT) {
      if (s2.type == SymbolType.ATTRIBUTE) {
        attr=true;
      }
 else {
        lexer.pushback(s2);
      }
    }
 else {
      lexer.pushback(s2);
    }
    if (s.type == SymbolType.TYPENAME) {
      lexer.pushback(s);
      ret=applyType(thisType,pkg,needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
      s=lex();
    }
 else     if (s.type == SymbolType.BRACKET_OPEN) {
      GraphTargetItem index=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
      expectedType(SymbolType.BRACKET_CLOSE);
      ret=new IndexAVM2Item(attr,ret,index,null,openedNamespaces);
      s=lex();
    }
 else {
      s=lex();
      expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
      String propName=s.value.toString();
      GraphTargetItem propItem=null;
      s=lex();
      GraphTargetItem ns=null;
      if (s.type == SymbolType.NAMESPACE_OP) {
        ns=new UnresolvedAVM2Item(new ArrayList<GraphTargetItem>(),importedClasses,false,null,lexer.yyline(),propName,null,openedNamespaces);
        variables.add((UnresolvedAVM2Item)ns);
        s=lex();
        if (s.type == SymbolType.BRACKET_OPEN) {
          propItem=expression(thisType,pkg,needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
          expectedType(SymbolType.BRACKET_CLOSE);
          propName=null;
        }
 else {
          expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
          propName=s.value.toString();
          propItem=null;
        }
      }
 else {
        lexer.pushback(s);
      }
      if (ns != null) {
        ret=new NamespacedAVM2Item(ns,propName,propItem,ret,attr,openedNamespaces,null);
      }
 else {
        ret=new PropertyAVM2Item(ret,(attr ? ""String_Node_Str"" : ""String_Node_Str"") + propName,abc,otherABCs,openedNamespaces,new ArrayList<MethodBody>());
      }
      s=lex();
    }
  }
  if (s.type.getPrecedence() == GraphTargetItem.PRECEDENCE_ASSIGMENT) {
    ret=expression1(ret,s.type.getPrecedence(),thisType,pkg,needsActivation,importedClasses,openedNamespaces,inMethod,registerVars,inFunction,inMethod,false,variables);
  }
 else {
    lexer.pushback(s);
  }
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  return ret;
}",0.9971103178650348
61582,"@Override public Component getTreeCellRendererComponent(JTree tree,Object value,boolean sel,boolean expanded,boolean leaf,int row,boolean hasFocus){
  TreeItem val=(TreeItem)value;
  if (val.getSwf() == null) {
    value=null;
  }
  super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
  TreeNodeType type=getTreeNodeType(val);
  if (type == TreeNodeType.FOLDER && expanded) {
    type=TreeNodeType.FOLDER_OPEN;
  }
  if ((type == TreeNodeType.FOLDER || type == TreeNodeType.FOLDER_OPEN) && val instanceof FolderItem) {
    FolderItem si=(FolderItem)val;
    if (!TagTreeRoot.FOLDER_ROOT.equals(si.getName())) {
      String itemName=""String_Node_Str"" + si.getName();
      setIcon(View.getIcon(itemName.toLowerCase() + ""String_Node_Str""));
    }
  }
 else {
    setIcon(icons.get(type));
  }
  boolean isModified=val.isModified();
  if (isModified) {
    if (boldFont == null) {
      Font font=getFont();
      boldFont=font.deriveFont(Font.BOLD);
    }
  }
 else {
    if (plainFont == null) {
      Font font=getFont();
      plainFont=font.deriveFont(Font.PLAIN);
    }
  }
  setFont(isModified ? boldFont : plainFont);
  return this;
}","@Override public Component getTreeCellRendererComponent(JTree tree,Object value,boolean sel,boolean expanded,boolean leaf,int row,boolean hasFocus){
  TreeItem val=(TreeItem)value;
  if (!(val instanceof SWFList) && val.getSwf() == null) {
    value=null;
  }
  super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
  TreeNodeType type=getTreeNodeType(val);
  if (type == TreeNodeType.FOLDER && expanded) {
    type=TreeNodeType.FOLDER_OPEN;
  }
  if ((type == TreeNodeType.FOLDER || type == TreeNodeType.FOLDER_OPEN) && val instanceof FolderItem) {
    FolderItem si=(FolderItem)val;
    if (!TagTreeRoot.FOLDER_ROOT.equals(si.getName())) {
      String itemName=""String_Node_Str"" + si.getName();
      setIcon(View.getIcon(itemName.toLowerCase() + ""String_Node_Str""));
    }
  }
 else {
    setIcon(icons.get(type));
  }
  boolean isModified=val.isModified();
  if (isModified) {
    if (boldFont == null) {
      Font font=getFont();
      boldFont=font.deriveFont(Font.BOLD);
    }
  }
 else {
    if (plainFont == null) {
      Font font=getFont();
      plainFont=font.deriveFont(Font.PLAIN);
    }
  }
  setFont(isModified ? boldFont : plainFont);
  return this;
}",0.987727465086754
61583,"public GraphTextWriter toString(Trait parent,String path,ABC abc,boolean isStatic,ScriptExportMode exportMode,boolean makePackages,int scriptIndex,int classIndex,GraphTextWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  for (int t=0; t < traits.size(); t++) {
    writer.newLine();
    Trait trait=traits.get(t);
    int h=t;
    if (classIndex != -1) {
      if (!isStatic) {
        h+=abc.class_info.get(classIndex).static_traits.traits.size();
      }
    }
    if (trait instanceof TraitClass) {
      writer.startClass(((TraitClass)trait).class_info);
    }
 else {
      writer.startTrait(h);
    }
    if (makePackages) {
      trait.toStringPackaged(parent,path,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
    }
 else {
      trait.toString(parent,path,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
    }
    if (trait instanceof TraitClass) {
      writer.endClass();
    }
 else {
      writer.endTrait();
    }
  }
  return writer;
}","public GraphTextWriter toString(Class[] traitTypes,Trait parent,String path,ABC abc,boolean isStatic,ScriptExportMode exportMode,boolean makePackages,int scriptIndex,int classIndex,GraphTextWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  for (int t=0; t < traits.size(); t++) {
    Trait trait=traits.get(t);
    if (traitTypes != null) {
      boolean found=false;
      for (      Class c : traitTypes) {
        if (c.isInstance(trait)) {
          found=true;
          break;
        }
      }
      if (!found) {
        continue;
      }
    }
    writer.newLine();
    int h=t;
    if (classIndex != -1) {
      if (!isStatic) {
        h+=abc.class_info.get(classIndex).static_traits.traits.size();
      }
    }
    if (trait instanceof TraitClass) {
      writer.startClass(((TraitClass)trait).class_info);
    }
 else {
      writer.startTrait(h);
    }
    if (makePackages) {
      trait.toStringPackaged(parent,path,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
    }
 else {
      trait.toString(parent,path,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
    }
    if (trait instanceof TraitClass) {
      writer.endClass();
    }
 else {
      writer.endTrait();
    }
  }
  return writer;
}",0.8658080598255089
61584,"public void gotoTrait(int traitId){
  if (traitId == -1) {
    return;
  }
  Highlighting tc=Highlighting.searchIndex(classHighlights,classIndex);
  if (tc != null) {
    Highlighting th=Highlighting.searchIndex(traitHighlights,traitId,tc.startPos,tc.startPos + tc.len);
    int pos;
    if (th != null) {
      ignoreCarret=true;
      int startPos=th.startPos + th.len - 1;
      if (startPos <= getDocument().getLength()) {
        setCaretPosition(startPos);
      }
      ignoreCarret=false;
      pos=th.startPos;
    }
 else {
      pos=tc.startPos;
    }
    final int fpos=pos;
    new Timer().schedule(new TimerTask(){
      @Override public void run(){
        if (fpos <= getDocument().getLength()) {
          setCaretPosition(fpos);
        }
      }
    }
,100);
  }
}","public void gotoTrait(int traitId){
  if (traitId == -1) {
    return;
  }
  Highlighting tc=Highlighting.searchIndex(classHighlights,classIndex);
  if (tc != null) {
    Highlighting th=Highlighting.searchIndex(traitHighlights,traitId,tc.startPos,tc.startPos + tc.len);
    int pos;
    if (th != null) {
      if (th.len > 1) {
        ignoreCarret=true;
        int startPos=th.startPos + th.len - 1;
        if (startPos <= getDocument().getLength()) {
          setCaretPosition(startPos);
        }
        ignoreCarret=false;
      }
      pos=th.startPos;
    }
 else {
      pos=tc.startPos;
    }
    final int fpos=pos;
    new Timer().schedule(new TimerTask(){
      @Override public void run(){
        if (fpos <= getDocument().getLength()) {
          setCaretPosition(fpos);
        }
      }
    }
,100);
  }
}",0.9701863354037268
61585,"protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  if (isLoop) {
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext && part.nextParts.size() == 2) {
    if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (!reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((OrItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof AndItem) {
            o.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
 else     if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
  }
  if (parseNext) {
    if (false && part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      for (      GraphPart p : part.nextParts) {
        if (!first) {
          caseValues.add(new IntegerValueItem(null,pos++));
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (first) {
            defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
          }
 else {
            caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
          }
          vis.add(p);
        }
        first=false;
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      if (staticOperation != SOP_USE_STATIC) {
        if (expr.isCompileTime()) {
          boolean doJump=EcmaScript.toBoolean(expr.getResult());
          if (doJump) {
            nextOnePart=part.nextParts.get(0);
          }
 else {
            nextOnePart=part.nextParts.get(1);
          }
          if (staticOperation == SOP_REMOVE_STATIC) {
          }
        }
      }
      if (nextOnePart == null) {
        List<GraphPart> nps;
        nps=part.nextParts;
        GraphPart next=getCommonPart(localData,nps,loops);
        TranslateStack trueStack=(TranslateStack)stack.clone();
        TranslateStack falseStack=(TranslateStack)stack.clone();
        int trueStackSizeBefore=trueStack.size();
        int falseStackSizeBefore=falseStack.size();
        List<GraphTargetItem> onTrue=new ArrayList<>();
        boolean isEmpty=nps.get(0) == nps.get(1);
        if (isEmpty) {
          next=nps.get(0);
        }
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if (next != null) {
          stopPart2.add(next);
        }
        if (!isEmpty) {
          onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty) {
          onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
          stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
        }
 else {
          currentRet.add(new IfItem(null,expr,onTrue,onFalse));
        }
        if (next != null) {
          if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
            onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
              stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
            }
 else {
              currentRet.add(new IfItem(null,expr,onTrue,onFalse));
            }
          }
 else {
            printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
          }
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(visited,localData,new TranslateStack(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                if (expr instanceof LogicalOpItem) {
                  expr=((LogicalOpItem)expr).invert();
                }
 else {
                  expr=new NotItem(null,expr);
                }
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
switch (part.stopPartType) {
case AND_OR:
      part.setAndOrStack(stack);
    break;
case COMMONPART:
  part.setCommonPartStack(stack);
break;
case NONE:
break;
}
return ret;
}
if ((part != null) && (code.size() <= part.start)) {
ret.add(new ScriptEndItem());
return ret;
}
List<GraphTargetItem> currentRet=ret;
UniversalLoopItem loopItem=null;
if (isLoop) {
loopItem=new UniversalLoopItem(null,currentLoop);
currentRet.add(loopItem);
loopItem.commands=new ArrayList<>();
currentRet=loopItem.commands;
}
boolean parseNext=true;
List<GraphTargetItem> output=new ArrayList<>();
List<GraphPart> parts=new ArrayList<>();
if (part instanceof GraphPartMulti) {
parts=((GraphPartMulti)part).parts;
}
 else {
parts.add(part);
}
for (GraphPart p : parts) {
int end=p.end;
int start=p.start;
output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
output.add(new ScriptEndItem());
}
}
if (parseNext) {
List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
if (retCheck != null) {
if (!retCheck.isEmpty()) {
currentRet.addAll(retCheck);
}
parseNext=false;
}
 else {
currentRet.addAll(output);
}
}
if (parseNext && part.nextParts.size() == 2) {
if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (!reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((OrItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof AndItem) {
  o.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
 else if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((AndItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
}
if (parseNext) {
if (false && part.nextParts.size() > 2) {
GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
List<GraphPart> vis=new ArrayList<>();
GraphTargetItem switchedItem=stack.pop();
List<GraphTargetItem> caseValues=new ArrayList<>();
List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
List<GraphTargetItem> defaultCommands=new ArrayList<>();
List<Integer> valueMappings=new ArrayList<>();
Loop swLoop=new Loop(loops.size(),null,next);
swLoop.phase=1;
loops.add(swLoop);
boolean first=false;
int pos=0;
for (GraphPart p : part.nextParts) {
if (!first) {
caseValues.add(new IntegerValueItem(null,pos++));
if (vis.contains(p)) {
  valueMappings.add(caseCommands.size() - 1);
  continue;
}
valueMappings.add(caseCommands.size());
}
List<GraphPart> stopPart2=new ArrayList<>();
if (next != null) {
stopPart2.add(next);
}
 else if (!stopPart.isEmpty()) {
stopPart2.add(stopPart.get(stopPart.size() - 1));
}
for (GraphPart p2 : part.nextParts) {
if (p2 == p) {
  continue;
}
if (!stopPart2.contains(p2)) {
  stopPart2.add(p2);
}
}
if (next != p) {
if (first) {
  defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
 else {
  caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
}
vis.add(p);
}
first=false;
}
SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
currentRet.add(sw);
swLoop.phase=2;
if (next != null) {
currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
GraphPart nextOnePart=null;
if (part.nextParts.size() == 2) {
GraphTargetItem expr=stack.pop();
if (expr instanceof LogicalOpItem) {
expr=((LogicalOpItem)expr).invert();
}
 else {
expr=new NotItem(null,expr);
}
if (staticOperation != SOP_USE_STATIC) {
if (expr.isCompileTime()) {
boolean doJump=EcmaScript.toBoolean(expr.getResult());
if (doJump) {
  nextOnePart=part.nextParts.get(0);
}
 else {
  nextOnePart=part.nextParts.get(1);
}
if (staticOperation == SOP_REMOVE_STATIC) {
}
}
}
if (nextOnePart == null) {
List<GraphPart> nps;
nps=part.nextParts;
GraphPart next=getCommonPart(localData,nps,loops);
TranslateStack trueStack=(TranslateStack)stack.clone();
TranslateStack falseStack=(TranslateStack)stack.clone();
int trueStackSizeBefore=trueStack.size();
int falseStackSizeBefore=falseStack.size();
List<GraphTargetItem> onTrue=new ArrayList<>();
boolean isEmpty=nps.get(0) == nps.get(1);
if (isEmpty) {
next=nps.get(0);
}
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart.CommonPartStack commonPartStack=null;
if ((!isEmpty) && (next != null)) {
commonPartStack=next.new CommonPartStack();
if (next.commonPartStacks == null) {
  next.commonPartStacks=new ArrayList<>();
}
next.stopPartType=GraphPart.StopPartType.COMMONPART;
stopPart2.add(next);
}
if (!isEmpty) {
if (next != null) {
  next.commonPartStacks.add(commonPartStack);
  commonPartStack.isTrueStack=true;
}
onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
List<GraphTargetItem> onFalse=new ArrayList<>();
if (!isEmpty) {
if (next != null) {
  commonPartStack.isTrueStack=false;
}
onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
if ((!isEmpty) && (next != null)) {
if ((commonPartStack.trueStack != null) && (commonPartStack.falseStack != null)) {
  trueStack=commonPartStack.trueStack;
  falseStack=commonPartStack.falseStack;
}
next.commonPartStacks.remove(next.commonPartStacks.size() - 1);
if (next.commonPartStacks.isEmpty()) {
  next.stopPartType=GraphPart.StopPartType.NONE;
}
}
if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
}
 else {
currentRet.add(new IfItem(null,expr,onTrue,onFalse));
}
if (next != null) {
if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
  onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
    stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
  }
 else {
    currentRet.add(new IfItem(null,expr,onTrue,onFalse));
  }
}
 else {
  printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
}
}
if (part.nextParts.size() == 1) {
nextOnePart=part.nextParts.get(0);
}
if (nextOnePart != null) {
printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
if (isLoop) {
LoopItem li=loopItem;
boolean loopTypeFound=false;
boolean hasContinue=false;
processIfs(loopItem.commands);
checkContinueAtTheEnd(loopItem.commands,currentLoop);
List<ContinueItem> continues=loopItem.getContinues();
for (ContinueItem c : continues) {
if (c.loopId == currentLoop.id) {
hasContinue=true;
break;
}
}
if (!hasContinue) {
if (currentLoop.loopPreContinue != null) {
List<GraphPart> stopContPart=new ArrayList<>();
stopContPart.add(currentLoop.loopContinue);
GraphPart precoBackup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
loopItem.commands.addAll(printGraph(visited,localData,new TranslateStack(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(0) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(0);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
boolean breakpos2=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
 else if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
BreakItem bi=(BreakItem)loopItem.commands.get(1);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
  breakpos2=true;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
exprList.add(expr);
List<GraphTargetItem> commands=new ArrayList<>();
commands.addAll(bodyBranch);
loopItem.commands.remove(0);
if (breakpos2) {
  loopItem.commands.remove(0);
}
commands.addAll(loopItem.commands);
checkContinueAtTheEnd(commands,currentLoop);
List<GraphTargetItem> finalComm=new ArrayList<>();
if (currentLoop.loopPreContinue != null) {
  GraphPart backup=currentLoop.loopPreContinue;
  currentLoop.loopPreContinue=null;
  List<GraphPart> stopPart2=new ArrayList<>(stopPart);
  stopPart2.add(currentLoop.loopContinue);
  finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
  currentLoop.loopPreContinue=backup;
  checkContinueAtTheEnd(finalComm,currentLoop);
}
if (!finalComm.isEmpty()) {
  ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
}
 else {
  ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
checkContinueAtTheEnd(bodyBranch,currentLoop);
List<GraphTargetItem> commands=new ArrayList<>();
if (!bodyBranch.isEmpty()) {
  ret.add(index,loopItem);
}
 else {
  loopItem.commands.remove(loopItem.commands.size() - 1);
  commands.addAll(loopItem.commands);
  commands.addAll(bodyBranch);
  exprList.add(expr);
  checkContinueAtTheEnd(commands,currentLoop);
  ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound) {
if (currentLoop.loopPreContinue != null) {
loopTypeFound=true;
GraphPart backup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
stopPart2.add(currentLoop.loopContinue);
List<GraphTargetItem> finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
currentLoop.loopPreContinue=backup;
checkContinueAtTheEnd(finalComm,currentLoop);
if (!finalComm.isEmpty()) {
if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
  IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
  boolean ok=false;
  boolean invert=false;
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
    invert=true;
  }
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
  }
  if (ok) {
    finalComm.remove(finalComm.size() - 1);
    int index=ret.indexOf(loopItem);
    ret.remove(index);
    List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
    GraphTargetItem expr=ifi.expression;
    if (invert) {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
    }
    exprList.add(expr);
    ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
  }
}
}
}
}
if (!loopTypeFound) {
checkContinueAtTheEnd(loopItem.commands,currentLoop);
}
currentLoop.phase=2;
GraphTargetItem replaced=checkLoop(li,localData,loops);
if (replaced != li) {
int index=ret.indexOf(li);
ret.remove(index);
if (replaced != null) {
ret.add(index,replaced);
}
}
if (currentLoop.loopBreak != null) {
ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
return ret;
}",0.8574057483232039
61586,"public static void frameToImage(Timeline timeline,int frame,int time,RenderContext renderContext,SerializableImage image,Matrix transformation,ColorTransform colorTransform){
  double unzoom=SWF.unitDivisor;
  if (timeline.getFrameCount() <= frame) {
    return;
  }
  Frame frameObj=timeline.getFrame(frame);
  Graphics2D g=(Graphics2D)image.getGraphics();
  g.setPaint(frameObj.backgroundColor.toColor());
  g.fill(new Rectangle(image.getWidth(),image.getHeight()));
  g.setTransform(transformation.toTransform());
  List<Clip> clips=new ArrayList<>();
  List<Shape> prevClips=new ArrayList<>();
  int maxDepth=timeline.getMaxDepth();
  for (int i=1; i <= maxDepth; i++) {
    for (int c=0; c < clips.size(); c++) {
      if (clips.get(c).depth == i) {
        g.setClip(prevClips.get(c));
        prevClips.remove(c);
        clips.remove(c);
      }
    }
    if (!frameObj.layers.containsKey(i)) {
      continue;
    }
    DepthState layer=frameObj.layers.get(i);
    if (!timeline.swf.getCharacters().containsKey(layer.characterId)) {
      continue;
    }
    if (!layer.isVisible) {
      continue;
    }
    CharacterTag character=timeline.swf.getCharacter(layer.characterId);
    Matrix mat=new Matrix(layer.matrix);
    mat=mat.preConcatenate(transformation);
    if (colorTransform == null) {
      colorTransform=new ColorTransform();
    }
    ColorTransform clrTrans=colorTransform.clone();
    if (layer.colorTransForm != null && layer.blendMode <= 1) {
      clrTrans=colorTransform.merge(layer.colorTransForm);
    }
    boolean showPlaceholder=false;
    if (character instanceof DrawableTag) {
      DrawableTag drawable=(DrawableTag)character;
      Matrix drawMatrix=new Matrix();
      int drawableFrameCount=drawable.getNumFrames();
      if (drawableFrameCount == 0) {
        drawableFrameCount=1;
      }
      int dframe=(time + layer.time) % drawableFrameCount;
      if (character instanceof ButtonTag) {
        dframe=ButtonTag.FRAME_UP;
        if (renderContext.stateUnderCursor == layer) {
          if (renderContext.mouseButton > 0) {
            dframe=ButtonTag.FRAME_DOWN;
          }
 else {
            dframe=ButtonTag.FRAME_OVER;
          }
        }
      }
      RECT boundRect=drawable.getRect();
      ExportRectangle rect=new ExportRectangle(boundRect);
      rect=mat.transform(rect);
      Matrix m=mat.clone();
      if (layer.filters != null && layer.filters.size() > 0) {
        double deltaXMax=0;
        double deltaYMax=0;
        for (        FILTER filter : layer.filters) {
          double x=filter.getDeltaX();
          double y=filter.getDeltaY();
          deltaXMax=Math.max(x,deltaXMax);
          deltaYMax=Math.max(y,deltaYMax);
        }
        rect.xMin-=deltaXMax * unzoom;
        rect.xMax+=deltaXMax * unzoom;
        rect.yMin-=deltaYMax * unzoom;
        rect.yMax+=deltaYMax * unzoom;
      }
      rect.xMin-=1 * unzoom;
      rect.yMin-=1 * unzoom;
      rect.xMin=Math.max(0,rect.xMin);
      rect.yMin=Math.max(0,rect.yMin);
      int newWidth=(int)(rect.getWidth() / unzoom);
      int newHeight=(int)(rect.getHeight() / unzoom);
      int deltaX=(int)(rect.xMin / unzoom);
      int deltaY=(int)(rect.yMin / unzoom);
      newWidth=Math.min(image.getWidth() - deltaX,newWidth) + 1;
      newHeight=Math.min(image.getHeight() - deltaY,newHeight) + 1;
      if (newWidth <= 0 || newHeight <= 0) {
        continue;
      }
      m.translate(-rect.xMin,-rect.yMin);
      drawMatrix.translate(rect.xMin,rect.yMin);
      SerializableImage img=null;
      String cacheKey=null;
      if (drawable instanceof ShapeTag) {
        cacheKey=m.toString() + clrTrans.toString();
        img=renderContext.shapeCache.get(cacheKey);
      }
      if (img == null) {
        img=new SerializableImage(newWidth,newHeight,SerializableImage.TYPE_INT_ARGB);
        img.fillTransparent();
        drawable.toImage(dframe,layer.time + time,layer.ratio,renderContext,img,m,clrTrans);
        if (cacheKey != null) {
          renderContext.shapeCache.put(cacheKey,img);
        }
      }
      if (layer.filters != null) {
        for (        FILTER filter : layer.filters) {
          img=filter.apply(img);
        }
      }
      if (layer.blendMode > 1) {
        if (layer.colorTransForm != null) {
          img=layer.colorTransForm.apply(img);
        }
      }
      drawMatrix.translateX/=unzoom;
      drawMatrix.translateY/=unzoom;
      AffineTransform trans=drawMatrix.toTransform();
switch (layer.blendMode) {
case 0:
case 1:
        g.setComposite(AlphaComposite.SrcOver);
      break;
case 2:
    g.setComposite(AlphaComposite.SrcOver);
  break;
case 3:
g.setComposite(BlendComposite.Multiply);
break;
case 4:
g.setComposite(BlendComposite.Screen);
break;
case 5:
g.setComposite(BlendComposite.Lighten);
break;
case 6:
g.setComposite(BlendComposite.Darken);
break;
case 7:
g.setComposite(BlendComposite.Difference);
break;
case 8:
g.setComposite(BlendComposite.Add);
break;
case 9:
g.setComposite(BlendComposite.Subtract);
break;
case 10:
g.setComposite(BlendComposite.Invert);
break;
case 11:
g.setComposite(BlendComposite.Alpha);
break;
case 12:
g.setComposite(BlendComposite.Erase);
break;
case 13:
g.setComposite(BlendComposite.Overlay);
break;
case 14:
g.setComposite(BlendComposite.HardLight);
break;
default :
g.setComposite(AlphaComposite.SrcOver);
break;
}
if (layer.clipDepth > -1) {
BufferedImage mask=new BufferedImage(image.getWidth(),image.getHeight(),image.getType());
Graphics2D gm=(Graphics2D)mask.getGraphics();
gm.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
gm.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
gm.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
gm.setComposite(AlphaComposite.Src);
gm.setColor(new Color(0,0,0,0f));
gm.fillRect(0,0,image.getWidth(),image.getHeight());
gm.setTransform(trans);
gm.drawImage(img.getBufferedImage(),0,0,null);
Clip clip=new Clip(Helper.imageToShape(mask),layer.clipDepth);
clips.add(clip);
prevClips.add(g.getClip());
g.setTransform(AffineTransform.getTranslateInstance(0,0));
g.setClip(clip.shape);
}
 else {
g.setTransform(trans);
g.drawImage(img.getBufferedImage(),0,0,null);
}
}
 else if (character instanceof BoundedTag) {
showPlaceholder=true;
}
if (showPlaceholder) {
mat.translateX/=unzoom;
mat.translateY/=unzoom;
AffineTransform trans=mat.toTransform();
g.setTransform(trans);
BoundedTag b=(BoundedTag)character;
g.setPaint(new Color(255,255,255,128));
g.setComposite(BlendComposite.Invert);
RECT r=b.getRect();
int div=(int)unzoom;
g.drawString(character.toString(),r.Xmin / div + 3,r.Ymin / div + 15);
g.draw(new Rectangle(r.Xmin / div,r.Ymin / div,r.getWidth() / div,r.getHeight() / div));
g.drawLine(r.Xmin / div,r.Ymin / div,r.Xmax / div,r.Ymax / div);
g.drawLine(r.Xmax / div,r.Ymin / div,r.Xmin / div,r.Ymax / div);
g.setComposite(AlphaComposite.Dst);
}
}
g.setTransform(AffineTransform.getScaleInstance(1,1));
}","public static void frameToImage(Timeline timeline,int frame,int time,RenderContext renderContext,SerializableImage image,Matrix transformation,ColorTransform colorTransform){
  double unzoom=SWF.unitDivisor;
  if (timeline.getFrameCount() <= frame) {
    return;
  }
  Frame frameObj=timeline.getFrame(frame);
  Graphics2D g=(Graphics2D)image.getGraphics();
  g.setPaint(frameObj.backgroundColor.toColor());
  g.fill(new Rectangle(image.getWidth(),image.getHeight()));
  g.setTransform(transformation.toTransform());
  List<Clip> clips=new ArrayList<>();
  List<Shape> prevClips=new ArrayList<>();
  int maxDepth=timeline.getMaxDepth();
  for (int i=1; i <= maxDepth; i++) {
    for (int c=0; c < clips.size(); c++) {
      if (clips.get(c).depth == i) {
        g.setClip(prevClips.get(c));
        prevClips.remove(c);
        clips.remove(c);
      }
    }
    if (!frameObj.layers.containsKey(i)) {
      continue;
    }
    DepthState layer=frameObj.layers.get(i);
    if (!timeline.swf.getCharacters().containsKey(layer.characterId)) {
      continue;
    }
    if (!layer.isVisible) {
      continue;
    }
    CharacterTag character=timeline.swf.getCharacter(layer.characterId);
    Matrix mat=new Matrix(layer.matrix);
    mat=mat.preConcatenate(transformation);
    if (colorTransform == null) {
      colorTransform=new ColorTransform();
    }
    ColorTransform clrTrans=colorTransform.clone();
    if (layer.colorTransForm != null && layer.blendMode <= 1) {
      clrTrans=colorTransform.merge(layer.colorTransForm);
    }
    boolean showPlaceholder=false;
    if (character instanceof DrawableTag) {
      DrawableTag drawable=(DrawableTag)character;
      Matrix drawMatrix=new Matrix();
      int drawableFrameCount=drawable.getNumFrames();
      if (drawableFrameCount == 0) {
        drawableFrameCount=1;
      }
      int dframe=(time + layer.time) % drawableFrameCount;
      if (character instanceof ButtonTag) {
        dframe=ButtonTag.FRAME_UP;
        if (renderContext.stateUnderCursor == layer) {
          if (renderContext.mouseButton > 0) {
            dframe=ButtonTag.FRAME_DOWN;
          }
 else {
            dframe=ButtonTag.FRAME_OVER;
          }
        }
      }
      RECT boundRect=drawable.getRect();
      ExportRectangle rect=new ExportRectangle(boundRect);
      rect=mat.transform(rect);
      Matrix m=mat.clone();
      if (layer.filters != null && layer.filters.size() > 0) {
        double deltaXMax=0;
        double deltaYMax=0;
        for (        FILTER filter : layer.filters) {
          double x=filter.getDeltaX();
          double y=filter.getDeltaY();
          deltaXMax=Math.max(x,deltaXMax);
          deltaYMax=Math.max(y,deltaYMax);
        }
        rect.xMin-=deltaXMax * unzoom;
        rect.xMax+=deltaXMax * unzoom;
        rect.yMin-=deltaYMax * unzoom;
        rect.yMax+=deltaYMax * unzoom;
      }
      rect.xMin-=1 * unzoom;
      rect.yMin-=1 * unzoom;
      rect.xMin=Math.max(0,rect.xMin);
      rect.yMin=Math.max(0,rect.yMin);
      int newWidth=(int)(rect.getWidth() / unzoom);
      int newHeight=(int)(rect.getHeight() / unzoom);
      int deltaX=(int)(rect.xMin / unzoom);
      int deltaY=(int)(rect.yMin / unzoom);
      newWidth=Math.min(image.getWidth() - deltaX,newWidth) + 1;
      newHeight=Math.min(image.getHeight() - deltaY,newHeight) + 1;
      if (newWidth <= 0 || newHeight <= 0) {
        continue;
      }
      m.translate(-rect.xMin,-rect.yMin);
      drawMatrix.translate(rect.xMin,rect.yMin);
      SerializableImage img=null;
      String cacheKey=null;
      if (drawable instanceof ShapeTag) {
        cacheKey=((ShapeTag)drawable).getCharacterId() + m.toString() + clrTrans.toString();
        img=renderContext.shapeCache.get(cacheKey);
      }
      if (img == null) {
        img=new SerializableImage(newWidth,newHeight,SerializableImage.TYPE_INT_ARGB);
        img.fillTransparent();
        drawable.toImage(dframe,layer.time + time,layer.ratio,renderContext,img,m,clrTrans);
        if (cacheKey != null) {
          renderContext.shapeCache.put(cacheKey,img);
        }
      }
      if (layer.filters != null) {
        for (        FILTER filter : layer.filters) {
          img=filter.apply(img);
        }
      }
      if (layer.blendMode > 1) {
        if (layer.colorTransForm != null) {
          img=layer.colorTransForm.apply(img);
        }
      }
      drawMatrix.translateX/=unzoom;
      drawMatrix.translateY/=unzoom;
      AffineTransform trans=drawMatrix.toTransform();
switch (layer.blendMode) {
case 0:
case 1:
        g.setComposite(AlphaComposite.SrcOver);
      break;
case 2:
    g.setComposite(AlphaComposite.SrcOver);
  break;
case 3:
g.setComposite(BlendComposite.Multiply);
break;
case 4:
g.setComposite(BlendComposite.Screen);
break;
case 5:
g.setComposite(BlendComposite.Lighten);
break;
case 6:
g.setComposite(BlendComposite.Darken);
break;
case 7:
g.setComposite(BlendComposite.Difference);
break;
case 8:
g.setComposite(BlendComposite.Add);
break;
case 9:
g.setComposite(BlendComposite.Subtract);
break;
case 10:
g.setComposite(BlendComposite.Invert);
break;
case 11:
g.setComposite(BlendComposite.Alpha);
break;
case 12:
g.setComposite(BlendComposite.Erase);
break;
case 13:
g.setComposite(BlendComposite.Overlay);
break;
case 14:
g.setComposite(BlendComposite.HardLight);
break;
default :
g.setComposite(AlphaComposite.SrcOver);
break;
}
if (layer.clipDepth > -1) {
BufferedImage mask=new BufferedImage(image.getWidth(),image.getHeight(),image.getType());
Graphics2D gm=(Graphics2D)mask.getGraphics();
gm.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
gm.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
gm.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
gm.setComposite(AlphaComposite.Src);
gm.setColor(new Color(0,0,0,0f));
gm.fillRect(0,0,image.getWidth(),image.getHeight());
gm.setTransform(trans);
gm.drawImage(img.getBufferedImage(),0,0,null);
Clip clip=new Clip(Helper.imageToShape(mask),layer.clipDepth);
clips.add(clip);
prevClips.add(g.getClip());
g.setTransform(AffineTransform.getTranslateInstance(0,0));
g.setClip(clip.shape);
}
 else {
g.setTransform(trans);
g.drawImage(img.getBufferedImage(),0,0,null);
}
}
 else if (character instanceof BoundedTag) {
showPlaceholder=true;
}
if (showPlaceholder) {
mat.translateX/=unzoom;
mat.translateY/=unzoom;
AffineTransform trans=mat.toTransform();
g.setTransform(trans);
BoundedTag b=(BoundedTag)character;
g.setPaint(new Color(255,255,255,128));
g.setComposite(BlendComposite.Invert);
RECT r=b.getRect();
int div=(int)unzoom;
g.drawString(character.toString(),r.Xmin / div + 3,r.Ymin / div + 15);
g.draw(new Rectangle(r.Xmin / div,r.Ymin / div,r.getWidth() / div,r.getHeight() / div));
g.drawLine(r.Xmin / div,r.Ymin / div,r.Xmax / div,r.Ymax / div);
g.drawLine(r.Xmax / div,r.Ymin / div,r.Xmin / div,r.Ymax / div);
g.setComposite(AlphaComposite.Dst);
}
}
g.setTransform(AffineTransform.getScaleInstance(1,1));
}",0.997153024911032
61587,"public MainFrameRibbonMenu(MainFrameRibbon mainFrame,JRibbon ribbon,boolean externalFlashPlayerUnavailable){
  super(mainFrame);
  this.mainFrame=mainFrame;
  ribbon.addTask(createFileRibbonTask());
  ribbon.addTask(createToolsRibbonTask());
  ribbon.addTask(createSettingsRibbonTask(externalFlashPlayerUnavailable));
  ribbon.addTask(createHelpRibbonTask());
  if (Configuration.debugMode.get()) {
    ribbon.addTask(createDebugRibbonTask());
  }
  ribbon.setApplicationMenu(createMainMenu());
}","public MainFrameRibbonMenu(MainFrameRibbon mainFrame,JRibbon ribbon,boolean externalFlashPlayerUnavailable){
  super(mainFrame);
  this.mainFrame=mainFrame;
  ribbon.addTask(createFileRibbonTask());
  ribbon.addTask(createToolsRibbonTask());
  ribbon.addTask(createSettingsRibbonTask(externalFlashPlayerUnavailable));
  ribbon.addTask(createHelpRibbonTask());
  if (Configuration.showDebugMenu.get()) {
    ribbon.addTask(createDebugRibbonTask());
  }
  ribbon.setApplicationMenu(createMainMenu());
}",0.9879518072289156
61588,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_DEBUGGER_SWITCH:
    if (debuggerSwitchGroup.getSelected() == null || View.showConfirmDialog(mainFrame,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.INFORMATION_MESSAGE,Configuration.displayDebuggerInfo,JOptionPane.OK_OPTION) == JOptionPane.OK_OPTION) {
      switchDebugger();
      mainFrame.getPanel().refreshDecompiled();
    }
 else {
      if (debuggerSwitchGroup.getSelected() == debuggerSwitchCommandButton) {
        debuggerSwitchGroup.setSelected(debuggerSwitchCommandButton,false);
      }
    }
  debuggerReplaceTraceCommandButton.setEnabled(debuggerSwitchGroup.getSelected() == debuggerSwitchCommandButton);
break;
case ACTION_DEBUGGER_LOG:
debuggerShowLog();
break;
case ACTION_DEBUGGER_REPLACE_TRACE:
ReplaceTraceDialog rtd=new ReplaceTraceDialog(mainFrame,Configuration.lastDebuggerReplaceFunction.get());
rtd.setVisible(true);
if (rtd.getValue() != null) {
replaceTraceCalls(rtd.getValue());
mainFrame.getPanel().refreshDecompiled();
Configuration.lastDebuggerReplaceFunction.set(rtd.getValue());
}
break;
case ACTION_RELOAD:
reload();
break;
case ACTION_ADVANCED_SETTINGS:
advancedSettings();
break;
case ACTION_LOAD_MEMORY:
loadFromMemory();
break;
case ACTION_LOAD_CACHE:
loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
setLanguage();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.getPanel().disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected(),false);
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.getPanel().gotoDocumentClass(mainFrame.getPanel().getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.getPanel().reload(true);
break;
case ACTION_VIEWMODE_RESOURCES:
Configuration.dumpView.set(false);
mainFrame.getPanel().showView(MainPanel.VIEW_RESOURCES);
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,true);
break;
case ACTION_VIEWMODE_HEX_DUMP:
Configuration.dumpView.set(true);
mainFrame.getPanel().showView(MainPanel.VIEW_DUMP);
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
viewModeToggleGroup.setSelected(viewModeHexToggleButton,true);
break;
case ACTION_DEOBFUSCATION_MODE_OLD:
Configuration.deobfuscationMode.set(0);
mainFrame.getPanel().autoDeobfuscateChanged();
break;
case ACTION_DEOBFUSCATION_MODE_NEW:
Configuration.deobfuscationMode.set(1);
mainFrame.getPanel().autoDeobfuscateChanged();
break;
case ACTION_SEARCH:
search(null);
break;
case ACTION_REPLACE:
replace();
break;
case ACTION_TIMELINE:
timeLineToggleGroup.setSelected(timeLineToggleButton,timeLineToggleGroup.getSelected() == timeLineToggleButton);
if (timeLineToggleGroup.getSelected() == timeLineToggleButton) {
if (!mainFrame.getPanel().showView(MainPanel.VIEW_TIMELINE)) {
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
}
 else {
viewModeToggleGroup.setSelected(viewModeHexToggleButton,false);
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,false);
}
}
 else {
if (Configuration.dumpView.get()) {
viewModeToggleGroup.setSelected(viewModeHexToggleButton,true);
mainFrame.getPanel().showView(MainPanel.VIEW_DUMP);
}
 else {
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,true);
mainFrame.getPanel().showView(MainPanel.VIEW_RESOURCES);
}
}
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.getPanel(),translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.getPanel().autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_CLEAR_RECENT_FILES:
Configuration.recentFiles.set(null);
break;
case ACTION_EXIT:
exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
renameOneIdentifier();
break;
case ACTION_SHOW_PROXY:
showProxy();
break;
case ACTION_SUB_LIMITER:
setSubLimiter(((JCheckBox)e.getSource()).isSelected());
break;
case ACTION_SAVE:
save();
break;
case ACTION_SAVE_AS:
saveAs();
break;
case ACTION_SAVE_AS_EXE:
saveAsExe();
break;
case ACTION_OPEN:
open();
break;
case ACTION_CLOSE:
close();
break;
case ACTION_CLOSE_ALL:
closeAll();
break;
case ACTION_IMPORT_TEXT:
importText();
break;
case ACTION_IMPORT_SYMBOL_CLASS:
importSymbolClass();
break;
case ACTION_EXPORT_SWF_XML:
mainFrame.getPanel().exportSwfXml();
break;
case ACTION_IMPORT_SWF_XML:
mainFrame.getPanel().importSwfXml();
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().equals(ACTION_EXPORT_SEL);
export(onlySel);
break;
case ACTION_EXPORT_FLA:
exportFla();
break;
case ACTION_CHECK_UPDATES:
checkUpdates();
break;
case ACTION_HELP_US:
helpUs();
break;
case ACTION_HOMEPAGE:
homePage();
break;
case ACTION_ABOUT:
about();
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().equals(ACTION_RESTORE_CONTROL_FLOW_ALL);
restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
renameIdentifiers();
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
deobfuscate();
break;
case ACTION_REMOVE_NON_SCRIPTS:
removeNonScripts();
break;
case ACTION_REFRESH_DECOMPILED:
refreshDecompiled();
break;
case ACTION_CHECK_RESOURCES:
checkResources();
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_DEBUGGER_SWITCH:
    if (debuggerSwitchGroup.getSelected() == null || View.showConfirmDialog(mainFrame,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.INFORMATION_MESSAGE,Configuration.displayDebuggerInfo,JOptionPane.OK_OPTION) == JOptionPane.OK_OPTION) {
      switchDebugger();
      mainFrame.getPanel().refreshDecompiled();
    }
 else {
      if (debuggerSwitchGroup.getSelected() == debuggerSwitchCommandButton) {
        debuggerSwitchGroup.setSelected(debuggerSwitchCommandButton,false);
      }
    }
  debuggerReplaceTraceCommandButton.setEnabled(debuggerSwitchGroup.getSelected() == debuggerSwitchCommandButton);
break;
case ACTION_DEBUGGER_LOG:
debuggerShowLog();
break;
case ACTION_DEBUGGER_REPLACE_TRACE:
ReplaceTraceDialog rtd=new ReplaceTraceDialog(mainFrame,Configuration.lastDebuggerReplaceFunction.get());
rtd.setVisible(true);
if (rtd.getValue() != null) {
replaceTraceCalls(rtd.getValue());
mainFrame.getPanel().refreshDecompiled();
Configuration.lastDebuggerReplaceFunction.set(rtd.getValue());
}
break;
case ACTION_RELOAD:
reload();
break;
case ACTION_ADVANCED_SETTINGS:
advancedSettings();
break;
case ACTION_LOAD_MEMORY:
loadFromMemory();
break;
case ACTION_LOAD_CACHE:
loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
setLanguage();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.getPanel().disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected(),false);
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.getPanel().gotoDocumentClass(mainFrame.getPanel().getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.getPanel().reload(true);
break;
case ACTION_VIEWMODE_RESOURCES:
Configuration.dumpView.set(false);
mainFrame.getPanel().showView(MainPanel.VIEW_RESOURCES);
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,true);
break;
case ACTION_VIEWMODE_HEX_DUMP:
Configuration.dumpView.set(true);
mainFrame.getPanel().showView(MainPanel.VIEW_DUMP);
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
viewModeToggleGroup.setSelected(viewModeHexToggleButton,true);
break;
case ACTION_DEOBFUSCATION_MODE_OLD:
Configuration.deobfuscationMode.set(0);
mainFrame.getPanel().autoDeobfuscateChanged();
break;
case ACTION_DEOBFUSCATION_MODE_NEW:
Configuration.deobfuscationMode.set(1);
mainFrame.getPanel().autoDeobfuscateChanged();
break;
case ACTION_SEARCH:
search(null);
break;
case ACTION_REPLACE:
replace();
break;
case ACTION_TIMELINE:
timeLineToggleGroup.setSelected(timeLineToggleButton,timeLineToggleGroup.getSelected() == timeLineToggleButton);
if (timeLineToggleGroup.getSelected() == timeLineToggleButton) {
if (!mainFrame.getPanel().showView(MainPanel.VIEW_TIMELINE)) {
timeLineToggleGroup.setSelected(timeLineToggleButton,false);
}
 else {
viewModeToggleGroup.setSelected(viewModeHexToggleButton,false);
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,false);
}
}
 else {
if (Configuration.dumpView.get()) {
viewModeToggleGroup.setSelected(viewModeHexToggleButton,true);
mainFrame.getPanel().showView(MainPanel.VIEW_DUMP);
}
 else {
viewModeToggleGroup.setSelected(viewModeResourcesToggleButton,true);
mainFrame.getPanel().showView(MainPanel.VIEW_RESOURCES);
}
}
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.getPanel(),translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.getPanel().autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_CLEAR_RECENT_FILES:
Configuration.recentFiles.set(null);
break;
case ACTION_EXIT:
exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
renameOneIdentifier();
break;
case ACTION_SHOW_PROXY:
showProxy();
break;
case ACTION_SUB_LIMITER:
setSubLimiter(((JCheckBox)e.getSource()).isSelected());
break;
case ACTION_SAVE:
save();
break;
case ACTION_SAVE_AS:
saveAs();
break;
case ACTION_SAVE_AS_EXE:
saveAsExe();
break;
case ACTION_OPEN:
open();
break;
case ACTION_CLOSE:
close();
break;
case ACTION_CLOSE_ALL:
closeAll();
break;
case ACTION_IMPORT_TEXT:
importText();
break;
case ACTION_IMPORT_SYMBOL_CLASS:
importSymbolClass();
break;
case ACTION_EXPORT_SWF_XML:
mainFrame.getPanel().exportSwfXml();
break;
case ACTION_IMPORT_SWF_XML:
mainFrame.getPanel().importSwfXml();
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().equals(ACTION_EXPORT_SEL);
export(onlySel);
break;
case ACTION_EXPORT_FLA:
exportFla();
break;
case ACTION_CHECK_UPDATES:
checkUpdates();
break;
case ACTION_HELP_US:
helpUs();
break;
case ACTION_HOMEPAGE:
homePage();
break;
case ACTION_ABOUT:
about();
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().equals(ACTION_RESTORE_CONTROL_FLOW_ALL);
restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
renameIdentifiers();
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
deobfuscate();
break;
}
}",0.9875063190582798
61589,"private RibbonTask createDebugRibbonTask(){
  JRibbonBand debugBand=new JRibbonBand(""String_Node_Str"",null);
  debugBand.setResizePolicies(getResizePolicies(debugBand));
  JCommandButton removeNonScriptsCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),View.getResizableIcon(""String_Node_Str""));
  assignListener(removeNonScriptsCommandButton,ACTION_REMOVE_NON_SCRIPTS);
  JCommandButton refreshDecompiledCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),View.getResizableIcon(""String_Node_Str""));
  assignListener(refreshDecompiledCommandButton,ACTION_REFRESH_DECOMPILED);
  JCommandButton checkResourcesCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),View.getResizableIcon(""String_Node_Str""));
  assignListener(checkResourcesCommandButton,ACTION_CHECK_RESOURCES);
  debugBand.addCommandButton(removeNonScriptsCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(refreshDecompiledCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(checkResourcesCommandButton,RibbonElementPriority.MEDIUM);
  return new RibbonTask(""String_Node_Str"",debugBand);
}","private RibbonTask createDebugRibbonTask(){
  ResizableIcon icon=View.getResizableIcon(""String_Node_Str"");
  JRibbonBand debugBand=new JRibbonBand(""String_Node_Str"",null);
  debugBand.setResizePolicies(getResizePolicies(debugBand));
  JCommandButton removeNonScriptsCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),icon);
  removeNonScriptsCommandButton.addActionListener(e -> removeNonScripts());
  JCommandButton refreshDecompiledCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),icon);
  refreshDecompiledCommandButton.addActionListener(e -> refreshDecompiled());
  JCommandButton checkResourcesCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),icon);
  checkResourcesCommandButton.addActionListener(e -> checkResources());
  JCommandButton callGcCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),icon);
  callGcCommandButton.addActionListener(e -> System.gc());
  JCommandButton emptyCacheCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),icon);
  emptyCacheCommandButton.addActionListener(e -> {
    SWF swf=mainFrame.getPanel().getCurrentSwf();
    if (swf != null) {
      swf.clearAllCache();
    }
  }
);
  debugBand.addCommandButton(removeNonScriptsCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(refreshDecompiledCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(checkResourcesCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(callGcCommandButton,RibbonElementPriority.MEDIUM);
  debugBand.addCommandButton(emptyCacheCommandButton,RibbonElementPriority.MEDIUM);
  return new RibbonTask(""String_Node_Str"",debugBand);
}",0.4698837618879887
61590,"protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
switch (part.stopPartType) {
case AND_OR:
      part.setAndOrStack(stack);
    break;
case COMMONPART:
  part.setCommonPartStack(stack);
break;
case NONE:
break;
}
return ret;
}
if ((part != null) && (code.size() <= part.start)) {
ret.add(new ScriptEndItem());
return ret;
}
List<GraphTargetItem> currentRet=ret;
UniversalLoopItem loopItem=null;
if (isLoop) {
loopItem=new UniversalLoopItem(null,currentLoop);
currentRet.add(loopItem);
loopItem.commands=new ArrayList<>();
currentRet=loopItem.commands;
}
boolean parseNext=true;
List<GraphTargetItem> output=new ArrayList<>();
List<GraphPart> parts=new ArrayList<>();
if (part instanceof GraphPartMulti) {
parts=((GraphPartMulti)part).parts;
}
 else {
parts.add(part);
}
for (GraphPart p : parts) {
int end=p.end;
int start=p.start;
output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
output.add(new ScriptEndItem());
}
}
if (parseNext) {
List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
if (retCheck != null) {
if (!retCheck.isEmpty()) {
currentRet.addAll(retCheck);
}
parseNext=false;
}
 else {
currentRet.addAll(output);
}
}
if (parseNext && part.nextParts.size() == 2) {
if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (!reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((OrItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof AndItem) {
  o.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
 else if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((AndItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
}
if (parseNext) {
if (false && part.nextParts.size() > 2) {
GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
List<GraphPart> vis=new ArrayList<>();
GraphTargetItem switchedItem=stack.pop();
List<GraphTargetItem> caseValues=new ArrayList<>();
List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
List<GraphTargetItem> defaultCommands=new ArrayList<>();
List<Integer> valueMappings=new ArrayList<>();
Loop swLoop=new Loop(loops.size(),null,next);
swLoop.phase=1;
loops.add(swLoop);
boolean first=false;
int pos=0;
for (GraphPart p : part.nextParts) {
if (!first) {
caseValues.add(new IntegerValueItem(null,pos++));
if (vis.contains(p)) {
  valueMappings.add(caseCommands.size() - 1);
  continue;
}
valueMappings.add(caseCommands.size());
}
List<GraphPart> stopPart2=new ArrayList<>();
if (next != null) {
stopPart2.add(next);
}
 else if (!stopPart.isEmpty()) {
stopPart2.add(stopPart.get(stopPart.size() - 1));
}
for (GraphPart p2 : part.nextParts) {
if (p2 == p) {
  continue;
}
if (!stopPart2.contains(p2)) {
  stopPart2.add(p2);
}
}
if (next != p) {
if (first) {
  defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
 else {
  caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
}
vis.add(p);
}
first=false;
}
SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
currentRet.add(sw);
swLoop.phase=2;
if (next != null) {
currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
GraphPart nextOnePart=null;
if (part.nextParts.size() == 2) {
GraphTargetItem expr=stack.pop();
if (expr instanceof LogicalOpItem) {
expr=((LogicalOpItem)expr).invert();
}
 else {
expr=new NotItem(null,expr);
}
if (staticOperation != SOP_USE_STATIC) {
if (expr.isCompileTime()) {
boolean doJump=EcmaScript.toBoolean(expr.getResult());
if (doJump) {
  nextOnePart=part.nextParts.get(0);
}
 else {
  nextOnePart=part.nextParts.get(1);
}
if (staticOperation == SOP_REMOVE_STATIC) {
}
}
}
if (nextOnePart == null) {
List<GraphPart> nps;
nps=part.nextParts;
GraphPart next=getCommonPart(localData,nps,loops);
TranslateStack trueStack=(TranslateStack)stack.clone();
TranslateStack falseStack=(TranslateStack)stack.clone();
int trueStackSizeBefore=trueStack.size();
int falseStackSizeBefore=falseStack.size();
List<GraphTargetItem> onTrue=new ArrayList<>();
boolean isEmpty=nps.get(0) == nps.get(1);
if (isEmpty) {
next=nps.get(0);
}
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart.CommonPartStack commonPartStack=null;
if ((!isEmpty) && (next != null)) {
commonPartStack=next.new CommonPartStack();
if (next.commonPartStacks == null) {
  next.commonPartStacks=new ArrayList<>();
}
next.stopPartType=GraphPart.StopPartType.COMMONPART;
stopPart2.add(next);
}
if (!isEmpty) {
if (next != null) {
  next.commonPartStacks.add(commonPartStack);
  commonPartStack.isTrueStack=true;
}
onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
List<GraphTargetItem> onFalse=new ArrayList<>();
if (!isEmpty) {
if (next != null) {
  commonPartStack.isTrueStack=false;
}
onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
if ((!isEmpty) && (next != null)) {
if ((commonPartStack.trueStack != null) && (commonPartStack.falseStack != null)) {
  trueStack=commonPartStack.trueStack;
  falseStack=commonPartStack.falseStack;
}
next.commonPartStacks.remove(next.commonPartStacks.size() - 1);
if (next.commonPartStacks.isEmpty()) {
  next.stopPartType=GraphPart.StopPartType.NONE;
}
}
if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
}
 else {
currentRet.add(new IfItem(null,expr,onTrue,onFalse));
}
if (next != null) {
if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
  onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
    stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
  }
 else {
    currentRet.add(new IfItem(null,expr,onTrue,onFalse));
  }
}
 else {
  printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
}
}
if (part.nextParts.size() == 1) {
nextOnePart=part.nextParts.get(0);
}
if (nextOnePart != null) {
printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
if (isLoop) {
LoopItem li=loopItem;
boolean loopTypeFound=false;
boolean hasContinue=false;
processIfs(loopItem.commands);
checkContinueAtTheEnd(loopItem.commands,currentLoop);
List<ContinueItem> continues=loopItem.getContinues();
for (ContinueItem c : continues) {
if (c.loopId == currentLoop.id) {
hasContinue=true;
break;
}
}
if (!hasContinue) {
if (currentLoop.loopPreContinue != null) {
List<GraphPart> stopContPart=new ArrayList<>();
stopContPart.add(currentLoop.loopContinue);
GraphPart precoBackup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
loopItem.commands.addAll(printGraph(visited,localData,new TranslateStack(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(0) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(0);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
boolean breakpos2=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
 else if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
BreakItem bi=(BreakItem)loopItem.commands.get(1);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
  breakpos2=true;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
exprList.add(expr);
List<GraphTargetItem> commands=new ArrayList<>();
commands.addAll(bodyBranch);
loopItem.commands.remove(0);
if (breakpos2) {
  loopItem.commands.remove(0);
}
commands.addAll(loopItem.commands);
checkContinueAtTheEnd(commands,currentLoop);
List<GraphTargetItem> finalComm=new ArrayList<>();
if (currentLoop.loopPreContinue != null) {
  GraphPart backup=currentLoop.loopPreContinue;
  currentLoop.loopPreContinue=null;
  List<GraphPart> stopPart2=new ArrayList<>(stopPart);
  stopPart2.add(currentLoop.loopContinue);
  finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
  currentLoop.loopPreContinue=backup;
  checkContinueAtTheEnd(finalComm,currentLoop);
}
if (!finalComm.isEmpty()) {
  ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
}
 else {
  ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
checkContinueAtTheEnd(bodyBranch,currentLoop);
List<GraphTargetItem> commands=new ArrayList<>();
if (!bodyBranch.isEmpty()) {
  ret.add(index,loopItem);
}
 else {
  loopItem.commands.remove(loopItem.commands.size() - 1);
  commands.addAll(loopItem.commands);
  commands.addAll(bodyBranch);
  exprList.add(expr);
  checkContinueAtTheEnd(commands,currentLoop);
  ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound) {
if (currentLoop.loopPreContinue != null) {
loopTypeFound=true;
GraphPart backup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
stopPart2.add(currentLoop.loopContinue);
List<GraphTargetItem> finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
currentLoop.loopPreContinue=backup;
checkContinueAtTheEnd(finalComm,currentLoop);
if (!finalComm.isEmpty()) {
if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
  IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
  boolean ok=false;
  boolean invert=false;
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
    invert=true;
  }
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
  }
  if (ok) {
    finalComm.remove(finalComm.size() - 1);
    int index=ret.indexOf(loopItem);
    ret.remove(index);
    List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
    GraphTargetItem expr=ifi.expression;
    if (invert) {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
    }
    exprList.add(expr);
    ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
  }
}
}
}
}
if (!loopTypeFound) {
checkContinueAtTheEnd(loopItem.commands,currentLoop);
}
currentLoop.phase=2;
GraphTargetItem replaced=checkLoop(li,localData,loops);
if (replaced != li) {
int index=ret.indexOf(li);
ret.remove(index);
if (replaced != null) {
ret.add(index,replaced);
}
}
if (currentLoop.loopBreak != null) {
ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
return ret;
}","protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,TranslateStack stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
switch (part.stopPartType) {
case AND_OR:
      part.setAndOrStack(stack);
    break;
case COMMONPART:
  part.setCommonPartStack(stack);
break;
case NONE:
break;
}
return ret;
}
if ((part != null) && (code.size() <= part.start)) {
ret.add(new ScriptEndItem());
return ret;
}
List<GraphTargetItem> currentRet=ret;
UniversalLoopItem loopItem=null;
if (isLoop) {
loopItem=new UniversalLoopItem(null,currentLoop);
currentRet.add(loopItem);
loopItem.commands=new ArrayList<>();
currentRet=loopItem.commands;
}
boolean parseNext=true;
List<GraphTargetItem> output=new ArrayList<>();
List<GraphPart> parts=new ArrayList<>();
if (part instanceof GraphPartMulti) {
parts=((GraphPartMulti)part).parts;
}
 else {
parts.add(part);
}
for (GraphPart p : parts) {
int end=p.end;
int start=p.start;
output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
output.add(new ScriptEndItem());
}
}
if (parseNext) {
List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
if (retCheck != null) {
if (!retCheck.isEmpty()) {
currentRet.addAll(retCheck);
}
parseNext=false;
}
 else {
currentRet.addAll(output);
}
}
if (parseNext && part.nextParts.size() == 2) {
if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (!reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((OrItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof AndItem) {
  o.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
 else if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
boolean reversed=false;
loopContinues=getLoopsContinues(loops);
loopContinues.add(part);
if (sp1.leadsTo(localData,this,code,sp0,loops)) {
}
 else if (sp0.leadsTo(localData,this,code,sp1,loops)) {
reversed=true;
}
GraphPart next=reversed ? sp0 : sp1;
GraphTargetItem ti;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart andOrStopPart=reversed ? sp1 : sp0;
andOrStopPart.stopPartType=GraphPart.StopPartType.AND_OR;
stopPart2.add(andOrStopPart);
printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
stack=andOrStopPart.andOrStack;
GraphTargetItem second=stack.pop();
GraphTargetItem first=stack.pop();
andOrStopPart.stopPartType=GraphPart.StopPartType.NONE;
if (reversed) {
AndItem a=new AndItem(null,first,second);
stack.push(a);
a.firstPart=part;
if (second instanceof AndItem) {
  a.firstPart=((AndItem)second).firstPart;
}
if (second instanceof OrItem) {
  a.firstPart=((OrItem)second).firstPart;
}
}
 else {
OrItem o=new OrItem(null,first,second);
stack.push(o);
o.firstPart=part;
if (second instanceof OrItem) {
  o.firstPart=((OrItem)second).firstPart;
}
if (second instanceof AndItem) {
  o.firstPart=((AndItem)second).firstPart;
}
}
next=reversed ? sp1 : sp0;
if ((ti=checkLoop(next,stopPart,loops)) != null) {
currentRet.add(ti);
}
 else {
currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
parseNext=false;
}
}
if (parseNext) {
if (false && part.nextParts.size() > 2) {
GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
List<GraphPart> vis=new ArrayList<>();
GraphTargetItem switchedItem=stack.pop();
List<GraphTargetItem> caseValues=new ArrayList<>();
List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
List<GraphTargetItem> defaultCommands=new ArrayList<>();
List<Integer> valueMappings=new ArrayList<>();
Loop swLoop=new Loop(loops.size(),null,next);
swLoop.phase=1;
loops.add(swLoop);
boolean first=false;
int pos=0;
for (GraphPart p : part.nextParts) {
if (!first) {
caseValues.add(new IntegerValueItem(null,pos++));
if (vis.contains(p)) {
  valueMappings.add(caseCommands.size() - 1);
  continue;
}
valueMappings.add(caseCommands.size());
}
List<GraphPart> stopPart2=new ArrayList<>();
if (next != null) {
stopPart2.add(next);
}
 else if (!stopPart.isEmpty()) {
stopPart2.add(stopPart.get(stopPart.size() - 1));
}
for (GraphPart p2 : part.nextParts) {
if (p2 == p) {
  continue;
}
if (!stopPart2.contains(p2)) {
  stopPart2.add(p2);
}
}
if (next != p) {
if (first) {
  defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
 else {
  caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
}
vis.add(p);
}
first=false;
}
SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
currentRet.add(sw);
swLoop.phase=2;
if (next != null) {
currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
GraphPart nextOnePart=null;
if (part.nextParts.size() == 2) {
GraphTargetItem expr=stack.pop();
if (expr instanceof LogicalOpItem) {
expr=((LogicalOpItem)expr).invert();
}
 else {
expr=new NotItem(null,expr);
}
if (staticOperation != SOP_USE_STATIC) {
if (expr.isCompileTime()) {
boolean doJump=EcmaScript.toBoolean(expr.getResult());
if (doJump) {
  nextOnePart=part.nextParts.get(0);
}
 else {
  nextOnePart=part.nextParts.get(1);
}
if (staticOperation == SOP_REMOVE_STATIC) {
}
}
}
if (nextOnePart == null) {
List<GraphPart> nps;
nps=part.nextParts;
GraphPart next=getCommonPart(localData,nps,loops);
TranslateStack trueStack=(TranslateStack)stack.clone();
TranslateStack falseStack=(TranslateStack)stack.clone();
int trueStackSizeBefore=trueStack.size();
int falseStackSizeBefore=falseStack.size();
List<GraphTargetItem> onTrue=new ArrayList<>();
boolean isEmpty=nps.get(0) == nps.get(1);
if (isEmpty) {
next=nps.get(0);
}
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
GraphPart.CommonPartStack commonPartStack=null;
if ((!isEmpty) && (next != null)) {
commonPartStack=next.new CommonPartStack();
if (next.commonPartStacks == null) {
  next.commonPartStacks=new ArrayList<>();
}
next.stopPartType=GraphPart.StopPartType.COMMONPART;
stopPart2.add(next);
}
if (!isEmpty) {
if (next != null) {
  next.commonPartStacks.add(commonPartStack);
  commonPartStack.isTrueStack=true;
}
onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
List<GraphTargetItem> onFalse=new ArrayList<>();
if (!isEmpty) {
if (next != null) {
  commonPartStack.isTrueStack=false;
}
onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
}
if ((!isEmpty) && (next != null)) {
if ((commonPartStack.trueStack != null) && (commonPartStack.falseStack != null)) {
  trueStack=commonPartStack.trueStack;
  falseStack=commonPartStack.falseStack;
}
next.commonPartStacks.remove(next.commonPartStacks.size() - 1);
if (next.commonPartStacks.isEmpty()) {
  next.stopPartType=GraphPart.StopPartType.NONE;
}
}
if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
}
 else {
currentRet.add(new IfItem(null,expr,onTrue,onFalse));
}
if (next != null) {
if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
  onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
  if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
    stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
  }
 else {
    currentRet.add(new IfItem(null,expr,onTrue,onFalse));
  }
}
 else {
  printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
}
}
if (part.nextParts.size() == 1) {
nextOnePart=part.nextParts.get(0);
}
if (nextOnePart != null) {
printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
}
}
if (isLoop) {
LoopItem li=loopItem;
boolean loopTypeFound=false;
boolean hasContinue=false;
processIfs(loopItem.commands);
checkContinueAtTheEnd(loopItem.commands,currentLoop);
List<ContinueItem> continues=loopItem.getContinues();
for (ContinueItem c : continues) {
if (c.loopId == currentLoop.id) {
hasContinue=true;
break;
}
}
if (!hasContinue) {
if (currentLoop.loopPreContinue != null) {
List<GraphPart> stopContPart=new ArrayList<>();
stopContPart.add(currentLoop.loopContinue);
GraphPart precoBackup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
loopItem.commands.addAll(printGraph(visited,localData,new TranslateStack(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(0) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(0);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
boolean breakpos2=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
 else if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
BreakItem bi=(BreakItem)loopItem.commands.get(1);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
  breakpos2=true;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
exprList.add(expr);
List<GraphTargetItem> commands=new ArrayList<>();
commands.addAll(bodyBranch);
loopItem.commands.remove(0);
if (breakpos2) {
  loopItem.commands.remove(0);
}
commands.addAll(loopItem.commands);
checkContinueAtTheEnd(commands,currentLoop);
List<GraphTargetItem> finalComm=new ArrayList<>();
if (currentLoop.loopPreContinue != null) {
  GraphPart backup=currentLoop.loopPreContinue;
  currentLoop.loopPreContinue=null;
  List<GraphPart> stopPart2=new ArrayList<>(stopPart);
  stopPart2.add(currentLoop.loopContinue);
  finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
  currentLoop.loopPreContinue=backup;
  checkContinueAtTheEnd(finalComm,currentLoop);
}
if (!finalComm.isEmpty()) {
  ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
}
 else {
  ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
List<GraphTargetItem> bodyBranch=null;
boolean inverted=false;
if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onTrue.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onFalse;
  inverted=true;
}
}
 else if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
BreakItem bi=(BreakItem)ifi.onFalse.get(0);
if (bi.loopId == currentLoop.id) {
  bodyBranch=ifi.onTrue;
}
}
if (bodyBranch != null) {
int index=ret.indexOf(loopItem);
ret.remove(index);
List<GraphTargetItem> exprList=new ArrayList<>();
GraphTargetItem expr=ifi.expression;
if (inverted) {
  if (expr instanceof LogicalOpItem) {
    expr=((LogicalOpItem)expr).invert();
  }
 else {
    expr=new NotItem(null,expr);
  }
}
checkContinueAtTheEnd(bodyBranch,currentLoop);
List<GraphTargetItem> commands=new ArrayList<>();
if (!bodyBranch.isEmpty()) {
  ret.add(index,loopItem);
}
 else {
  loopItem.commands.remove(loopItem.commands.size() - 1);
  commands.addAll(loopItem.commands);
  commands.addAll(bodyBranch);
  exprList.add(expr);
  checkContinueAtTheEnd(commands,currentLoop);
  ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
}
loopTypeFound=true;
}
}
}
if (!loopTypeFound) {
if (currentLoop.loopPreContinue != null) {
loopTypeFound=true;
GraphPart backup=currentLoop.loopPreContinue;
currentLoop.loopPreContinue=null;
List<GraphPart> stopPart2=new ArrayList<>(stopPart);
stopPart2.add(currentLoop.loopContinue);
List<GraphTargetItem> finalComm=printGraph(visited,localData,new TranslateStack(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
currentLoop.loopPreContinue=backup;
checkContinueAtTheEnd(finalComm,currentLoop);
if (!finalComm.isEmpty()) {
if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
  IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
  boolean ok=false;
  boolean invert=false;
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
    invert=true;
  }
  if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
    ok=true;
  }
  if (ok) {
    finalComm.remove(finalComm.size() - 1);
    int index=ret.indexOf(loopItem);
    ret.remove(index);
    List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
    GraphTargetItem expr=ifi.expression;
    if (invert) {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
    }
    exprList.add(expr);
    ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
  }
}
}
}
}
if (!loopTypeFound) {
checkContinueAtTheEnd(loopItem.commands,currentLoop);
}
currentLoop.phase=2;
GraphTargetItem replaced=checkLoop(li,localData,loops);
if (replaced != li) {
int index=ret.indexOf(li);
ret.remove(index);
if (replaced != null) {
ret.add(index,replaced);
}
}
if (currentLoop.loopBreak != null) {
ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
}
}
return ret;
}",0.988332435828397
61591,"public void reload(boolean forceReload){
  closeTag();
  if (Configuration.dumpView.get()) {
    dumpViewReload(forceReload);
    return;
  }
  TreeItem treeItem=(TreeItem)tagTree.getLastSelectedPathComponent();
  if (treeItem == null) {
    return;
  }
  if (!forceReload && (treeItem == oldItem)) {
    return;
  }
  oldItem=treeItem;
  boolean preferScript=false;
  if (treeItem instanceof TagScript) {
    treeItem=((TagScript)treeItem).getTag();
    preferScript=true;
  }
  folderPreviewPanel.setItems(new ArrayList<TreeItem>());
  previewPanel.clear();
  stopFlashPlayer();
  if (treeItem instanceof ScriptPack) {
    final ScriptPack scriptLeaf=(ScriptPack)treeItem;
    if (setSourceWorker != null) {
      setSourceWorker.cancel(true);
      setSourceWorker=null;
    }
    if (!Main.isWorking()) {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      CancellableWorker worker=new CancellableWorker(){
        @Override protected Void doInBackground() throws Exception {
          getABCPanel().detailPanel.methodTraitPanel.methodCodePanel.clear();
          getABCPanel().navigator.setAbc(scriptLeaf.abc);
          getABCPanel().setAbc(scriptLeaf.abc);
          getABCPanel().decompiledTextArea.setScript(scriptLeaf);
          getABCPanel().decompiledTextArea.setNoTrait();
          return null;
        }
        @Override protected void done(){
          Main.stopWork();
          View.execInEventDispatch(new Runnable(){
            @Override public void run(){
              setSourceWorker=null;
              try {
                get();
              }
 catch (              CancellationException ex) {
                getABCPanel().decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
              }
catch (              Exception ex) {
                getABCPanel().decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ ex);
              }
            }
          }
);
        }
      }
;
      worker.execute();
      setSourceWorker=worker;
      Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"",worker);
    }
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPT3PANEL);
    return;
  }
 else {
    showDetail(DETAILCARDEMPTYPANEL);
  }
  previewPanel.setImageReplaceButtonVisible(false);
  boolean internalViewer=isInternalFlashViewerSelected();
  if (treeItem instanceof HeaderItem) {
    showCard(CARDHEADER);
    headerPanel.load(((HeaderItem)treeItem).getSwf());
  }
 else   if (treeItem instanceof FolderItem) {
    showCard(CARDFOLDERPREVIEWPANEL);
    showFolderPreview(treeItem);
  }
 else   if (treeItem instanceof SWF) {
    SWF swf=(SWF)treeItem;
    showCard(CARDPREVIEWPANEL);
    if (internalViewer) {
      previewPanel.showImagePanel(swf,swf,-1);
    }
 else {
      previewPanel.setParametersPanelVisible(false);
      if (flashPanel != null) {
        previewPanel.showFlashViewerPanel();
        previewPanel.showSwf(swf);
      }
    }
  }
 else   if (treeItem instanceof DefineBinaryDataTag) {
    DefineBinaryDataTag binaryTag=(DefineBinaryDataTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    previewPanel.showBinaryPanel(binaryTag);
  }
 else   if (treeItem instanceof ASMSource && (!(treeItem instanceof DrawableTag) || preferScript)) {
    ensureActionPanel();
    showCard(CARDACTIONSCRIPTPANEL);
    getActionPanel().setSource((ASMSource)treeItem,!forceReload);
  }
 else   if (treeItem instanceof ImageTag) {
    ImageTag imageTag=(ImageTag)treeItem;
    previewPanel.setImageReplaceButtonVisible(imageTag.importSupported());
    showCard(CARDPREVIEWPANEL);
    previewPanel.showImagePanel(imageTag.getImage());
  }
 else   if ((treeItem instanceof DrawableTag) && (!(treeItem instanceof TextTag)) && (!(treeItem instanceof FontTag))&& internalViewer) {
    final Tag tag=(Tag)treeItem;
    showCard(CARDPREVIEWPANEL);
    DrawableTag d=(DrawableTag)tag;
    Timelined timelined;
    if (treeItem instanceof Timelined && !(treeItem instanceof ButtonTag)) {
      timelined=(Timelined)tag;
    }
 else {
      timelined=makeTimelined(tag);
    }
    previewPanel.setParametersPanelVisible(false);
    previewPanel.showImagePanel(timelined,tag.getSwf(),-1);
  }
 else   if ((treeItem instanceof FontTag) && internalViewer) {
    FontTag fontTag=(FontTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    showFontTag(fontTag);
  }
 else   if ((treeItem instanceof TextTag) && internalViewer) {
    TextTag textTag=(TextTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    showTextTag(textTag);
  }
 else   if (treeItem instanceof Frame && internalViewer) {
    showCard(CARDPREVIEWPANEL);
    Frame fn=(Frame)treeItem;
    SWF swf=fn.getSwf();
    List<Tag> controlTags=swf.tags;
    int containerId=0;
    RECT rect=swf.displayRect;
    int totalFrameCount=swf.frameCount;
    Timelined timelined=swf;
    if (fn.timeline.timelined instanceof DefineSpriteTag) {
      DefineSpriteTag parentSprite=(DefineSpriteTag)fn.timeline.timelined;
      controlTags=parentSprite.subTags;
      containerId=parentSprite.spriteId;
      rect=parentSprite.getRect();
      totalFrameCount=parentSprite.frameCount;
      timelined=parentSprite;
    }
    previewPanel.showImagePanel(timelined,swf,fn.frame);
  }
 else   if ((treeItem instanceof SoundTag)) {
    showCard(CARDPREVIEWPANEL);
    previewPanel.showImagePanel(new SerializableImage(View.loadImage(""String_Node_Str"")));
    previewPanel.setImageReplaceButtonVisible(treeItem instanceof DefineSoundTag);
    try {
      SoundTagPlayer soundThread=new SoundTagPlayer((SoundTag)treeItem,Integer.MAX_VALUE,true);
      previewPanel.setMedia(soundThread);
    }
 catch (    LineUnavailableException|IOException|UnsupportedAudioFileException ex) {
      logger.log(Level.SEVERE,null,ex);
    }
  }
 else   if ((treeItem instanceof Frame) || ((treeItem instanceof CharacterTag) || (treeItem instanceof FontTag)) && (treeItem instanceof Tag) || (treeItem instanceof SoundStreamHeadTypeTag)) {
    showCard(CARDPREVIEWPANEL);
    previewPanel.createAndShowTempSwf(treeItem);
    if (treeItem instanceof TextTag) {
      showTextTag((TextTag)treeItem);
    }
 else     if (treeItem instanceof FontTag) {
      showFontTag((FontTag)treeItem);
    }
 else {
      previewPanel.setParametersPanelVisible(false);
    }
  }
 else   if (treeItem instanceof Tag) {
    showGenericTag((Tag)treeItem);
  }
 else {
    showCard(CARDEMPTYPANEL);
  }
}","public void reload(boolean forceReload){
  if (Configuration.dumpView.get()) {
    dumpViewReload(forceReload);
    return;
  }
  TreeItem treeItem=(TreeItem)tagTree.getLastSelectedPathComponent();
  if (treeItem == null) {
    return;
  }
  if (!forceReload && (treeItem == oldItem)) {
    return;
  }
  if (oldItem != treeItem) {
    closeTag();
  }
  oldItem=treeItem;
  boolean preferScript=false;
  if (treeItem instanceof TagScript) {
    treeItem=((TagScript)treeItem).getTag();
    preferScript=true;
  }
  folderPreviewPanel.setItems(new ArrayList<>());
  previewPanel.clear();
  stopFlashPlayer();
  if (treeItem instanceof ScriptPack) {
    final ScriptPack scriptLeaf=(ScriptPack)treeItem;
    if (setSourceWorker != null) {
      setSourceWorker.cancel(true);
      setSourceWorker=null;
    }
    if (!Main.isWorking()) {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      CancellableWorker worker=new CancellableWorker(){
        @Override protected Void doInBackground() throws Exception {
          getABCPanel().detailPanel.methodTraitPanel.methodCodePanel.clear();
          getABCPanel().navigator.setAbc(scriptLeaf.abc);
          getABCPanel().setAbc(scriptLeaf.abc);
          getABCPanel().decompiledTextArea.setScript(scriptLeaf);
          getABCPanel().decompiledTextArea.setNoTrait();
          return null;
        }
        @Override protected void done(){
          Main.stopWork();
          View.execInEventDispatch(new Runnable(){
            @Override public void run(){
              setSourceWorker=null;
              try {
                get();
              }
 catch (              CancellationException ex) {
                getABCPanel().decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
              }
catch (              Exception ex) {
                getABCPanel().decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ ex);
              }
            }
          }
);
        }
      }
;
      worker.execute();
      setSourceWorker=worker;
      Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"",worker);
    }
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPT3PANEL);
    return;
  }
 else {
    showDetail(DETAILCARDEMPTYPANEL);
  }
  previewPanel.setImageReplaceButtonVisible(false);
  boolean internalViewer=isInternalFlashViewerSelected();
  if (treeItem instanceof HeaderItem) {
    showCard(CARDHEADER);
    headerPanel.load(((HeaderItem)treeItem).getSwf());
  }
 else   if (treeItem instanceof FolderItem) {
    showCard(CARDFOLDERPREVIEWPANEL);
    showFolderPreview(treeItem);
  }
 else   if (treeItem instanceof SWF) {
    SWF swf=(SWF)treeItem;
    showCard(CARDPREVIEWPANEL);
    if (internalViewer) {
      previewPanel.showImagePanel(swf,swf,-1);
    }
 else {
      previewPanel.setParametersPanelVisible(false);
      if (flashPanel != null) {
        previewPanel.showFlashViewerPanel();
        previewPanel.showSwf(swf);
      }
    }
  }
 else   if (treeItem instanceof DefineBinaryDataTag) {
    DefineBinaryDataTag binaryTag=(DefineBinaryDataTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    previewPanel.showBinaryPanel(binaryTag);
  }
 else   if (treeItem instanceof ASMSource && (!(treeItem instanceof DrawableTag) || preferScript)) {
    ensureActionPanel();
    showCard(CARDACTIONSCRIPTPANEL);
    getActionPanel().setSource((ASMSource)treeItem,!forceReload);
  }
 else   if (treeItem instanceof ImageTag) {
    ImageTag imageTag=(ImageTag)treeItem;
    previewPanel.setImageReplaceButtonVisible(imageTag.importSupported());
    showCard(CARDPREVIEWPANEL);
    previewPanel.showImagePanel(imageTag.getImage());
  }
 else   if ((treeItem instanceof DrawableTag) && (!(treeItem instanceof TextTag)) && (!(treeItem instanceof FontTag))&& internalViewer) {
    final Tag tag=(Tag)treeItem;
    showCard(CARDPREVIEWPANEL);
    DrawableTag d=(DrawableTag)tag;
    Timelined timelined;
    if (treeItem instanceof Timelined && !(treeItem instanceof ButtonTag)) {
      timelined=(Timelined)tag;
    }
 else {
      timelined=makeTimelined(tag);
    }
    previewPanel.setParametersPanelVisible(false);
    previewPanel.showImagePanel(timelined,tag.getSwf(),-1);
  }
 else   if ((treeItem instanceof FontTag) && internalViewer) {
    FontTag fontTag=(FontTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    showFontTag(fontTag);
  }
 else   if ((treeItem instanceof TextTag) && internalViewer) {
    TextTag textTag=(TextTag)treeItem;
    showCard(CARDPREVIEWPANEL);
    showTextTag(textTag);
  }
 else   if (treeItem instanceof Frame && internalViewer) {
    showCard(CARDPREVIEWPANEL);
    Frame fn=(Frame)treeItem;
    SWF swf=fn.getSwf();
    List<Tag> controlTags=swf.tags;
    int containerId=0;
    RECT rect=swf.displayRect;
    int totalFrameCount=swf.frameCount;
    Timelined timelined=swf;
    if (fn.timeline.timelined instanceof DefineSpriteTag) {
      DefineSpriteTag parentSprite=(DefineSpriteTag)fn.timeline.timelined;
      controlTags=parentSprite.subTags;
      containerId=parentSprite.spriteId;
      rect=parentSprite.getRect();
      totalFrameCount=parentSprite.frameCount;
      timelined=parentSprite;
    }
    previewPanel.showImagePanel(timelined,swf,fn.frame);
  }
 else   if ((treeItem instanceof SoundTag)) {
    showCard(CARDPREVIEWPANEL);
    previewPanel.showImagePanel(new SerializableImage(View.loadImage(""String_Node_Str"")));
    previewPanel.setImageReplaceButtonVisible(treeItem instanceof DefineSoundTag);
    try {
      SoundTagPlayer soundThread=new SoundTagPlayer((SoundTag)treeItem,Integer.MAX_VALUE,true);
      previewPanel.setMedia(soundThread);
    }
 catch (    LineUnavailableException|IOException|UnsupportedAudioFileException ex) {
      logger.log(Level.SEVERE,null,ex);
    }
  }
 else   if ((treeItem instanceof Frame) || ((treeItem instanceof CharacterTag) || (treeItem instanceof FontTag)) && (treeItem instanceof Tag) || (treeItem instanceof SoundStreamHeadTypeTag)) {
    showCard(CARDPREVIEWPANEL);
    previewPanel.createAndShowTempSwf(treeItem);
    if (treeItem instanceof TextTag) {
      showTextTag((TextTag)treeItem);
    }
 else     if (treeItem instanceof FontTag) {
      showFontTag((FontTag)treeItem);
    }
 else {
      previewPanel.setParametersPanelVisible(false);
    }
  }
 else   if (treeItem instanceof Tag) {
    showGenericTag((Tag)treeItem);
  }
 else {
    showCard(CARDEMPTYPANEL);
  }
}",0.9945372008925136
61592,"public void closeTag(){
  if (modified && Configuration.autoSaveTagModifications.get()) {
    saveText();
  }
  textTag=null;
}","public void closeTag(){
  if (modified && Configuration.autoSaveTagModifications.get()) {
    saveText(false);
  }
  textTag=null;
}",0.9806949806949808
61593,"public TextPanel(final MainPanel mainPanel){
  super(new BorderLayout());
  DefaultSyntaxKit.initKit();
  this.mainPanel=mainPanel;
  textSearchPanel=new SearchPanel<>(new FlowLayout(),mainPanel);
  textSearchPanel.setAlignmentX(0);
  JPanel topPanel=new JPanel();
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  topPanel.add(textSearchPanel);
  textValue=new LineMarkedEditorPane();
  add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setFont(new Font(""String_Node_Str"",Font.PLAIN,textValue.getFont().getSize()));
  textValue.setContentType(""String_Node_Str"");
  textValue.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      textChanged();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      textChanged();
    }
    @Override public void changedUpdate(    DocumentEvent e){
      textChanged();
    }
  }
);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout(SwingConstants.WEST));
  textAlignLeftButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.LEFT));
  textAlignCenterButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.CENTER));
  textAlignRightButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.RIGHT));
  textAlignJustifyButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.JUSTIFY));
  decreaseTranslateXButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> translateX(-(int)SWF.unitDivisor,((JRepeatButton)e.getSource()).getRepeatCount()),true);
  increaseTranslateXButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> translateX((int)SWF.unitDivisor,((JRepeatButton)e.getSource()).getRepeatCount()),true);
  undoChangesButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> undoChanges());
  textButtonsPanel.add(textAlignLeftButton);
  textButtonsPanel.add(textAlignCenterButton);
  textButtonsPanel.add(textAlignRightButton);
  textButtonsPanel.add(textAlignJustifyButton);
  textButtonsPanel.add(decreaseTranslateXButton);
  textButtonsPanel.add(increaseTranslateXButton);
  textButtonsPanel.add(undoChangesButton);
  textButtonsPanel.setAlignmentX(0);
  topPanel.add(textButtonsPanel);
  add(topPanel,BorderLayout.NORTH);
  JPanel buttonsPanel=new JPanel(new FlowLayout());
  textEditButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> editText());
  textSaveButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> saveText());
  textCancelButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> cancelText());
  buttonsPanel.add(textEditButton);
  buttonsPanel.add(textSaveButton);
  buttonsPanel.add(textCancelButton);
  add(buttonsPanel,BorderLayout.SOUTH);
}","public TextPanel(final MainPanel mainPanel){
  super(new BorderLayout());
  DefaultSyntaxKit.initKit();
  this.mainPanel=mainPanel;
  textSearchPanel=new SearchPanel<>(new FlowLayout(),mainPanel);
  textSearchPanel.setAlignmentX(0);
  JPanel topPanel=new JPanel();
  topPanel.setLayout(new BoxLayout(topPanel,BoxLayout.Y_AXIS));
  topPanel.add(textSearchPanel);
  textValue=new LineMarkedEditorPane();
  add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setFont(new Font(""String_Node_Str"",Font.PLAIN,textValue.getFont().getSize()));
  textValue.setContentType(""String_Node_Str"");
  textValue.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void insertUpdate(    DocumentEvent e){
      textChanged();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      textChanged();
    }
    @Override public void changedUpdate(    DocumentEvent e){
      textChanged();
    }
  }
);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout(SwingConstants.WEST));
  textAlignLeftButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.LEFT));
  textAlignCenterButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.CENTER));
  textAlignRightButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.RIGHT));
  textAlignJustifyButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> textAlign(TextAlign.JUSTIFY));
  decreaseTranslateXButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> translateX(-(int)SWF.unitDivisor,((JRepeatButton)e.getSource()).getRepeatCount()),true);
  increaseTranslateXButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> translateX((int)SWF.unitDivisor,((JRepeatButton)e.getSource()).getRepeatCount()),true);
  undoChangesButton=createButton(null,""String_Node_Str"",""String_Node_Str"",e -> undoChanges());
  textButtonsPanel.add(textAlignLeftButton);
  textButtonsPanel.add(textAlignCenterButton);
  textButtonsPanel.add(textAlignRightButton);
  textButtonsPanel.add(textAlignJustifyButton);
  textButtonsPanel.add(decreaseTranslateXButton);
  textButtonsPanel.add(increaseTranslateXButton);
  textButtonsPanel.add(undoChangesButton);
  textButtonsPanel.setAlignmentX(0);
  topPanel.add(textButtonsPanel);
  add(topPanel,BorderLayout.NORTH);
  JPanel buttonsPanel=new JPanel(new FlowLayout());
  textEditButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> editText());
  textSaveButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> saveText(true));
  textCancelButton=createButton(""String_Node_Str"",""String_Node_Str"",null,e -> cancelText());
  buttonsPanel.add(textEditButton);
  buttonsPanel.add(textSaveButton);
  buttonsPanel.add(textCancelButton);
  add(buttonsPanel,BorderLayout.SOUTH);
}",0.9992977528089888
61594,"private void saveText(){
  if (mainPanel.saveText(textTag,textValue.getText(),null)) {
    setEditText(false);
    modified=false;
    textTag.getSwf().clearImageCache();
    mainPanel.refreshTree();
  }
}","private void saveText(boolean refresh){
  if (mainPanel.saveText(textTag,textValue.getText(),null)) {
    setEditText(false);
    modified=false;
    textTag.getSwf().clearImageCache();
    if (refresh) {
      mainPanel.refreshTree();
    }
  }
}",0.9070796460176992
61595,"public static SerializableImage frameToImageGet(Timeline timeline,int frame,int time,DepthState stateUnderCursor,int mouseButton,RECT displayRect,Matrix transformation,ColorTransform colorTransform,Color backGroundColor,boolean useCache,double zoom){
  String key=""String_Node_Str"" + frame + ""String_Node_Str""+ timeline.id+ ""String_Node_Str""+ timeline.swf.hashCode()+ ""String_Node_Str""+ zoom;
  SerializableImage image;
  if (useCache) {
    image=getFromCache(key);
    if (image != null) {
      return image;
    }
  }
  if (timeline.getFrameCount() == 0) {
    return new SerializableImage(1,1,SerializableImage.TYPE_INT_ARGB);
  }
  RECT rect=displayRect;
  image=new SerializableImage((int)(rect.getWidth() * zoom / SWF.unitDivisor) + 1,(int)(rect.getHeight() * zoom / SWF.unitDivisor) + 1,SerializableImage.TYPE_INT_ARGB);
  if (backGroundColor == null) {
    image.fillTransparent();
  }
 else {
    Graphics2D g=(Graphics2D)image.getBufferedImage().getGraphics();
    g.setComposite(AlphaComposite.Src);
    g.setColor(backGroundColor);
    g.fill(new Rectangle(image.getWidth(),image.getHeight()));
  }
  Matrix m=transformation.clone();
  m.translate(-rect.Xmin,-rect.Ymin);
  m.scale(zoom);
  RenderContext renderContext=new RenderContext();
  renderContext.stateUnderCursor=stateUnderCursor;
  renderContext.mouseButton=mouseButton;
  frameToImage(timeline,frame,time,renderContext,image,m,colorTransform);
  if (useCache) {
    putToCache(key,image);
  }
  return image;
}","public static SerializableImage frameToImageGet(Timeline timeline,int frame,int time,DepthState stateUnderCursor,int mouseButton,RECT displayRect,Matrix transformation,ColorTransform colorTransform,Color backGroundColor,boolean useCache,double zoom){
  String key=""String_Node_Str"" + frame + ""String_Node_Str""+ timeline.id+ ""String_Node_Str""+ timeline.swf.hashCode()+ ""String_Node_Str""+ zoom;
  SerializableImage image;
  if (useCache) {
    image=getFromCache(key);
    if (image != null) {
      return image;
    }
  }
  if (timeline.getFrameCount() == 0) {
    return new SerializableImage(1,1,SerializableImage.TYPE_INT_ARGB);
  }
  RECT rect=displayRect;
  image=new SerializableImage((int)(rect.getWidth() * zoom / SWF.unitDivisor) + 1,(int)(rect.getHeight() * zoom / SWF.unitDivisor) + 1,SerializableImage.TYPE_INT_ARGB);
  if (backGroundColor == null) {
    image.fillTransparent();
  }
 else {
    Graphics2D g=(Graphics2D)image.getBufferedImage().getGraphics();
    g.setComposite(AlphaComposite.Src);
    g.setColor(backGroundColor);
    g.fill(new Rectangle(image.getWidth(),image.getHeight()));
  }
  Matrix m=transformation.clone();
  m.translate(-rect.Xmin * zoom,-rect.Ymin * zoom);
  m.scale(zoom);
  RenderContext renderContext=new RenderContext();
  renderContext.stateUnderCursor=stateUnderCursor;
  renderContext.mouseButton=mouseButton;
  frameToImage(timeline,frame,time,renderContext,image,m,colorTransform);
  if (useCache) {
    putToCache(key,image);
  }
  return image;
}",0.9866041527126592
61596,"private List<TreeItem> searchTag(TreeItem obj,TreeItem parent,List<TreeItem> path){
  List<TreeItem> ret=null;
  int cnt=getChildCount(parent);
  for (int i=0; i < cnt; i++) {
    TreeItem n=getChild(parent,i);
    List<TreeItem> newPath=new ArrayList<>();
    newPath.addAll(path);
    newPath.add(n);
    if (n instanceof AS3ClassTreeItem) {
      AS3ClassTreeItem te=(AS3ClassTreeItem)n;
      if (obj.equals(te)) {
        return newPath;
      }
    }
    if (obj instanceof FolderItem && n instanceof FolderItem) {
      FolderItem nds=(FolderItem)n;
      FolderItem objs=(FolderItem)obj;
      if (objs.getName().equals(nds.getName())) {
        return newPath;
      }
    }
 else {
      if (obj.equals(n)) {
        return newPath;
      }
    }
    ret=searchTag(obj,n,newPath);
    if (ret != null) {
      return ret;
    }
  }
  return ret;
}","private List<TreeItem> searchTag(TreeItem obj,TreeItem parent,List<TreeItem> path){
  List<TreeItem> ret=null;
  int cnt=getChildCount(parent);
  for (int i=0; i < cnt; i++) {
    TreeItem n=getChild(parent,i);
    List<TreeItem> newPath=new ArrayList<>();
    newPath.addAll(path);
    newPath.add(n);
    if (n instanceof AS3ClassTreeItem) {
      AS3ClassTreeItem te=(AS3ClassTreeItem)n;
      if (obj.equals(te)) {
        return newPath;
      }
    }
    if (obj instanceof FolderItem && n instanceof FolderItem) {
      FolderItem nds=(FolderItem)n;
      FolderItem objs=(FolderItem)obj;
      if (objs.getName().equals(nds.getName())) {
        return newPath;
      }
    }
 else {
      TreeItem n2=n;
      if (n2 instanceof TagScript) {
        n2=((TagScript)n2).getTag();
      }
      if (obj.equals(n2)) {
        return newPath;
      }
    }
    ret=searchTag(obj,n,newPath);
    if (ret != null) {
      return ret;
    }
  }
  return ret;
}",0.9427942794279428
61597,"/** 
 * Script for updating license header in java files :-)
 * @param dir Star directory (e.g. ""src/"")
 * @param lgpl
 */
public static void updateLicenseInDir(File dir,boolean lgpl){
  int defaultStartYear=2010;
  int defaultFinalYear=2015;
  String defaultAuthor=""String_Node_Str"";
  String defaultYearStr=Integer.toString(defaultStartYear);
  if (defaultFinalYear != defaultStartYear) {
    defaultYearStr+=""String_Node_Str"" + defaultFinalYear;
  }
  String gplLicense=""String_Node_Str"";
  String lgplLicense=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String license=lgpl ? lgplLicense : gplLicense;
  File[] files=dir.listFiles();
  for (  File f : files) {
    if (f.isDirectory()) {
      updateLicenseInDir(f,lgpl);
    }
 else {
      if (f.getName().endsWith(""String_Node_Str"")) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintWriter pw=new Utf8PrintWriter(baos);
        try {
          try (BufferedReader br=new BufferedReader(new FileReader(f))){
            String s;
            boolean packageFound=false;
            String author=defaultAuthor;
            String yearStr=defaultYearStr;
            while ((s=br.readLine()) != null) {
              if (!packageFound) {
                if (s.trim().startsWith(""String_Node_Str"")) {
                  packageFound=true;
                  pw.println(license.replace(""String_Node_Str"",yearStr).replace(""String_Node_Str"",author));
                }
 else {
                  Matcher mAuthor=Pattern.compile(lgpl ? ""String_Node_Str"" : ""String_Node_Str"").matcher(s);
                  if (mAuthor.matches()) {
                    author=mAuthor.group(3).trim();
                    int startYear=Integer.parseInt(mAuthor.group(1).trim());
                    if (startYear == defaultFinalYear) {
                      yearStr=Integer.toString(startYear);
                    }
 else {
                      yearStr=Integer.toString(startYear) + ""String_Node_Str"" + defaultFinalYear;
                    }
                    if (!author.equals(defaultAuthor)) {
                      System.out.println(""String_Node_Str"" + author + ""String_Node_Str""+ f.getAbsolutePath());
                    }
                  }
                }
              }
              if (packageFound) {
                pw.println(s);
              }
            }
          }
           pw.close();
        }
 catch (        IOException ex) {
        }
        FileOutputStream fos;
        try {
          fos=new FileOutputStream(f);
          fos.write(baos.toByteArray());
          fos.close();
        }
 catch (        IOException ex) {
        }
      }
    }
  }
}","/** 
 * Script for updating license header in java files :-)
 * @param dir Star directory (e.g. ""src/"")
 * @param lgpl
 */
public static void updateLicenseInDir(File dir,boolean lgpl){
  int defaultStartYear=2010;
  int defaultFinalYear=2015;
  String defaultAuthor=""String_Node_Str"";
  String defaultYearStr=Integer.toString(defaultStartYear);
  if (defaultFinalYear != defaultStartYear) {
    defaultYearStr+=""String_Node_Str"" + defaultFinalYear;
  }
  String gplLicense=""String_Node_Str"";
  String lgplLicense=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String license=lgpl ? lgplLicense : gplLicense;
  File[] files=dir.listFiles();
  for (  File f : files) {
    if (f.isDirectory()) {
      updateLicenseInDir(f,lgpl);
    }
 else {
      if (f.getName().endsWith(""String_Node_Str"")) {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintWriter pw=new Utf8PrintWriter(baos);
        try {
          try (BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(f),Utf8Helper.charset))){
            String s;
            boolean packageFound=false;
            String author=defaultAuthor;
            String yearStr=defaultYearStr;
            while ((s=br.readLine()) != null) {
              if (!packageFound) {
                if (s.trim().startsWith(""String_Node_Str"")) {
                  packageFound=true;
                  pw.println(license.replace(""String_Node_Str"",yearStr).replace(""String_Node_Str"",author));
                }
 else {
                  Matcher mAuthor=Pattern.compile(lgpl ? ""String_Node_Str"" : ""String_Node_Str"").matcher(s);
                  if (mAuthor.matches()) {
                    author=mAuthor.group(3).trim();
                    int startYear=Integer.parseInt(mAuthor.group(1).trim());
                    if (startYear == defaultFinalYear) {
                      yearStr=Integer.toString(startYear);
                    }
 else {
                      yearStr=Integer.toString(startYear) + ""String_Node_Str"" + defaultFinalYear;
                    }
                    if (!author.equals(defaultAuthor)) {
                      System.out.println(""String_Node_Str"" + author + ""String_Node_Str""+ f.getAbsolutePath());
                    }
                  }
                }
              }
              if (packageFound) {
                pw.println(s);
              }
            }
          }
           pw.close();
        }
 catch (        IOException ex) {
        }
        FileOutputStream fos;
        try {
          fos=new FileOutputStream(f);
          fos.write(baos.toByteArray());
          fos.close();
        }
 catch (        IOException ex) {
        }
      }
    }
  }
}",0.9891323098154218
61598,"@Override public void lineStyle(double thickness,RGB color,boolean pixelHinting,String scaleMode,int startCaps,int endCaps,int joints,int miterLimit){
  finalizePath();
  thickness*=zoom / SWF.unitDivisor;
  path.setAttribute(""String_Node_Str"",""String_Node_Str"");
  path.setAttribute(""String_Node_Str"",color.toHexRGB());
  path.setAttribute(""String_Node_Str"",Double.toString(thickness == 0 ? 1 : thickness));
  if (color instanceof RGBA) {
    RGBA colorA=(RGBA)color;
    if (colorA.alpha != 255) {
      path.setAttribute(""String_Node_Str"",Float.toString(colorA.getAlphaFloat()));
    }
  }
switch (startCaps) {
case LINESTYLE2.NO_CAP:
    path.setAttribute(""String_Node_Str"",""String_Node_Str"");
  break;
case LINESTYLE2.SQUARE_CAP:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
}
switch (joints) {
case LINESTYLE2.BEVEL_JOIN:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case LINESTYLE2.ROUND_JOIN:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
if (miterLimit >= 1 && miterLimit != 4) {
path.setAttribute(""String_Node_Str"",Integer.toString(miterLimit));
}
break;
}
}","@Override public void lineStyle(double thickness,RGB color,boolean pixelHinting,String scaleMode,int startCaps,int endCaps,int joints,int miterLimit){
  finalizePath();
  thickness*=zoom / SWF.unitDivisor;
  path.setAttribute(""String_Node_Str"",""String_Node_Str"");
  if (color != null) {
    path.setAttribute(""String_Node_Str"",color.toHexRGB());
  }
  path.setAttribute(""String_Node_Str"",Double.toString(thickness == 0 ? 1 : thickness));
  if (color instanceof RGBA) {
    RGBA colorA=(RGBA)color;
    if (colorA.alpha != 255) {
      path.setAttribute(""String_Node_Str"",Float.toString(colorA.getAlphaFloat()));
    }
  }
switch (startCaps) {
case LINESTYLE2.NO_CAP:
    path.setAttribute(""String_Node_Str"",""String_Node_Str"");
  break;
case LINESTYLE2.SQUARE_CAP:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
}
switch (joints) {
case LINESTYLE2.BEVEL_JOIN:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
case LINESTYLE2.ROUND_JOIN:
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
break;
default :
path.setAttribute(""String_Node_Str"",""String_Node_Str"");
if (miterLimit >= 1 && miterLimit != 4) {
path.setAttribute(""String_Node_Str"",Integer.toString(miterLimit));
}
break;
}
}",0.9886229894076108
61599,"@Override public String toString(){
  return name;
}","@Override public String toString(){
  if (isBundle) {
    return name;
  }
 else {
    return swfs.get(0).getFileTitle();
  }
}",0.5810055865921788
61600,"public void close(SWFList swfList){
  boolean modified=false;
  for (  SWF swf : swfList) {
    if (swf.isModified()) {
      modified=true;
    }
  }
  if (modified) {
    if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",swfList.name),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,Configuration.showCloseConfirmation,JOptionPane.CANCEL_OPTION) == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  swfs.remove(swfList);
  if (abcPanel != null) {
    for (    SWF swf : swfList) {
      if (abcPanel.swf == swf) {
        abcPanel.clearSwf();
      }
    }
  }
  if (actionPanel != null) {
    actionPanel.clearSource();
  }
  oldItem=null;
  previewPanel.clear();
  updateUi();
  refreshTree();
}","public void close(SWFList swfList){
  boolean modified=false;
  for (  SWF swf : swfList) {
    if (swf.isModified()) {
      modified=true;
    }
  }
  if (modified) {
    if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",swfList.toString()),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,Configuration.showCloseConfirmation,JOptionPane.OK_OPTION) == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  swfs.remove(swfList);
  if (abcPanel != null) {
    for (    SWF swf : swfList) {
      if (abcPanel.swf == swf) {
        abcPanel.clearSwf();
      }
    }
  }
  if (actionPanel != null) {
    actionPanel.clearSource();
  }
  oldItem=null;
  previewPanel.clear();
  updateUi();
  refreshTree();
}",0.9534574468085106
61601,"public void fixCharactersOrder(boolean checkAll){
  Set<Integer> addedCharacterIds=new HashSet<>();
  Set<CharacterTag> movedTags=new HashSet<>();
  for (int i=0; i < tags.size(); i++) {
    Tag tag=tags.get(i);
    if (checkAll || tag.isModified()) {
      Set<Integer> needed=new HashSet<>();
      tag.getNeededCharacters(needed);
      boolean moved=false;
      for (      Integer id : needed) {
        if (!addedCharacterIds.contains(id)) {
          CharacterTag neededCharacter=characters.get(id);
          if (neededCharacter == null) {
            continue;
          }
          if (movedTags.contains(neededCharacter)) {
            logger.log(Level.SEVERE,""String_Node_Str"");
            return;
          }
          tags.remove(neededCharacter);
          tags.add(i,neededCharacter);
          movedTags.add(neededCharacter);
          moved=true;
        }
      }
      if (moved) {
        i--;
        continue;
      }
    }
    if (tag instanceof CharacterTag) {
      addedCharacterIds.add(((CharacterTag)tag).getCharacterId());
    }
  }
}","public void fixCharactersOrder(boolean checkAll){
  Set<Integer> addedCharacterIds=new HashSet<>();
  Set<CharacterTag> movedTags=new HashSet<>();
  for (int i=0; i < tags.size(); i++) {
    Tag tag=tags.get(i);
    if (checkAll || tag.isModified()) {
      Set<Integer> needed=new HashSet<>();
      tag.getNeededCharacters(needed);
      if (tag instanceof CharacterTag) {
        CharacterTag characterTag=(CharacterTag)tag;
        needed.remove(characterTag.getCharacterId());
      }
      boolean moved=false;
      for (      Integer id : needed) {
        if (!addedCharacterIds.contains(id)) {
          CharacterTag neededCharacter=characters.get(id);
          if (neededCharacter == null) {
            continue;
          }
          if (movedTags.contains(neededCharacter)) {
            logger.log(Level.SEVERE,""String_Node_Str"");
            return;
          }
          tags.remove(neededCharacter);
          tags.add(i,neededCharacter);
          movedTags.add(neededCharacter);
          moved=true;
        }
      }
      if (moved) {
        i--;
        continue;
      }
    }
    if (tag instanceof CharacterTag) {
      addedCharacterIds.add(((CharacterTag)tag).getCharacterId());
    }
  }
}",0.931758530183727
61602,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws TextParseException {
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    List<TEXTRECORD> textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
    }
 else {
      throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new TextParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
default :
throw new TextParseException(""String_Node_Str"" + paramName,lexer.yyline());
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new TextParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getCharKerningAdjustment(c,nextChar);
}
advance=(int)Math.round(((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment)) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
setModified(true);
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
return false;
}
catch (TextParseException ex) {
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws TextParseException {
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    List<TEXTRECORD> textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
    }
 else {
      throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new TextParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
default :
throw new TextParseException(""String_Node_Str"" + paramName,lexer.yyline());
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new TextParseException(""String_Node_Str"",lexer.yyline());
}
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
return setFormattedText(missingCharHandler,formattedText,texts);
}
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getCharKerningAdjustment(c,nextChar);
}
advance=(int)Math.round(((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment)) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
setModified(true);
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
return false;
}
catch (TextParseException ex) {
throw ex;
}
return true;
}",0.9672394043528064
61603,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws TextParseException {
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    List<TEXTRECORD> textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new TextParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
default :
throw new TextParseException(""String_Node_Str"" + paramName,lexer.yyline());
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new TextParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getCharKerningAdjustment(c,nextChar);
}
advance=(int)Math.round(((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment)) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
setModified(true);
this.textRecords=textRecords;
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
return false;
}
catch (TextParseException ex) {
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws TextParseException {
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    List<TEXTRECORD> textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new TextParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new TextParseException(""String_Node_Str"" + paramValue,lexer.yyline());
}
break;
default :
throw new TextParseException(""String_Node_Str"" + paramName,lexer.yyline());
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new TextParseException(""String_Node_Str"",lexer.yyline());
}
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
return setFormattedText(missingCharHandler,formattedText,texts);
}
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getCharKerningAdjustment(c,nextChar);
}
advance=(int)Math.round(((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment)) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
setModified(true);
this.textRecords=textRecords;
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
return false;
}
catch (TextParseException ex) {
throw ex;
}
return true;
}",0.9671792517787468
61604,"public void shiftGlyphIndices(int fontId,int startIndex){
  for (  Tag t : swf.tags) {
    List<TEXTRECORD> textRecords=null;
    if (t instanceof DefineTextTag) {
      textRecords=((DefineTextTag)t).textRecords;
    }
 else     if (t instanceof DefineText2Tag) {
      textRecords=((DefineText2Tag)t).textRecords;
    }
    if (textRecords != null) {
      int curFontId=0;
      for (      TEXTRECORD tr : textRecords) {
        if (tr.styleFlagsHasFont) {
          curFontId=tr.fontId;
        }
        if (curFontId != fontId) {
          continue;
        }
        for (        GLYPHENTRY en : tr.glyphEntries) {
          if (en == null) {
            continue;
          }
          if (en.glyphIndex >= startIndex) {
            en.glyphIndex++;
          }
        }
        t.setModified(true);
      }
    }
  }
}","protected void shiftGlyphIndices(int fontId,int startIndex){
  for (  Tag t : swf.tags) {
    List<TEXTRECORD> textRecords=null;
    if (t instanceof DefineTextTag) {
      textRecords=((DefineTextTag)t).textRecords;
    }
 else     if (t instanceof DefineText2Tag) {
      textRecords=((DefineText2Tag)t).textRecords;
    }
    if (textRecords != null) {
      int curFontId=0;
      for (      TEXTRECORD tr : textRecords) {
        if (tr.styleFlagsHasFont) {
          curFontId=tr.fontId;
        }
        if (curFontId != fontId) {
          continue;
        }
        for (        GLYPHENTRY en : tr.glyphEntries) {
          if (en == null) {
            continue;
          }
          if (en.glyphIndex >= startIndex) {
            en.glyphIndex++;
          }
        }
        t.setModified(true);
      }
    }
  }
}",0.9921639541892706
61605,"public int typeName(SourceGeneratorLocalData localData,GraphTargetItem type) throws CompilationException {
  if (type instanceof UnboundedTypeItem) {
    return 0;
  }
  return resolveType(localData,type,abc,allABCs);
}","public int typeName(SourceGeneratorLocalData localData,GraphTargetItem type) throws CompilationException {
  if (type instanceof UnboundedTypeItem) {
    return 0;
  }
  if ((""String_Node_Str"" + type).equals(""String_Node_Str"")) {
    return 0;
  }
  return resolveType(localData,type,abc,allABCs);
}",0.8455598455598455
61606,"private int genNs(List<String> importedClasses,String pkg,String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData,int line) throws CompilationException {
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<GraphTargetItem>(null),new Reference<GraphTargetItem>(null),new Reference<>(0),value);
    boolean resolved=true;
    if (value.getVal() == null) {
      resolved=false;
    }
    if (!resolved) {
      String customPkg=""String_Node_Str"";
      String fullCustom=""String_Node_Str"";
      for (      String imp : importedClasses) {
        if (imp.endsWith(""String_Node_Str"" + custom)) {
          customPkg=imp.substring(0,imp.lastIndexOf('.'));
          fullCustom=imp;
          break;
        }
      }
      List<ABC> aas=new ArrayList<>();
      aas.add(abc);
      aas.addAll(allABCs);
      for (      ABC a : aas) {
        for (        ScriptInfo si : a.script_info) {
          for (          Trait t : si.traits.traits) {
            Multiname m=t.getName(a);
            if (fullCustom.equals(m.getNameWithNamespace(a.constants,true))) {
              if (t instanceof TraitSlotConst) {
                if (((TraitSlotConst)t).isNamespace()) {
                  return ((TraitSlotConst)t).value_index;
                }
              }
            }
          }
        }
      }
      throw new CompilationException(""String_Node_Str"",line);
    }
    namespace=value.getVal().value_index;
  }
  return namespace;
}","private int genNs(List<String> importedClasses,String pkg,String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData,int line) throws CompilationException {
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<GraphTargetItem>(null),new Reference<GraphTargetItem>(null),new Reference<>(0),value);
    boolean resolved=true;
    if (value.getVal() == null) {
      resolved=false;
    }
    if (!resolved) {
      String customPkg=""String_Node_Str"";
      String fullCustom=""String_Node_Str"";
      for (      String imp : importedClasses) {
        if (imp.endsWith(""String_Node_Str"" + custom)) {
          customPkg=imp.substring(0,imp.lastIndexOf('.'));
          fullCustom=imp;
          break;
        }
      }
      List<ABC> aas=new ArrayList<>();
      aas.add(abc);
      aas.addAll(allABCs);
      for (      ABC a : aas) {
        for (        ScriptInfo si : a.script_info) {
          for (          Trait t : si.traits.traits) {
            Multiname m=t.getName(a);
            if (fullCustom.equals(m.getNameWithNamespace(a.constants,true))) {
              if (t instanceof TraitSlotConst) {
                if (((TraitSlotConst)t).isNamespace()) {
                  Namespace ns=a.constants.getNamespace(((TraitSlotConst)t).value_index);
                  return abc.constants.getNamespaceId(new Namespace(ns.kind,abc.constants.getStringId(ns.getName(a.constants,true),true)),0,true);
                }
              }
            }
          }
        }
      }
      throw new CompilationException(""String_Node_Str"",line);
    }
    namespace=value.getVal().value_index;
  }
  return namespace;
}",0.826796450042943
61607,"private boolean parseUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants,false);
{
    String oldimport=newimport;
    newimport=null;
    for (    ABCContainerTag abcTag : abcTags) {
      String newname=abcTag.getABC().nsValueToName(oldimport);
      if (newname.equals(""String_Node_Str"")) {
        return true;
      }
      if (!newname.isEmpty()) {
        newimport=newname;
        break;
      }
    }
    if (newimport == null) {
      newimport=oldimport;
      newimport+=""String_Node_Str"" + name;
    }
    if (newimport != null && newimport.isEmpty()) {
      newimport=null;
    }
    if (newimport != null) {
      if (!imports.contains(newimport)) {
        if (newimport.contains(""String_Node_Str"")) {
          return true;
        }
        String pkg=""String_Node_Str"";
        if (newimport.contains(""String_Node_Str"")) {
          pkg=newimport.substring(0,newimport.lastIndexOf('.'));
        }
        String usname=newimport;
        if (usname.contains(""String_Node_Str"")) {
          usname=usname.substring(usname.lastIndexOf('.') + 1);
        }
        if (ns.kind == Namespace.KIND_PACKAGE) {
          if (!pkg.equals(ignorePackage)) {
            if (!pkg.equals(""String_Node_Str"")) {
              imports.add(newimport);
            }
          }
        }
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          if (!usname.equals(""String_Node_Str"")) {
            if (!pkg.equals(ignorePackage)) {
              imports.add(newimport);
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}","private boolean parseUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants,ns.kind == Namespace.KIND_NAMESPACE);
{
    String oldimport=newimport;
    newimport=null;
    for (    ABCContainerTag abcTag : abcTags) {
      String newname=abcTag.getABC().nsValueToName(oldimport);
      if (newname.equals(""String_Node_Str"")) {
        return true;
      }
      if (!newname.isEmpty()) {
        newimport=newname;
        break;
      }
    }
    if (newimport == null) {
      newimport=oldimport;
      newimport+=""String_Node_Str"" + name;
    }
    if (newimport != null && newimport.isEmpty()) {
      newimport=null;
    }
    if (newimport != null) {
      if (!imports.contains(newimport)) {
        if (newimport.contains(""String_Node_Str"")) {
          return true;
        }
        String pkg=""String_Node_Str"";
        if (newimport.contains(""String_Node_Str"")) {
          pkg=newimport.substring(0,newimport.lastIndexOf('.'));
        }
        String usname=newimport;
        if (usname.contains(""String_Node_Str"")) {
          usname=usname.substring(usname.lastIndexOf('.') + 1);
        }
        if (ns.kind == Namespace.KIND_PACKAGE) {
          if (!pkg.equals(ignorePackage)) {
            if (!pkg.equals(""String_Node_Str"")) {
              imports.add(newimport);
            }
          }
        }
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          if (!usname.equals(""String_Node_Str"")) {
            if (!pkg.equals(ignorePackage)) {
              imports.add(newimport);
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.9891126837234622
61608,"public ValueKind getValueKind(int ns,GraphTargetItem type,GraphTargetItem val){
  if (val instanceof BooleanAVM2Item) {
    BooleanAVM2Item bi=(BooleanAVM2Item)val;
    if (bi.value) {
      return new ValueKind(0,ValueKind.CONSTANT_True);
    }
 else {
      return new ValueKind(0,ValueKind.CONSTANT_False);
    }
  }
  boolean isNs=false;
  if (type instanceof NameAVM2Item) {
    if (((NameAVM2Item)type).getVariableName().equals(""String_Node_Str"")) {
      isNs=true;
    }
  }
  if ((type instanceof TypeItem) && (((TypeItem)type).fullTypeName.equals(""String_Node_Str""))) {
    isNs=true;
  }
  if (val instanceof StringAVM2Item) {
    StringAVM2Item sval=(StringAVM2Item)val;
    if (isNs) {
      return new ValueKind(namespace(abc.constants.constant_namespace.get(ns).kind,sval.value),Namespace.KIND_NAMESPACE);
    }
 else {
      return new ValueKind(str(sval.value),ValueKind.CONSTANT_Utf8);
    }
  }
  if (val instanceof IntegerValueAVM2Item) {
    return new ValueKind(abc.constants.getIntId(((IntegerValueAVM2Item)val).value,true),ValueKind.CONSTANT_Int);
  }
  if (val instanceof FloatValueAVM2Item) {
    return new ValueKind(abc.constants.getDoubleId(((FloatValueAVM2Item)val).value,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NanAVM2Item) {
    return new ValueKind(abc.constants.getDoubleId(Double.NaN,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NullAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Null);
  }
  if (val instanceof UndefinedAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Undefined);
  }
  return null;
}","public ValueKind getValueKind(int ns,GraphTargetItem type,GraphTargetItem val){
  if (val instanceof BooleanAVM2Item) {
    BooleanAVM2Item bi=(BooleanAVM2Item)val;
    if (bi.value) {
      return new ValueKind(0,ValueKind.CONSTANT_True);
    }
 else {
      return new ValueKind(0,ValueKind.CONSTANT_False);
    }
  }
  boolean isNs=false;
  if (type instanceof NameAVM2Item) {
    if (((NameAVM2Item)type).getVariableName().equals(""String_Node_Str"")) {
      isNs=true;
    }
  }
  if ((type instanceof TypeItem) && (((TypeItem)type).fullTypeName.equals(""String_Node_Str""))) {
    isNs=true;
  }
  if (val instanceof StringAVM2Item) {
    StringAVM2Item sval=(StringAVM2Item)val;
    if (isNs) {
      return new ValueKind(namespace(Namespace.KIND_NAMESPACE,sval.value),ValueKind.CONSTANT_Namespace);
    }
 else {
      return new ValueKind(str(sval.value),ValueKind.CONSTANT_Utf8);
    }
  }
  if (val instanceof IntegerValueAVM2Item) {
    return new ValueKind(abc.constants.getIntId(((IntegerValueAVM2Item)val).value,true),ValueKind.CONSTANT_Int);
  }
  if (val instanceof FloatValueAVM2Item) {
    return new ValueKind(abc.constants.getDoubleId(((FloatValueAVM2Item)val).value,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NanAVM2Item) {
    return new ValueKind(abc.constants.getDoubleId(Double.NaN,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NullAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Null);
  }
  if (val instanceof UndefinedAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Undefined);
  }
  return null;
}",0.938349668036674
61609,"public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands,int classPos) throws AVM2ParseException, CompilationException {
  Reference<Integer> class_index=new Reference<>(classPos);
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,false,localData,commands,si.traits,class_index);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(new GetLocal0Ins()));
  mbCode.add(ins(new PushScopeIns()));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new GetLexIns(),parents.get(i)));
          mbCode.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mbCode.add(ins(new GetLexIns(),parents.get(1)));
      }
      mbCode.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new PopScopeIns()));
        }
      }
      mbCode.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,false,localData,commands,si.traits,traitArr,initScopes,class_index);
  return si;
}","public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands,int classPos) throws AVM2ParseException, CompilationException {
  Reference<Integer> class_index=new Reference<>(classPos);
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,true,localData,commands,si.traits,class_index);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(new GetLocal0Ins()));
  mbCode.add(ins(new PushScopeIns()));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new GetLexIns(),parents.get(i)));
          mbCode.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mbCode.add(ins(new GetLexIns(),parents.get(1)));
      }
      mbCode.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new PopScopeIns()));
        }
      }
      mbCode.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,true,localData,commands,si.traits,traitArr,initScopes,class_index);
  return si;
}",0.9974274163910328
61610,"private GraphTargetItem traits(String scriptName,boolean scriptTraits,List<AssignableAVM2Item> sinitVariables,Reference<Boolean> sinitNeedsActivation,List<GraphTargetItem> staticInitializer,List<String> importedClasses,int privateNs,int protectedNs,int publicNs,int packageInternalNs,int protectedStaticNs,List<Integer> openedNamespaces,String pkg,String classNameStr,boolean isInterface,List<GraphTargetItem> traits) throws AVM2ParseException, IOException, CompilationException {
  ParsedSymbol s;
  GraphTargetItem constr=null;
  TypeItem thisType=pkg == null && classNameStr == null ? null : new TypeItem(pkg == null || ""String_Node_Str"".equals(pkg) ? classNameStr : pkg + ""String_Node_Str"" + classNameStr);
  List<AssignableAVM2Item> constrVariables=new ArrayList<>();
  List<Integer> originalOpenedNamespaces=openedNamespaces;
  int originalPrivateNs=privateNs;
  boolean inPkg=pkg != null;
  looptrait:   while (true) {
    s=lex();
    boolean isStatic=false;
    int namespace=-1;
    boolean isGetter=false;
    boolean isSetter=false;
    boolean isOverride=false;
    boolean isFinal=false;
    boolean isDynamic=false;
    String customAccess=null;
    if (scriptTraits && s.type == SymbolType.PACKAGE) {
      if (inPkg) {
        throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
      }
      openedNamespaces=new ArrayList<>();
      lexer.pushback(s);
      PackageAVM2Item p=parsePackage(openedNamespaces);
      pkg=p.packageName;
      inPkg=true;
      publicNs=p.publicNs;
      importedClasses=p.importedClasses;
      s=lex();
    }
    if (inPkg || classNameStr != null) {
      if (s.type == SymbolType.CURLY_OPEN) {
        staticInitializer.addAll(commands(thisType,pkg,sinitNeedsActivation,importedClasses,openedNamespaces,new Stack<Loop>(),new HashMap<Loop,String>(),new HashMap<String,Integer>(),true,false,0,sinitVariables));
        expectedType(SymbolType.CURLY_CLOSE);
        s=lex();
      }
      while (s.isType(SymbolType.STATIC,SymbolType.PUBLIC,SymbolType.PRIVATE,SymbolType.PROTECTED,SymbolType.OVERRIDE,SymbolType.FINAL,SymbolType.DYNAMIC,SymbolGroup.IDENTIFIER)) {
        if (s.type == SymbolType.FINAL) {
          if (isFinal) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isFinal=true;
        }
 else         if (s.type == SymbolType.DYNAMIC) {
          if (isDynamic) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isDynamic=true;
        }
 else         if (s.type == SymbolType.OVERRIDE) {
          if (isOverride) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isOverride=true;
        }
 else         if (s.type == SymbolType.STATIC) {
          if (isInterface) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          if (classNameStr == null) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          if (isStatic) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isStatic=true;
        }
 else         if (s.group == SymbolGroup.IDENTIFIER) {
          customAccess=s.value.toString();
          namespace=-2;
        }
 else {
          if (namespace != -1) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
        }
switch (s.type) {
case PUBLIC:
          namespace=publicNs;
        if (isInterface) {
          throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
        }
      break;
case PRIVATE:
    namespace=privateNs;
  if (isInterface) {
    throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
  }
break;
case PROTECTED:
namespace=protectedNs;
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
s=lex();
}
}
 else {
namespace=privateNs;
}
if (namespace == -1) {
if (isInterface) {
namespace=abc.constants.getNamespaceId(new Namespace(Namespace.KIND_NAMESPACE,abc.constants.getStringId(pkg == null || pkg.isEmpty() ? classNameStr : pkg + ""String_Node_Str"" + classNameStr,true)),0,true);
}
 else {
namespace=packageInternalNs;
}
}
if (namespace == protectedNs && isStatic) {
namespace=protectedStaticNs;
}
switch (s.type) {
case CLASS:
List<Integer> subNamespaces=new ArrayList<>(openedNamespaces);
if (classNameStr != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String classTypeStr=s.value.toString();
GraphTargetItem extendsTypeStr=null;
s=lex();
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,subNamespaces,new ArrayList<AssignableAVM2Item>());
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,subNamespaces,new ArrayList<AssignableAVM2Item>());
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
if (customAccess != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
traits.add((classTraits(scriptName,publicNs,pkg,importedClasses,isDynamic,isFinal,subNamespaces,pkg,namespace,false,classTypeStr,extendsTypeStr,implementsTypeStrs,new ArrayList<AssignableAVM2Item>())));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
if (classNameStr != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String intTypeStr=s.value.toString();
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new ArrayList<AssignableAVM2Item>());
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
if (customAccess != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
traits.add((classTraits(scriptName,publicNs,pkg,importedClasses,false,isFinal,openedNamespaces,pkg,namespace,true,intTypeStr,null,intExtendsTypeStrs,new ArrayList<AssignableAVM2Item>())));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
if (s.type == SymbolType.GET) {
if (classNameStr == null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
isGetter=true;
s=lex();
}
 else if (s.type == SymbolType.SET) {
if (classNameStr == null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
isSetter=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String fname=s.value.toString();
if (classNameStr != null && fname.equals(classNameStr)) {
if (isStatic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isStatic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
constr=(method(pkg,false,customAccess,new Reference<>(false),importedClasses,false,false,thisType,openedNamespaces,false,namespace,""String_Node_Str"",true,constrVariables));
}
 else {
MethodAVM2Item ft=method(pkg,isInterface,customAccess,new Reference<>(false),importedClasses,isOverride,isFinal,thisType,openedNamespaces,isStatic,namespace,fname,true,new ArrayList<AssignableAVM2Item>());
if (isGetter) {
if (!ft.paramTypes.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
if (isSetter) {
if (ft.paramTypes.size() != 1) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
if (isStatic && isInterface) {
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
GraphTargetItem t;
if (isGetter) {
GetterAVM2Item g=new GetterAVM2Item(ft.pkg,isInterface,customAccess,ft.needsActivation,ft.hasRest,ft.line,ft.isOverride(),ft.isFinal(),isStatic,ft.namespace,ft.functionName,ft.paramTypes,ft.paramNames,ft.paramValues,ft.body,ft.subvariables,ft.retType);
t=g;
}
 else if (isSetter) {
SetterAVM2Item st=new SetterAVM2Item(ft.pkg,isInterface,customAccess,ft.needsActivation,ft.hasRest,ft.line,ft.isOverride(),ft.isFinal(),isStatic,ft.namespace,ft.functionName,ft.paramTypes,ft.paramNames,ft.paramValues,ft.body,ft.subvariables,ft.retType);
t=st;
}
 else {
t=ft;
}
traits.add(t);
}
break;
case NAMESPACE:
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String nname=s.value.toString();
String nval=""String_Node_Str"";
s=lex();
if (s.type == SymbolType.ASSIGN) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
nval=s.value.toString();
s=lex();
}
 else {
nval=(pkg == null || pkg.isEmpty() ? classNameStr : pkg + ""String_Node_Str"" + classNameStr) + ""String_Node_Str"" + nname;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
ConstAVM2Item ns=new ConstAVM2Item(pkg,customAccess,true,namespace,nname,new TypeItem(""String_Node_Str""),new StringAVM2Item(null,nval),lexer.yyline());
traits.add(ns);
break;
case CONST:
case VAR:
boolean isConst=s.type == SymbolType.CONST;
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String vcname=s.value.toString();
s=lex();
GraphTargetItem type=null;
if (s.type == SymbolType.COLON) {
type=type(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new ArrayList<AssignableAVM2Item>());
s=lex();
}
 else {
type=TypeItem.UNBOUNDED;
}
GraphTargetItem value=null;
if (s.type == SymbolType.ASSIGN) {
value=expression(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new HashMap<String,Integer>(),false,false,true,isStatic || isConst ? sinitVariables : constrVariables);
s=lex();
}
GraphTargetItem tar;
if (isConst) {
tar=new ConstAVM2Item(pkg,customAccess,isStatic,namespace,vcname,type,value,lexer.yyline());
}
 else {
tar=new SlotAVM2Item(pkg,customAccess,isStatic,namespace,vcname,type,value,lexer.yyline());
}
traits.add(tar);
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
break;
default :
if (s.type == SymbolType.CURLY_CLOSE && inPkg && classNameStr == null) {
inPkg=false;
pkg=null;
openedNamespaces=originalOpenedNamespaces;
privateNs=originalPrivateNs;
}
 else {
lexer.pushback(s);
break looptrait;
}
}
}
return constr;
}","private GraphTargetItem traits(String scriptName,boolean scriptTraits,List<AssignableAVM2Item> sinitVariables,Reference<Boolean> sinitNeedsActivation,List<GraphTargetItem> staticInitializer,List<String> importedClasses,int privateNs,int protectedNs,int publicNs,int packageInternalNs,int protectedStaticNs,List<Integer> openedNamespaces,String pkg,String classNameStr,boolean isInterface,List<GraphTargetItem> traits) throws AVM2ParseException, IOException, CompilationException {
  ParsedSymbol s;
  GraphTargetItem constr=null;
  TypeItem thisType=pkg == null && classNameStr == null ? null : new TypeItem(pkg == null || ""String_Node_Str"".equals(pkg) ? classNameStr : pkg + ""String_Node_Str"" + classNameStr);
  List<AssignableAVM2Item> constrVariables=new ArrayList<>();
  List<Integer> originalOpenedNamespaces=openedNamespaces;
  int originalPrivateNs=privateNs;
  boolean inPkg=pkg != null;
  looptrait:   while (true) {
    s=lex();
    boolean isStatic=false;
    int namespace=-1;
    boolean isGetter=false;
    boolean isSetter=false;
    boolean isOverride=false;
    boolean isFinal=false;
    boolean isDynamic=false;
    String customAccess=null;
    if (scriptTraits && s.type == SymbolType.PACKAGE) {
      if (inPkg) {
        throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
      }
      openedNamespaces=new ArrayList<>();
      lexer.pushback(s);
      PackageAVM2Item p=parsePackage(openedNamespaces);
      pkg=p.packageName;
      inPkg=true;
      publicNs=p.publicNs;
      importedClasses=p.importedClasses;
      s=lex();
    }
    if (inPkg || classNameStr != null) {
      if (s.type == SymbolType.CURLY_OPEN) {
        staticInitializer.addAll(commands(thisType,pkg,sinitNeedsActivation,importedClasses,openedNamespaces,new Stack<Loop>(),new HashMap<Loop,String>(),new HashMap<String,Integer>(),true,false,0,sinitVariables));
        expectedType(SymbolType.CURLY_CLOSE);
        s=lex();
      }
      while (s.isType(SymbolType.STATIC,SymbolType.PUBLIC,SymbolType.PRIVATE,SymbolType.PROTECTED,SymbolType.OVERRIDE,SymbolType.FINAL,SymbolType.DYNAMIC,SymbolGroup.IDENTIFIER)) {
        if (s.type == SymbolType.FINAL) {
          if (isFinal) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isFinal=true;
        }
 else         if (s.type == SymbolType.DYNAMIC) {
          if (isDynamic) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isDynamic=true;
        }
 else         if (s.type == SymbolType.OVERRIDE) {
          if (isOverride) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isOverride=true;
        }
 else         if (s.type == SymbolType.STATIC) {
          if (isInterface) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          if (classNameStr == null) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          if (isStatic) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
          isStatic=true;
        }
 else         if (s.type == SymbolType.NAMESPACE) {
          break;
        }
 else         if (s.type == SymbolType.NATIVE) {
          throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
        }
 else         if (s.group == SymbolGroup.IDENTIFIER) {
          customAccess=s.value.toString();
          namespace=-2;
        }
 else {
          if (namespace != -1) {
            throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
          }
        }
switch (s.type) {
case PUBLIC:
          namespace=publicNs;
        if (isInterface) {
          throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
        }
      break;
case PRIVATE:
    namespace=privateNs;
  if (isInterface) {
    throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
  }
break;
case PROTECTED:
namespace=protectedNs;
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
s=lex();
}
}
 else {
namespace=privateNs;
}
if (namespace == -1) {
if (isInterface) {
namespace=abc.constants.getNamespaceId(new Namespace(Namespace.KIND_NAMESPACE,abc.constants.getStringId(pkg == null || pkg.isEmpty() ? classNameStr : pkg + ""String_Node_Str"" + classNameStr,true)),0,true);
}
 else {
namespace=packageInternalNs;
}
}
if (namespace == protectedNs && isStatic) {
namespace=protectedStaticNs;
}
switch (s.type) {
case CLASS:
List<Integer> subNamespaces=new ArrayList<>(openedNamespaces);
if (classNameStr != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String classTypeStr=s.value.toString();
GraphTargetItem extendsTypeStr=null;
s=lex();
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,subNamespaces,new ArrayList<AssignableAVM2Item>());
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,subNamespaces,new ArrayList<AssignableAVM2Item>());
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
if (customAccess != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
traits.add((classTraits(scriptName,publicNs,pkg,importedClasses,isDynamic,isFinal,subNamespaces,pkg,namespace,false,classTypeStr,extendsTypeStr,implementsTypeStrs,new ArrayList<AssignableAVM2Item>())));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
if (classNameStr != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String intTypeStr=s.value.toString();
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new ArrayList<AssignableAVM2Item>());
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
if (customAccess != null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
traits.add((classTraits(scriptName,publicNs,pkg,importedClasses,false,isFinal,openedNamespaces,pkg,namespace,true,intTypeStr,null,intExtendsTypeStrs,new ArrayList<AssignableAVM2Item>())));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
if (s.type == SymbolType.GET) {
if (classNameStr == null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
isGetter=true;
s=lex();
}
 else if (s.type == SymbolType.SET) {
if (classNameStr == null) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
isSetter=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String fname=s.value.toString();
if (classNameStr != null && fname.equals(classNameStr)) {
if (isStatic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isStatic) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
constr=(method(pkg,false,customAccess,new Reference<>(false),importedClasses,false,false,thisType,openedNamespaces,false,namespace,""String_Node_Str"",true,constrVariables));
}
 else {
MethodAVM2Item ft=method(pkg,isInterface,customAccess,new Reference<>(false),importedClasses,isOverride,isFinal,thisType,openedNamespaces,isStatic,namespace,fname,true,new ArrayList<AssignableAVM2Item>());
if (isGetter) {
if (!ft.paramTypes.isEmpty()) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
if (isSetter) {
if (ft.paramTypes.size() != 1) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
if (isStatic && isInterface) {
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
}
GraphTargetItem t;
if (isGetter) {
GetterAVM2Item g=new GetterAVM2Item(ft.pkg,isInterface,customAccess,ft.needsActivation,ft.hasRest,ft.line,ft.isOverride(),ft.isFinal(),isStatic,ft.namespace,ft.functionName,ft.paramTypes,ft.paramNames,ft.paramValues,ft.body,ft.subvariables,ft.retType);
t=g;
}
 else if (isSetter) {
SetterAVM2Item st=new SetterAVM2Item(ft.pkg,isInterface,customAccess,ft.needsActivation,ft.hasRest,ft.line,ft.isOverride(),ft.isFinal(),isStatic,ft.namespace,ft.functionName,ft.paramTypes,ft.paramNames,ft.paramValues,ft.body,ft.subvariables,ft.retType);
t=st;
}
 else {
t=ft;
}
traits.add(t);
}
break;
case NAMESPACE:
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String nname=s.value.toString();
String nval=""String_Node_Str"";
s=lex();
if (s.type == SymbolType.ASSIGN) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
nval=s.value.toString();
s=lex();
}
 else {
nval=(pkg == null || pkg.isEmpty() ? classNameStr : pkg + ""String_Node_Str"" + classNameStr) + ""String_Node_Str"" + nname;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
ConstAVM2Item ns=new ConstAVM2Item(pkg,customAccess,true,namespace,nname,new TypeItem(""String_Node_Str""),new StringAVM2Item(null,nval),lexer.yyline());
traits.add(ns);
break;
case CONST:
case VAR:
boolean isConst=s.type == SymbolType.CONST;
if (isOverride) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isFinal) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isDynamic) {
throw new AVM2ParseException(""String_Node_Str"" + (isConst ? ""String_Node_Str"" : ""String_Node_Str""),lexer.yyline());
}
if (isInterface) {
throw new AVM2ParseException(""String_Node_Str"",lexer.yyline());
}
s=lex();
expected(s,lexer.yyline(),SymbolGroup.IDENTIFIER);
String vcname=s.value.toString();
s=lex();
GraphTargetItem type=null;
if (s.type == SymbolType.COLON) {
type=type(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new ArrayList<AssignableAVM2Item>());
s=lex();
}
 else {
type=TypeItem.UNBOUNDED;
}
GraphTargetItem value=null;
if (s.type == SymbolType.ASSIGN) {
value=expression(thisType,pkg,new Reference<>(false),importedClasses,openedNamespaces,new HashMap<String,Integer>(),false,false,true,isStatic || isConst ? sinitVariables : constrVariables);
s=lex();
}
GraphTargetItem tar;
if (isConst) {
tar=new ConstAVM2Item(pkg,customAccess,isStatic,namespace,vcname,type,value,lexer.yyline());
}
 else {
tar=new SlotAVM2Item(pkg,customAccess,isStatic,namespace,vcname,type,value,lexer.yyline());
}
traits.add(tar);
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
break;
default :
if (s.type == SymbolType.CURLY_CLOSE && inPkg && classNameStr == null) {
inPkg=false;
pkg=null;
openedNamespaces=originalOpenedNamespaces;
privateNs=originalPrivateNs;
}
 else {
lexer.pushback(s);
break looptrait;
}
}
}
return constr;
}",0.990916880891174
61611,"public int method(boolean subMethod,boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants,true));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>(),true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
          mbodyCode.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
      mbodyCode.add(1,new AVM2Instruction(0,new PushScopeIns(),null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,new ReturnVoidIns(),null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,new PushUndefinedIns(),null));
        mbodyCode.add(new AVM2Instruction(0,new ReturnValueIns(),null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}","public int method(boolean subMethod,boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  newlocalData.subMethod=subMethod;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=subMethod ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants,true));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>(),true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
          mbodyCode.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
      mbodyCode.add(1,new AVM2Instruction(0,new PushScopeIns(),null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,new ReturnVoidIns(),null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,new PushUndefinedIns(),null));
        mbodyCode.add(new AVM2Instruction(0,new ReturnValueIns(),null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}",0.9990082392432102
61612,"@Override public void actionListParsed(ActionList actions,SWF swf){
  removeObfuscationIfs(actions);
}","@Override public void actionListParsed(ActionList actions,SWF swf){
  removeGetTimes(actions);
  removeObfuscationIfs(actions);
}",0.8831168831168831
61613,"private void executeActions(ActionList actions,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  ActionLocalData localData=new ActionLocalData();
  FixItemCounterTranslateStack stack=new FixItemCounterTranslateStack();
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      Action action=actions.get(idx);
      instructionsProcessed++;
      if (instructionsProcessed > executionLimit) {
        break;
      }
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      if (!(action instanceof ActionPush || action instanceof ActionPushDuplicate || action instanceof ActionCharToAscii|| action instanceof ActionAdd|| action instanceof ActionAdd2|| action instanceof ActionSubtract|| action instanceof ActionModulo|| action instanceof ActionMultiply|| action instanceof ActionBitXor|| action instanceof ActionBitAnd|| action instanceof ActionBitOr|| action instanceof ActionBitLShift|| action instanceof ActionBitRShift|| action instanceof ActionEquals|| action instanceof ActionNot|| action instanceof ActionIf|| action instanceof ActionJump)) {
        break;
      }
      if (action instanceof ActionPush) {
        ActionPush push=(ActionPush)action;
        boolean ok=true;
        for (        Object value : push.values) {
          if (value instanceof ConstantIndex || value instanceof RegisterNumber) {
            ok=false;
            break;
          }
        }
        if (!ok) {
          break;
        }
      }
      idx++;
      if (action instanceof ActionJump) {
        ActionJump jump=(ActionJump)action;
        long address=jump.getAddress() + jump.getTotalActionLength() + jump.getJumpOffset();
        idx=actions.indexOf(actions.getByAddress(address));
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
      if (action instanceof ActionIf) {
        ActionIf aif=(ActionIf)action;
        if (EcmaScript.toBoolean(stack.pop().getResult())) {
          long address=aif.getAddress() + aif.getTotalActionLength() + aif.getJumpOffset();
          idx=actions.indexOf(actions.getByAddress(address));
          if (idx == -1) {
            throw new TranslateException(""String_Node_Str"" + address);
          }
        }
      }
      if (stack.allItemsFixed()) {
        result.idx=idx == actions.size() ? idx - 1 : idx;
        result.instructionsProcessed=instructionsProcessed;
        result.stack.clear();
        result.stack.addAll(stack);
      }
    }
  }
 catch (  EmptyStackException|TranslateException|InterruptedException ex) {
  }
}","private void executeActions(ActionList actions,int idx,int endIdx,ExecutionResult result){
  List<GraphTargetItem> output=new ArrayList<>();
  ActionLocalData localData=new ActionLocalData();
  FixItemCounterTranslateStack stack=new FixItemCounterTranslateStack();
  int instructionsProcessed=0;
  try {
    while (true) {
      if (idx > endIdx) {
        break;
      }
      Action action=actions.get(idx);
      instructionsProcessed++;
      if (instructionsProcessed > executionLimit) {
        break;
      }
      action.translate(localData,stack,output,Graph.SOP_USE_STATIC,""String_Node_Str"");
      if (!(action instanceof ActionPush || action instanceof ActionPushDuplicate || action instanceof ActionCharToAscii|| action instanceof ActionAdd|| action instanceof ActionAdd2|| action instanceof ActionSubtract|| action instanceof ActionModulo|| action instanceof ActionMultiply|| action instanceof ActionBitXor|| action instanceof ActionBitAnd|| action instanceof ActionBitOr|| action instanceof ActionBitLShift|| action instanceof ActionBitRShift|| action instanceof ActionEquals|| action instanceof ActionNot|| action instanceof ActionIf|| action instanceof ActionJump)) {
        break;
      }
      if (action instanceof ActionPush) {
        ActionPush push=(ActionPush)action;
        boolean ok=true;
        instructionsProcessed+=push.values.size() - 1;
        for (        Object value : push.values) {
          if (value instanceof ConstantIndex || value instanceof RegisterNumber) {
            ok=false;
            break;
          }
        }
        if (!ok) {
          break;
        }
      }
      idx++;
      if (action instanceof ActionJump) {
        ActionJump jump=(ActionJump)action;
        long address=jump.getAddress() + jump.getTotalActionLength() + jump.getJumpOffset();
        idx=actions.indexOf(actions.getByAddress(address));
        if (idx == -1) {
          throw new TranslateException(""String_Node_Str"" + address);
        }
      }
      if (action instanceof ActionIf) {
        ActionIf aif=(ActionIf)action;
        if (EcmaScript.toBoolean(stack.pop().getResult())) {
          long address=aif.getAddress() + aif.getTotalActionLength() + aif.getJumpOffset();
          idx=actions.indexOf(actions.getByAddress(address));
          if (idx == -1) {
            throw new TranslateException(""String_Node_Str"" + address);
          }
        }
      }
      if (stack.allItemsFixed()) {
        result.idx=idx == actions.size() ? idx - 1 : idx;
        result.instructionsProcessed=instructionsProcessed;
        result.stack.clear();
        result.stack.addAll(stack);
      }
    }
  }
 catch (  EmptyStackException|TranslateException|InterruptedException ex) {
  }
}",0.9898204701091986
61614,"private boolean removeObfuscationIfs(ActionList actions){
  if (actions.size() == 0) {
    return false;
  }
  removeUnreachableActions(actions);
  removeZeroJumps(actions);
  for (int i=0; i < actions.size(); i++) {
    ExecutionResult result=new ExecutionResult();
    executeActions(actions,i,actions.size() - 1,result);
    if (result.idx != -1) {
      int newIstructionCount=1;
      if (!result.stack.isEmpty()) {
        newIstructionCount++;
      }
      if (newIstructionCount + 1 < result.instructionsProcessed) {
        Action target=actions.get(result.idx);
        Action prevAction=actions.get(i);
        if (!result.stack.isEmpty()) {
          ActionPush push=new ActionPush(0);
          push.values.clear();
          for (          GraphTargetItem graphTargetItem : result.stack) {
            DirectValueActionItem dv=(DirectValueActionItem)graphTargetItem;
            push.values.add(dv.value);
          }
          push.setAddress(prevAction.getAddress());
          actions.addAction(i++,push);
          prevAction=push;
        }
        ActionJump jump=new ActionJump(0);
        jump.setAddress(prevAction.getAddress());
        jump.setJumpOffset((int)(target.getAddress() - jump.getAddress() - jump.getTotalActionLength()));
        actions.addAction(i++,jump);
        Action nextAction=actions.size() > i ? actions.get(i) : null;
        removeUnreachableActions(actions);
        removeZeroJumps(actions);
        if (nextAction != null) {
          int nextIdx=actions.indexOf(nextAction);
          if (nextIdx < i) {
            i=nextIdx;
          }
        }
      }
    }
  }
  return false;
}","private boolean removeObfuscationIfs(ActionList actions){
  if (actions.size() == 0) {
    return false;
  }
  removeUnreachableActions(actions);
  removeZeroJumps(actions);
  for (int i=0; i < actions.size(); i++) {
    ExecutionResult result=new ExecutionResult();
    executeActions(actions,i,actions.size() - 1,result);
    if (result.idx != -1) {
      int newIstructionCount=1;
      if (!result.stack.isEmpty()) {
        newIstructionCount+=result.stack.size();
      }
      if (newIstructionCount < result.instructionsProcessed) {
        Action target=actions.get(result.idx);
        Action prevAction=actions.get(i);
        if (!result.stack.isEmpty()) {
          ActionPush push=new ActionPush(0);
          push.values.clear();
          for (          GraphTargetItem graphTargetItem : result.stack) {
            DirectValueActionItem dv=(DirectValueActionItem)graphTargetItem;
            push.values.add(dv.value);
          }
          push.setAddress(prevAction.getAddress());
          actions.addAction(i++,push);
          prevAction=push;
        }
        ActionJump jump=new ActionJump(0);
        jump.setAddress(prevAction.getAddress());
        jump.setJumpOffset((int)(target.getAddress() - jump.getAddress() - jump.getTotalActionLength()));
        actions.addAction(i++,jump);
        Action nextAction=actions.size() > i ? actions.get(i) : null;
        removeUnreachableActions(actions);
        removeZeroJumps(actions);
        if (nextAction != null) {
          int nextIdx=actions.indexOf(nextAction);
          if (nextIdx < i) {
            i=nextIdx;
          }
        }
      }
    }
  }
  return false;
}",0.9924035247645092
61615,"@Override public Set<Entry<K,V>> entrySet(){
  if (deleted) {
    throw new NullPointerException();
  }
  Set<Entry<K,V>> ret=new HashSet<Entry<K,V>>();
  for (  K key : keySet()) {
    ret.add(new FileEntry<K,V>(this,key));
  }
  return ret;
}","@Override public Set<Entry<K,V>> entrySet(){
  if (deleted) {
    throw new NullPointerException();
  }
  Set<Entry<K,V>> ret=new HashSet<>();
  for (  K key : keySet()) {
    ret.add(new FileEntry<>(this,key));
  }
  return ret;
}",0.9726315789473684
61616,"public void fixCharactersOrder(boolean checkAll){
  Set<Integer> addedCharacterIds=new HashSet<>();
  Set<CharacterTag> movedTags=new HashSet<>();
  for (int i=0; i < tags.size(); i++) {
    Tag tag=tags.get(i);
    if (checkAll || tag.isModified()) {
      Set<Integer> needed=new HashSet<>();
      tag.getNeededCharacters(needed);
      boolean moved=false;
      for (      Integer id : needed) {
        if (!addedCharacterIds.contains(id)) {
          CharacterTag neededCharacter=characters.get(id);
          if (movedTags.contains(neededCharacter)) {
            logger.log(Level.SEVERE,""String_Node_Str"");
            return;
          }
          tags.remove(neededCharacter);
          tags.add(i,neededCharacter);
          movedTags.add(neededCharacter);
          moved=true;
        }
      }
      if (moved) {
        i--;
        continue;
      }
    }
    if (tag instanceof CharacterTag) {
      addedCharacterIds.add(((CharacterTag)tag).getCharacterId());
    }
  }
}","public void fixCharactersOrder(boolean checkAll){
  Set<Integer> addedCharacterIds=new HashSet<>();
  Set<CharacterTag> movedTags=new HashSet<>();
  for (int i=0; i < tags.size(); i++) {
    Tag tag=tags.get(i);
    if (checkAll || tag.isModified()) {
      Set<Integer> needed=new HashSet<>();
      tag.getNeededCharacters(needed);
      boolean moved=false;
      for (      Integer id : needed) {
        if (!addedCharacterIds.contains(id)) {
          CharacterTag neededCharacter=characters.get(id);
          if (neededCharacter == null) {
            continue;
          }
          if (movedTags.contains(neededCharacter)) {
            logger.log(Level.SEVERE,""String_Node_Str"");
            return;
          }
          tags.remove(neededCharacter);
          tags.add(i,neededCharacter);
          movedTags.add(neededCharacter);
          moved=true;
        }
      }
      if (moved) {
        i--;
        continue;
      }
    }
    if (tag instanceof CharacterTag) {
      addedCharacterIds.add(((CharacterTag)tag).getCharacterId());
    }
  }
}",0.9635036496350364
61617,"public List<GraphTargetItem> toGraphTargetItems(String path,boolean isStatic,int scriptIndex,int classIndex,ABC abc,AVM2ConstantPool constants,List<MethodInfo> method_info,MethodBody body,HashMap<Integer,String> localRegNames,ScopeStack scopeStack,boolean isStaticInitializer,List<String> fullyQualifiedNames,Traits initTraits,int staticOperation,HashMap<Integer,Integer> localRegAssigmentIps,HashMap<Integer,List<Integer>> refs) throws InterruptedException {
  initToSource();
  List<GraphTargetItem> list;
  HashMap<Integer,GraphTargetItem> localRegs=new HashMap<>();
  int regCount=getRegisterCount();
  list=AVM2Graph.translateViaGraph(path,this,abc,body,isStatic,scriptIndex,classIndex,localRegs,scopeStack,localRegNames,fullyQualifiedNames,staticOperation,localRegAssigmentIps,refs);
  if (initTraits != null) {
    for (int i=0; i < list.size(); i++) {
      GraphTargetItem ti=list.get(i);
      if ((ti instanceof InitPropertyAVM2Item) || (ti instanceof SetPropertyAVM2Item)) {
        int multinameIndex=0;
        GraphTargetItem value=null;
        if (ti instanceof InitPropertyAVM2Item) {
          multinameIndex=((InitPropertyAVM2Item)ti).propertyName.multinameIndex;
          value=((InitPropertyAVM2Item)ti).value;
        }
        if (ti instanceof SetPropertyAVM2Item) {
          multinameIndex=((FullMultinameAVM2Item)((SetPropertyAVM2Item)ti).propertyName).multinameIndex;
          value=((SetPropertyAVM2Item)ti).value;
        }
        for (        Trait t : initTraits.traits) {
          if (t.name_index == multinameIndex) {
            if ((t instanceof TraitSlotConst)) {
              if (((TraitSlotConst)t).isConst() || isStaticInitializer) {
                ((TraitSlotConst)t).assignedValue=value;
                list.remove(i);
                i--;
                continue;
              }
              break;
            }
          }
        }
      }
 else {
      }
    }
  }
  if (isStaticInitializer) {
    List<GraphTargetItem> newList=new ArrayList<>();
    for (    GraphTargetItem ti : list) {
      if (!(ti instanceof ReturnVoidAVM2Item)) {
        if (!(ti instanceof InitPropertyAVM2Item)) {
          if (!(ti instanceof SetPropertyAVM2Item)) {
            newList.add(ti);
          }
        }
      }
    }
    list=newList;
    if (list.isEmpty()) {
      return list;
    }
  }
  boolean[] declaredRegisters=new boolean[regCount];
  for (int b=0; b < declaredRegisters.length; b++) {
    declaredRegisters[b]=false;
  }
  List<Slot> declaredSlots=new ArrayList<>();
  for (int i=0; i < list.size(); i++) {
    GraphTargetItem ti=list.get(i);
    if (ti instanceof SetLocalAVM2Item) {
      int reg=((SetLocalAVM2Item)ti).regIndex;
      if (!declaredRegisters[reg]) {
        list.set(i,new DeclarationAVM2Item(ti));
        declaredRegisters[reg]=true;
      }
    }
    if (ti instanceof SetSlotAVM2Item) {
      SetSlotAVM2Item ssti=(SetSlotAVM2Item)ti;
      Slot sl=new Slot(ssti.scope,ssti.slotName);
      if (!declaredSlots.contains(sl)) {
        GraphTargetItem type=TypeItem.UNBOUNDED;
        for (int t=0; t < body.traits.traits.size(); t++) {
          if (body.traits.traits.get(t).getName(abc) == sl.multiname) {
            if (body.traits.traits.get(t) instanceof TraitSlotConst) {
              type=PropertyAVM2Item.multinameToType(((TraitSlotConst)body.traits.traits.get(t)).type_index,abc.constants);
            }
          }
        }
        list.set(i,new DeclarationAVM2Item(ti,type));
        declaredSlots.add(sl);
      }
    }
  }
  int lastPos=list.size() - 1;
  if (lastPos < 0) {
    lastPos=0;
  }
  if ((list.size() > lastPos) && (list.get(lastPos) instanceof ScriptEndItem)) {
    lastPos--;
  }
  if (lastPos < 0) {
    lastPos=0;
  }
  if ((list.size() > lastPos) && (list.get(lastPos) instanceof ReturnVoidAVM2Item)) {
    list.remove(lastPos);
  }
  return list;
}","public List<GraphTargetItem> toGraphTargetItems(String path,boolean isStatic,int scriptIndex,int classIndex,ABC abc,AVM2ConstantPool constants,List<MethodInfo> method_info,MethodBody body,HashMap<Integer,String> localRegNames,ScopeStack scopeStack,boolean isStaticInitializer,List<String> fullyQualifiedNames,Traits initTraits,int staticOperation,HashMap<Integer,Integer> localRegAssigmentIps,HashMap<Integer,List<Integer>> refs) throws InterruptedException {
  initToSource();
  List<GraphTargetItem> list;
  HashMap<Integer,GraphTargetItem> localRegs=new HashMap<>();
  int regCount=getRegisterCount();
  list=AVM2Graph.translateViaGraph(path,this,abc,body,isStatic,scriptIndex,classIndex,localRegs,scopeStack,localRegNames,fullyQualifiedNames,staticOperation,localRegAssigmentIps,refs);
  if (initTraits != null) {
    for (int i=0; i < list.size(); i++) {
      GraphTargetItem ti=list.get(i);
      if ((ti instanceof InitPropertyAVM2Item) || (ti instanceof SetPropertyAVM2Item)) {
        int multinameIndex=0;
        GraphTargetItem value=null;
        if (ti instanceof InitPropertyAVM2Item) {
          multinameIndex=((InitPropertyAVM2Item)ti).propertyName.multinameIndex;
          value=((InitPropertyAVM2Item)ti).value;
        }
        if (ti instanceof SetPropertyAVM2Item) {
          multinameIndex=((FullMultinameAVM2Item)((SetPropertyAVM2Item)ti).propertyName).multinameIndex;
          value=((SetPropertyAVM2Item)ti).value;
        }
        for (        Trait t : initTraits.traits) {
          if (t.name_index == multinameIndex) {
            if ((t instanceof TraitSlotConst)) {
              if (((TraitSlotConst)t).isConst() || isStaticInitializer) {
                ((TraitSlotConst)t).assignedValue=value;
                list.remove(i);
                i--;
                continue;
              }
              break;
            }
          }
        }
      }
 else {
      }
    }
  }
  if (isStaticInitializer) {
    List<GraphTargetItem> newList=new ArrayList<>();
    for (    GraphTargetItem ti : list) {
      if (!(ti instanceof ReturnVoidAVM2Item)) {
        if (!(ti instanceof InitPropertyAVM2Item)) {
          if (!(ti instanceof SetPropertyAVM2Item)) {
            newList.add(ti);
          }
        }
      }
    }
    list=newList;
    if (list.isEmpty()) {
      return list;
    }
  }
  injectDeclarations(list,new boolean[regCount],new ArrayList<Slot>(),abc,body);
  int lastPos=list.size() - 1;
  if (lastPos < 0) {
    lastPos=0;
  }
  if ((list.size() > lastPos) && (list.get(lastPos) instanceof ScriptEndItem)) {
    lastPos--;
  }
  if (lastPos < 0) {
    lastPos=0;
  }
  if ((list.size() > lastPos) && (list.get(lastPos) instanceof ReturnVoidAVM2Item)) {
    list.remove(lastPos);
  }
  return list;
}",0.8183325795266094
61618,"@Override protected GraphTargetItem checkLoop(LoopItem loopItem,BaseLocalData localData,List<Loop> loops){
  AVM2LocalData aLocalData=(AVM2LocalData)localData;
  if (loopItem instanceof WhileItem) {
    WhileItem w=(WhileItem)loopItem;
    if ((!w.expression.isEmpty()) && (w.expression.get(w.expression.size() - 1) instanceof HasNextAVM2Item)) {
      if (((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection != null) {
        if (((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection.getNotCoerced().getThroughRegister() instanceof FilteredCheckAVM2Item) {
          if (w.commands.size() >= 3) {
            int pos=0;
            while (w.commands.get(pos) instanceof SetLocalAVM2Item) {
              pos++;
            }
            GraphTargetItem ft=w.commands.get(pos);
            if (ft instanceof WithAVM2Item) {
              ft=w.commands.get(pos + 1);
              if (ft instanceof IfItem) {
                IfItem ift=(IfItem)ft;
                if (ift.onTrue.size() > 0) {
                  ft=ift.onTrue.get(0);
                  if (ft instanceof SetPropertyAVM2Item) {
                    SetPropertyAVM2Item spt=(SetPropertyAVM2Item)ft;
                    if (spt.object instanceof LocalRegAVM2Item) {
                      int regIndex=((LocalRegAVM2Item)spt.object).regIndex;
                      HasNextAVM2Item iti=(HasNextAVM2Item)w.expression.get(w.expression.size() - 1);
                      HashMap<Integer,GraphTargetItem> localRegs=aLocalData.localRegs;
                      localRegs.put(regIndex,new FilterAVM2Item(null,iti.collection.getThroughRegister(),ift.expression));
                      return null;
                    }
                  }
                }
              }
            }
          }
        }
 else         if (!w.commands.isEmpty()) {
          if (w.commands.get(0) instanceof SetTypeAVM2Item) {
            SetTypeAVM2Item sti=(SetTypeAVM2Item)w.commands.remove(0);
            GraphTargetItem gti=sti.getValue().getNotCoerced();
            if (gti instanceof NextValueAVM2Item) {
              return new ForEachInAVM2Item(w.src,w.loop,new InAVM2Item(null,sti.getObject(),((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection),w.commands);
            }
 else             if (gti instanceof NextNameAVM2Item) {
              return new ForInAVM2Item(w.src,w.loop,new InAVM2Item(null,sti.getObject(),((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection),w.commands);
            }
          }
        }
      }
    }
  }
  return loopItem;
}","@Override protected GraphTargetItem checkLoop(LoopItem loopItem,BaseLocalData localData,List<Loop> loops){
  AVM2LocalData aLocalData=(AVM2LocalData)localData;
  if (loopItem instanceof WhileItem) {
    WhileItem w=(WhileItem)loopItem;
    if ((!w.expression.isEmpty()) && (w.expression.get(w.expression.size() - 1) instanceof HasNextAVM2Item)) {
      HasNextAVM2Item hn=(HasNextAVM2Item)w.expression.get(w.expression.size() - 1);
      if (((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection != null) {
        if (((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection.getNotCoerced().getThroughRegister() instanceof FilteredCheckAVM2Item) {
          if (w.commands.size() >= 3) {
            int pos=0;
            while (w.commands.get(pos) instanceof SetLocalAVM2Item) {
              pos++;
            }
            GraphTargetItem ft=w.commands.get(pos);
            if (ft instanceof WithAVM2Item) {
              ft=w.commands.get(pos + 1);
              if (ft instanceof IfItem) {
                IfItem ift=(IfItem)ft;
                if (ift.onTrue.size() > 0) {
                  ft=ift.onTrue.get(0);
                  if (ft instanceof SetPropertyAVM2Item) {
                    SetPropertyAVM2Item spt=(SetPropertyAVM2Item)ft;
                    if (spt.object instanceof LocalRegAVM2Item) {
                      int regIndex=((LocalRegAVM2Item)spt.object).regIndex;
                      HasNextAVM2Item iti=(HasNextAVM2Item)w.expression.get(w.expression.size() - 1);
                      HashMap<Integer,GraphTargetItem> localRegs=aLocalData.localRegs;
                      localRegs.put(regIndex,new FilterAVM2Item(null,iti.collection.getThroughRegister(),ift.expression));
                      return null;
                    }
                  }
                }
              }
            }
          }
        }
 else         if (!w.commands.isEmpty()) {
          if (w.commands.get(0) instanceof SetTypeAVM2Item) {
            SetTypeAVM2Item sti=(SetTypeAVM2Item)w.commands.remove(0);
            GraphTargetItem gti=sti.getValue().getNotCoerced();
            if (gti instanceof NextValueAVM2Item) {
              return new ForEachInAVM2Item(w.src,w.loop,new InAVM2Item(hn.instruction,sti.getObject(),((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection),w.commands);
            }
 else             if (gti instanceof NextNameAVM2Item) {
              return new ForInAVM2Item(w.src,w.loop,new InAVM2Item(hn.instruction,sti.getObject(),((HasNextAVM2Item)w.expression.get(w.expression.size() - 1)).collection),w.commands);
            }
          }
        }
      }
    }
  }
  return loopItem;
}",0.9778534923339012
61619,"public AVM2Item(GraphSourceItem instruction,int precedence){
  super(instruction,precedence);
}","public AVM2Item(GraphSourceItem instruction,int precedence){
  super(instruction,precedence);
  if (instruction instanceof AVM2Instruction) {
    this.instruction=(AVM2Instruction)instruction;
  }
}",0.6484641638225256
61620,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  if (slotName == null) {
    return writer.append(""String_Node_Str"");
  }
  srcData.put(""String_Node_Str"",slotName.getName(localData.constantsAvm2,localData.fullyQualifiedNames,false));
  return writer.append(slotName.getName(localData.constantsAvm2,localData.fullyQualifiedNames,false));
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  if (slotName == null) {
    return writer.append(""String_Node_Str"");
  }
  srcData.put(""String_Node_Str"",getNameAsStr(localData));
  return writer.append(slotName.getName(localData.constantsAvm2,localData.fullyQualifiedNames,false));
}",0.7834757834757835
61621,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (assignment instanceof SetLocalAVM2Item) {
    SetLocalAVM2Item lti=(SetLocalAVM2Item)assignment;
    String localName=localRegName(localData.localRegNames,lti.regIndex);
    srcData.put(""String_Node_Str"",localName);
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    GraphTargetItem coerType=TypeItem.UNBOUNDED;
    if (lti.value instanceof CoerceAVM2Item) {
      coerType=((CoerceAVM2Item)lti.value).typeObj;
    }
    if (lti.value instanceof ConvertAVM2Item) {
      coerType=((ConvertAVM2Item)lti.value).type;
    }
    writer.append(""String_Node_Str"");
    writer.append(localName);
    writer.append(""String_Node_Str"");
    coerType.appendTo(writer,localData);
    writer.append(""String_Node_Str"");
    return lti.value.toString(writer,localData);
  }
  if (assignment instanceof SetSlotAVM2Item) {
    SetSlotAVM2Item ssti=(SetSlotAVM2Item)assignment;
    srcData.put(""String_Node_Str"",ssti.getNameAsStr(localData));
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    writer.append(""String_Node_Str"");
    ssti.getName(writer,localData);
    writer.append(""String_Node_Str"");
    type.appendTo(writer,localData);
    writer.append(""String_Node_Str"");
    return ssti.value.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  return assignment.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (assignment instanceof LocalRegAVM2Item) {
    LocalRegAVM2Item lti=(LocalRegAVM2Item)assignment;
    String localName=localRegName(localData.localRegNames,lti.regIndex);
    srcData.put(""String_Node_Str"",localName);
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    writer.append(""String_Node_Str"");
    writer.append(localName);
    return writer;
  }
  if (assignment instanceof GetSlotAVM2Item) {
    GetSlotAVM2Item sti=(GetSlotAVM2Item)assignment;
    srcData.put(""String_Node_Str"",sti.getNameAsStr(localData));
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    writer.append(""String_Node_Str"");
    sti.getName(writer,localData);
    return writer;
  }
  if (assignment instanceof SetLocalAVM2Item) {
    SetLocalAVM2Item lti=(SetLocalAVM2Item)assignment;
    String localName=localRegName(localData.localRegNames,lti.regIndex);
    srcData.put(""String_Node_Str"",localName);
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    GraphTargetItem coerType=TypeItem.UNBOUNDED;
    if (lti.value instanceof CoerceAVM2Item) {
      coerType=((CoerceAVM2Item)lti.value).typeObj;
    }
    if (lti.value instanceof ConvertAVM2Item) {
      coerType=((ConvertAVM2Item)lti.value).type;
    }
    writer.append(""String_Node_Str"");
    writer.append(localName);
    writer.append(""String_Node_Str"");
    coerType.appendTo(writer,localData);
    writer.append(""String_Node_Str"");
    return lti.value.toString(writer,localData);
  }
  if (assignment instanceof SetSlotAVM2Item) {
    SetSlotAVM2Item ssti=(SetSlotAVM2Item)assignment;
    srcData.put(""String_Node_Str"",ssti.getNameAsStr(localData));
    srcData.put(""String_Node_Str"",""String_Node_Str"");
    writer.append(""String_Node_Str"");
    ssti.getName(writer,localData);
    writer.append(""String_Node_Str"");
    type.appendTo(writer,localData);
    writer.append(""String_Node_Str"");
    return ssti.value.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  return assignment.toString(writer,localData);
}",0.4744998591152437
61622,"public GraphTextWriter getParamStr(GraphTextWriter writer,AVM2ConstantPool constants,MethodBody body,ABC abc,List<String> fullyQualifiedNames){
  Map<Integer,String> localRegNames=new HashMap<>();
  if (body != null && Configuration.getLocalNamesFromDebugInfo.get()) {
    localRegNames=body.getCode().getLocalRegNamesFromDebug(abc);
  }
  Map<String,String> pdata;
  for (int i=0; i < param_types.length; i++) {
    if (i > 0) {
      writer.appendNoHilight(""String_Node_Str"");
    }
    pdata=new HashMap<>();
    pdata.put(""String_Node_Str"",""String_Node_Str"");
    if (!localRegNames.isEmpty()) {
      pdata.put(""String_Node_Str"",localRegNames.get(i + 1));
      writer.hilightSpecial(IdentifiersDeobfuscation.printIdentifier(true,localRegNames.get(i + 1)),""String_Node_Str"",i,pdata);
    }
 else     if ((paramNames.length > i) && (paramNames[i] != 0) && Configuration.paramNamesEnable.get()) {
      writer.hilightSpecial(IdentifiersDeobfuscation.printIdentifier(true,constants.getString(paramNames[i])),""String_Node_Str"",i,pdata);
    }
 else {
      writer.hilightSpecial(""String_Node_Str"" + (i + 1),""String_Node_Str"",i,pdata);
    }
    writer.appendNoHilight(""String_Node_Str"");
    if (param_types[i] == 0) {
      writer.hilightSpecial(""String_Node_Str"",""String_Node_Str"",i);
    }
 else {
      writer.hilightSpecial(constants.getMultiname(param_types[i]).getName(constants,fullyQualifiedNames,false),""String_Node_Str"",i);
    }
    if (optional != null) {
      if (i >= param_types.length - optional.length) {
        int optionalIndex=i - (param_types.length - optional.length);
        writer.appendNoHilight(""String_Node_Str"");
        writer.hilightSpecial(optional[optionalIndex].toString(constants),""String_Node_Str"",optionalIndex);
      }
    }
  }
  if (flagNeed_rest()) {
    String restAdd=""String_Node_Str"";
    if ((param_types != null) && (param_types.length > 0)) {
      restAdd+=""String_Node_Str"";
    }
    restAdd+=""String_Node_Str"";
    String restName;
    if (!localRegNames.isEmpty()) {
      restName=localRegNames.get(param_types.length + 1);
    }
 else {
      restName=""String_Node_Str"";
    }
    restAdd+=restName;
    pdata=new HashMap<>();
    pdata.put(""String_Node_Str"",""String_Node_Str"");
    pdata.put(""String_Node_Str"",restName);
    writer.hilightSpecial(restAdd,""String_Node_Str"",0,pdata);
  }
  return writer;
}","public GraphTextWriter getParamStr(GraphTextWriter writer,AVM2ConstantPool constants,MethodBody body,ABC abc,List<String> fullyQualifiedNames){
  Map<Integer,String> localRegNames=new HashMap<>();
  if (body != null && Configuration.getLocalNamesFromDebugInfo.get()) {
    localRegNames=body.getCode().getLocalRegNamesFromDebug(abc);
  }
  Map<String,String> pdata;
  for (int i=0; i < param_types.length; i++) {
    if (i > 0) {
      writer.appendNoHilight(""String_Node_Str"");
    }
    pdata=new HashMap<>();
    pdata.put(""String_Node_Str"",""String_Node_Str"");
    if (!localRegNames.isEmpty()) {
      pdata.put(""String_Node_Str"",localRegNames.get(i + 1));
      writer.hilightSpecial(IdentifiersDeobfuscation.printIdentifier(true,localRegNames.get(i + 1)),""String_Node_Str"",i,pdata);
    }
 else     if ((paramNames.length > i) && (paramNames[i] != 0) && Configuration.paramNamesEnable.get()) {
      pdata.put(""String_Node_Str"",constants.getString(paramNames[i]));
      writer.hilightSpecial(IdentifiersDeobfuscation.printIdentifier(true,constants.getString(paramNames[i])),""String_Node_Str"",i,pdata);
    }
 else {
      pdata.put(""String_Node_Str"",""String_Node_Str"" + (i + 1));
      writer.hilightSpecial(""String_Node_Str"" + (i + 1),""String_Node_Str"",i,pdata);
    }
    writer.appendNoHilight(""String_Node_Str"");
    if (param_types[i] == 0) {
      writer.hilightSpecial(""String_Node_Str"",""String_Node_Str"",i);
    }
 else {
      writer.hilightSpecial(constants.getMultiname(param_types[i]).getName(constants,fullyQualifiedNames,false),""String_Node_Str"",i);
    }
    if (optional != null) {
      if (i >= param_types.length - optional.length) {
        int optionalIndex=i - (param_types.length - optional.length);
        writer.appendNoHilight(""String_Node_Str"");
        writer.hilightSpecial(optional[optionalIndex].toString(constants),""String_Node_Str"",optionalIndex);
      }
    }
  }
  if (flagNeed_rest()) {
    String restAdd=""String_Node_Str"";
    if ((param_types != null) && (param_types.length > 0)) {
      restAdd+=""String_Node_Str"";
    }
    restAdd+=""String_Node_Str"";
    String restName;
    if (!localRegNames.isEmpty()) {
      restName=localRegNames.get(param_types.length + 1);
    }
 else {
      restName=""String_Node_Str"";
    }
    pdata=new HashMap<>();
    pdata.put(""String_Node_Str"",""String_Node_Str"");
    pdata.put(""String_Node_Str"",restName);
    writer.append(restAdd);
    writer.hilightSpecial(restName,""String_Node_Str"",0,pdata);
  }
  return writer;
}",0.9558793351118408
61623,"public void createContextMenu(final List<SWFList> swfs){
}","public void createContextMenu(final List<SWFList> swfs){
  this.swfs=swfs;
  contextPopupMenu=new JPopupMenu();
  expandRecursiveMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  expandRecursiveMenuItem.addActionListener(this);
  expandRecursiveMenuItem.setActionCommand(ACTION_EXPAND_RECURSIVE);
  contextPopupMenu.add(expandRecursiveMenuItem);
  removeMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  removeMenuItem.addActionListener(this);
  removeMenuItem.setActionCommand(ACTION_REMOVE_ITEM);
  contextPopupMenu.add(removeMenuItem);
  removeWithDependenciesMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  removeWithDependenciesMenuItem.addActionListener(this);
  removeWithDependenciesMenuItem.setActionCommand(ACTION_REMOVE_ITEM_WITH_DEPENDENCIES);
  contextPopupMenu.add(removeWithDependenciesMenuItem);
  exportSelectionMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  exportSelectionMenuItem.setActionCommand(MainFrameRibbonMenu.ACTION_EXPORT_SEL);
  exportSelectionMenuItem.addActionListener(mainPanel);
  contextPopupMenu.add(exportSelectionMenuItem);
  replaceSelectionMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  replaceSelectionMenuItem.setActionCommand(MainPanel.ACTION_REPLACE);
  replaceSelectionMenuItem.addActionListener(mainPanel);
  contextPopupMenu.add(replaceSelectionMenuItem);
  rawEditMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  rawEditMenuItem.setActionCommand(ACTION_RAW_EDIT);
  rawEditMenuItem.addActionListener(this);
  rawEditMenuItem.setVisible(false);
  contextPopupMenu.add(rawEditMenuItem);
  jumpToCharacterMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  jumpToCharacterMenuItem.setActionCommand(ACTION_JUMP_TO_CHARACTER);
  jumpToCharacterMenuItem.addActionListener(this);
  jumpToCharacterMenuItem.setVisible(false);
  contextPopupMenu.add(jumpToCharacterMenuItem);
  closeSelectionMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  closeSelectionMenuItem.setActionCommand(ACTION_CLOSE_SWF);
  closeSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(closeSelectionMenuItem);
  addTagMenu=new JMenu(mainPanel.translate(""String_Node_Str""));
  contextPopupMenu.add(addTagMenu);
  moveTagMenu=new JMenu(mainPanel.translate(""String_Node_Str""));
  contextPopupMenu.add(moveTagMenu);
  openSWFInsideTagMenuItem=new JMenuItem(mainPanel.translate(""String_Node_Str""));
  contextPopupMenu.add(openSWFInsideTagMenuItem);
  openSWFInsideTagMenuItem.setActionCommand(ACTION_OPEN_SWFINSIDE);
  openSWFInsideTagMenuItem.addActionListener(this);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (SwingUtilities.isRightMouseButton(e)) {
        int row=getClosestRowForLocation(e.getX(),e.getY());
        int[] selectionRows=getSelectionRows();
        if (!Helper.contains(selectionRows,row)) {
          setSelectionRow(row);
        }
        TreePath[] paths=getSelectionPaths();
        if (paths == null || paths.length == 0) {
          return;
        }
        boolean allSelectedIsTagOrFrame=true;
        for (        TreePath treePath : paths) {
          TreeItem tag=(TreeItem)treePath.getLastPathComponent();
          if (!(tag instanceof Tag) && !(tag instanceof Frame)) {
            allSelectedIsTagOrFrame=false;
            break;
          }
        }
        replaceSelectionMenuItem.setVisible(false);
        closeSelectionMenuItem.setVisible(false);
        moveTagMenu.setVisible(false);
        addTagMenu.setVisible(false);
        expandRecursiveMenuItem.setVisible(false);
        openSWFInsideTagMenuItem.setVisible(false);
        if (paths.length == 1) {
          TreeItem item=(TreeItem)paths[0].getLastPathComponent();
          List<TreeItem> li=new ArrayList<>();
          li.add(item);
          updateContextMenu(swfs,li);
        }
        removeMenuItem.setVisible(allSelectedIsTagOrFrame);
        exportSelectionMenuItem.setEnabled(hasExportableNodes());
        contextPopupMenu.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
}",0.0277114190157668
61624,"public void updateContextMenu(final List<SWFList> swfs,List<TreeItem> items){
}","public void updateContextMenu(final List<SWFList> swfs,List<TreeItem> items){
  replaceSelectionMenuItem.setVisible(false);
  closeSelectionMenuItem.setVisible(false);
  moveTagMenu.setVisible(false);
  addTagMenu.setVisible(false);
  expandRecursiveMenuItem.setVisible(false);
  openSWFInsideTagMenuItem.setVisible(false);
  removeMenuItem.setVisible(true);
  for (  TreeItem t : items) {
    if (!((t instanceof Tag) || (t instanceof Frame))) {
      removeMenuItem.setVisible(false);
    }
  }
  exportSelectionMenuItem.setEnabled(!items.isEmpty() && !getSelection(items.get(0).getSwf(),items).isEmpty());
  final TreeItem item=items.get(0);
  if (item instanceof ImageTag && ((ImageTag)item).importSupported()) {
    replaceSelectionMenuItem.setVisible(true);
  }
  if (item instanceof DefineBinaryDataTag) {
    replaceSelectionMenuItem.setVisible(true);
    DefineBinaryDataTag bin=(DefineBinaryDataTag)item;
    if (bin.binaryData.length > 8) {
      String signature=new String(bin.binaryData,0,3,Utf8Helper.charset);
      if (Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(signature)) {
        openSWFInsideTagMenuItem.setVisible(true);
      }
    }
  }
  if (item instanceof DefineSoundTag) {
    replaceSelectionMenuItem.setVisible(true);
  }
  if (item instanceof SWF) {
    closeSelectionMenuItem.setVisible(true);
  }
  List<Integer> allowedTagTypes=null;
  if (item instanceof FolderItem) {
    allowedTagTypes=getSwfFolderItemNestedTagIds(((FolderItem)item).getName(),item.getSwf().gfx);
  }
 else   if (item instanceof DefineSpriteTag) {
    allowedTagTypes=getSpriteNestedTagIds();
  }
  addTagMenu.removeAll();
  if (allowedTagTypes != null) {
    for (    Integer tagId : allowedTagTypes) {
      final Class cl=TagIdClassMap.getClassByTagId(tagId);
      JMenuItem tagItem=new JMenuItem(cl.getSimpleName());
      tagItem.addActionListener(new ActionListener(){
        @Override @SuppressWarnings(""String_Node_Str"") public void actionPerformed(        ActionEvent ae){
          try {
            SWF swf=item.getSwf();
            Tag t=(Tag)cl.getDeclaredConstructor(SWF.class).newInstance(new Object[]{swf});
            boolean isDefineSprite=item instanceof DefineSpriteTag;
            Timelined timelined=isDefineSprite ? (DefineSpriteTag)item : swf;
            t.setTimelined(timelined);
            if (isDefineSprite) {
              ((DefineSpriteTag)item).subTags.add(t);
            }
 else {
              swf.tags.add(t);
            }
            timelined.getTimeline().reset();
            swf.updateCharacters();
            mainPanel.refreshTree();
          }
 catch (          InstantiationException|IllegalAccessException|NoSuchMethodException|SecurityException|IllegalArgumentException|InvocationTargetException ex) {
            Logger.getLogger(TagTree.class.getName()).log(Level.SEVERE,null,ex);
          }
        }
      }
);
      addTagMenu.add(tagItem);
    }
    addTagMenu.setVisible(true);
  }
  if (item instanceof Tag && swfs.size() > 1) {
    final Tag tag=(Tag)item;
    moveTagMenu.removeAll();
    for (    SWFList targetSwfList : swfs) {
      for (      final SWF targetSwf : targetSwfList) {
        if (targetSwf != tag.getSwf()) {
          JMenuItem swfItem=new JMenuItem(targetSwf.getShortFileName());
          swfItem.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent ae){
              tag.getSwf().tags.remove(tag);
              tag.setSwf(targetSwf);
              targetSwf.tags.add(tag);
              mainPanel.refreshTree();
            }
          }
);
          moveTagMenu.add(swfItem);
        }
      }
    }
    moveTagMenu.setVisible(true);
  }
  TreeModel model=getModel();
  expandRecursiveMenuItem.setVisible(model.getChildCount(item) > 0);
  jumpToCharacterMenuItem.setVisible(item instanceof CharacterIdTag && !(item instanceof CharacterTag));
  rawEditMenuItem.setVisible(item instanceof Tag);
}",0.0385084084815988
61625,"@Override public FileTextWriter hilightSpecial(String text,String type,int index){
  writeToFile(text);
  return this;
}","@Override public GraphTextWriter hilightSpecial(String text,String type,int index,Map<String,String> data){
  writeToFile(text);
  return this;
}",0.8754716981132076
61626,"@Override public void addCharacter(char character,Font cfont){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  double d=1;
  SHAPE shp=SHAPERECORD.fontCharacterToSHAPE(cfont,fontStyle,(int)(SWF.unitDivisor * font.nominalSize * d),character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode >= code) {
      if (font.glyphInfo.get(i).glyphCode == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  if (!exists) {
    shiftGlyphIndices(fontId,pos);
  }
  Font fnt=cfont.deriveFont(fontStyle,Math.round(font.nominalSize * d));
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  if (!exists) {
    font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
    shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  }
 else {
    font.glyphInfo.set(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.set(pos,new GlyphType(shp.shapeRecords));
    shapeCache.set(pos,font.glyphs.get(pos).toSHAPE());
  }
  setModified(true);
  SWF.clearImageCache();
}","@Override public void addCharacter(char character,Font cfont){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  double d=1;
  SHAPE shp=SHAPERECORD.fontCharacterToSHAPE(cfont,fontStyle,(int)(font.nominalSize * d),character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode >= code) {
      if (font.glyphInfo.get(i).glyphCode == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  if (!exists) {
    shiftGlyphIndices(fontId,pos);
  }
  Font fnt=cfont.deriveFont(fontStyle,Math.round(font.nominalSize * d));
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  if (!exists) {
    font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
    shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  }
 else {
    font.glyphInfo.set(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.set(pos,new GlyphType(shp.shapeRecords));
    shapeCache.set(pos,font.glyphs.get(pos).toSHAPE());
  }
  setModified(true);
  SWF.clearImageCache();
}",0.993212669683258
61627,"public ContourType(GFxInputStream sis) throws IOException {
  moveToX=sis.readSI15(""String_Node_Str"");
  moveToY=sis.readSI15(""String_Node_Str"");
  long numEdgesRef=sis.readUI30(""String_Node_Str"");
  isReference=(numEdgesRef & 1) == 1;
  numEdgesRef>>=1;
  long oldPos=sis.getPos();
  if (isReference) {
    sis.setPos(numEdgesRef);
    numEdgesRef=sis.readUI30(""String_Node_Str"");
    numEdgesRef>>=1;
  }
  edges=new EdgeType[(int)numEdgesRef];
  for (int i=0; i < edges.length; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    edges[i]=new EdgeType(sis);
    sis.endDumpLevel();
  }
  if (isReference) {
    sis.setPos(oldPos);
  }
}","public ContourType(GFxInputStream sis,long fontOffset) throws IOException {
  moveToX=sis.readSI15(""String_Node_Str"");
  moveToY=sis.readSI15(""String_Node_Str"");
  long numEdgesRef=sis.readUI30(""String_Node_Str"");
  isReference=(numEdgesRef & 1) == 1;
  numEdgesRef>>=1;
  long oldPos=sis.getPos();
  int numEdges;
  if (isReference) {
    long referencePos=numEdgesRef;
    sis.setPos(fontOffset + referencePos);
    numEdges=(int)(sis.readUI30(""String_Node_Str"") >> 1);
  }
 else {
    numEdges=(int)numEdgesRef;
  }
  edges=new EdgeType[(int)numEdges];
  for (int i=0; i < edges.length; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    edges[i]=new EdgeType(sis);
    sis.endDumpLevel();
  }
  if (isReference) {
    sis.setPos(oldPos);
  }
}",0.8559381588193956
61628,"public FontType(GFxInputStream sis) throws IOException {
  long offset=sis.getPos();
  fontName=sis.readString(""String_Node_Str"");
  flags=sis.readUI16(""String_Node_Str"");
  nominalSize=sis.readUI16(""String_Node_Str"");
  ascent=sis.readSI16(""String_Node_Str"");
  descent=sis.readSI16(""String_Node_Str"");
  leading=sis.readSI16(""String_Node_Str"");
  long numGlyphs=sis.readUI32(""String_Node_Str"");
  long glyphBytesLen=sis.readUI32(""String_Node_Str"");
  byte glyphBytes[]=new byte[(int)glyphBytesLen];
  sis.read(glyphBytes);
  glyphInfo=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    glyphInfo.add(new GlyphInfoType(sis));
    sis.endDumpLevel();
  }
  long kerningTableSize=sis.readUI30(""String_Node_Str"");
  kerning=new ArrayList<>();
  for (int i=0; i < kerningTableSize; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    kerning.add(new KerningPairType(sis));
    sis.endDumpLevel();
  }
  long pos=sis.getPos();
  glyphs=new ArrayList<>();
  for (int i=0; i < glyphInfo.size(); i++) {
    sis.setPos(glyphInfo.get(i).globalOffset + offset);
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    glyphs.add(new GlyphType(sis));
    sis.endDumpLevel();
  }
  sis.setPos(pos);
}","public FontType(GFxInputStream sis) throws IOException {
  long offset=sis.getPos();
  fontName=sis.readString(""String_Node_Str"");
  flags=sis.readUI16(""String_Node_Str"");
  nominalSize=sis.readUI16(""String_Node_Str"");
  ascent=sis.readSI16(""String_Node_Str"");
  descent=sis.readSI16(""String_Node_Str"");
  leading=sis.readSI16(""String_Node_Str"");
  long numGlyphs=sis.readUI32(""String_Node_Str"");
  long glyphBytesLen=sis.readUI32(""String_Node_Str"");
  byte glyphBytes[]=new byte[(int)glyphBytesLen];
  sis.read(glyphBytes);
  glyphInfo=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    glyphInfo.add(new GlyphInfoType(sis));
    sis.endDumpLevel();
  }
  long kerningTableSize=sis.readUI30(""String_Node_Str"");
  kerning=new ArrayList<>();
  for (int i=0; i < kerningTableSize; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    kerning.add(new KerningPairType(sis));
    sis.endDumpLevel();
  }
  long pos=sis.getPos();
  glyphs=new ArrayList<>();
  for (int i=0; i < glyphInfo.size(); i++) {
    sis.setPos(glyphInfo.get(i).globalOffset + offset);
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    glyphs.add(new GlyphType(sis,offset));
    sis.endDumpLevel();
  }
  sis.setPos(pos);
}",0.9972773239984442
61629,"public GlyphType(GFxInputStream sis) throws IOException {
  boundingBox=new int[4];
  for (int i=0; i < 4; i++) {
    boundingBox[i]=sis.readSI15(""String_Node_Str"");
  }
  int numContours=sis.readUI15(""String_Node_Str"");
  contours=new ContourType[numContours];
  for (int i=0; i < numContours; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    contours[i]=new ContourType(sis);
    sis.endDumpLevel();
  }
}","public GlyphType(GFxInputStream sis,long fontOffset) throws IOException {
  boundingBox=new int[4];
  for (int i=0; i < 4; i++) {
    boundingBox[i]=sis.readSI15(""String_Node_Str"");
  }
  int numContours=sis.readUI15(""String_Node_Str"");
  contours=new ContourType[numContours];
  for (int i=0; i < numContours; i++) {
    sis.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
    contours[i]=new ContourType(sis,fontOffset);
    sis.endDumpLevel();
  }
}",0.9694224235560588
61630,"private String readString(InputStream is) throws IOException {
  int len=is.read();
  if (len == -1) {
    return ""String_Node_Str"";
  }
  byte buf[]=new byte[len];
  is.read(buf);
  return new String(buf,""String_Node_Str"");
}","private String readString(InputStream is) throws IOException {
  int len=is.read();
  if (len == -1) {
    throw new EOFException();
  }
  byte buf[]=new byte[len];
  for (int i=0; i < len; i++) {
    int rd=is.read();
    if (rd == -1) {
      throw new EOFException();
    }
    buf[i]=(byte)rd;
  }
  return new String(buf,""String_Node_Str"");
}",0.4363001745200698
61631,"public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  DumpInfo diParent=ais.dumpInfo;
  List<Long> addresses=new ArrayList<>();
  addresses.add(ais.getPosition());
  while (!addresses.isEmpty()) {
    long address=addresses.remove(0);
    if (codeMap.containsKey(address)) {
      continue;
    }
    try {
      ais.seek(address);
      while (ais.available() > 0) {
        DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
        long startOffset=ais.getPosition();
        int instructionCode=ais.read(""String_Node_Str"");
        InstructionDefinition instr=instructionSetByCode[instructionCode];
        if (di != null) {
          di.name=instr.instructionName;
        }
        if (instr != null) {
          int[] actualOperands=null;
          if (instructionCode == 0x1b) {
            int firstOperand=ais.readS24(""String_Node_Str"");
            int case_count=ais.readU30(""String_Node_Str"");
            actualOperands=new int[case_count + 3];
            actualOperands[0]=firstOperand;
            actualOperands[1]=case_count;
            for (int c=0; c < case_count + 1; c++) {
              actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
            }
          }
 else {
            if (instr.operands.length > 0) {
              actualOperands=new int[instr.operands.length];
              for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                  actualOperands[op]=ais.readU30(""String_Node_Str"");
                break;
case OPT_U8:
              actualOperands[op]=ais.read(""String_Node_Str"");
            break;
case OPT_BYTE:
          actualOperands[op]=(byte)ais.read(""String_Node_Str"");
        break;
case OPT_S24:
      actualOperands[op]=ais.readS24(""String_Node_Str"");
    break;
}
}
}
}
if (instr instanceof IfTypeIns) {
long target=ais.getPosition() + actualOperands[0];
addresses.add(target);
}
codeMap.put(startOffset,new AVM2Instruction(startOffset,instr,actualOperands));
ais.endDumpLevel(instr.instructionCode);
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
}
code.addAll(codeMap.values());
}","public AVM2Code(ABCInputStream ais) throws IOException {
  Map<Long,AVM2Instruction> codeMap=new TreeMap<>();
  DumpInfo diParent=ais.dumpInfo;
  try {
    while (ais.available() > 0) {
      DumpInfo di=ais.newDumpLevel(""String_Node_Str"",""String_Node_Str"");
      long startOffset=ais.getPosition();
      int instructionCode=ais.read(""String_Node_Str"");
      InstructionDefinition instr=instructionSetByCode[instructionCode];
      if (di != null) {
        di.name=instr.instructionName;
      }
      if (instr != null) {
        int[] actualOperands=null;
        if (instructionCode == 0x1b) {
          int firstOperand=ais.readS24(""String_Node_Str"");
          int case_count=ais.readU30(""String_Node_Str"");
          actualOperands=new int[case_count + 3];
          actualOperands[0]=firstOperand;
          actualOperands[1]=case_count;
          for (int c=0; c < case_count + 1; c++) {
            actualOperands[2 + c]=ais.readS24(""String_Node_Str"");
          }
        }
 else {
          if (instr.operands.length > 0) {
            actualOperands=new int[instr.operands.length];
            for (int op=0; op < instr.operands.length; op++) {
switch (instr.operands[op] & 0xff00) {
case OPT_U30:
                actualOperands[op]=ais.readU30(""String_Node_Str"");
              break;
case OPT_U8:
            actualOperands[op]=ais.readU8(""String_Node_Str"");
          break;
case OPT_BYTE:
        actualOperands[op]=(byte)ais.read(""String_Node_Str"");
      break;
case OPT_S24:
    actualOperands[op]=ais.readS24(""String_Node_Str"");
  break;
}
}
}
}
codeMap.put(startOffset,new AVM2Instruction(startOffset,instr,actualOperands));
ais.endDumpLevel(instr.instructionCode);
}
 else {
ais.endDumpLevel();
break;
}
}
}
 catch (EndOfStreamException ex) {
ais.endDumpLevelUntil(diParent);
}
code.addAll(codeMap.values());
}",0.8706516413522783
61632,"public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item,class_index);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item,class_index);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}","public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item,class_index);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item,class_index);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(false,isInterface,new ArrayList<MethodBody>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(false,isInterface,new ArrayList<MethodBody>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}",0.9970688812896922
61633,"public int method(boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  for (  GraphTargetItem p : paramTypes) {
    slotTypes.add(""String_Node_Str"" + p);
  }
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants,true));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>(),true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
          mbodyCode.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null) {
      mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
      mbodyCode.add(1,new AVM2Instruction(0,new PushScopeIns(),null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,new ReturnVoidIns(),null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,new PushUndefinedIns(),null));
        mbodyCode.add(new AVM2Instruction(0,new ReturnValueIns(),null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}","public int method(boolean subMethod,boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  for (int t=0; t < paramTypes.size(); t++) {
    GraphTargetItem an=paramTypes.get(t);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        paramTypes.set(t,res);
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    List<AVM2Instruction> mbodyCode=toInsList(src);
    mbody.setCode(new AVM2Code());
    mbody.getCode().code=mbodyCode;
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants,true));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>(),true),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbodyCode.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbodyCode.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbodyCode) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
          mbodyCode.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0}));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null && !subMethod) {
      mbodyCode.add(0,new AVM2Instruction(0,new GetLocal0Ins(),null));
      mbodyCode.add(1,new AVM2Instruction(0,new PushScopeIns(),null));
    }
    boolean addRet=false;
    if (!mbodyCode.isEmpty()) {
      InstructionDefinition lastDef=mbodyCode.get(mbodyCode.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbodyCode.add(new AVM2Instruction(0,new ReturnVoidIns(),null));
      }
 else {
        mbodyCode.add(new AVM2Instruction(0,new PushUndefinedIns(),null));
        mbodyCode.add(new AVM2Instruction(0,new ReturnValueIns(),null));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbodyCode.size(); i++) {
      AVM2Instruction ins=mbodyCode.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbodyCode.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}",0.934311100764366
61634,"public static String convertTimeline(int spriteId,List<Integer> nonLibraryShapes,String backgroundColor,List<Tag> tags,List<Tag> timelineTags,HashMap<Integer,CharacterTag> characters,String name,FLAVersion flaVersion,HashMap<String,byte[]> files){
  String ret=""String_Node_Str"";
  ret+=""String_Node_Str"" + name + ""String_Node_Str"";
  ret+=""String_Node_Str"";
  ret+=convertLabelsLayer(spriteId,tags,timelineTags,backgroundColor);
  String scriptLayer=convertActionScriptLayer(spriteId,tags,timelineTags,backgroundColor);
  int index=0;
  if (!scriptLayer.isEmpty()) {
    index++;
  }
  ret+=scriptLayer;
  int layerCount=getLayerCount(timelineTags);
  Stack<Integer> parentLayers=new Stack<>();
  for (int d=layerCount; d >= 1; d--, index++) {
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getClipDepth() == d) {
          for (int m=po.getDepth(); m < po.getClipDepth(); m++) {
            parentLayers.push(index);
          }
          ret+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
          ret+=""String_Node_Str"";
          ret+=""String_Node_Str"";
          ret+=convertFrames(""String_Node_Str"",""String_Node_Str"",nonLibraryShapes,tags,timelineTags,characters,po.getDepth(),flaVersion,files);
          ret+=""String_Node_Str"";
          index++;
          break;
        }
      }
    }
    boolean hasClipDepth=false;
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getDepth() == d) {
          if (po.getClipDepth() != -1) {
            hasClipDepth=true;
            break;
          }
        }
      }
    }
    if (hasClipDepth) {
      index--;
      continue;
    }
    int parentLayer=-1;
    if (!parentLayers.isEmpty()) {
      parentLayer=parentLayers.pop();
    }
    String layerPrev=""String_Node_Str"";
    layerPrev+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
    if (d == 1) {
      layerPrev+=""String_Node_Str"";
    }
    if (parentLayer != -1) {
      if (parentLayer != d) {
        layerPrev+=""String_Node_Str"" + (parentLayer) + ""String_Node_Str"";
      }
    }
    layerPrev+=""String_Node_Str"";
    String layerAfter=""String_Node_Str"";
    String cf=convertFrames(layerPrev,layerAfter,nonLibraryShapes,tags,timelineTags,characters,d,flaVersion,files);
    if (cf.isEmpty()) {
      index--;
    }
    ret+=cf;
  }
  int soundLayerIndex=layerCount;
  layerCount++;
  ret+=convertSoundLayer(soundLayerIndex,backgroundColor,characters,tags,timelineTags,files);
  ret+=""String_Node_Str"";
  ret+=""String_Node_Str"";
  return ret;
}","public static String convertTimeline(int spriteId,List<Integer> nonLibraryShapes,String backgroundColor,List<Tag> tags,List<Tag> timelineTags,HashMap<Integer,CharacterTag> characters,String name,FLAVersion flaVersion,HashMap<String,byte[]> files){
  String ret=""String_Node_Str"";
  ret+=""String_Node_Str"" + name + ""String_Node_Str"";
  ret+=""String_Node_Str"";
  String labelsLayer=convertLabelsLayer(spriteId,tags,timelineTags,backgroundColor);
  ret+=labelsLayer;
  String scriptLayer=convertActionScriptLayer(spriteId,tags,timelineTags,backgroundColor);
  ret+=scriptLayer;
  int index=0;
  if (!labelsLayer.isEmpty()) {
    index++;
  }
  if (!scriptLayer.isEmpty()) {
    index++;
  }
  int layerCount=getLayerCount(timelineTags);
  Stack<Integer> parentLayers=new Stack<>();
  for (int d=layerCount; d >= 1; d--, index++) {
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getClipDepth() == d) {
          for (int m=po.getDepth(); m < po.getClipDepth(); m++) {
            parentLayers.push(index);
          }
          ret+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
          ret+=""String_Node_Str"";
          ret+=""String_Node_Str"";
          ret+=convertFrames(""String_Node_Str"",""String_Node_Str"",nonLibraryShapes,tags,timelineTags,characters,po.getDepth(),flaVersion,files);
          ret+=""String_Node_Str"";
          index++;
          break;
        }
      }
    }
    boolean hasClipDepth=false;
    for (    Tag t : timelineTags) {
      if (t instanceof PlaceObjectTypeTag) {
        PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
        if (po.getDepth() == d) {
          if (po.getClipDepth() != -1) {
            hasClipDepth=true;
            break;
          }
        }
      }
    }
    if (hasClipDepth) {
      index--;
      continue;
    }
    int parentLayer=-1;
    if (!parentLayers.isEmpty()) {
      parentLayer=parentLayers.pop();
    }
    String layerPrev=""String_Node_Str"";
    layerPrev+=""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ randomOutlineColor()+ ""String_Node_Str"";
    if (d == 1) {
      layerPrev+=""String_Node_Str"";
    }
    if (parentLayer != -1) {
      if (parentLayer != d) {
        layerPrev+=""String_Node_Str"" + (parentLayer) + ""String_Node_Str"";
      }
    }
    layerPrev+=""String_Node_Str"";
    String layerAfter=""String_Node_Str"";
    String cf=convertFrames(layerPrev,layerAfter,nonLibraryShapes,tags,timelineTags,characters,d,flaVersion,files);
    if (cf.isEmpty()) {
      index--;
    }
    ret+=cf;
  }
  int soundLayerIndex=layerCount;
  layerCount++;
  ret+=convertSoundLayer(soundLayerIndex,backgroundColor,characters,tags,timelineTags,files);
  ret+=""String_Node_Str"";
  ret+=""String_Node_Str"";
  return ret;
}",0.9748438893844782
61635,"public void replaceSciptPack(ScriptPack pack,String as) throws AVM2ParseException, CompilationException, IOException, InterruptedException {
  String scriptName=pack.getPathScriptName() + ""String_Node_Str"";
  int oldIndex=pack.scriptIndex;
  int newIndex=script_info.size();
  String documentClass=""String_Node_Str"";
  loopt:   for (  Tag t : swf.tags) {
    if (t instanceof SymbolClassTag) {
      SymbolClassTag sc=(SymbolClassTag)t;
      for (int i=0; i < sc.tags.length; i++) {
        if (sc.tags[i] == 0) {
          documentClass=sc.names[i];
          break loopt;
        }
      }
    }
  }
  boolean isDocumentClass=documentClass.equals(pack.getPath().toString());
  script_info.get(oldIndex).delete(this,true);
  ActionScriptParser.compile(as,this,new ArrayList<ABC>(),isDocumentClass,scriptName);
  script_info.set(oldIndex,script_info.get(newIndex));
  script_info.remove(newIndex);
  pack();
  ((Tag)parentTag).setModified(true);
}","public void replaceSciptPack(ScriptPack pack,String as) throws AVM2ParseException, CompilationException, IOException, InterruptedException {
  String scriptName=pack.getPathScriptName() + ""String_Node_Str"";
  int oldIndex=pack.scriptIndex;
  int newIndex=script_info.size();
  String documentClass=""String_Node_Str"";
  loopt:   for (  Tag t : swf.tags) {
    if (t instanceof SymbolClassTag) {
      SymbolClassTag sc=(SymbolClassTag)t;
      for (int i=0; i < sc.tags.length; i++) {
        if (sc.tags[i] == 0) {
          documentClass=sc.names[i];
          break loopt;
        }
      }
    }
  }
  boolean isDocumentClass=documentClass.equals(pack.getPath().toString());
  ScriptInfo si=script_info.get(oldIndex);
  si.delete(this,true);
  int newClassIndex=instance_info.size();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      newClassIndex=tc.class_info + 1;
    }
  }
  ActionScriptParser.compile(as,this,new ArrayList<ABC>(),isDocumentClass,scriptName,newClassIndex);
  script_info.set(oldIndex,script_info.get(newIndex));
  script_info.remove(newIndex);
  pack();
  ((Tag)parentTag).setModified(true);
}",0.8901408450704226
61636,"public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts) throws AVM2ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(ii);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo instanceInfo=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(instanceInfo);
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : ((item instanceof SetterAVM2Item) ? Trait.TRAIT_SETTER : Trait.TRAIT_METHOD);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
    }
 else     if (item instanceof FunctionAVM2Item) {
      TraitFunction tf=new TraitFunction();
      tf.slot_id=slot_id++;
      tf.kindType=Trait.TRAIT_FUNCTION;
      ts.traits.add(tf);
      traits[k]=tf;
    }
  }
  return traits;
}","public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Reference<Integer> classIndex) throws AVM2ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abc.addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      tc.class_info=classIndex.getVal();
      abc.addClass(ci,ii,classIndex.getVal());
      classIndex.setVal(classIndex.getVal() + 1);
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : ((item instanceof SetterAVM2Item) ? Trait.TRAIT_SETTER : Trait.TRAIT_METHOD);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
    }
 else     if (item instanceof FunctionAVM2Item) {
      TraitFunction tf=new TraitFunction();
      tf.slot_id=slot_id++;
      tf.kindType=Trait.TRAIT_FUNCTION;
      ts.traits.add(tf);
      traits[k]=tf;
    }
  }
  return traits;
}",0.9339323467230444
61637,"public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}","public void generateTraitsPhase3(int methodInitScope,boolean isInterface,String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts,Trait[] traits,Map<Trait,Integer> initScopes,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof InterfaceAVM2Item) {
      generateClass(((InterfaceAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((InterfaceAVM2Item)item).pkg,localData,(InterfaceAVM2Item)item,class_index);
    }
    if (item instanceof ClassAVM2Item) {
      generateClass(((ClassAVM2Item)item).namespace,abc.class_info.get(((TraitClass)traits[k]).class_info),abc.instance_info.get(((TraitClass)traits[k]).class_info),initScopes.get(traits[k]),((ClassAVM2Item)item).pkg,localData,(ClassAVM2Item)item,class_index);
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      ((TraitMethodGetterSetter)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),mai.pkg,mai.needsActivation,mai.subvariables,methodInitScope + (mai.isStatic() ? 0 : 1),mai.hasRest,mai.line,className,superName,false,localData,mai.paramTypes,mai.paramNames,mai.paramValues,mai.body,mai.retType);
    }
 else     if (item instanceof FunctionAVM2Item) {
      FunctionAVM2Item fai=(FunctionAVM2Item)item;
      ((TraitFunction)traits[k]).method_info=method(isInterface,new ArrayList<MethodBody>(),fai.pkg,fai.needsActivation,fai.subvariables,methodInitScope,fai.hasRest,fai.line,className,superName,false,localData,fai.paramTypes,fai.paramNames,fai.paramValues,fai.body,fai.retType);
    }
  }
}",0.9863421902160416
61638,"public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands) throws AVM2ParseException, CompilationException {
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,false,localData,commands,si.traits);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(new GetLocal0Ins()));
  mbCode.add(ins(new PushScopeIns()));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new GetLexIns(),parents.get(i)));
          mbCode.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mbCode.add(ins(new GetLexIns(),parents.get(1)));
      }
      mbCode.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new PopScopeIns()));
        }
      }
      mbCode.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,false,localData,commands,si.traits,traitArr,initScopes);
  return si;
}","public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands,int classPos) throws AVM2ParseException, CompilationException {
  Reference<Integer> class_index=new Reference<>(classPos);
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,false,localData,commands,si.traits,class_index);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.setCode(new AVM2Code());
  List<AVM2Instruction> mbCode=mb.getCode().code;
  mbCode.add(ins(new GetLocal0Ins()));
  mbCode.add(ins(new PushScopeIns()));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mbCode.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mbCode.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mbCode.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new GetLexIns(),parents.get(i)));
          mbCode.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mbCode.add(ins(new GetLexIns(),parents.get(1)));
      }
      mbCode.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mbCode.add(ins(new PopScopeIns()));
        }
      }
      mbCode.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mbCode.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,false,localData,commands,si.traits,traitArr,initScopes,class_index);
  return si;
}",0.9818589863474846
61639,"public int generateClass(int namespace,ClassInfo ci,InstanceInfo ii,int initScope,String pkg,SourceGeneratorLocalData localData,AVM2Item cls) throws AVM2ParseException, CompilationException {
  if (cls instanceof ClassAVM2Item) {
    ClassAVM2Item cai=(ClassAVM2Item)cls;
    generateClass(cai.importedClasses,cai.sinitVariables,cai.staticInitActivation,cai.staticInit,cai.openedNamespaces,namespace,initScope,pkg,ci,ii,localData,false,cai.className,cai.extendsOp == null ? ""String_Node_Str"" : cai.extendsOp.toString(),cai.extendsOp,cai.implementsOp,cai.constructor,cai.traits);
    if (!cai.isDynamic) {
      ii.flags|=InstanceInfo.CLASS_SEALED;
    }
    if (cai.isFinal) {
      ii.flags|=InstanceInfo.CLASS_FINAL;
    }
    ii.flags|=InstanceInfo.CLASS_PROTECTEDNS;
    ii.protectedNS=cai.protectedNs;
  }
  if (cls instanceof InterfaceAVM2Item) {
    InterfaceAVM2Item iai=(InterfaceAVM2Item)cls;
    ii.flags|=InstanceInfo.CLASS_INTERFACE;
    ii.flags|=InstanceInfo.CLASS_SEALED;
    generateClass(iai.importedClasses,new ArrayList<AssignableAVM2Item>(),false,new ArrayList<GraphTargetItem>(),iai.openedNamespaces,namespace,initScope,pkg,ci,ii,localData,true,iai.name,null,null,iai.superInterfaces,null,iai.methods);
  }
  return abc.instance_info.size() - 1;
}","public int generateClass(int namespace,ClassInfo ci,InstanceInfo ii,int initScope,String pkg,SourceGeneratorLocalData localData,AVM2Item cls,Reference<Integer> class_index) throws AVM2ParseException, CompilationException {
  if (cls instanceof ClassAVM2Item) {
    ClassAVM2Item cai=(ClassAVM2Item)cls;
    generateClass(cai.importedClasses,cai.sinitVariables,cai.staticInitActivation,cai.staticInit,cai.openedNamespaces,namespace,initScope,pkg,ci,ii,localData,false,cai.className,cai.extendsOp == null ? ""String_Node_Str"" : cai.extendsOp.toString(),cai.extendsOp,cai.implementsOp,cai.constructor,cai.traits,class_index);
    if (!cai.isDynamic) {
      ii.flags|=InstanceInfo.CLASS_SEALED;
    }
    if (cai.isFinal) {
      ii.flags|=InstanceInfo.CLASS_FINAL;
    }
    ii.flags|=InstanceInfo.CLASS_PROTECTEDNS;
    ii.protectedNS=cai.protectedNs;
  }
  if (cls instanceof InterfaceAVM2Item) {
    InterfaceAVM2Item iai=(InterfaceAVM2Item)cls;
    ii.flags|=InstanceInfo.CLASS_INTERFACE;
    ii.flags|=InstanceInfo.CLASS_SEALED;
    generateClass(iai.importedClasses,new ArrayList<AssignableAVM2Item>(),false,new ArrayList<GraphTargetItem>(),iai.openedNamespaces,namespace,initScope,pkg,ci,ii,localData,true,iai.name,null,null,iai.superInterfaces,null,iai.methods,class_index);
  }
  return abc.instance_info.size() - 1;
}",0.978789047435403
61640,"public void addScriptFromTree(List<GraphTargetItem> items,boolean documentClass) throws AVM2ParseException, CompilationException {
  AVM2SourceGenerator gen=new AVM2SourceGenerator(abc,otherABCs);
  List<AVM2Instruction> ret=new ArrayList<>();
  SourceGeneratorLocalData localData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),0,Boolean.FALSE,0);
  localData.documentClass=documentClass;
  abc.script_info.add(gen.generateScriptInfo(localData,items));
}","public void addScriptFromTree(List<GraphTargetItem> items,boolean documentClass,int classPos) throws AVM2ParseException, CompilationException {
  AVM2SourceGenerator gen=new AVM2SourceGenerator(abc,otherABCs);
  List<AVM2Instruction> ret=new ArrayList<>();
  SourceGeneratorLocalData localData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),0,Boolean.FALSE,0);
  localData.documentClass=documentClass;
  abc.script_info.add(gen.generateScriptInfo(localData,items,classPos));
}",0.9769392033542976
61641,"public void addScript(String s,boolean documentClass,String fileName) throws AVM2ParseException, IOException, CompilationException {
  List<GraphTargetItem> traits=scriptTraitsFromString(s,fileName);
  addScriptFromTree(traits,documentClass);
}","public void addScript(String s,boolean documentClass,String fileName,int classPos) throws AVM2ParseException, IOException, CompilationException {
  List<GraphTargetItem> traits=scriptTraitsFromString(s,fileName);
  addScriptFromTree(traits,documentClass,classPos);
}",0.9568627450980391
61642,"public static void compile(SWF swf,String src,String dst){
  System.err.println(""String_Node_Str"");
  try {
    initPlayer();
    ABC abc=new ABC(swf);
    ActionScriptParser parser=new ActionScriptParser(abc,playerABCs);
    parser.addScript(new String(Helper.readFile(src),""String_Node_Str""),true,src);
    abc.saveToStream(new FileOutputStream(new File(dst)));
  }
 catch (  Exception ex) {
    Logger.getLogger(ActionScriptParser.class.getName()).log(Level.SEVERE,null,ex);
  }
  System.exit(0);
}","public static void compile(SWF swf,String src,String dst,int classPos){
  System.err.println(""String_Node_Str"");
  try {
    initPlayer();
    ABC abc=new ABC(swf);
    ActionScriptParser parser=new ActionScriptParser(abc,playerABCs);
    parser.addScript(new String(Helper.readFile(src),""String_Node_Str""),true,src,classPos);
    abc.saveToStream(new FileOutputStream(new File(dst)));
  }
 catch (  Exception ex) {
    Logger.getLogger(ActionScriptParser.class.getName()).log(Level.SEVERE,null,ex);
  }
  System.exit(0);
}",0.978515625
61643,"@Test(dataProvider=""String_Node_Str"") public void testDirectEditing(String filename) throws IOException, InterruptedException, AVM2ParseException, CompilationException {
  Configuration.autoDeobfuscate.set(false);
  try {
    SWF swf=new SWF(new BufferedInputStream(new FileInputStream(TESTDATADIR + File.separator + filename)),false);
    if ((swf.fileAttributes != null && swf.fileAttributes.actionScript3) || (swf.fileAttributes == null && swf.isAS3)) {
      boolean dotest=false;
      List<ABC> allAbcs=new ArrayList<>();
      for (      ABCContainerTag ct : swf.abcList) {
        allAbcs.add(ct.getABC());
      }
      for (      ABC abc : allAbcs) {
        for (int s=0; s < abc.script_info.size(); s++) {
          String startAfter=null;
          HilightedTextWriter htw=new HilightedTextWriter(new CodeFormatting(),false);
          MyEntry<ClassPath,ScriptPack> en=abc.script_info.get(s).getPacks(abc,s).get(0);
          if (startAfter == null || en.getKey().toString().equals(startAfter)) {
            dotest=true;
          }
          if (!dotest) {
            System.out.println(""String_Node_Str"" + en.getKey().toString());
            continue;
          }
          System.out.println(""String_Node_Str"" + en.getKey().toString() + ""String_Node_Str"");
          en.getValue().toSource(htw,swf.abcList,abc.script_info.get(s).traits.traits,ScriptExportMode.AS,false);
          String original=htw.toString();
          ABC nabc=new ABC(swf);
          com.jpexs.decompiler.flash.abc.avm2.parser.script.ActionScriptParser.compile(original,nabc,allAbcs,false,en.getKey().className + ""String_Node_Str"");
        }
      }
    }
 else {
      List<ContainerItem> list2=new ArrayList<>();
      list2.addAll(swf.tags);
      List<TreeNode> list=SWF.createASTagList(list2,null);
      TagNode.setExport(list,true);
      testAS2DirectEditingOneRecursive(swf.version,list);
    }
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"");
    throw ex;
  }
}","@Test(dataProvider=""String_Node_Str"") public void testDirectEditing(String filename) throws IOException, InterruptedException, AVM2ParseException, CompilationException {
  Configuration.autoDeobfuscate.set(false);
  try {
    SWF swf=new SWF(new BufferedInputStream(new FileInputStream(TESTDATADIR + File.separator + filename)),false);
    if ((swf.fileAttributes != null && swf.fileAttributes.actionScript3) || (swf.fileAttributes == null && swf.isAS3)) {
      boolean dotest=false;
      List<ABC> allAbcs=new ArrayList<>();
      for (      ABCContainerTag ct : swf.abcList) {
        allAbcs.add(ct.getABC());
      }
      for (      ABC abc : allAbcs) {
        for (int s=0; s < abc.script_info.size(); s++) {
          String startAfter=null;
          HilightedTextWriter htw=new HilightedTextWriter(new CodeFormatting(),false);
          MyEntry<ClassPath,ScriptPack> en=abc.script_info.get(s).getPacks(abc,s).get(0);
          if (startAfter == null || en.getKey().toString().equals(startAfter)) {
            dotest=true;
          }
          if (!dotest) {
            System.out.println(""String_Node_Str"" + en.getKey().toString());
            continue;
          }
          System.out.println(""String_Node_Str"" + en.getKey().toString() + ""String_Node_Str"");
          en.getValue().toSource(htw,swf.abcList,abc.script_info.get(s).traits.traits,ScriptExportMode.AS,false);
          String original=htw.toString();
          ABC nabc=new ABC(swf);
          com.jpexs.decompiler.flash.abc.avm2.parser.script.ActionScriptParser.compile(original,nabc,allAbcs,false,en.getKey().className + ""String_Node_Str"",abc.instance_info.size());
        }
      }
    }
 else {
      List<ContainerItem> list2=new ArrayList<>();
      list2.addAll(swf.tags);
      List<TreeNode> list=SWF.createASTagList(list2,null);
      TagNode.setExport(list,true);
      testAS2DirectEditingOneRecursive(swf.version,list);
    }
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"");
    throw ex;
  }
}",0.9937515621094728
61644,"public static SWFList parseSWF(SWFSourceInfo sourceInfo) throws Exception {
  SWFList result=new SWFList();
  InputStream inputStream=sourceInfo.getInputStream();
  SWFBundle bundle=null;
  if (inputStream == null) {
    inputStream=new BufferedInputStream(new FileInputStream(sourceInfo.getFile()));
    bundle=sourceInfo.getBundle(false,SearchMode.ALL);
    logger.log(Level.INFO,""String_Node_Str"",sourceInfo.getFile());
  }
 else   if (inputStream instanceof SeekableInputStream || inputStream instanceof BufferedInputStream) {
    try {
      inputStream.reset();
    }
 catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
    }
    logger.log(Level.INFO,""String_Node_Str"",sourceInfo.getFileTitle());
  }
  Stopwatch sw=Stopwatch.startNew();
  if (bundle != null) {
    result.isBundle=true;
    result.name=new File(sourceInfo.getFileTitleOrName()).getName();
    for (    Entry<String,SeekableInputStream> streamEntry : bundle.getAll().entrySet()) {
      InputStream stream=streamEntry.getValue();
      stream.reset();
      SWF swf=new SWF(stream,new ProgressListener(){
        @Override public void progress(        int p){
          startWork(AppStrings.translate(""String_Node_Str""),p);
        }
      }
,Configuration.parallelSpeedUp.get());
      swf.fileTitle=streamEntry.getKey();
      swf.readOnly=true;
      result.add(swf);
    }
  }
 else {
    SWF swf=new SWF(inputStream,new ProgressListener(){
      @Override public void progress(      int p){
        startWork(AppStrings.translate(""String_Node_Str""),p);
      }
    }
,Configuration.parallelSpeedUp.get());
    swf.file=sourceInfo.getFile();
    swf.fileTitle=sourceInfo.getFileTitle();
    result.add(swf);
  }
  if (inputStream instanceof FileInputStream) {
    logger.log(Level.INFO,""String_Node_Str"",(sw.getElapsedMilliseconds() / 1000));
    inputStream.close();
  }
 else {
    logger.log(Level.INFO,""String_Node_Str"",(sw.getElapsedMilliseconds() / 1000));
  }
  result.sourceInfo=sourceInfo;
  for (  SWF swf : result) {
    logger.log(Level.INFO,""String_Node_Str"");
    logger.log(Level.INFO,""String_Node_Str"");
    logger.log(Level.INFO,""String_Node_Str"",Helper.formatFileSize(swf.fileSize));
    logger.log(Level.INFO,""String_Node_Str"",swf.version);
    int width=(int)((swf.displayRect.Xmax - swf.displayRect.Xmin) / SWF.unitDivisor);
    int height=(int)((swf.displayRect.Ymax - swf.displayRect.Ymin) / SWF.unitDivisor);
    logger.log(Level.INFO,""String_Node_Str"",width);
    logger.log(Level.INFO,""String_Node_Str"",height);
    swf.swfList=result;
    swf.addEventListener(new EventListener(){
      @Override public void handleEvent(      String event,      Object data){
        if (event.equals(""String_Node_Str"")) {
          startWork((String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
      }
    }
);
  }
  return result;
}","public static SWFList parseSWF(SWFSourceInfo sourceInfo) throws Exception {
  SWFList result=new SWFList();
  InputStream inputStream=sourceInfo.getInputStream();
  SWFBundle bundle=null;
  FileInputStream fis=null;
  if (inputStream == null) {
    inputStream=new BufferedInputStream(fis=new FileInputStream(sourceInfo.getFile()));
    bundle=sourceInfo.getBundle(false,SearchMode.ALL);
    logger.log(Level.INFO,""String_Node_Str"",sourceInfo.getFile());
  }
 else   if (inputStream instanceof SeekableInputStream || inputStream instanceof BufferedInputStream) {
    try {
      inputStream.reset();
    }
 catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
    }
    logger.log(Level.INFO,""String_Node_Str"",sourceInfo.getFileTitle());
  }
  Stopwatch sw=Stopwatch.startNew();
  if (bundle != null) {
    result.isBundle=true;
    result.name=new File(sourceInfo.getFileTitleOrName()).getName();
    for (    Entry<String,SeekableInputStream> streamEntry : bundle.getAll().entrySet()) {
      InputStream stream=streamEntry.getValue();
      stream.reset();
      SWF swf=new SWF(stream,new ProgressListener(){
        @Override public void progress(        int p){
          startWork(AppStrings.translate(""String_Node_Str""),p);
        }
      }
,Configuration.parallelSpeedUp.get());
      swf.fileTitle=streamEntry.getKey();
      swf.readOnly=true;
      result.add(swf);
    }
  }
 else {
    SWF swf=new SWF(inputStream,new ProgressListener(){
      @Override public void progress(      int p){
        startWork(AppStrings.translate(""String_Node_Str""),p);
      }
    }
,Configuration.parallelSpeedUp.get());
    swf.file=sourceInfo.getFile();
    swf.fileTitle=sourceInfo.getFileTitle();
    result.add(swf);
  }
  if (fis != null) {
    logger.log(Level.INFO,""String_Node_Str"",(sw.getElapsedMilliseconds() / 1000));
    fis.close();
  }
 else {
    logger.log(Level.INFO,""String_Node_Str"",(sw.getElapsedMilliseconds() / 1000));
  }
  result.sourceInfo=sourceInfo;
  for (  SWF swf : result) {
    logger.log(Level.INFO,""String_Node_Str"");
    logger.log(Level.INFO,""String_Node_Str"");
    logger.log(Level.INFO,""String_Node_Str"",Helper.formatFileSize(swf.fileSize));
    logger.log(Level.INFO,""String_Node_Str"",swf.version);
    int width=(int)((swf.displayRect.Xmax - swf.displayRect.Xmin) / SWF.unitDivisor);
    int height=(int)((swf.displayRect.Ymax - swf.displayRect.Ymin) / SWF.unitDivisor);
    logger.log(Level.INFO,""String_Node_Str"",width);
    logger.log(Level.INFO,""String_Node_Str"",height);
    swf.swfList=result;
    swf.addEventListener(new EventListener(){
      @Override public void handleEvent(      String event,      Object data){
        if (event.equals(""String_Node_Str"")) {
          startWork((String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
        if (event.equals(""String_Node_Str"")) {
          startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"" + (String)data);
        }
      }
    }
);
  }
  return result;
}",0.985493968544816
61645,"public TextPanel(MainPanel mainPanel){
  super(new BorderLayout());
  this.mainPanel=mainPanel;
  textSearchPanel=new SearchPanel<>(new FlowLayout(),mainPanel);
  add(textSearchPanel,BorderLayout.NORTH);
  textValue=new LineMarkedEditorPane();
  add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  add(textButtonsPanel,BorderLayout.SOUTH);
}","public TextPanel(MainPanel mainPanel){
  super(new BorderLayout());
  DefaultSyntaxKit.initKit();
  this.mainPanel=mainPanel;
  textSearchPanel=new SearchPanel<>(new FlowLayout(),mainPanel);
  add(textSearchPanel,BorderLayout.NORTH);
  textValue=new LineMarkedEditorPane();
  add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(mainPanel.translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  add(textButtonsPanel,BorderLayout.SOUTH);
}",0.9894810659186536
61646,"public String getStringUnderCursor(){
  int pos=decompiledEditor.getCaretPosition();
  Highlighting h=Highlighting.search(decompiledHilights,pos);
  if (h != null) {
    List<Action> list=lastCode;
    Action lastIns=null;
    int inspos=0;
    Action selIns=null;
    for (    Action ins : list) {
      if (h.getPropertyLong(""String_Node_Str"") == ins.getOffset()) {
        selIns=ins;
        break;
      }
      if (ins.getOffset() > h.getPropertyLong(""String_Node_Str"")) {
        inspos=(int)(h.getPropertyLong(""String_Node_Str"") - lastIns.getAddress());
        selIns=lastIns;
        break;
      }
      lastIns=ins;
    }
    if (selIns != null) {
      if (selIns instanceof ActionPush) {
        ActionPush ap=(ActionPush)selIns;
        Object var=ap.values.get(inspos - 1);
        String identifier=null;
        if (var instanceof String) {
          identifier=(String)var;
        }
        if (var instanceof ConstantIndex) {
          identifier=ap.constantPool.get(((ConstantIndex)var).index);
        }
        return identifier;
      }
    }
  }
  return null;
}","public String getStringUnderCursor(){
  int pos=decompiledEditor.getCaretPosition();
  SyntaxDocument sDoc=ActionUtils.getSyntaxDocument(decompiledEditor);
  if (sDoc != null) {
    Token t=sDoc.getTokenAt(pos);
    String ident=null;
    if (t != null && (t.type == TokenType.IDENTIFIER || t.type == TokenType.REGEX)) {
      CharSequence tData=t.getText(sDoc);
      ident=tData.toString();
      ActionScriptLexer lex=new ActionScriptLexer(new StringReader(ident));
      try {
        ParsedSymbol symb=lex.lex();
        if (symb.type == SymbolType.IDENTIFIER) {
          ident=(String)symb.value;
        }
 else {
          ident=null;
        }
      }
 catch (      IOException|ActionParseException ex) {
        ident=null;
      }
    }
    if (ident == null) {
      Highlighting h=Highlighting.search(decompiledHilights,pos);
      if (h != null) {
        List<Action> list=lastCode;
        Action lastIns=null;
        int inspos=0;
        Action selIns=null;
        for (        Action ins : list) {
          if (h.getPropertyLong(""String_Node_Str"") == ins.getOffset()) {
            selIns=ins;
            break;
          }
          if (ins.getOffset() > h.getPropertyLong(""String_Node_Str"")) {
            inspos=(int)(h.getPropertyLong(""String_Node_Str"") - lastIns.getAddress());
            selIns=lastIns;
            break;
          }
          lastIns=ins;
        }
        if (selIns != null) {
          if (selIns instanceof ActionPush) {
            ActionPush ap=(ActionPush)selIns;
            Object var=ap.values.get(inspos - 1);
            String identifier=null;
            if (var instanceof String) {
              identifier=(String)var;
            }
            if (var instanceof ConstantIndex) {
              identifier=ap.constantPool.get(((ConstantIndex)var).index);
            }
            return identifier;
          }
        }
      }
    }
 else {
      return ident;
    }
  }
  return null;
}",0.6745484400656815
61647,"public ConvertOutput toSourceOutput(String path,GraphPart part,boolean processJumps,boolean isStatic,int scriptIndex,int classIndex,HashMap<Integer,GraphTargetItem> localRegs,TranslateStack stack,ScopeStack scopeStack,ABC abc,AVM2ConstantPool constants,List<MethodInfo> method_info,MethodBody body,int start,int end,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,boolean[] visited,HashMap<Integer,Integer> localRegAssigmentIps,HashMap<Integer,List<Integer>> refs) throws ConvertException, InterruptedException {
  boolean debugMode=DEBUG_MODE;
  if (debugMode) {
    System.out.println(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ code.get(start).toString()+ ""String_Node_Str""+ code.get(end).toString());
  }
  if (visited == null) {
    visited=new boolean[code.size()];
  }
  toSourceCount++;
  if (toSourceLimit > 0) {
    if (toSourceCount > toSourceLimit) {
      throw new ConvertException(""String_Node_Str"" + toSourceLimit + ""String_Node_Str"",start);
    }
  }
  List<GraphTargetItem> output=new ArrayList<>();
  int ip=start;
  iploop:   while (ip <= end) {
    if (ignoredIns.contains(ip)) {
      ip++;
      continue;
    }
    boolean processTry=processJumps;
    int ipfix=fixIPAfterDebugLine(ip);
    int maxend=-1;
    if (ip > end) {
      break;
    }
    if (unknownJumps.contains(ip)) {
      unknownJumps.remove(Integer.valueOf(ip));
      throw new UnknownJumpException(stack,ip,output);
    }
    if (visited[ip]) {
      logger.warning(""String_Node_Str"" + Helper.formatAddress(pos2adr(ip)) + ""String_Node_Str""+ ip);
      break;
    }
    visited[ip]=true;
    AVM2Instruction ins=code.get(ip);
    if (debugMode) {
      System.err.println(""String_Node_Str"" + ip + ""String_Node_Str""+ ins.toString()+ ""String_Node_Str""+ stack.toString()+ ""String_Node_Str""+ scopeStack.toString());
    }
    if (ins.definition instanceof NewFunctionIns) {
      if (ip + 1 <= end) {
        if (code.get(ip + 1).definition instanceof PopIns) {
          ip+=2;
          continue;
        }
      }
    }
    if ((ins.definition instanceof GetLocalTypeIns) && (!output.isEmpty()) && (output.get(output.size() - 1) instanceof SetLocalAVM2Item)&& (((SetLocalAVM2Item)output.get(output.size() - 1)).regIndex == ((GetLocalTypeIns)ins.definition).getRegisterId(ins))&& isKilled(((SetLocalAVM2Item)output.get(output.size() - 1)).regIndex,start,end)) {
      SetLocalAVM2Item slt=(SetLocalAVM2Item)output.remove(output.size() - 1);
      stack.push(slt.getValue());
      ip++;
    }
 else     if ((ins.definition instanceof SetLocalTypeIns) && (ip + 1 <= end) && (isKilled(((SetLocalTypeIns)ins.definition).getRegisterId(ins),ip,end))) {
      AVM2Instruction insAfter=code.get(ip + 1);
      if ((insAfter.definition instanceof GetLocalTypeIns) && (((GetLocalTypeIns)insAfter.definition).getRegisterId(insAfter) == ((SetLocalTypeIns)ins.definition).getRegisterId(ins))) {
        GraphTargetItem before=stack.peek();
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
        stack.push(before);
        ip+=2;
        continue iploop;
      }
 else {
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
        ip++;
        continue iploop;
      }
    }
 else     if (ins.definition instanceof DupIns) {
      int nextPos;
      do {
        AVM2Instruction insAfter=code.get(ip + 1);
        AVM2Instruction insBefore=ins;
        if (ip - 1 >= start) {
          insBefore=code.get(ip - 1);
        }
        if (insAfter.definition instanceof ConvertBIns) {
          ip++;
          insAfter=code.get(ip + 1);
        }
        boolean isAnd;
        if (processJumps && (insAfter.definition instanceof IfFalseIns)) {
          isAnd=true;
        }
 else         if (processJumps && (insAfter.definition instanceof IfTrueIns)) {
          isAnd=false;
        }
 else         if (insAfter.definition instanceof SetLocalTypeIns) {
          int reg=(((SetLocalTypeIns)insAfter.definition).getRegisterId(insAfter));
          for (int t=ip + 1; t <= end - 1; t++) {
            if (code.get(t).definition instanceof KillIns) {
              if (code.get(t).operands[0] == reg) {
                break;
              }
            }
            if (code.get(t).definition instanceof GetLocalTypeIns) {
              if (((GetLocalTypeIns)code.get(t).definition).getRegisterId(code.get(t)) == reg) {
                if (code.get(t + 1).definition instanceof KillIns) {
                  if (code.get(t + 1).operands[0] == reg) {
                    ConvertOutput assignment=toSourceOutput(path,part,processJumps,isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,abc,constants,method_info,body,ip + 2,t - 1,localRegNames,fullyQualifiedNames,visited,localRegAssigmentIps,refs);
                    GraphTargetItem tar=assignment.output.remove(assignment.output.size() - 1);
                    tar.firstPart=part;
                    stack.push(tar);
                    ip=t + 2;
                    continue iploop;
                  }
                }
              }
            }
          }
          if (!isKilled(reg,0,end)) {
            for (int i=ip; i >= start; i--) {
              if (code.get(i).definition instanceof DupIns) {
                if (stack.isEmpty()) {
                  break;
                }
                GraphTargetItem v=stack.pop();
                stack.push(new LocalRegAVM2Item(ins,reg,v));
                stack.push(v);
              }
 else {
                break;
              }
            }
          }
 else {
            ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
          }
          ip++;
          break;
        }
 else {
          ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
          ip++;
          break;
        }
      }
 while (ins.definition instanceof DupIns);
    }
 else     if ((ins.definition instanceof ReturnValueIns) || (ins.definition instanceof ReturnVoidIns) || (ins.definition instanceof ThrowIns)) {
      ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      break;
    }
 else     if (ins.definition instanceof NewFunctionIns) {
      String functionName=""String_Node_Str"";
      if ((ip >= start + 2) && (ip <= end - 4)) {
        AVM2Instruction prev2=code.get(ip - 2);
        if (prev2.definition instanceof NewObjectIns) {
          if (prev2.operands[0] == 0) {
            if (code.get(ip - 1).definition instanceof PushWithIns) {
              boolean hasDup=false;
              int plus=0;
              if (code.get(ip + 1).definition instanceof DupIns) {
                hasDup=true;
                plus=1;
              }
              AVM2Instruction psco=code.get(ip + 1 + plus);
              if (psco.definition instanceof GetScopeObjectIns) {
                if (psco.operands[0] == scopeStack.size() - 1) {
                  if (code.get(ip + plus + 2).definition instanceof SwapIns) {
                    if (code.get(ip + plus + 4).definition instanceof PopScopeIns) {
                      if (code.get(ip + plus + 3).definition instanceof SetPropertyIns) {
                        functionName=abc.constants.getMultiname(code.get(ip + plus + 3).operands[0]).getName(constants,fullyQualifiedNames,true);
                        scopeStack.pop();
                        output.remove(output.size() - 1);
                        ip=ip + plus + 4;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      NewFunctionAVM2Item nft=(NewFunctionAVM2Item)stack.peek();
      nft.functionName=functionName;
      ip++;
    }
 else {
      try {
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      }
 catch (      RuntimeException re) {
        throw re;
      }
      ip++;
    }
  }
  if (debugMode) {
    System.out.println(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ code.get(start).toString()+ ""String_Node_Str""+ code.get(end).toString());
  }
  return new ConvertOutput(stack,output);
}","public ConvertOutput toSourceOutput(String path,GraphPart part,boolean processJumps,boolean isStatic,int scriptIndex,int classIndex,HashMap<Integer,GraphTargetItem> localRegs,TranslateStack stack,ScopeStack scopeStack,ABC abc,AVM2ConstantPool constants,List<MethodInfo> method_info,MethodBody body,int start,int end,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,boolean[] visited,HashMap<Integer,Integer> localRegAssigmentIps,HashMap<Integer,List<Integer>> refs) throws ConvertException, InterruptedException {
  calcKilledStats(body);
  boolean debugMode=DEBUG_MODE;
  if (debugMode) {
    System.out.println(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ code.get(start).toString()+ ""String_Node_Str""+ code.get(end).toString());
  }
  if (visited == null) {
    visited=new boolean[code.size()];
  }
  toSourceCount++;
  if (toSourceLimit > 0) {
    if (toSourceCount > toSourceLimit) {
      throw new ConvertException(""String_Node_Str"" + toSourceLimit + ""String_Node_Str"",start);
    }
  }
  List<GraphTargetItem> output=new ArrayList<>();
  int ip=start;
  iploop:   while (ip <= end) {
    if (ignoredIns.contains(ip)) {
      ip++;
      continue;
    }
    boolean processTry=processJumps;
    int ipfix=fixIPAfterDebugLine(ip);
    int maxend=-1;
    if (ip > end) {
      break;
    }
    if (unknownJumps.contains(ip)) {
      unknownJumps.remove(Integer.valueOf(ip));
      throw new UnknownJumpException(stack,ip,output);
    }
    if (visited[ip]) {
      logger.warning(""String_Node_Str"" + Helper.formatAddress(pos2adr(ip)) + ""String_Node_Str""+ ip);
      break;
    }
    visited[ip]=true;
    AVM2Instruction ins=code.get(ip);
    if (debugMode) {
      System.err.println(""String_Node_Str"" + ip + ""String_Node_Str""+ ins.toString()+ ""String_Node_Str""+ stack.toString()+ ""String_Node_Str""+ scopeStack.toString());
    }
    if (ins.definition instanceof NewFunctionIns) {
      if (ip + 1 <= end) {
        if (code.get(ip + 1).definition instanceof PopIns) {
          ip+=2;
          continue;
        }
      }
    }
    if ((ins.definition instanceof GetLocalTypeIns) && (!output.isEmpty()) && (output.get(output.size() - 1) instanceof SetLocalAVM2Item)&& (((SetLocalAVM2Item)output.get(output.size() - 1)).regIndex == ((GetLocalTypeIns)ins.definition).getRegisterId(ins))&& isKilled(((SetLocalAVM2Item)output.get(output.size() - 1)).regIndex,start,end)) {
      SetLocalAVM2Item slt=(SetLocalAVM2Item)output.remove(output.size() - 1);
      stack.push(slt.getValue());
      ip++;
    }
 else     if ((ins.definition instanceof SetLocalTypeIns) && (ip + 1 <= end) && (isKilled(((SetLocalTypeIns)ins.definition).getRegisterId(ins),ip,end))) {
      AVM2Instruction insAfter=code.get(ip + 1);
      if ((insAfter.definition instanceof GetLocalTypeIns) && (((GetLocalTypeIns)insAfter.definition).getRegisterId(insAfter) == ((SetLocalTypeIns)ins.definition).getRegisterId(ins))) {
        GraphTargetItem before=stack.peek();
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
        stack.push(before);
        ip+=2;
        continue iploop;
      }
 else {
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
        ip++;
        continue iploop;
      }
    }
 else     if (ins.definition instanceof DupIns) {
      int nextPos;
      do {
        AVM2Instruction insAfter=code.get(ip + 1);
        AVM2Instruction insBefore=ins;
        if (ip - 1 >= start) {
          insBefore=code.get(ip - 1);
        }
        if (insAfter.definition instanceof ConvertBIns) {
          ip++;
          insAfter=code.get(ip + 1);
        }
        boolean isAnd;
        if (processJumps && (insAfter.definition instanceof IfFalseIns)) {
          isAnd=true;
        }
 else         if (processJumps && (insAfter.definition instanceof IfTrueIns)) {
          isAnd=false;
        }
 else         if (insAfter.definition instanceof SetLocalTypeIns) {
          int reg=(((SetLocalTypeIns)insAfter.definition).getRegisterId(insAfter));
          for (int t=ip + 1; t <= end - 1; t++) {
            if (code.get(t).definition instanceof KillIns) {
              if (code.get(t).operands[0] == reg) {
                break;
              }
            }
            if (code.get(t).definition instanceof GetLocalTypeIns) {
              if (((GetLocalTypeIns)code.get(t).definition).getRegisterId(code.get(t)) == reg) {
                if (code.get(t + 1).definition instanceof KillIns) {
                  if (code.get(t + 1).operands[0] == reg) {
                    ConvertOutput assignment=toSourceOutput(path,part,processJumps,isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,abc,constants,method_info,body,ip + 2,t - 1,localRegNames,fullyQualifiedNames,visited,localRegAssigmentIps,refs);
                    GraphTargetItem tar=assignment.output.remove(assignment.output.size() - 1);
                    tar.firstPart=part;
                    stack.push(tar);
                    ip=t + 2;
                    continue iploop;
                  }
                }
              }
            }
          }
          if (!isKilled(reg,0,end)) {
            for (int i=ip; i >= start; i--) {
              if (code.get(i).definition instanceof DupIns) {
                if (stack.isEmpty()) {
                  break;
                }
                GraphTargetItem v=stack.pop();
                stack.push(new LocalRegAVM2Item(ins,reg,v));
                stack.push(v);
              }
 else {
                break;
              }
            }
          }
 else {
            ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
          }
          ip++;
          break;
        }
 else {
          ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
          ip++;
          break;
        }
      }
 while (ins.definition instanceof DupIns);
    }
 else     if ((ins.definition instanceof ReturnValueIns) || (ins.definition instanceof ReturnVoidIns) || (ins.definition instanceof ThrowIns)) {
      ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      break;
    }
 else     if (ins.definition instanceof NewFunctionIns) {
      String functionName=""String_Node_Str"";
      if ((ip >= start + 2) && (ip <= end - 4)) {
        AVM2Instruction prev2=code.get(ip - 2);
        if (prev2.definition instanceof NewObjectIns) {
          if (prev2.operands[0] == 0) {
            if (code.get(ip - 1).definition instanceof PushWithIns) {
              boolean hasDup=false;
              int plus=0;
              if (code.get(ip + 1).definition instanceof DupIns) {
                hasDup=true;
                plus=1;
              }
              AVM2Instruction psco=code.get(ip + 1 + plus);
              if (psco.definition instanceof GetScopeObjectIns) {
                if (psco.operands[0] == scopeStack.size() - 1) {
                  if (code.get(ip + plus + 2).definition instanceof SwapIns) {
                    if (code.get(ip + plus + 4).definition instanceof PopScopeIns) {
                      if (code.get(ip + plus + 3).definition instanceof SetPropertyIns) {
                        functionName=abc.constants.getMultiname(code.get(ip + plus + 3).operands[0]).getName(constants,fullyQualifiedNames,true);
                        scopeStack.pop();
                        output.remove(output.size() - 1);
                        ip=ip + plus + 4;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      NewFunctionAVM2Item nft=(NewFunctionAVM2Item)stack.peek();
      nft.functionName=functionName;
      ip++;
    }
 else {
      try {
        ins.definition.translate(isStatic,scriptIndex,classIndex,localRegs,stack,scopeStack,constants,ins,method_info,output,body,abc,localRegNames,fullyQualifiedNames,path,localRegAssigmentIps,ip,refs,this);
      }
 catch (      RuntimeException re) {
        throw re;
      }
      ip++;
    }
  }
  if (debugMode) {
    System.out.println(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str""+ code.get(start).toString()+ ""String_Node_Str""+ code.get(end).toString());
  }
  return new ConvertOutput(stack,output);
}",0.9986315616618316
61648,"public boolean isKilled(int regName,int start,int end){
  for (int k=start; k <= end; k++) {
    if (code.get(k).definition instanceof KillIns) {
      if (code.get(k).operands[0] == regName) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Test for killed register. CalcKilledStats must be called before
 * @param regName
 * @param start
 * @param end
 * @return 
 */
public boolean isKilled(int regName,int start,int end){
  return killedRegs.contains(regName);
}",0.2531120331950207
61649,"public void exportSound(OutputStream fos,SoundTag st,SoundExportMode mode) throws IOException {
  SoundFormat fmt=st.getSoundFormat();
  int nativeFormat=fmt.getNativeExportFormat();
  if (nativeFormat == SoundFormat.EXPORT_MP3 && mode.hasMP3()) {
    fos.write(st.getRawSoundData());
  }
 else   if ((nativeFormat == SoundFormat.EXPORT_FLV && mode.hasFlv()) || mode == SoundExportMode.FLV) {
    if (st instanceof DefineSoundTag) {
      FLVOutputStream flv=new FLVOutputStream(fos);
      flv.writeHeader(true,false);
      flv.writeTag(new FLVTAG(0,new AUDIODATA(st.getSoundFormatId(),st.getSoundRate(),st.getSoundSize(),st.getSoundType(),st.getRawSoundData())));
    }
 else     if (st instanceof SoundStreamHeadTypeTag) {
      SoundStreamHeadTypeTag sh=(SoundStreamHeadTypeTag)st;
      FLVOutputStream flv=new FLVOutputStream(fos);
      flv.writeHeader(true,false);
      List<SoundStreamBlockTag> blocks=sh.getBlocks();
      int ms=(int)(1000.0f / ((float)((Tag)st).getSwf().frameRate));
      for (int b=0; b < blocks.size(); b++) {
        byte[] data=blocks.get(b).streamSoundData;
        if (st.getSoundFormatId() == 2) {
          data=Arrays.copyOfRange(data,4,data.length);
        }
        flv.writeTag(new FLVTAG(ms * b,new AUDIODATA(st.getSoundFormatId(),st.getSoundRate(),st.getSoundSize(),st.getSoundType(),data)));
      }
    }
  }
 else {
    byte[] soundData=st.getRawSoundData();
    SWF swf=((Tag)st).getSwf();
    fmt.createWav(new SWFInputStream(swf,soundData),fos);
  }
}","public void exportSound(OutputStream fos,SoundTag st,SoundExportMode mode) throws IOException {
  SoundFormat fmt=st.getSoundFormat();
  int nativeFormat=fmt.getNativeExportFormat();
  if (nativeFormat == SoundFormat.EXPORT_MP3 && mode.hasMP3()) {
    List<byte[]> datas=st.getRawSoundData();
    for (    byte[] data : datas) {
      fos.write(data);
    }
  }
 else   if ((nativeFormat == SoundFormat.EXPORT_FLV && mode.hasFlv()) || mode == SoundExportMode.FLV) {
    if (st instanceof DefineSoundTag) {
      FLVOutputStream flv=new FLVOutputStream(fos);
      flv.writeHeader(true,false);
      List<byte[]> datas=st.getRawSoundData();
      for (      byte[] data : datas) {
        flv.writeTag(new FLVTAG(0,new AUDIODATA(st.getSoundFormatId(),st.getSoundRate(),st.getSoundSize(),st.getSoundType(),data)));
      }
    }
 else     if (st instanceof SoundStreamHeadTypeTag) {
      SoundStreamHeadTypeTag sh=(SoundStreamHeadTypeTag)st;
      FLVOutputStream flv=new FLVOutputStream(fos);
      flv.writeHeader(true,false);
      List<SoundStreamBlockTag> blocks=sh.getBlocks();
      int ms=(int)(1000.0f / ((float)((Tag)st).getSwf().frameRate));
      for (int b=0; b < blocks.size(); b++) {
        byte[] data=blocks.get(b).streamSoundData;
        if (st.getSoundFormatId() == 2) {
          data=Arrays.copyOfRange(data,4,data.length);
        }
        flv.writeTag(new FLVTAG(ms * b,new AUDIODATA(st.getSoundFormatId(),st.getSoundRate(),st.getSoundSize(),st.getSoundType(),data)));
      }
    }
  }
 else {
    List<byte[]> soundData=st.getRawSoundData();
    SWF swf=((Tag)st).getSwf();
    List<SWFInputStream> siss=new ArrayList<>();
    for (    byte[] data : soundData) {
      siss.add(new SWFInputStream(swf,data));
    }
    fmt.createWav(siss,fos);
  }
}",0.875
61650,"@Override public byte[] getRawSoundData(){
  if (soundFormat == SoundFormat.FORMAT_MP3) {
    return Arrays.copyOfRange(soundData,2,soundData.length);
  }
  return soundData;
}","@Override public List<byte[]> getRawSoundData(){
  List<byte[]> ret=new ArrayList<byte[]>();
  if (soundFormat == SoundFormat.FORMAT_MP3) {
    ret.add(Arrays.copyOfRange(soundData,2,soundData.length));
    return ret;
  }
  ret.add(soundData);
  return ret;
}",0.7293577981651376
61651,"@Override public List<SoundStreamBlockTag> getBlocks(){
  List<SoundStreamBlockTag> ret=new ArrayList<>();
  SoundStreamHeadTag.populateSoundStreamBlocks(swf.tags,this,ret);
  return ret;
}","@Override public List<SoundStreamBlockTag> getBlocks(){
  List<SoundStreamBlockTag> ret=new ArrayList<>();
  SoundStreamHeadTag.populateSoundStreamBlocks(0,swf.tags,this,ret);
  return ret;
}",0.9947368421052633
61652,"@Override public byte[] getRawSoundData(){
  List<SoundStreamBlockTag> blocks=getBlocks();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    for (    SoundStreamBlockTag block : blocks) {
      if (streamSoundCompression == SoundFormat.FORMAT_MP3) {
        baos.write(block.streamSoundData,4,block.streamSoundData.length - 4);
      }
 else {
        baos.write(block.streamSoundData);
      }
    }
  }
 catch (  IOException ex) {
    return null;
  }
  return baos.toByteArray();
}","@Override public List<byte[]> getRawSoundData(){
  List<byte[]> ret=new ArrayList<byte[]>();
  List<SoundStreamBlockTag> blocks=getBlocks();
  for (  SoundStreamBlockTag block : blocks) {
    if (streamSoundCompression == SoundFormat.FORMAT_MP3) {
      ret.add(Arrays.copyOfRange(block.streamSoundData,4,block.streamSoundData.length));
    }
 else {
      ret.add(block.streamSoundData);
    }
  }
  return ret;
}",0.6056644880174292
61653,"@Override public List<SoundStreamBlockTag> getBlocks(){
  List<SoundStreamBlockTag> ret=new ArrayList<>();
  populateSoundStreamBlocks(swf.tags,this,ret);
  return ret;
}","@Override public List<SoundStreamBlockTag> getBlocks(){
  List<SoundStreamBlockTag> ret=new ArrayList<>();
  populateSoundStreamBlocks(0,swf.tags,this,ret);
  return ret;
}",0.9941520467836256
61654,"public static void populateSoundStreamBlocks(List<? extends ContainerItem> tags,Tag head,List<SoundStreamBlockTag> output){
  boolean found=false;
  for (  ContainerItem t : tags) {
    if (t == head) {
      found=true;
      continue;
    }
    if (!found) {
      continue;
    }
    if (t instanceof SoundStreamBlockTag) {
      output.add((SoundStreamBlockTag)t);
    }
    if (t instanceof SoundStreamHeadTypeTag) {
      break;
    }
    if (t instanceof Container) {
      populateSoundStreamBlocks(((Container)t).getSubItems(),head,output);
    }
  }
}","public static void populateSoundStreamBlocks(int containerId,List<? extends ContainerItem> tags,Tag head,List<SoundStreamBlockTag> output){
  boolean found=false;
  for (  ContainerItem t : tags) {
    if (t == head) {
      found=true;
      ((SoundStreamHeadTypeTag)head).setVirtualCharacterId(containerId);
      continue;
    }
    if (t instanceof Container) {
      populateSoundStreamBlocks(((CharacterIdTag)t).getCharacterId(),((Container)t).getSubItems(),head,output);
    }
    if (!found) {
      continue;
    }
    if (t instanceof SoundStreamBlockTag) {
      output.add((SoundStreamBlockTag)t);
    }
    if (t instanceof SoundStreamHeadTypeTag) {
      break;
    }
  }
}",0.5336538461538461
61655,"@Override public byte[] getRawSoundData(){
  List<SoundStreamBlockTag> blocks=getBlocks();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    for (    SoundStreamBlockTag block : blocks) {
      if (streamSoundCompression == SoundFormat.FORMAT_MP3) {
        baos.write(block.streamSoundData,4,block.streamSoundData.length - 4);
      }
 else {
        baos.write(block.streamSoundData);
      }
    }
  }
 catch (  IOException ex) {
    return null;
  }
  return baos.toByteArray();
}","@Override public List<byte[]> getRawSoundData(){
  List<byte[]> ret=new ArrayList<byte[]>();
  List<SoundStreamBlockTag> blocks=getBlocks();
  for (  SoundStreamBlockTag block : blocks) {
    if (streamSoundCompression == SoundFormat.FORMAT_MP3) {
      ret.add(Arrays.copyOfRange(block.streamSoundData,4,block.streamSoundData.length));
    }
 else {
      ret.add(block.streamSoundData);
    }
  }
  return ret;
}",0.6056644880174292
61656,public byte[] getRawSoundData();,public List<byte[]> getRawSoundData();,0.9142857142857144
61657,"public boolean createWav(SWFInputStream sis,OutputStream os){
  ensureFormat();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  decode(sis,baos);
  try {
    createWavFromPcmData(os,samplingRate,true,stereo,baos.toByteArray());
    return true;
  }
 catch (  IOException ex) {
    return false;
  }
}","public boolean createWav(List<SWFInputStream> siss,OutputStream os){
  ensureFormat();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  for (  SWFInputStream sis : siss) {
    decode(sis,baos);
  }
  try {
    createWavFromPcmData(os,samplingRate,true,stereo,baos.toByteArray());
    return true;
  }
 catch (  IOException ex) {
    return false;
  }
}",0.9155555555555556
61658,"public SoundTagPlayer(SoundTag tag,int loops) throws LineUnavailableException, IOException, UnsupportedAudioFileException {
  this.tag=tag;
  this.loops=loops;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  byte[] soundData=tag.getRawSoundData();
  SWF swf=((Tag)tag).getSwf();
  tag.getSoundFormat().createWav(new SWFInputStream(swf,soundData),baos);
  player=new SoundPlayer(new ByteArrayInputStream(baos.toByteArray()));
}","public SoundTagPlayer(SoundTag tag,int loops) throws LineUnavailableException, IOException, UnsupportedAudioFileException {
  this.tag=tag;
  this.loops=loops;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  List<byte[]> soundData=tag.getRawSoundData();
  SWF swf=((Tag)tag).getSwf();
  List<SWFInputStream> siss=new ArrayList<>();
  for (  byte[] data : soundData) {
    siss.add(new SWFInputStream(swf,data));
  }
  tag.getSoundFormat().createWav(siss,baos);
  player=new SoundPlayer(new ByteArrayInputStream(baos.toByteArray()));
}",0.7987804878048781
61659,"private List<TreeNode> createTagList(List<Tag> list,SWF swf,SWFNode swfNode,ClassesListTreeModel classTreeModel){
  boolean hasAbc=swf.abcList != null && !swf.abcList.isEmpty();
  List<TreeNode> ret=new ArrayList<>();
  List<TreeNode> frames=new ArrayList<>();
  List<TreeNode> shapes=new ArrayList<>();
  List<TreeNode> morphShapes=new ArrayList<>();
  List<TreeNode> sprites=new ArrayList<>();
  List<TreeNode> buttons=new ArrayList<>();
  List<TreeNode> images=new ArrayList<>();
  List<TreeNode> fonts=new ArrayList<>();
  List<TreeNode> texts=new ArrayList<>();
  List<TreeNode> movies=new ArrayList<>();
  List<TreeNode> sounds=new ArrayList<>();
  List<TreeNode> binaryData=new ArrayList<>();
  List<TreeNode> others=new ArrayList<>();
  List<TreeNode> actionScript=SWF.createASTagList(list,swf);
  List<Tag> actionScriptTags=new ArrayList<>();
  SWF.getTagsFromTreeNodes(actionScript,actionScriptTags);
  for (  Tag t : list) {
    TreeNodeType ttype=TagTree.getTreeNodeType(t);
switch (ttype) {
case SHAPE:
      shapes.add(new TagNode(t));
    break;
case MORPH_SHAPE:
  morphShapes.add(new TagNode(t));
break;
case SPRITE:
sprites.add(new TagNode(t));
break;
case BUTTON:
buttons.add(new TagNode(t));
break;
case IMAGE:
images.add(new TagNode(t));
break;
case FONT:
fonts.add(new TagNode(t));
break;
case TEXT:
texts.add(new TagNode(t));
break;
case MOVIE:
movies.add(new TagNode(t));
break;
case SOUND:
sounds.add(new TagNode(t));
break;
case BINARY_DATA:
TagNode bt;
binaryData.add(bt=new TagNode(t));
break;
default :
if (!actionScriptTags.contains(t) && t.getId() != ShowFrameTag.ID && !ShowFrameTag.isNestedTagType(t.getId())) {
others.add(new TagNode(t));
}
break;
}
}
Timeline timeline=swf.getTimeline();
for (int i=0; i < timeline.getFrameCount(); i++) {
frames.add(new FrameNode(new FrameNodeItem(swf,i + 1,swf,true),timeline.frames.get(i).innerTags,false));
}
for (int i=0; i < sounds.size(); i++) {
if (sounds.get(i).getItem() instanceof SoundStreamHeadTypeTag) {
List<SoundStreamBlockTag> blocks=((SoundStreamHeadTypeTag)sounds.get(i).getItem()).getBlocks();
if (blocks.isEmpty()) {
sounds.remove(i);
i--;
}
}
}
for (TreeNode n : sprites) {
Timelined timelined=n.getItem() instanceof Timelined ? (Timelined)n.getItem() : null;
n.subNodes=createSubTagList(((DefineSpriteTag)n.getItem()).subTags,timelined,swf,actionScriptTags);
}
StringNode textsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_TEXTS,swf));
textsNode.subNodes.addAll(texts);
StringNode imagesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_IMAGES,swf));
imagesNode.subNodes.addAll(images);
StringNode moviesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_MOVIES,swf));
moviesNode.subNodes.addAll(movies);
StringNode soundsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SOUNDS,swf));
soundsNode.subNodes.addAll(sounds);
StringNode binaryDataNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_BINARY_DATA,swf));
binaryDataNode.subNodes.addAll(binaryData);
StringNode fontsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_FONTS,swf));
fontsNode.subNodes.addAll(fonts);
StringNode spritesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SPRITES,swf));
spritesNode.subNodes.addAll(sprites);
StringNode shapesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SHAPES,swf));
shapesNode.subNodes.addAll(shapes);
StringNode morphShapesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_MORPHSHAPES,swf));
morphShapesNode.subNodes.addAll(morphShapes);
StringNode buttonsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_BUTTONS,swf));
buttonsNode.subNodes.addAll(buttons);
StringNode framesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_FRAMES,swf));
framesNode.subNodes.addAll(frames);
StringNode otherNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_OTHERS,swf));
otherNode.subNodes.addAll(others);
TreeNode actionScriptNode;
if (hasAbc) {
actionScriptNode=new ClassesListNode(classTreeModel);
}
 else {
actionScriptNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SCRIPTS,swf));
actionScriptNode.subNodes.addAll(actionScript);
}
swfNode.scriptsNode=actionScriptNode;
ret.add(new HeaderNode(new HeaderItem(swf,AppStrings.translate(""String_Node_Str""))));
if (!shapesNode.subNodes.isEmpty()) {
ret.add(shapesNode);
}
if (!morphShapesNode.subNodes.isEmpty()) {
ret.add(morphShapesNode);
}
if (!spritesNode.subNodes.isEmpty()) {
ret.add(spritesNode);
}
if (!textsNode.subNodes.isEmpty()) {
ret.add(textsNode);
}
if (!imagesNode.subNodes.isEmpty()) {
ret.add(imagesNode);
}
if (!moviesNode.subNodes.isEmpty()) {
ret.add(moviesNode);
}
if (!soundsNode.subNodes.isEmpty()) {
ret.add(soundsNode);
}
if (!buttonsNode.subNodes.isEmpty()) {
ret.add(buttonsNode);
}
if (!fontsNode.subNodes.isEmpty()) {
ret.add(fontsNode);
}
if (!binaryDataNode.subNodes.isEmpty()) {
ret.add(binaryDataNode);
}
if (!framesNode.subNodes.isEmpty()) {
ret.add(framesNode);
}
if (!otherNode.subNodes.isEmpty()) {
ret.add(otherNode);
}
if ((!actionScriptNode.subNodes.isEmpty()) || hasAbc) {
ret.add(actionScriptNode);
}
return ret;
}","private List<TreeNode> createTagList(List<Tag> list,SWF swf,SWFNode swfNode,ClassesListTreeModel classTreeModel){
  boolean hasAbc=swf.abcList != null && !swf.abcList.isEmpty();
  List<TreeNode> ret=new ArrayList<>();
  List<TreeNode> frames=new ArrayList<>();
  List<TreeNode> shapes=new ArrayList<>();
  List<TreeNode> morphShapes=new ArrayList<>();
  List<TreeNode> sprites=new ArrayList<>();
  List<TreeNode> buttons=new ArrayList<>();
  List<TreeNode> images=new ArrayList<>();
  List<TreeNode> fonts=new ArrayList<>();
  List<TreeNode> texts=new ArrayList<>();
  List<TreeNode> movies=new ArrayList<>();
  List<TreeNode> sounds=new ArrayList<>();
  List<TreeNode> binaryData=new ArrayList<>();
  List<TreeNode> others=new ArrayList<>();
  List<TreeNode> actionScript=SWF.createASTagList(list,swf);
  List<Tag> actionScriptTags=new ArrayList<>();
  SWF.getTagsFromTreeNodes(actionScript,actionScriptTags);
  for (  Tag t : list) {
    TreeNodeType ttype=TagTree.getTreeNodeType(t);
switch (ttype) {
case SHAPE:
      shapes.add(new TagNode(t));
    break;
case MORPH_SHAPE:
  morphShapes.add(new TagNode(t));
break;
case SPRITE:
sprites.add(new TagNode(t));
sounds.addAll(getSoundStreams((DefineSpriteTag)t));
break;
case BUTTON:
buttons.add(new TagNode(t));
break;
case IMAGE:
images.add(new TagNode(t));
break;
case FONT:
fonts.add(new TagNode(t));
break;
case TEXT:
texts.add(new TagNode(t));
break;
case MOVIE:
movies.add(new TagNode(t));
break;
case SOUND:
sounds.add(new TagNode(t));
break;
case BINARY_DATA:
TagNode bt;
binaryData.add(bt=new TagNode(t));
break;
default :
if (!actionScriptTags.contains(t) && t.getId() != ShowFrameTag.ID && !ShowFrameTag.isNestedTagType(t.getId())) {
others.add(new TagNode(t));
}
break;
}
}
Timeline timeline=swf.getTimeline();
for (int i=0; i < timeline.getFrameCount(); i++) {
frames.add(new FrameNode(new FrameNodeItem(swf,i + 1,swf,true),timeline.frames.get(i).innerTags,false));
}
for (int i=0; i < sounds.size(); i++) {
if (sounds.get(i).getItem() instanceof SoundStreamHeadTypeTag) {
List<SoundStreamBlockTag> blocks=((SoundStreamHeadTypeTag)sounds.get(i).getItem()).getBlocks();
if (blocks.isEmpty()) {
sounds.remove(i);
i--;
}
}
}
for (TreeNode n : sprites) {
Timelined timelined=n.getItem() instanceof Timelined ? (Timelined)n.getItem() : null;
n.subNodes=createSubTagList(((DefineSpriteTag)n.getItem()).subTags,timelined,swf,actionScriptTags);
}
StringNode textsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_TEXTS,swf));
textsNode.subNodes.addAll(texts);
StringNode imagesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_IMAGES,swf));
imagesNode.subNodes.addAll(images);
StringNode moviesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_MOVIES,swf));
moviesNode.subNodes.addAll(movies);
StringNode soundsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SOUNDS,swf));
soundsNode.subNodes.addAll(sounds);
StringNode binaryDataNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_BINARY_DATA,swf));
binaryDataNode.subNodes.addAll(binaryData);
StringNode fontsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_FONTS,swf));
fontsNode.subNodes.addAll(fonts);
StringNode spritesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SPRITES,swf));
spritesNode.subNodes.addAll(sprites);
StringNode shapesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SHAPES,swf));
shapesNode.subNodes.addAll(shapes);
StringNode morphShapesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_MORPHSHAPES,swf));
morphShapesNode.subNodes.addAll(morphShapes);
StringNode buttonsNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_BUTTONS,swf));
buttonsNode.subNodes.addAll(buttons);
StringNode framesNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_FRAMES,swf));
framesNode.subNodes.addAll(frames);
StringNode otherNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_OTHERS,swf));
otherNode.subNodes.addAll(others);
TreeNode actionScriptNode;
if (hasAbc) {
actionScriptNode=new ClassesListNode(classTreeModel);
}
 else {
actionScriptNode=new StringNode(new StringItem(translate(""String_Node_Str""),FOLDER_SCRIPTS,swf));
actionScriptNode.subNodes.addAll(actionScript);
}
swfNode.scriptsNode=actionScriptNode;
ret.add(new HeaderNode(new HeaderItem(swf,AppStrings.translate(""String_Node_Str""))));
if (!shapesNode.subNodes.isEmpty()) {
ret.add(shapesNode);
}
if (!morphShapesNode.subNodes.isEmpty()) {
ret.add(morphShapesNode);
}
if (!spritesNode.subNodes.isEmpty()) {
ret.add(spritesNode);
}
if (!textsNode.subNodes.isEmpty()) {
ret.add(textsNode);
}
if (!imagesNode.subNodes.isEmpty()) {
ret.add(imagesNode);
}
if (!moviesNode.subNodes.isEmpty()) {
ret.add(moviesNode);
}
if (!soundsNode.subNodes.isEmpty()) {
ret.add(soundsNode);
}
if (!buttonsNode.subNodes.isEmpty()) {
ret.add(buttonsNode);
}
if (!fontsNode.subNodes.isEmpty()) {
ret.add(fontsNode);
}
if (!binaryDataNode.subNodes.isEmpty()) {
ret.add(binaryDataNode);
}
if (!framesNode.subNodes.isEmpty()) {
ret.add(framesNode);
}
if (!otherNode.subNodes.isEmpty()) {
ret.add(otherNode);
}
if ((!actionScriptNode.subNodes.isEmpty()) || hasAbc) {
ret.add(actionScriptNode);
}
return ret;
}",0.9950869236583524
61660,"public static void copyStream(InputStream is,OutputStream os,long maxLength){
  try {
    final int bufSize=4096;
    byte[] buf=new byte[bufSize];
    int cnt=0;
    while ((cnt=is.read(buf)) > 0) {
      os.write(buf,0,cnt);
      maxLength-=cnt;
      if (maxLength < bufSize) {
        buf=new byte[(int)maxLength];
      }
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(Helper.class.getName()).log(Level.SEVERE,null,ex);
  }
}","public static void copyStream(InputStream is,OutputStream os,long maxLength){
  try {
    final int bufSize=4096;
    byte[] buf=new byte[bufSize];
    int cnt=0;
    while ((cnt=is.read(buf)) > 0) {
      os.write(buf,0,cnt);
      maxLength-=cnt;
      if (maxLength < bufSize) {
        buf=new byte[(int)maxLength];
      }
    }
  }
 catch (  IOException ex) {
  }
}",0.9041769041769042
61661,"/** 
 * Parses the console arguments
 * @param arguments
 * @return path to the file which should be opened or null
 * @throws java.io.IOException
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>();
  for (  String arg : arguments) {
    if (arg.length() > 0) {
      args.add(arg);
    }
  }
  AbortRetryIgnoreHandler handler=null;
  Map<String,String> format=new HashMap<>();
  double zoom=1;
  Selection selection=new Selection();
  Selection selectionIds=new Selection();
  String nextParam;
  OUTER:   while (true) {
    nextParam=args.remove();
    if (nextParam != null) {
      nextParam=nextParam.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      selectionIds=parseSelect(args);
    break;
case ""String_Node_Str"":
  selection=parseSelect(args);
break;
case ""String_Node_Str"":
zoom=parseZoom(args);
break;
case ""String_Node_Str"":
format=parseFormat(args);
break;
case ""String_Node_Str"":
parseConfig(args);
if (args.isEmpty()) {
Configuration.saveConfig();
System.out.println(""String_Node_Str"");
return null;
}
break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
for (int i=0; i < arguments.length; i++) {
System.out.println(i + ""String_Node_Str"" + arguments.length);
}
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(selection,selectionIds,args,handler,traceLevel,format);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExtract(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseFlashPaperToPdf(selection,zoom,args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseReplaceBinaryData(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ActionScriptParser.compile(null,args.remove(),args.remove());
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParam;
}
 else {
badArguments();
}
return null;
}","/** 
 * Parses the console arguments
 * @param arguments
 * @return path to the file which should be opened or null
 * @throws java.io.IOException
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>();
  for (  String arg : arguments) {
    if (arg.length() > 0) {
      args.add(arg);
    }
  }
  AbortRetryIgnoreHandler handler=null;
  Map<String,String> format=new HashMap<>();
  double zoom=1;
  Selection selection=new Selection();
  Selection selectionIds=new Selection();
  String nextParam;
  OUTER:   while (true) {
    nextParam=args.remove();
    if (nextParam != null) {
      nextParam=nextParam.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      selectionIds=parseSelect(args);
    break;
case ""String_Node_Str"":
  selection=parseSelect(args);
break;
case ""String_Node_Str"":
zoom=parseZoom(args);
break;
case ""String_Node_Str"":
format=parseFormat(args);
break;
case ""String_Node_Str"":
parseConfig(args);
if (args.isEmpty()) {
Configuration.saveConfig();
System.out.println(""String_Node_Str"");
return null;
}
break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
for (int i=0; i < arguments.length; i++) {
System.out.println(i + ""String_Node_Str"" + arguments[i]);
}
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(selection,selectionIds,args,handler,traceLevel,format);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExtract(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseFlashPaperToPdf(selection,zoom,args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseReplaceBinaryData(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ActionScriptParser.compile(null,args.remove(),args.remove());
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParam;
}
 else {
badArguments();
}
return null;
}",0.9983943481053308
61662,"/** 
 * Reads one Tag from the stream with optional resolving (= reading tag content)
 * @param timelined
 * @param level
 * @param pos
 * @param resolve
 * @param parallel
 * @param skipUnusualTags
 * @return Tag or null when End tag
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public Tag readTag(Timelined timelined,int level,long pos,boolean resolve,boolean parallel,boolean skipUnusualTags) throws IOException, InterruptedException {
  int tagIDTagLength=readUI16(""String_Node_Str"");
  int tagID=(tagIDTagLength) >> 6;
  logger.log(Level.INFO,""String_Node_Str"",new Object[]{tagID,pos});
  long tagLength=(tagIDTagLength & 0x003F);
  boolean readLong=false;
  if (tagLength == 0x3f) {
    tagLength=readSI32(""String_Node_Str"");
    readLong=true;
  }
  int headerLength=readLong ? 6 : 2;
  SWFInputStream tagDataStream=getLimitedStream((int)tagLength);
  int available=available();
  if (tagLength > available) {
    tagLength=available;
  }
  ByteArrayRange dataRange=new ByteArrayRange(swf.uncompressedData,(int)pos,(int)(tagLength + headerLength));
  skipBytes(tagLength);
  TagStub tagStub=new TagStub(swf,tagID,""String_Node_Str"",dataRange,tagDataStream);
  tagStub.forceWriteAsLong=readLong;
  Tag ret=tagStub;
  if (tagDataStream.dumpInfo == null && dumpInfo != null) {
    dumpInfo.tagToResolve=tagStub;
  }
  if (resolve) {
    DumpInfo di=dumpInfo;
    try {
      ret=resolveTag(tagStub,level,parallel,skipUnusualTags);
    }
 catch (    EndOfStreamException ex) {
      tagDataStream.endDumpLevelUntil(di);
      logger.log(Level.SEVERE,""String_Node_Str"" + timelined.toString(),ex);
    }
    if (Configuration.debugMode.get()) {
      byte[] data=ret.getOriginalData().getRangeData();
      byte[] dataNew=ret.getData();
      int ignoreFirst=0;
      for (int i=0; i < data.length; i++) {
        if (i >= dataNew.length) {
          break;
        }
        if (dataNew[i] != data[i]) {
          if (ignoreFirst > 0) {
            ignoreFirst--;
            continue;
          }
          String e=""String_Node_Str"" + ret.toString() + ""String_Node_Str"";
          for (int j=i - 10; j <= i + 5; j++) {
            while (j < 0) {
              j++;
            }
            if (j >= data.length) {
              break;
            }
            if (j >= dataNew.length) {
              break;
            }
            if (j >= i) {
              e+=(Long.toHexString(data[j] & 0xff) + ""String_Node_Str"" + Long.toHexString(dataNew[j] & 0xff)+ ""String_Node_Str"");
            }
 else {
              e+=(Long.toHexString(data[j] & 0xff) + ""String_Node_Str"");
            }
          }
          logger.fine(e);
        }
      }
    }
  }
  return ret;
}","/** 
 * Reads one Tag from the stream with optional resolving (= reading tag content)
 * @param timelined
 * @param level
 * @param pos
 * @param resolve
 * @param parallel
 * @param skipUnusualTags
 * @return Tag or null when End tag
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public Tag readTag(Timelined timelined,int level,long pos,boolean resolve,boolean parallel,boolean skipUnusualTags) throws IOException, InterruptedException {
  int tagIDTagLength=readUI16(""String_Node_Str"");
  int tagID=(tagIDTagLength) >> 6;
  logger.log(Level.INFO,""String_Node_Str"",new Object[]{tagID,pos});
  long tagLength=(tagIDTagLength & 0x003F);
  boolean readLong=false;
  if (tagLength == 0x3f) {
    tagLength=readSI32(""String_Node_Str"");
    readLong=true;
  }
  int headerLength=readLong ? 6 : 2;
  SWFInputStream tagDataStream=getLimitedStream((int)tagLength);
  int available=available();
  if (tagLength > available) {
    tagLength=available;
  }
  ByteArrayRange dataRange=new ByteArrayRange(swf.uncompressedData,(int)pos,(int)(tagLength + headerLength));
  skipBytes(tagLength);
  TagStub tagStub=new TagStub(swf,tagID,""String_Node_Str"",dataRange,tagDataStream);
  tagStub.forceWriteAsLong=readLong;
  Tag ret=tagStub;
  if (tagDataStream.dumpInfo == null && dumpInfo != null) {
    dumpInfo.tagToResolve=tagStub;
  }
  if (resolve) {
    DumpInfo di=dumpInfo;
    try {
      ret=resolveTag(tagStub,level,parallel,skipUnusualTags);
    }
 catch (    Exception ex) {
      tagDataStream.endDumpLevelUntil(di);
      logger.log(Level.SEVERE,""String_Node_Str"" + timelined.toString(),ex);
    }
    if (Configuration.debugMode.get()) {
      byte[] data=ret.getOriginalData().getRangeData();
      byte[] dataNew=ret.getData();
      int ignoreFirst=0;
      for (int i=0; i < data.length; i++) {
        if (i >= dataNew.length) {
          break;
        }
        if (dataNew[i] != data[i]) {
          if (ignoreFirst > 0) {
            ignoreFirst--;
            continue;
          }
          String e=""String_Node_Str"" + ret.toString() + ""String_Node_Str"";
          for (int j=i - 10; j <= i + 5; j++) {
            while (j < 0) {
              j++;
            }
            if (j >= data.length) {
              break;
            }
            if (j >= dataNew.length) {
              break;
            }
            if (j >= i) {
              e+=(Long.toHexString(data[j] & 0xff) + ""String_Node_Str"" + Long.toHexString(dataNew[j] & 0xff)+ ""String_Node_Str"");
            }
 else {
              e+=(Long.toHexString(data[j] & 0xff) + ""String_Node_Str"");
            }
          }
          logger.fine(e);
        }
      }
    }
  }
  return ret;
}",0.9979572887650882
61663,"public FontType(GFxInputStream sis) throws IOException {
  fontName=sis.readString();
  flags=sis.readUI16();
  nominalSize=sis.readUI16();
  ascent=sis.readSI16();
  descent=sis.readSI16();
  leading=sis.readSI16();
  long numGlyphs=sis.readUI32();
  long glyphBytesLen=sis.readUI32();
  byte glyphBytes[]=new byte[(int)glyphBytesLen];
  sis.read(glyphBytes);
  glyphInfo=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphInfo.add(new GlyphInfoType(sis));
  }
  long kerningTableSize=sis.readUI30();
  kerning=new ArrayList<>();
  for (int i=0; i < kerningTableSize; i++) {
    kerning.add(new KerningPairType(sis));
  }
  glyphs=new ArrayList<>();
  for (int i=0; i < glyphInfo.size(); i++) {
    sis.setPos(glyphInfo.get(i).globalOffset);
    glyphs.add(new GlyphType(sis));
  }
}","public FontType(GFxInputStream sis) throws IOException {
  fontName=sis.readString();
  flags=sis.readUI16();
  nominalSize=sis.readUI16();
  ascent=sis.readSI16();
  descent=sis.readSI16();
  leading=sis.readSI16();
  long numGlyphs=sis.readUI32();
  long glyphBytesLen=sis.readUI32();
  byte glyphBytes[]=new byte[(int)glyphBytesLen];
  sis.read(glyphBytes);
  glyphInfo=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphInfo.add(new GlyphInfoType(sis));
  }
  long kerningTableSize=sis.readUI30();
  kerning=new ArrayList<>();
  for (int i=0; i < kerningTableSize; i++) {
    kerning.add(new KerningPairType(sis));
  }
  long pos=sis.getPos();
  glyphs=new ArrayList<>();
  for (int i=0; i < glyphInfo.size(); i++) {
    sis.setPos(glyphInfo.get(i).globalOffset);
    glyphs.add(new GlyphType(sis));
  }
  sis.setPos(pos);
}",0.9732034104750305
61664,"/** 
 * Reads one string value from the stream
 * @param name
 * @return String value
 * @throws IOException
 */
public String readString() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int r;
  while (true) {
    r=readUI8();
    if (r == 0) {
      return new String(baos.toByteArray(),Utf8Helper.charset);
    }
    baos.write(r);
  }
}","/** 
 * Reads one string value from the stream
 * @return String value
 * @throws IOException
 */
public String readString() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int r;
  while (true) {
    r=readUI8();
    if (r == 0) {
      return new String(baos.toByteArray(),Utf8Helper.charset);
    }
    baos.write(r);
  }
}",0.9795361527967258
61665,"/** 
 * Parses the console arguments
 * @param arguments
 * @return path to the file which should be opened or null
 * @throws java.io.IOException
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>();
  for (  String arg : arguments) {
    if (arg.length() > 0) {
      args.add(arg);
    }
  }
  AbortRetryIgnoreHandler handler=null;
  Map<String,String> format=new HashMap<>();
  double zoom=1;
  Selection selection=new Selection();
  Selection selectionIds=new Selection();
  String nextParam;
  OUTER:   while (true) {
    nextParam=args.remove();
    if (nextParam != null) {
      nextParam=nextParam.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      selectionIds=parseSelect(args);
    break;
case ""String_Node_Str"":
  selection=parseSelect(args);
break;
case ""String_Node_Str"":
zoom=parseZoom(args);
break;
case ""String_Node_Str"":
format=parseFormat(args);
break;
case ""String_Node_Str"":
parseConfig(args);
if (args.isEmpty()) {
Configuration.saveConfig();
System.out.println(""String_Node_Str"");
return null;
}
break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(selection,selectionIds,args,handler,traceLevel,format);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExtract(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseFlashPaperToPdf(selection,zoom,args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseReplaceBinaryData(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ActionScriptParser.compile(null,args.remove(),args.remove());
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParam;
}
 else {
badArguments();
}
return null;
}","/** 
 * Parses the console arguments
 * @param arguments
 * @return path to the file which should be opened or null
 * @throws java.io.IOException
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>();
  for (  String arg : arguments) {
    if (arg.length() > 0) {
      args.add(arg);
    }
  }
  AbortRetryIgnoreHandler handler=null;
  Map<String,String> format=new HashMap<>();
  double zoom=1;
  Selection selection=new Selection();
  Selection selectionIds=new Selection();
  String nextParam=null, nextParamOriginal=null;
  OUTER:   while (true) {
    nextParamOriginal=args.remove();
    if (nextParamOriginal != null) {
      nextParam=nextParamOriginal.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      selectionIds=parseSelect(args);
    break;
case ""String_Node_Str"":
  selection=parseSelect(args);
break;
case ""String_Node_Str"":
zoom=parseZoom(args);
break;
case ""String_Node_Str"":
format=parseFormat(args);
break;
case ""String_Node_Str"":
parseConfig(args);
if (args.isEmpty()) {
Configuration.saveConfig();
System.out.println(""String_Node_Str"");
return null;
}
break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(selection,selectionIds,args,handler,traceLevel,format);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExtract(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseFlashPaperToPdf(selection,zoom,args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseReplaceBinaryData(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ActionScriptParser.compile(null,args.remove(),args.remove());
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParamOriginal;
}
 else {
badArguments();
}
return null;
}",0.9899654548445468
61666,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : swf.tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : swf.tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9798783341132428
61667,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9972100438421682
61668,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9821299783636508
61669,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : swf.tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : swf.tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * ((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9990680335507922
61670,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round(((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,String formattedText,String[] texts) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(formattedText));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    int textIdx=0;
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : swf.tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
String txt=(texts == null || textIdx >= texts.length) ? (String)s.values[0] : texts[textIdx++];
if (txt == null || (font == null && txt.isEmpty())) {
continue;
}
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(c)) {
if (!missingCharHandler.handle(font,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(nextChar)) {
if (!missingCharHandler.handle(font,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tr.glyphEntries[i].glyphIndex,font.charToGlyph(nextChar));
}
advance=(int)Math.round(font.getDivider() * ((double)textHeight * font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0));
}
 else {
advance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor),c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9990451941438574
61671,"@Override public void setActions(List<Action> actions){
  actionBytes=Action.actionsToBytes(actions,true,swf.version);
}","@Override public void setActions(List<Action> actions){
  byte[] bytes=Action.actionsToBytes(actions,true,swf.version);
  actionBytes=new ByteArrayRange(bytes,0,bytes.length);
}",0.7676767676767676
61672,"@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes);
}","@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes.getRangeData());
}",0.9494949494949496
61673,"/** 
 * Returns actions associated with this object
 * @return List of actions
 * @throws java.lang.InterruptedException
 */
@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength;
    SWFInputStream rri;
    if (actionBytes == null) {
      prevLength=(int)(getDataPos() + hdrSize);
      rri=new SWFInputStream(swf,getOriginalRange().array);
      rri.seek(prevLength);
    }
 else {
      prevLength=0;
      rri=new SWFInputStream(swf,actionBytes);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}","/** 
 * Returns actions associated with this object
 * @return List of actions
 * @throws java.lang.InterruptedException
 */
@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength=actionBytes.pos;
    SWFInputStream rri=new SWFInputStream(swf,actionBytes.array);
    if (prevLength != 0) {
      rri.seek(prevLength);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}",0.8109875735775016
61674,"/** 
 * Constructor
 * @param sis
 * @param data
 * @throws IOException
 */
public DefineButtonTag(SWFInputStream sis,ByteArrayRange data) throws IOException {
  super(sis.getSwf(),ID,""String_Node_Str"",data);
  buttonId=sis.readUI16(""String_Node_Str"");
  characters=sis.readBUTTONRECORDList(false,""String_Node_Str"");
  hdrSize=sis.getPos();
  actionBytes=sis.readBytesEx(sis.available(),""String_Node_Str"");
}","/** 
 * Constructor
 * @param sis
 * @param data
 * @throws IOException
 */
public DefineButtonTag(SWFInputStream sis,ByteArrayRange data) throws IOException {
  super(sis.getSwf(),ID,""String_Node_Str"",data);
  buttonId=sis.readUI16(""String_Node_Str"");
  characters=sis.readBUTTONRECORDList(false,""String_Node_Str"");
  int pos=(int)sis.getPos();
  byte[] bytes=sis.readBytesEx(sis.available(),""String_Node_Str"");
  actionBytes=new ByteArrayRange(data.array,pos,bytes.length);
}",0.8903954802259887
61675,"@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=actionBytes;
}","@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=new ByteArrayRange(actionBytes);
}",0.900990099009901
61676,"/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  if (Configuration.debugCopy.get()) {
    os=new CopyOutputStream(os,new ByteArrayInputStream(getOriginalData()));
  }
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  try {
    sos.writeUI16(buttonId);
    sos.writeBUTTONRECORDList(characters,false);
    sos.write(actionBytes);
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  if (Configuration.debugCopy.get()) {
    os=new CopyOutputStream(os,new ByteArrayInputStream(getOriginalData()));
  }
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  try {
    sos.writeUI16(buttonId);
    sos.writeBUTTONRECORDList(characters,false);
    sos.write(getActionBytes());
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.97538742023701
61677,"@Override public byte[] getActionBytes(){
  return actionBytes;
}","@Override public byte[] getActionBytes(){
  return actionBytes.getRangeData();
}",0.896551724137931
61678,"/** 
 * Constructor
 * @param swf
 * @param data
 */
public DoActionTag(SWF swf,ByteArrayRange data){
  super(swf,ID,""String_Node_Str"",data);
  actionBytes=new byte[0];
}","/** 
 * Constructor
 * @param swf
 * @param data
 */
public DoActionTag(SWF swf,ByteArrayRange data){
  super(swf,ID,""String_Node_Str"",data);
  actionBytes=new ByteArrayRange(new byte[0]);
}",0.9444444444444444
61679,"@Override public void setActions(List<Action> actions){
  actionBytes=Action.actionsToBytes(actions,true,swf.version);
}","@Override public void setActions(List<Action> actions){
  byte[] bytes=Action.actionsToBytes(actions,true,swf.version);
  actionBytes=new ByteArrayRange(bytes,0,bytes.length);
}",0.7676767676767676
61680,"@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes);
}","@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes.getRangeData());
}",0.9494949494949496
61681,"@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength;
    SWFInputStream rri;
    if (actionBytes == null) {
      prevLength=(int)getDataPos();
      rri=new SWFInputStream(swf,getOriginalRange().array);
      rri.seek(prevLength);
    }
 else {
      prevLength=0;
      rri=new SWFInputStream(swf,actionBytes);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}","@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength=actionBytes.pos;
    SWFInputStream rri=new SWFInputStream(swf,actionBytes.array);
    if (prevLength != 0) {
      rri.seek(prevLength);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}",0.7813733228097869
61682,"@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=actionBytes;
}","@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=new ByteArrayRange(actionBytes);
}",0.900990099009901
61683,"@Override public byte[] getActionBytes(){
  return actionBytes;
}","@Override public byte[] getActionBytes(){
  return actionBytes.getRangeData();
}",0.896551724137931
61684,"/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  return actionBytes;
}","/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  return getActionBytes();
}",0.9691629955947136
61685,"@Override public void setActions(List<Action> actions){
  actionBytes=Action.actionsToBytes(actions,true,swf.version);
}","@Override public void setActions(List<Action> actions){
  byte[] bytes=Action.actionsToBytes(actions,true,swf.version);
  actionBytes=new ByteArrayRange(bytes,0,bytes.length);
}",0.7676767676767676
61686,"@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes);
}","@Override public GraphTextWriter getActionBytesAsHex(GraphTextWriter writer){
  return Helper.byteArrayToHexWithHeader(writer,actionBytes.getRangeData());
}",0.9494949494949496
61687,"@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength;
    SWFInputStream rri;
    if (actionBytes == null) {
      prevLength=(int)(getDataPos() + 2);
      rri=new SWFInputStream(swf,getOriginalRange().array);
      rri.seek(prevLength);
    }
 else {
      prevLength=0;
      rri=new SWFInputStream(swf,actionBytes);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}","@Override public List<Action> getActions() throws InterruptedException {
  try {
    int prevLength=actionBytes.pos;
    SWFInputStream rri=new SWFInputStream(swf,actionBytes.array);
    if (prevLength != 0) {
      rri.seek(prevLength);
    }
    List<Action> list=ActionListReader.readActionListTimeout(listeners,rri,getVersion(),prevLength,-1,toString());
    return list;
  }
 catch (  InterruptedException ex) {
    throw ex;
  }
catch (  Exception ex) {
    Logger.getLogger(DoActionTag.class.getName()).log(Level.SEVERE,null,ex);
    return new ArrayList<>();
  }
}",0.7776904948939513
61688,"/** 
 * Constructor
 * @param sis
 * @param data
 * @throws IOException
 */
public DoInitActionTag(SWFInputStream sis,ByteArrayRange data) throws IOException {
  super(sis.getSwf(),ID,""String_Node_Str"",data);
  spriteId=sis.readUI16(""String_Node_Str"");
  sis.readBytesEx(sis.available(),""String_Node_Str"");
}","/** 
 * Constructor
 * @param sis
 * @param data
 * @throws IOException
 */
public DoInitActionTag(SWFInputStream sis,ByteArrayRange data) throws IOException {
  super(sis.getSwf(),ID,""String_Node_Str"",data);
  spriteId=sis.readUI16(""String_Node_Str"");
  int pos=(int)sis.getPos();
  byte[] bytes=sis.readBytesEx(sis.available(),""String_Node_Str"");
  actionBytes=new ByteArrayRange(data.array,pos,bytes.length);
}",0.8543689320388349
61689,"@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=actionBytes;
}","@Override public void setActionBytes(byte[] actionBytes){
  this.actionBytes=new ByteArrayRange(actionBytes);
}",0.900990099009901
61690,"@Override public byte[] getActionBytes(){
  return actionBytes;
}","@Override public byte[] getActionBytes(){
  return actionBytes.getRangeData();
}",0.896551724137931
61691,"/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,getVersion());
  try {
    sos.writeUI16(spriteId);
    sos.write(actionBytes);
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,getVersion());
  try {
    sos.writeUI16(spriteId);
    sos.write(getActionBytes());
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.9622377622377624
61692,"public void clearModified(){
  for (  Tag tag : tags) {
    if (tag.isModified()) {
      tag.setModified(false);
    }
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    saveTo(baos,SWFCompression.NONE);
    byte[] swfData=baos.toByteArray();
    uncompressedData=swfData;
  }
 catch (  IOException ex) {
    Logger.getLogger(SWF.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
}","public void clearModified(){
  for (  Tag tag : tags) {
    if (tag.isModified()) {
      tag.createOriginalData();
      tag.setModified(false);
    }
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    saveTo(baos,SWFCompression.NONE);
    byte[] swfData=baos.toByteArray();
    uncompressedData=swfData;
  }
 catch (  IOException ex) {
    Logger.getLogger(SWF.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
}",0.9629629629629628
61693,"public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,int containerId,List<Integer> frames,final FramesExportSettings settings) throws IOException {
  final List<File> ret=new ArrayList<>();
  if (tags.isEmpty()) {
    return ret;
  }
  Timeline tim=null;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim=getTimeline();
  }
 else {
    tim=((Timelined)characters.get(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(characters.get(containerId).getExportFileName());
  }
  if (frames == null) {
    int frameCnt=tim.frames.size();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  if (!foutdir.exists()) {
    if (!foutdir.mkdirs()) {
      if (!foutdir.exists()) {
        throw new IOException(""String_Node_Str"" + outdir);
      }
    }
  }
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  if (settings.mode == FramesExportMode.AVI) {
    for (    Tag t : tags) {
      if (t instanceof SetBackgroundColorTag) {
        SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
        backgroundColor=sb.backgroundColor.toColor();
      }
    }
  }
  if (settings.mode == FramesExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      final int fi=i;
      final Timeline ftim=tim;
      final Color fbackgroundColor=backgroundColor;
      new RetryTask(new RunnableIOEx(){
        @Override public void run() throws IOException {
          int frame=fframes.get(fi);
          File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
          try (FileOutputStream fos=new FileOutputStream(f)){
            SVGExporter exporter=new SVGExporter(new ExportRectangle(ftim.displayRect));
            if (fbackgroundColor != null) {
              exporter.setBackGroundColor(fbackgroundColor);
            }
            frameToSvg(ftim,frame,0,null,0,exporter,new ColorTransform(),0);
            fos.write(Utf8Helper.getBytes(exporter.getSVG()));
          }
           ret.add(f);
        }
      }
,handler).run();
    }
    return ret;
  }
  if (settings.mode == FramesExportMode.CANVAS) {
    final Timeline ftim=tim;
    final Color fbackgroundColor=backgroundColor;
    final SWF fswf=this;
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
        Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
        ret.add(fcanvas);
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
        int width=(int)(ftim.displayRect.getWidth() / SWF.unitDivisor);
        int height=(int)(ftim.displayRect.getHeight() / SWF.unitDivisor);
        try (FileOutputStream fos=new FileOutputStream(f)){
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          Set<Integer> library=new HashSet<>();
          ftim.getNeededCharacters(fframes,library);
          writeLibrary(fswf,library,fos);
          String currentName=ftim.id == 0 ? ""String_Node_Str"" : getTypePrefix(fswf.characters.get(ftim.id)) + ftim.id;
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (-ftim.displayRect.Xmin / unitDivisor) + ""String_Node_Str""+ (-ftim.displayRect.Ymin / unitDivisor)+ ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(framesToHtmlCanvas(unitDivisor,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor)));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          for (          int i : fframes) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str"" + i + ""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          RGB backgroundColor=new RGB(255,255,255);
          for (          Tag t : fswf.tags) {
            if (t instanceof SetBackgroundColorTag) {
              SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
              backgroundColor=sb.backgroundColor;
            }
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + backgroundColor.toHexRGB() + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + width + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + height + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (int)(1000.0 / ftim.swf.frameRate) + ""String_Node_Str""));
        }
         if (Configuration.packJavaScripts.get()) {
          try {
            JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
            f.delete();
          }
 catch (          Exception|Error e) {
            Logger.getLogger(SWF.class.getName()).log(Level.WARNING,""String_Node_Str"");
            f.renameTo(fmin);
          }
        }
 else {
          f.renameTo(fmin);
        }
        File fh=new File(foutdir + File.separator + ""String_Node_Str"");
        try (FileOutputStream fos=new FileOutputStream(fh);FileInputStream fis=new FileInputStream(fmin)){
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
          byte buf[]=new byte[1000];
          int cnt;
          while ((cnt=fis.read(buf)) > 0) {
            fos.write(buf,0,cnt);
          }
          if (Configuration.packJavaScripts.get()) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
        }
         fmin.delete();
        ret.add(f);
      }
    }
,handler).run();
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private final int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      return frameToImageGet(ftim,fframes.get(pos),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        makeGIF(frameImages,frameRate,f);
        ret.add(f);
      }
    }
,handler).run();
  break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(new RunnableIOEx(){
    @Override public void run() throws IOException {
      File f=new File(foutdir + File.separator + fframes.get(fi)+ ""String_Node_Str"");
      ImageIO.write(frameImages.next(),""String_Node_Str"",f);
      ret.add(f);
    }
  }
,handler).run();
}
break;
case PDF:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new FileOutputStream(f));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
  BufferedImage img=frameImages.next();
  Graphics g=job.getGraphics(pf);
  g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
  g.dispose();
}
job.end();
ret.add(f);
}
}
,handler).run();
break;
case AVI:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,frameRate,f);
ret.add(f);
}
}
,handler).run();
break;
}
return ret;
}","public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,int containerId,List<Integer> frames,final FramesExportSettings settings) throws IOException {
  final List<File> ret=new ArrayList<>();
  if (tags.isEmpty()) {
    return ret;
  }
  Timeline tim=null;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim=getTimeline();
  }
 else {
    tim=((Timelined)characters.get(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(characters.get(containerId).getExportFileName());
  }
  if (frames == null) {
    int frameCnt=tim.frames.size();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  if (!foutdir.exists()) {
    if (!foutdir.mkdirs()) {
      if (!foutdir.exists()) {
        throw new IOException(""String_Node_Str"" + outdir);
      }
    }
  }
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  if (settings.mode == FramesExportMode.AVI) {
    for (    Tag t : tags) {
      if (t instanceof SetBackgroundColorTag) {
        SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
        backgroundColor=sb.backgroundColor.toColor();
      }
    }
  }
  if (settings.mode == FramesExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      final int fi=i;
      final Timeline ftim=tim;
      final Color fbackgroundColor=backgroundColor;
      new RetryTask(new RunnableIOEx(){
        @Override public void run() throws IOException {
          int frame=fframes.get(fi);
          File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
          try (FileOutputStream fos=new FileOutputStream(f)){
            SVGExporter exporter=new SVGExporter(new ExportRectangle(ftim.displayRect));
            if (fbackgroundColor != null) {
              exporter.setBackGroundColor(fbackgroundColor);
            }
            frameToSvg(ftim,frame,0,null,0,exporter,new ColorTransform(),0);
            fos.write(Utf8Helper.getBytes(exporter.getSVG()));
          }
           ret.add(f);
        }
      }
,handler).run();
    }
    return ret;
  }
  if (settings.mode == FramesExportMode.CANVAS) {
    final Timeline ftim=tim;
    final Color fbackgroundColor=backgroundColor;
    final SWF fswf=this;
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
        Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
        ret.add(fcanvas);
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
        int width=(int)(ftim.displayRect.getWidth() / SWF.unitDivisor);
        int height=(int)(ftim.displayRect.getHeight() / SWF.unitDivisor);
        try (FileOutputStream fos=new FileOutputStream(f)){
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          Set<Integer> library=new HashSet<>();
          ftim.getNeededCharacters(fframes,library);
          writeLibrary(fswf,library,fos);
          String currentName=ftim.id == 0 ? ""String_Node_Str"" : getTypePrefix(fswf.characters.get(ftim.id)) + ftim.id;
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (-ftim.displayRect.Xmin / unitDivisor) + ""String_Node_Str""+ (-ftim.displayRect.Ymin / unitDivisor)+ ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(framesToHtmlCanvas(unitDivisor,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor)));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          for (          int i : fframes) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str"" + i + ""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          RGB backgroundColor=new RGB(255,255,255);
          for (          Tag t : fswf.tags) {
            if (t instanceof SetBackgroundColorTag) {
              SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
              backgroundColor=sb.backgroundColor;
            }
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + backgroundColor.toHexRGB() + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + width + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + height + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (int)(1000.0 / ftim.swf.frameRate) + ""String_Node_Str""));
        }
         if (Configuration.packJavaScripts.get()) {
          try {
            JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
            f.delete();
          }
 catch (          Exception|Error e) {
            Logger.getLogger(SWF.class.getName()).log(Level.WARNING,""String_Node_Str"");
            f.renameTo(fmin);
          }
        }
 else {
          f.renameTo(fmin);
        }
        File fh=new File(foutdir + File.separator + ""String_Node_Str"");
        try (FileOutputStream fos=new FileOutputStream(fh);FileInputStream fis=new FileInputStream(fmin)){
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
          byte buf[]=new byte[1000];
          int cnt;
          while ((cnt=fis.read(buf)) > 0) {
            fos.write(buf,0,cnt);
          }
          if (Configuration.packJavaScripts.get()) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
        }
         fmin.delete();
        ret.add(f);
      }
    }
,handler).run();
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private final int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      return frameToImageGet(ftim,fframes.get(pos),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        makeGIF(frameImages,frameRate,f);
        ret.add(f);
      }
    }
,handler).run();
  break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(new RunnableIOEx(){
    @Override public void run() throws IOException {
      File f=new File(foutdir + File.separator + fframes.get(fi)+ ""String_Node_Str"");
      ImageIO.write(frameImages.next(),""String_Node_Str"",f);
      ret.add(f);
    }
  }
,handler).run();
}
break;
case PDF:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new FileOutputStream(f));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
  BufferedImage img=frameImages.next();
  Graphics g=job.getGraphics(pf);
  g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
  g.dispose();
}
job.end();
ret.add(f);
}
}
,handler).run();
break;
case AVI:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,frameRate,f);
ret.add(f);
}
}
,handler).run();
break;
}
return ret;
}",0.9951412248384858
61694,"@Test public void testFIXEDandFIXED8() throws IOException {
  byte[] data=new byte[]{(byte)0x00,(byte)0x80,(byte)0x07,(byte)0x00};
  SWFInputStream sis=new SWFInputStream(null,data);
  assertTrue(Double.compare(7.5,sis.readFIXED()) == 0);
  sis.close();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  double dd=5.25;
  sos.writeFIXED(dd);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertTrue(Double.compare(dd,sis.readFIXED()) == 0);
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  float ff=5.25f;
  sos.writeFIXED8(ff);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(ff,sis.readFIXED8());
  sis.close();
}","@Test public void testFIXEDandFIXED8() throws IOException {
  byte[] data=new byte[]{(byte)0x00,(byte)0x80,(byte)0x07,(byte)0x00};
  SWFInputStream sis=new SWFInputStream(null,data);
  assertTrue(Double.compare(7.5,sis.readFIXED(""String_Node_Str"")) == 0);
  sis.close();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  double dd=5.25;
  sos.writeFIXED(dd);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertTrue(Double.compare(dd,sis.readFIXED(""String_Node_Str"")) == 0);
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  float ff=5.25f;
  sos.writeFIXED8(ff);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(ff,sis.readFIXED8(""String_Node_Str""));
  sis.close();
}",0.9693325315694528
61695,"@Test public void testRECT() throws IOException {
  RECT rect;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    rect=new RECT(-0x80000000,0x7FFFFFFF,-0x80000000,0x7FFFFFFF);
    sos.writeRECT(rect);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    RECT readRECT=sis.readRECT();
    assertEquals(readRECT.Xmin,-0x3FFFFFFF);
    assertEquals(readRECT.Xmax,0x3FFFFFFF);
    assertEquals(readRECT.Ymin,-0x3FFFFFFF);
    assertEquals(readRECT.Ymax,0x3FFFFFFF);
  }
 }","@Test public void testRECT() throws IOException {
  RECT rect;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    rect=new RECT(-0x80000000,0x7FFFFFFF,-0x80000000,0x7FFFFFFF);
    sos.writeRECT(rect);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    RECT readRECT=sis.readRECT(""String_Node_Str"");
    assertEquals(readRECT.Xmin,-0x3FFFFFFF);
    assertEquals(readRECT.Xmax,0x3FFFFFFF);
    assertEquals(readRECT.Ymin,-0x3FFFFFFF);
    assertEquals(readRECT.Ymax,0x3FFFFFFF);
  }
 }",0.9856054191363252
61696,"@Test public void testSB() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeSB(5,-1);
    sos.writeSB(6,2);
    sos.writeSB(7,-3);
    sos.writeSB(8,4);
    sos.writeSB(9,-5);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertEquals(-1,sis.readSB(5));
    assertEquals(2,sis.readSB(6));
    assertEquals(-3,sis.readSB(7));
    assertEquals(4,sis.readSB(8));
    assertEquals(-5,sis.readSB(9));
  }
 }","@Test public void testSB() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeSB(5,-1);
    sos.writeSB(6,2);
    sos.writeSB(7,-3);
    sos.writeSB(8,4);
    sos.writeSB(9,-5);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertEquals(-1,sis.readSB(5,""String_Node_Str""));
    assertEquals(2,sis.readSB(6,""String_Node_Str""));
    assertEquals(-3,sis.readSB(7,""String_Node_Str""));
    assertEquals(4,sis.readSB(8,""String_Node_Str""));
    assertEquals(-5,sis.readSB(9,""String_Node_Str""));
  }
 }",0.925
61697,"@Test public void testUB() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeUB(5,1);
    sos.writeUB(6,2);
    sos.writeUB(7,3);
    sos.writeUB(8,4);
    sos.writeUB(9,5);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertEquals(1,sis.readUB(5));
    assertEquals(2,sis.readUB(6));
    assertEquals(3,sis.readUB(7));
    assertEquals(4,sis.readUB(8));
    assertEquals(5,sis.readUB(9));
  }
 }","@Test public void testUB() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeUB(5,1);
    sos.writeUB(6,2);
    sos.writeUB(7,3);
    sos.writeUB(8,4);
    sos.writeUB(9,5);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertEquals(1,sis.readUB(5,""String_Node_Str""));
    assertEquals(2,sis.readUB(6,""String_Node_Str""));
    assertEquals(3,sis.readUB(7,""String_Node_Str""));
    assertEquals(4,sis.readUB(8,""String_Node_Str""));
    assertEquals(5,sis.readUB(9,""String_Node_Str""));
  }
 }",0.9242424242424242
61698,"@Test public void testFLOATAndDouble() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  float f=5.25f;
  sos.writeFLOAT(f);
  sos.close();
  SWFInputStream sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(f,sis.readFLOAT());
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  f=5.25f;
  sos.writeFLOAT16(f);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(f,sis.readFLOAT16());
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  double d=5.25;
  sos.writeDOUBLE(d);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(d,sis.readDOUBLE());
  sis.close();
}","@Test public void testFLOATAndDouble() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  float f=5.25f;
  sos.writeFLOAT(f);
  sos.close();
  SWFInputStream sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(f,sis.readFLOAT(""String_Node_Str""));
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  f=5.25f;
  sos.writeFLOAT16(f);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(f,sis.readFLOAT16(""String_Node_Str""));
  sis.close();
  baos=new ByteArrayOutputStream();
  sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
  double d=5.25;
  sos.writeDOUBLE(d);
  sos.close();
  sis=new SWFInputStream(null,baos.toByteArray());
  assertEquals(d,sis.readDOUBLE(""String_Node_Str""));
  sis.close();
}",0.9706390328151986
61699,"@Test public void testFB() throws IOException {
  double f=5.25;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeFB(20,f);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertTrue(Double.compare(f,sis.readFB(20)) == 0);
  }
 }","@Test public void testFB() throws IOException {
  double f=5.25;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try (SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION)){
    sos.writeFB(20,f);
  }
   try (SWFInputStream sis=new SWFInputStream(null,baos.toByteArray())){
    assertTrue(Double.compare(f,sis.readFB(20,""String_Node_Str"")) == 0);
  }
 }",0.9755434782608696
61700,"protected void finalizePath(){
  if (path != null) {
    if (fillPaint != null) {
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);
  lineStroke=null;
  lineColor=null;
  fillPaint=null;
}","protected void finalizePath(){
  if (path != null) {
    if (fillPaint != null) {
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.setComposite(AlphaComposite.SrcOver);
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);
  lineStroke=null;
  lineColor=null;
  fillPaint=null;
}",0.987770864621326
61701,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  boolean singleLine=pairs.size() < 2;
  if (!singleLine) {
    writer.newLine();
    writer.indent();
  }
  writer.append(""String_Node_Str"");
  if (!singleLine) {
    writer.newLine();
    writer.indent();
  }
  for (int n=0; n < pairs.size(); n++) {
    if (n > 0) {
      writer.append(""String_Node_Str"").newLine();
    }
    pairs.get(n).toString(writer,localData);
  }
  if (!singleLine) {
    writer.newLine();
    writer.unindent();
  }
  writer.append(""String_Node_Str"");
  if (!singleLine) {
    writer.unindent();
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  boolean singleLine=pairs.size() < 2;
  writer.append(""String_Node_Str"");
  if (!singleLine) {
    writer.newLine();
    writer.indent();
  }
  for (int n=0; n < pairs.size(); n++) {
    if (n > 0) {
      writer.append(""String_Node_Str"").newLine();
    }
    pairs.get(n).toString(writer,localData);
  }
  if (!singleLine) {
    writer.newLine();
    writer.unindent();
  }
  writer.append(""String_Node_Str"");
  return writer;
}",0.8807947019867549
61702,"@Override public BufferedImage next(){
  if (!hasNext()) {
    return null;
  }
  return frameToImageGet(ftim,fframes.get(pos),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
}","@Override public BufferedImage next(){
  if (!hasNext()) {
    return null;
  }
  return frameToImageGet(ftim,fframes.get(pos++),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
}",0.9957081545064378
61703,"public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,int containerId,List<Integer> frames,final FramesExportSettings settings) throws IOException {
  final List<File> ret=new ArrayList<>();
  if (tags.isEmpty()) {
    return ret;
  }
  Timeline tim=null;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim=getTimeline();
  }
 else {
    tim=((Timelined)characters.get(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(characters.get(containerId).getExportFileName());
  }
  if (frames == null) {
    int frameCnt=tim.frames.size();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  if (!foutdir.exists()) {
    if (!foutdir.mkdirs()) {
      if (!foutdir.exists()) {
        throw new IOException(""String_Node_Str"" + outdir);
      }
    }
  }
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  if (settings.mode == FramesExportMode.AVI) {
    for (    Tag t : tags) {
      if (t instanceof SetBackgroundColorTag) {
        SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
        backgroundColor=sb.backgroundColor.toColor();
      }
    }
  }
  if (settings.mode == FramesExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      final int fi=i;
      final Timeline ftim=tim;
      final Color fbackgroundColor=backgroundColor;
      new RetryTask(new RunnableIOEx(){
        @Override public void run() throws IOException {
          int frame=fframes.get(fi);
          File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
          try (FileOutputStream fos=new FileOutputStream(f)){
            SVGExporter exporter=new SVGExporter(new ExportRectangle(ftim.displayRect));
            if (fbackgroundColor != null) {
              exporter.setBackGroundColor(fbackgroundColor);
            }
            frameToSvg(ftim,frame,0,null,0,exporter,new ColorTransform(),0);
            fos.write(Utf8Helper.getBytes(exporter.getSVG()));
          }
           ret.add(f);
        }
      }
,handler).run();
    }
    return ret;
  }
  if (settings.mode == FramesExportMode.CANVAS) {
    final Timeline ftim=tim;
    final Color fbackgroundColor=backgroundColor;
    final SWF fswf=this;
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
        Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
        ret.add(fcanvas);
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
        int width=(int)(ftim.displayRect.getWidth() / SWF.unitDivisor);
        int height=(int)(ftim.displayRect.getHeight() / SWF.unitDivisor);
        try (FileOutputStream fos=new FileOutputStream(f)){
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          Set<Integer> library=new HashSet<>();
          ftim.getNeededCharacters(fframes,library);
          writeLibrary(fswf,library,fos);
          String currentName=ftim.id == 0 ? ""String_Node_Str"" : getTypePrefix(fswf.characters.get(ftim.id)) + ftim.id;
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (-ftim.displayRect.Xmin / unitDivisor) + ""String_Node_Str""+ (-ftim.displayRect.Ymin / unitDivisor)+ ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(framesToHtmlCanvas(unitDivisor,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor)));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          for (          int i : fframes) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str"" + i + ""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          RGB backgroundColor=new RGB(255,255,255);
          for (          Tag t : fswf.tags) {
            if (t instanceof SetBackgroundColorTag) {
              SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
              backgroundColor=sb.backgroundColor;
            }
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + backgroundColor.toHexRGB() + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + width + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + height + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (int)(1000.0 / ftim.swf.frameRate) + ""String_Node_Str""));
        }
         if (Configuration.packJavaScripts.get()) {
          try {
            JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
            f.delete();
          }
 catch (          Exception|Error e) {
            Logger.getLogger(SWF.class.getName()).log(Level.WARNING,""String_Node_Str"");
            f.renameTo(fmin);
          }
        }
 else {
          f.renameTo(fmin);
        }
        File fh=new File(foutdir + File.separator + ""String_Node_Str"");
        try (FileOutputStream fos=new FileOutputStream(fh);FileInputStream fis=new FileInputStream(fmin)){
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
          byte buf[]=new byte[1000];
          int cnt;
          while ((cnt=fis.read(buf)) > 0) {
            fos.write(buf,0,cnt);
          }
          if (Configuration.packJavaScripts.get()) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
        }
         fmin.delete();
        ret.add(f);
      }
    }
,handler).run();
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private final int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      return frameToImageGet(ftim,fframes.get(pos),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        makeGIF(frameImages,frameRate,f);
        ret.add(f);
      }
    }
,handler).run();
  break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(new RunnableIOEx(){
    @Override public void run() throws IOException {
      File f=new File(foutdir + File.separator + fframes.get(fi)+ ""String_Node_Str"");
      ImageIO.write(frameImages.next(),""String_Node_Str"",f);
      ret.add(f);
    }
  }
,handler).run();
}
break;
case PDF:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new FileOutputStream(f));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
  BufferedImage img=frameImages.next();
  Graphics g=job.getGraphics(pf);
  g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
  g.dispose();
}
job.end();
ret.add(f);
}
}
,handler).run();
break;
case AVI:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,frameRate,f);
ret.add(f);
}
}
,handler).run();
break;
}
return ret;
}","public List<File> exportFrames(AbortRetryIgnoreHandler handler,String outdir,int containerId,List<Integer> frames,final FramesExportSettings settings) throws IOException {
  final List<File> ret=new ArrayList<>();
  if (tags.isEmpty()) {
    return ret;
  }
  Timeline tim=null;
  String path=""String_Node_Str"";
  if (containerId == 0) {
    tim=getTimeline();
  }
 else {
    tim=((Timelined)characters.get(containerId)).getTimeline();
    path=File.separator + Helper.makeFileName(characters.get(containerId).getExportFileName());
  }
  if (frames == null) {
    int frameCnt=tim.frames.size();
    frames=new ArrayList<>();
    for (int i=0; i < frameCnt; i++) {
      frames.add(i);
    }
  }
  final File foutdir=new File(outdir + path);
  if (!foutdir.exists()) {
    if (!foutdir.mkdirs()) {
      if (!foutdir.exists()) {
        throw new IOException(""String_Node_Str"" + outdir);
      }
    }
  }
  final List<Integer> fframes=frames;
  Color backgroundColor=null;
  if (settings.mode == FramesExportMode.AVI) {
    for (    Tag t : tags) {
      if (t instanceof SetBackgroundColorTag) {
        SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
        backgroundColor=sb.backgroundColor.toColor();
      }
    }
  }
  if (settings.mode == FramesExportMode.SVG) {
    for (int i=0; i < frames.size(); i++) {
      final int fi=i;
      final Timeline ftim=tim;
      final Color fbackgroundColor=backgroundColor;
      new RetryTask(new RunnableIOEx(){
        @Override public void run() throws IOException {
          int frame=fframes.get(fi);
          File f=new File(foutdir + File.separator + frame+ ""String_Node_Str"");
          try (FileOutputStream fos=new FileOutputStream(f)){
            SVGExporter exporter=new SVGExporter(new ExportRectangle(ftim.displayRect));
            if (fbackgroundColor != null) {
              exporter.setBackGroundColor(fbackgroundColor);
            }
            frameToSvg(ftim,frame,0,null,0,exporter,new ColorTransform(),0);
            fos.write(Utf8Helper.getBytes(exporter.getSVG()));
          }
           ret.add(f);
        }
      }
,handler).run();
    }
    return ret;
  }
  if (settings.mode == FramesExportMode.CANVAS) {
    final Timeline ftim=tim;
    final Color fbackgroundColor=backgroundColor;
    final SWF fswf=this;
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File fcanvas=new File(foutdir + File.separator + ""String_Node_Str"");
        Helper.saveStream(SWF.class.getClassLoader().getResourceAsStream(""String_Node_Str""),fcanvas);
        ret.add(fcanvas);
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        File fmin=new File(foutdir + File.separator + ""String_Node_Str"");
        int width=(int)(ftim.displayRect.getWidth() / SWF.unitDivisor);
        int height=(int)(ftim.displayRect.getHeight() / SWF.unitDivisor);
        try (FileOutputStream fos=new FileOutputStream(f)){
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          Set<Integer> library=new HashSet<>();
          ftim.getNeededCharacters(fframes,library);
          writeLibrary(fswf,library,fos);
          String currentName=ftim.id == 0 ? ""String_Node_Str"" : getTypePrefix(fswf.characters.get(ftim.id)) + ftim.id;
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (-ftim.displayRect.Xmin / unitDivisor) + ""String_Node_Str""+ (-ftim.displayRect.Ymin / unitDivisor)+ ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(framesToHtmlCanvas(unitDivisor,ftim,fframes,0,null,0,ftim.displayRect,new ColorTransform(),fbackgroundColor)));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          for (          int i : fframes) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str"" + i + ""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          RGB backgroundColor=new RGB(255,255,255);
          for (          Tag t : fswf.tags) {
            if (t instanceof SetBackgroundColorTag) {
              SetBackgroundColorTag sb=(SetBackgroundColorTag)t;
              backgroundColor=sb.backgroundColor;
            }
          }
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + backgroundColor.toHexRGB() + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + width + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + height + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + currentName + ""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          fos.write(Utf8Helper.getBytes(""String_Node_Str"" + (int)(1000.0 / ftim.swf.frameRate) + ""String_Node_Str""));
        }
         if (Configuration.packJavaScripts.get()) {
          try {
            JPacker.main(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",fmin.getAbsolutePath(),f.getAbsolutePath()});
            f.delete();
          }
 catch (          Exception|Error e) {
            Logger.getLogger(SWF.class.getName()).log(Level.WARNING,""String_Node_Str"");
            f.renameTo(fmin);
          }
        }
 else {
          f.renameTo(fmin);
        }
        File fh=new File(foutdir + File.separator + ""String_Node_Str"");
        try (FileOutputStream fos=new FileOutputStream(fh);FileInputStream fis=new FileInputStream(fmin)){
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlPrefix(width,height)));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsPrefix()));
          byte buf[]=new byte[1000];
          int cnt;
          while ((cnt=fis.read(buf)) > 0) {
            fos.write(buf,0,cnt);
          }
          if (Configuration.packJavaScripts.get()) {
            fos.write(Utf8Helper.getBytes(""String_Node_Str""));
          }
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getJsSuffix()));
          fos.write(Utf8Helper.getBytes(CanvasShapeExporter.getHtmlSuffix()));
        }
         fmin.delete();
        ret.add(f);
      }
    }
,handler).run();
    return ret;
  }
  final Timeline ftim=tim;
  final Color fbackgroundColor=backgroundColor;
  final Iterator<BufferedImage> frameImages=new Iterator<BufferedImage>(){
    private int pos=0;
    @Override public boolean hasNext(){
      return fframes.size() > pos;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public BufferedImage next(){
      if (!hasNext()) {
        return null;
      }
      return frameToImageGet(ftim,fframes.get(pos++),0,null,0,ftim.displayRect,new Matrix(),new ColorTransform(),fbackgroundColor,false).getBufferedImage();
    }
  }
;
switch (settings.mode) {
case GIF:
    new RetryTask(new RunnableIOEx(){
      @Override public void run() throws IOException {
        File f=new File(foutdir + File.separator + ""String_Node_Str"");
        makeGIF(frameImages,frameRate,f);
        ret.add(f);
      }
    }
,handler).run();
  break;
case PNG:
for (int i=0; frameImages.hasNext(); i++) {
  final int fi=i;
  new RetryTask(new RunnableIOEx(){
    @Override public void run() throws IOException {
      File f=new File(foutdir + File.separator + (fframes.get(fi) + 1)+ ""String_Node_Str"");
      ImageIO.write(frameImages.next(),""String_Node_Str"",f);
      ret.add(f);
    }
  }
,handler).run();
}
break;
case PDF:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
PDFJob job=new PDFJob(new FileOutputStream(f));
PageFormat pf=new PageFormat();
pf.setOrientation(PageFormat.PORTRAIT);
Paper p=new Paper();
BufferedImage img0=frameImages.next();
p.setSize(img0.getWidth() + 10,img0.getHeight() + 10);
pf.setPaper(p);
for (int i=0; frameImages.hasNext(); i++) {
  BufferedImage img=frameImages.next();
  Graphics g=job.getGraphics(pf);
  g.drawImage(img,5,5,img.getWidth(),img.getHeight(),null);
  g.dispose();
}
job.end();
ret.add(f);
}
}
,handler).run();
break;
case AVI:
new RetryTask(new RunnableIOEx(){
@Override public void run() throws IOException {
File f=new File(foutdir + File.separator + ""String_Node_Str"");
makeAVI(frameImages,frameRate,f);
ret.add(f);
}
}
,handler).run();
break;
}
return ret;
}",0.9977685686962066
61704,"public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts) throws ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(ii);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo instanceInfo=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(instanceInfo);
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof MethodAVM2Item) ? Trait.TRAIT_METHOD : ((item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : Trait.TRAIT_SETTER);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
    }
 else     if (item instanceof FunctionAVM2Item) {
      TraitFunction tf=new TraitFunction();
      tf.slot_id=slot_id++;
      tf.kindType=Trait.TRAIT_FUNCTION;
      ts.traits.add(tf);
      traits[k]=tf;
    }
  }
  return traits;
}","public Trait[] generateTraitsPhase1(String className,String superName,boolean generateStatic,SourceGeneratorLocalData localData,List<GraphTargetItem> items,Traits ts) throws ParseException, CompilationException {
  Trait[] traits=new Trait[items.size()];
  int slot_id=1;
  int disp_id=3;
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (item instanceof InterfaceAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo ii=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(ii);
      ii.flags|=InstanceInfo.CLASS_INTERFACE;
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=0;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if (item instanceof ClassAVM2Item) {
      TraitClass tc=new TraitClass();
      ClassInfo ci=new ClassInfo();
      InstanceInfo instanceInfo=new InstanceInfo();
      abc.class_info.add(ci);
      abc.instance_info.add(instanceInfo);
      tc.class_info=abc.instance_info.size() - 1;
      tc.kindType=Trait.TRAIT_CLASS;
      tc.slot_id=slot_id++;
      ts.traits.add(tc);
      traits[k]=tc;
    }
    if ((item instanceof SlotAVM2Item) || (item instanceof ConstAVM2Item)) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.kindType=(item instanceof SlotAVM2Item) ? Trait.TRAIT_SLOT : Trait.TRAIT_CONST;
      String var=null;
      GraphTargetItem val=null;
      GraphTargetItem type=null;
      boolean isNamespace=false;
      int namespace=0;
      boolean isStatic=false;
      if (item instanceof SlotAVM2Item) {
        SlotAVM2Item sai=(SlotAVM2Item)item;
        if (sai.isStatic() != generateStatic) {
          continue;
        }
        var=sai.var;
        val=sai.value;
        type=sai.type;
        isStatic=sai.isStatic();
        namespace=sai.getNamespace();
      }
      if (item instanceof ConstAVM2Item) {
        ConstAVM2Item cai=(ConstAVM2Item)item;
        if (cai.isStatic() != generateStatic) {
          continue;
        }
        var=cai.var;
        val=cai.value;
        type=cai.type;
        namespace=cai.getNamespace();
        isNamespace=type.toString().equals(""String_Node_Str"");
        isStatic=cai.isStatic();
      }
      if (isNamespace) {
        tsc.name_index=traitName(namespace,var);
      }
      tsc.type_index=isNamespace ? 0 : (type == null ? 0 : typeName(localData,type));
      ValueKind vk=getValueKind(namespace,type,val);
      if (vk == null) {
        tsc.value_kind=ValueKind.CONSTANT_Undefined;
      }
 else {
        tsc.value_kind=vk.value_kind;
        tsc.value_index=vk.value_index;
      }
      tsc.slot_id=isStatic ? slot_id++ : 0;
      ts.traits.add(tsc);
      traits[k]=tsc;
    }
    if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      MethodAVM2Item mai=(MethodAVM2Item)item;
      if (mai.isStatic() != generateStatic) {
        continue;
      }
      TraitMethodGetterSetter tmgs=new TraitMethodGetterSetter();
      tmgs.kindType=(item instanceof GetterAVM2Item) ? Trait.TRAIT_GETTER : ((item instanceof SetterAVM2Item) ? Trait.TRAIT_SETTER : Trait.TRAIT_METHOD);
      tmgs.disp_id=mai.isStatic() ? disp_id++ : 0;
      if (mai.isFinal() || mai.isStatic()) {
        tmgs.kindFlags|=Trait.ATTR_Final;
      }
      if (mai.isOverride()) {
        tmgs.kindFlags|=Trait.ATTR_Override;
      }
      ts.traits.add(tmgs);
      traits[k]=tmgs;
    }
 else     if (item instanceof FunctionAVM2Item) {
      TraitFunction tf=new TraitFunction();
      tf.slot_id=slot_id++;
      tf.kindType=Trait.TRAIT_FUNCTION;
      ts.traits.add(tf);
      traits[k]=tf;
    }
  }
  return traits;
}",0.9957333333333334
61705,"@Override public void translate(boolean isStatic,int scriptIndex,int classIndex,java.util.HashMap<Integer,GraphTargetItem> localRegs,Stack<GraphTargetItem> stack,java.util.Stack<GraphTargetItem> scopeStack,ConstantPool constants,AVM2Instruction ins,List<MethodInfo> method_info,List<GraphTargetItem> output,MethodBody body,ABC abc,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,String path,HashMap<Integer,Integer> localRegsAssignmentIps,int ip,HashMap<Integer,List<Integer>> refs,AVM2Code code){
  if (stack.size() > 0) {
    GraphTargetItem top=stack.pop();
    if (top instanceof CallPropertyAVM2Item) {
      output.add(top);
    }
 else     if (top instanceof CallSuperAVM2Item) {
      output.add(top);
    }
 else     if (top instanceof CallStaticAVM2Item) {
      output.add(top);
    }
 else     if (top instanceof CallMethodAVM2Item) {
      output.add(top);
    }
 else     if (top instanceof CallAVM2Item) {
      output.add(top);
    }
 else     if (top instanceof AssignmentAVM2Item) {
      output.add(top);
    }
  }
}","@Override public void translate(boolean isStatic,int scriptIndex,int classIndex,java.util.HashMap<Integer,GraphTargetItem> localRegs,Stack<GraphTargetItem> stack,java.util.Stack<GraphTargetItem> scopeStack,ConstantPool constants,AVM2Instruction ins,List<MethodInfo> method_info,List<GraphTargetItem> output,MethodBody body,ABC abc,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,String path,HashMap<Integer,Integer> localRegsAssignmentIps,int ip,HashMap<Integer,List<Integer>> refs,AVM2Code code){
  if (stack.size() > 0) {
    GraphTargetItem top=stack.pop();
    if (!(top instanceof IntegerValueAVM2Item)) {
      output.add(top);
    }
  }
}",0.7392815758980301
61706,"protected void finalizePath(){
  if (path != null) {
    if (fillPaint != null) {
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.setComposite(AlphaComposite.SrcOver);
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);
  lineStroke=null;
  lineColor=null;
  fillPaint=null;
}","protected void finalizePath(){
  if (path != null) {
    if (fillPaint != null) {
      graphics.setComposite(AlphaComposite.SrcOver);
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        Matrix inverse=null;
        try {
          inverse=new Matrix(new AffineTransform(fillTransform).createInverse());
        }
 catch (        NoninvertibleTransformException ex) {
        }
        fillTransform.preConcatenate(oldAf);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        if (inverse != null) {
          ExportRectangle rect=inverse.transform(new ExportRectangle(path.getBounds2D()));
          double minX=rect.xMin;
          double minY=rect.yMin;
          graphics.fill(new java.awt.Rectangle((int)minX,(int)minY,(int)(rect.xMax - minX),(int)(rect.yMax - minY)));
        }
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);
  lineStroke=null;
  lineColor=null;
  fillPaint=null;
}",0.9766652524395418
61707,"private static BufferedImage dropShadow(BufferedImage src,int blurX,int blurY,float angle,double distance,Color color,boolean inner,int iterations,float strength,boolean knockout){
  int width=src.getWidth();
  int height=src.getHeight();
  int[] srcPixels=getRGB(src,0,0,width,height);
  int shadow[]=new int[srcPixels.length];
  for (int i=0; i < srcPixels.length; i++) {
    int alpha=(srcPixels[i] >> 24) & 0xff;
    if (inner) {
      alpha=255 - alpha;
    }
    shadow[i]=new Color(color.getRed(),color.getGreen(),color.getBlue(),cut(color.getAlpha() * alpha * strength)).getRGB();
  }
  Color colorFirst=Color.BLACK;
  Color colorAlpha=new Color(0,0,0,0);
  double angleRad=angle / 180 * Math.PI;
  double moveX=(distance * Math.cos(angleRad));
  double moveY=(distance * Math.sin(angleRad));
  shadow=moveRGB(width,height,shadow,moveX,moveY,inner ? colorFirst : colorAlpha);
  BufferedImage retCanvas=new BufferedImage(width,height,src.getType());
  setRGB(retCanvas,0,0,width,height,shadow);
  if (blurX > 0 || blurY > 0) {
    retCanvas=blur(retCanvas,blurX,blurY,iterations,null);
  }
  shadow=getRGB(retCanvas,0,0,width,height);
  for (int i=0; i < shadow.length; i++) {
    int mask=(srcPixels[i] >> 24) & 0xff;
    if (!inner) {
      mask=255 - mask;
    }
    shadow[i]=shadow[i] & 0xffffff + ((mask * ((shadow[i] >> 24) & 0xff) / 255) << 24);
  }
  setRGB(retCanvas,0,0,width,height,shadow);
  if (!knockout) {
    Graphics2D g=retCanvas.createGraphics();
    g.setComposite(AlphaComposite.DstOver);
    g.drawImage(src,0,0,null);
  }
  return retCanvas;
}","private static BufferedImage dropShadow(BufferedImage src,int blurX,int blurY,float angle,double distance,Color color,boolean inner,int iterations,float strength,boolean knockout){
  int width=src.getWidth();
  int height=src.getHeight();
  int[] srcPixels=getRGB(src,0,0,width,height);
  int shadow[]=new int[srcPixels.length];
  for (int i=0; i < srcPixels.length; i++) {
    int alpha=(srcPixels[i] >> 24) & 0xff;
    if (inner) {
      alpha=255 - alpha;
    }
    shadow[i]=new Color(color.getRed(),color.getGreen(),color.getBlue(),cut(color.getAlpha() * alpha / 255 * strength)).getRGB();
  }
  Color colorFirst=Color.BLACK;
  Color colorAlpha=new Color(0,0,0,0);
  double angleRad=angle / 180 * Math.PI;
  double moveX=(distance * Math.cos(angleRad));
  double moveY=(distance * Math.sin(angleRad));
  shadow=moveRGB(width,height,shadow,moveX,moveY,inner ? colorFirst : colorAlpha);
  BufferedImage retCanvas=new BufferedImage(width,height,src.getType());
  setRGB(retCanvas,0,0,width,height,shadow);
  if (blurX > 0 || blurY > 0) {
    retCanvas=blur(retCanvas,blurX,blurY,iterations,null);
  }
  shadow=getRGB(retCanvas,0,0,width,height);
  for (int i=0; i < shadow.length; i++) {
    int mask=(srcPixels[i] >> 24) & 0xff;
    if (!inner) {
      mask=255 - mask;
    }
    shadow[i]=shadow[i] & 0xffffff + ((mask * ((shadow[i] >> 24) & 0xff) / 255) << 24);
  }
  setRGB(retCanvas,0,0,width,height,shadow);
  if (!knockout) {
    Graphics2D g=retCanvas.createGraphics();
    g.setComposite(AlphaComposite.DstOver);
    g.drawImage(src,0,0,null);
  }
  return retCanvas;
}",0.9980976537729866
61708,"public AppDialog(){
  View.installEscapeCloseOperation(this);
  if (Configuration.useRibbonInterface.get()) {
    getRootPane().setWindowDecorationStyle(JRootPane.FRAME);
  }
}","public AppDialog(Window owner){
  super(owner);
  View.installEscapeCloseOperation(this);
  if (Configuration.useRibbonInterface.get()) {
    getRootPane().setWindowDecorationStyle(JRootPane.FRAME);
  }
}",0.9263157894736842
61709,"public void searchAs(){
  if (searchDialog == null) {
    searchDialog=new SearchDialog();
  }
  searchDialog.setVisible(true);
  if (searchDialog.result) {
    final String txt=searchDialog.searchField.getText();
    if (!txt.isEmpty()) {
      final SWF swf=getCurrentSwf();
      new CancellableWorker(){
        @Override protected Void doInBackground() throws Exception {
          boolean found=false;
          if (searchDialog.searchInASRadioButton.isSelected()) {
            if (swf.isAS3) {
              if (abcPanel != null && abcPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
                found=true;
                View.execInEventDispatch(new Runnable(){
                  @Override public void run(){
                    showDetail(DETAILCARDAS3NAVIGATOR);
                    showCard(CARDACTIONSCRIPT3PANEL);
                  }
                }
);
              }
            }
 else {
              if (actionPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
                found=true;
                View.execInEventDispatch(new Runnable(){
                  @Override public void run(){
                    showCard(CARDACTIONSCRIPTPANEL);
                  }
                }
);
              }
            }
          }
 else           if (searchDialog.searchInTextsRadioButton.isSelected()) {
            if (searchText(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected(),swf)) {
              found=true;
            }
          }
          if (!found) {
            View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
          }
          return null;
        }
      }
.execute();
    }
  }
}","public void searchAs(){
  if (searchDialog == null) {
    searchDialog=new SearchDialog(getMainFrame().getWindow());
  }
  searchDialog.setVisible(true);
  if (searchDialog.result) {
    final String txt=searchDialog.searchField.getText();
    if (!txt.isEmpty()) {
      final SWF swf=getCurrentSwf();
      new CancellableWorker(){
        @Override protected Void doInBackground() throws Exception {
          boolean found=false;
          if (searchDialog.searchInASRadioButton.isSelected()) {
            if (swf.isAS3) {
              if (abcPanel != null && abcPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
                found=true;
                View.execInEventDispatch(new Runnable(){
                  @Override public void run(){
                    showDetail(DETAILCARDAS3NAVIGATOR);
                    showCard(CARDACTIONSCRIPT3PANEL);
                  }
                }
);
              }
            }
 else {
              if (actionPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
                found=true;
                View.execInEventDispatch(new Runnable(){
                  @Override public void run(){
                    showCard(CARDACTIONSCRIPTPANEL);
                  }
                }
);
              }
            }
          }
 else           if (searchDialog.searchInTextsRadioButton.isSelected()) {
            if (searchText(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected(),swf)) {
              found=true;
            }
          }
          if (!found) {
            View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
          }
          return null;
        }
      }
.execute();
    }
  }
}",0.9931470743278862
61710,"public SearchDialog(){
  setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
  Container cnt=getContentPane();
  setSize(400,150);
  cnt.setLayout(new BoxLayout(cnt,BoxLayout.PAGE_AXIS));
  JPanel panButtons=new JPanel(new FlowLayout());
  JButton okButton=new JButton(translate(""String_Node_Str""));
  okButton.setActionCommand(ACTION_OK);
  okButton.addActionListener(this);
  JButton cancelButton=new JButton(translate(""String_Node_Str""));
  cancelButton.setActionCommand(ACTION_CANCEL);
  cancelButton.addActionListener(this);
  panButtons.add(okButton);
  panButtons.add(cancelButton);
  JPanel panField=new JPanel(new FlowLayout());
  searchField.setPreferredSize(new Dimension(250,searchField.getPreferredSize().height));
  panField.add(new JLabel(translate(""String_Node_Str"")));
  panField.add(searchField);
  cnt.add(panField);
  JPanel checkPanel=new JPanel(new FlowLayout());
  checkPanel.add(ignoreCaseCheckBox);
  checkPanel.add(regexpCheckBox);
  cnt.add(checkPanel);
  ButtonGroup group=new ButtonGroup();
  group.add(searchInASRadioButton);
  group.add(searchInTextsRadioButton);
  JPanel rbPanel=new JPanel(new FlowLayout());
  searchInASRadioButton.setSelected(true);
  searchInTextsRadioButton.setSelected(false);
  rbPanel.add(searchInASRadioButton);
  rbPanel.add(searchInTextsRadioButton);
  cnt.add(rbPanel);
  cnt.add(panButtons);
  getRootPane().setDefaultButton(okButton);
  View.centerScreen(this);
  setIconImage(View.loadImage(""String_Node_Str""));
  setTitle(translate(""String_Node_Str""));
  setModalityType(ModalityType.APPLICATION_MODAL);
  pack();
  java.util.List<Image> images=new ArrayList<>();
  images.add(View.loadImage(""String_Node_Str""));
  images.add(View.loadImage(""String_Node_Str""));
  setIconImages(images);
}","public SearchDialog(Window owner){
  super(owner);
  setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
  Container cnt=getContentPane();
  setSize(400,150);
  cnt.setLayout(new BoxLayout(cnt,BoxLayout.PAGE_AXIS));
  JPanel panButtons=new JPanel(new FlowLayout());
  JButton okButton=new JButton(translate(""String_Node_Str""));
  okButton.setActionCommand(ACTION_OK);
  okButton.addActionListener(this);
  JButton cancelButton=new JButton(translate(""String_Node_Str""));
  cancelButton.setActionCommand(ACTION_CANCEL);
  cancelButton.addActionListener(this);
  panButtons.add(okButton);
  panButtons.add(cancelButton);
  JPanel panField=new JPanel(new FlowLayout());
  searchField.setPreferredSize(new Dimension(250,searchField.getPreferredSize().height));
  panField.add(new JLabel(translate(""String_Node_Str"")));
  panField.add(searchField);
  cnt.add(panField);
  JPanel checkPanel=new JPanel(new FlowLayout());
  checkPanel.add(ignoreCaseCheckBox);
  checkPanel.add(regexpCheckBox);
  cnt.add(checkPanel);
  ButtonGroup group=new ButtonGroup();
  group.add(searchInASRadioButton);
  group.add(searchInTextsRadioButton);
  JPanel rbPanel=new JPanel(new FlowLayout());
  searchInASRadioButton.setSelected(true);
  searchInTextsRadioButton.setSelected(false);
  rbPanel.add(searchInASRadioButton);
  rbPanel.add(searchInTextsRadioButton);
  cnt.add(rbPanel);
  cnt.add(panButtons);
  getRootPane().setDefaultButton(okButton);
  View.centerScreen(this);
  setIconImage(View.loadImage(""String_Node_Str""));
  setTitle(translate(""String_Node_Str""));
  setModalityType(ModalityType.APPLICATION_MODAL);
  pack();
  java.util.List<Image> images=new ArrayList<>();
  images.add(View.loadImage(""String_Node_Str""));
  images.add(View.loadImage(""String_Node_Str""));
  setIconImages(images);
}",0.992063492063492
61711,"public SearchResultsDialog(String text,SearchListener<E> listener){
  setTitle(translate(""String_Node_Str"").replace(""String_Node_Str"",text));
  Container cnt=getContentPane();
  model=new DefaultListModel<>();
  resultsList=new JList<>(model);
  this.listener=listener;
  gotoButton.setActionCommand(ACTION_GOTO);
  gotoButton.addActionListener(this);
  closeButton.setActionCommand(ACTION_CANCEL);
  closeButton.addActionListener(this);
  JPanel buttonsPanel=new JPanel();
  buttonsPanel.setLayout(new FlowLayout());
  buttonsPanel.add(gotoButton);
  buttonsPanel.add(closeButton);
  resultsList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        gotoElement();
      }
    }
  }
);
  cnt.setLayout(new BorderLayout());
  JScrollPane sp=new JScrollPane(resultsList);
  sp.setPreferredSize(new Dimension(300,300));
  cnt.add(sp,BorderLayout.CENTER);
  cnt.add(buttonsPanel,BorderLayout.SOUTH);
  pack();
  setAlwaysOnTop(true);
  View.centerScreen(this);
  View.setWindowIcon(this);
}","public SearchResultsDialog(Window owner,String text,SearchListener<E> listener){
  super(owner);
  setTitle(translate(""String_Node_Str"").replace(""String_Node_Str"",text));
  Container cnt=getContentPane();
  model=new DefaultListModel<>();
  resultsList=new JList<>(model);
  this.listener=listener;
  gotoButton.setActionCommand(ACTION_GOTO);
  gotoButton.addActionListener(this);
  closeButton.setActionCommand(ACTION_CANCEL);
  closeButton.addActionListener(this);
  JPanel buttonsPanel=new JPanel();
  buttonsPanel.setLayout(new FlowLayout());
  buttonsPanel.add(gotoButton);
  buttonsPanel.add(closeButton);
  resultsList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        gotoElement();
      }
    }
  }
);
  cnt.setLayout(new BorderLayout());
  JScrollPane sp=new JScrollPane(resultsList);
  sp.setPreferredSize(new Dimension(300,300));
  cnt.add(sp,BorderLayout.CENTER);
  cnt.add(buttonsPanel,BorderLayout.SOUTH);
  pack();
  View.centerScreen(this);
  View.setWindowIcon(this);
}",0.9753373662168452
61712,"public boolean search(final String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchPanel.setOptions(ignoreCase,regexp);
    TagTreeModel ttm=(TagTreeModel)mainPanel.tagTree.getModel();
    TreeNode scriptsNode=ttm.getSwfNode(mainPanel.getCurrentSwf()).scriptsNode;
    final List<ABCPanelSearchResult> found=new ArrayList<>();
    if (scriptsNode.getItem() instanceof ClassesListTreeModel) {
      ClassesListTreeModel clModel=(ClassesListTreeModel)scriptsNode.getItem();
      List<MyEntry<ClassPath,ScriptPack>> allpacks=clModel.getList();
      final Pattern pat=regexp ? Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0) : Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
      int pos=0;
      for (      final MyEntry<ClassPath,ScriptPack> item : allpacks) {
        pos++;
        String workText=AppStrings.translate(""String_Node_Str"");
        String decAdd=""String_Node_Str"";
        if (!decompiledTextArea.isCached(item.value)) {
          decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
        }
        try {
          CancellableWorker worker=new CancellableWorker(){
            @Override public Void doInBackground() throws Exception {
              decompiledTextArea.cacheScriptPack(item.value,swf.abcList);
              if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
                ABCPanelSearchResult searchResult=new ABCPanelSearchResult();
                searchResult.scriptPack=item.value;
                searchResult.classPath=item.key;
                found.add(searchResult);
              }
              return null;
            }
          }
;
          worker.execute();
          Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ allpacks.size()+ ""String_Node_Str""+ item.key.toString()+ ""String_Node_Str"",worker);
          worker.get();
        }
 catch (        InterruptedException ex) {
          break;
        }
catch (        ExecutionException ex) {
          Logger.getLogger(ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
    }
    System.gc();
    Main.stopWork();
    searchPanel.setSearchText(txt);
    final ABCPanel that=this;
    View.execInEventDispatch(new Runnable(){
      @Override public void run(){
        SearchResultsDialog<ABCPanelSearchResult> sr=new SearchResultsDialog<ABCPanelSearchResult>(txt,that);
        sr.setResults(found);
        sr.setVisible(true);
      }
    }
);
    return true;
  }
  return false;
}","public boolean search(final String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchPanel.setOptions(ignoreCase,regexp);
    TagTreeModel ttm=(TagTreeModel)mainPanel.tagTree.getModel();
    TreeNode scriptsNode=ttm.getSwfNode(mainPanel.getCurrentSwf()).scriptsNode;
    final List<ABCPanelSearchResult> found=new ArrayList<>();
    if (scriptsNode.getItem() instanceof ClassesListTreeModel) {
      ClassesListTreeModel clModel=(ClassesListTreeModel)scriptsNode.getItem();
      List<MyEntry<ClassPath,ScriptPack>> allpacks=clModel.getList();
      final Pattern pat=regexp ? Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0) : Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
      int pos=0;
      for (      final MyEntry<ClassPath,ScriptPack> item : allpacks) {
        pos++;
        String workText=AppStrings.translate(""String_Node_Str"");
        String decAdd=""String_Node_Str"";
        if (!decompiledTextArea.isCached(item.value)) {
          decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
        }
        try {
          CancellableWorker worker=new CancellableWorker(){
            @Override public Void doInBackground() throws Exception {
              decompiledTextArea.cacheScriptPack(item.value,swf.abcList);
              if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
                ABCPanelSearchResult searchResult=new ABCPanelSearchResult();
                searchResult.scriptPack=item.value;
                searchResult.classPath=item.key;
                found.add(searchResult);
              }
              return null;
            }
          }
;
          worker.execute();
          Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ allpacks.size()+ ""String_Node_Str""+ item.key.toString()+ ""String_Node_Str"",worker);
          worker.get();
        }
 catch (        InterruptedException ex) {
          break;
        }
catch (        ExecutionException ex) {
          Logger.getLogger(ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
    }
    System.gc();
    Main.stopWork();
    searchPanel.setSearchText(txt);
    View.execInEventDispatch(new Runnable(){
      @Override public void run(){
        SearchResultsDialog<ABCPanelSearchResult> sr=new SearchResultsDialog<>(ABCPanel.this.mainPanel.getMainFrame().getWindow(),txt,ABCPanel.this);
        sr.setResults(found);
        sr.setVisible(true);
      }
    }
);
    return true;
  }
  return false;
}",0.9721054642720672
61713,"public UsageFrame(List<ABCContainerTag> abcTags,ABC abc,int multinameIndex,ABCPanel abcPanel,boolean definitions){
  this.abcPanel=abcPanel;
  List<MultinameUsage> usages=definitions ? abc.findMultinameDefinition(abcTags,multinameIndex) : abc.findMultinameUsage(abcTags,multinameIndex);
  Multiname m=abc.constants.constant_multiname.get(multinameIndex);
  if (m.namespace_index > 0 && abc.constants.constant_namespace.get(m.namespace_index).kind != Namespace.KIND_PRIVATE) {
    for (    ABCContainerTag at : abcTags) {
      ABC a=at.getABC();
      if (a == abc) {
        continue;
      }
      int mid=a.constants.getMultinameId(m,false);
      if (mid > 0) {
        usages.addAll(definitions ? a.findMultinameDefinition(abcTags,mid) : a.findMultinameUsage(abcTags,mid));
      }
    }
  }
  usageListModel=new UsageListModel();
  for (  MultinameUsage u : usages) {
    usageListModel.addElement(u);
  }
  usageList=new JList<>(usageListModel);
  usageList.setBackground(Color.white);
  gotoButton.setActionCommand(ACTION_GOTO);
  gotoButton.addActionListener(this);
  cancelButton.setActionCommand(ACTION_CANCEL);
  cancelButton.addActionListener(this);
  JPanel buttonsPanel=new JPanel();
  buttonsPanel.setLayout(new FlowLayout());
  buttonsPanel.add(gotoButton);
  buttonsPanel.add(cancelButton);
  usageList.addMouseListener(this);
  Container cont=getContentPane();
  cont.setLayout(new BorderLayout());
  cont.add(new JScrollPane(usageList),BorderLayout.CENTER);
  cont.add(buttonsPanel,BorderLayout.SOUTH);
  setSize(400,300);
  setTitle((definitions ? translate(""String_Node_Str"") : translate(""String_Node_Str"")) + abc.constants.getMultiname(multinameIndex).getNameWithNamespace(abc.constants));
  View.centerScreen(this);
  View.setWindowIcon(this);
}","public UsageFrame(List<ABCContainerTag> abcTags,ABC abc,int multinameIndex,ABCPanel abcPanel,boolean definitions){
  super(abcPanel.getMainPanel().getMainFrame().getWindow());
  this.abcPanel=abcPanel;
  List<MultinameUsage> usages=definitions ? abc.findMultinameDefinition(abcTags,multinameIndex) : abc.findMultinameUsage(abcTags,multinameIndex);
  Multiname m=abc.constants.constant_multiname.get(multinameIndex);
  if (m.namespace_index > 0 && abc.constants.constant_namespace.get(m.namespace_index).kind != Namespace.KIND_PRIVATE) {
    for (    ABCContainerTag at : abcTags) {
      ABC a=at.getABC();
      if (a == abc) {
        continue;
      }
      int mid=a.constants.getMultinameId(m,false);
      if (mid > 0) {
        usages.addAll(definitions ? a.findMultinameDefinition(abcTags,mid) : a.findMultinameUsage(abcTags,mid));
      }
    }
  }
  usageListModel=new UsageListModel();
  for (  MultinameUsage u : usages) {
    usageListModel.addElement(u);
  }
  usageList=new JList<>(usageListModel);
  usageList.setBackground(Color.white);
  gotoButton.setActionCommand(ACTION_GOTO);
  gotoButton.addActionListener(this);
  cancelButton.setActionCommand(ACTION_CANCEL);
  cancelButton.addActionListener(this);
  JPanel buttonsPanel=new JPanel();
  buttonsPanel.setLayout(new FlowLayout());
  buttonsPanel.add(gotoButton);
  buttonsPanel.add(cancelButton);
  usageList.addMouseListener(this);
  Container cont=getContentPane();
  cont.setLayout(new BorderLayout());
  cont.add(new JScrollPane(usageList),BorderLayout.CENTER);
  cont.add(buttonsPanel,BorderLayout.SOUTH);
  setSize(400,300);
  setTitle((definitions ? translate(""String_Node_Str"") : translate(""String_Node_Str"")) + abc.constants.getMultiname(multinameIndex).getNameWithNamespace(abc.constants));
  View.centerScreen(this);
  View.setWindowIcon(this);
}",0.9830508474576272
61714,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_GRAPH:
    if (lastCode != null) {
      try {
        GraphFrame gf=new GraphFrame(new ActionGraph(lastCode,new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),SWF.DEFAULT_VERSION),""String_Node_Str"");
        gf.setVisible(true);
      }
 catch (      InterruptedException ex) {
        Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  break;
case ACTION_EDIT_ACTION:
setEditMode(true);
break;
case ACTION_HEX:
case ACTION_HEX_ONLY:
if (e.getActionCommand() == ACTION_HEX) {
hexOnlyButton.setSelected(false);
}
 else {
hexButton.setSelected(false);
}
setHex(getExportMode());
break;
case ACTION_CANCEL_ACTION:
setEditMode(false);
setHex(getExportMode());
break;
case ACTION_SAVE_ACTION:
try {
String text=editor.getText();
if (text.trim().startsWith(""String_Node_Str"")) {
src.setActionBytes(Helper.getBytesFromHexaText(text));
}
 else {
src.setActions(ASMParser.parse(0,src.getPos(),true,text,src.getSwf().version,false));
}
src.setModified();
setSource(this.src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
saveButton.setVisible(false);
cancelButton.setVisible(false);
editButton.setVisible(true);
editor.setEditable(false);
editMode=false;
}
 catch (IOException ex) {
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
editor.gotoLine((int)ex.line);
}
break;
case ACTION_EDIT_DECOMPILED:
if (View.showConfirmDialog(null,AppStrings.translate(""String_Node_Str""),AppStrings.translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.WARNING_MESSAGE,Configuration.warningExperimentalAS12Edit,JOptionPane.OK_OPTION) == JOptionPane.OK_OPTION) {
setDecompiledEditMode(true);
}
break;
case ACTION_CANCEL_DECOMPILED:
setDecompiledEditMode(false);
break;
case ACTION_SAVE_DECOMPILED:
try {
ActionScriptParser par=new ActionScriptParser(mainPanel.getCurrentSwf().version);
src.setActions(par.actionsFromString(decompiledEditor.getText()));
src.setModified();
setSource(src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
setDecompiledEditMode(false);
}
 catch (IOException ex) {
Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
catch (CompilationException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_GRAPH:
    if (lastCode != null) {
      try {
        GraphDialog gf=new GraphDialog(mainPanel.getMainFrame().getWindow(),new ActionGraph(lastCode,new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),SWF.DEFAULT_VERSION),""String_Node_Str"");
        gf.setVisible(true);
      }
 catch (      InterruptedException ex) {
        Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  break;
case ACTION_EDIT_ACTION:
setEditMode(true);
break;
case ACTION_HEX:
case ACTION_HEX_ONLY:
if (e.getActionCommand() == ACTION_HEX) {
hexOnlyButton.setSelected(false);
}
 else {
hexButton.setSelected(false);
}
setHex(getExportMode());
break;
case ACTION_CANCEL_ACTION:
setEditMode(false);
setHex(getExportMode());
break;
case ACTION_SAVE_ACTION:
try {
String text=editor.getText();
if (text.trim().startsWith(""String_Node_Str"")) {
src.setActionBytes(Helper.getBytesFromHexaText(text));
}
 else {
src.setActions(ASMParser.parse(0,src.getPos(),true,text,src.getSwf().version,false));
}
src.setModified();
setSource(this.src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
saveButton.setVisible(false);
cancelButton.setVisible(false);
editButton.setVisible(true);
editor.setEditable(false);
editMode=false;
}
 catch (IOException ex) {
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
editor.gotoLine((int)ex.line);
}
break;
case ACTION_EDIT_DECOMPILED:
if (View.showConfirmDialog(null,AppStrings.translate(""String_Node_Str""),AppStrings.translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.WARNING_MESSAGE,Configuration.warningExperimentalAS12Edit,JOptionPane.OK_OPTION) == JOptionPane.OK_OPTION) {
setDecompiledEditMode(true);
}
break;
case ACTION_CANCEL_DECOMPILED:
setDecompiledEditMode(false);
break;
case ACTION_SAVE_DECOMPILED:
try {
ActionScriptParser par=new ActionScriptParser(mainPanel.getCurrentSwf().version);
src.setActions(par.actionsFromString(decompiledEditor.getText()));
src.setModified();
setSource(src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
setDecompiledEditMode(false);
}
 catch (IOException ex) {
Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
catch (CompilationException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
}
}",0.9920389926888707
61715,"public boolean search(final String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchPanel.setOptions(ignoreCase,regexp);
    List<TreeNode> list=SWF.createASTagList(mainPanel.getCurrentSwf().tags,null);
    Map<String,ASMSource> asms=new HashMap<>();
    getASMs(""String_Node_Str"",list,asms);
    final List<ActionSearchResult> found=new ArrayList<>();
    Pattern pat=null;
    if (regexp) {
      pat=Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    }
 else {
      pat=Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    }
    int pos=0;
    for (    Entry<String,ASMSource> item : asms.entrySet()) {
      pos++;
      String workText=AppStrings.translate(""String_Node_Str"");
      String decAdd=""String_Node_Str"";
      if (!isCached(item.getValue())) {
        decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
      }
      Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ asms.size()+ ""String_Node_Str""+ item.getKey()+ ""String_Node_Str"");
      try {
        cacheScript(item.getValue(),null);
      }
 catch (      InterruptedException ex) {
        break;
      }
      if (pat.matcher(getCached(item.getValue()).text).find()) {
        found.add(new ActionSearchResult(item.getValue(),item.getKey()));
      }
    }
    Main.stopWork();
    searchPanel.setSearchText(txt);
    final ActionPanel that=this;
    View.execInEventDispatch(new Runnable(){
      @Override public void run(){
        SearchResultsDialog<ActionSearchResult> sr=new SearchResultsDialog<ActionSearchResult>(txt,that);
        sr.setResults(found);
        sr.setVisible(true);
      }
    }
);
    return true;
  }
  return false;
}","public boolean search(final String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchPanel.setOptions(ignoreCase,regexp);
    List<TreeNode> list=SWF.createASTagList(mainPanel.getCurrentSwf().tags,null);
    Map<String,ASMSource> asms=new HashMap<>();
    getASMs(""String_Node_Str"",list,asms);
    final List<ActionSearchResult> found=new ArrayList<>();
    Pattern pat=null;
    if (regexp) {
      pat=Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    }
 else {
      pat=Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    }
    int pos=0;
    for (    Entry<String,ASMSource> item : asms.entrySet()) {
      pos++;
      String workText=AppStrings.translate(""String_Node_Str"");
      String decAdd=""String_Node_Str"";
      if (!isCached(item.getValue())) {
        decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
      }
      Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ asms.size()+ ""String_Node_Str""+ item.getKey()+ ""String_Node_Str"");
      try {
        cacheScript(item.getValue(),null);
      }
 catch (      InterruptedException ex) {
        break;
      }
      if (pat.matcher(getCached(item.getValue()).text).find()) {
        found.add(new ActionSearchResult(item.getValue(),item.getKey()));
      }
    }
    Main.stopWork();
    searchPanel.setSearchText(txt);
    View.execInEventDispatch(new Runnable(){
      @Override public void run(){
        SearchResultsDialog<ActionSearchResult> sr=new SearchResultsDialog<>(ActionPanel.this.mainPanel.getMainFrame().getWindow(),txt,ActionPanel.this);
        sr.setResults(found);
        sr.setVisible(true);
      }
    }
);
    return true;
  }
  return false;
}",0.9565938623168372
61716,"/** 
 * update the finder object with data from our UI
 */
private void updateFinder(){
  String regex=(String)jCmbFind.getSelectedItem();
  try {
    dsd.setPattern(regex,jChkRegex.isSelected(),jChkIgnoreCase.isSelected());
    ActionUtils.insertIntoCombo(jCmbFind,regex);
  }
 catch (  PatternSyntaxException e) {
    showRegexpError(e);
  }
}","/** 
 * update the finder object with data from our UI
 */
private void updateFinder(){
  String regex=(String)jCmbFind.getSelectedItem();
  try {
    dsd.setWrap(jChkWrap.isSelected());
    dsd.setPattern(regex,jChkRegex.isSelected(),jChkIgnoreCase.isSelected());
    ActionUtils.insertIntoCombo(jCmbFind,regex);
  }
 catch (  PatternSyntaxException e) {
    showRegexpError(e);
  }
}",0.9452054794520548
61717,"/** 
 * Creates new form FindDialog
 * @param text
 * @param dsd DocumentSerachData
 */
public ReplaceDialog(JTextComponent text,DocumentSearchData dsd){
  super(ActionUtils.getFrameFor(text),false);
  initComponents();
  textComponent=text;
  this.dsd=dsd;
  textComponent.addCaretListener(this);
  setLocationRelativeTo(text.getRootPane());
  getRootPane().setDefaultButton(jBtnNext);
  SwingUtils.addEscapeListener(this);
  jBtnReplaceAll.setEnabled(text.isEditable() && text.isEnabled());
}","/** 
 * Creates new form FindDialog
 * @param text
 * @param dsd DocumentSerachData
 */
public ReplaceDialog(JTextComponent text,DocumentSearchData dsd){
  super(ActionUtils.getFrameFor(text),false);
  initComponents();
  textComponent=text;
  this.dsd=dsd;
  textComponent.addCaretListener(this);
  setLocationRelativeTo(text.getRootPane());
  getRootPane().setDefaultButton(jBtnNext);
  SwingUtils.addEscapeListener(this);
  jBtnReplaceAll.setEnabled(text.isEditable() && text.isEnabled());
  jChkWrap.setSelected(dsd.isWrap());
}",0.9629629629629628
61718,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  if (!sceneBiasFlag && (frame instanceof DirectValueActionItem) && (((DirectValueActionItem)frame).value instanceof Long)) {
    return toSourceMerge(localData,generator,frame,new ActionGotoFrame((int)((long)(Long)((DirectValueActionItem)frame).value) - 1),playFlag ? new ActionPlay() : null);
  }
 else {
    return toSourceMerge(localData,generator,frame,new ActionGotoFrame2(playFlag,sceneBiasFlag,sceneBias));
  }
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  if (!sceneBiasFlag && (frame instanceof DirectValueActionItem) && (((DirectValueActionItem)frame).value instanceof Long)) {
    return toSourceMerge(localData,generator,new ActionGotoFrame((int)((long)(Long)((DirectValueActionItem)frame).value) - 1),playFlag ? new ActionPlay() : null);
  }
 else {
    return toSourceMerge(localData,generator,frame,new ActionGotoFrame2(playFlag,sceneBiasFlag,sceneBias));
  }
}",0.9946140035906644
61719,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  writer.spaceBeforeCallParenthesies(1);
  writer.append(""String_Node_Str"");
  target.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    ti.toString(writer,localData).newLine();
  }
  writer.unindent();
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  writer.spaceBeforeCallParenthesies(1);
  writer.append(""String_Node_Str"");
  target.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    ti.toStringSemicoloned(writer,localData).newLine();
  }
  writer.unindent();
  return writer.append(""String_Node_Str"");
}",0.989786443825441
61720,"@Override public void translate(boolean isStatic,int scriptIndex,int classIndex,java.util.HashMap<Integer,GraphTargetItem> localRegs,Stack<GraphTargetItem> stack,java.util.Stack<GraphTargetItem> scopeStack,ConstantPool constants,AVM2Instruction ins,List<MethodInfo> method_info,List<GraphTargetItem> output,MethodBody body,ABC abc,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,String path,HashMap<Integer,Integer> localRegsAssignmentIps,int ip,HashMap<Integer,List<Integer>> refs,AVM2Code code){
  stack.push(new IntegerValueAVM2Item(ins,Long.valueOf(ins.operands[0])));
}","@Override public void translate(boolean isStatic,int scriptIndex,int classIndex,java.util.HashMap<Integer,GraphTargetItem> localRegs,Stack<GraphTargetItem> stack,java.util.Stack<GraphTargetItem> scopeStack,ConstantPool constants,AVM2Instruction ins,List<MethodInfo> method_info,List<GraphTargetItem> output,MethodBody body,ABC abc,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames,String path,HashMap<Integer,Integer> localRegsAssignmentIps,int ip,HashMap<Integer,List<Integer>> refs,AVM2Code code){
  stack.push(new IntegerValueAVM2Item(ins,Long.valueOf((long)(short)ins.operands[0])));
}",0.9892294946147472
61721,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  AVM2Instruction ins=null;
  if (value >= 0 && value <= 255) {
    ins=new AVM2Instruction(0,new PushByteIns(),new int[]{(int)(long)value},new byte[0]);
  }
 else   if (value >= 0 && value <= 65535) {
    ins=new AVM2Instruction(0,new PushShortIns(),new int[]{(int)(long)value},new byte[0]);
  }
 else {
    ins=new AVM2Instruction(0,new PushIntIns(),new int[]{((AVM2SourceGenerator)generator).abc.constants.getIntId(value,true)},new byte[0]);
  }
  return toSourceMerge(localData,generator,ins);
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  AVM2Instruction ins=null;
  if (value >= -128 && value <= 127) {
    ins=new AVM2Instruction(0,new PushByteIns(),new int[]{(int)(long)value},new byte[0]);
  }
 else   if (value >= -32768 && value <= 32767) {
    ins=new AVM2Instruction(0,new PushShortIns(),new int[]{((int)(long)value) & 0xffff},new byte[0]);
  }
 else {
    ins=new AVM2Instruction(0,new PushIntIns(),new int[]{((AVM2SourceGenerator)generator).abc.constants.getIntId(value,true)},new byte[0]);
  }
  return toSourceMerge(localData,generator,ins);
}",0.9714726291441788
61722,"@Override public List<GraphSourceItem> generate(SourceGeneratorLocalData localData,TypeItem item) throws CompilationException {
  String currentFullClassName=localData.currentClass == null ? null : (localData.pkg.isEmpty() ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
  if (localData.documentClass && item.toString().equals(currentFullClassName)) {
    int slotId=0;
    int c=abc.findClassByName(currentFullClassName);
    for (    Trait t : localData.currentScript.traits.traits) {
      if (t instanceof TraitClass) {
        TraitClass tc=(TraitClass)t;
        if (tc.class_info == c) {
          slotId=tc.slot_id;
          break;
        }
      }
    }
    return GraphTargetItem.toSourceMerge(localData,this,ins(new GetGlobalScopeIns()),ins(new GetSlotIns(),slotId));
  }
 else {
    return GraphTargetItem.toSourceMerge(localData,this,ins(new GetLexIns(),resolveType(localData,item,abc,allABCs)));
  }
}","@Override public List<GraphSourceItem> generate(SourceGeneratorLocalData localData,TypeItem item) throws CompilationException {
  String currentFullClassName=localData.getFullClass();
  if (localData.documentClass && item.toString().equals(currentFullClassName)) {
    int slotId=0;
    int c=abc.findClassByName(currentFullClassName);
    for (    Trait t : localData.currentScript.traits.traits) {
      if (t instanceof TraitClass) {
        TraitClass tc=(TraitClass)t;
        if (tc.class_info == c) {
          slotId=tc.slot_id;
          break;
        }
      }
    }
    return GraphTargetItem.toSourceMerge(localData,this,ins(new GetGlobalScopeIns()),ins(new GetSlotIns(),slotId));
  }
 else {
    return GraphTargetItem.toSourceMerge(localData,this,ins(new GetLexIns(),resolveType(localData,item,abc,allABCs)));
  }
}",0.9155008393956352
61723,"public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,ABC abc,List<ABC> allABCs) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.currentClass == null ? null : (localData.pkg == null || localData.pkg.isEmpty() ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item.getClass().getName(),0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.currentClass == null ? null : (localData.pkg == null || localData.pkg.isEmpty() ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (mname.getNamespace(abc.constants) != null && pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.equals(""String_Node_Str"") && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc).getName(abc.constants,new ArrayList<String>()).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    List<Integer> params=new ArrayList<>();
    for (    GraphTargetItem s : atype.params) {
      params.add(resolveType(localData,s,abc,allABCs));
    }
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}","public static int resolveType(SourceGeneratorLocalData localData,GraphTargetItem item,ABC abc,List<ABC> allABCs) throws CompilationException {
  int name_index=0;
  GraphTargetItem typeItem=null;
  if (item instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    item=((UnresolvedAVM2Item)item).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (item instanceof TypeItem) {
    typeItem=item;
  }
 else   if (item instanceof ApplyTypeAVM2Item) {
    typeItem=((ApplyTypeAVM2Item)item).object;
  }
 else {
    throw new CompilationException(""String_Node_Str"" + item.getClass().getName(),0);
  }
  if (typeItem instanceof UnresolvedAVM2Item) {
    String fullClass=localData.getFullClass();
    typeItem=((UnresolvedAVM2Item)typeItem).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  if (!(typeItem instanceof TypeItem)) {
    throw new CompilationException(""String_Node_Str"",0);
  }
  TypeItem type=(TypeItem)typeItem;
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (mname != null && name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (mname.getNamespace(abc.constants) != null && pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    if (pkg.equals(""String_Node_Str"") && localData.currentScript != null) {
      for (      Trait t : localData.currentScript.traits.traits) {
        if (t.getName(abc).getName(abc.constants,new ArrayList<String>()).equals(name)) {
          name_index=t.name_index;
          break;
        }
      }
    }
    if (name_index == 0) {
      name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
    }
  }
  if (item instanceof ApplyTypeAVM2Item) {
    ApplyTypeAVM2Item atype=(ApplyTypeAVM2Item)item;
    List<Integer> params=new ArrayList<>();
    for (    GraphTargetItem s : atype.params) {
      params.add(resolveType(localData,s,abc,allABCs));
    }
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
  }
  return name_index;
}",0.9496402877697842
61724,"public int method(boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.currentClass == null ? null : (localData.pkg == null || pkg.isEmpty() ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  for (  GraphTargetItem p : paramTypes) {
    slotTypes.add(""String_Node_Str"" + p);
  }
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    mbody.code=new AVM2Code();
    mbody.code.code=toInsList(src);
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbody.code.code.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbody.code.code) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
          mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null) {
      mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
      mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
    }
    boolean addRet=false;
    if (!mbody.code.code.isEmpty()) {
      InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbody.code.code.size(); i++) {
      AVM2Instruction ins=mbody.code.code.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}","public int method(boolean isInterface,List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.getFullClass();
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg == null || pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  for (  GraphTargetItem p : paramTypes) {
    slotTypes.add(""String_Node_Str"" + p);
  }
  if (hasRest) {
    slotTypes.add(""String_Node_Str"");
  }
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramValues.get(i));
    if (optional[i] == null) {
      throw new CompilationException(""String_Node_Str"",line);
    }
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  int mindex;
  if (!isInterface) {
    MethodBody mbody=new MethodBody();
    if (needsActivation) {
      mbody.traits=new Traits();
      int slotId=1;
      for (int i=1; i < slotNames.size(); i++) {
        TraitSlotConst tsc=new TraitSlotConst();
        tsc.slot_id=slotId++;
        tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
        tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
        mbody.traits.traits.add(tsc);
      }
      for (int i=1; i < paramRegCount; i++) {
        NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
        param.setRegNumber(i);
        NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
        d.setSlotScope(slotScope);
        d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
        declarations.add(d);
      }
    }
    if (body != null) {
      body.addAll(0,declarations);
    }
    localData.exceptions=new ArrayList<>();
    localData.callStack.add(mbody);
    List<GraphSourceItem> src=body == null ? new ArrayList<GraphSourceItem>() : generate(localData,body);
    mbody.method_info=abc.addMethodInfo(mi);
    mi.setBody(mbody);
    mbody.code=new AVM2Code();
    mbody.code.code=toInsList(src);
    if (needsActivation) {
      if (localData.traitUsages.containsKey(mbody)) {
        List<Integer> usages=localData.traitUsages.get(mbody);
        for (int i=0; i < mbody.traits.traits.size(); i++) {
          if (usages.contains(i)) {
            TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
            GraphTargetItem type=TypeItem.UNBOUNDED;
            if (tsc.type_index > 0) {
              type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
            }
            NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
            d.setSlotNumber(tsc.slot_id);
            d.setSlotScope(slotScope);
            mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
          }
        }
      }
      List<AVM2Instruction> acts=new ArrayList<>();
      acts.add(ins(new NewActivationIns()));
      acts.add(ins(new DupIns()));
      acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
      acts.add(ins(new PushScopeIns()));
      mbody.code.code.addAll(0,acts);
    }
    if (constructor) {
      List<ABC> abcs=new ArrayList<>();
      abcs.add(abc);
      abcs.addAll(allABCs);
      int parentConstMinAC=0;
      for (      ABC a : abcs) {
        int ci=a.findClassByName(superType);
        if (ci > -1) {
          MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
          parentConstMinAC=pmi.param_types.length;
          if (pmi.flagHas_optional()) {
            parentConstMinAC-=pmi.optional.length;
          }
        }
      }
      int ac=-1;
      for (      AVM2Instruction ins : mbody.code.code) {
        if (ins.definition instanceof ConstructSuperIns) {
          ac=ins.operands[0];
          if (parentConstMinAC > ac) {
            throw new CompilationException(""String_Node_Str"",line);
          }
        }
      }
      if (ac == -1) {
        if (parentConstMinAC == 0) {
          mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
          mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
        }
 else {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (className != null) {
      mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
      mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
    }
    boolean addRet=false;
    if (!mbody.code.code.isEmpty()) {
      InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
      if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
        addRet=true;
      }
    }
 else {
      addRet=true;
    }
    if (addRet) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
    mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
    int offset=0;
    for (int i=0; i < mbody.code.code.size(); i++) {
      AVM2Instruction ins=mbody.code.code.get(i);
      if (ins instanceof ExceptionMarkAVM2Instruction) {
        ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
          mbody.exceptions[m.exceptionId].start=offset;
        break;
case MARK_E_END:
      mbody.exceptions[m.exceptionId].end=offset;
    break;
case MARK_E_TARGET:
  mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope,className != null);
abc.addMethodBody(mbody);
mindex=mbody.method_info;
}
 else {
mindex=abc.addMethodInfo(mi);
}
return mindex;
}",0.9938873413803776
61725,"public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands) throws ParseException, CompilationException {
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,false,localData,commands,si.traits);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.code=new AVM2Code();
  mb.code.code.add(ins(new GetLocal0Ins()));
  mb.code.code.add(ins(new PushScopeIns()));
  int traitScope=1;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mb.code.code.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mb.code.code.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mb.code.code.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mb.code.code.add(ins(new GetLexIns(),parents.get(i)));
          mb.code.code.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mb.code.code.add(ins(new GetLexIns(),parents.get(1)));
      }
      mb.code.code.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mb.code.code.add(ins(new PopScopeIns()));
        }
      }
      mb.code.code.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mb.code.code.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,localData.documentClass ? 1 : 0,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,false,localData,commands,si.traits,traitArr,initScopes);
  return si;
}","public ScriptInfo generateScriptInfo(SourceGeneratorLocalData localData,List<GraphTargetItem> commands) throws ParseException, CompilationException {
  ScriptInfo si=new ScriptInfo();
  localData.currentScript=si;
  Trait[] traitArr=generateTraitsPhase1(null,null,false,localData,commands,si.traits);
  generateTraitsPhase2(new ArrayList<String>(),null,commands,traitArr,new ArrayList<Integer>(),localData);
  MethodInfo mi=new MethodInfo(new int[0],0,0,0,new ValueKind[0],new int[0]);
  MethodBody mb=new MethodBody();
  mb.method_info=abc.addMethodInfo(mi);
  mb.code=new AVM2Code();
  mb.code.code.add(ins(new GetLocal0Ins()));
  mb.code.code.add(ins(new PushScopeIns()));
  int traitScope=2;
  Map<Trait,Integer> initScopes=new HashMap<>();
  for (  Trait t : si.traits.traits) {
    if (t instanceof TraitClass) {
      TraitClass tc=(TraitClass)t;
      List<Integer> parents=new ArrayList<>();
      if (localData.documentClass) {
        mb.code.code.add(ins(new GetScopeObjectIns(),0));
        traitScope++;
      }
 else {
        NamespaceSet nsset=new NamespaceSet(new int[]{abc.constants.constant_multiname.get(tc.name_index).namespace_index});
        mb.code.code.add(ins(new FindPropertyStrictIns(),abc.constants.getMultinameId(new Multiname(Multiname.MULTINAME,abc.constants.constant_multiname.get(tc.name_index).name_index,0,abc.constants.getNamespaceSetId(nsset,true),0,new ArrayList<Integer>()),true)));
      }
      if (abc.instance_info.get(tc.class_info).isInterface()) {
        mb.code.code.add(ins(new PushNullIns()));
      }
 else {
        parentNamesAddNames(abc,allABCs,abc.instance_info.get(tc.class_info).name_index,parents,new ArrayList<String>(),new ArrayList<String>());
        for (int i=parents.size() - 1; i >= 1; i--) {
          mb.code.code.add(ins(new GetLexIns(),parents.get(i)));
          mb.code.code.add(ins(new PushScopeIns()));
          traitScope++;
        }
        mb.code.code.add(ins(new GetLexIns(),parents.get(1)));
      }
      mb.code.code.add(ins(new NewClassIns(),tc.class_info));
      if (!abc.instance_info.get(tc.class_info).isInterface()) {
        for (int i=parents.size() - 1; i >= 1; i--) {
          mb.code.code.add(ins(new PopScopeIns()));
        }
      }
      mb.code.code.add(ins(new InitPropertyIns(),tc.name_index));
      initScopes.put(t,traitScope);
      traitScope=1;
    }
  }
  mb.code.code.add(ins(new ReturnVoidIns()));
  mb.autoFillStats(abc,1,false);
  abc.addMethodBody(mb);
  si.init_index=mb.method_info;
  localData.pkg=null;
  generateTraitsPhase3(1,false,null,null,false,localData,commands,si.traits,traitArr,initScopes);
  return si;
}",0.9939713639788996
61726,"public static boolean searchPrototypeChain(boolean instanceOnly,List<ABC> abcs,String pkg,String obj,String propertyName,Reference<String> outName,Reference<String> outNs,Reference<String> outPropNs,Reference<Integer> outPropNsKind,Reference<GraphTargetItem> outPropType,Reference<ValueKind> outPropValue){
  for (  ABC abc : abcs) {
    if (!instanceOnly) {
      for (      ScriptInfo ii : abc.script_info) {
        for (        Trait t : ii.traits.traits) {
          if (eq(pkg,t.getName(abc).getNamespace(abc.constants).getName(abc.constants))) {
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t));
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
        }
      }
    }
    for (int i=0; i < abc.instance_info.size(); i++) {
      InstanceInfo ii=abc.instance_info.get(i);
      Multiname clsName=ii.getName(abc.constants);
      if (obj.equals(clsName.getName(abc.constants,new ArrayList<String>()))) {
        if (eq(pkg,clsName.getNamespace(abc.constants).getName(abc.constants))) {
          for (          Trait t : ii.instance_traits.traits) {
            if (t.getName(abc) == null) {
              continue;
            }
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t));
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
          if (!instanceOnly) {
            for (            Trait t : abc.class_info.get(i).static_traits.traits) {
              if (t.getName(abc) == null) {
                continue;
              }
              if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
                outName.setVal(obj);
                outNs.setVal(pkg);
                outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
                outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
                outPropType.setVal(getTraitReturnType(abc,t));
                if (t instanceof TraitSlotConst) {
                  TraitSlotConst tsc=(TraitSlotConst)t;
                  outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
                }
                return true;
              }
            }
          }
          Multiname superName=abc.constants.constant_multiname.get(ii.super_index);
          if (superName != null) {
            return searchPrototypeChain(instanceOnly,abcs,superName.getNamespace(abc.constants).getName(abc.constants),superName.getName(abc.constants,new ArrayList<String>()),propertyName,outName,outNs,outPropNs,outPropNsKind,outPropType,outPropValue);
          }
 else {
            return false;
          }
        }
      }
    }
  }
  return false;
}","public static boolean searchPrototypeChain(boolean instanceOnly,List<ABC> abcs,String pkg,String obj,String propertyName,Reference<String> outName,Reference<String> outNs,Reference<String> outPropNs,Reference<Integer> outPropNsKind,Reference<Integer> outPropNsIndex,Reference<GraphTargetItem> outPropType,Reference<ValueKind> outPropValue){
  for (  ABC abc : abcs) {
    if (!instanceOnly) {
      for (      ScriptInfo ii : abc.script_info) {
        if (ii.deleted) {
          continue;
        }
        for (        Trait t : ii.traits.traits) {
          if (eq(pkg,t.getName(abc).getNamespace(abc.constants).getName(abc.constants))) {
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropNsIndex.setVal(abc.constants.getNamespaceSubIndex(t.getName(abc).namespace_index));
              outPropType.setVal(getTraitReturnType(abc,t));
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
        }
      }
    }
    for (int i=0; i < abc.instance_info.size(); i++) {
      InstanceInfo ii=abc.instance_info.get(i);
      if (ii.deleted) {
        continue;
      }
      Multiname clsName=ii.getName(abc.constants);
      if (obj.equals(clsName.getName(abc.constants,new ArrayList<String>()))) {
        if (eq(pkg,clsName.getNamespace(abc.constants).getName(abc.constants))) {
          for (          Trait t : ii.instance_traits.traits) {
            if (t.getName(abc) == null) {
              continue;
            }
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropNsIndex.setVal(abc.constants.getNamespaceSubIndex(t.getName(abc).namespace_index));
              outPropType.setVal(getTraitReturnType(abc,t));
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
          if (!instanceOnly) {
            for (            Trait t : abc.class_info.get(i).static_traits.traits) {
              if (t.getName(abc) == null) {
                continue;
              }
              if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
                outName.setVal(obj);
                outNs.setVal(pkg);
                outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
                outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
                outPropNsIndex.setVal(abc.constants.getNamespaceSubIndex(t.getName(abc).namespace_index));
                outPropType.setVal(getTraitReturnType(abc,t));
                if (t instanceof TraitSlotConst) {
                  TraitSlotConst tsc=(TraitSlotConst)t;
                  outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
                }
                return true;
              }
            }
          }
          Multiname superName=abc.constants.constant_multiname.get(ii.super_index);
          if (superName != null) {
            return searchPrototypeChain(instanceOnly,abcs,superName.getNamespace(abc.constants).getName(abc.constants),superName.getName(abc.constants,new ArrayList<String>()),propertyName,outName,outNs,outPropNs,outPropNsKind,outPropNsIndex,outPropType,outPropValue);
          }
 else {
            return false;
          }
        }
      }
    }
  }
  return false;
}",0.9410294852573712
61727,"public static Map<String,Object> getTextRecordsAttributes(List<TEXTRECORD> list,List<Tag> tags){
  Map<String,Object> att=new HashMap<>();
  RECT textBounds=new RECT(Integer.MAX_VALUE,Integer.MIN_VALUE,Integer.MAX_VALUE,Integer.MIN_VALUE);
  FontTag font=null;
  int x=0;
  int y=0;
  int textHeight=12;
  int lineSpacing=0;
  double leading=0;
  double ascent=0;
  double descent=0;
  double lineDistance=0;
  List<SHAPE> glyphs=new ArrayList<>();
  boolean firstLine=true;
  double top=0;
  List<Integer> allLeftMargins=new ArrayList<>();
  List<Integer> allLetterSpacings=new ArrayList<>();
  FontMetrics fontMetrics;
  BufferedImage bi=new BufferedImage(1,1,BufferedImage.TYPE_INT_RGB);
  Graphics graphics=bi.getGraphics();
  Font aFont=null;
  int currentLeftMargin;
  for (int r=0; r < list.size(); r++) {
    TEXTRECORD rec=list.get(r);
    if (rec.styleFlagsHasFont) {
      for (      Tag t : tags) {
        if (t instanceof FontTag) {
          FontTag ft=(FontTag)t;
          if (ft.getFontId() == rec.fontId) {
            font=ft;
          }
        }
      }
      textHeight=rec.textHeight;
      glyphs=font.getGlyphShapeTable();
      if (!font.hasLayout()) {
        String fontName=FontTag.getFontNameWithFallback(font.getFontName());
        aFont=new Font(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor));
        fontMetrics=graphics.getFontMetrics(aFont);
        LineMetrics lm=fontMetrics.getLineMetrics(""String_Node_Str"",graphics);
        ascent=lm.getAscent();
        descent=lm.getDescent();
        leading=lm.getLeading();
        lineDistance=ascent + descent;
      }
 else {
        leading=((double)font.getLeading() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        ascent=((double)font.getAscent() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        descent=((double)font.getDescent() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        lineDistance=ascent + descent;
      }
    }
    currentLeftMargin=0;
    if (rec.styleFlagsHasXOffset) {
      x=rec.xOffset;
      currentLeftMargin=x;
    }
    if (rec.styleFlagsHasYOffset) {
      if (!firstLine) {
        top+=lineDistance;
        int topint=(int)Math.round(SWF.unitDivisor * top);
        lineSpacing=rec.yOffset - topint;
        top+=lineSpacing / SWF.unitDivisor;
      }
 else {
        top=ascent - 2.0;
      }
      y=rec.yOffset;
    }
    firstLine=false;
    allLeftMargins.add(currentLeftMargin);
    int letterSpacing=0;
    for (int e=0; e < rec.glyphEntries.length; e++) {
      GLYPHENTRY entry=rec.glyphEntries[e];
      GLYPHENTRY nextEntry=null;
      if (e < rec.glyphEntries.length - 1) {
        nextEntry=rec.glyphEntries[e + 1];
      }
      RECT rect=SHAPERECORD.getBounds(glyphs.get(entry.glyphIndex).shapeRecords);
      rect.Xmax=(int)Math.round(((double)rect.Xmax * textHeight) / (font.getDivider() * 1024));
      rect.Xmin=(int)Math.round(((double)rect.Xmin * textHeight) / (font.getDivider() * 1024));
      rect.Ymax=(int)Math.round(((double)rect.Ymax * textHeight) / (font.getDivider() * 1024));
      rect.Ymin=(int)Math.round(((double)rect.Ymin * textHeight) / (font.getDivider() * 1024));
      updateRect(textBounds,x + rect.Xmin,y + rect.Ymin);
      updateRect(textBounds,x + rect.Xmax,y + rect.Ymax);
      int adv=entry.glyphAdvance;
      int defaultAdvance;
      if (font.hasLayout()) {
        int kerningAdjustment=0;
        if (nextEntry != null) {
          kerningAdjustment=font.getGlyphKerningAdjustment(entry.glyphIndex,nextEntry.glyphIndex);
        }
        defaultAdvance=(int)Math.round(textHeight * (font.getGlyphAdvance(entry.glyphIndex) + kerningAdjustment) / 1024.0);
      }
 else {
        defaultAdvance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(aFont,font.glyphToChar(entry.glyphIndex),nextEntry == null ? null : font.glyphToChar(nextEntry.glyphIndex)));
      }
      letterSpacing=adv - defaultAdvance;
      x+=adv / (font.getDivider());
    }
    allLetterSpacings.add(letterSpacing);
  }
  att.put(""String_Node_Str"",0);
  att.put(""String_Node_Str"",0);
  att.put(""String_Node_Str"",lineSpacing);
  att.put(""String_Node_Str"",textBounds);
  att.put(""String_Node_Str"",allLeftMargins);
  att.put(""String_Node_Str"",allLetterSpacings);
  return att;
}","public static Map<String,Object> getTextRecordsAttributes(List<TEXTRECORD> list,List<Tag> tags){
  Map<String,Object> att=new HashMap<>();
  RECT textBounds=new RECT(Integer.MAX_VALUE,Integer.MIN_VALUE,Integer.MAX_VALUE,Integer.MIN_VALUE);
  FontTag font=null;
  int x=0;
  int y=0;
  int textHeight=12;
  int lineSpacing=0;
  double leading=0;
  double ascent=0;
  double descent=0;
  double lineDistance=0;
  List<SHAPE> glyphs=new ArrayList<>();
  boolean firstLine=true;
  double top=0;
  List<Integer> allLeftMargins=new ArrayList<>();
  List<Integer> allLetterSpacings=new ArrayList<>();
  FontMetrics fontMetrics;
  BufferedImage bi=new BufferedImage(1,1,BufferedImage.TYPE_INT_RGB);
  Graphics graphics=bi.getGraphics();
  Font aFont=null;
  int currentLeftMargin;
  for (int r=0; r < list.size(); r++) {
    TEXTRECORD rec=list.get(r);
    if (rec.styleFlagsHasFont) {
      for (      Tag t : tags) {
        if (t instanceof FontTag) {
          FontTag ft=(FontTag)t;
          if (ft.getFontId() == rec.fontId) {
            font=ft;
          }
        }
      }
      textHeight=rec.textHeight;
      glyphs=font.getGlyphShapeTable();
      if (!font.hasLayout()) {
        String fontName=FontTag.getFontNameWithFallback(font.getFontName());
        aFont=new Font(fontName,font.getFontStyle(),(int)(textHeight / SWF.unitDivisor));
        fontMetrics=graphics.getFontMetrics(aFont);
        LineMetrics lm=fontMetrics.getLineMetrics(""String_Node_Str"",graphics);
        ascent=lm.getAscent();
        descent=lm.getDescent();
        leading=lm.getLeading();
        lineDistance=ascent + descent;
      }
 else {
        leading=((double)font.getLeading() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        ascent=((double)font.getAscent() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        descent=((double)font.getDescent() * textHeight / 1024.0 / font.getDivider() / SWF.unitDivisor);
        lineDistance=ascent + descent;
      }
    }
    currentLeftMargin=0;
    if (rec.styleFlagsHasXOffset) {
      x=rec.xOffset;
      currentLeftMargin=x;
    }
    if (rec.styleFlagsHasYOffset) {
      if (!firstLine) {
        top+=ascent + descent;
        int topint=(int)(Math.round(top) * SWF.unitDivisor);
        lineSpacing=rec.yOffset - topint;
        top+=lineSpacing / SWF.unitDivisor;
      }
 else {
        top=ascent;
      }
      y=rec.yOffset;
    }
    firstLine=false;
    allLeftMargins.add(currentLeftMargin);
    int letterSpacing=0;
    for (int e=0; e < rec.glyphEntries.length; e++) {
      GLYPHENTRY entry=rec.glyphEntries[e];
      GLYPHENTRY nextEntry=null;
      if (e < rec.glyphEntries.length - 1) {
        nextEntry=rec.glyphEntries[e + 1];
      }
      RECT rect=SHAPERECORD.getBounds(glyphs.get(entry.glyphIndex).shapeRecords);
      rect.Xmax=(int)Math.round(((double)rect.Xmax * textHeight) / (font.getDivider() * 1024));
      rect.Xmin=(int)Math.round(((double)rect.Xmin * textHeight) / (font.getDivider() * 1024));
      rect.Ymax=(int)Math.round(((double)rect.Ymax * textHeight) / (font.getDivider() * 1024));
      rect.Ymin=(int)Math.round(((double)rect.Ymin * textHeight) / (font.getDivider() * 1024));
      updateRect(textBounds,x + rect.Xmin,y + rect.Ymin);
      updateRect(textBounds,x + rect.Xmax,y + rect.Ymax);
      int adv=entry.glyphAdvance;
      int defaultAdvance;
      if (font.hasLayout()) {
        int kerningAdjustment=0;
        if (nextEntry != null) {
          kerningAdjustment=font.getGlyphKerningAdjustment(entry.glyphIndex,nextEntry.glyphIndex);
        }
        defaultAdvance=(int)Math.round(textHeight * (font.getGlyphAdvance(entry.glyphIndex) + kerningAdjustment) / 1024.0);
      }
 else {
        defaultAdvance=(int)Math.round(SWF.unitDivisor * FontTag.getSystemFontAdvance(aFont,font.glyphToChar(entry.glyphIndex),nextEntry == null ? null : font.glyphToChar(nextEntry.glyphIndex)));
      }
      letterSpacing=adv - defaultAdvance;
      x+=adv / (font.getDivider());
    }
    allLetterSpacings.add(letterSpacing);
  }
  att.put(""String_Node_Str"",0);
  att.put(""String_Node_Str"",0);
  att.put(""String_Node_Str"",lineSpacing);
  att.put(""String_Node_Str"",textBounds);
  att.put(""String_Node_Str"",allLeftMargins);
  att.put(""String_Node_Str"",allLetterSpacings);
  return att;
}",0.98840714120102
61728,"/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  if (Configuration.debugCopy.get()) {
    os=new CopyOutputStream(os,new ByteArrayInputStream(super.data));
  }
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  try {
    sos.writeUI16(spriteId);
    sos.writeUI16(frameCount);
    if (hasEndTag) {
      sos.writeUI16(0);
    }
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  if (Configuration.debugCopy.get()) {
    os=new CopyOutputStream(os,new ByteArrayInputStream(super.data));
  }
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  try {
    sos.writeUI16(spriteId);
    sos.writeUI16(frameCount);
    sos.writeTags(subTags);
    if (hasEndTag) {
      sos.writeUI16(0);
    }
    sos.close();
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.974910394265233
61729,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  Set<String> usedNames=new HashSet<>();
  for (  VariableActionItem v : variables) {
    usedNames.add(v.getVariableName());
  }
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<Integer> paramRegs=new ArrayList<>();
  SourceGeneratorLocalData localDataCopy=Helper.deepCopy(localData);
  localDataCopy.inFunction++;
  boolean preloadParentFlag=false;
  boolean preloadRootFlag=false;
  boolean preloadSuperFlag=false;
  boolean preloadArgumentsFlag=false;
  boolean preloadThisFlag=false;
  boolean preloadGlobalFlag=false;
  boolean suppressParentFlag=false;
  boolean suppressArgumentsFlag=false;
  boolean suppressThisFlag=false;
  boolean needsFun2=false;
  List<String> registerNames=new ArrayList<>();
  registerNames.add(""String_Node_Str"");
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadThisFlag=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressThisFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadArgumentsFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressArgumentsFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadSuperFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadRootFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadParentFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressParentFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadGlobalFlag=true;
    registerNames.add(""String_Node_Str"");
  }
  int preloadedNumber=registerNames.size();
  if (!paramNames.isEmpty()) {
    needsFun2=true;
  }
  if (localData.inMethod) {
    needsFun2=true;
  }
  if (localData.inFunction > 1) {
    needsFun2=true;
  }
  if (needsFun2) {
    for (int i=0; i < paramNames.size(); i++) {
      paramRegs.add(registerNames.size());
      registerNames.add(paramNames.get(i));
    }
  }
  if (actions != null && !actions.isEmpty()) {
    localDataCopy.inFunction++;
    for (    VariableActionItem v : variables) {
      String varName=v.getVariableName();
      GraphTargetItem stored=v.getStoreValue();
      if (needsFun2) {
        if (v.isDefinition() && !registerNames.contains(varName)) {
          registerNames.add(varName);
        }
      }
      if (registerNames.contains(varName)) {
        if (stored != null) {
          v.setBoxedValue(new StoreRegisterActionItem(null,new RegisterNumber(registerNames.indexOf(varName),varName),stored,false));
        }
 else {
          v.setBoxedValue(new DirectValueActionItem(new RegisterNumber(registerNames.indexOf(varName),varName)));
        }
      }
 else {
        if (v.isDefinition()) {
          v.setBoxedValue(new DefineLocalActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
        }
 else {
          if (stored != null) {
            v.setBoxedValue(new SetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
          }
 else {
            v.setBoxedValue(new GetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName)));
          }
        }
      }
    }
    ret.addAll(asGenerator.toActionList(asGenerator.generate(localDataCopy,actions)));
  }
  int len=Action.actionsToBytes(asGenerator.toActionList(ret),false,SWF.DEFAULT_VERSION).length;
  if (!needsFun2 && paramNames.isEmpty()) {
    ret.add(0,new ActionDefineFunction(functionName,paramNames,len,SWF.DEFAULT_VERSION));
  }
 else {
    ret.add(0,new ActionDefineFunction2(functionName,preloadParentFlag,preloadRootFlag,suppressParentFlag,preloadSuperFlag,suppressArgumentsFlag,preloadArgumentsFlag,suppressThisFlag,preloadThisFlag,preloadGlobalFlag,registerNames.size() - 1,len,SWF.DEFAULT_VERSION,paramNames,paramRegs));
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  Set<String> usedNames=new HashSet<>();
  for (  VariableActionItem v : variables) {
    usedNames.add(v.getVariableName());
  }
  List<GraphSourceItem> ret=new ArrayList<>();
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<Integer> paramRegs=new ArrayList<>();
  SourceGeneratorLocalData localDataCopy=Helper.deepCopy(localData);
  localDataCopy.inFunction++;
  boolean preloadParentFlag=false;
  boolean preloadRootFlag=false;
  boolean preloadSuperFlag=false;
  boolean preloadArgumentsFlag=false;
  boolean preloadThisFlag=false;
  boolean preloadGlobalFlag=false;
  boolean suppressParentFlag=false;
  boolean suppressArgumentsFlag=false;
  boolean suppressThisFlag=false;
  boolean needsFun2=false;
  List<String> registerNames=new ArrayList<>();
  registerNames.add(""String_Node_Str"");
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadThisFlag=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressThisFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadArgumentsFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressArgumentsFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadSuperFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadRootFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
  if (usedNames.contains(""String_Node_Str"")) {
    preloadParentFlag=true;
    needsFun2=true;
    registerNames.add(""String_Node_Str"");
  }
 else {
    suppressParentFlag=true;
  }
  if (usedNames.contains(""String_Node_Str"")) {
    needsFun2=true;
    preloadGlobalFlag=true;
    registerNames.add(""String_Node_Str"");
  }
  int preloadedNumber=registerNames.size();
  if (!paramNames.isEmpty()) {
    needsFun2=true;
  }
  if (localData.inMethod) {
    needsFun2=true;
  }
  if (localData.inFunction > 1) {
    needsFun2=true;
  }
  if (needsFun2) {
    for (int i=0; i < paramNames.size(); i++) {
      paramRegs.add(registerNames.size());
      registerNames.add(paramNames.get(i));
    }
  }
  if (actions != null && !actions.isEmpty()) {
    localDataCopy.inFunction++;
    for (    VariableActionItem v : variables) {
      String varName=v.getVariableName();
      GraphTargetItem stored=v.getStoreValue();
      if (needsFun2) {
        if (v.isDefinition() && !registerNames.contains(varName)) {
          registerNames.add(varName);
        }
      }
      if (registerNames.contains(varName)) {
        if (stored != null) {
          v.setBoxedValue(new StoreRegisterActionItem(null,new RegisterNumber(registerNames.indexOf(varName),varName),stored,false));
        }
 else {
          v.setBoxedValue(new DirectValueActionItem(new RegisterNumber(registerNames.indexOf(varName),varName)));
        }
      }
 else {
        if (v.isDefinition()) {
          v.setBoxedValue(new DefineLocalActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
        }
 else {
          if (stored != null) {
            v.setBoxedValue(new SetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName),stored));
          }
 else {
            v.setBoxedValue(new GetVariableActionItem(null,((ActionSourceGenerator)generator).pushConstTargetItem(varName)));
          }
        }
      }
    }
    ret.addAll(asGenerator.toActionList(asGenerator.generate(localDataCopy,actions)));
  }
  int len=Action.actionsToBytes(asGenerator.toActionList(ret),false,SWF.DEFAULT_VERSION).length;
  if (!needsFun2 && paramNames.isEmpty()) {
    ret.add(0,new ActionDefineFunction(functionName,paramNames,len,SWF.DEFAULT_VERSION));
  }
 else {
    ret.add(0,new ActionDefineFunction2(functionName,preloadParentFlag,preloadRootFlag,suppressParentFlag,preloadSuperFlag,suppressArgumentsFlag,preloadArgumentsFlag,suppressThisFlag,preloadThisFlag,preloadGlobalFlag,registerNames.size(),len,SWF.DEFAULT_VERSION,paramNames,paramRegs));
  }
  return ret;
}",0.9995243757431628
61730,"@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem index=stack.pop();
  GraphTargetItem target=stack.pop();
  int indexInt=0;
  if (index instanceof DirectValueActionItem) {
    if (((DirectValueActionItem)index).value instanceof Long) {
      indexInt=(int)(long)(Long)((DirectValueActionItem)index).value;
    }
  }
  stack.push(new GetPropertyActionItem(this,target,indexInt));
}","@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem index=stack.pop();
  GraphTargetItem target=stack.pop();
  int indexInt=0;
  if (index instanceof DirectValueActionItem) {
    if (((DirectValueActionItem)index).value instanceof Long) {
      indexInt=(int)(long)(Long)((DirectValueActionItem)index).value;
    }
 else     if (((DirectValueActionItem)index).value instanceof Double) {
      indexInt=(int)Math.round((Double)((DirectValueActionItem)index).value);
    }
 else     if (((DirectValueActionItem)index).value instanceof Float) {
      indexInt=(int)Math.round((Float)((DirectValueActionItem)index).value);
    }
  }
  stack.push(new GetPropertyActionItem(this,target,indexInt));
}",0.7947019867549668
61731,"@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem value=stack.pop().getThroughDuplicate();
  GraphTargetItem index=stack.pop().getThroughDuplicate();
  GraphTargetItem target=stack.pop().getThroughDuplicate();
  int indexInt=0;
  if (index instanceof DirectValueActionItem) {
    if (((DirectValueActionItem)index).value instanceof Long) {
      indexInt=(int)(long)(Long)((DirectValueActionItem)index).value;
    }
  }
  if (value.getThroughDuplicate() instanceof IncrementActionItem) {
    GraphTargetItem obj=((IncrementActionItem)value).object;
    if (!stack.isEmpty()) {
      if (stack.peek().valueEquals(obj)) {
        stack.pop();
        stack.push(new PostIncrementActionItem(this,obj));
        return;
      }
    }
  }
  if (value.getThroughDuplicate() instanceof DecrementActionItem) {
    GraphTargetItem obj=((DecrementActionItem)value).object;
    if (!stack.isEmpty()) {
      if (stack.peek().valueEquals(obj)) {
        stack.pop();
        stack.push(new PostDecrementActionItem(this,obj));
        return;
      }
    }
  }
  GraphTargetItem ret=new SetPropertyActionItem(this,target,indexInt,value);
  if (value instanceof StoreRegisterActionItem) {
    StoreRegisterActionItem sr=(StoreRegisterActionItem)value;
    if (sr.define) {
      value=sr.getValue();
      ((SetPropertyActionItem)ret).setValue(value);
      if (value instanceof IncrementActionItem) {
        if (((IncrementActionItem)value).object instanceof GetPropertyActionItem) {
          if (((GetPropertyActionItem)((IncrementActionItem)value).object).valueEquals(((SetPropertyActionItem)ret).getObject())) {
            ret=new PreIncrementActionItem(this,((IncrementActionItem)value).object);
          }
        }
      }
 else       if (value instanceof DecrementActionItem) {
        if (((DecrementActionItem)value).object instanceof GetPropertyActionItem) {
          if (((GetPropertyActionItem)((DecrementActionItem)value).object).valueEquals(((SetPropertyActionItem)ret).getObject())) {
            ret=new PreDecrementActionItem(this,((DecrementActionItem)value).object);
          }
        }
      }
 else {
        sr.temporary=true;
        ((SetPropertyActionItem)ret).setValue(sr);
      }
      variables.put(""String_Node_Str"" + sr.register.number,new TemporaryRegister(sr.register.number,ret));
      return;
    }
  }
  output.add(ret);
}","@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem value=stack.pop().getThroughDuplicate();
  GraphTargetItem index=stack.pop().getThroughDuplicate();
  GraphTargetItem target=stack.pop().getThroughDuplicate();
  int indexInt=0;
  if (index instanceof DirectValueActionItem) {
    if (((DirectValueActionItem)index).value instanceof Long) {
      indexInt=(int)(long)(Long)((DirectValueActionItem)index).value;
    }
 else     if (((DirectValueActionItem)index).value instanceof Double) {
      indexInt=(int)Math.round((Double)((DirectValueActionItem)index).value);
    }
 else     if (((DirectValueActionItem)index).value instanceof Float) {
      indexInt=(int)Math.round((Float)((DirectValueActionItem)index).value);
    }
  }
  if (value.getThroughDuplicate() instanceof IncrementActionItem) {
    GraphTargetItem obj=((IncrementActionItem)value).object;
    if (!stack.isEmpty()) {
      if (stack.peek().valueEquals(obj)) {
        stack.pop();
        stack.push(new PostIncrementActionItem(this,obj));
        return;
      }
    }
  }
  if (value.getThroughDuplicate() instanceof DecrementActionItem) {
    GraphTargetItem obj=((DecrementActionItem)value).object;
    if (!stack.isEmpty()) {
      if (stack.peek().valueEquals(obj)) {
        stack.pop();
        stack.push(new PostDecrementActionItem(this,obj));
        return;
      }
    }
  }
  GraphTargetItem ret=new SetPropertyActionItem(this,target,indexInt,value);
  if (value instanceof StoreRegisterActionItem) {
    StoreRegisterActionItem sr=(StoreRegisterActionItem)value;
    if (sr.define) {
      value=sr.getValue();
      ((SetPropertyActionItem)ret).setValue(value);
      if (value instanceof IncrementActionItem) {
        if (((IncrementActionItem)value).object instanceof GetPropertyActionItem) {
          if (((GetPropertyActionItem)((IncrementActionItem)value).object).valueEquals(((SetPropertyActionItem)ret).getObject())) {
            ret=new PreIncrementActionItem(this,((IncrementActionItem)value).object);
          }
        }
      }
 else       if (value instanceof DecrementActionItem) {
        if (((DecrementActionItem)value).object instanceof GetPropertyActionItem) {
          if (((GetPropertyActionItem)((DecrementActionItem)value).object).valueEquals(((SetPropertyActionItem)ret).getObject())) {
            ret=new PreDecrementActionItem(this,((DecrementActionItem)value).object);
          }
        }
      }
 else {
        sr.temporary=true;
        ((SetPropertyActionItem)ret).setValue(sr);
      }
      variables.put(""String_Node_Str"" + sr.register.number,new TemporaryRegister(sr.register.number,ret));
      return;
    }
  }
  output.add(ret);
}",0.9431609827649432
61732,"/** 
 * Construct SWF from stream
 * @param is Stream to read SWF from
 * @param listener
 * @param parallelRead Use parallel threads?
 * @param checkOnly Check only file validity
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public SWF(InputStream is,ProgressListener listener,boolean parallelRead,boolean checkOnly) throws IOException, InterruptedException {
  byte[] hdr=new byte[3];
  is.read(hdr);
  String shdr=new String(hdr,Utf8Helper.charset);
  if (!Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(shdr)) {
    throw new IOException(""String_Node_Str"");
  }
  version=is.read();
  SWFInputStream sis=new SWFInputStream(is,version,4);
  fileSize=sis.readUI32();
  if (hdr[1] == 'F' && hdr[2] == 'X') {
    gfx=true;
  }
  if (hdr[0] == 'C') {
    byte[] uncompressedData=Helper.readStream(new InflaterInputStream(is));
    sis=new SWFInputStream(new ByteArrayInputStream(uncompressedData),version,8);
    compressed=true;
  }
  if (hdr[0] == 'Z') {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    sis.readUI32();
    int propertiesSize=5;
    lzmaProperties=new byte[propertiesSize];
    if (sis.read(lzmaProperties,0,propertiesSize) != propertiesSize) {
      throw new IOException(""String_Node_Str"");
    }
    long dictionarySize=0;
    for (int i=0; i < 4; i++) {
      dictionarySize+=((int)(lzmaProperties[1 + i]) & 0xFF) << (i * 8);
      if (dictionarySize > Runtime.getRuntime().freeMemory()) {
        throw new IOException(""String_Node_Str"");
      }
    }
    SevenZip.Compression.LZMA.Decoder decoder=new SevenZip.Compression.LZMA.Decoder();
    if (!decoder.SetDecoderProperties(lzmaProperties)) {
      throw new IOException(""String_Node_Str"");
    }
    if (!decoder.Code(sis,baos,fileSize - 8)) {
      throw new IOException(""String_Node_Str"");
    }
    sis=new SWFInputStream(new ByteArrayInputStream(baos.toByteArray()),version,8);
    compressed=true;
    lzma=true;
  }
  if (listener != null) {
    sis.addPercentListener(listener);
  }
  sis.setPercentMax(fileSize);
  displayRect=sis.readRECT();
  sis.readUI8();
  frameRate=sis.readUI8();
  frameCount=sis.readUI16();
  List<Tag> tags=sis.readTagList(this,this,0,parallelRead,true,!checkOnly,gfx);
  if (tags.get(tags.size() - 1).getId() == EndTag.ID) {
    hasEndTag=true;
    tags.remove(tags.size() - 1);
  }
  this.tags=tags;
  if (!checkOnly) {
    checkInvalidSprites();
    updateInnerTagsForShowFrameTags();
    updateCharacters();
    assignExportNamesToSymbols();
    assignClassesToSymbols();
    findFileAttributes();
  }
 else {
    boolean hasNonUnknownTag=false;
    for (    Tag tag : tags) {
      if (tag.getOriginalData().length > 0 && Tag.getRequiredTags().contains(tag.getId())) {
        hasNonUnknownTag=true;
      }
    }
    if (!hasNonUnknownTag) {
      throw new IOException(""String_Node_Str"");
    }
  }
}","/** 
 * Construct SWF from stream
 * @param is Stream to read SWF from
 * @param listener
 * @param parallelRead Use parallel threads?
 * @param checkOnly Check only file validity
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public SWF(InputStream is,ProgressListener listener,boolean parallelRead,boolean checkOnly) throws IOException, InterruptedException {
  byte[] hdr=new byte[3];
  is.read(hdr);
  String shdr=new String(hdr,Utf8Helper.charset);
  if (!Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(shdr)) {
    throw new IOException(""String_Node_Str"");
  }
  version=is.read();
  SWFInputStream sis=new SWFInputStream(is,version,4);
  fileSize=sis.readUI32();
  if (hdr[1] == 'F' && hdr[2] == 'X') {
    gfx=true;
  }
  if (hdr[0] == 'C') {
    byte[] uncompressedData=Helper.readStream(new InflaterInputStream(is));
    sis=new SWFInputStream(new ByteArrayInputStream(uncompressedData),version,8);
    compressed=true;
  }
  if (hdr[0] == 'Z') {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    sis.readUI32();
    int propertiesSize=5;
    lzmaProperties=new byte[propertiesSize];
    if (sis.read(lzmaProperties,0,propertiesSize) != propertiesSize) {
      throw new IOException(""String_Node_Str"");
    }
    long dictionarySize=0;
    for (int i=0; i < 4; i++) {
      dictionarySize+=((int)(lzmaProperties[1 + i]) & 0xFF) << (i * 8);
      if (dictionarySize > Runtime.getRuntime().freeMemory()) {
        throw new IOException(""String_Node_Str"");
      }
    }
    SevenZip.Compression.LZMA.Decoder decoder=new SevenZip.Compression.LZMA.Decoder();
    if (!decoder.SetDecoderProperties(lzmaProperties)) {
      throw new IOException(""String_Node_Str"");
    }
    if (!decoder.Code(sis,baos,fileSize - 8)) {
      throw new IOException(""String_Node_Str"");
    }
    sis=new SWFInputStream(new ByteArrayInputStream(baos.toByteArray()),version,8);
    compressed=true;
    lzma=true;
  }
  if (listener != null) {
    sis.addPercentListener(listener);
  }
  sis.setPercentMax(fileSize);
  displayRect=sis.readRECT();
  sis.readUI8();
  frameRate=sis.readUI8();
  frameCount=sis.readUI16();
  List<Tag> tags=sis.readTagList(this,this,0,parallelRead,true,!checkOnly,gfx);
  if (tags.get(tags.size() - 1).getId() == EndTag.ID) {
    hasEndTag=true;
    tags.remove(tags.size() - 1);
  }
  this.tags=tags;
  if (!checkOnly) {
    checkInvalidSprites();
    updateInnerTagsForShowFrameTags();
    updateCharacters();
    assignExportNamesToSymbols();
    assignClassesToSymbols();
    findFileAttributes();
    findABCTags();
  }
 else {
    boolean hasNonUnknownTag=false;
    for (    Tag tag : tags) {
      if (tag.getOriginalData().length > 0 && Tag.getRequiredTags().contains(tag.getId())) {
        hasNonUnknownTag=true;
      }
    }
    if (!hasNonUnknownTag) {
      throw new IOException(""String_Node_Str"");
    }
  }
}",0.9967615476393388
61733,"public Multiname readMultiname() throws IOException {
  int kind=readU8();
  int namespace_index=-1;
  int name_index=-1;
  int namespace_set_index=-1;
  int qname_index=-1;
  List<Integer> params=new ArrayList<>();
  if ((kind == 7) || (kind == 0xd)) {
    namespace_index=readU30();
    name_index=readU30();
  }
 else   if ((kind == 0xf) || (kind == 0x10)) {
    name_index=readU30();
  }
 else   if ((kind == 0x11) || (kind == 0x12)) {
  }
 else   if ((kind == 9) || (kind == 0xe)) {
    name_index=readU30();
    namespace_set_index=readU30();
  }
 else   if ((kind == 0x1B) || (kind == 0x1C)) {
    namespace_set_index=readU30();
  }
 else   if (kind == 0x1D) {
    qname_index=readU30();
    int paramsLength=readU30();
    for (int i=0; i < paramsLength; i++) {
      params.add(readU30());
    }
  }
 else {
    throw new IOException(""String_Node_Str"" + Integer.toHexString(kind));
  }
  return new Multiname(kind,name_index,namespace_index,namespace_set_index,qname_index,params);
}","public Multiname readMultiname() throws IOException {
  int kind=readU8();
  int namespace_index=0;
  int name_index=0;
  int namespace_set_index=0;
  int qname_index=0;
  List<Integer> params=new ArrayList<>();
  if ((kind == Multiname.QNAME) || (kind == Multiname.QNAMEA)) {
    namespace_index=readU30();
    name_index=readU30();
  }
 else   if ((kind == Multiname.RTQNAME) || (kind == Multiname.RTQNAMEA)) {
    name_index=readU30();
  }
 else   if ((kind == Multiname.RTQNAMEL) || (kind == Multiname.RTQNAMELA)) {
  }
 else   if ((kind == Multiname.MULTINAME) || (kind == Multiname.MULTINAMEA)) {
    name_index=readU30();
    namespace_set_index=readU30();
  }
 else   if ((kind == Multiname.MULTINAMEL) || (kind == Multiname.MULTINAMELA)) {
    namespace_set_index=readU30();
  }
 else   if (kind == Multiname.TYPENAME) {
    qname_index=readU30();
    int paramsLength=readU30();
    for (int i=0; i < paramsLength; i++) {
      params.add(readU30());
    }
  }
 else {
    throw new IOException(""String_Node_Str"" + Integer.toHexString(kind));
  }
  return new Multiname(kind,name_index,namespace_index,namespace_set_index,qname_index,params);
}",0.8667287977632805
61734,"public CodeStats getStats(ABC abc,MethodBody body,int initScope){
  CodeStats stats=new CodeStats(this);
  stats.initscope=initScope;
  if (!walkCode(stats,0,0,initScope,abc)) {
    return null;
  }
  int scopePos=-1;
  int prevStart=0;
  for (int e=0; e < body.exceptions.length; e++) {
    ABCException ex=body.exceptions[e];
    try {
      if (scopePos == -1) {
        scopePos=stats.instructionStats[adr2pos(ex.end) - 1].scopepos_after;
      }
      List<Integer> visited=new ArrayList<>();
      for (int i=0; i < stats.instructionStats.length; i++) {
        if (stats.instructionStats[i].seen) {
          visited.add(i);
        }
      }
      if (!walkCode(stats,adr2pos(ex.target),1 + (ex.isFinally() ? 1 : 0),scopePos,abc)) {
        return null;
      }
      int maxIp=0;
      for (int i=0; i < stats.instructionStats.length; i++) {
        if (stats.instructionStats[i].seen && !visited.contains(i)) {
          maxIp=i;
        }
      }
      scopePos=stats.instructionStats[maxIp].scopepos_after;
      int stackPos=stats.instructionStats[maxIp].stackpos_after;
      int nextIp=maxIp + 1;
      if (code.get(maxIp).definition instanceof JumpIns) {
        nextIp=adr2pos(pos2adr(nextIp) + code.get(maxIp).operands[0]);
      }
      int origScopePos=stats.instructionStats[nextIp].scopepos;
      int origStackPos=stats.instructionStats[nextIp].stackpos;
      if (prevStart == ex.start && ex.isFinally() && !code.get(nextIp).isExit() && stats.instructionStats[nextIp].seen) {
        for (int i=0; i < stats.instructionStats.length; i++) {
          stats.instructionStats[i].seen=false;
        }
        if (!walkCode(stats,nextIp,origStackPos + 1,scopePos - 1,abc)) {
          return null;
        }
        scopePos--;
      }
      prevStart=ex.start;
    }
 catch (    ConvertException ex1) {
    }
  }
  return stats;
}","public CodeStats getStats(ABC abc,MethodBody body,int initScope){
  CodeStats stats=new CodeStats(this);
  stats.initscope=initScope;
  if (!walkCode(stats,0,0,initScope,abc)) {
    return null;
  }
  int scopePos=-1;
  int prevStart=0;
  for (int e=0; e < body.exceptions.length; e++) {
    ABCException ex=body.exceptions[e];
    try {
      if (scopePos == -1) {
        scopePos=stats.instructionStats[adr2pos(ex.end) - 1].scopepos_after;
      }
      List<Integer> visited=new ArrayList<>();
      for (int i=0; i < stats.instructionStats.length; i++) {
        if (stats.instructionStats[i].seen) {
          visited.add(i);
        }
      }
      if (!walkCode(stats,adr2pos(ex.target),1 + (ex.isFinally() ? 1 : 0),scopePos,abc)) {
        return null;
      }
      int maxIp=0;
      for (int i=0; i < stats.instructionStats.length; i++) {
        if (stats.instructionStats[i].seen && !visited.contains(i)) {
          maxIp=i;
        }
      }
      scopePos=stats.instructionStats[maxIp].scopepos_after;
      int stackPos=stats.instructionStats[maxIp].stackpos_after;
      int nextIp=maxIp + 1;
      if (code.get(maxIp).definition instanceof JumpIns) {
        nextIp=adr2pos(pos2adr(nextIp) + code.get(maxIp).operands[0]);
      }
      if (nextIp < stats.instructionStats.length) {
        int origScopePos=stats.instructionStats[nextIp].scopepos;
        int origStackPos=stats.instructionStats[nextIp].stackpos;
        if (prevStart == ex.start && ex.isFinally() && !code.get(nextIp).isExit() && stats.instructionStats[nextIp].seen) {
          for (int i=0; i < stats.instructionStats.length; i++) {
            stats.instructionStats[i].seen=false;
          }
          if (!walkCode(stats,nextIp,origStackPos + 1,scopePos - 1,abc)) {
            return null;
          }
          scopePos--;
        }
      }
      prevStart=ex.start;
    }
 catch (    ConvertException ex1) {
    }
  }
  return stats;
}",0.9751585623678648
61735,"public static AVM2Instruction ins(InstructionDefinition def,int... operands){
  return new AVM2Instruction(0,def,operands,new byte[0]);
}","public static AVM2Instruction ins(InstructionDefinition def,Integer... operands){
  List<Integer> ops=new ArrayList<>();
  for (  Integer o : operands) {
    if (o != null) {
      ops.add(o);
    }
  }
  int opArr[]=new int[ops.size()];
  for (int i=0; i < ops.size(); i++) {
    opArr[i]=ops.get(i);
  }
  return new AVM2Instruction(0,def,opArr,new byte[0]);
}",0.5130260521042084
61736,"private static int parseMultiName(ConstantPool constants,Flasm3Lexer lexer) throws ParseException, IOException {
  ParsedSymbol s=lexer.lex();
  int kind=0;
  int name_index=-1;
  int namespace_index=-1;
  int namespace_set_index=-1;
  int qname_index=-1;
  List<Integer> params=new ArrayList<>();
switch (s.type) {
case ParsedSymbol.TYPE_KEYWORD_NULL:
    return 0;
case ParsedSymbol.TYPE_KEYWORD_QNAME:
  kind=Multiname.QNAME;
break;
case ParsedSymbol.TYPE_KEYWORD_QNAMEA:
kind=Multiname.QNAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAME:
kind=Multiname.RTQNAME;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEA:
kind=Multiname.RTQNAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEL:
kind=Multiname.RTQNAMEL;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMELA:
kind=Multiname.RTQNAMELA;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAME:
kind=Multiname.MULTINAME;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEA:
kind=Multiname.MULTINAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEL:
kind=Multiname.MULTINAMEL;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMELA:
kind=Multiname.MULTINAMELA;
break;
case ParsedSymbol.TYPE_KEYWORD_TYPENAME:
kind=Multiname.TYPENAME;
break;
default :
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
switch (s.type) {
case ParsedSymbol.TYPE_KEYWORD_QNAME:
case ParsedSymbol.TYPE_KEYWORD_QNAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
namespace_index=parseNamespace(constants,lexer);
expected(ParsedSymbol.TYPE_COMMA,""String_Node_Str"",lexer);
ParsedSymbol name=lexer.lex();
expected(name,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)name.value,true);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAME:
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
ParsedSymbol rtqName=lexer.lex();
expected(rtqName,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)rtqName.value,true);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEL:
case ParsedSymbol.TYPE_KEYWORD_RTQNAMELA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAME:
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
ParsedSymbol mName=lexer.lex();
expected(mName,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)mName.value,true);
expected(ParsedSymbol.TYPE_COMMA,""String_Node_Str"",lexer);
namespace_set_index=parseNamespaceSet(constants,lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEL:
case ParsedSymbol.TYPE_KEYWORD_MULTINAMELA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
namespace_set_index=parseNamespaceSet(constants,lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_TYPENAME:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
qname_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_LOWERTHAN,""String_Node_Str"",lexer);
params.add(parseMultiName(constants,lexer));
ParsedSymbol nt=lexer.lex();
while (nt.type == ParsedSymbol.TYPE_COMMA) {
params.add(parseMultiName(constants,lexer));
nt=lexer.lex();
}
expected(nt,ParsedSymbol.TYPE_GREATERTHAN,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
}
return constants.getMultinameId(new Multiname(kind,name_index,namespace_index,namespace_set_index,qname_index,params),true);
}","private static int parseMultiName(ConstantPool constants,Flasm3Lexer lexer) throws ParseException, IOException {
  ParsedSymbol s=lexer.lex();
  int kind=0;
  int name_index=-1;
  int namespace_index=-1;
  int namespace_set_index=-1;
  int qname_index=-1;
  List<Integer> params=new ArrayList<>();
switch (s.type) {
case ParsedSymbol.TYPE_KEYWORD_NULL:
    return 0;
case ParsedSymbol.TYPE_KEYWORD_QNAME:
  kind=Multiname.QNAME;
break;
case ParsedSymbol.TYPE_KEYWORD_QNAMEA:
kind=Multiname.QNAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAME:
kind=Multiname.RTQNAME;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEA:
kind=Multiname.RTQNAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEL:
kind=Multiname.RTQNAMEL;
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMELA:
kind=Multiname.RTQNAMELA;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAME:
kind=Multiname.MULTINAME;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEA:
kind=Multiname.MULTINAMEA;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEL:
kind=Multiname.MULTINAMEL;
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMELA:
kind=Multiname.MULTINAMELA;
break;
case ParsedSymbol.TYPE_KEYWORD_TYPENAME:
kind=Multiname.TYPENAME;
break;
default :
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
switch (s.type) {
case ParsedSymbol.TYPE_KEYWORD_QNAME:
case ParsedSymbol.TYPE_KEYWORD_QNAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
namespace_index=parseNamespace(constants,lexer);
expected(ParsedSymbol.TYPE_COMMA,""String_Node_Str"",lexer);
ParsedSymbol name=lexer.lex();
if (name.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
name_index=0;
}
 else {
expected(name,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)name.value,true);
}
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAME:
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
ParsedSymbol rtqName=lexer.lex();
if (rtqName.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
name_index=0;
}
 else {
expected(rtqName,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)rtqName.value,true);
}
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_RTQNAMEL:
case ParsedSymbol.TYPE_KEYWORD_RTQNAMELA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAME:
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
ParsedSymbol mName=lexer.lex();
if (mName.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
name_index=0;
}
 else {
expected(mName,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
name_index=constants.getStringId((String)mName.value,true);
}
expected(ParsedSymbol.TYPE_COMMA,""String_Node_Str"",lexer);
namespace_set_index=parseNamespaceSet(constants,lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_MULTINAMEL:
case ParsedSymbol.TYPE_KEYWORD_MULTINAMELA:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
namespace_set_index=parseNamespaceSet(constants,lexer);
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_TYPENAME:
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
qname_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_LOWERTHAN,""String_Node_Str"",lexer);
params.add(parseMultiName(constants,lexer));
ParsedSymbol nt=lexer.lex();
while (nt.type == ParsedSymbol.TYPE_COMMA) {
params.add(parseMultiName(constants,lexer));
nt=lexer.lex();
}
expected(nt,ParsedSymbol.TYPE_GREATERTHAN,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
}
return constants.getMultinameId(new Multiname(kind,name_index,namespace_index,namespace_set_index,qname_index,params),true);
}",0.9697593617295072
61737,"public void generateTraitsPhase2(String pkg,List<GraphTargetItem> items,Trait[] traits,List<Integer> openedNamespaces,SourceGeneratorLocalData localData) throws CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
 else     if (item instanceof InterfaceAVM2Item) {
      traits[k].name_index=traitName(((InterfaceAVM2Item)item).namespace,((InterfaceAVM2Item)item).name);
    }
 else     if (item instanceof ClassAVM2Item) {
      traits[k].name_index=traitName(((ClassAVM2Item)item).namespace,((ClassAVM2Item)item).className);
    }
 else     if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      traits[k].name_index=traitName(genNs(((MethodAVM2Item)item).customNamespace,((MethodAVM2Item)item).namespace,openedNamespaces,localData),((MethodAVM2Item)item).functionName);
    }
 else     if (item instanceof FunctionAVM2Item) {
      traits[k].name_index=traitName(((FunctionAVM2Item)item).namespace,((FunctionAVM2Item)item).functionName);
    }
 else     if (item instanceof ConstAVM2Item) {
      traits[k].name_index=traitName(genNs(((ConstAVM2Item)item).customNamespace,((ConstAVM2Item)item).getNamespace(),openedNamespaces,localData),((ConstAVM2Item)item).var);
    }
 else     if (item instanceof SlotAVM2Item) {
      traits[k].name_index=traitName(genNs(((SlotAVM2Item)item).customNamespace,((SlotAVM2Item)item).getNamespace(),openedNamespaces,localData),((SlotAVM2Item)item).var);
    }
  }
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof ClassAVM2Item) {
      InstanceInfo instanceInfo=abc.instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abc.constants.addMultiname(new Multiname(Multiname.QNAME,abc.constants.getStringId(((ClassAVM2Item)item).className,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()));
      if (((ClassAVM2Item)item).extendsOp != null) {
        instanceInfo.super_index=typeName(localData,((ClassAVM2Item)item).extendsOp);
      }
 else {
        instanceInfo.super_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(""String_Node_Str""),namespace(Namespace.KIND_PACKAGE,""String_Node_Str""),0,0,new ArrayList<Integer>()),true);
      }
      instanceInfo.interfaces=new int[((ClassAVM2Item)item).implementsOp.size()];
      for (int i=0; i < ((ClassAVM2Item)item).implementsOp.size(); i++) {
        instanceInfo.interfaces[i]=superIntName(((ClassAVM2Item)item).implementsOp.get(i));
      }
    }
    if (item instanceof InterfaceAVM2Item) {
      InstanceInfo instanceInfo=abc.instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abc.constants.addMultiname(new Multiname(Multiname.QNAME,abc.constants.getStringId(((InterfaceAVM2Item)item).name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()));
      instanceInfo.interfaces=new int[((InterfaceAVM2Item)item).superInterfaces.size()];
      for (int i=0; i < ((InterfaceAVM2Item)item).superInterfaces.size(); i++) {
        GraphTargetItem un=((InterfaceAVM2Item)item).superInterfaces.get(i);
        instanceInfo.interfaces[i]=superIntName(un);
      }
    }
  }
}","public void generateTraitsPhase2(String pkg,List<GraphTargetItem> items,Trait[] traits,List<Integer> openedNamespaces,SourceGeneratorLocalData localData) throws CompilationException {
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
 else     if (item instanceof InterfaceAVM2Item) {
      traits[k].name_index=traitName(((InterfaceAVM2Item)item).namespace,((InterfaceAVM2Item)item).name);
    }
 else     if (item instanceof ClassAVM2Item) {
      traits[k].name_index=traitName(((ClassAVM2Item)item).namespace,((ClassAVM2Item)item).className);
    }
 else     if ((item instanceof MethodAVM2Item) || (item instanceof GetterAVM2Item) || (item instanceof SetterAVM2Item)) {
      traits[k].name_index=traitName(genNs(pkg,((MethodAVM2Item)item).customNamespace,((MethodAVM2Item)item).namespace,openedNamespaces,localData,((MethodAVM2Item)item).line),((MethodAVM2Item)item).functionName);
    }
 else     if (item instanceof FunctionAVM2Item) {
      traits[k].name_index=traitName(((FunctionAVM2Item)item).namespace,((FunctionAVM2Item)item).functionName);
    }
 else     if (item instanceof ConstAVM2Item) {
      traits[k].name_index=traitName(genNs(pkg,((ConstAVM2Item)item).customNamespace,((ConstAVM2Item)item).getNamespace(),openedNamespaces,localData,((ConstAVM2Item)item).line),((ConstAVM2Item)item).var);
    }
 else     if (item instanceof SlotAVM2Item) {
      traits[k].name_index=traitName(genNs(pkg,((SlotAVM2Item)item).customNamespace,((SlotAVM2Item)item).getNamespace(),openedNamespaces,localData,((SlotAVM2Item)item).line),((SlotAVM2Item)item).var);
    }
  }
  for (int k=0; k < items.size(); k++) {
    GraphTargetItem item=items.get(k);
    if (traits[k] == null) {
      continue;
    }
    if (item instanceof ClassAVM2Item) {
      InstanceInfo instanceInfo=abc.instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abc.constants.addMultiname(new Multiname(Multiname.QNAME,abc.constants.getStringId(((ClassAVM2Item)item).className,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()));
      if (((ClassAVM2Item)item).extendsOp != null) {
        instanceInfo.super_index=typeName(localData,((ClassAVM2Item)item).extendsOp);
      }
 else {
        instanceInfo.super_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(""String_Node_Str""),namespace(Namespace.KIND_PACKAGE,""String_Node_Str""),0,0,new ArrayList<Integer>()),true);
      }
      instanceInfo.interfaces=new int[((ClassAVM2Item)item).implementsOp.size()];
      for (int i=0; i < ((ClassAVM2Item)item).implementsOp.size(); i++) {
        instanceInfo.interfaces[i]=superIntName(((ClassAVM2Item)item).implementsOp.get(i));
      }
    }
    if (item instanceof InterfaceAVM2Item) {
      InstanceInfo instanceInfo=abc.instance_info.get(((TraitClass)traits[k]).class_info);
      instanceInfo.name_index=abc.constants.addMultiname(new Multiname(Multiname.QNAME,abc.constants.getStringId(((InterfaceAVM2Item)item).name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()));
      instanceInfo.interfaces=new int[((InterfaceAVM2Item)item).superInterfaces.size()];
      for (int i=0; i < ((InterfaceAVM2Item)item).superInterfaces.size(); i++) {
        GraphTargetItem un=((InterfaceAVM2Item)item).superInterfaces.get(i);
        instanceInfo.interfaces[i]=superIntName(un);
      }
    }
  }
}",0.9868847835284164
61738,"public static int resolveType(TypeItem type,ABC abc){
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  int name_index=0;
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname.getName(abc.constants,new ArrayList<String>()).equals(name)) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
  }
  if (type.subtypes.isEmpty()) {
    return name_index;
  }
  List<Integer> params=new ArrayList<>();
  for (  String s : type.subtypes) {
    params.add(resolveType(new TypeItem(s),abc));
  }
  return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
}","public static int resolveType(TypeItem type,ABC abc){
  String name=type.fullTypeName;
  String pkg=""String_Node_Str"";
  int name_index=0;
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname.getName(abc.constants,new ArrayList<String>()).equals(name)) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        name_index=ii.name_index;
        break;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (mname.getNamespace(abc.constants) != null && pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        name_index=i;
        break;
      }
    }
  }
  if (name_index == 0) {
    name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
  }
  if (type.subtypes.isEmpty()) {
    return name_index;
  }
  List<Integer> params=new ArrayList<>();
  for (  String s : type.subtypes) {
    params.add(resolveType(new TypeItem(s),abc));
  }
  return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,name_index,params),true);
}",0.9857188194224056
61739,"public ValueKind getValueKind(int nsKind,GraphTargetItem type,GraphTargetItem val){
  if (val instanceof BooleanAVM2Item) {
    BooleanAVM2Item bi=(BooleanAVM2Item)val;
    if (bi.value) {
      return new ValueKind(0,ValueKind.CONSTANT_True);
    }
 else {
      return new ValueKind(0,ValueKind.CONSTANT_False);
    }
  }
  boolean isNs=false;
  if (type instanceof NameAVM2Item) {
    if (((NameAVM2Item)type).getVariableName().equals(""String_Node_Str"")) {
      isNs=true;
    }
  }
  if ((type instanceof TypeItem) && (((TypeItem)type).fullTypeName.equals(""String_Node_Str""))) {
    isNs=true;
  }
  if (val instanceof StringAVM2Item) {
    StringAVM2Item sval=(StringAVM2Item)val;
    if (isNs) {
      return new ValueKind(namespace(nsKind,sval.value),Namespace.KIND_NAMESPACE);
    }
 else {
      return new ValueKind(str(sval.value),ValueKind.CONSTANT_Utf8);
    }
  }
  if (val instanceof IntegerValueAVM2Item) {
    return new ValueKind(abc.constants.getIntId(((IntegerValueAVM2Item)val).value,true),ValueKind.CONSTANT_Int);
  }
  if (val instanceof FloatValueAVM2Item) {
    return new ValueKind(abc.constants.getIntId(((IntegerValueAVM2Item)val).value,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NullAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Null);
  }
  if (val instanceof UndefinedAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Undefined);
  }
  return null;
}","public ValueKind getValueKind(int nsKind,GraphTargetItem type,GraphTargetItem val){
  if (val instanceof BooleanAVM2Item) {
    BooleanAVM2Item bi=(BooleanAVM2Item)val;
    if (bi.value) {
      return new ValueKind(0,ValueKind.CONSTANT_True);
    }
 else {
      return new ValueKind(0,ValueKind.CONSTANT_False);
    }
  }
  boolean isNs=false;
  if (type instanceof NameAVM2Item) {
    if (((NameAVM2Item)type).getVariableName().equals(""String_Node_Str"")) {
      isNs=true;
    }
  }
  if ((type instanceof TypeItem) && (((TypeItem)type).fullTypeName.equals(""String_Node_Str""))) {
    isNs=true;
  }
  if (val instanceof StringAVM2Item) {
    StringAVM2Item sval=(StringAVM2Item)val;
    if (isNs) {
      return new ValueKind(namespace(nsKind,sval.value),Namespace.KIND_NAMESPACE);
    }
 else {
      return new ValueKind(str(sval.value),ValueKind.CONSTANT_Utf8);
    }
  }
  if (val instanceof IntegerValueAVM2Item) {
    return new ValueKind(abc.constants.getIntId(((IntegerValueAVM2Item)val).value,true),ValueKind.CONSTANT_Int);
  }
  if (val instanceof FloatValueAVM2Item) {
    return new ValueKind(abc.constants.getDoubleId(((FloatValueAVM2Item)val).value,true),ValueKind.CONSTANT_Double);
  }
  if (val instanceof NullAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Null);
  }
  if (val instanceof UndefinedAVM2Item) {
    return new ValueKind(0,ValueKind.CONSTANT_Undefined);
  }
  return null;
}",0.989072964399013
61740,"public static boolean searchPrototypeChain(boolean instanceOnly,List<ABC> abcs,String pkg,String obj,String propertyName,Reference<String> outName,Reference<String> outNs,Reference<String> outPropNs,Reference<Integer> outPropNsKind,Reference<String> outPropType,Reference<ValueKind> outPropValue){
  for (  ABC abc : abcs) {
    if (!instanceOnly) {
      for (      ScriptInfo ii : abc.script_info) {
        for (        Trait t : ii.traits.traits) {
          if (pkg.equals(t.getName(abc).getNamespace(abc.constants).getName(abc.constants))) {
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t).toString());
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
        }
      }
    }
    for (int i=0; i < abc.instance_info.size(); i++) {
      InstanceInfo ii=abc.instance_info.get(i);
      Multiname clsName=ii.getName(abc.constants);
      if (obj.equals(clsName.getName(abc.constants,new ArrayList<String>()))) {
        if (pkg.equals(clsName.getNamespace(abc.constants).getName(abc.constants))) {
          for (          Trait t : ii.instance_traits.traits) {
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t).toString());
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
          if (!instanceOnly) {
            for (            Trait t : abc.class_info.get(i).static_traits.traits) {
              if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
                outName.setVal(obj);
                outNs.setVal(pkg);
                outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
                outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
                outPropType.setVal(getTraitReturnType(abc,t).toString());
                if (t instanceof TraitSlotConst) {
                  TraitSlotConst tsc=(TraitSlotConst)t;
                  outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
                }
                return true;
              }
            }
          }
          Multiname superName=abc.constants.constant_multiname.get(ii.super_index);
          if (superName != null) {
            return searchPrototypeChain(instanceOnly,abcs,superName.getNamespace(abc.constants).getName(abc.constants),superName.getName(abc.constants,new ArrayList<String>()),propertyName,outName,outNs,outPropNs,outPropNsKind,outPropType,outPropValue);
          }
 else {
            return false;
          }
        }
      }
    }
  }
  return false;
}","public static boolean searchPrototypeChain(boolean instanceOnly,List<ABC> abcs,String pkg,String obj,String propertyName,Reference<String> outName,Reference<String> outNs,Reference<String> outPropNs,Reference<Integer> outPropNsKind,Reference<String> outPropType,Reference<ValueKind> outPropValue){
  for (  ABC abc : abcs) {
    if (!instanceOnly) {
      for (      ScriptInfo ii : abc.script_info) {
        for (        Trait t : ii.traits.traits) {
          if (pkg.equals(t.getName(abc).getNamespace(abc.constants).getName(abc.constants))) {
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t).toString());
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
        }
      }
    }
    for (int i=0; i < abc.instance_info.size(); i++) {
      InstanceInfo ii=abc.instance_info.get(i);
      Multiname clsName=ii.getName(abc.constants);
      if (obj.equals(clsName.getName(abc.constants,new ArrayList<String>()))) {
        if (pkg.equals(clsName.getNamespace(abc.constants).getName(abc.constants))) {
          for (          Trait t : ii.instance_traits.traits) {
            if (t.getName(abc) == null) {
              continue;
            }
            if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
              outName.setVal(obj);
              outNs.setVal(pkg);
              outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
              outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
              outPropType.setVal(getTraitReturnType(abc,t).toString());
              if (t instanceof TraitSlotConst) {
                TraitSlotConst tsc=(TraitSlotConst)t;
                outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
              }
              return true;
            }
          }
          if (!instanceOnly) {
            for (            Trait t : abc.class_info.get(i).static_traits.traits) {
              if (t.getName(abc) == null) {
                continue;
              }
              if (propertyName.equals(t.getName(abc).getName(abc.constants,new ArrayList<String>()))) {
                outName.setVal(obj);
                outNs.setVal(pkg);
                outPropNs.setVal(t.getName(abc).getNamespace(abc.constants).getName(abc.constants));
                outPropNsKind.setVal(t.getName(abc).getNamespace(abc.constants).kind);
                outPropType.setVal(getTraitReturnType(abc,t).toString());
                if (t instanceof TraitSlotConst) {
                  TraitSlotConst tsc=(TraitSlotConst)t;
                  outPropValue.setVal(new ValueKind(tsc.value_index,tsc.value_kind));
                }
                return true;
              }
            }
          }
          Multiname superName=abc.constants.constant_multiname.get(ii.super_index);
          if (superName != null) {
            return searchPrototypeChain(instanceOnly,abcs,superName.getNamespace(abc.constants).getName(abc.constants),superName.getName(abc.constants,new ArrayList<String>()),propertyName,outName,outNs,outPropNs,outPropNsKind,outPropType,outPropValue);
          }
 else {
            return false;
          }
        }
      }
    }
  }
  return false;
}",0.9776581426648722
61741,"private int genNs(String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData){
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<String>(""String_Node_Str""),new Reference<String>(""String_Node_Str""),new Reference<Integer>(0),value);
    namespace=value.getVal().value_index;
  }
  return namespace;
}","private int genNs(String pkg,String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData,int line) throws CompilationException {
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<String>(""String_Node_Str""),new Reference<String>(""String_Node_Str""),new Reference<Integer>(0),value);
    boolean resolved=true;
    if (value.getVal() == null) {
      resolved=false;
    }
    if (!resolved) {
      throw new CompilationException(""String_Node_Str"",line);
    }
    namespace=value.getVal().value_index;
  }
  return namespace;
}",0.819258089976322
61742,"public int method(List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        GraphTargetItem res=n.resolve(paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramTypes.get(i));
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  MethodBody mbody=new MethodBody();
  if (needsActivation) {
    mbody.traits=new Traits();
    int slotId=1;
    for (int i=1; i < slotNames.size(); i++) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.slot_id=slotId++;
      tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
      tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
      mbody.traits.traits.add(tsc);
    }
    for (int i=1; i < paramRegCount; i++) {
      NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
      param.setRegNumber(i);
      NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
      d.setSlotScope(slotScope);
      d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
      declarations.add(d);
    }
  }
  body.addAll(0,declarations);
  localData.exceptions=new ArrayList<>();
  localData.callStack.add(mbody);
  List<GraphSourceItem> src=generate(localData,body);
  mbody.method_info=abc.addMethodInfo(mi);
  mi.setBody(mbody);
  mbody.code=new AVM2Code();
  mbody.code.code=toInsList(src);
  if (needsActivation) {
    if (localData.traitUsages.containsKey(mbody)) {
      List<Integer> usages=localData.traitUsages.get(mbody);
      for (int i=0; i < mbody.traits.traits.size(); i++) {
        if (usages.contains(i)) {
          TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
          GraphTargetItem type=TypeItem.UNBOUNDED;
          if (tsc.type_index > 0) {
            type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
          }
          NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
          d.setSlotNumber(tsc.slot_id);
          d.setSlotScope(slotScope);
          mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
        }
      }
    }
    List<AVM2Instruction> acts=new ArrayList<>();
    acts.add(ins(new NewActivationIns()));
    acts.add(ins(new DupIns()));
    acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
    acts.add(ins(new PushScopeIns()));
    mbody.code.code.addAll(0,acts);
  }
  if (constructor) {
    List<ABC> abcs=new ArrayList<>();
    abcs.add(abc);
    abcs.addAll(allABCs);
    int parentConsAC=0;
    for (    ABC a : abcs) {
      int ci=a.findClassByName(superType);
      if (ci > -1) {
        MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
        parentConsAC=pmi.param_types.length;
      }
    }
    int ac=-1;
    for (    AVM2Instruction ins : mbody.code.code) {
      if (ins.definition instanceof ConstructSuperIns) {
        ac=ins.operands[0];
        if (parentConsAC != ac) {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (ac == -1) {
      if (parentConsAC == 0) {
        mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
        mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
      }
 else {
        throw new CompilationException(""String_Node_Str"",line);
      }
    }
  }
  if (className != null) {
    mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
    mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
  }
  if (!mbody.code.code.isEmpty()) {
    InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
    if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
  }
  mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
  int offset=0;
  for (int i=0; i < mbody.code.code.size(); i++) {
    AVM2Instruction ins=mbody.code.code.get(i);
    if (ins instanceof ExceptionMarkAVM2Instruction) {
      ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
        mbody.exceptions[m.exceptionId].start=offset;
      break;
case MARK_E_END:
    mbody.exceptions[m.exceptionId].end=offset;
  break;
case MARK_E_TARGET:
mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope);
abc.addMethodBody(mbody);
return mbody.method_info;
}","public int method(List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        String fullClass=localData.currentClass == null ? null : (localData.pkg.equals(""String_Node_Str"") ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
        GraphTargetItem res=n.resolve(new TypeItem(fullClass),paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (!n.getVariableName().equals(""String_Node_Str"") && needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      if (""String_Node_Str"".equals(n.getVariableName()) || paramNames.contains(n.getVariableName()) || ""String_Node_Str"".equals(n.getVariableName())) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramTypes.get(i));
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  MethodBody mbody=new MethodBody();
  if (needsActivation) {
    mbody.traits=new Traits();
    int slotId=1;
    for (int i=1; i < slotNames.size(); i++) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.slot_id=slotId++;
      tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
      tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
      mbody.traits.traits.add(tsc);
    }
    for (int i=1; i < paramRegCount; i++) {
      NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
      param.setRegNumber(i);
      NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
      d.setSlotScope(slotScope);
      d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
      declarations.add(d);
    }
  }
  body.addAll(0,declarations);
  localData.exceptions=new ArrayList<>();
  localData.callStack.add(mbody);
  List<GraphSourceItem> src=generate(localData,body);
  mbody.method_info=abc.addMethodInfo(mi);
  mi.setBody(mbody);
  mbody.code=new AVM2Code();
  mbody.code.code=toInsList(src);
  if (needsActivation) {
    if (localData.traitUsages.containsKey(mbody)) {
      List<Integer> usages=localData.traitUsages.get(mbody);
      for (int i=0; i < mbody.traits.traits.size(); i++) {
        if (usages.contains(i)) {
          TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
          GraphTargetItem type=TypeItem.UNBOUNDED;
          if (tsc.type_index > 0) {
            type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
          }
          NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
          d.setSlotNumber(tsc.slot_id);
          d.setSlotScope(slotScope);
          mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
        }
      }
    }
    List<AVM2Instruction> acts=new ArrayList<>();
    acts.add(ins(new NewActivationIns()));
    acts.add(ins(new DupIns()));
    acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
    acts.add(ins(new PushScopeIns()));
    mbody.code.code.addAll(0,acts);
  }
  if (constructor) {
    List<ABC> abcs=new ArrayList<>();
    abcs.add(abc);
    abcs.addAll(allABCs);
    int parentConsAC=0;
    for (    ABC a : abcs) {
      int ci=a.findClassByName(superType);
      if (ci > -1) {
        MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
        parentConsAC=pmi.param_types.length;
      }
    }
    int ac=-1;
    for (    AVM2Instruction ins : mbody.code.code) {
      if (ins.definition instanceof ConstructSuperIns) {
        ac=ins.operands[0];
        if (parentConsAC != ac) {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (ac == -1) {
      if (parentConsAC == 0) {
        mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
        mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
      }
 else {
        throw new CompilationException(""String_Node_Str"",line);
      }
    }
  }
  if (className != null) {
    mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
    mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
  }
  if (!mbody.code.code.isEmpty()) {
    InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
    if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
  }
  mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
  int offset=0;
  for (int i=0; i < mbody.code.code.size(); i++) {
    AVM2Instruction ins=mbody.code.code.get(i);
    if (ins instanceof ExceptionMarkAVM2Instruction) {
      ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
        mbody.exceptions[m.exceptionId].start=offset;
      break;
case MARK_E_END:
    mbody.exceptions[m.exceptionId].end=offset;
  break;
case MARK_E_TARGET:
mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope);
abc.addMethodBody(mbody);
return mbody.method_info;
}",0.981208393022668
61743,"public int typeName(SourceGeneratorLocalData localData,GraphTargetItem type) throws CompilationException {
  if (type instanceof UnboundedTypeItem) {
    return 0;
  }
  if (type instanceof UnresolvedAVM2Item) {
    type=((UnresolvedAVM2Item)type).resolve(new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  String pkg=""String_Node_Str"";
  String name=type.toString();
  if (""String_Node_Str"".equals(name)) {
    return 0;
  }
  TypeItem nameItem=(TypeItem)type;
  name=nameItem.fullTypeName;
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  if (!nameItem.subtypes.isEmpty()) {
    List<Integer> params=new ArrayList<>();
    for (    String p : nameItem.subtypes) {
      String ppkg=""String_Node_Str"";
      if (p.contains(""String_Node_Str"")) {
        ppkg=p.substring(0,p.lastIndexOf('.'));
        p=p.substring(p.lastIndexOf('.') + 1);
      }
      params.add(abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(p),namespace(Namespace.KIND_PACKAGE,ppkg),0,0,new ArrayList<Integer>()),true));
    }
    int qname=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(name),namespace(Namespace.KIND_PACKAGE,pkg),0,0,new ArrayList<Integer>()),true);
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,qname,params),true);
  }
 else {
    return abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(name),namespace(Namespace.KIND_PACKAGE,pkg),0,0,new ArrayList<Integer>()),true);
  }
}","public int typeName(SourceGeneratorLocalData localData,GraphTargetItem type) throws CompilationException {
  if (type instanceof UnboundedTypeItem) {
    return 0;
  }
  if (type instanceof UnresolvedAVM2Item) {
    String fullClass=localData.currentClass == null ? null : (localData.pkg.equals(""String_Node_Str"") ? localData.currentClass : localData.pkg + ""String_Node_Str"" + localData.currentClass);
    type=((UnresolvedAVM2Item)type).resolve(new TypeItem(fullClass),new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,allABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>());
  }
  String pkg=""String_Node_Str"";
  String name=type.toString();
  if (""String_Node_Str"".equals(name)) {
    return 0;
  }
  TypeItem nameItem=(TypeItem)type;
  name=nameItem.fullTypeName;
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf('.'));
    name=name.substring(name.lastIndexOf('.') + 1);
  }
  if (!nameItem.subtypes.isEmpty()) {
    List<Integer> params=new ArrayList<>();
    for (    String p : nameItem.subtypes) {
      String ppkg=""String_Node_Str"";
      if (p.contains(""String_Node_Str"")) {
        ppkg=p.substring(0,p.lastIndexOf('.'));
        p=p.substring(p.lastIndexOf('.') + 1);
      }
      params.add(abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(p),namespace(Namespace.KIND_PACKAGE,ppkg),0,0,new ArrayList<Integer>()),true));
    }
    int qname=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(name),namespace(Namespace.KIND_PACKAGE,pkg),0,0,new ArrayList<Integer>()),true);
    return abc.constants.getMultinameId(new Multiname(Multiname.TYPENAME,0,0,0,qname,params),true);
  }
 else {
    return abc.constants.getMultinameId(new Multiname(Multiname.QNAME,str(name),namespace(Namespace.KIND_PACKAGE,pkg),0,0,new ArrayList<Integer>()),true);
  }
}",0.936280137772675
61744,"private int genNs(String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData){
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,null,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<String>(""String_Node_Str""),new Reference<String>(""String_Node_Str""),new Reference<Integer>(0),value);
    namespace=value.getVal().value_index;
  }
  return namespace;
}","private int genNs(String custom,int namespace,List<Integer> openedNamespaces,SourceGeneratorLocalData localData){
  if (custom != null) {
    PropertyAVM2Item prop=new PropertyAVM2Item(null,custom,abc,allABCs,openedNamespaces,new ArrayList<MethodBody>());
    Reference<ValueKind> value=new Reference<>(null);
    prop.resolve(localData,new Reference<String>(""String_Node_Str""),new Reference<String>(""String_Node_Str""),new Reference<Integer>(0),value);
    namespace=value.getVal().value_index;
  }
  return namespace;
}",0.9952153110047848
61745,"private GraphTargetItem classTraits(int packageInternalNs,List<String> importedClasses,int privateNs,boolean isDynamic,boolean isFinal,List<Integer> openedNamespaces,String packageName,int namespace,boolean isInterface,String nameStr,GraphTargetItem extendsStr,List<GraphTargetItem> implementsStr,List<AssignableAVM2Item> variables) throws IOException, ParseException, CompilationException {
  GraphTargetItem ret=null;
  ParsedSymbol s=null;
  List<GraphTargetItem> traits=new ArrayList<>();
  String classNameStr=nameStr;
  openedNamespaces=new ArrayList<>(openedNamespaces);
  int protectedNs=0;
  int publicNs=namespace;
  int protectedStaticNs=0;
  openedNamespaces.add(protectedNs=abc.constants.addNamespace(new Namespace(Namespace.KIND_PROTECTED,abc.constants.getStringId(packageName.isEmpty() ? classNameStr : packageName + ""String_Node_Str"" + classNameStr,true))));
  openedNamespaces.add(protectedStaticNs=abc.constants.addNamespace(new Namespace(Namespace.KIND_STATIC_PROTECTED,abc.constants.getStringId(packageName.isEmpty() ? classNameStr : packageName + ""String_Node_Str"" + classNameStr,true))));
  List<Integer> indices=new ArrayList<>();
  List<String> names=new ArrayList<>();
  List<String> namespaces=new ArrayList<>();
  AVM2SourceGenerator.parentNamesAddNames(abc,otherABCs,AVM2SourceGenerator.resolveType(((TypeItem)((UnresolvedAVM2Item)extendsStr).resolve(new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>())),abc),indices,names,namespaces);
  for (int i=0; i < names.size(); i++) {
    if (namespaces.get(i).isEmpty()) {
      continue;
    }
    openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_STATIC_PROTECTED,abc.constants.getStringId(namespaces.get(i) + ""String_Node_Str"" + names.get(i),true)),0,true));
  }
  Reference<Boolean> staticNeedsActivation=new Reference<>(false);
  List<GraphTargetItem> staticInit=new ArrayList<>();
  List<AssignableAVM2Item> sinitVariables=new ArrayList<>();
  GraphTargetItem constr=traits(sinitVariables,staticNeedsActivation,staticInit,importedClasses,privateNs,protectedNs,publicNs,packageInternalNs,protectedStaticNs,openedNamespaces,packageName,classNameStr,isInterface,traits);
  if (isInterface) {
    return new InterfaceAVM2Item(openedNamespaces,isFinal,namespace,classNameStr,implementsStr,traits);
  }
 else {
    return new ClassAVM2Item(openedNamespaces,protectedNs,isDynamic,isFinal,namespace,classNameStr,extendsStr,implementsStr,staticInit,staticNeedsActivation.getVal(),sinitVariables,constr,traits);
  }
}","private GraphTargetItem classTraits(int packageInternalNs,List<String> importedClasses,int privateNs,boolean isDynamic,boolean isFinal,List<Integer> openedNamespaces,String packageName,int namespace,boolean isInterface,String nameStr,GraphTargetItem extendsStr,List<GraphTargetItem> implementsStr,List<AssignableAVM2Item> variables) throws IOException, ParseException, CompilationException {
  GraphTargetItem ret=null;
  ParsedSymbol s=null;
  List<GraphTargetItem> traits=new ArrayList<>();
  String classNameStr=nameStr;
  openedNamespaces=new ArrayList<>(openedNamespaces);
  int protectedNs=0;
  int publicNs=namespace;
  int protectedStaticNs=0;
  openedNamespaces.add(protectedNs=abc.constants.addNamespace(new Namespace(Namespace.KIND_PROTECTED,abc.constants.getStringId(packageName.isEmpty() ? classNameStr : packageName + ""String_Node_Str"" + classNameStr,true))));
  openedNamespaces.add(protectedStaticNs=abc.constants.addNamespace(new Namespace(Namespace.KIND_STATIC_PROTECTED,abc.constants.getStringId(packageName.isEmpty() ? classNameStr : packageName + ""String_Node_Str"" + classNameStr,true))));
  List<Integer> indices=new ArrayList<>();
  List<String> names=new ArrayList<>();
  List<String> namespaces=new ArrayList<>();
  AVM2SourceGenerator.parentNamesAddNames(abc,otherABCs,AVM2SourceGenerator.resolveType(((TypeItem)((UnresolvedAVM2Item)extendsStr).resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),new ArrayList<AssignableAVM2Item>())),abc),indices,names,namespaces);
  for (int i=0; i < names.size(); i++) {
    if (namespaces.get(i).isEmpty()) {
      continue;
    }
    openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_STATIC_PROTECTED,abc.constants.getStringId(namespaces.get(i) + ""String_Node_Str"" + names.get(i),true)),0,true));
  }
  Reference<Boolean> staticNeedsActivation=new Reference<>(false);
  List<GraphTargetItem> staticInit=new ArrayList<>();
  List<AssignableAVM2Item> sinitVariables=new ArrayList<>();
  GraphTargetItem constr=traits(sinitVariables,staticNeedsActivation,staticInit,importedClasses,privateNs,protectedNs,publicNs,packageInternalNs,protectedStaticNs,openedNamespaces,packageName,classNameStr,isInterface,traits);
  if (isInterface) {
    return new InterfaceAVM2Item(openedNamespaces,isFinal,namespace,classNameStr,implementsStr,traits);
  }
 else {
    return new ClassAVM2Item(openedNamespaces,protectedNs,isDynamic,isFinal,namespace,classNameStr,extendsStr,implementsStr,staticInit,staticNeedsActivation.getVal(),sinitVariables,constr,traits);
  }
}",0.9990382765916522
61746,"private GraphTargetItem member(Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,GraphTargetItem obj,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables) throws IOException, ParseException {
  GraphTargetItem ret=obj;
  ParsedSymbol s=lex();
  while (s.isType(SymbolType.DOT)) {
    s=lex();
    boolean attr=false;
    if (s.type == SymbolType.ATTRIBUTE) {
      attr=true;
      s=lex();
    }
    expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
    String propName=s.value.toString();
    s=lex();
    GraphTargetItem ns=null;
    if (s.type == SymbolType.NAMESPACE_OP) {
      s=lex();
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
      ns=new UnresolvedAVM2Item(new ArrayList<String>(),importedClasses,false,null,lexer.yyline(),propName,null,openedNamespaces);
      variables.add((UnresolvedAVM2Item)ns);
      propName=s.value.toString();
      s=lex();
    }
    GraphTargetItem index=null;
    if (s.type == SymbolType.BRACKET_OPEN) {
      index=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
      expectedType(SymbolType.BRACKET_CLOSE);
    }
 else {
      lexer.pushback(s);
    }
    if (ns != null) {
      ret=new NamespacedAVM2Item(index,ns,propName,ret,attr,openedNamespaces,null);
    }
 else {
      ret=new PropertyAVM2Item(ret,(attr ? ""String_Node_Str"" : ""String_Node_Str"") + propName,index,abc,otherABCs,openedNamespaces,new ArrayList<MethodBody>());
    }
    s=lex();
  }
  lexer.pushback(s);
  return ret;
}","private GraphTargetItem member(Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,GraphTargetItem obj,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables) throws IOException, ParseException {
  GraphTargetItem ret=obj;
  ParsedSymbol s=lex();
  while (s.isType(SymbolType.DOT,SymbolType.BRACKET_OPEN)) {
    ParsedSymbol s2=lex();
    boolean attr=false;
    if (s.type == SymbolType.DOT) {
      if (s2.type == SymbolType.ATTRIBUTE) {
        attr=true;
        s=lex();
      }
 else {
        lexer.pushback(s2);
      }
    }
 else {
      lexer.pushback(s2);
    }
    if (s.type == SymbolType.BRACKET_OPEN) {
      GraphTargetItem index=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
      expectedType(SymbolType.BRACKET_CLOSE);
      ret=new IndexAVM2Item(attr,ret,index,null,openedNamespaces);
      s=lex();
    }
 else {
      s=lex();
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
      String propName=s.value.toString();
      s=lex();
      GraphTargetItem ns=null;
      if (s.type == SymbolType.NAMESPACE_OP) {
        s=lex();
        expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
        ns=new UnresolvedAVM2Item(new ArrayList<String>(),importedClasses,false,null,lexer.yyline(),propName,null,openedNamespaces);
        variables.add((UnresolvedAVM2Item)ns);
        propName=s.value.toString();
      }
 else {
        lexer.pushback(s);
      }
      if (ns != null) {
        ret=new NamespacedAVM2Item(ns,propName,ret,attr,openedNamespaces,null);
      }
 else {
        ret=new PropertyAVM2Item(ret,(attr ? ""String_Node_Str"" : ""String_Node_Str"") + propName,abc,otherABCs,openedNamespaces,new ArrayList<MethodBody>());
      }
      s=lex();
    }
  }
  lexer.pushback(s);
  return ret;
}",0.7133466704772792
61747,"private GraphTargetItem command(Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,Stack<Loop> loops,Map<Loop,String> loopLabels,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<AssignableAVM2Item> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
  String loopLabel=null;
  if (s.type == SymbolType.IDENTIFIER) {
    ParsedSymbol sc=lex();
    if (sc.type == SymbolType.COLON) {
      loopLabel=s.value.toString();
      s=lex();
    }
 else {
      lexer.pushback(sc);
    }
  }
  if (s.type == SymbolType.DEFAULT) {
    ParsedSymbol sx=lex();
    if (sx.type != SymbolType.IDENTIFIER) {
      lexer.pushback(sx);
    }
 else {
      if (!sx.value.equals(""String_Node_Str"")) {
        lexer.pushback(sx);
      }
 else {
        expectedType(SymbolType.NAMESPACE);
        expectedType(SymbolType.ASSIGN);
        GraphTargetItem ns=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
        ret=new DefaultXMLNamespace(null,ns);
      }
    }
  }
  if (ret == null) {
switch (s.type) {
case USE:
      expectedType(SymbolType.NAMESPACE);
    GraphTargetItem ns=type(needsActivation,importedClasses,openedNamespaces,variables);
  openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(ns.toString(),true)),0,true));
break;
case WITH:
needsActivation.setVal(true);
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(wvar)) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<AssignableAVM2Item> withVars=new ArrayList<>();
List<GraphTargetItem> wcmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,withVars);
variables.addAll(withVars);
for (AssignableAVM2Item a : withVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ua=(UnresolvedAVM2Item)a;
ua.scopeStack.add(0,wvar);
}
}
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithAVM2Item(null,wvar,wcmd);
((WithAVM2Item)ret).subvariables=withVars;
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
needsActivation.setVal(true);
ret=(function(needsActivation,importedClasses,0,TypeItem.UNBOUNDED,openedNamespaces,true,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
GraphTargetItem type;
if (s.type == SymbolType.COLON) {
type=type(needsActivation,importedClasses,openedNamespaces,variables);
s=lex();
}
 else {
type=new UnboundedTypeItem();
}
if (s.type == SymbolType.ASSIGN) {
GraphTargetItem varval=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,varval,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
}
 else {
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,null,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case SUPER:
ParsedSymbol ss2=lex();
if (ss2.type == SymbolType.PARENT_OPEN) {
List<GraphTargetItem> args=call(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
ret=new ConstructSuperAVM2Item(null,new LocalRegAVM2Item(null,0,null),args);
}
 else {
lexer.pushback(ss2);
lexer.pushback(s);
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
Loop wloop=new Loop(uniqId(),null,null);
if (loopLabel != null) {
loopLabels.put(wloop,loopLabel);
}
loops.push(wloop);
whileBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,wloop,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
Loop dloop=new Loop(uniqId(),null,null);
loops.push(dloop);
if (loopLabel != null) {
loopLabels.put(dloop,loopLabel);
}
doBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,dloop,doBody,doExpr);
break;
case FOR:
s=lex();
boolean forin=false;
boolean each=false;
GraphTargetItem collection=null;
if (s.type == SymbolType.EACH) {
each=true;
forin=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolType.PARENT_OPEN);
GraphTargetItem firstCommand=command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,false,variables);
if (firstCommand instanceof NameAVM2Item) {
NameAVM2Item nai=(NameAVM2Item)firstCommand;
if (nai.isDefinition() && nai.getAssignedValue() == null) {
firstCommand=expressionRemainder(needsActivation,openedNamespaces,firstCommand,registerVars,inFunction,inMethod,true,variables,importedClasses);
}
}
InAVM2Item inexpr=null;
if (firstCommand instanceof InAVM2Item) {
forin=true;
inexpr=(InAVM2Item)firstCommand;
}
 else {
if (forin) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
Loop floop=new Loop(uniqId(),null,null);
loops.push(floop);
if (loopLabel != null) {
loopLabels.put(floop,loopLabel);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
if (firstCommand != null) {
forFirstCommands.add(firstCommand);
}
forExpr=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
if (each) {
ret=new ForEachInAVM2Item(null,floop,inexpr,forBody);
}
 else {
ret=new ForInAVM2Item(null,floop,inexpr,forBody);
}
}
 else {
ret=new ForItem(null,floop,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
Loop sloop=new Loop(-uniqId(),null,null);
loops.push(sloop);
if (loopLabel != null) {
loopLabels.put(sloop,loopLabel);
}
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,sloop,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
s=lex();
long bloopId=0;
if (loops.isEmpty()) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.IDENTIFIER) {
String breakLabel=s.value.toString();
for (Loop l : loops) {
if (breakLabel.equals(loopLabels.get(l))) {
bloopId=l.id;
break;
}
}
if (bloopId == 0) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
bloopId=loops.peek().id;
}
ret=new BreakItem(null,bloopId);
break;
case CONTINUE:
s=lex();
long cloopId=0;
if (loops.isEmpty()) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.IDENTIFIER) {
String continueLabel=s.value.toString();
for (Loop l : loops) {
if (l.id < 0) {
continue;
}
if (continueLabel.equals(loopLabels.get(l))) {
cloopId=l.id;
break;
}
}
if (cloopId == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
for (int i=loops.size() - 1; i >= 0; i--) {
if (loops.get(i).id >= 0) {
cloopId=loops.get(i).id;
break;
}
}
if (cloopId <= 0) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
ret=new ContinueItem(null,cloopId);
break;
case RETURN:
GraphTargetItem retexpr=expression(needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
ret=new ReturnVoidAVM2Item(null);
}
 else {
ret=new ReturnValueAVM2Item(null,retexpr);
}
break;
case TRY:
needsActivation.setVal(true);
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=new ArrayList<>();
List<NameAVM2Item> catchExceptions=new ArrayList<>();
int varCnt=variables.size();
List<List<AssignableAVM2Item>> catchesVars=new ArrayList<>();
while (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
String enamestr=s.value.toString();
expectedType(SymbolType.COLON);
GraphTargetItem etype=type(needsActivation,importedClasses,openedNamespaces,variables);
NameAVM2Item e=new NameAVM2Item(etype,lexer.yyline(),enamestr,new ExceptionAVM2Item(null),true,openedNamespaces);
variables.add(e);
catchExceptions.add(e);
e.setSlotNumber(1);
e.setSlotScope(Integer.MAX_VALUE);
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> cc=new ArrayList<>();
List<AssignableAVM2Item> catchVars=new ArrayList<>();
cc.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,catchVars));
catchesVars.add(catchVars);
variables.addAll(catchVars);
for (AssignableAVM2Item a : catchVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)a;
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
catchCommands.add(cc);
s=lex();
found=true;
}
for (int i=varCnt; i < variables.size(); i++) {
AssignableAVM2Item av=variables.get(i);
if (av instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)av;
for (NameAVM2Item e : catchExceptions) {
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
TryAVM2Item tai=new TryAVM2Item(tryCommands,null,catchCommands,finallyCommands);
tai.catchVariables=catchesVars;
tai.catchExceptions2=catchExceptions;
ret=tai;
break;
case THROW:
ret=new ThrowAVM2Item(null,expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type == SymbolType.SEMICOLON) {
return null;
}
lexer.pushback(s);
ret=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (debugMode) {
System.out.println(""String_Node_Str"");
}
}
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}","private GraphTargetItem command(Reference<Boolean> needsActivation,List<String> importedClasses,List<Integer> openedNamespaces,Stack<Loop> loops,Map<Loop,String> loopLabels,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<AssignableAVM2Item> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
  String loopLabel=null;
  if (s.type == SymbolType.IDENTIFIER) {
    ParsedSymbol sc=lex();
    if (sc.type == SymbolType.COLON) {
      loopLabel=s.value.toString();
      s=lex();
    }
 else {
      lexer.pushback(sc);
    }
  }
  if (s.type == SymbolType.DEFAULT) {
    ParsedSymbol sx=lex();
    if (sx.type != SymbolType.IDENTIFIER) {
      lexer.pushback(sx);
    }
 else {
      if (!sx.value.equals(""String_Node_Str"")) {
        lexer.pushback(sx);
      }
 else {
        expectedType(SymbolType.NAMESPACE);
        expectedType(SymbolType.ASSIGN);
        GraphTargetItem ns=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
        ret=new DefaultXMLNamespace(null,ns);
      }
    }
  }
  if (ret == null) {
switch (s.type) {
case USE:
      expectedType(SymbolType.NAMESPACE);
    GraphTargetItem ns=type(needsActivation,importedClasses,openedNamespaces,variables);
  openedNamespaces.add(abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(ns.toString(),true)),0,true));
break;
case WITH:
needsActivation.setVal(true);
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (!isNameOrProp(wvar)) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<AssignableAVM2Item> withVars=new ArrayList<>();
List<GraphTargetItem> wcmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,withVars);
variables.addAll(withVars);
for (AssignableAVM2Item a : withVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ua=(UnresolvedAVM2Item)a;
ua.scopeStack.add(0,wvar);
}
}
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithAVM2Item(null,wvar,wcmd);
((WithAVM2Item)ret).subvariables=withVars;
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
needsActivation.setVal(true);
ret=(function(needsActivation,importedClasses,0,TypeItem.UNBOUNDED,openedNamespaces,true,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
GraphTargetItem type;
if (s.type == SymbolType.COLON) {
type=type(needsActivation,importedClasses,openedNamespaces,variables);
s=lex();
}
 else {
type=new UnboundedTypeItem();
}
if (s.type == SymbolType.ASSIGN) {
GraphTargetItem varval=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,varval,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
}
 else {
ret=new NameAVM2Item(type,lexer.yyline(),varIdentifier,null,true,openedNamespaces);
variables.add((NameAVM2Item)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case SUPER:
ParsedSymbol ss2=lex();
if (ss2.type == SymbolType.PARENT_OPEN) {
List<GraphTargetItem> args=call(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,variables);
ret=new ConstructSuperAVM2Item(null,new LocalRegAVM2Item(null,0,null),args);
}
 else {
lexer.pushback(ss2);
lexer.pushback(s);
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
Loop wloop=new Loop(uniqId(),null,null);
if (loopLabel != null) {
loopLabels.put(wloop,loopLabel);
}
loops.push(wloop);
whileBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,wloop,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
Loop dloop=new Loop(uniqId(),null,null);
loops.push(dloop);
if (loopLabel != null) {
loopLabels.put(dloop,loopLabel);
}
doBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,dloop,doBody,doExpr);
break;
case FOR:
s=lex();
boolean forin=false;
boolean each=false;
GraphTargetItem collection=null;
if (s.type == SymbolType.EACH) {
each=true;
forin=true;
s=lex();
}
expected(s,lexer.yyline(),SymbolType.PARENT_OPEN);
GraphTargetItem firstCommand=command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,false,variables);
if (firstCommand instanceof NameAVM2Item) {
NameAVM2Item nai=(NameAVM2Item)firstCommand;
if (nai.isDefinition() && nai.getAssignedValue() == null) {
firstCommand=expressionRemainder(needsActivation,openedNamespaces,firstCommand,registerVars,inFunction,inMethod,true,variables,importedClasses);
}
}
InAVM2Item inexpr=null;
if (firstCommand instanceof InAVM2Item) {
forin=true;
inexpr=(InAVM2Item)firstCommand;
}
 else {
if (forin) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
Loop floop=new Loop(uniqId(),null,null);
loops.push(floop);
if (loopLabel != null) {
loopLabels.put(floop,loopLabel);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
if (firstCommand != null) {
forFirstCommands.add(firstCommand);
}
forExpr=(expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
if (each) {
ret=new ForEachInAVM2Item(null,floop,inexpr,forBody);
}
 else {
ret=new ForInAVM2Item(null,floop,inexpr,forBody);
}
}
 else {
ret=new ForItem(null,floop,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
Loop sloop=new Loop(-uniqId(),null,null);
loops.push(sloop);
if (loopLabel != null) {
loopLabels.put(sloop,loopLabel);
}
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,sloop,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
s=lex();
long bloopId=0;
if (loops.isEmpty()) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.IDENTIFIER) {
String breakLabel=s.value.toString();
for (Loop l : loops) {
if (breakLabel.equals(loopLabels.get(l))) {
bloopId=l.id;
break;
}
}
if (bloopId == 0) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
bloopId=loops.peek().id;
}
ret=new BreakItem(null,bloopId);
break;
case CONTINUE:
s=lex();
long cloopId=0;
if (loops.isEmpty()) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
if (s.type == SymbolType.IDENTIFIER) {
String continueLabel=s.value.toString();
for (Loop l : loops) {
if (l.id < 0) {
continue;
}
if (continueLabel.equals(loopLabels.get(l))) {
cloopId=l.id;
break;
}
}
if (cloopId == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
for (int i=loops.size() - 1; i >= 0; i--) {
if (loops.get(i).id >= 0) {
cloopId=loops.get(i).id;
break;
}
}
if (cloopId <= 0) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
ret=new ContinueItem(null,cloopId);
break;
case RETURN:
GraphTargetItem retexpr=expression(needsActivation,importedClasses,openedNamespaces,true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
ret=new ReturnVoidAVM2Item(null);
}
 else {
ret=new ReturnValueAVM2Item(null,retexpr);
}
break;
case TRY:
needsActivation.setVal(true);
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=new ArrayList<>();
List<NameAVM2Item> catchExceptions=new ArrayList<>();
int varCnt=variables.size();
List<List<AssignableAVM2Item>> catchesVars=new ArrayList<>();
while (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
String enamestr=s.value.toString();
expectedType(SymbolType.COLON);
GraphTargetItem etype=type(needsActivation,importedClasses,openedNamespaces,variables);
NameAVM2Item e=new NameAVM2Item(etype,lexer.yyline(),enamestr,new ExceptionAVM2Item(null),true,openedNamespaces);
variables.add(e);
catchExceptions.add(e);
e.setSlotNumber(1);
e.setSlotScope(Integer.MAX_VALUE);
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> cc=new ArrayList<>();
List<AssignableAVM2Item> catchVars=new ArrayList<>();
cc.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,catchVars));
catchesVars.add(catchVars);
variables.addAll(catchVars);
for (AssignableAVM2Item a : catchVars) {
if (a instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)a;
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
catchCommands.add(cc);
s=lex();
found=true;
}
for (int i=varCnt; i < variables.size(); i++) {
AssignableAVM2Item av=variables.get(i);
if (av instanceof UnresolvedAVM2Item) {
UnresolvedAVM2Item ui=(UnresolvedAVM2Item)av;
for (NameAVM2Item e : catchExceptions) {
if (ui.getVariableName().equals(e.getVariableName())) {
try {
ui.resolve(null,new ArrayList<GraphTargetItem>(),new ArrayList<String>(),abc,otherABCs,new ArrayList<MethodBody>(),variables);
}
 catch (CompilationException ex) {
}
ui.setSlotNumber(e.getSlotNumber());
ui.setSlotScope(e.getSlotScope());
}
}
}
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(needsActivation,importedClasses,openedNamespaces,loops,loopLabels,registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
TryAVM2Item tai=new TryAVM2Item(tryCommands,null,catchCommands,finallyCommands);
tai.catchVariables=catchesVars;
tai.catchExceptions2=catchExceptions;
ret=tai;
break;
case THROW:
ret=new ThrowAVM2Item(null,expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type == SymbolType.SEMICOLON) {
return null;
}
lexer.pushback(s);
ret=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
if (debugMode) {
System.out.println(""String_Node_Str"");
}
}
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}",0.9996743095362168
61748,"private GraphTargetItem name(Reference<Boolean> needsActivation,boolean typeOnly,List<Integer> openedNamespaces,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables,List<String> importedClasses) throws IOException, ParseException {
  ParsedSymbol s=lex();
  String name=""String_Node_Str"";
  if (s.type == SymbolType.ATTRIBUTE) {
    name+=""String_Node_Str"";
    s=lex();
  }
  expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
  name+=s.value.toString();
  s=lex();
  while (s.isType(SymbolType.DOT)) {
    name+=s.value.toString();
    s=lex();
    if (s.type == SymbolType.ATTRIBUTE) {
      name+=""String_Node_Str"";
      s=lex();
      if (s.type == SymbolType.IDENTIFIER) {
        name+=s.value.toString();
      }
 else {
        if (s.type != SymbolType.BRACKET_OPEN) {
          throw new ParseException(""String_Node_Str"",lexer.yyline());
        }
        continue;
      }
    }
 else {
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.NAMESPACE);
      name+=s.value.toString();
    }
    s=lex();
  }
  String nsname=null;
  String nsprop=null;
  if (s.type == SymbolType.NAMESPACE_OP) {
    if (name.contains(""String_Node_Str"")) {
      nsname=name.substring(name.lastIndexOf('.') + 1);
    }
 else {
      nsname=name;
    }
    s=lex();
    if (s.type == SymbolType.IDENTIFIER) {
      nsprop=s.value.toString();
    }
 else {
      nsprop=null;
      lexer.pushback(s);
    }
    if (name.contains(""String_Node_Str"")) {
      name=name.substring(0,name.lastIndexOf('.'));
    }
 else {
      name=null;
    }
    s=lex();
  }
  List<String> params=new ArrayList<>();
  if (s.type == SymbolType.TYPENAME) {
    s=lex();
    do {
      String p=""String_Node_Str"";
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
      p=s.value.toString();
      s=lex();
      while (s.type == SymbolType.DOT) {
        s=lex();
        expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
        name+=""String_Node_Str"" + s.value.toString();
        s=lex();
      }
      params.add(p);
    }
 while (s.type == SymbolType.COMMA);
    expected(s,lexer.yyline(),SymbolType.GREATER_THAN);
    s=lex();
  }
  GraphTargetItem index=null;
  if (s.type == SymbolType.BRACKET_OPEN) {
    index=expression(needsActivation,importedClasses,openedNamespaces,registerVars,inFunction,inMethod,true,variables);
    expectedType(SymbolType.BRACKET_CLOSE);
  }
 else {
    lexer.pushback(s);
  }
  GraphTargetItem ret=null;
  if (name != null) {
    UnresolvedAVM2Item unr=new UnresolvedAVM2Item(params,importedClasses,typeOnly,null,lexer.yyline(),name,null,openedNamespaces);
    unr.setIndex(index);
    variables.add(unr);
    ret=unr;
  }
  if (nsname != null) {
    boolean attr=nsname.startsWith(""String_Node_Str"");
    if (attr) {
      nsname=nsname.substring(1);
    }
    UnresolvedAVM2Item ns=new UnresolvedAVM2Item(params,importedClasses,typeOnly,null,lexer.yyline(),nsname,null,openedNamespaces);
    variables.add(ns);
    ret=new NamespacedAVM2Item(index,ns,nsprop,ret,attr,openedNamespaces,null);
  }
  return ret;
}","private GraphTargetItem name(Reference<Boolean> needsActivation,boolean typeOnly,List<Integer> openedNamespaces,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<AssignableAVM2Item> variables,List<String> importedClasses) throws IOException, ParseException {
  ParsedSymbol s=lex();
  String name=""String_Node_Str"";
  if (s.type == SymbolType.ATTRIBUTE) {
    name+=""String_Node_Str"";
    s=lex();
  }
  expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.THIS,SymbolType.SUPER,SymbolType.STRING_OP);
  name+=s.value.toString();
  s=lex();
  boolean attrBracket=false;
  while (s.isType(SymbolType.DOT)) {
    name+=s.value.toString();
    s=lex();
    if (s.type == SymbolType.ATTRIBUTE) {
      name+=""String_Node_Str"";
      s=lex();
      if (s.type == SymbolType.IDENTIFIER) {
        name+=s.value.toString();
      }
 else {
        if (s.type != SymbolType.BRACKET_OPEN) {
          throw new ParseException(""String_Node_Str"",lexer.yyline());
        }
        attrBracket=true;
        continue;
      }
    }
 else {
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.NAMESPACE);
      name+=s.value.toString();
    }
    s=lex();
  }
  String nsname=null;
  String nsprop=null;
  if (s.type == SymbolType.NAMESPACE_OP) {
    if (name.contains(""String_Node_Str"")) {
      nsname=name.substring(name.lastIndexOf('.') + 1);
    }
 else {
      nsname=name;
    }
    s=lex();
    if (s.type == SymbolType.IDENTIFIER) {
      nsprop=s.value.toString();
    }
 else {
      nsprop=null;
      lexer.pushback(s);
    }
    if (name.contains(""String_Node_Str"")) {
      name=name.substring(0,name.lastIndexOf('.'));
    }
 else {
      name=null;
    }
    s=lex();
  }
  List<String> params=new ArrayList<>();
  if (s.type == SymbolType.TYPENAME) {
    s=lex();
    do {
      String p=""String_Node_Str"";
      expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
      p=s.value.toString();
      s=lex();
      while (s.type == SymbolType.DOT) {
        s=lex();
        expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
        name+=""String_Node_Str"" + s.value.toString();
        s=lex();
      }
      params.add(p);
    }
 while (s.type == SymbolType.COMMA);
    expected(s,lexer.yyline(),SymbolType.GREATER_THAN);
    s=lex();
  }
  GraphTargetItem ret=null;
  if (name != null) {
    UnresolvedAVM2Item unr=new UnresolvedAVM2Item(params,importedClasses,typeOnly,null,lexer.yyline(),name,null,openedNamespaces);
    variables.add(unr);
    ret=unr;
  }
  if (nsname != null) {
    boolean attr=nsname.startsWith(""String_Node_Str"");
    if (attr) {
      nsname=nsname.substring(1);
    }
    UnresolvedAVM2Item ns=new UnresolvedAVM2Item(params,importedClasses,typeOnly,null,lexer.yyline(),nsname,null,openedNamespaces);
    variables.add(ns);
    ret=new NamespacedAVM2Item(ns,nsprop,ret,attr,openedNamespaces,null);
  }
  if (s.type == SymbolType.BRACKET_OPEN) {
    lexer.pushback(s);
    if (attrBracket) {
      lexer.pushback(new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.ATTRIBUTE,""String_Node_Str""));
      lexer.pushback(new ParsedSymbol(SymbolGroup.OPERATOR,SymbolType.DOT,""String_Node_Str""));
    }
    ret=member(needsActivation,importedClasses,openedNamespaces,ret,registerVars,inFunction,inMethod,variables);
  }
 else {
    lexer.pushback(s);
  }
  return ret;
}",0.7518889745566693
61749,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  return toSourceMerge(localData,generator,leftSide,rightSide,new AVM2Instruction(0,new AsTypeIns(),new int[]{},new byte[0]));
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  return toSourceMerge(localData,generator,leftSide,rightSide,new AVM2Instruction(0,new AsTypeLateIns(),new int[]{},new byte[0]));
}",0.9925925925925926
61750,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  return toSourceMerge(localData,generator,leftSide,rightSide,new AVM2Instruction(0,new IsTypeIns(),new int[]{},new byte[0]));
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator) throws CompilationException {
  return toSourceMerge(localData,generator,leftSide,rightSide,new AVM2Instruction(0,new IsTypeLateIns(),new int[]{},new byte[0]));
}",0.9925925925925926
61751,"public int method(List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        GraphTargetItem res=n.resolve(paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramTypes.get(i));
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  MethodBody mbody=new MethodBody();
  if (needsActivation) {
    mbody.traits=new Traits();
    int slotId=1;
    for (int i=1; i < slotNames.size(); i++) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.slot_id=slotId++;
      tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
      tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
      mbody.traits.traits.add(tsc);
    }
    for (int i=1; i < paramRegCount; i++) {
      NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
      param.setRegNumber(i);
      NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
      d.setSlotScope(slotScope);
      d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
      declarations.add(d);
    }
  }
  body.addAll(0,declarations);
  localData.exceptions=new ArrayList<>();
  localData.callStack.add(mbody);
  List<GraphSourceItem> src=generate(localData,body);
  mbody.method_info=abc.addMethodInfo(mi);
  mi.setBody(mbody);
  mbody.code=new AVM2Code();
  mbody.code.code=toInsList(src);
  if (needsActivation) {
    if (localData.traitUsages.containsKey(mbody)) {
      List<Integer> usages=localData.traitUsages.get(mbody);
      for (int i=0; i < mbody.traits.traits.size(); i++) {
        if (usages.contains(i)) {
          TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
          GraphTargetItem type=TypeItem.UNBOUNDED;
          if (tsc.type_index > 0) {
            type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
          }
          NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
          d.setSlotNumber(tsc.slot_id);
          d.setSlotScope(slotScope);
          mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
        }
      }
    }
    List<AVM2Instruction> acts=new ArrayList<>();
    acts.add(ins(new NewActivationIns()));
    acts.add(ins(new DupIns()));
    acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
    acts.add(ins(new PushScopeIns()));
    mbody.code.code.addAll(0,acts);
  }
  if (constructor) {
    List<ABC> abcs=new ArrayList<>();
    abcs.add(abc);
    abcs.addAll(allABCs);
    int parentConsAC=0;
    for (    ABC a : abcs) {
      int ci=a.findClassByName(superType);
      if (ci > -1) {
        MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
        parentConsAC=pmi.param_types.length;
      }
    }
    int ac=-1;
    for (    AVM2Instruction ins : mbody.code.code) {
      if (ins.definition instanceof ConstructSuperIns) {
        ac=ins.operands[0];
        if (parentConsAC != ac) {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (ac == -1) {
      if (parentConsAC == 0) {
        mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
        mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
      }
 else {
        throw new CompilationException(""String_Node_Str"",line);
      }
    }
  }
  if (className != null) {
    mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
    mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
  }
  if (!mbody.code.code.isEmpty()) {
    InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
    if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
  }
  mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
  int offset=0;
  for (int i=0; i < mbody.code.code.size(); i++) {
    AVM2Instruction ins=mbody.code.code.get(i);
    if (ins instanceof ExceptionMarkAVM2Instruction) {
      ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
        mbody.exceptions[m.exceptionId].start=offset;
      break;
case MARK_E_END:
    mbody.exceptions[m.exceptionId].end=offset;
  break;
case MARK_E_TARGET:
mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.autoFillStats(abc,initScope);
abc.addMethodBody(mbody);
return mbody.method_info;
}","public int method(List<MethodBody> callStack,String pkg,boolean needsActivation,List<AssignableAVM2Item> subvariables,int initScope,boolean hasRest,int line,String className,String superType,boolean constructor,SourceGeneratorLocalData localData,List<GraphTargetItem> paramTypes,List<String> paramNames,List<GraphTargetItem> paramValues,List<GraphTargetItem> body,GraphTargetItem retType) throws CompilationException {
  SourceGeneratorLocalData newlocalData=new SourceGeneratorLocalData(new HashMap<String,Integer>(),1,true,0);
  newlocalData.currentClass=className;
  newlocalData.pkg=localData.pkg;
  newlocalData.callStack.addAll(localData.callStack);
  newlocalData.traitUsages=localData.traitUsages;
  newlocalData.currentScript=localData.currentScript;
  newlocalData.documentClass=localData.documentClass;
  localData=newlocalData;
  localData.activationReg=0;
  for (int i=0; i < subvariables.size(); i++) {
    AssignableAVM2Item an=subvariables.get(i);
    if (an instanceof UnresolvedAVM2Item) {
      UnresolvedAVM2Item n=(UnresolvedAVM2Item)an;
      if (n.resolved == null) {
        GraphTargetItem res=n.resolve(paramTypes,paramNames,abc,allABCs,callStack,subvariables);
        if (res instanceof AssignableAVM2Item) {
          subvariables.set(i,(AssignableAVM2Item)res);
        }
 else {
          subvariables.remove(i);
          i--;
        }
      }
    }
  }
  boolean hasArguments=false;
  List<String> slotNames=new ArrayList<>();
  List<String> slotTypes=new ArrayList<>();
  slotNames.add(""String_Node_Str"");
  slotTypes.add(""String_Node_Str"");
  List<String> registerNames=new ArrayList<>();
  List<String> registerTypes=new ArrayList<>();
  if (className != null) {
    String fullClassName=pkg.isEmpty() ? className : pkg + ""String_Node_Str"" + className;
    registerTypes.add(fullClassName);
    localData.scopeStack.add(new LocalRegAVM2Item(null,registerNames.size(),null));
    registerNames.add(""String_Node_Str"");
  }
 else {
    registerTypes.add(""String_Node_Str"");
    registerNames.add(""String_Node_Str"");
  }
  for (  GraphTargetItem t : paramTypes) {
    registerTypes.add(t.toString());
    slotTypes.add(t.toString());
  }
  registerNames.addAll(paramNames);
  slotNames.addAll(paramNames);
  localData.registerVars.clear();
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName().equals(""String_Node_Str"") & !n.isDefinition()) {
        registerNames.add(""String_Node_Str"");
        registerTypes.add(""String_Node_Str"");
        hasArguments=true;
        break;
      }
    }
  }
  int paramRegCount=registerNames.size();
  if (needsActivation) {
    registerNames.add(""String_Node_Str"");
    localData.activationReg=registerNames.size() - 1;
    registerTypes.add(""String_Node_Str"");
    localData.scopeStack.add(new LocalRegAVM2Item(null,localData.activationReg,null));
  }
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.isDefinition()) {
        if (!needsActivation || (n.getSlotScope() <= 0)) {
          registerNames.add(n.getVariableName());
          registerTypes.add(n.type.toString());
          slotNames.add(n.getVariableName());
          slotTypes.add(n.type.toString());
        }
      }
    }
  }
  int slotScope=className == null ? 0 : 1;
  for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (n.getVariableName() != null) {
        if (needsActivation) {
          if (n.getSlotNumber() <= 0) {
            n.setSlotNumber(slotNames.indexOf(n.getVariableName()));
            n.setSlotScope(slotScope);
          }
        }
 else {
          n.setRegNumber(registerNames.indexOf(n.getVariableName()));
        }
      }
    }
  }
  for (int i=0; i < registerNames.size(); i++) {
    if (needsActivation && i > localData.activationReg) {
      break;
    }
    localData.registerVars.put(registerNames.get(i),i);
  }
  List<NameAVM2Item> declarations=new ArrayList<>();
  loopn:   for (  AssignableAVM2Item an : subvariables) {
    if (an instanceof NameAVM2Item) {
      NameAVM2Item n=(NameAVM2Item)an;
      if (needsActivation) {
        if (n.getSlotScope() != slotScope) {
          continue;
        }
 else {
          if (n.getSlotNumber() < paramRegCount) {
            continue;
          }
        }
      }
      for (      NameAVM2Item d : declarations) {
        if (n.getVariableName() != null && n.getVariableName().equals(d.getVariableName())) {
          continue loopn;
        }
      }
      for (      GraphTargetItem it : body) {
        if (it instanceof NameAVM2Item) {
          NameAVM2Item n2=(NameAVM2Item)it;
          if (n2.isDefinition() && n2.getAssignedValue() != null && n2.getVariableName().equals(n.getVariableName())) {
            continue loopn;
          }
          if (!n2.isDefinition() && n2.getVariableName() != null && n2.getVariableName().equals(n.getVariableName())) {
            break;
          }
        }
      }
      if (n.unresolved) {
        continue;
      }
      if (n.redirect != null) {
        continue;
      }
      if (n.getNs() != null) {
        continue;
      }
      NameAVM2Item d=new NameAVM2Item(n.type,n.line,n.getVariableName(),NameAVM2Item.getDefaultValue(""String_Node_Str"" + n.type),true,n.openedNamespaces);
      if (needsActivation) {
        if (d.getSlotNumber() <= 0) {
          d.setSlotNumber(n.getSlotNumber());
          d.setSlotScope(n.getSlotScope());
        }
      }
 else {
        d.setRegNumber(n.getRegNumber());
      }
      declarations.add(d);
    }
  }
  int param_types[]=new int[paramTypes.size()];
  ValueKind optional[]=new ValueKind[paramValues.size()];
  for (int i=0; i < paramTypes.size(); i++) {
    param_types[i]=typeName(localData,paramTypes.get(i));
  }
  for (int i=0; i < paramValues.size(); i++) {
    optional[i]=getValueKind(Namespace.KIND_NAMESPACE,paramTypes.get(paramTypes.size() - paramValues.size() + i),paramTypes.get(i));
  }
  MethodInfo mi=new MethodInfo(param_types,constructor ? 0 : typeName(localData,retType),0,0,optional,new int[0]);
  if (hasArguments) {
    mi.setFlagNeed_Arguments();
  }
  if (!paramValues.isEmpty()) {
    mi.setFlagHas_optional();
  }
  if (hasRest) {
    mi.setFlagNeed_rest();
  }
  MethodBody mbody=new MethodBody();
  if (needsActivation) {
    mbody.traits=new Traits();
    int slotId=1;
    for (int i=1; i < slotNames.size(); i++) {
      TraitSlotConst tsc=new TraitSlotConst();
      tsc.slot_id=slotId++;
      tsc.name_index=abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(slotNames.get(i),true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE_INTERNAL,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
      tsc.type_index=typeName(localData,new TypeItem(slotTypes.get(i)));
      mbody.traits.traits.add(tsc);
    }
    for (int i=1; i < paramRegCount; i++) {
      NameAVM2Item param=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),null,false,new ArrayList<Integer>());
      param.setRegNumber(i);
      NameAVM2Item d=new NameAVM2Item(new TypeItem(registerTypes.get(i)),0,registerNames.get(i),param,true,new ArrayList<Integer>());
      d.setSlotScope(slotScope);
      d.setSlotNumber(slotNames.indexOf(registerNames.get(i)));
      declarations.add(d);
    }
  }
  body.addAll(0,declarations);
  localData.exceptions=new ArrayList<>();
  localData.callStack.add(mbody);
  List<GraphSourceItem> src=generate(localData,body);
  mbody.method_info=abc.addMethodInfo(mi);
  mi.setBody(mbody);
  mbody.code=new AVM2Code();
  mbody.code.code=toInsList(src);
  if (needsActivation) {
    if (localData.traitUsages.containsKey(mbody)) {
      List<Integer> usages=localData.traitUsages.get(mbody);
      for (int i=0; i < mbody.traits.traits.size(); i++) {
        if (usages.contains(i)) {
          TraitSlotConst tsc=(TraitSlotConst)mbody.traits.traits.get(i);
          GraphTargetItem type=TypeItem.UNBOUNDED;
          if (tsc.type_index > 0) {
            type=new TypeItem(abc.constants.constant_multiname.get(tsc.type_index).getNameWithNamespace(abc.constants));
          }
          NameAVM2Item d=new NameAVM2Item(type,0,tsc.getName(abc).getName(abc.constants,new ArrayList<String>()),NameAVM2Item.getDefaultValue(""String_Node_Str"" + type),true,new ArrayList<Integer>());
          d.setSlotNumber(tsc.slot_id);
          d.setSlotScope(slotScope);
          mbody.code.code.addAll(0,toInsList(d.toSourceIgnoreReturnValue(localData,this)));
        }
      }
    }
    List<AVM2Instruction> acts=new ArrayList<>();
    acts.add(ins(new NewActivationIns()));
    acts.add(ins(new DupIns()));
    acts.add(AssignableAVM2Item.generateSetLoc(localData.activationReg));
    acts.add(ins(new PushScopeIns()));
    mbody.code.code.addAll(0,acts);
  }
  if (constructor) {
    List<ABC> abcs=new ArrayList<>();
    abcs.add(abc);
    abcs.addAll(allABCs);
    int parentConsAC=0;
    for (    ABC a : abcs) {
      int ci=a.findClassByName(superType);
      if (ci > -1) {
        MethodInfo pmi=a.method_info.get(a.instance_info.get(ci).iinit_index);
        parentConsAC=pmi.param_types.length;
      }
    }
    int ac=-1;
    for (    AVM2Instruction ins : mbody.code.code) {
      if (ins.definition instanceof ConstructSuperIns) {
        ac=ins.operands[0];
        if (parentConsAC != ac) {
          throw new CompilationException(""String_Node_Str"",line);
        }
      }
    }
    if (ac == -1) {
      if (parentConsAC == 0) {
        mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
        mbody.code.code.add(1,new AVM2Instruction(0,new ConstructSuperIns(),new int[]{0},new byte[0]));
      }
 else {
        throw new CompilationException(""String_Node_Str"",line);
      }
    }
  }
  if (className != null) {
    mbody.code.code.add(0,new AVM2Instruction(0,new GetLocal0Ins(),new int[]{},new byte[0]));
    mbody.code.code.add(1,new AVM2Instruction(0,new PushScopeIns(),new int[]{},new byte[0]));
  }
  if (!mbody.code.code.isEmpty()) {
    InstructionDefinition lastDef=mbody.code.code.get(mbody.code.code.size() - 1).definition;
    if (!((lastDef instanceof ReturnVoidIns) || (lastDef instanceof ReturnValueIns))) {
      if (retType.toString().equals(""String_Node_Str"") || retType.toString().equals(""String_Node_Str"") || constructor) {
        mbody.code.code.add(new AVM2Instruction(0,new ReturnVoidIns(),new int[]{},new byte[0]));
      }
 else {
        mbody.code.code.add(new AVM2Instruction(0,new PushUndefinedIns(),new int[]{},new byte[0]));
        mbody.code.code.add(new AVM2Instruction(0,new ReturnValueIns(),new int[]{},new byte[0]));
      }
    }
  }
  mbody.exceptions=localData.exceptions.toArray(new ABCException[localData.exceptions.size()]);
  int offset=0;
  for (int i=0; i < mbody.code.code.size(); i++) {
    AVM2Instruction ins=mbody.code.code.get(i);
    if (ins instanceof ExceptionMarkAVM2Instruction) {
      ExceptionMarkAVM2Instruction m=(ExceptionMarkAVM2Instruction)ins;
switch (m.markType) {
case MARK_E_START:
        mbody.exceptions[m.exceptionId].start=offset;
      break;
case MARK_E_END:
    mbody.exceptions[m.exceptionId].end=offset;
  break;
case MARK_E_TARGET:
mbody.exceptions[m.exceptionId].target=offset;
break;
}
mbody.code.code.remove(i);
i--;
continue;
}
offset+=ins.getBytes().length;
}
mbody.markOffsets();
mbody.autoFillStats(abc,initScope);
abc.addMethodBody(mbody);
return mbody.method_info;
}",0.9990974341341816
61752,"public HasNext2Ins(){
  super(0x32,""String_Node_Str"",new int[]{AVM2Code.OPT_U8,AVM2Code.OPT_U8});
}","public HasNext2Ins(){
  super(0x32,""String_Node_Str"",new int[]{AVM2Code.DAT_LOCAL_REG_INDEX,AVM2Code.DAT_LOCAL_REG_INDEX});
}",0.8125
61753,"protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,Stack<GraphTargetItem> stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  if (isLoop) {
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (part.nextParts.size() == 2) {
    if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (!reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((OrItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof AndItem) {
            o.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
 else     if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
  }
  if (parseNext) {
    if (false && part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      for (      GraphPart p : part.nextParts) {
        if (!first) {
          caseValues.add(new IntegerValueItem(null,pos++));
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (first) {
            defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
          }
 else {
            caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
          }
          vis.add(p);
        }
        first=false;
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      if (staticOperation != SOP_USE_STATIC) {
        if (expr.isCompileTime()) {
          boolean doJump=EcmaScript.toBoolean(expr.getResult());
          if (doJump) {
            nextOnePart=part.nextParts.get(0);
          }
 else {
            nextOnePart=part.nextParts.get(1);
          }
          if (staticOperation == SOP_REMOVE_STATIC) {
          }
        }
      }
      if (nextOnePart == null) {
        List<GraphPart> nps=new ArrayList<>(part.nextParts);
        nps=part.nextParts;
        GraphPart next=getCommonPart(localData,nps,loops);
        @SuppressWarnings(""String_Node_Str"") Stack<GraphTargetItem> trueStack=(Stack<GraphTargetItem>)stack.clone();
        @SuppressWarnings(""String_Node_Str"") Stack<GraphTargetItem> falseStack=(Stack<GraphTargetItem>)stack.clone();
        int trueStackSizeBefore=trueStack.size();
        int falseStackSizeBefore=falseStack.size();
        List<GraphTargetItem> onTrue=new ArrayList<>();
        boolean isEmpty=nps.get(0) == nps.get(1);
        if (isEmpty) {
          next=nps.get(0);
        }
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if (next != null) {
          stopPart2.add(next);
        }
        if (!isEmpty) {
          onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty) {
          onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
          stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
        }
 else {
          currentRet.add(new IfItem(null,expr,onTrue,onFalse));
        }
        if (next != null) {
          if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
            onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
              stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
            }
 else {
              currentRet.add(new IfItem(null,expr,onTrue,onFalse));
            }
          }
 else {
            printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
          }
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                if (expr instanceof LogicalOpItem) {
                  expr=((LogicalOpItem)expr).invert();
                }
 else {
                  expr=new NotItem(null,expr);
                }
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}","protected List<GraphTargetItem> printGraph(List<GraphPart> visited,BaseLocalData localData,Stack<GraphTargetItem> stack,List<GraphPart> allParts,GraphPart parent,GraphPart part,List<GraphPart> stopPart,List<Loop> loops,List<GraphTargetItem> ret,int staticOperation,String path,int recursionLevel) throws InterruptedException {
  if (Thread.currentThread().isInterrupted()) {
    throw new InterruptedException();
  }
  if (stopPart == null) {
    stopPart=new ArrayList<>();
  }
  if (recursionLevel > allParts.size() + 1) {
    throw new TranslateException(""String_Node_Str"");
  }
  if (visited.contains(part)) {
  }
 else {
    visited.add(part);
  }
  if (ret == null) {
    ret=new ArrayList<>();
  }
  boolean debugMode=false;
  if (debugMode) {
    System.err.println(""String_Node_Str"" + part + ""String_Node_Str""+ part.nextParts.size());
  }
  if (part == null) {
    return ret;
  }
  part=checkPart(stack,localData,part,allParts);
  if (part == null) {
    return ret;
  }
  if (part.ignored) {
    return ret;
  }
  List<GraphPart> loopContinues=getLoopsContinues(loops);
  boolean isLoop=false;
  Loop currentLoop=null;
  for (  Loop el : loops) {
    if ((el.loopContinue == part) && (el.phase == 0)) {
      currentLoop=el;
      currentLoop.phase=1;
      isLoop=true;
      break;
    }
  }
  if (debugMode) {
    System.err.println(""String_Node_Str"" + loops.size());
  }
  for (int l=loops.size() - 1; l >= 0; l--) {
    Loop el=loops.get(l);
    if (el == currentLoop) {
      if (debugMode) {
        System.err.println(""String_Node_Str"" + el);
      }
      continue;
    }
    if (el.phase != 1) {
      if (debugMode) {
      }
      continue;
    }
    if (el.loopBreak == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new BreakItem(null,el.id));
      return ret;
    }
    if (el.loopPreContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
    if (el.loopContinue == part) {
      if (currentLoop != null) {
        currentLoop.phase=0;
      }
      if (debugMode) {
        System.err.println(""String_Node_Str"");
      }
      ret.add(new ContinueItem(null,el.id));
      return ret;
    }
  }
  if (stopPart.contains(part)) {
    if (currentLoop != null) {
      currentLoop.phase=0;
    }
    return ret;
  }
  if ((part != null) && (code.size() <= part.start)) {
    ret.add(new ScriptEndItem());
    return ret;
  }
  List<GraphTargetItem> currentRet=ret;
  UniversalLoopItem loopItem=null;
  if (isLoop) {
    loopItem=new UniversalLoopItem(null,currentLoop);
    currentRet.add(loopItem);
    loopItem.commands=new ArrayList<>();
    currentRet=loopItem.commands;
  }
  boolean parseNext=true;
  List<GraphTargetItem> output=new ArrayList<>();
  List<GraphPart> parts=new ArrayList<>();
  if (part instanceof GraphPartMulti) {
    parts=((GraphPartMulti)part).parts;
  }
 else {
    parts.add(part);
  }
  for (  GraphPart p : parts) {
    int end=p.end;
    int start=p.start;
    output.addAll(code.translatePart(p,localData,stack,start,end,staticOperation,path));
    if ((end >= code.size() - 1) && p.nextParts.isEmpty()) {
      output.add(new ScriptEndItem());
    }
  }
  if (parseNext) {
    List<GraphTargetItem> retCheck=check(code,localData,allParts,stack,parent,part,stopPart,loops,output,currentLoop,staticOperation,path);
    if (retCheck != null) {
      if (!retCheck.isEmpty()) {
        currentRet.addAll(retCheck);
      }
      parseNext=false;
    }
 else {
      currentRet.addAll(output);
    }
  }
  if (parseNext && part.nextParts.size() == 2) {
    if ((stack.size() >= 2) && (stack.get(stack.size() - 1) instanceof NotItem) && (((NotItem)(stack.get(stack.size() - 1))).getOriginal().getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (!reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((OrItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof AndItem) {
            o.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
 else     if ((stack.size() >= 2) && (stack.get(stack.size() - 1).getNotCoerced() == stack.get(stack.size() - 2).getNotCoerced())) {
      GraphPart sp0=getNextNoJump(part.nextParts.get(0),localData);
      GraphPart sp1=getNextNoJump(part.nextParts.get(1),localData);
      boolean reversed=false;
      loopContinues=getLoopsContinues(loops);
      loopContinues.add(part);
      if (sp1.leadsTo(localData,this,code,sp0,loops)) {
      }
 else       if (sp0.leadsTo(localData,this,code,sp1,loops)) {
        reversed=true;
      }
      GraphPart next=reversed ? sp0 : sp1;
      GraphTargetItem ti;
      if ((ti=checkLoop(next,stopPart,loops)) != null) {
        currentRet.add(ti);
      }
 else {
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(reversed ? sp1 : sp0);
        printGraph(visited,localData,stack,allParts,parent,next,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        GraphTargetItem second=stack.pop();
        GraphTargetItem first=stack.pop();
        if (reversed) {
          AndItem a=new AndItem(null,first,second);
          stack.push(a);
          a.firstPart=part;
          if (second instanceof AndItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            a.firstPart=((AndItem)second).firstPart;
          }
        }
 else {
          OrItem o=new OrItem(null,first,second);
          stack.push(o);
          o.firstPart=part;
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
          if (second instanceof OrItem) {
            o.firstPart=((OrItem)second).firstPart;
          }
        }
        next=reversed ? sp1 : sp0;
        if ((ti=checkLoop(next,stopPart,loops)) != null) {
          currentRet.add(ti);
        }
 else {
          currentRet.addAll(printGraph(visited,localData,stack,allParts,parent,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
        }
      }
      parseNext=false;
    }
  }
  if (parseNext) {
    if (false && part.nextParts.size() > 2) {
      GraphPart next=getMostCommonPart(localData,part.nextParts,loops);
      List<GraphPart> vis=new ArrayList<>();
      GraphTargetItem switchedItem=stack.pop();
      List<GraphTargetItem> caseValues=new ArrayList<>();
      List<List<GraphTargetItem>> caseCommands=new ArrayList<>();
      List<GraphTargetItem> defaultCommands=new ArrayList<>();
      List<Integer> valueMappings=new ArrayList<>();
      Loop swLoop=new Loop(loops.size(),null,next);
      swLoop.phase=1;
      loops.add(swLoop);
      boolean first=false;
      int pos=0;
      for (      GraphPart p : part.nextParts) {
        if (!first) {
          caseValues.add(new IntegerValueItem(null,pos++));
          if (vis.contains(p)) {
            valueMappings.add(caseCommands.size() - 1);
            continue;
          }
          valueMappings.add(caseCommands.size());
        }
        List<GraphPart> stopPart2=new ArrayList<>();
        if (next != null) {
          stopPart2.add(next);
        }
 else         if (!stopPart.isEmpty()) {
          stopPart2.add(stopPart.get(stopPart.size() - 1));
        }
        for (        GraphPart p2 : part.nextParts) {
          if (p2 == p) {
            continue;
          }
          if (!stopPart2.contains(p2)) {
            stopPart2.add(p2);
          }
        }
        if (next != p) {
          if (first) {
            defaultCommands=printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
          }
 else {
            caseCommands.add(printGraph(visited,prepareBranchLocalData(localData),stack,allParts,part,p,stopPart2,loops,null,staticOperation,path,recursionLevel + 1));
          }
          vis.add(p);
        }
        first=false;
      }
      SwitchItem sw=new SwitchItem(null,swLoop,switchedItem,caseValues,caseCommands,defaultCommands,valueMappings);
      currentRet.add(sw);
      swLoop.phase=2;
      if (next != null) {
        currentRet.addAll(printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    GraphPart nextOnePart=null;
    if (part.nextParts.size() == 2) {
      GraphTargetItem expr=stack.pop();
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      if (staticOperation != SOP_USE_STATIC) {
        if (expr.isCompileTime()) {
          boolean doJump=EcmaScript.toBoolean(expr.getResult());
          if (doJump) {
            nextOnePart=part.nextParts.get(0);
          }
 else {
            nextOnePart=part.nextParts.get(1);
          }
          if (staticOperation == SOP_REMOVE_STATIC) {
          }
        }
      }
      if (nextOnePart == null) {
        List<GraphPart> nps=new ArrayList<>(part.nextParts);
        nps=part.nextParts;
        GraphPart next=getCommonPart(localData,nps,loops);
        @SuppressWarnings(""String_Node_Str"") Stack<GraphTargetItem> trueStack=(Stack<GraphTargetItem>)stack.clone();
        @SuppressWarnings(""String_Node_Str"") Stack<GraphTargetItem> falseStack=(Stack<GraphTargetItem>)stack.clone();
        int trueStackSizeBefore=trueStack.size();
        int falseStackSizeBefore=falseStack.size();
        List<GraphTargetItem> onTrue=new ArrayList<>();
        boolean isEmpty=nps.get(0) == nps.get(1);
        if (isEmpty) {
          next=nps.get(0);
        }
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        if (next != null) {
          stopPart2.add(next);
        }
        if (!isEmpty) {
          onTrue=printGraph(visited,prepareBranchLocalData(localData),trueStack,allParts,part,nps.get(1),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        List<GraphTargetItem> onFalse=new ArrayList<>();
        if (!isEmpty) {
          onFalse=printGraph(visited,prepareBranchLocalData(localData),falseStack,allParts,part,nps.get(0),stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        }
        if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
          stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
        }
 else {
          currentRet.add(new IfItem(null,expr,onTrue,onFalse));
        }
        if (next != null) {
          if (trueStack.size() != trueStackSizeBefore || falseStack.size() != falseStackSizeBefore) {
            onTrue=printGraph(visited,localData,trueStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            onFalse=printGraph(visited,localData,falseStack,allParts,part,next,stopPart,loops,null,staticOperation,path,recursionLevel + 1);
            if (isEmpty(onTrue) && isEmpty(onFalse) && (trueStack.size() == trueStackSizeBefore + 1)&& (falseStack.size() == falseStackSizeBefore + 1)) {
              stack.push(new TernarOpItem(null,expr,trueStack.pop(),falseStack.pop()));
            }
 else {
              currentRet.add(new IfItem(null,expr,onTrue,onFalse));
            }
          }
 else {
            printGraph(visited,localData,stack,allParts,part,next,stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
          }
        }
      }
    }
    if (part.nextParts.size() == 1) {
      nextOnePart=part.nextParts.get(0);
    }
    if (nextOnePart != null) {
      printGraph(visited,localData,stack,allParts,part,part.nextParts.get(0),stopPart,loops,currentRet,staticOperation,path,recursionLevel + 1);
    }
  }
  if (isLoop) {
    LoopItem li=loopItem;
    boolean loopTypeFound=false;
    boolean hasContinue=false;
    processIfs(loopItem.commands);
    checkContinueAtTheEnd(loopItem.commands,currentLoop);
    List<ContinueItem> continues=loopItem.getContinues();
    for (    ContinueItem c : continues) {
      if (c.loopId == currentLoop.id) {
        hasContinue=true;
        break;
      }
    }
    if (!hasContinue) {
      if (currentLoop.loopPreContinue != null) {
        List<GraphPart> stopContPart=new ArrayList<>();
        stopContPart.add(currentLoop.loopContinue);
        GraphPart precoBackup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        loopItem.commands.addAll(printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,precoBackup,stopContPart,loops,null,staticOperation,path,recursionLevel + 1));
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(0) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(0);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        boolean breakpos2=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
 else         if (loopItem.commands.size() == 2 && (loopItem.commands.get(1) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)loopItem.commands.get(1);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
            breakpos2=true;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          exprList.add(expr);
          List<GraphTargetItem> commands=new ArrayList<>();
          commands.addAll(bodyBranch);
          loopItem.commands.remove(0);
          if (breakpos2) {
            loopItem.commands.remove(0);
          }
          commands.addAll(loopItem.commands);
          checkContinueAtTheEnd(commands,currentLoop);
          List<GraphTargetItem> finalComm=new ArrayList<>();
          if (currentLoop.loopPreContinue != null) {
            GraphPart backup=currentLoop.loopPreContinue;
            currentLoop.loopPreContinue=null;
            List<GraphPart> stopPart2=new ArrayList<>(stopPart);
            stopPart2.add(currentLoop.loopContinue);
            finalComm=printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
            currentLoop.loopPreContinue=backup;
            checkContinueAtTheEnd(finalComm,currentLoop);
          }
          if (!finalComm.isEmpty()) {
            ret.add(index,li=new ForItem(null,currentLoop,new ArrayList<GraphTargetItem>(),exprList.get(exprList.size() - 1),finalComm,commands));
          }
 else {
            ret.add(index,li=new WhileItem(null,currentLoop,exprList,commands));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound && (!loopItem.commands.isEmpty())) {
      if (loopItem.commands.get(loopItem.commands.size() - 1) instanceof IfItem) {
        IfItem ifi=(IfItem)loopItem.commands.get(loopItem.commands.size() - 1);
        List<GraphTargetItem> bodyBranch=null;
        boolean inverted=false;
        if ((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onTrue.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onFalse;
            inverted=true;
          }
        }
 else         if ((ifi.onFalse.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem)) {
          BreakItem bi=(BreakItem)ifi.onFalse.get(0);
          if (bi.loopId == currentLoop.id) {
            bodyBranch=ifi.onTrue;
          }
        }
        if (bodyBranch != null) {
          int index=ret.indexOf(loopItem);
          ret.remove(index);
          List<GraphTargetItem> exprList=new ArrayList<>();
          GraphTargetItem expr=ifi.expression;
          if (inverted) {
            if (expr instanceof LogicalOpItem) {
              expr=((LogicalOpItem)expr).invert();
            }
 else {
              expr=new NotItem(null,expr);
            }
          }
          checkContinueAtTheEnd(bodyBranch,currentLoop);
          List<GraphTargetItem> commands=new ArrayList<>();
          if (!bodyBranch.isEmpty()) {
            ret.add(index,loopItem);
          }
 else {
            loopItem.commands.remove(loopItem.commands.size() - 1);
            commands.addAll(loopItem.commands);
            commands.addAll(bodyBranch);
            exprList.add(expr);
            checkContinueAtTheEnd(commands,currentLoop);
            ret.add(index,li=new DoWhileItem(null,currentLoop,commands,exprList));
          }
          loopTypeFound=true;
        }
      }
    }
    if (!loopTypeFound) {
      if (currentLoop.loopPreContinue != null) {
        loopTypeFound=true;
        GraphPart backup=currentLoop.loopPreContinue;
        currentLoop.loopPreContinue=null;
        List<GraphPart> stopPart2=new ArrayList<>(stopPart);
        stopPart2.add(currentLoop.loopContinue);
        List<GraphTargetItem> finalComm=printGraph(visited,localData,new Stack<GraphTargetItem>(),allParts,null,backup,stopPart2,loops,null,staticOperation,path,recursionLevel + 1);
        currentLoop.loopPreContinue=backup;
        checkContinueAtTheEnd(finalComm,currentLoop);
        if (!finalComm.isEmpty()) {
          if (finalComm.get(finalComm.size() - 1) instanceof IfItem) {
            IfItem ifi=(IfItem)finalComm.get(finalComm.size() - 1);
            boolean ok=false;
            boolean invert=false;
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof BreakItem) && (((BreakItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
              invert=true;
            }
            if (((ifi.onTrue.size() == 1) && (ifi.onTrue.get(0) instanceof ContinueItem) && (((ContinueItem)ifi.onTrue.get(0)).loopId == currentLoop.id)) && ((ifi.onTrue.size() == 1) && (ifi.onFalse.get(0) instanceof BreakItem) && (((BreakItem)ifi.onFalse.get(0)).loopId == currentLoop.id))) {
              ok=true;
            }
            if (ok) {
              finalComm.remove(finalComm.size() - 1);
              int index=ret.indexOf(loopItem);
              ret.remove(index);
              List<GraphTargetItem> exprList=new ArrayList<>(finalComm);
              GraphTargetItem expr=ifi.expression;
              if (invert) {
                if (expr instanceof LogicalOpItem) {
                  expr=((LogicalOpItem)expr).invert();
                }
 else {
                  expr=new NotItem(null,expr);
                }
              }
              exprList.add(expr);
              ret.add(index,li=new DoWhileItem(null,currentLoop,loopItem.commands,exprList));
            }
          }
        }
      }
    }
    if (!loopTypeFound) {
      checkContinueAtTheEnd(loopItem.commands,currentLoop);
    }
    currentLoop.phase=2;
    GraphTargetItem replaced=checkLoop(li,localData,loops);
    if (replaced != li) {
      int index=ret.indexOf(li);
      ret.remove(index);
      if (replaced != null) {
        ret.add(index,replaced);
      }
    }
    if (currentLoop.loopBreak != null) {
      ret.addAll(printGraph(visited,localData,stack,allParts,part,currentLoop.loopBreak,stopPart,loops,null,staticOperation,path,recursionLevel + 1));
    }
  }
  return ret;
}",0.9997040679277924
61754,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  scope.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  writer.unindent();
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesWithParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  scope.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  writer.unindent();
  return writer.append(""String_Node_Str"");
}",0.8310502283105022
61755,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesForEachParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9192944949225014
61756,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesForParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9212640599892876
61757,"public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ScriptExportMode exportMode,boolean makePackages,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  if (!parallel || traits.size() < 2) {
    for (int t=0; t < traits.size(); t++) {
      TraitConvertTask task=new TraitConvertTask(traits.get(t),parent,makePackages,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,t,parallel);
      task.call();
    }
  }
 else {
    ExecutorService executor=Executors.newFixedThreadPool(Configuration.parallelThreadCount.get());
    List<Future<Void>> futureResults=null;
    futureResults=new ArrayList<>();
    for (int t=0; t < traits.size(); t++) {
      TraitConvertTask task=new TraitConvertTask(traits.get(t),parent,makePackages,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,t,parallel);
      Future<Void> future=executor.submit(task);
      futureResults.add(future);
    }
    for (int f=0; f < futureResults.size(); f++) {
      try {
        futureResults.get(f).get();
      }
 catch (      InterruptedException ex) {
        executor.shutdownNow();
        throw ex;
      }
catch (      ExecutionException ex) {
        Logger.getLogger(Traits.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
      }
    }
    executor.shutdown();
  }
}","public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ScriptExportMode exportMode,boolean makePackages,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  if (!parallel || traits.size() < 2) {
    for (int t=0; t < traits.size(); t++) {
      TraitConvertTask task=new TraitConvertTask(traits.get(t),parent,makePackages,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,t,parallel);
      task.call();
    }
  }
 else {
    ExecutorService executor=Executors.newFixedThreadPool(Configuration.parallelThreadCount.get());
    List<Future<Void>> futureResults=null;
    futureResults=new ArrayList<>();
    for (int t=0; t < traits.size(); t++) {
      TraitConvertTask task=new TraitConvertTask(traits.get(t),parent,makePackages,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,new NulWriter(),fullyQualifiedNames,t,parallel);
      Future<Void> future=executor.submit(task);
      futureResults.add(future);
    }
    for (int f=0; f < futureResults.size(); f++) {
      try {
        futureResults.get(f).get();
      }
 catch (      InterruptedException ex) {
        executor.shutdownNow();
        throw ex;
      }
catch (      ExecutionException ex) {
        Logger.getLogger(Traits.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
      }
    }
    executor.shutdown();
  }
}",0.9934864586904354
61758,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if ((variableName instanceof DirectValueActionItem) && (((DirectValueActionItem)variableName).value instanceof RegisterNumber)) {
    writer.append(""String_Node_Str"");
  }
  stripQuotes(variableName,localData,writer);
  writer.append(""String_Node_Str"");
  enumVariable.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    ti.toStringSemicoloned(writer,localData).newLine();
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesForParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  if ((variableName instanceof DirectValueActionItem) && (((DirectValueActionItem)variableName).value instanceof RegisterNumber)) {
    writer.append(""String_Node_Str"");
  }
  stripQuotes(variableName,localData,writer);
  writer.append(""String_Node_Str"");
  enumVariable.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    ti.toStringSemicoloned(writer,localData).newLine();
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9306930693069309
61759,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : tryCommands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  for (int e=0; e < catchExceptions.size(); e++) {
    writer.newLine();
    writer.append(""String_Node_Str"");
    catchExceptions.get(e).toStringNoQuotes(writer,localData);
    writer.append(""String_Node_Str"").newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.indent();
    List<GraphTargetItem> commands=catchCommands.get(e);
    for (    GraphTargetItem ti : commands) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
    writer.append(""String_Node_Str"");
  }
  if (finallyCommands.size() > 0) {
    writer.newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.indent();
    for (    GraphTargetItem ti : finallyCommands) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
    writer.append(""String_Node_Str"");
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : tryCommands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.unindent();
  writer.append(""String_Node_Str"");
  for (int e=0; e < catchExceptions.size(); e++) {
    writer.newLine();
    writer.append(""String_Node_Str"");
    if (writer.getFormatting().spaceBeforeParenthesesCatchParentheses) {
      writer.append(""String_Node_Str"");
    }
    writer.append(""String_Node_Str"");
    catchExceptions.get(e).toStringNoQuotes(writer,localData);
    writer.append(""String_Node_Str"").newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.indent();
    List<GraphTargetItem> commands=catchCommands.get(e);
    for (    GraphTargetItem ti : commands) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
    writer.append(""String_Node_Str"");
  }
  if (finallyCommands.size() > 0) {
    writer.newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.append(""String_Node_Str"").newLine();
    writer.indent();
    for (    GraphTargetItem ti : finallyCommands) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
    writer.append(""String_Node_Str"");
  }
  return writer;
}",0.9466893039049236
61760,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  scope.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : items) {
    ti.toString(writer,localData).newLine();
  }
  writer.unindent();
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesWithParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  scope.toString(writer,localData);
  writer.append(""String_Node_Str"").newLine();
  writer.append(""String_Node_Str"").newLine();
  writer.indent();
  for (  GraphTargetItem ti : items) {
    ti.toString(writer,localData).newLine();
  }
  writer.unindent();
  return writer.append(""String_Node_Str"");
}",0.8593155893536122
61761,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  writer.startBlock();
  writer.indent();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  writer.append(""String_Node_Str"");
  for (int i=0; i < expression.size(); i++) {
    if (expression.get(i).isEmpty()) {
      continue;
    }
    if (i != 0) {
      writer.append(""String_Node_Str"");
    }
    expression.get(i).toString(writer,localData);
  }
  writer.append(""String_Node_Str"").newLine();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  writer.startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock().newLine();
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesWhileParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  for (int i=0; i < expression.size(); i++) {
    if (expression.get(i).isEmpty()) {
      continue;
    }
    if (i != 0) {
      writer.append(""String_Node_Str"");
    }
    expression.get(i).toString(writer,localData);
  }
  writer.append(""String_Node_Str"").newLine();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9175068744271312
61762,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  int p=0;
  for (int i=0; i < firstCommands.size(); i++) {
    if (firstCommands.get(i).isEmpty()) {
      continue;
    }
    if (p > 0) {
      writer.append(""String_Node_Str"");
    }
    firstCommands.get(i).toString(writer,localData);
    writer.stripSemicolon();
    p++;
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"");
  p=0;
  for (int i=0; i < finalCommands.size(); i++) {
    if (finalCommands.get(i).isEmpty()) {
      continue;
    }
    if (p > 0) {
      writer.append(""String_Node_Str"");
    }
    finalCommands.get(i).toString(writer,localData);
    writer.stripSemicolon();
    p++;
  }
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesForParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  int p=0;
  for (int i=0; i < firstCommands.size(); i++) {
    if (firstCommands.get(i).isEmpty()) {
      continue;
    }
    if (p > 0) {
      writer.append(""String_Node_Str"");
    }
    firstCommands.get(i).toString(writer,localData);
    writer.stripSemicolon();
    p++;
  }
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  writer.append(""String_Node_Str"");
  p=0;
  for (int i=0; i < finalCommands.size(); i++) {
    if (finalCommands.get(i).isEmpty()) {
      continue;
    }
    if (p > 0) {
      writer.append(""String_Node_Str"");
    }
    finalCommands.get(i).toString(writer,localData);
    writer.stripSemicolon();
    p++;
  }
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9499148211243612
61763,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  GraphTargetItem expr=expression;
  List<GraphTargetItem> ifBranch=onTrue;
  List<GraphTargetItem> elseBranch=onFalse;
  if (onTrue.isEmpty()) {
    if (onFalse.isEmpty()) {
      if (expr instanceof NotItem) {
        expr=((NotItem)expr).getOriginal();
      }
    }
 else {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      ifBranch=onFalse;
      elseBranch=onTrue;
    }
  }
  writer.append(""String_Node_Str"");
  expr.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : ifBranch) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (elseBranch.size() > 0) {
    boolean elseIf=elseBranch.size() == 1 && (elseBranch.get(0) instanceof IfItem);
    if (writer.getFormatting().beginBlockOnNewLine) {
      writer.newLine();
    }
 else {
      writer.append(""String_Node_Str"");
    }
    writer.append(""String_Node_Str"");
    if (!elseIf) {
      writer.startBlock();
    }
 else {
      writer.append(""String_Node_Str"");
    }
    for (    GraphTargetItem ti : elseBranch) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    if (!elseIf) {
      writer.endBlock();
    }
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  GraphTargetItem expr=expression;
  List<GraphTargetItem> ifBranch=onTrue;
  List<GraphTargetItem> elseBranch=onFalse;
  if (onTrue.isEmpty()) {
    if (onFalse.isEmpty()) {
      if (expr instanceof NotItem) {
        expr=((NotItem)expr).getOriginal();
      }
    }
 else {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      ifBranch=onFalse;
      elseBranch=onTrue;
    }
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesIfParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  expr.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : ifBranch) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (elseBranch.size() > 0) {
    boolean elseIf=elseBranch.size() == 1 && (elseBranch.get(0) instanceof IfItem);
    if (writer.getFormatting().beginBlockOnNewLine) {
      writer.newLine();
    }
 else {
      writer.append(""String_Node_Str"");
    }
    writer.append(""String_Node_Str"");
    if (!elseIf) {
      writer.startBlock();
    }
 else {
      writer.append(""String_Node_Str"");
    }
    for (    GraphTargetItem ti : elseBranch) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).newLine();
      }
    }
    if (!elseIf) {
      writer.endBlock();
    }
  }
  return writer;
}",0.9324410452517528
61764,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_SWITCH);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  switchedObject.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (int i=0; i < caseCommands.size(); i++) {
    for (int k=0; k < valuesMapping.size(); k++) {
      if (valuesMapping.get(k) == i) {
        writer.append(""String_Node_Str"");
        caseValues.get(k).toString(writer,localData);
        writer.append(""String_Node_Str"").newLine();
      }
    }
    writer.indent();
    for (int j=0; j < caseCommands.get(i).size(); j++) {
      if (!caseCommands.get(i).get(j).isEmpty()) {
        caseCommands.get(i).get(j).toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
  }
  if (defaultCommands != null) {
    if (defaultCommands.size() > 0) {
      writer.append(""String_Node_Str"");
      writer.append(""String_Node_Str"").newLine();
      writer.indent();
      for (int j=0; j < defaultCommands.size(); j++) {
        if (!defaultCommands.get(j).isEmpty()) {
          defaultCommands.get(j).toStringSemicoloned(writer,localData).newLine();
        }
      }
      writer.unindent();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_SWITCH);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesSwitchParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  switchedObject.toString(writer,localData);
  writer.append(""String_Node_Str"").startBlock();
  for (int i=0; i < caseCommands.size(); i++) {
    for (int k=0; k < valuesMapping.size(); k++) {
      if (valuesMapping.get(k) == i) {
        writer.append(""String_Node_Str"");
        caseValues.get(k).toString(writer,localData);
        writer.append(""String_Node_Str"").newLine();
      }
    }
    writer.indent();
    for (int j=0; j < caseCommands.get(i).size(); j++) {
      if (!caseCommands.get(i).get(j).isEmpty()) {
        caseCommands.get(i).get(j).toStringSemicoloned(writer,localData).newLine();
      }
    }
    writer.unindent();
  }
  if (defaultCommands != null) {
    if (defaultCommands.size() > 0) {
      writer.append(""String_Node_Str"");
      writer.append(""String_Node_Str"").newLine();
      writer.indent();
      for (int j=0; j < defaultCommands.size(); j++) {
        if (!defaultCommands.get(j).isEmpty()) {
          defaultCommands.get(j).toStringSemicoloned(writer,localData).newLine();
        }
      }
      writer.unindent();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9554896142433236
61765,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"").startBlock();
  if (writer.getFormatting().spaceBeforeParenthesesWhileParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"").startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.8942558746736292
61766,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  for (int i=0; i < expression.size(); i++) {
    if (expression.get(i).isEmpty()) {
      continue;
    }
    if (i != 0) {
      writer.append(""String_Node_Str"");
    }
    expression.get(i).toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  writer.startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (writer instanceof NulWriter) {
    ((NulWriter)writer).startLoop(loop.id,LoopWithType.LOOP_TYPE_LOOP);
  }
  if (labelUsed) {
    writer.append(""String_Node_Str"" + loop.id + ""String_Node_Str"").newLine();
  }
  writer.append(""String_Node_Str"");
  if (writer.getFormatting().spaceBeforeParenthesesWhileParentheses) {
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  for (int i=0; i < expression.size(); i++) {
    if (expression.get(i).isEmpty()) {
      continue;
    }
    if (i != 0) {
      writer.append(""String_Node_Str"");
    }
    expression.get(i).toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  writer.startBlock();
  for (  GraphTargetItem ti : commands) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).newLine();
    }
  }
  writer.endBlock();
  if (writer instanceof NulWriter) {
    LoopWithType loopOjb=((NulWriter)writer).endLoop(loop.id);
    labelUsed=loopOjb.used;
  }
  return writer;
}",0.9277049975739932
61767,"@Override protected Object doInBackground() throws Exception {
  boolean first=true;
  for (  final SWFSourceInfo sourceInfo : sourceInfos) {
    SWFList swfs=null;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      swfs=parseSWF(sourceInfo);
    }
 catch (    OutOfMemoryError ex) {
      logger.log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
catch (    Exception ex) {
      logger.log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
    final SWFList swfs1=swfs;
    final boolean first1=first;
    first=false;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          ensureMainFrame();
          mainFrame.getPanel().load(swfs1,first1);
        }
      }
);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,null,ex);
    }
  }
  loadingDialog.setVisible(false);
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      if (mainFrame != null) {
        mainFrame.setVisible(true);
      }
      Main.stopWork();
    }
  }
);
  return true;
}","@Override protected Object doInBackground() throws Exception {
  boolean first=true;
  SWF firstSWF=null;
  for (  final SWFSourceInfo sourceInfo : sourceInfos) {
    SWFList swfs=null;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      swfs=parseSWF(sourceInfo);
    }
 catch (    OutOfMemoryError ex) {
      logger.log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
catch (    Exception ex) {
      logger.log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
    final SWFList swfs1=swfs;
    final boolean first1=first;
    first=false;
    if (firstSWF == null) {
      firstSWF=swfs1.get(0);
    }
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          ensureMainFrame();
          mainFrame.getPanel().load(swfs1,first1);
        }
      }
);
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,null,ex);
    }
  }
  loadingDialog.setVisible(false);
  final SWF fswf=firstSWF;
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      if (mainFrame != null) {
        mainFrame.setVisible(true);
      }
      Main.stopWork();
      if (mainFrame != null && Configuration.gotoMainClassOnStartup.get()) {
        mainFrame.getPanel().gotoDocumentClass(fswf);
      }
    }
  }
);
  return true;
}",0.8950843727072634
61768,"public void convertPackaged(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ScriptExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  Namespace ns=abc.constants.getMultiname(name_index).getNamespace(abc.constants);
  if ((ns.kind == Namespace.KIND_PACKAGE) || (ns.kind == Namespace.KIND_PACKAGE_INTERNAL)) {
    String nsname=ns.getName(abc.constants);
    convert(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  }
}","public void convertPackaged(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ScriptExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  Namespace ns=abc.constants.getMultiname(name_index).getNamespace(abc.constants);
  if ((ns.kind == Namespace.KIND_PACKAGE) || (ns.kind == Namespace.KIND_PACKAGE_INTERNAL)) {
    convert(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  }
}",0.9615713065755764
61769,"public String getModifiers(List<ABCContainerTag> abcTags,ABC abc,boolean isStatic){
  String ret=""String_Node_Str"";
  if ((kindFlags & ATTR_Override) > 0) {
    ret+=""String_Node_Str"";
  }
  Multiname m=getName(abc);
  if (m != null) {
    String nsname=""String_Node_Str"";
{
      for (      ABCContainerTag abcTag : abcTags) {
        if (m.namespace_index == -1) {
          break;
        }
        nsname=abcTag.getABC().nsValueToName(abc.constants.getNamespace(m.namespace_index).getName(abc.constants));
        if (nsname.equals(""String_Node_Str"")) {
          break;
        }
        if (nsname.contains(""String_Node_Str"")) {
          nsname=nsname.substring(nsname.lastIndexOf('.') + 1);
        }
        if (!nsname.isEmpty()) {
          break;
        }
      }
    }
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname.contains(""String_Node_Str"")) {
      nsname=""String_Node_Str"";
    }
    if ((!nsname.isEmpty()) && (!nsname.equals(""String_Node_Str""))) {
    }
 else {
      if (ns != null) {
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          nsname=ns.getName(abc.constants);
        }
      }
    }
    if ((!nsname.contains(""String_Node_Str"")) && (!nsname.isEmpty())) {
      ret+=""String_Node_Str"" + nsname;
    }
    if (ns != null) {
      ret+=""String_Node_Str"" + ns.getPrefix(abc);
    }
  }
  if (isStatic) {
    ret+=""String_Node_Str"";
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      ret+=""String_Node_Str"";
    }
  }
  return ret.trim();
}","public String getModifiers(List<ABCContainerTag> abcTags,ABC abc,boolean isStatic){
  String ret=""String_Node_Str"";
  if ((kindFlags & ATTR_Override) > 0) {
    ret+=""String_Node_Str"";
  }
  Multiname m=getName(abc);
  if (m != null) {
    String nsname=""String_Node_Str"";
{
      for (      ABCContainerTag abcTag : abcTags) {
        if (m.namespace_index == -1) {
          break;
        }
        nsname=abcTag.getABC().nsValueToName(abc.constants.getNamespace(m.namespace_index).getName(abc.constants));
        if (nsname == null) {
          break;
        }
        if (nsname.contains(""String_Node_Str"")) {
          nsname=nsname.substring(nsname.lastIndexOf('.') + 1);
        }
        if (!nsname.isEmpty()) {
          break;
        }
      }
    }
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname.contains(""String_Node_Str"")) {
      nsname=""String_Node_Str"";
    }
    if ((!nsname.isEmpty()) && (!nsname.equals(""String_Node_Str""))) {
    }
 else {
      if (ns != null) {
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          nsname=ns.getName(abc.constants);
        }
      }
    }
    if (nsname != null && (!nsname.contains(""String_Node_Str"")) && (!nsname.isEmpty())) {
      ret+=""String_Node_Str"" + nsname;
    }
    if (ns != null) {
      ret+=""String_Node_Str"" + ns.getPrefix(abc);
    }
  }
  if (isStatic) {
    ret+=""String_Node_Str"";
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      ret+=""String_Node_Str"";
    }
  }
  return ret.trim();
}",0.9834656084656084
61770,"private void parseImportsUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants);
  if (parseUsagesFromNS(abcTags,abc,imports,uses,namespace_index,ignorePackage,name)) {
    return;
  }
 else   if ((ns.kind != Namespace.KIND_PACKAGE) && (ns.kind != Namespace.KIND_PACKAGE_INTERNAL)) {
    return;
  }
  if (newimport.equals(""String_Node_Str"")) {
    newimport=""String_Node_Str"";
  }
  newimport+=""String_Node_Str"" + name;
  if (newimport.contains(""String_Node_Str"")) {
    return;
  }
  if (!imports.contains(newimport)) {
    String pkg=newimport.substring(0,newimport.lastIndexOf('.'));
    if (!pkg.equals(ignorePackage)) {
      imports.add(newimport);
    }
  }
}","private void parseImportsUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants);
  if (parseUsagesFromNS(abcTags,abc,imports,uses,namespace_index,ignorePackage,name)) {
    return;
  }
 else   if ((ns.kind != Namespace.KIND_PACKAGE) && (ns.kind != Namespace.KIND_PACKAGE_INTERNAL)) {
    return;
  }
  if (newimport == null) {
    newimport=""String_Node_Str"";
  }
  newimport+=""String_Node_Str"" + name;
  if (newimport.contains(""String_Node_Str"")) {
    return;
  }
  if (!imports.contains(newimport)) {
    String pkg=newimport.substring(0,newimport.lastIndexOf('.'));
    if (!pkg.equals(ignorePackage)) {
      imports.add(newimport);
    }
  }
}",0.9834983498349836
61771,"private boolean parseUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants);
  if ((ns.kind != Namespace.KIND_PACKAGE) && (ns.kind != Namespace.KIND_NAMESPACE) && (ns.kind != Namespace.KIND_STATIC_PROTECTED)) {
    return false;
  }
{
    String oldimport=newimport;
    newimport=null;
    for (    ABCContainerTag abcTag : abcTags) {
      String newname=abcTag.getABC().nsValueToName(oldimport);
      if (newname.equals(""String_Node_Str"")) {
        return true;
      }
      if (!newname.isEmpty()) {
        newimport=newname;
        break;
      }
    }
    if (newimport == null) {
      newimport=oldimport;
      newimport+=""String_Node_Str"" + name;
    }
    if (newimport.isEmpty()) {
      newimport=null;
    }
    if (newimport != null) {
      if (!imports.contains(newimport)) {
        if (newimport.contains(""String_Node_Str"")) {
          return true;
        }
        String pkg=""String_Node_Str"";
        if (newimport.contains(""String_Node_Str"")) {
          pkg=newimport.substring(0,newimport.lastIndexOf('.'));
        }
        String usname=newimport;
        if (usname.contains(""String_Node_Str"")) {
          usname=usname.substring(usname.lastIndexOf('.') + 1);
        }
        if (ns.kind == Namespace.KIND_PACKAGE) {
          if (!pkg.equals(ignorePackage)) {
            imports.add(newimport);
          }
        }
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          if (!usname.equals(""String_Node_Str"")) {
            if (!uses.contains(usname)) {
              uses.add(usname);
            }
            if (!pkg.equals(ignorePackage)) {
              imports.add(newimport);
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}","private boolean parseUsagesFromNS(List<ABCContainerTag> abcTags,ABC abc,List<String> imports,List<String> uses,int namespace_index,String ignorePackage,String name){
  Namespace ns=abc.constants.getNamespace(namespace_index);
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  String newimport=ns.getName(abc.constants);
  if ((ns.kind != Namespace.KIND_PACKAGE) && (ns.kind != Namespace.KIND_NAMESPACE) && (ns.kind != Namespace.KIND_STATIC_PROTECTED)) {
    return false;
  }
{
    String oldimport=newimport;
    newimport=null;
    for (    ABCContainerTag abcTag : abcTags) {
      String newname=abcTag.getABC().nsValueToName(oldimport);
      if (newname.equals(""String_Node_Str"")) {
        return true;
      }
      if (!newname.isEmpty()) {
        newimport=newname;
        break;
      }
    }
    if (newimport == null) {
      newimport=oldimport;
      newimport+=""String_Node_Str"" + name;
    }
    if (newimport != null && newimport.isEmpty()) {
      newimport=null;
    }
    if (newimport != null) {
      if (!imports.contains(newimport)) {
        if (newimport.contains(""String_Node_Str"")) {
          return true;
        }
        String pkg=""String_Node_Str"";
        if (newimport.contains(""String_Node_Str"")) {
          pkg=newimport.substring(0,newimport.lastIndexOf('.'));
        }
        String usname=newimport;
        if (usname.contains(""String_Node_Str"")) {
          usname=usname.substring(usname.lastIndexOf('.') + 1);
        }
        if (ns.kind == Namespace.KIND_PACKAGE) {
          if (!pkg.equals(ignorePackage)) {
            imports.add(newimport);
          }
        }
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          if (!usname.equals(""String_Node_Str"")) {
            if (!uses.contains(usname)) {
              uses.add(usname);
            }
            if (!pkg.equals(ignorePackage)) {
              imports.add(newimport);
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.994706327199395
61772,"/** 
 * Returns the value for the cell at <code>columnIndex</code> and <code>rowIndex</code>.
 * @param rowIndex the row whose value is to be queried
 * @param columnIndex the column whose value is to be queried
 * @return the value Object at the specified cell
 */
@Override public Object getValueAt(int rowIndex,int columnIndex){
switch (columnIndex) {
case 0:
    return rowIndex;
case 1:
  if (rowIndex == 0) {
    return ""String_Node_Str"";
  }
return abc.constants.getNamespace(rowIndex).getKindStr();
case 2:
if (rowIndex == 0) {
return ""String_Node_Str"";
}
return abc.constants.getNamespace(rowIndex).getName(abc.constants);
default :
return null;
}
}","/** 
 * Returns the value for the cell at <code>columnIndex</code> and <code>rowIndex</code>.
 * @param rowIndex the row whose value is to be queried
 * @param columnIndex the column whose value is to be queried
 * @return the value Object at the specified cell
 */
@Override public Object getValueAt(int rowIndex,int columnIndex){
switch (columnIndex) {
case 0:
    return rowIndex;
case 1:
  if (rowIndex == 0) {
    return ""String_Node_Str"";
  }
return abc.constants.getNamespace(rowIndex).getKindStr();
case 2:
if (rowIndex == 0) {
return ""String_Node_Str"";
}
String val=abc.constants.getNamespace(rowIndex).getName(abc.constants);
if (val == null) {
val=""String_Node_Str"";
}
return val;
default :
return null;
}
}",0.943313953488372
61773,"public int resolveClass(ABC abc){
  String name=fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf(""String_Node_Str""));
    name=name.substring(name.lastIndexOf(""String_Node_Str"") + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname.getName(abc.constants,new ArrayList<String>()).equals(name)) {
      if (mname.getNamespace(abc.constants).getName(abc.constants).equals(pkg)) {
        return ii.name_index;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        return i;
      }
    }
  }
  return abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
}","public int resolveClass(ABC abc){
  String name=fullTypeName;
  String pkg=""String_Node_Str"";
  if (name.contains(""String_Node_Str"")) {
    pkg=name.substring(0,name.lastIndexOf(""String_Node_Str""));
    name=name.substring(name.lastIndexOf(""String_Node_Str"") + 1);
  }
  for (  InstanceInfo ii : abc.instance_info) {
    Multiname mname=abc.constants.constant_multiname.get(ii.name_index);
    if (mname.getName(abc.constants,new ArrayList<String>()).equals(name)) {
      if (mname.getNamespace(abc.constants).hasName(pkg,abc.constants)) {
        return ii.name_index;
      }
    }
  }
  for (int i=1; i < abc.constants.constant_multiname.size(); i++) {
    Multiname mname=abc.constants.constant_multiname.get(i);
    if (name.equals(mname.getName(abc.constants,new ArrayList<String>()))) {
      if (pkg.equals(mname.getNamespace(abc.constants).getName(abc.constants))) {
        return i;
      }
    }
  }
  return abc.constants.getMultinameId(new Multiname(Multiname.QNAME,abc.constants.getStringId(name,true),abc.constants.getNamespaceId(new Namespace(Namespace.KIND_PACKAGE,abc.constants.getStringId(pkg,true)),0,true),0,0,new ArrayList<Integer>()),true);
}",0.9786507258753202
61774,"public void init(BaseLocalData localData) throws InterruptedException {
  if (heads != null) {
    return;
  }
  heads=makeGraph(code,new ArrayList<GraphPart>(),alternateEntries);
  int time=1;
  List<GraphPart> ordered=new ArrayList<>();
  List<GraphPart> visited=new ArrayList<>();
  for (  GraphPart head : heads) {
    time=head.setTime(time,ordered,visited);
    fixGraph(localData,head);
    makeMulti(head,new ArrayList<GraphPart>());
  }
}","public void init(BaseLocalData localData) throws InterruptedException {
  if (heads != null) {
    return;
  }
  heads=makeGraph(code,new ArrayList<GraphPart>(),alternateEntries);
  int time=1;
  List<GraphPart> ordered=new ArrayList<>();
  List<GraphPart> visited=new ArrayList<>();
  for (  GraphPart head : heads) {
    time=head.setTime(time,ordered,visited);
  }
}",0.9044117647058824
61775,"private static void loadProperties(){
  Properties prop=new Properties();
  try {
    prop.load(ApplicationInfo.class.getResourceAsStream(""String_Node_Str""));
    version=prop.getProperty(""String_Node_Str"");
    build=prop.getProperty(""String_Node_Str"");
    nightly=prop.getProperty(""String_Node_Str"");
    if (nightly.equals(""String_Node_Str"")) {
      version=version + ""String_Node_Str"" + build;
    }
  }
 catch (  IOException|NullPointerException ex) {
    version=""String_Node_Str"";
  }
  applicationVerName=APPLICATION_NAME + ""String_Node_Str"" + version;
  updatePage=updatePageStub + version;
  shortApplicationVerName=SHORT_APPLICATION_NAME + ""String_Node_Str"" + version;
}","private static void loadProperties(){
  Properties prop=new Properties();
  try {
    prop.load(ApplicationInfo.class.getResourceAsStream(""String_Node_Str""));
    version=prop.getProperty(""String_Node_Str"");
    build=prop.getProperty(""String_Node_Str"");
    nightly=prop.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
    if (nightly) {
      version=version + ""String_Node_Str"" + build;
    }
  }
 catch (  IOException|NullPointerException ex) {
    version=""String_Node_Str"";
  }
  applicationVerName=APPLICATION_NAME + ""String_Node_Str"" + version;
  updatePage=updatePageStub + version;
  shortApplicationVerName=SHORT_APPLICATION_NAME + ""String_Node_Str"" + version;
}",0.9619326500732064
61776,"public static boolean checkForUpdates(){
  List<String> accepted=new ArrayList<>();
  if (Configuration.checkForUpdatesStable.get()) {
    accepted.add(""String_Node_Str"");
  }
  if (Configuration.checkForUpdatesNightly.get()) {
    accepted.add(""String_Node_Str"");
  }
  if (accepted.isEmpty()) {
    return false;
  }
  String acceptVersions=""String_Node_Str"";
  for (  String a : accepted) {
    if (!acceptVersions.equals(""String_Node_Str"")) {
      acceptVersions+=""String_Node_Str"";
    }
    acceptVersions+=a;
  }
  try {
    Socket sock=new Socket(""String_Node_Str"",80);
    OutputStream os=sock.getOutputStream();
    String currentLoc=Configuration.locale.get(""String_Node_Str"");
    os.write((""String_Node_Str"" + ApplicationInfo.version + ""String_Node_Str""+ ApplicationInfo.build+ ""String_Node_Str""+ ApplicationInfo.nightly+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ acceptVersions+ ""String_Node_Str""+ ""String_Node_Str""+ UPDATE_SYSTEM_MAJOR+ ""String_Node_Str""+ ""String_Node_Str""+ UPDATE_SYSTEM_MINOR+ ""String_Node_Str""+ ""String_Node_Str""+ ApplicationInfo.shortApplicationVerName+ ""String_Node_Str""+ ""String_Node_Str""+ currentLoc+ (""String_Node_Str"".equals(currentLoc) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes());
    BufferedReader br=new BufferedReader(new InputStreamReader(sock.getInputStream()));
    String s;
    boolean start=false;
    final java.util.List<Version> versions=new ArrayList<>();
    String header=""String_Node_Str"";
    Pattern headerPat=Pattern.compile(""String_Node_Str"");
    int updateMajor=0;
    int updateMinor=0;
    Version ver=null;
    while ((s=br.readLine()) != null) {
      if (start) {
        Matcher m=headerPat.matcher(s);
        if (m.matches()) {
          header=m.group(1);
          if (header.equals(""String_Node_Str"")) {
            ver=new Version();
            versions.add(ver);
          }
          if (header.equals(""String_Node_Str"")) {
            break;
          }
        }
 else {
          if (s.contains(""String_Node_Str"")) {
            String key=s.substring(0,s.indexOf('='));
            String val=s.substring(s.indexOf('=') + 1);
            if (""String_Node_Str"".equals(header)) {
              if (key.equals(""String_Node_Str"")) {
                updateMajor=Integer.parseInt(val);
                if (updateMajor > UPDATE_SYSTEM_MAJOR) {
                  break;
                }
              }
              if (key.equals(""String_Node_Str"")) {
                updateMinor=Integer.parseInt(val);
              }
            }
            if (""String_Node_Str"".equals(header) && (ver != null)) {
              if (key.equals(""String_Node_Str"")) {
                ver.versionId=Integer.parseInt(val);
              }
              if (key.equals(""String_Node_Str"")) {
                ver.versionName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.nightly=val.equals(""String_Node_Str"");
              }
              if (key.equals(""String_Node_Str"")) {
                ver.revision=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.longVersionName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.releaseDate=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.appName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.appFullName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.updateLink=val;
              }
              if (key.equals(""String_Node_Str"")) {
                String changeType=val.substring(0,val.indexOf('|'));
                String change=val.substring(val.indexOf('|') + 1);
                if (!ver.changes.containsKey(changeType)) {
                  ver.changes.put(changeType,new ArrayList<String>());
                }
                java.util.List<String> chlist=ver.changes.get(changeType);
                chlist.add(change);
              }
            }
          }
        }
      }
      if (s.isEmpty()) {
        start=true;
      }
    }
    if (!versions.isEmpty()) {
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          NewVersionDialog newVersionDialog=new NewVersionDialog(versions);
          newVersionDialog.setVisible(true);
          Configuration.lastUpdatesCheckDate.set(Calendar.getInstance());
        }
      }
);
      return true;
    }
  }
 catch (  IOException|NumberFormatException ex) {
    return false;
  }
  Configuration.lastUpdatesCheckDate.set(Calendar.getInstance());
  return false;
}","public static boolean checkForUpdates(){
  List<String> accepted=new ArrayList<>();
  if (Configuration.checkForUpdatesStable.get()) {
    accepted.add(""String_Node_Str"");
  }
  if (Configuration.checkForUpdatesNightly.get()) {
    accepted.add(""String_Node_Str"");
  }
  if (accepted.isEmpty()) {
    return false;
  }
  String acceptVersions=""String_Node_Str"";
  for (  String a : accepted) {
    if (!acceptVersions.equals(""String_Node_Str"")) {
      acceptVersions+=""String_Node_Str"";
    }
    acceptVersions+=a;
  }
  try {
    Socket sock=new Socket(""String_Node_Str"",80);
    OutputStream os=sock.getOutputStream();
    String currentLoc=Configuration.locale.get(""String_Node_Str"");
    os.write((""String_Node_Str"" + URLEncoder.encode(ApplicationInfo.version,""String_Node_Str"") + ""String_Node_Str""+ URLEncoder.encode(ApplicationInfo.build,""String_Node_Str"")+ ""String_Node_Str""+ (ApplicationInfo.nightly ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ acceptVersions+ ""String_Node_Str""+ ""String_Node_Str""+ UPDATE_SYSTEM_MAJOR+ ""String_Node_Str""+ ""String_Node_Str""+ UPDATE_SYSTEM_MINOR+ ""String_Node_Str""+ ""String_Node_Str""+ ApplicationInfo.shortApplicationVerName+ ""String_Node_Str""+ ""String_Node_Str""+ currentLoc+ (""String_Node_Str"".equals(currentLoc) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes());
    BufferedReader br=new BufferedReader(new InputStreamReader(sock.getInputStream()));
    String s;
    boolean start=false;
    final java.util.List<Version> versions=new ArrayList<>();
    String header=""String_Node_Str"";
    Pattern headerPat=Pattern.compile(""String_Node_Str"");
    int updateMajor=0;
    int updateMinor=0;
    Version ver=null;
    while ((s=br.readLine()) != null) {
      if (start) {
        Matcher m=headerPat.matcher(s);
        if (m.matches()) {
          header=m.group(1);
          if (header.equals(""String_Node_Str"")) {
            ver=new Version();
            versions.add(ver);
          }
          if (header.equals(""String_Node_Str"")) {
            break;
          }
        }
 else {
          if (s.contains(""String_Node_Str"")) {
            String key=s.substring(0,s.indexOf('='));
            String val=s.substring(s.indexOf('=') + 1);
            if (""String_Node_Str"".equals(header)) {
              if (key.equals(""String_Node_Str"")) {
                updateMajor=Integer.parseInt(val);
                if (updateMajor > UPDATE_SYSTEM_MAJOR) {
                  break;
                }
              }
              if (key.equals(""String_Node_Str"")) {
                updateMinor=Integer.parseInt(val);
              }
            }
            if (""String_Node_Str"".equals(header) && (ver != null)) {
              if (key.equals(""String_Node_Str"")) {
                ver.versionId=Integer.parseInt(val);
              }
              if (key.equals(""String_Node_Str"")) {
                ver.versionName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.nightly=val.equals(""String_Node_Str"");
              }
              if (key.equals(""String_Node_Str"")) {
                ver.revision=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.longVersionName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.releaseDate=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.appName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.appFullName=val;
              }
              if (key.equals(""String_Node_Str"")) {
                ver.updateLink=val;
              }
              if (key.equals(""String_Node_Str"")) {
                String changeType=val.substring(0,val.indexOf('|'));
                String change=val.substring(val.indexOf('|') + 1);
                if (!ver.changes.containsKey(changeType)) {
                  ver.changes.put(changeType,new ArrayList<String>());
                }
                java.util.List<String> chlist=ver.changes.get(changeType);
                chlist.add(change);
              }
            }
          }
        }
      }
      if (s.isEmpty()) {
        start=true;
      }
    }
    if (!versions.isEmpty()) {
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          NewVersionDialog newVersionDialog=new NewVersionDialog(versions);
          newVersionDialog.setVisible(true);
          Configuration.lastUpdatesCheckDate.set(Calendar.getInstance());
        }
      }
);
      return true;
    }
  }
 catch (  IOException|NumberFormatException ex) {
    return false;
  }
  Configuration.lastUpdatesCheckDate.set(Calendar.getInstance());
  return false;
}",0.9878483134297088
61777,"public byte[] getDataOrOriginalData(){
  if (modified) {
    return getData();
  }
  return data;
}","public byte[] getDataOrOriginalData(){
  if (isModified()) {
    return getData();
  }
  return data;
}",0.9702970297029704
61778,"public String builtInNs(String ns){
  if (ns.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (ns.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  return null;
}","public String builtInNs(String ns){
  if (ns == null) {
    return null;
  }
  if (ns.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (ns.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  return null;
}",0.9053117782909932
61779,"@Override public void run(){
  int startPos=0;
synchronized (playLock) {
    startPos=actualPos * FRAME_DIVISOR;
    paused=false;
  }
  player.setPosition(startPos);
  player.play();
  boolean playAgain=false;
synchronized (playLock) {
    playAgain=!paused;
    paused=true;
    if (loops > 0) {
      loops--;
    }
  }
  if (playAgain && loops > 0) {
    gotoFrame(0);
    run();
    return;
  }
 else {
    fireFinished();
  }
synchronized (playLock) {
    playLock.notifyAll();
  }
}","@Override public void run(){
  boolean playAgain=true;
  while (playAgain) {
    int startPos=0;
synchronized (playLock) {
      startPos=actualPos * FRAME_DIVISOR;
    }
    player.setPosition(startPos);
    player.play();
synchronized (playLock) {
      playAgain=!paused && loops > 0;
      if (!paused) {
        if (loops == 0) {
          paused=true;
        }
 else         if (loops != Integer.MAX_VALUE) {
          loops--;
        }
      }
      if (playAgain) {
        actualPos=0;
      }
    }
  }
  fireFinished();
synchronized (playLock) {
    playLock.notifyAll();
  }
}",0.4189063948100092
61780,"@Override public synchronized void pause(){
  if (!isPlaying()) {
    paused=true;
    return;
  }
synchronized (playLock) {
    actualPos=(int)(player.getSamplePosition() / FRAME_DIVISOR);
    paused=true;
    player.stop();
    try {
      playLock.wait();
    }
 catch (    InterruptedException ex) {
      Logger.getLogger(SoundTagPlayer.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}","@Override public synchronized void pause(){
  if (!isPlaying()) {
    paused=true;
    return;
  }
synchronized (playLock) {
    actualPos=(int)(player.getSamplePosition() / FRAME_DIVISOR);
  }
  waitStop();
}",0.6501650165016502
61781,"@Override public synchronized int getCurrentFrame(){
  if (!isPlaying()) {
    return actualPos;
  }
synchronized (playLock) {
    actualPos=(int)(player.getSamplePosition() / FRAME_DIVISOR);
  }
  return actualPos;
}","@Override public synchronized int getCurrentFrame(){
synchronized (playLock) {
    if (isPlaying()) {
      actualPos=(int)(player.getSamplePosition() / FRAME_DIVISOR);
    }
    return actualPos;
  }
}",0.7923627684964201
61782,"/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  if (Configuration.debugCopy.get()) {
    sos=new SWFOutputStream(new CopyOutputStream(sos,new ByteArrayInputStream(data)),10);
  }
  try {
    sos.writeUI16(fontId);
    sos.writeUB(1,fontFlagsHasLayout ? 1 : 0);
    sos.writeUB(1,fontFlagsShiftJIS ? 1 : 0);
    sos.writeUB(1,fontFlagsSmallText ? 1 : 0);
    sos.writeUB(1,fontFlagsANSI ? 1 : 0);
    sos.writeUB(1,fontFlagsWideOffsets ? 1 : 0);
    sos.writeUB(1,fontFlagsWideCodes ? 1 : 0);
    sos.writeUB(1,fontFlagsItalic ? 1 : 0);
    sos.writeUB(1,fontFlagsBold ? 1 : 0);
    sos.writeLANGCODE(languageCode);
    byte[] fontNameBytes=Utf8Helper.getBytes(fontName);
    sos.writeUI8(fontNameBytes.length);
    sos.write(fontNameBytes);
    sos.writeUI16(numGlyphs);
    List<Long> offsetTable=new ArrayList<>();
    ByteArrayOutputStream baosGlyphShapes=new ByteArrayOutputStream();
    SWFOutputStream sos3=new SWFOutputStream(baosGlyphShapes,getVersion());
    for (int i=0; i < numGlyphs; i++) {
      offsetTable.add((glyphShapeTable.size() + 1) * (fontFlagsWideOffsets ? 4 : 2) + sos3.getPos());
      sos3.writeSHAPE(glyphShapeTable.get(i),1);
    }
    byte[] baGlyphShapes=baosGlyphShapes.toByteArray();
    for (    Long offset : offsetTable) {
      if (fontFlagsWideOffsets) {
        sos.writeUI32(offset);
      }
 else {
        sos.writeUI16((int)(long)offset);
      }
    }
    if (numGlyphs > 0) {
      long offset=(glyphShapeTable.size() + 1) * (fontFlagsWideOffsets ? 4 : 2) + baGlyphShapes.length;
      if (fontFlagsWideOffsets) {
        sos.writeUI32(offset);
      }
 else {
        sos.writeUI16((int)offset);
      }
      sos.write(baGlyphShapes);
      for (int i=0; i < numGlyphs; i++) {
        if (fontFlagsWideCodes) {
          sos.writeUI16(codeTable.get(i));
        }
 else {
          sos.writeUI8(codeTable.get(i));
        }
      }
    }
    if (fontFlagsHasLayout) {
      sos.writeSI16(fontAscent);
      sos.writeSI16(fontDescent);
      sos.writeSI16(fontLeading);
      for (int i=0; i < numGlyphs; i++) {
        sos.writeSI16(fontAdvanceTable.get(i));
      }
      for (int i=0; i < numGlyphs; i++) {
        sos.writeRECT(fontBoundsTable.get(i));
      }
      sos.writeUI16(fontKerningTable.length);
      for (int k=0; k < fontKerningTable.length; k++) {
        sos.writeKERNINGRECORD(fontKerningTable[k],fontFlagsWideCodes);
      }
    }
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @return Bytes of data
 */
@Override public byte[] getData(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,getVersion());
  if (Configuration.debugCopy.get()) {
    sos=new SWFOutputStream(new CopyOutputStream(sos,new ByteArrayInputStream(data)),10);
  }
  try {
    List<Long> offsetTable=new ArrayList<>();
    ByteArrayOutputStream baosGlyphShapes=new ByteArrayOutputStream();
    SWFOutputStream sos3=new SWFOutputStream(baosGlyphShapes,getVersion());
    for (int i=0; i < numGlyphs; i++) {
      offsetTable.add(sos3.getPos());
      sos3.writeSHAPE(glyphShapeTable.get(i),1);
    }
    byte[] baGlyphShapes=baosGlyphShapes.toByteArray();
    if (!fontFlagsWideOffsets && numGlyphs > 0) {
      long maxOffset=(glyphShapeTable.size() + 1) * 2 + baGlyphShapes.length;
      if (maxOffset > 65535) {
        fontFlagsWideOffsets=true;
      }
    }
    sos.writeUI16(fontId);
    sos.writeUB(1,fontFlagsHasLayout ? 1 : 0);
    sos.writeUB(1,fontFlagsShiftJIS ? 1 : 0);
    sos.writeUB(1,fontFlagsSmallText ? 1 : 0);
    sos.writeUB(1,fontFlagsANSI ? 1 : 0);
    sos.writeUB(1,fontFlagsWideOffsets ? 1 : 0);
    sos.writeUB(1,fontFlagsWideCodes ? 1 : 0);
    sos.writeUB(1,fontFlagsItalic ? 1 : 0);
    sos.writeUB(1,fontFlagsBold ? 1 : 0);
    sos.writeLANGCODE(languageCode);
    byte[] fontNameBytes=Utf8Helper.getBytes(fontName);
    sos.writeUI8(fontNameBytes.length);
    sos.write(fontNameBytes);
    sos.writeUI16(numGlyphs);
    for (    long offset : offsetTable) {
      long offset2=(glyphShapeTable.size() + 1) * (fontFlagsWideOffsets ? 4 : 2) + offset;
      if (fontFlagsWideOffsets) {
        sos.writeUI32(offset2);
      }
 else {
        sos.writeUI16((int)offset2);
      }
    }
    if (numGlyphs > 0) {
      long offset=(glyphShapeTable.size() + 1) * (fontFlagsWideOffsets ? 4 : 2) + baGlyphShapes.length;
      if (fontFlagsWideOffsets) {
        sos.writeUI32(offset);
      }
 else {
        sos.writeUI16((int)offset);
      }
      sos.write(baGlyphShapes);
      for (int i=0; i < numGlyphs; i++) {
        if (fontFlagsWideCodes) {
          sos.writeUI16(codeTable.get(i));
        }
 else {
          sos.writeUI8(codeTable.get(i));
        }
      }
    }
    if (fontFlagsHasLayout) {
      sos.writeSI16(fontAscent);
      sos.writeSI16(fontDescent);
      sos.writeSI16(fontLeading);
      for (int i=0; i < numGlyphs; i++) {
        sos.writeSI16(fontAdvanceTable.get(i));
      }
      for (int i=0; i < numGlyphs; i++) {
        sos.writeRECT(fontBoundsTable.get(i));
      }
      sos.writeUI16(fontKerningTable.length);
      for (int k=0; k < fontKerningTable.length; k++) {
        sos.writeKERNINGRECORD(fontKerningTable[k],fontFlagsWideCodes);
      }
    }
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.7845123937036367
61783,"public int readU30() throws IOException {
  return readU32();
}","public int readU30() throws IOException {
  return (int)readU32();
}",0.9618320610687024
61784,"public int readU32() throws IOException {
  int i;
  int ret=0;
  int bytePos=0;
  int byteCount=0;
  boolean nextByte;
  do {
    i=read();
    nextByte=(i >> 7) == 1;
    i&=0x7f;
    ret+=(i << bytePos);
    byteCount++;
    bytePos+=7;
  }
 while (nextByte);
  return ret;
}","public long readU32() throws IOException {
  int i;
  long ret=0;
  int bytePos=0;
  int byteCount=0;
  boolean nextByte;
  do {
    i=read();
    nextByte=(i >> 7) == 1;
    i&=0x7f;
    ret+=(((long)i) << bytePos);
    byteCount++;
    bytePos+=7;
  }
 while (nextByte);
  return ret;
}",0.9575971731448764
61785,"private int renameAS2Identifiers(RenameType renameType,Map<String,String> selected) throws InterruptedException {
  actionsMap=new HashMap<>();
  allFunctions=new ArrayList<>();
  allVariableNames=new ArrayList<>();
  allStrings=new HashMap<>();
  List<ContainerItem> objs=new ArrayList<>();
  int ret=0;
  objs.addAll(tags);
  getVariables(objs,""String_Node_Str"");
  informListeners(""String_Node_Str"",""String_Node_Str"");
  int fc=0;
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    String name=it.key.toStringNoH(it.value);
    deobfuscation.allVariableNamesStr.add(name);
  }
  informListeners(""String_Node_Str"",""String_Node_Str"");
  int classCount=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      classCount++;
    }
  }
  int cnt=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      cnt++;
      informListeners(""String_Node_Str"",""String_Node_Str"" + cnt + ""String_Node_Str""+ classCount);
      DoInitActionTag dia=(DoInitActionTag)t;
      String exportName=dia.getExportName();
      final String pkgPrefix=""String_Node_Str"";
      String[] classNameParts=null;
      if ((exportName != null) && exportName.startsWith(pkgPrefix)) {
        String className=exportName.substring(pkgPrefix.length());
        if (className.contains(""String_Node_Str"")) {
          classNameParts=className.split(""String_Node_Str"");
        }
 else {
          classNameParts=new String[]{className};
        }
      }
      int staticOperation=Graph.SOP_USE_STATIC;
      List<GraphTargetItem> dec;
      try {
        dec=Action.actionsToTree(dia.getActions(),version,staticOperation,""String_Node_Str"");
      }
 catch (      EmptyStackException ex) {
        continue;
      }
      GraphTargetItem name=null;
      for (      GraphTargetItem it : dec) {
        if (it instanceof ClassActionItem) {
          ClassActionItem cti=(ClassActionItem)it;
          List<GraphTargetItem> methods=new ArrayList<>();
          methods.addAll(cti.functions);
          methods.addAll(cti.staticFunctions);
          for (          GraphTargetItem gti : methods) {
            if (gti instanceof FunctionActionItem) {
              FunctionActionItem fun=(FunctionActionItem)gti;
              if (fun.calculatedFunctionName instanceof DirectValueActionItem) {
                DirectValueActionItem dvf=(DirectValueActionItem)fun.calculatedFunctionName;
                String fname=dvf.toStringNoH(null);
                String changed=deobfuscation.deobfuscateName(fname,false,""String_Node_Str"",deobfuscated,renameType,selected);
                if (changed != null) {
                  deobfuscated.put(fname,changed);
                }
              }
            }
          }
          List<GraphTargetItem> vars=new ArrayList<>();
          for (          MyEntry<GraphTargetItem,GraphTargetItem> item : cti.vars) {
            vars.add(item.key);
          }
          for (          MyEntry<GraphTargetItem,GraphTargetItem> item : cti.staticVars) {
            vars.add(item.key);
          }
          for (          GraphTargetItem gti : vars) {
            if (gti instanceof DirectValueActionItem) {
              DirectValueActionItem dvf=(DirectValueActionItem)gti;
              String vname=dvf.toStringNoH(null);
              String changed=deobfuscation.deobfuscateName(vname,false,""String_Node_Str"",deobfuscated,renameType,selected);
              if (changed != null) {
                deobfuscated.put(vname,changed);
              }
            }
          }
          name=cti.className;
          break;
        }
        if (it instanceof InterfaceActionItem) {
          InterfaceActionItem ift=(InterfaceActionItem)it;
          name=ift.name;
        }
      }
      if (name != null) {
        int pos=0;
        while (name instanceof GetMemberActionItem) {
          GetMemberActionItem mem=(GetMemberActionItem)name;
          GraphTargetItem memberName=mem.memberName;
          if (memberName instanceof DirectValueActionItem) {
            DirectValueActionItem dvt=(DirectValueActionItem)memberName;
            String nameStr=dvt.toStringNoH(null);
            if (classNameParts != null) {
              if (classNameParts.length - 1 - pos < 0) {
                break;
              }
            }
            String changedNameStr=nameStr;
            if (classNameParts != null) {
              changedNameStr=classNameParts[classNameParts.length - 1 - pos];
            }
            String changedNameStr2=deobfuscation.deobfuscateName(changedNameStr,pos == 0,pos == 0 ? ""String_Node_Str"" : ""String_Node_Str"",deobfuscated,renameType,selected);
            if (changedNameStr2 != null) {
              changedNameStr=changedNameStr2;
            }
            ret++;
            deobfuscated.put(nameStr,changedNameStr);
            pos++;
          }
          name=mem.object;
        }
        if (name instanceof GetVariableActionItem) {
          GetVariableActionItem var=(GetVariableActionItem)name;
          if (var.name instanceof DirectValueActionItem) {
            DirectValueActionItem dvt=(DirectValueActionItem)var.name;
            String nameStr=dvt.toStringNoH(null);
            if (classNameParts != null) {
              if (classNameParts.length - 1 - pos < 0) {
                break;
              }
            }
            String changedNameStr=nameStr;
            if (classNameParts != null) {
              changedNameStr=classNameParts[classNameParts.length - 1 - pos];
            }
            String changedNameStr2=deobfuscation.deobfuscateName(changedNameStr,pos == 0,pos == 0 ? ""String_Node_Str"" : ""String_Node_Str"",deobfuscated,renameType,selected);
            if (changedNameStr2 != null) {
              changedNameStr=changedNameStr2;
            }
            ret++;
            deobfuscated.put(nameStr,changedNameStr);
            pos++;
          }
        }
      }
    }
  }
  for (  GraphSourceItem fun : allFunctions) {
    fc++;
    informListeners(""String_Node_Str"",""String_Node_Str"" + fc + ""String_Node_Str""+ allFunctions.size());
    if (fun instanceof ActionDefineFunction) {
      ActionDefineFunction f=(ActionDefineFunction)fun;
      if (f.functionName.isEmpty()) {
        continue;
      }
      String changed=deobfuscation.deobfuscateName(f.functionName,false,""String_Node_Str"",deobfuscated,renameType,selected);
      if (changed != null) {
        f.replacedFunctionName=changed;
        ret++;
      }
    }
    if (fun instanceof ActionDefineFunction2) {
      ActionDefineFunction2 f=(ActionDefineFunction2)fun;
      if (f.functionName.isEmpty()) {
        continue;
      }
      String changed=deobfuscation.deobfuscateName(f.functionName,false,""String_Node_Str"",deobfuscated,renameType,selected);
      if (changed != null) {
        f.replacedFunctionName=changed;
        ret++;
      }
    }
  }
  HashSet<String> stringsNoVarH=new HashSet<>();
  List<DirectValueActionItem> allVariableNamesDv=new ArrayList<>();
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    allVariableNamesDv.add(it.key);
  }
  for (  DirectValueActionItem ti : allStrings.keySet()) {
    if (!allVariableNamesDv.contains(ti)) {
      stringsNoVarH.add(System.identityHashCode(allStrings.get(ti)) + ""String_Node_Str"" + ti.toStringNoH(allStrings.get(ti)));
    }
  }
  int vc=0;
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    vc++;
    String name=it.key.toStringNoH(it.value);
    String changed=deobfuscation.deobfuscateName(name,false,usageTypes.get(it.key),deobfuscated,renameType,selected);
    if (changed != null) {
      boolean addNew=false;
      String h=System.identityHashCode(it.key) + ""String_Node_Str"" + name;
      if (stringsNoVarH.contains(h)) {
        addNew=true;
      }
      ActionPush pu=(ActionPush)it.key.src;
      if (pu.replacement == null) {
        pu.replacement=new ArrayList<>();
        pu.replacement.addAll(pu.values);
      }
      if (pu.replacement.get(it.key.pos) instanceof ConstantIndex) {
        ConstantIndex ci=(ConstantIndex)pu.replacement.get(it.key.pos);
        ConstantPool pool=it.value;
        if (pool == null) {
          continue;
        }
        if (pool.constants == null) {
          continue;
        }
        if (addNew) {
          pool.constants.add(changed);
          ci.index=pool.constants.size() - 1;
        }
 else {
          pool.constants.set(ci.index,changed);
        }
      }
 else {
        pu.replacement.set(it.key.pos,changed);
      }
      ret++;
    }
  }
  for (  ASMSource src : actionsMap.keySet()) {
    actionsMap.put(src,Action.removeNops(0,actionsMap.get(src),version,0,""String_Node_Str""));
    src.setActions(actionsMap.get(src));
  }
  deobfuscation.deobfuscateInstanceNames(deobfuscated,renameType,tags,selected);
  return ret;
}","private int renameAS2Identifiers(RenameType renameType,Map<String,String> selected) throws InterruptedException {
  actionsMap=new HashMap<>();
  allFunctions=new ArrayList<>();
  allVariableNames=new ArrayList<>();
  allStrings=new HashMap<>();
  List<ContainerItem> objs=new ArrayList<>();
  int ret=0;
  objs.addAll(tags);
  getVariables(objs,""String_Node_Str"");
  informListeners(""String_Node_Str"",""String_Node_Str"");
  int fc=0;
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    String name=it.key.toStringNoH(it.value);
    deobfuscation.allVariableNamesStr.add(name);
  }
  informListeners(""String_Node_Str"",""String_Node_Str"");
  int classCount=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      classCount++;
    }
  }
  int cnt=0;
  for (  Tag t : tags) {
    if (t instanceof DoInitActionTag) {
      cnt++;
      informListeners(""String_Node_Str"",""String_Node_Str"" + cnt + ""String_Node_Str""+ classCount);
      DoInitActionTag dia=(DoInitActionTag)t;
      String exportName=dia.getExportName();
      final String pkgPrefix=""String_Node_Str"";
      String[] classNameParts=null;
      if ((exportName != null) && exportName.startsWith(pkgPrefix)) {
        String className=exportName.substring(pkgPrefix.length());
        if (className.contains(""String_Node_Str"")) {
          classNameParts=className.split(""String_Node_Str"");
        }
 else {
          classNameParts=new String[]{className};
        }
      }
      int staticOperation=Graph.SOP_USE_STATIC;
      List<GraphTargetItem> dec;
      try {
        dec=Action.actionsToTree(dia.getActions(),version,staticOperation,""String_Node_Str"");
      }
 catch (      EmptyStackException ex) {
        continue;
      }
      GraphTargetItem name=null;
      for (      GraphTargetItem it : dec) {
        if (it instanceof ClassActionItem) {
          ClassActionItem cti=(ClassActionItem)it;
          List<GraphTargetItem> methods=new ArrayList<>();
          methods.addAll(cti.functions);
          methods.addAll(cti.staticFunctions);
          for (          GraphTargetItem gti : methods) {
            if (gti instanceof FunctionActionItem) {
              FunctionActionItem fun=(FunctionActionItem)gti;
              if (fun.calculatedFunctionName instanceof DirectValueActionItem) {
                DirectValueActionItem dvf=(DirectValueActionItem)fun.calculatedFunctionName;
                String fname=dvf.toStringNoH(null);
                String changed=deobfuscation.deobfuscateName(fname,false,""String_Node_Str"",deobfuscated,renameType,selected);
                if (changed != null) {
                  deobfuscated.put(fname,changed);
                }
              }
            }
          }
          List<GraphTargetItem> vars=new ArrayList<>();
          for (          MyEntry<GraphTargetItem,GraphTargetItem> item : cti.vars) {
            vars.add(item.key);
          }
          for (          MyEntry<GraphTargetItem,GraphTargetItem> item : cti.staticVars) {
            vars.add(item.key);
          }
          for (          GraphTargetItem gti : vars) {
            if (gti instanceof DirectValueActionItem) {
              DirectValueActionItem dvf=(DirectValueActionItem)gti;
              String vname=dvf.toStringNoH(null);
              String changed=deobfuscation.deobfuscateName(vname,false,""String_Node_Str"",deobfuscated,renameType,selected);
              if (changed != null) {
                deobfuscated.put(vname,changed);
              }
            }
          }
          name=cti.className;
          break;
        }
        if (it instanceof InterfaceActionItem) {
          InterfaceActionItem ift=(InterfaceActionItem)it;
          name=ift.name;
        }
      }
      if (name != null) {
        int pos=0;
        while (name instanceof GetMemberActionItem) {
          GetMemberActionItem mem=(GetMemberActionItem)name;
          GraphTargetItem memberName=mem.memberName;
          if (memberName instanceof DirectValueActionItem) {
            DirectValueActionItem dvt=(DirectValueActionItem)memberName;
            String nameStr=dvt.toStringNoH(null);
            if (classNameParts != null) {
              if (classNameParts.length - 1 - pos < 0) {
                break;
              }
            }
            String changedNameStr=nameStr;
            if (classNameParts != null) {
              changedNameStr=classNameParts[classNameParts.length - 1 - pos];
            }
            String changedNameStr2=deobfuscation.deobfuscateName(changedNameStr,pos == 0,pos == 0 ? ""String_Node_Str"" : ""String_Node_Str"",deobfuscated,renameType,selected);
            if (changedNameStr2 != null) {
              changedNameStr=changedNameStr2;
            }
            ret++;
            deobfuscated.put(nameStr,changedNameStr);
            pos++;
          }
          name=mem.object;
        }
        if (name instanceof GetVariableActionItem) {
          GetVariableActionItem var=(GetVariableActionItem)name;
          if (var.name instanceof DirectValueActionItem) {
            DirectValueActionItem dvt=(DirectValueActionItem)var.name;
            String nameStr=dvt.toStringNoH(null);
            if (classNameParts != null) {
              if (classNameParts.length - 1 - pos < 0) {
                break;
              }
            }
            String changedNameStr=nameStr;
            if (classNameParts != null) {
              changedNameStr=classNameParts[classNameParts.length - 1 - pos];
            }
            String changedNameStr2=deobfuscation.deobfuscateName(changedNameStr,pos == 0,pos == 0 ? ""String_Node_Str"" : ""String_Node_Str"",deobfuscated,renameType,selected);
            if (changedNameStr2 != null) {
              changedNameStr=changedNameStr2;
            }
            ret++;
            deobfuscated.put(nameStr,changedNameStr);
            pos++;
          }
        }
      }
    }
  }
  for (  GraphSourceItem fun : allFunctions) {
    fc++;
    informListeners(""String_Node_Str"",""String_Node_Str"" + fc + ""String_Node_Str""+ allFunctions.size());
    if (fun instanceof ActionDefineFunction) {
      ActionDefineFunction f=(ActionDefineFunction)fun;
      if (f.functionName.isEmpty()) {
        continue;
      }
      String changed=deobfuscation.deobfuscateName(f.functionName,false,""String_Node_Str"",deobfuscated,renameType,selected);
      if (changed != null) {
        f.replacedFunctionName=changed;
        ret++;
      }
    }
    if (fun instanceof ActionDefineFunction2) {
      ActionDefineFunction2 f=(ActionDefineFunction2)fun;
      if (f.functionName.isEmpty()) {
        continue;
      }
      String changed=deobfuscation.deobfuscateName(f.functionName,false,""String_Node_Str"",deobfuscated,renameType,selected);
      if (changed != null) {
        f.replacedFunctionName=changed;
        ret++;
      }
    }
  }
  HashSet<String> stringsNoVarH=new HashSet<>();
  List<DirectValueActionItem> allVariableNamesDv=new ArrayList<>();
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    allVariableNamesDv.add(it.key);
  }
  for (  DirectValueActionItem ti : allStrings.keySet()) {
    if (!allVariableNamesDv.contains(ti)) {
      stringsNoVarH.add(System.identityHashCode(allStrings.get(ti)) + ""String_Node_Str"" + ti.toStringNoH(allStrings.get(ti)));
    }
  }
  int vc=0;
  for (  MyEntry<DirectValueActionItem,ConstantPool> it : allVariableNames) {
    vc++;
    String name=it.key.toStringNoH(it.value);
    String changed=deobfuscation.deobfuscateName(name,false,usageTypes.get(it.key),deobfuscated,renameType,selected);
    if (changed != null) {
      boolean addNew=false;
      String h=System.identityHashCode(it.key) + ""String_Node_Str"" + name;
      if (stringsNoVarH.contains(h)) {
        addNew=true;
      }
      ActionPush pu=(ActionPush)it.key.src;
      if (pu.replacement == null) {
        pu.replacement=new ArrayList<>();
        pu.replacement.addAll(pu.values);
      }
      if (pu.replacement.get(it.key.pos) instanceof ConstantIndex) {
        ConstantIndex ci=(ConstantIndex)pu.replacement.get(it.key.pos);
        ConstantPool pool=it.value;
        if (pool == null) {
          continue;
        }
        if (pool.constants == null) {
          continue;
        }
        if (addNew) {
          pool.constants.add(changed);
          ci.index=pool.constants.size() - 1;
        }
 else {
          pool.constants.set(ci.index,changed);
        }
      }
 else {
        pu.replacement.set(it.key.pos,changed);
      }
      ret++;
    }
  }
  for (  ASMSource src : actionsMap.keySet()) {
    actionsMap.put(src,Action.removeNops(0,actionsMap.get(src),version,0,""String_Node_Str""));
    src.setActions(actionsMap.get(src));
    src.setModified();
  }
  deobfuscation.deobfuscateInstanceNames(deobfuscated,renameType,tags,selected);
  return ret;
}",0.998701958349794
61786,"/** 
 * Reads one CLIPACTIONS value from the stream
 * @param swf
 * @return CLIPACTIONS value
 * @throws IOException
 */
public CLIPACTIONS readCLIPACTIONS(SWF swf) throws IOException {
  CLIPACTIONS ret=new CLIPACTIONS();
  ret.reserved=readUI16();
  ret.allEventFlags=readCLIPEVENTFLAGS();
  CLIPACTIONRECORD cr;
  ret.clipActionRecords=new ArrayList<>();
  while ((cr=readCLIPACTIONRECORD(swf)) != null) {
    ret.clipActionRecords.add(cr);
  }
  return ret;
}","/** 
 * Reads one CLIPACTIONS value from the stream
 * @param swf
 * @return CLIPACTIONS value
 * @throws IOException
 */
public CLIPACTIONS readCLIPACTIONS(SWF swf,Tag tag) throws IOException {
  CLIPACTIONS ret=new CLIPACTIONS();
  ret.reserved=readUI16();
  ret.allEventFlags=readCLIPEVENTFLAGS();
  CLIPACTIONRECORD cr;
  ret.clipActionRecords=new ArrayList<>();
  while ((cr=readCLIPACTIONRECORD(swf,tag)) != null) {
    ret.clipActionRecords.add(cr);
  }
  return ret;
}",0.9872340425531916
61787,"/** 
 * Reads one CLIPACTIONRECORD value from the stream
 * @param swf
 * @return CLIPACTIONRECORD value
 * @throws IOException
 */
public CLIPACTIONRECORD readCLIPACTIONRECORD(SWF swf) throws IOException {
  CLIPACTIONRECORD ret=new CLIPACTIONRECORD(swf,this,getPos());
  if (ret.eventFlags.isClear()) {
    return null;
  }
  return ret;
}","/** 
 * Reads one CLIPACTIONRECORD value from the stream
 * @param swf
 * @return CLIPACTIONRECORD value
 * @throws IOException
 */
public CLIPACTIONRECORD readCLIPACTIONRECORD(SWF swf,Tag tag) throws IOException {
  CLIPACTIONRECORD ret=new CLIPACTIONRECORD(swf,this,getPos(),tag);
  if (ret.eventFlags.isClear()) {
    return null;
  }
  return ret;
}",0.9827089337175792
61788,"/** 
 * Reads one BUTTONCONDACTION value from the stream
 * @param swf
 * @return BUTTONCONDACTION value
 * @throws IOException
 */
public BUTTONCONDACTION readBUTTONCONDACTION(SWF swf) throws IOException {
  BUTTONCONDACTION ret=new BUTTONCONDACTION(swf,this,getPos());
  return ret;
}","/** 
 * Reads one BUTTONCONDACTION value from the stream
 * @param swf
 * @return BUTTONCONDACTION value
 * @throws IOException
 */
public BUTTONCONDACTION readBUTTONCONDACTION(SWF swf,Tag tag) throws IOException {
  BUTTONCONDACTION ret=new BUTTONCONDACTION(swf,this,getPos(),tag);
  return ret;
}",0.9794520547945206
61789,"/** 
 * Reads list of BUTTONCONDACTION values from the stream
 * @param swf
 * @return List of BUTTONCONDACTION values
 * @throws IOException
 */
public List<BUTTONCONDACTION> readBUTTONCONDACTIONList(SWF swf) throws IOException {
  List<BUTTONCONDACTION> ret=new ArrayList<>();
  BUTTONCONDACTION bc;
  while (!(bc=readBUTTONCONDACTION(swf)).isLast) {
    ret.add(bc);
  }
  ret.add(bc);
  return ret;
}","/** 
 * Reads list of BUTTONCONDACTION values from the stream
 * @param swf
 * @return List of BUTTONCONDACTION values
 * @throws IOException
 */
public List<BUTTONCONDACTION> readBUTTONCONDACTIONList(SWF swf,Tag tag) throws IOException {
  List<BUTTONCONDACTION> ret=new ArrayList<>();
  BUTTONCONDACTION bc;
  while (!(bc=readBUTTONCONDACTION(swf,tag)).isLast) {
    ret.add(bc);
  }
  ret.add(bc);
  return ret;
}",0.9853658536585366
61790,"/** 
 * Writes Tag value to the stream
 * @param tag Tag value
 * @throws IOException
 */
public void writeTag(Tag tag) throws IOException {
  byte[] data=tag.getData();
  write(getTagHeader(tag,data,version));
  write(data);
}","/** 
 * Writes Tag value to the stream
 * @param tag Tag value
 * @throws IOException
 */
public void writeTag(Tag tag) throws IOException {
  byte[] data=tag.getDataOrOriginalData();
  write(getTagHeader(tag,data,version));
  write(data);
}",0.97008547008547
61791,"private void fontAddChars(FontTag ft,Set<Integer> selChars,String selFont){
  FontTag f=(FontTag)mainPanel.tagTree.getCurrentTreeItem();
  SWF swf=ft.getSwf();
  String oldchars=f.getCharacters(swf.tags);
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) == -1) {
      Font font=new Font(selFont,f.getFontStyle(),1024);
      if (!font.canDisplay(c)) {
        View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
    }
  }
  String[] yesno=new String[]{translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str"")};
  boolean yestoall=false;
  boolean notoall=false;
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) > -1) {
      int opt;
      if (!(yestoall || notoall)) {
        opt=View.showOptionDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,yesno,translate(""String_Node_Str""));
        if (opt == 2) {
          yestoall=true;
        }
        if (opt == 3) {
          notoall=true;
        }
      }
      if (yestoall) {
        opt=0;
      }
 else       if (notoall) {
        opt=1;
      }
 else {
        opt=1;
      }
      if (opt == 1) {
        continue;
      }
    }
    f.addCharacter(c,fontSelection.getSelectedItem().toString());
    oldchars+=c;
  }
  int fontId=ft.getFontId();
  if (updateTextsCheckBox.isSelected()) {
    for (    Tag tag : swf.tags) {
      if (tag instanceof TextTag) {
        TextTag textTag=(TextTag)tag;
        if (textTag.getFontIds().contains(fontId)) {
          String text=textTag.getFormattedText();
          mainPanel.saveText(textTag,text);
        }
      }
    }
  }
  SWF.clearImageCache();
}","private void fontAddChars(FontTag ft,Set<Integer> selChars,String selFont){
  FontTag f=(FontTag)mainPanel.tagTree.getCurrentTreeItem();
  SWF swf=ft.getSwf();
  String oldchars=f.getCharacters(swf.tags);
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) == -1) {
      Font font=new Font(selFont,f.getFontStyle(),1024);
      if (!font.canDisplay(c)) {
        View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
    }
  }
  String[] yesno=new String[]{translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str"")};
  boolean yestoall=false;
  boolean notoall=false;
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) > -1) {
      int opt;
      if (!(yestoall || notoall)) {
        opt=View.showOptionDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,yesno,translate(""String_Node_Str""));
        if (opt == 2) {
          yestoall=true;
        }
        if (opt == 3) {
          notoall=true;
        }
      }
      if (yestoall) {
        opt=0;
      }
 else       if (notoall) {
        opt=1;
      }
 else {
        opt=1;
      }
      if (opt == 1) {
        continue;
      }
    }
    f.addCharacter(c,fontSelection.getSelectedItem().toString());
    oldchars+=c;
  }
  int fontId=ft.getFontId();
  if (updateTextsCheckBox.isSelected()) {
    for (    Tag tag : swf.tags) {
      if (tag instanceof TextTag) {
        TextTag textTag=(TextTag)tag;
        if (textTag.getFontIds().contains(fontId)) {
          String text=textTag.getFormattedText();
          mainPanel.saveText(textTag,text);
        }
      }
    }
  }
  ft.setModified(true);
  SWF.clearImageCache();
}",0.9938837920489296
61792,"public boolean save(ConstantPool constants){
  try {
    String text=getText();
    if (text.trim().startsWith(""String_Node_Str"")) {
      byte[] data=Helper.getBytesFromHexaText(text);
      MethodBody mb=abc.bodies[bodyIndex];
      mb.codeBytes=data;
      try {
        mb.code=new AVM2Code(new ByteArrayInputStream(mb.codeBytes));
      }
 catch (      UnknownInstructionCode re) {
        mb.code=new AVM2Code();
        Logger.getLogger(ABC.class.getName()).log(Level.SEVERE,null,re);
      }
      mb.code.compact();
    }
 else {
      AVM2Code acode=ASM3Parser.parse(new StringReader(text),constants,trait,new MissingSymbolHandler(){
        @Override public boolean missingString(        String value){
          return true;
        }
        @Override public boolean missingInt(        long value){
          return true;
        }
        @Override public boolean missingUInt(        long value){
          return true;
        }
        @Override public boolean missingDouble(        double value){
          return true;
        }
      }
,abc.bodies[bodyIndex],abc.method_info[abc.bodies[bodyIndex].method_info]);
      acode.getBytes(abc.bodies[bodyIndex].codeBytes);
      abc.bodies[bodyIndex].code=acode;
    }
  }
 catch (  IOException ex) {
  }
catch (  InterruptedException ex) {
  }
catch (  ParseException ex) {
    View.showMessageDialog(this,(ex.text + ""String_Node_Str"" + ex.line));
    selectLine((int)ex.line);
    return false;
  }
  return true;
}","public boolean save(ConstantPool constants){
  try {
    String text=getText();
    if (text.trim().startsWith(""String_Node_Str"")) {
      byte[] data=Helper.getBytesFromHexaText(text);
      MethodBody mb=abc.bodies[bodyIndex];
      mb.codeBytes=data;
      try {
        mb.code=new AVM2Code(new ByteArrayInputStream(mb.codeBytes));
      }
 catch (      UnknownInstructionCode re) {
        mb.code=new AVM2Code();
        Logger.getLogger(ABC.class.getName()).log(Level.SEVERE,null,re);
      }
      mb.code.compact();
    }
 else {
      AVM2Code acode=ASM3Parser.parse(new StringReader(text),constants,trait,new MissingSymbolHandler(){
        @Override public boolean missingString(        String value){
          return true;
        }
        @Override public boolean missingInt(        long value){
          return true;
        }
        @Override public boolean missingUInt(        long value){
          return true;
        }
        @Override public boolean missingDouble(        double value){
          return true;
        }
      }
,abc.bodies[bodyIndex],abc.method_info[abc.bodies[bodyIndex].method_info]);
      acode.getBytes(abc.bodies[bodyIndex].codeBytes);
      abc.bodies[bodyIndex].code=acode;
    }
    ((Tag)abc.parentTag).setModified(true);
  }
 catch (  IOException ex) {
  }
catch (  InterruptedException ex) {
  }
catch (  ParseException ex) {
    View.showMessageDialog(this,(ex.text + ""String_Node_Str"" + ex.line));
    selectLine((int)ex.line);
    return false;
  }
  return true;
}",0.985352862849534
61793,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_GRAPH:
    if (lastCode != null) {
      try {
        GraphFrame gf=new GraphFrame(new ActionGraph(lastCode,new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),SWF.DEFAULT_VERSION),""String_Node_Str"");
        gf.setVisible(true);
      }
 catch (      InterruptedException ex) {
        Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  break;
case ACTION_EDIT_ACTION:
setEditMode(true);
break;
case ACTION_HEX:
case ACTION_HEX_ONLY:
if (e.getActionCommand() == ACTION_HEX) {
hexOnlyButton.setSelected(false);
}
 else {
hexButton.setSelected(false);
}
setHex(getExportMode());
break;
case ACTION_CANCEL_ACTION:
setEditMode(false);
setHex(getExportMode());
break;
case ACTION_SAVE_ACTION:
try {
String text=editor.getText();
if (text.trim().startsWith(""String_Node_Str"")) {
src.setActionBytes(Helper.getBytesFromHexaText(text));
}
 else {
src.setActions(ASMParser.parse(0,src.getPos(),true,text,src.getSwf().version,false));
}
setSource(this.src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
saveButton.setVisible(false);
cancelButton.setVisible(false);
editButton.setVisible(true);
editor.setEditable(false);
editMode=false;
}
 catch (IOException ex) {
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_EDIT_DECOMPILED:
setDecompiledEditMode(true);
break;
case ACTION_CANCEL_DECOMPILED:
setDecompiledEditMode(false);
break;
case ACTION_SAVE_DECOMPILED:
try {
ActionScriptParser par=new ActionScriptParser();
src.setActions(par.actionsFromString(decompiledEditor.getText()));
setSource(src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
setDecompiledEditMode(false);
}
 catch (IOException ex) {
Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_GRAPH:
    if (lastCode != null) {
      try {
        GraphFrame gf=new GraphFrame(new ActionGraph(lastCode,new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),SWF.DEFAULT_VERSION),""String_Node_Str"");
        gf.setVisible(true);
      }
 catch (      InterruptedException ex) {
        Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  break;
case ACTION_EDIT_ACTION:
setEditMode(true);
break;
case ACTION_HEX:
case ACTION_HEX_ONLY:
if (e.getActionCommand() == ACTION_HEX) {
hexOnlyButton.setSelected(false);
}
 else {
hexButton.setSelected(false);
}
setHex(getExportMode());
break;
case ACTION_CANCEL_ACTION:
setEditMode(false);
setHex(getExportMode());
break;
case ACTION_SAVE_ACTION:
try {
String text=editor.getText();
if (text.trim().startsWith(""String_Node_Str"")) {
src.setActionBytes(Helper.getBytesFromHexaText(text));
}
 else {
src.setActions(ASMParser.parse(0,src.getPos(),true,text,src.getSwf().version,false));
}
src.setModified();
setSource(this.src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
saveButton.setVisible(false);
cancelButton.setVisible(false);
editButton.setVisible(true);
editor.setEditable(false);
editMode=false;
}
 catch (IOException ex) {
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_EDIT_DECOMPILED:
setDecompiledEditMode(true);
break;
case ACTION_CANCEL_DECOMPILED:
setDecompiledEditMode(false);
break;
case ACTION_SAVE_DECOMPILED:
try {
ActionScriptParser par=new ActionScriptParser();
src.setActions(par.actionsFromString(decompiledEditor.getText()));
src.setModified();
setSource(src,false);
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
setDecompiledEditMode(false);
}
 catch (IOException ex) {
Logger.getLogger(ActionPanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
catch (ParseException ex) {
View.showMessageDialog(this,AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),AppStrings.translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
}
}",0.9922417313189056
61794,"@Override public void setImage(byte[] data){
  imageData=data;
}","@Override public void setImage(byte[] data){
  imageData=data;
  setModified(true);
}",0.8590604026845637
61795,"@Override public void setImage(byte[] data) throws IOException {
  if (ImageTag.getImageFormat(data).equals(""String_Node_Str"")) {
    SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
    byte[] ba=new byte[image.getWidth() * image.getHeight()];
    for (int i=0; i < ba.length; i++) {
      ba[i]=(byte)255;
    }
    bitmapAlphaData=ba;
  }
 else {
    bitmapAlphaData=new byte[0];
  }
  imageData=data;
}","@Override public void setImage(byte[] data) throws IOException {
  if (ImageTag.getImageFormat(data).equals(""String_Node_Str"")) {
    SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
    byte[] ba=new byte[image.getWidth() * image.getHeight()];
    for (int i=0; i < ba.length; i++) {
      ba[i]=(byte)255;
    }
    bitmapAlphaData=ba;
  }
 else {
    bitmapAlphaData=new byte[0];
  }
  imageData=data;
  setModified(true);
}",0.977198697068404
61796,"@Override public void setImage(byte[] data){
  imageData=data;
  if (ImageTag.getImageFormat(data).equals(""String_Node_Str"")) {
    SerializableImage image=getImage();
    byte[] ba=new byte[image.getWidth() * image.getHeight()];
    for (int i=0; i < ba.length; i++) {
      ba[i]=(byte)255;
    }
    bitmapAlphaData=ba;
  }
 else {
    bitmapAlphaData=new byte[0];
  }
}","@Override public void setImage(byte[] data){
  imageData=data;
  if (ImageTag.getImageFormat(data).equals(""String_Node_Str"")) {
    SerializableImage image=getImage();
    byte[] ba=new byte[image.getWidth() * image.getHeight()];
    for (int i=0; i < ba.length; i++) {
      ba[i]=(byte)255;
    }
    bitmapAlphaData=ba;
  }
 else {
    bitmapAlphaData=new byte[0];
  }
  setModified(true);
}",0.9726205997392438
61797,"@Override public void setImage(byte[] data) throws IOException {
  SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
  ALPHABITMAPDATA bitmapData=new ALPHABITMAPDATA();
  bitmapFormat=DefineBitsLosslessTag.FORMAT_24BIT_RGB;
  bitmapWidth=image.getWidth();
  bitmapHeight=image.getHeight();
  bitmapData.bitmapPixelData=new ARGB[bitmapWidth * bitmapHeight];
  int pos=0;
  for (int y=0; y < bitmapHeight; y++) {
    for (int x=0; x < bitmapWidth; x++) {
      int argb=image.getRGB(x,y);
      int a=(argb >> 24) & 0xff;
      int r=(argb >> 16) & 0xff;
      int g=(argb >> 8) & 0xff;
      int b=(argb) & 0xff;
      r=r * a / 255;
      g=g * a / 255;
      b=b * a / 255;
      bitmapData.bitmapPixelData[pos]=new ARGB();
      bitmapData.bitmapPixelData[pos].alpha=a;
      bitmapData.bitmapPixelData[pos].red=r;
      bitmapData.bitmapPixelData[pos].green=g;
      bitmapData.bitmapPixelData[pos].blue=b;
      pos++;
    }
  }
  ByteArrayOutputStream bitmapDataOS=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(bitmapDataOS,getVersion());
  sos.writeALPHABITMAPDATA(bitmapData,bitmapFormat,bitmapWidth,bitmapHeight);
  ByteArrayOutputStream zlibOS=new ByteArrayOutputStream();
  SWFOutputStream sos2=new SWFOutputStream(zlibOS,getVersion());
  sos2.writeBytesZlib(bitmapDataOS.toByteArray());
  zlibBitmapData=zlibOS.toByteArray();
  decompressed=false;
}","@Override public void setImage(byte[] data) throws IOException {
  SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
  ALPHABITMAPDATA bitmapData=new ALPHABITMAPDATA();
  bitmapFormat=DefineBitsLosslessTag.FORMAT_24BIT_RGB;
  bitmapWidth=image.getWidth();
  bitmapHeight=image.getHeight();
  bitmapData.bitmapPixelData=new ARGB[bitmapWidth * bitmapHeight];
  int pos=0;
  for (int y=0; y < bitmapHeight; y++) {
    for (int x=0; x < bitmapWidth; x++) {
      int argb=image.getRGB(x,y);
      int a=(argb >> 24) & 0xff;
      int r=(argb >> 16) & 0xff;
      int g=(argb >> 8) & 0xff;
      int b=(argb) & 0xff;
      r=r * a / 255;
      g=g * a / 255;
      b=b * a / 255;
      bitmapData.bitmapPixelData[pos]=new ARGB();
      bitmapData.bitmapPixelData[pos].alpha=a;
      bitmapData.bitmapPixelData[pos].red=r;
      bitmapData.bitmapPixelData[pos].green=g;
      bitmapData.bitmapPixelData[pos].blue=b;
      pos++;
    }
  }
  ByteArrayOutputStream bitmapDataOS=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(bitmapDataOS,getVersion());
  sos.writeALPHABITMAPDATA(bitmapData,bitmapFormat,bitmapWidth,bitmapHeight);
  ByteArrayOutputStream zlibOS=new ByteArrayOutputStream();
  SWFOutputStream sos2=new SWFOutputStream(zlibOS,getVersion());
  sos2.writeBytesZlib(bitmapDataOS.toByteArray());
  zlibBitmapData=zlibOS.toByteArray();
  decompressed=false;
  setModified(true);
}",0.9927007299270072
61798,"@Override public void setImage(byte[] data) throws IOException {
  SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
  bitmapFormat=FORMAT_24BIT_RGB;
  bitmapWidth=image.getWidth();
  bitmapHeight=image.getHeight();
  bitmapData=new BITMAPDATA();
  bitmapData.bitmapPixelDataPix24=new PIX24[bitmapWidth * bitmapHeight];
  int pos=0;
  for (int y=0; y < bitmapHeight; y++) {
    for (int x=0; x < bitmapWidth; x++) {
      int argb=image.getRGB(x,y);
      int r=(argb >> 16) & 0xff;
      int g=(argb >> 8) & 0xff;
      int b=(argb) & 0xff;
      bitmapData.bitmapPixelDataPix24[pos]=new PIX24();
      bitmapData.bitmapPixelDataPix24[pos].red=r;
      bitmapData.bitmapPixelDataPix24[pos].green=g;
      bitmapData.bitmapPixelDataPix24[pos].blue=b;
      bitmapData.bitmapPixelDataPix24[pos].reserved=0xff;
      pos++;
    }
  }
  ByteArrayOutputStream bitmapDataOS=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(bitmapDataOS,getVersion());
  sos.writeBITMAPDATA(bitmapData,bitmapFormat,bitmapWidth,bitmapHeight);
  ByteArrayOutputStream zlibOS=new ByteArrayOutputStream();
  SWFOutputStream sos2=new SWFOutputStream(zlibOS,getVersion());
  sos2.writeBytesZlib(bitmapDataOS.toByteArray());
  zlibBitmapData=zlibOS.toByteArray();
  decompressed=false;
}","@Override public void setImage(byte[] data) throws IOException {
  SerializableImage image=new SerializableImage(ImageIO.read(new ByteArrayInputStream(data)));
  bitmapFormat=FORMAT_24BIT_RGB;
  bitmapWidth=image.getWidth();
  bitmapHeight=image.getHeight();
  bitmapData=new BITMAPDATA();
  bitmapData.bitmapPixelDataPix24=new PIX24[bitmapWidth * bitmapHeight];
  int pos=0;
  for (int y=0; y < bitmapHeight; y++) {
    for (int x=0; x < bitmapWidth; x++) {
      int argb=image.getRGB(x,y);
      int r=(argb >> 16) & 0xff;
      int g=(argb >> 8) & 0xff;
      int b=(argb) & 0xff;
      bitmapData.bitmapPixelDataPix24[pos]=new PIX24();
      bitmapData.bitmapPixelDataPix24[pos].red=r;
      bitmapData.bitmapPixelDataPix24[pos].green=g;
      bitmapData.bitmapPixelDataPix24[pos].blue=b;
      bitmapData.bitmapPixelDataPix24[pos].reserved=0xff;
      pos++;
    }
  }
  ByteArrayOutputStream bitmapDataOS=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(bitmapDataOS,getVersion());
  sos.writeBITMAPDATA(bitmapData,bitmapFormat,bitmapWidth,bitmapHeight);
  ByteArrayOutputStream zlibOS=new ByteArrayOutputStream();
  SWFOutputStream sos2=new SWFOutputStream(zlibOS,getVersion());
  sos2.writeBytesZlib(bitmapDataOS.toByteArray());
  zlibBitmapData=zlibOS.toByteArray();
  decompressed=false;
  setModified(true);
}",0.9921200750469044
61799,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DefineButton2Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  buttonId=sis.readUI16();
  reserved=(int)sis.readUB(7);
  trackAsMenu=sis.readUB(1) == 1;
  int actionOffset=sis.readUI16();
  characters=sis.readBUTTONRECORDList(true);
  if (actionOffset > 0) {
    actions=sis.readBUTTONCONDACTIONList(swf);
  }
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DefineButton2Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  buttonId=sis.readUI16();
  reserved=(int)sis.readUB(7);
  trackAsMenu=sis.readUB(1) == 1;
  int actionOffset=sis.readUI16();
  characters=sis.readBUTTONRECORDList(true);
  if (actionOffset > 0) {
    actions=sis.readBUTTONCONDACTIONList(swf,this);
  }
}",0.9955156950672646
61800,"@Override public boolean setSound(InputStream is,int newSoundFormat){
  int newSoundRate=-1;
  boolean newSoundSize=false;
  boolean newSoundType=false;
  long newSoundSampleCount=-1;
  byte newSoundData[];
switch (newSoundFormat) {
case SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN:
    try (AudioInputStream audioIs=AudioSystem.getAudioInputStream(new BufferedInputStream(is))){
      AudioFormat fmt=audioIs.getFormat();
      newSoundType=fmt.getChannels() == 2;
      newSoundSize=fmt.getSampleSizeInBits() == 16;
      newSoundSampleCount=audioIs.getFrameLength();
      newSoundData=Helper.readStream(audioIs);
      newSoundRate=(int)Math.round(fmt.getSampleRate());
switch (newSoundRate) {
case 5512:
        newSoundRate=0;
      break;
case 11025:
    newSoundRate=1;
  break;
case 22050:
newSoundRate=2;
break;
case 44100:
newSoundRate=3;
break;
default :
return false;
}
}
 catch (UnsupportedAudioFileException|IOException ex) {
return false;
}
break;
case SoundFormat.FORMAT_MP3:
BufferedInputStream bis=new BufferedInputStream(is);
loadID3v2(bis);
byte mp3data[]=Helper.readStream(bis);
final int ID3_V1_LENTGH=128;
final int ID3_V1_EXT_LENGTH=227;
if (mp3data.length > ID3_V1_LENTGH) {
if (mp3data[mp3data.length - ID3_V1_LENTGH] == 'T' && mp3data[mp3data.length - ID3_V1_LENTGH + 1] == 'A' && mp3data[mp3data.length - ID3_V1_LENTGH + 2] == 'G') {
mp3data=Arrays.copyOf(mp3data,mp3data.length - ID3_V1_LENTGH);
if (mp3data.length > ID3_V1_EXT_LENGTH) {
if (mp3data[mp3data.length - ID3_V1_EXT_LENGTH] == 'T' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 1] == 'A' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 2] == 'G' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 3] == '+') {
mp3data=Arrays.copyOf(mp3data,mp3data.length - ID3_V1_EXT_LENGTH);
}
}
}
}
try {
MP3SOUNDDATA snd=new MP3SOUNDDATA(new ByteArrayInputStream(mp3data),true);
if (!snd.frames.isEmpty()) {
MP3FRAME fr=snd.frames.get(0);
newSoundRate=fr.getSamplingRate();
switch (newSoundRate) {
case 11025:
newSoundRate=1;
break;
case 22050:
newSoundRate=2;
break;
case 44100:
newSoundRate=3;
break;
default :
return false;
}
newSoundSize=true;
newSoundType=fr.isStereo();
int len=snd.sampleCount();
if (fr.isStereo()) {
len=len / 2;
}
newSoundSampleCount=len;
}
ByteArrayOutputStream baos=new ByteArrayOutputStream();
SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
sos.writeSI16(0);
sos.write(mp3data);
newSoundData=baos.toByteArray();
}
 catch (IOException ex) {
return false;
}
break;
default :
return false;
}
if (newSoundData != null) {
this.soundSize=newSoundSize;
this.soundRate=newSoundRate;
this.soundSampleCount=newSoundSampleCount;
this.soundData=newSoundData;
this.soundType=newSoundType;
this.soundFormat=newSoundFormat;
return true;
}
return false;
}","@Override public boolean setSound(InputStream is,int newSoundFormat){
  int newSoundRate=-1;
  boolean newSoundSize=false;
  boolean newSoundType=false;
  long newSoundSampleCount=-1;
  byte newSoundData[];
switch (newSoundFormat) {
case SoundFormat.FORMAT_UNCOMPRESSED_LITTLE_ENDIAN:
    try (AudioInputStream audioIs=AudioSystem.getAudioInputStream(new BufferedInputStream(is))){
      AudioFormat fmt=audioIs.getFormat();
      newSoundType=fmt.getChannels() == 2;
      newSoundSize=fmt.getSampleSizeInBits() == 16;
      newSoundSampleCount=audioIs.getFrameLength();
      newSoundData=Helper.readStream(audioIs);
      newSoundRate=(int)Math.round(fmt.getSampleRate());
switch (newSoundRate) {
case 5512:
        newSoundRate=0;
      break;
case 11025:
    newSoundRate=1;
  break;
case 22050:
newSoundRate=2;
break;
case 44100:
newSoundRate=3;
break;
default :
return false;
}
}
 catch (UnsupportedAudioFileException|IOException ex) {
return false;
}
break;
case SoundFormat.FORMAT_MP3:
BufferedInputStream bis=new BufferedInputStream(is);
loadID3v2(bis);
byte mp3data[]=Helper.readStream(bis);
final int ID3_V1_LENTGH=128;
final int ID3_V1_EXT_LENGTH=227;
if (mp3data.length > ID3_V1_LENTGH) {
if (mp3data[mp3data.length - ID3_V1_LENTGH] == 'T' && mp3data[mp3data.length - ID3_V1_LENTGH + 1] == 'A' && mp3data[mp3data.length - ID3_V1_LENTGH + 2] == 'G') {
mp3data=Arrays.copyOf(mp3data,mp3data.length - ID3_V1_LENTGH);
if (mp3data.length > ID3_V1_EXT_LENGTH) {
if (mp3data[mp3data.length - ID3_V1_EXT_LENGTH] == 'T' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 1] == 'A' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 2] == 'G' && mp3data[mp3data.length - ID3_V1_EXT_LENGTH + 3] == '+') {
mp3data=Arrays.copyOf(mp3data,mp3data.length - ID3_V1_EXT_LENGTH);
}
}
}
}
try {
MP3SOUNDDATA snd=new MP3SOUNDDATA(new ByteArrayInputStream(mp3data),true);
if (!snd.frames.isEmpty()) {
MP3FRAME fr=snd.frames.get(0);
newSoundRate=fr.getSamplingRate();
switch (newSoundRate) {
case 11025:
newSoundRate=1;
break;
case 22050:
newSoundRate=2;
break;
case 44100:
newSoundRate=3;
break;
default :
return false;
}
newSoundSize=true;
newSoundType=fr.isStereo();
int len=snd.sampleCount();
if (fr.isStereo()) {
len=len / 2;
}
newSoundSampleCount=len;
}
ByteArrayOutputStream baos=new ByteArrayOutputStream();
SWFOutputStream sos=new SWFOutputStream(baos,SWF.DEFAULT_VERSION);
sos.writeSI16(0);
sos.write(mp3data);
newSoundData=baos.toByteArray();
}
 catch (IOException ex) {
return false;
}
break;
default :
return false;
}
if (newSoundData != null) {
this.soundSize=newSoundSize;
this.soundRate=newSoundRate;
this.soundSampleCount=newSoundSampleCount;
this.soundData=newSoundData;
this.soundType=newSoundType;
this.soundFormat=newSoundFormat;
setModified(true);
return true;
}
return false;
}",0.9965771932985048
61801,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DoABCDefineTag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  InputStream is=new ByteArrayInputStream(data);
  SWFInputStream sis=new SWFInputStream(is,swf.version);
  flags=sis.readUI32();
  name=sis.readString();
  abc=new ABC(is,swf);
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DoABCDefineTag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  InputStream is=new ByteArrayInputStream(data);
  SWFInputStream sis=new SWFInputStream(is,swf.version);
  flags=sis.readUI32();
  name=sis.readString();
  abc=new ABC(is,swf,this);
}",0.9937421777221528
61802,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DoABCTag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  InputStream is=new ByteArrayInputStream(data);
  abc=new ABC(is,swf);
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public DoABCTag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  InputStream is=new ByteArrayInputStream(data);
  abc=new ABC(is,swf,this);
}",0.991304347826087
61803,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject2Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf);
  }
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject2Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf,this);
  }
}",0.9978118161925602
61804,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject3Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  reserved=sis.readUB(1) == 1;
  placeFlagOpaqueBackground=sis.readUB(1) == 1;
  placeFlagHasVisible=sis.readUB(1) == 1;
  placeFlagHasImage=sis.readUB(1) == 1;
  placeFlagHasClassName=sis.readUB(1) == 1;
  placeFlagHasCacheAsBitmap=sis.readUB(1) == 1;
  placeFlagHasBlendMode=sis.readUB(1) == 1;
  placeFlagHasFilterList=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasClassName) {
    className=sis.readString();
  }
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasFilterList) {
    surfaceFilterList=sis.readFILTERLIST();
  }
  if (placeFlagHasBlendMode) {
    blendMode=sis.readUI8();
  }
  bitmapCacheBug=false;
  if (placeFlagHasCacheAsBitmap) {
    try {
      bitmapCache=sis.readUI8();
    }
 catch (    EndOfStreamException eex) {
      bitmapCacheBug=true;
      bitmapCache=1;
    }
  }
  if (placeFlagHasVisible) {
    visible=sis.readUI8();
  }
  if (placeFlagOpaqueBackground) {
    backgroundColor=sis.readRGBA();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf);
  }
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject3Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  reserved=sis.readUB(1) == 1;
  placeFlagOpaqueBackground=sis.readUB(1) == 1;
  placeFlagHasVisible=sis.readUB(1) == 1;
  placeFlagHasImage=sis.readUB(1) == 1;
  placeFlagHasClassName=sis.readUB(1) == 1;
  placeFlagHasCacheAsBitmap=sis.readUB(1) == 1;
  placeFlagHasBlendMode=sis.readUB(1) == 1;
  placeFlagHasFilterList=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasClassName) {
    className=sis.readString();
  }
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasFilterList) {
    surfaceFilterList=sis.readFILTERLIST();
  }
  if (placeFlagHasBlendMode) {
    blendMode=sis.readUI8();
  }
  bitmapCacheBug=false;
  if (placeFlagHasCacheAsBitmap) {
    try {
      bitmapCache=sis.readUI8();
    }
 catch (    EndOfStreamException eex) {
      bitmapCacheBug=true;
      bitmapCache=1;
    }
  }
  if (placeFlagHasVisible) {
    visible=sis.readUI8();
  }
  if (placeFlagOpaqueBackground) {
    backgroundColor=sis.readRGBA();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf,this);
  }
}",0.9987724036336852
61805,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject4Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  reserved=sis.readUB(1) == 1;
  placeFlagOpaqueBackground=sis.readUB(1) == 1;
  placeFlagHasVisible=sis.readUB(1) == 1;
  placeFlagHasImage=sis.readUB(1) == 1;
  placeFlagHasClassName=sis.readUB(1) == 1;
  placeFlagHasCacheAsBitmap=sis.readUB(1) == 1;
  placeFlagHasBlendMode=sis.readUB(1) == 1;
  placeFlagHasFilterList=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasClassName) {
    className=sis.readString();
  }
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasFilterList) {
    surfaceFilterList=sis.readFILTERLIST();
  }
  if (placeFlagHasBlendMode) {
    blendMode=sis.readUI8();
  }
  bitmapCacheBug=false;
  if (placeFlagHasCacheAsBitmap) {
    try {
      bitmapCache=sis.readUI8();
    }
 catch (    EndOfStreamException eex) {
      bitmapCacheBug=true;
      bitmapCache=1;
    }
  }
  if (placeFlagHasVisible) {
    visible=sis.readUI8();
  }
  if (placeFlagOpaqueBackground) {
    backgroundColor=sis.readRGBA();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf);
  }
  amfData=sis.readBytesEx(sis.available());
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param pos
 * @throws IOException
 */
public PlaceObject4Tag(SWF swf,byte[] data,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),swf.version);
  placeFlagHasClipActions=sis.readUB(1) == 1;
  placeFlagHasClipDepth=sis.readUB(1) == 1;
  placeFlagHasName=sis.readUB(1) == 1;
  placeFlagHasRatio=sis.readUB(1) == 1;
  placeFlagHasColorTransform=sis.readUB(1) == 1;
  placeFlagHasMatrix=sis.readUB(1) == 1;
  placeFlagHasCharacter=sis.readUB(1) == 1;
  placeFlagMove=sis.readUB(1) == 1;
  reserved=sis.readUB(1) == 1;
  placeFlagOpaqueBackground=sis.readUB(1) == 1;
  placeFlagHasVisible=sis.readUB(1) == 1;
  placeFlagHasImage=sis.readUB(1) == 1;
  placeFlagHasClassName=sis.readUB(1) == 1;
  placeFlagHasCacheAsBitmap=sis.readUB(1) == 1;
  placeFlagHasBlendMode=sis.readUB(1) == 1;
  placeFlagHasFilterList=sis.readUB(1) == 1;
  depth=sis.readUI16();
  if (placeFlagHasClassName) {
    className=sis.readString();
  }
  if (placeFlagHasCharacter) {
    characterId=sis.readUI16();
  }
  if (placeFlagHasMatrix) {
    matrix=sis.readMatrix();
  }
  if (placeFlagHasColorTransform) {
    colorTransform=sis.readCXFORMWITHALPHA();
  }
  if (placeFlagHasRatio) {
    ratio=sis.readUI16();
  }
  if (placeFlagHasName) {
    name=sis.readString();
  }
  if (placeFlagHasClipDepth) {
    clipDepth=sis.readUI16();
  }
  if (placeFlagHasFilterList) {
    surfaceFilterList=sis.readFILTERLIST();
  }
  if (placeFlagHasBlendMode) {
    blendMode=sis.readUI8();
  }
  bitmapCacheBug=false;
  if (placeFlagHasCacheAsBitmap) {
    try {
      bitmapCache=sis.readUI8();
    }
 catch (    EndOfStreamException eex) {
      bitmapCacheBug=true;
      bitmapCache=1;
    }
  }
  if (placeFlagHasVisible) {
    visible=sis.readUI8();
  }
  if (placeFlagOpaqueBackground) {
    backgroundColor=sis.readRGBA();
  }
  if (placeFlagHasClipActions) {
    clipActions=sis.readCLIPACTIONS(swf,this);
  }
  amfData=sis.readBytesEx(sis.available());
}",0.9987983657774572
61806,"public BUTTONCONDACTION(SWF swf,InputStream is,long containerOffset) throws IOException {
  this.swf=swf;
  SWFInputStream sis=new SWFInputStream(is,swf.version);
  pos=containerOffset;
  int condActionSize=sis.readUI16();
  isLast=condActionSize <= 0;
  condIdleToOverDown=sis.readUB(1) == 1;
  condOutDownToIdle=sis.readUB(1) == 1;
  condOutDownToOverDown=sis.readUB(1) == 1;
  condOverDownToOutDown=sis.readUB(1) == 1;
  condOverDownToOverUp=sis.readUB(1) == 1;
  condOverUpToOverDown=sis.readUB(1) == 1;
  condOverUpToIddle=sis.readUB(1) == 1;
  condIdleToOverUp=sis.readUB(1) == 1;
  condKeyPress=(int)sis.readUB(7);
  condOverDownToIddle=sis.readUB(1) == 1;
  if (condActionSize <= 0) {
    actionBytes=sis.readBytesEx(sis.available());
  }
 else {
    actionBytes=sis.readBytesEx(condActionSize - 4);
  }
}","public BUTTONCONDACTION(SWF swf,InputStream is,long containerOffset,Tag tag) throws IOException {
  this.swf=swf;
  this.tag=tag;
  SWFInputStream sis=new SWFInputStream(is,swf.version);
  pos=containerOffset;
  int condActionSize=sis.readUI16();
  isLast=condActionSize <= 0;
  condIdleToOverDown=sis.readUB(1) == 1;
  condOutDownToIdle=sis.readUB(1) == 1;
  condOutDownToOverDown=sis.readUB(1) == 1;
  condOverDownToOutDown=sis.readUB(1) == 1;
  condOverDownToOverUp=sis.readUB(1) == 1;
  condOverUpToOverDown=sis.readUB(1) == 1;
  condOverUpToIddle=sis.readUB(1) == 1;
  condIdleToOverUp=sis.readUB(1) == 1;
  condKeyPress=(int)sis.readUB(7);
  condOverDownToIddle=sis.readUB(1) == 1;
  if (condActionSize <= 0) {
    actionBytes=sis.readBytesEx(sis.available());
  }
 else {
    actionBytes=sis.readBytesEx(condActionSize - 4);
  }
}",0.9854545454545456
61807,"public List<DepthState> getObjectsUnderCursor(Point mousePos,int mouseButton,Matrix transformation){
  List<DepthState> ret=new ArrayList<>();
  List<Integer> keys=new ArrayList<>(layers.keySet());
  DepthState maxds=null;
  Stack<Clip> clips=new Stack<>();
  for (  int d : keys) {
    DepthState ds=layers.get(d);
    Clip currentClip=null;
    for (int j=clips.size() - 1; j >= 0; j--) {
      Clip cl=clips.get(j);
      if (cl.depth >= d) {
        clips.remove(j);
      }
    }
    if (!clips.isEmpty()) {
      currentClip=clips.peek();
    }
    CharacterTag c=timeline.swf.characters.get(ds.characterId);
    if (c instanceof DrawableTag) {
      Matrix m=new Matrix(ds.matrix).concatenate(transformation);
      int frame=ds.time % ((DrawableTag)c).getNumFrames();
      if (c instanceof ButtonTag) {
        frame=ButtonTag.FRAME_HITTEST;
      }
      Shape outline=SHAPERECORD.twipToPixelShape(((DrawableTag)c).getOutline(frame,ds.ratio,null,mouseButton,m));
      Area checkArea=new Area(outline);
      if (currentClip != null) {
        Area a=new Area(checkArea.getBounds());
        a.subtract(new Area(currentClip.shape));
        checkArea.subtract(a);
      }
      if (ds.clipDepth > -1) {
        Clip clip=new Clip(checkArea,ds.clipDepth);
        clips.push(clip);
      }
 else       if (checkArea.contains(mousePos)) {
        maxds=ds;
      }
    }
  }
  if (maxds == null) {
    return ret;
  }
  ret.add(maxds);
  CharacterTag c=timeline.swf.characters.get(maxds.characterId);
  if (c instanceof Timelined) {
    Timelined tc=((Timelined)c);
    int frame=maxds.time % ((DrawableTag)c).getNumFrames();
    ;
    if (tc instanceof ButtonTag) {
      frame=ButtonTag.FRAME_HITTEST;
    }
    ret.addAll(tc.getTimeline().frames.get(frame).getObjectsUnderCursor(mousePos,mouseButton,new Matrix(maxds.matrix).preConcatenate(transformation)));
  }
  return ret;
}","public List<DepthState> getObjectsUnderCursor(Point mousePos,int mouseButton,Matrix transformation){
  List<DepthState> ret=new ArrayList<>();
  List<Integer> keys=new ArrayList<>(layers.keySet());
  DepthState maxds=null;
  Stack<Clip> clips=new Stack<>();
  for (  int d : keys) {
    DepthState ds=layers.get(d);
    Clip currentClip=null;
    for (int j=clips.size() - 1; j >= 0; j--) {
      Clip cl=clips.get(j);
      if (cl.depth >= d) {
        clips.remove(j);
      }
    }
    if (!clips.isEmpty()) {
      currentClip=clips.peek();
    }
    CharacterTag c=timeline.swf.characters.get(ds.characterId);
    if (c instanceof DrawableTag) {
      Matrix m=new Matrix(ds.matrix).preConcatenate(transformation);
      int frame=ds.time % ((DrawableTag)c).getNumFrames();
      if (c instanceof ButtonTag) {
        frame=ButtonTag.FRAME_HITTEST;
      }
      Shape outline=SHAPERECORD.twipToPixelShape(((DrawableTag)c).getOutline(frame,ds.ratio,null,mouseButton,m));
      Area checkArea=new Area(outline);
      if (currentClip != null) {
        Area a=new Area(checkArea.getBounds());
        a.subtract(new Area(currentClip.shape));
        checkArea.subtract(a);
      }
      if (ds.clipDepth > -1) {
        Clip clip=new Clip(checkArea,ds.clipDepth);
        clips.push(clip);
      }
 else       if (checkArea.contains(mousePos)) {
        maxds=ds;
      }
    }
  }
  if (maxds == null) {
    return ret;
  }
  ret.add(maxds);
  CharacterTag c=timeline.swf.characters.get(maxds.characterId);
  if (c instanceof Timelined) {
    Timelined tc=((Timelined)c);
    int frame=maxds.time % ((DrawableTag)c).getNumFrames();
    ;
    if (tc instanceof ButtonTag) {
      frame=ButtonTag.FRAME_HITTEST;
    }
    ret.addAll(tc.getTimeline().frames.get(frame).getObjectsUnderCursor(mousePos,mouseButton,new Matrix(maxds.matrix).preConcatenate(transformation)));
  }
  return ret;
}",0.9986775985189104
61808,"@Override public boolean hasReturnValue(){
  return false;
}","@Override public boolean hasReturnValue(){
  return true;
}",0.9411764705882352
61809,"@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem propertyName=stack.pop();
  GraphTargetItem object=stack.pop();
  output.add(new DeleteActionItem(this,object,propertyName));
  stack.push(new DirectValueActionItem(this,-1,Boolean.TRUE,new ArrayList<String>()));
}","@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem propertyName=stack.pop();
  GraphTargetItem object=stack.pop();
  stack.push(new DeleteActionItem(this,object,propertyName));
}",0.8782707622298066
61810,"@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem propertyName=stack.pop();
  output.add(new DeleteActionItem(this,null,propertyName));
  stack.push(new DirectValueActionItem(this,-1,Boolean.TRUE,new ArrayList<String>()));
}","@Override public void translate(Stack<GraphTargetItem> stack,List<GraphTargetItem> output,java.util.HashMap<Integer,String> regNames,HashMap<String,GraphTargetItem> variables,HashMap<String,GraphTargetItem> functions,int staticOperation,String path){
  GraphTargetItem propertyName=stack.pop();
  stack.push(new DeleteActionItem(this,null,propertyName));
}",0.8685857321652065
61811,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  return toSourceMerge(localData,generator,object,propertyName,new ActionDelete());
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  if (object == null) {
    return toSourceMerge(localData,generator,propertyName,new ActionDelete2());
  }
  return toSourceMerge(localData,generator,object,propertyName,new ActionDelete());
}",0.62
61812,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  if (object == null) {
    return propertyName.toString(writer,localData);
  }
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return stripQuotes(propertyName,localData,writer);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  if (object == null) {
    return propertyName.toStringNoQuotes(writer,localData);
  }
  object.toStringNoQuotes(writer,localData);
  writer.append(""String_Node_Str"");
  return propertyName.toStringNoQuotes(writer,localData);
}",0.8903924221921515
61813,"private GraphTargetItem command(HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<VariableActionItem> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
switch (s.type) {
case CALL:
    expectedType(SymbolType.PARENT_OPEN);
  ret=new CallActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case LENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new StringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case MBLENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new MBStringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case SET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem name1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem value1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new SetVariableActionItem(null,name1,value1);
break;
case WITH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=(variable(registerVars,inFunction,inMethod,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> wcmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithActionItem(null,wvar,wcmd);
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case TRACE:
expectedType(SymbolType.PARENT_OPEN);
ret=new TraceActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case GETURL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int getuMethod=1;
GraphTargetItem target=null;
if (s.type == SymbolType.COMMA) {
target=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
getuMethod=1;
}
 else if (s.value.equals(""String_Node_Str"")) {
getuMethod=2;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
target=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new GetURL2ActionItem(null,url,target,getuMethod);
break;
case GOTOANDSTOP:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtsFrame,false,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case NEXTFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new NextFrameActionItem(null);
break;
case PLAY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PlayActionItem(null);
break;
case PREVFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PrevFrameActionItem(null);
break;
case TELLTARGET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem tellTarget=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> tellcmds=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new TellTargetActionItem(null,tellTarget,tellcmds);
break;
case STOP:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopActionItem(null);
break;
case STOPALLSOUNDS:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopAllSoundsActionItem(null);
break;
case TOGGLEHIGHQUALITY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new ToggleHighQualityActionItem(null);
break;
case STOPDRAG:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopDragActionItem(null);
break;
case TARGETPATH:
expectedType(SymbolType.PARENT_OPEN);
ret=new TargetPathActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case UNLOADMOVIE:
case UNLOADMOVIENUM:
SymbolType unloadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem unTargetOrNum=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
if (unloadType == SymbolType.UNLOADMOVIE) {
ret=new UnLoadMovieActionItem(null,unTargetOrNum);
}
if (unloadType == SymbolType.UNLOADMOVIENUM) {
ret=new UnLoadMovieNumActionItem(null,unTargetOrNum);
}
break;
case PRINT:
case PRINTASBITMAP:
case PRINTASBITMAPNUM:
case PRINTNUM:
SymbolType printType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem printTarget=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem printBBox=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
switch (printType) {
case PRINT:
ret=new PrintActionItem(null,printTarget,printBBox);
break;
case PRINTNUM:
ret=new PrintNumActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAP:
ret=new PrintAsBitmapActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAPNUM:
ret=new PrintAsBitmapNumActionItem(null,printTarget,printBBox);
break;
}
break;
case LOADVARIABLES:
case LOADMOVIE:
case LOADVARIABLESNUM:
case LOADMOVIENUM:
SymbolType loadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url2=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem targetOrNum=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int lvmethod=1;
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
lvmethod=2;
}
 else if (s.value.equals(""String_Node_Str"")) {
lvmethod=1;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
switch (loadType) {
case LOADVARIABLES:
ret=new LoadVariablesActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIE:
ret=new LoadMovieActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADVARIABLESNUM:
ret=new LoadVariablesNumActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIENUM:
ret=new LoadMovieNumActionItem(null,url2,targetOrNum,lvmethod);
break;
}
break;
case GOTOANDPLAY:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtpFrame,true,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case REMOVEMOVIECLIP:
expectedType(SymbolType.PARENT_OPEN);
ret=new RemoveSpriteActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case STARTDRAG:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem dragTarget=(expression(registerVars,inFunction,inMethod,true,variables));
GraphTargetItem lockCenter=null;
GraphTargetItem constrain=null;
GraphTargetItem x1=null;
GraphTargetItem y1=null;
GraphTargetItem x2=null;
GraphTargetItem y2=null;
s=lex();
if (s.type == SymbolType.COMMA) {
lockCenter=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
constrain=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
x1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
x2=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y2=(expression(registerVars,inFunction,inMethod,true,variables));
}
 else {
lexer.pushback(s);
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y1=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
}
}
 else {
lockCenter=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new StartDragActionItem(null,dragTarget,lockCenter,constrain,x1,y1,x2,y2);
break;
case IFFRAMELOADED:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem iflExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> iflComs=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new IfFrameLoadedActionItem(iflExpr,iflComs,null);
break;
case CLASS:
GraphTargetItem classTypeStr=type(variables);
s=lex();
GraphTargetItem extendsTypeStr=null;
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(variables);
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(variables);
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(false,classTypeStr,extendsTypeStr,implementsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
GraphTargetItem interfaceTypeStr=type(variables);
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(variables);
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(true,interfaceTypeStr,null,intExtendsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
ret=(function(true,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
if (s.type == SymbolType.COLON) {
type(variables);
s=lex();
}
if (s.type == SymbolType.ASSIGN) {
if (!inFunction) {
}
GraphTargetItem varval=(expression(registerVars,inFunction,inMethod,true,variables));
ret=new VariableActionItem(varIdentifier,varval,true);
variables.add((VariableActionItem)ret);
}
 else {
ret=new VariableActionItem(varIdentifier,null,true);
variables.add((VariableActionItem)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,varincdec);
}
 else if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,varincdec);
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case PARENT_OPEN:
case EVAL:
ParsedSymbol varS=s;
boolean isEval=false;
GraphTargetItem var;
if (s.type == SymbolType.PARENT_OPEN) {
var=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=expression(registerVars,inFunction,inMethod,true,variables);
var=new EvalActionItem(null,var);
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
isEval=true;
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
}
s=lex();
switch (s.type) {
case ASSIGN:
ret=var;
ret=Action.gettoset(ret,expression(registerVars,inFunction,inMethod,true,variables),variables);
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_SHIFT_LEFT:
case ASSIGN_SHIFT_RIGHT:
case ASSIGN_USHIFT_RIGHT:
case ASSIGN_XOR:
GraphTargetItem valtoappend=(expression(registerVars,inFunction,inMethod,true,variables));
switch (s.type) {
case ASSIGN_BITAND:
ret=Action.gettoset(var,new BitAndActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_BITOR:
ret=Action.gettoset(var,new BitOrActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_DIVIDE:
ret=Action.gettoset(var,new DivideActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MINUS:
ret=Action.gettoset(var,new SubtractActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MODULO:
ret=Action.gettoset(var,new ModuloActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MULTIPLY:
ret=Action.gettoset(var,new MultiplyActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_PLUS:
ret=Action.gettoset(var,new AddActionItem(null,var,valtoappend,true),variables);
break;
}
break;
case INCREMENT:
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
ret=var;
if (varS.type == SymbolType.SUPER || varS.type == SymbolType.THIS && (var instanceof VariableActionItem)) {
List<GraphTargetItem> args=call(registerVars,inFunction,inMethod,variables);
ret=new CallMethodActionItem(null,ret,new DirectValueActionItem(null,0,new Undefined(),constantPool),args);
}
 else {
lexer.pushback(s);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
}
break;
default :
if (isEval) {
ret=var;
}
 else {
ret=null;
}
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
whileBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,null,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
doBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,null,doBody,doExpr);
break;
case FOR:
expectedType(SymbolType.PARENT_OPEN);
s=lex();
boolean forin=false;
GraphTargetItem collection=null;
String objIdent=null;
int innerExprReg=0;
if (s.type == SymbolType.VAR || s.type == SymbolType.IDENTIFIER) {
ParsedSymbol s2=null;
ParsedSymbol ssel=s;
if (s.type == SymbolType.VAR) {
s2=lex();
ssel=s2;
}
if (ssel.type == SymbolType.IDENTIFIER) {
objIdent=ssel.value.toString();
ParsedSymbol s3=lex();
if (s3.type == SymbolType.IN) {
if (inFunction) {
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(objIdent,i);
innerExprReg=i;
break;
}
}
}
collection=expression(registerVars,inFunction,inMethod,true,variables);
forin=true;
}
 else {
lexer.pushback(s3);
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
forFirstCommands.add((command(registerVars,inFunction,inMethod,forinlevel,true,variables)));
forExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
ret=new ForInActionItem(null,null,pushConst(objIdent),collection,forBody);
}
 else {
ret=new ForItem(null,null,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,null,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
ret=new BreakItem(null,0);
break;
case CONTINUE:
ret=new ContinueItem(null,0);
break;
case RETURN:
GraphTargetItem retexpr=expression(true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
retexpr=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
}
ret=new ReturnActionItem(null,retexpr);
break;
case TRY:
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=null;
List<GraphTargetItem> catchExceptions=new ArrayList<>();
if (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING);
catchExceptions.add(pushConst((String)s.value));
expectedType(SymbolType.PARENT_CLOSE);
catchCommands=new ArrayList<>();
List<GraphTargetItem> cc=new ArrayList<>();
cc.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
catchCommands.add(cc);
s=lex();
found=true;
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
ret=new TryActionItem(tryCommands,catchExceptions,catchCommands,finallyCommands);
break;
case THROW:
ret=new ThrowActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return null;
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}","private GraphTargetItem command(HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<VariableActionItem> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
switch (s.type) {
case CALL:
    expectedType(SymbolType.PARENT_OPEN);
  ret=new CallActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case LENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new StringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case MBLENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new MBStringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case SET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem name1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem value1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new SetVariableActionItem(null,name1,value1);
break;
case WITH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=(variable(registerVars,inFunction,inMethod,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> wcmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithActionItem(null,wvar,wcmd);
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else if (varDel instanceof VariableActionItem) {
variables.remove(varDel);
ret=new DeleteActionItem(null,null,pushConst(((VariableActionItem)varDel).getVariableName()));
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case TRACE:
expectedType(SymbolType.PARENT_OPEN);
ret=new TraceActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case GETURL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int getuMethod=1;
GraphTargetItem target=null;
if (s.type == SymbolType.COMMA) {
target=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
getuMethod=1;
}
 else if (s.value.equals(""String_Node_Str"")) {
getuMethod=2;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
target=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new GetURL2ActionItem(null,url,target,getuMethod);
break;
case GOTOANDSTOP:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtsFrame,false,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case NEXTFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new NextFrameActionItem(null);
break;
case PLAY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PlayActionItem(null);
break;
case PREVFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PrevFrameActionItem(null);
break;
case TELLTARGET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem tellTarget=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> tellcmds=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new TellTargetActionItem(null,tellTarget,tellcmds);
break;
case STOP:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopActionItem(null);
break;
case STOPALLSOUNDS:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopAllSoundsActionItem(null);
break;
case TOGGLEHIGHQUALITY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new ToggleHighQualityActionItem(null);
break;
case STOPDRAG:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopDragActionItem(null);
break;
case TARGETPATH:
expectedType(SymbolType.PARENT_OPEN);
ret=new TargetPathActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case UNLOADMOVIE:
case UNLOADMOVIENUM:
SymbolType unloadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem unTargetOrNum=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
if (unloadType == SymbolType.UNLOADMOVIE) {
ret=new UnLoadMovieActionItem(null,unTargetOrNum);
}
if (unloadType == SymbolType.UNLOADMOVIENUM) {
ret=new UnLoadMovieNumActionItem(null,unTargetOrNum);
}
break;
case PRINT:
case PRINTASBITMAP:
case PRINTASBITMAPNUM:
case PRINTNUM:
SymbolType printType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem printTarget=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem printBBox=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
switch (printType) {
case PRINT:
ret=new PrintActionItem(null,printTarget,printBBox);
break;
case PRINTNUM:
ret=new PrintNumActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAP:
ret=new PrintAsBitmapActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAPNUM:
ret=new PrintAsBitmapNumActionItem(null,printTarget,printBBox);
break;
}
break;
case LOADVARIABLES:
case LOADMOVIE:
case LOADVARIABLESNUM:
case LOADMOVIENUM:
SymbolType loadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url2=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem targetOrNum=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int lvmethod=1;
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
lvmethod=2;
}
 else if (s.value.equals(""String_Node_Str"")) {
lvmethod=1;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
switch (loadType) {
case LOADVARIABLES:
ret=new LoadVariablesActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIE:
ret=new LoadMovieActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADVARIABLESNUM:
ret=new LoadVariablesNumActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIENUM:
ret=new LoadMovieNumActionItem(null,url2,targetOrNum,lvmethod);
break;
}
break;
case GOTOANDPLAY:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtpFrame,true,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case REMOVEMOVIECLIP:
expectedType(SymbolType.PARENT_OPEN);
ret=new RemoveSpriteActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case STARTDRAG:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem dragTarget=(expression(registerVars,inFunction,inMethod,true,variables));
GraphTargetItem lockCenter=null;
GraphTargetItem constrain=null;
GraphTargetItem x1=null;
GraphTargetItem y1=null;
GraphTargetItem x2=null;
GraphTargetItem y2=null;
s=lex();
if (s.type == SymbolType.COMMA) {
lockCenter=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
constrain=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
x1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
x2=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y2=(expression(registerVars,inFunction,inMethod,true,variables));
}
 else {
lexer.pushback(s);
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y1=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
}
}
 else {
lockCenter=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new StartDragActionItem(null,dragTarget,lockCenter,constrain,x1,y1,x2,y2);
break;
case IFFRAMELOADED:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem iflExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> iflComs=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new IfFrameLoadedActionItem(iflExpr,iflComs,null);
break;
case CLASS:
GraphTargetItem classTypeStr=type(variables);
s=lex();
GraphTargetItem extendsTypeStr=null;
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(variables);
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(variables);
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(false,classTypeStr,extendsTypeStr,implementsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
GraphTargetItem interfaceTypeStr=type(variables);
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(variables);
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(true,interfaceTypeStr,null,intExtendsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
ret=(function(true,s.value.toString(),false,variables));
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
if (s.type == SymbolType.COLON) {
type(variables);
s=lex();
}
if (s.type == SymbolType.ASSIGN) {
if (!inFunction) {
}
GraphTargetItem varval=(expression(registerVars,inFunction,inMethod,true,variables));
ret=new VariableActionItem(varIdentifier,varval,true);
variables.add((VariableActionItem)ret);
}
 else {
ret=new VariableActionItem(varIdentifier,null,true);
variables.add((VariableActionItem)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,varincdec);
}
 else if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,varincdec);
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case PARENT_OPEN:
case EVAL:
ParsedSymbol varS=s;
boolean isEval=false;
GraphTargetItem var;
if (s.type == SymbolType.PARENT_OPEN) {
var=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=expression(registerVars,inFunction,inMethod,true,variables);
var=new EvalActionItem(null,var);
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
isEval=true;
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
s=lex();
switch (s.type) {
case ASSIGN:
ret=var;
ret=Action.gettoset(ret,expression(registerVars,inFunction,inMethod,true,variables),variables);
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_SHIFT_LEFT:
case ASSIGN_SHIFT_RIGHT:
case ASSIGN_USHIFT_RIGHT:
case ASSIGN_XOR:
GraphTargetItem valtoappend=(expression(registerVars,inFunction,inMethod,true,variables));
switch (s.type) {
case ASSIGN_BITAND:
ret=Action.gettoset(var,new BitAndActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_BITOR:
ret=Action.gettoset(var,new BitOrActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_DIVIDE:
ret=Action.gettoset(var,new DivideActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MINUS:
ret=Action.gettoset(var,new SubtractActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MODULO:
ret=Action.gettoset(var,new ModuloActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MULTIPLY:
ret=Action.gettoset(var,new MultiplyActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_PLUS:
ret=Action.gettoset(var,new AddActionItem(null,var,valtoappend,true),variables);
break;
}
break;
case INCREMENT:
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
ret=var;
if (varS.type == SymbolType.SUPER || varS.type == SymbolType.THIS && (var instanceof VariableActionItem)) {
List<GraphTargetItem> args=call(registerVars,inFunction,inMethod,variables);
ret=new CallMethodActionItem(null,ret,new DirectValueActionItem(null,0,new Undefined(),constantPool),args);
}
 else {
lexer.pushback(s);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
}
break;
default :
if (isEval) {
ret=var;
}
 else {
ret=null;
}
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
whileBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,null,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
doBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,null,doBody,doExpr);
break;
case FOR:
expectedType(SymbolType.PARENT_OPEN);
s=lex();
boolean forin=false;
GraphTargetItem collection=null;
String objIdent=null;
int innerExprReg=0;
if (s.type == SymbolType.VAR || s.type == SymbolType.IDENTIFIER) {
ParsedSymbol s2=null;
ParsedSymbol ssel=s;
if (s.type == SymbolType.VAR) {
s2=lex();
ssel=s2;
}
if (ssel.type == SymbolType.IDENTIFIER) {
objIdent=ssel.value.toString();
ParsedSymbol s3=lex();
if (s3.type == SymbolType.IN) {
if (inFunction) {
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(objIdent,i);
innerExprReg=i;
break;
}
}
}
collection=expression(registerVars,inFunction,inMethod,true,variables);
forin=true;
}
 else {
lexer.pushback(s3);
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
forFirstCommands.add((command(registerVars,inFunction,inMethod,forinlevel,true,variables)));
forExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
ret=new ForInActionItem(null,null,pushConst(objIdent),collection,forBody);
}
 else {
ret=new ForItem(null,null,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,null,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
ret=new BreakItem(null,0);
break;
case CONTINUE:
ret=new ContinueItem(null,0);
break;
case RETURN:
GraphTargetItem retexpr=expression(true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
retexpr=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
}
ret=new ReturnActionItem(null,retexpr);
break;
case TRY:
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=null;
List<GraphTargetItem> catchExceptions=new ArrayList<>();
if (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING);
catchExceptions.add(pushConst((String)s.value));
expectedType(SymbolType.PARENT_CLOSE);
catchCommands=new ArrayList<>();
List<GraphTargetItem> cc=new ArrayList<>();
cc.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
catchCommands.add(cc);
s=lex();
found=true;
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
ret=new TryActionItem(tryCommands,catchExceptions,catchCommands,finallyCommands);
break;
case THROW:
ret=new ThrowActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
ret=expression(registerVars,inFunction,inMethod,true,variables);
if (debugMode) {
System.out.println(""String_Node_Str"");
}
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
lexer.removeListener(buf);
if (ret == null) {
buf.pushAllBack(lexer);
ret=expression(registerVars,inFunction,inMethod,true,variables);
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
return ret;
}",0.9928663051061052
61814,"private GraphTargetItem memberOrCall(GraphTargetItem newcmds,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<VariableActionItem> variables) throws IOException, ParseException {
  ParsedSymbol s=lex();
  GraphTargetItem ret=newcmds;
  while (s.isType(SymbolType.DOT,SymbolType.BRACKET_OPEN,SymbolType.PARENT_OPEN)) {
switch (s.type) {
case DOT:
case BRACKET_OPEN:
      lexer.pushback(s);
    ret=member(ret,registerVars,inFunction,inMethod,variables);
  break;
case PARENT_OPEN:
if (ret instanceof GetMemberActionItem) {
  GetMemberActionItem mem=(GetMemberActionItem)ret;
  ret=new CallMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (ret instanceof VariableActionItem) {
  VariableActionItem var=(VariableActionItem)ret;
  ret=new CallFunctionActionItem(null,var,call(registerVars,inFunction,inMethod,variables));
}
 else {
  ret=new CallFunctionActionItem(null,ret,call(registerVars,inFunction,inMethod,variables));
}
break;
}
s=lex();
}
lexer.pushback(s);
return ret;
}","private GraphTargetItem memberOrCall(GraphTargetItem newcmds,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,List<VariableActionItem> variables) throws IOException, ParseException {
  ParsedSymbol s=lex();
  GraphTargetItem ret=newcmds;
  while (s.isType(SymbolType.DOT,SymbolType.BRACKET_OPEN,SymbolType.PARENT_OPEN)) {
switch (s.type) {
case DOT:
case BRACKET_OPEN:
      lexer.pushback(s);
    ret=member(ret,registerVars,inFunction,inMethod,variables);
  break;
case PARENT_OPEN:
if (ret instanceof GetMemberActionItem) {
  GetMemberActionItem mem=(GetMemberActionItem)ret;
  ret=new CallMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (ret instanceof VariableActionItem) {
  VariableActionItem var=(VariableActionItem)ret;
  ret=new CallFunctionActionItem(null,pushConst(var.getVariableName()),call(registerVars,inFunction,inMethod,variables));
}
 else {
  ret=new CallFunctionActionItem(null,ret,call(registerVars,inFunction,inMethod,variables));
}
break;
}
s=lex();
}
lexer.pushback(s);
return ret;
}",0.9745252431681334
61815,"/** 
 * Reads list of tags from the stream. Reading ends with End tag(=0) or end of the stream. Optionally can skip AS1/2 tags when file is AS3
 * @param swf
 * @param level
 * @param parallel
 * @param skipUnusualTags
 * @param parseTags
 * @param gfx
 * @return List of tags
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public List<Tag> readTagList(SWF swf,int level,boolean parallel,boolean skipUnusualTags,boolean parseTags,boolean gfx) throws IOException, InterruptedException {
  ExecutorService executor=null;
  List<Future<Tag>> futureResults=new ArrayList<>();
  if (parallel) {
    executor=Executors.newFixedThreadPool(Configuration.parallelThreadCount.get());
    futureResults=new ArrayList<>();
  }
  List<Tag> tags=new ArrayList<>();
  Tag tag;
  Tag previousTag=null;
  boolean isAS3=false;
  while (true) {
    long pos=getPos();
    try {
      tag=readTag(swf,level,pos,parseTags && !parallel,parallel,skipUnusualTags,gfx);
    }
 catch (    EOFException|EndOfStreamException ex) {
      tag=null;
    }
    if (tag == null) {
      break;
    }
    if (!parallel) {
      tags.add(tag);
    }
    if (Configuration.dumpTags.get() && level == 0) {
      dumpTag(System.out,version,tag,level);
    }
    tag.previousTag=previousTag;
    previousTag=tag;
    if (ShowFrameTag.isNestedTagType(tag.getId())) {
      tagPositionsInFrame.add(pos);
    }
 else     if (tag.getId() == ShowFrameTag.ID) {
      tagPositionsInFrames.put(pos,tagPositionsInFrame);
      tagPositionsInFrame=new ArrayList<>();
    }
    boolean doParse;
    if (!skipUnusualTags) {
      doParse=true;
    }
 else {
switch (tag.getId()) {
case FileAttributesTag.ID:
        FileAttributesTag fileAttributes=(FileAttributesTag)resolveTag(swf,tag,version,level,parallel,skipUnusualTags,gfx);
      if (fileAttributes.actionScript3) {
        isAS3=true;
      }
    doParse=true;
  break;
case DoActionTag.ID:
case DoInitActionTag.ID:
if (isAS3) {
  doParse=false;
}
 else {
  doParse=true;
}
break;
case ShowFrameTag.ID:
case PlaceObjectTag.ID:
case PlaceObject2Tag.ID:
case RemoveObjectTag.ID:
case RemoveObject2Tag.ID:
case PlaceObject3Tag.ID:
case StartSoundTag.ID:
case FrameLabelTag.ID:
case SoundStreamHeadTag.ID:
case SoundStreamHead2Tag.ID:
case SoundStreamBlockTag.ID:
doParse=true;
break;
default :
if (level > 0) {
Logger.getLogger(SWFInputStream.class.getName()).log(Level.FINE,""String_Node_Str"",tag.getId());
doParse=false;
}
 else {
doParse=true;
}
}
}
if (!parseTags) {
doParse=false;
}
if (doParse) {
if (parallel) {
Future<Tag> future=executor.submit(new TagResolutionTask(swf,tag,version,level,parallel,skipUnusualTags,gfx));
futureResults.add(future);
}
}
}
if (parallel) {
for (Future<Tag> future : futureResults) {
try {
tags.add(future.get());
}
 catch (InterruptedException ex) {
future.cancel(true);
}
catch (ExecutionException e) {
Logger.getLogger(SWFInputStream.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
}
}
executor.shutdown();
}
return tags;
}","/** 
 * Reads list of tags from the stream. Reading ends with End tag(=0) or end of the stream. Optionally can skip AS1/2 tags when file is AS3
 * @param swf
 * @param level
 * @param parallel
 * @param skipUnusualTags
 * @param parseTags
 * @param gfx
 * @return List of tags
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public List<Tag> readTagList(SWF swf,int level,boolean parallel,boolean skipUnusualTags,boolean parseTags,boolean gfx) throws IOException, InterruptedException {
  ExecutorService executor=null;
  List<Future<Tag>> futureResults=new ArrayList<>();
  if (parallel) {
    executor=Executors.newFixedThreadPool(Configuration.parallelThreadCount.get());
    futureResults=new ArrayList<>();
  }
  List<Tag> tags=new ArrayList<>();
  Tag tag;
  Tag previousTag=null;
  boolean isAS3=false;
  while (true) {
    long pos=getPos();
    try {
      tag=readTag(swf,level,pos,parseTags && !parallel,parallel,skipUnusualTags,gfx);
    }
 catch (    EOFException|EndOfStreamException ex) {
      tag=null;
    }
    if (tag == null) {
      break;
    }
    if (!parallel) {
      tags.add(tag);
    }
    if (Configuration.dumpTags.get() && level == 0) {
      dumpTag(System.out,version,tag,level);
    }
    tag.previousTag=previousTag;
    previousTag=tag;
    if (ShowFrameTag.isNestedTagType(tag.getId())) {
      tagPositionsInFrame.add(pos);
    }
 else     if (tag.getId() == ShowFrameTag.ID) {
      tagPositionsInFrames.put(pos,tagPositionsInFrame);
      tagPositionsInFrame=new ArrayList<>();
    }
    boolean doParse;
    if (!skipUnusualTags) {
      doParse=true;
    }
 else {
switch (tag.getId()) {
case FileAttributesTag.ID:
        FileAttributesTag fileAttributes=(FileAttributesTag)resolveTag(swf,tag,version,level,parallel,skipUnusualTags,gfx);
      if (fileAttributes.actionScript3) {
        isAS3=true;
      }
    doParse=true;
  break;
case DoActionTag.ID:
case DoInitActionTag.ID:
if (isAS3) {
  doParse=false;
}
 else {
  doParse=true;
}
break;
case ShowFrameTag.ID:
case PlaceObjectTag.ID:
case PlaceObject2Tag.ID:
case RemoveObjectTag.ID:
case RemoveObject2Tag.ID:
case PlaceObject3Tag.ID:
case StartSoundTag.ID:
case FrameLabelTag.ID:
case SoundStreamHeadTag.ID:
case SoundStreamHead2Tag.ID:
case SoundStreamBlockTag.ID:
case VideoFrameTag.ID:
doParse=true;
break;
default :
if (level > 0) {
Logger.getLogger(SWFInputStream.class.getName()).log(Level.FINE,""String_Node_Str"",tag.getId());
doParse=false;
}
 else {
doParse=true;
}
}
}
if (!parseTags) {
doParse=false;
}
if (doParse) {
if (parallel) {
Future<Tag> future=executor.submit(new TagResolutionTask(swf,tag,version,level,parallel,skipUnusualTags,gfx));
futureResults.add(future);
}
}
}
if (parallel) {
for (Future<Tag> future : futureResults) {
try {
tags.add(future.get());
}
 catch (InterruptedException ex) {
future.cancel(true);
}
catch (ExecutionException e) {
Logger.getLogger(SWFInputStream.class.getName()).log(Level.SEVERE,""String_Node_Str"",e);
}
}
executor.shutdown();
}
return tags;
}",0.996180036538781
61816,"/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param mis
 * @param version
 * @param ip
 * @param endIp
 * @param path
 * @return List of actions
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,MemoryInputStream mis,int version,int ip,int endIp,String path) throws IOException, InterruptedException {
  boolean deobfuscate=Configuration.autoDeobfuscate.get();
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(mis,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  Action lastAction=actions.get(actions.size() - 1);
  Action aEnd=new ActionEnd();
  if (!(lastAction instanceof ActionEnd)) {
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
  }
 else {
    endAddress-=getTotalActionLength(aEnd);
  }
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  if (deobfuscate) {
    try {
      actions=deobfuscateActionList(listeners,containerSWFOffset,actions,version,ip,path);
      updateActionLengths(actions,version);
      removeZeroJumps(actions,version);
    }
 catch (    OutOfMemoryError|StackOverflowError|TranslateException ex) {
      Logger.getLogger(ActionListReader.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  return actions;
}","/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param mis
 * @param version
 * @param ip
 * @param endIp
 * @param path
 * @return List of actions
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,MemoryInputStream mis,int version,int ip,int endIp,String path) throws IOException, InterruptedException {
  boolean deobfuscate=Configuration.autoDeobfuscate.get();
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(mis,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  Action lastAction=actions.get(actions.size() - 1);
  Action aEnd=new ActionEnd();
  if (!(lastAction instanceof ActionEnd)) {
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
  }
 else {
    endAddress-=getTotalActionLength(aEnd);
  }
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  if (deobfuscate) {
    try {
      actions=deobfuscateActionList(listeners,containerSWFOffset,actions,version,ip,path);
      updateActionLengths(actions,version);
      removeZeroJumps(actions,version);
    }
 catch (    OutOfMemoryError|StackOverflowError|TranslateException ex) {
      Logger.getLogger(ActionListReader.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  return actions;
}",0.9937846463967748
61817,"/** 
 * Removes an action from the action list, and updates all references
 * @param actions
 * @param index
 * @param version
 * @param removeWhenLast
 * @return
 */
public static boolean removeAction(List<Action> actions,int index,int version,boolean removeWhenLast){
  if (index < 0 || actions.size() <= index) {
    return false;
  }
  long startIp=actions.get(0).getAddress();
  Action lastAction=actions.get(actions.size() - 1);
  int lastIdx=(int)lastAction.getAddress();
  long endAddress=lastAction.getAddress() + getTotalActionLength(lastAction);
  List<Action> actionMap=new ArrayList<>(lastIdx);
  for (int i=0; i <= lastIdx; i++) {
    actionMap.add(null);
  }
  for (  Action a : actions) {
    actionMap.set((int)a.getAddress(),a);
  }
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  Action prevAction=index > 0 ? actions.get(index - 1) : null;
  Action nextAction=index + 1 < actions.size() ? actions.get(index + 1) : null;
  Action actionToRemove=actions.get(index);
  for (  Action a : containerLastActions.keySet()) {
    List<Action> lastActions=containerLastActions.get(a);
    for (int i=0; i < lastActions.size(); i++) {
      if (lastActions.get(i) == actionToRemove) {
        if (!removeWhenLast) {
          return false;
        }
        lastActions.set(i,prevAction);
      }
    }
  }
  for (  Action a : jumps.keySet()) {
    Action targetAction=jumps.get(a);
    if (targetAction == actionToRemove) {
      jumps.put(a,nextAction);
    }
  }
  if (containerLastActions.containsKey(actionToRemove)) {
    containerLastActions.remove(actionToRemove);
  }
  if (jumps.containsKey(actionToRemove)) {
    jumps.remove(actionToRemove);
  }
  actions.remove(index);
  updateAddresses(actions,startIp,version);
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  return true;
}","/** 
 * Removes an action from the action list, and updates all references
 * @param actions
 * @param index
 * @param version
 * @param removeWhenLast
 * @return
 */
public static boolean removeAction(List<Action> actions,int index,int version,boolean removeWhenLast){
  if (index < 0 || actions.size() <= index) {
    return false;
  }
  long startIp=actions.get(0).getAddress();
  Action lastAction=actions.get(actions.size() - 1);
  int lastIdx=(int)lastAction.getAddress();
  long endAddress=lastAction.getAddress() + getTotalActionLength(lastAction);
  List<Action> actionMap=new ArrayList<>(lastIdx);
  for (int i=0; i <= lastIdx; i++) {
    actionMap.add(null);
  }
  for (  Action a : actions) {
    actionMap.set((int)a.getAddress(),a);
  }
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  Action prevAction=index > 0 ? actions.get(index - 1) : null;
  Action nextAction=index + 1 < actions.size() ? actions.get(index + 1) : null;
  Action actionToRemove=actions.get(index);
  for (  Action a : containerLastActions.keySet()) {
    List<Action> lastActions=containerLastActions.get(a);
    for (int i=0; i < lastActions.size(); i++) {
      if (lastActions.get(i) == actionToRemove) {
        if (!removeWhenLast) {
          return false;
        }
        lastActions.set(i,prevAction);
      }
    }
  }
  for (  Action a : jumps.keySet()) {
    Action targetAction=jumps.get(a);
    if (targetAction == actionToRemove) {
      jumps.put(a,nextAction);
    }
  }
  if (containerLastActions.containsKey(actionToRemove)) {
    containerLastActions.remove(actionToRemove);
  }
  if (jumps.containsKey(actionToRemove)) {
    jumps.remove(actionToRemove);
  }
  actions.remove(index);
  updateAddresses(actions,startIp,version);
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  return true;
}",0.9652027837772978
61818,"@Override public String getASMSource(List<? extends GraphSourceItem> container,List<Long> knownAddreses,List<String> constantPool,int version,ExportMode exportMode){
  String ret=""String_Node_Str"" + frame + ""String_Node_Str""+ skipCount;
  for (int i=0; i < skipped.size(); i++) {
    if (skipped.get(i) instanceof ActionEnd) {
      break;
    }
    ret+=""String_Node_Str"" + skipped.get(i).getASMSource(container,knownAddreses,constantPool,version,exportMode);
  }
  return ret;
}","@Override public String getASMSource(List<? extends GraphSourceItem> container,List<Long> knownAddreses,List<String> constantPool,int version,ExportMode exportMode){
  String ret=""String_Node_Str"" + frame + ""String_Node_Str""+ skipCount;
  return ret;
}",0.6885245901639344
61819,"@Override public byte[] getBytes(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,version);
  try {
    sos.writeUI16(frame);
    sos.writeUI8(skipCount);
    for (int i=0; i < skipped.size(); i++) {
      sos.write(skipped.get(i).getBytes(SWF.DEFAULT_VERSION));
    }
    sos.close();
  }
 catch (  IOException e) {
  }
  return surroundWithAction(baos.toByteArray(),version);
}","@Override public byte[] getBytes(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  SWFOutputStream sos=new SWFOutputStream(baos,version);
  try {
    sos.writeUI16(frame);
    sos.writeUI8(skipCount);
    sos.close();
  }
 catch (  IOException e) {
  }
  return surroundWithAction(baos.toByteArray(),version);
}",0.8545918367346939
61820,"@Override public String getASMSource(List<? extends GraphSourceItem> container,List<Long> knownAddreses,List<String> constantPool,int version,ExportMode exportMode){
  String ret=""String_Node_Str"" + skipCount;
  for (int i=0; i < skipped.size(); i++) {
    if (skipped.get(i) instanceof ActionEnd) {
      break;
    }
    ret+=""String_Node_Str"" + skipped.get(i).getASMSource(container,knownAddreses,constantPool,version,exportMode);
  }
  return ret;
}","@Override public String getASMSource(List<? extends GraphSourceItem> container,List<Long> knownAddreses,List<String> constantPool,int version,ExportMode exportMode){
  String ret=""String_Node_Str"" + skipCount;
  return ret;
}",0.6637168141592921
61821,"private GraphTargetItem expression(boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean existsRemainder=false;
  boolean assocRight=false;
switch (s.type) {
case MINUS:
    GraphTargetItem num=expression(registerVars,inFunction,inMethod,true,variables);
  if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Long)) {
    ((DirectValueActionItem)num).value=-(Long)((DirectValueActionItem)num).value;
    ret=num;
  }
 else   if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Double)) {
    Double d=(Double)((DirectValueActionItem)num).value;
    if (d.isInfinite()) {
      ((DirectValueActionItem)num).value=Double.NEGATIVE_INFINITY;
    }
 else {
      ((DirectValueActionItem)num).value=-d;
    }
    ret=(num);
  }
 else   if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Float)) {
    ((DirectValueActionItem)num).value=-(Float)((DirectValueActionItem)num).value;
    ret=(num);
  }
 else {
    ;
    ret=(new SubtractActionItem(null,new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>()),num));
  }
break;
case TYPEOF:
expectedType(SymbolType.PARENT_OPEN);
ret=new TypeOfActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
existsRemainder=true;
break;
case TRUE:
ret=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
existsRemainder=true;
break;
case NULL:
ret=new DirectValueActionItem(null,0,new Null(),new ArrayList<String>());
existsRemainder=true;
break;
case UNDEFINED:
ret=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
break;
case FALSE:
ret=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
existsRemainder=true;
break;
case CURLY_OPEN:
s=lex();
List<GraphTargetItem> objectNames=new ArrayList<>();
List<GraphTargetItem> objectValues=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
objectNames.add(0,pushConst((String)s.value));
expectedType(SymbolType.COLON);
objectValues.add(0,expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new InitObjectActionItem(null,objectNames,objectValues);
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(inBrackets,registerVars,inFunction,inMethod,variables);
ret=new InitArrayActionItem(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.type == SymbolType.IDENTIFIER) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
ret=function(true,fname,false,variables);
break;
case STRING:
ret=pushConst(s.value.toString());
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
case NEWLINE:
ret=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
existsRemainder=true;
break;
case NAN:
ret=new DirectValueActionItem(null,0,Double.NaN,new ArrayList<String>());
existsRemainder=true;
break;
case INFINITY:
ret=new DirectValueActionItem(null,0,Double.POSITIVE_INFINITY,new ArrayList<String>());
existsRemainder=true;
break;
case INTEGER:
case DOUBLE:
ret=new DirectValueActionItem(null,0,s.value,new ArrayList<String>());
existsRemainder=true;
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem prevar=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,prevar);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,prevar);
}
existsRemainder=true;
break;
case NOT:
ret=new NotItem(null,expression(registerVars,inFunction,inMethod,true,variables));
existsRemainder=true;
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
case NEW:
GraphTargetItem newvar=variable(registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
if (newvar instanceof GetMemberActionItem) {
GetMemberActionItem mem=(GetMemberActionItem)newvar;
ret=new NewMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (newvar instanceof VariableActionItem) {
ret=new NewObjectActionItem(null,newvar,call(registerVars,inFunction,inMethod,variables));
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
existsRemainder=true;
break;
case IDENTIFIER:
case THIS:
case EVAL:
GraphTargetItem var;
if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=new EvalActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
}
VariableActionItem gva=null;
GetMemberActionItem gmb=null;
RegisterNumber reg=null;
if (var instanceof VariableActionItem) {
gva=(VariableActionItem)var;
}
 else if (var instanceof GetMemberActionItem) {
gmb=(GetMemberActionItem)var;
}
s=lex();
switch (s.type) {
case ASSIGN:
GraphTargetItem varval=expression(registerVars,inFunction,inMethod,true,variables);
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),varval,false);
variables.add((VariableActionItem)ret);
}
 else if (gmb != null) {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,varval);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
existsRemainder=true;
assocRight=true;
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_XOR:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
GraphTargetItem varval2=expression(registerVars,inFunction,inMethod,true,variables);
switch (s.type) {
case ASSIGN_BITAND:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new BitAndActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new BitAndActionItem(null,gmb,varval2));
}
break;
case ASSIGN_BITOR:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new BitOrActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new BitOrActionItem(null,gmb,varval2));
}
break;
case ASSIGN_DIVIDE:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new DivideActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new DivideActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MINUS:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new SubtractActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new SubtractActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MODULO:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new ModuloActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new ModuloActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MULTIPLY:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new MultiplyActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new MultiplyActionItem(null,gmb,varval2));
}
break;
case ASSIGN_PLUS:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new AddActionItem(null,gva,varval2,true),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new AddActionItem(null,gmb,varval2,true));
}
break;
}
existsRemainder=true;
assocRight=true;
break;
case INCREMENT:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
lexer.pushback(s);
ret=memberOrCall(var,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
default :
ret=var;
lexer.pushback(s);
existsRemainder=true;
}
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
existsRemainder=true;
ret=excmd;
break;
}
lexer.pushback(s);
}
if (allowRemainder && existsRemainder) {
GraphTargetItem rem=ret;
do {
rem=expressionRemainder(rem,registerVars,inFunction,inMethod,assocRight,variables);
if (rem != null) {
ret=rem;
}
}
 while ((!assocRight) && (rem != null));
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}","private GraphTargetItem expression(boolean allowEmpty,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ParseException {
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
  boolean existsRemainder=false;
  boolean assocRight=false;
switch (s.type) {
case MINUS:
    s=lex();
  if (s.isType(SymbolType.DOUBLE)) {
    ret=new DirectValueActionItem(null,0,-(double)(Double)s.value,new ArrayList<String>());
    existsRemainder=true;
  }
 else   if (s.isType(SymbolType.INTEGER)) {
    ret=new DirectValueActionItem(null,0,-(long)(Long)s.value,new ArrayList<String>());
    existsRemainder=true;
  }
 else {
    lexer.pushback(s);
    GraphTargetItem num=expression(registerVars,inFunction,inMethod,true,variables);
    if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Long)) {
      ((DirectValueActionItem)num).value=-(Long)((DirectValueActionItem)num).value;
      ret=num;
    }
 else     if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Double)) {
      Double d=(Double)((DirectValueActionItem)num).value;
      if (d.isInfinite()) {
        ((DirectValueActionItem)num).value=Double.NEGATIVE_INFINITY;
      }
 else {
        ((DirectValueActionItem)num).value=-d;
      }
      ret=(num);
    }
 else     if ((num instanceof DirectValueActionItem) && (((DirectValueActionItem)num).value instanceof Float)) {
      ((DirectValueActionItem)num).value=-(Float)((DirectValueActionItem)num).value;
      ret=(num);
    }
 else {
      ;
      ret=(new SubtractActionItem(null,new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>()),num));
    }
  }
break;
case TYPEOF:
expectedType(SymbolType.PARENT_OPEN);
ret=new TypeOfActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
existsRemainder=true;
break;
case TRUE:
ret=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
existsRemainder=true;
break;
case NULL:
ret=new DirectValueActionItem(null,0,new Null(),new ArrayList<String>());
existsRemainder=true;
break;
case UNDEFINED:
ret=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
break;
case FALSE:
ret=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
existsRemainder=true;
break;
case CURLY_OPEN:
s=lex();
List<GraphTargetItem> objectNames=new ArrayList<>();
List<GraphTargetItem> objectValues=new ArrayList<>();
while (s.type != SymbolType.CURLY_CLOSE) {
if (s.type != SymbolType.COMMA) {
lexer.pushback(s);
}
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
objectNames.add(0,pushConst((String)s.value));
expectedType(SymbolType.COLON);
objectValues.add(0,expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (!s.isType(SymbolType.COMMA,SymbolType.CURLY_CLOSE)) {
expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.CURLY_CLOSE);
}
}
ret=new InitObjectActionItem(null,objectNames,objectValues);
break;
case BRACKET_OPEN:
lexer.pushback(s);
List<GraphTargetItem> inBrackets=new ArrayList<>();
int arrCnt=brackets(inBrackets,registerVars,inFunction,inMethod,variables);
ret=new InitArrayActionItem(null,inBrackets);
break;
case FUNCTION:
s=lexer.lex();
String fname=""String_Node_Str"";
if (s.type == SymbolType.IDENTIFIER) {
fname=s.value.toString();
}
 else {
lexer.pushback(s);
}
ret=function(true,fname,false,variables);
break;
case STRING:
ret=pushConst(s.value.toString());
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
case NEWLINE:
ret=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
existsRemainder=true;
break;
case NAN:
ret=new DirectValueActionItem(null,0,Double.NaN,new ArrayList<String>());
existsRemainder=true;
break;
case INFINITY:
ret=new DirectValueActionItem(null,0,Double.POSITIVE_INFINITY,new ArrayList<String>());
existsRemainder=true;
break;
case INTEGER:
case DOUBLE:
ret=new DirectValueActionItem(null,0,s.value,new ArrayList<String>());
existsRemainder=true;
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem prevar=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,prevar);
}
if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,prevar);
}
existsRemainder=true;
break;
case NOT:
ret=new NotItem(null,expression(registerVars,inFunction,inMethod,true,variables));
existsRemainder=true;
break;
case PARENT_OPEN:
ret=new ParenthesisItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
case NEW:
GraphTargetItem newvar=variable(registerVars,inFunction,inMethod,variables);
expectedType(SymbolType.PARENT_OPEN);
if (newvar instanceof GetMemberActionItem) {
GetMemberActionItem mem=(GetMemberActionItem)newvar;
ret=new NewMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (newvar instanceof VariableActionItem) {
ret=new NewObjectActionItem(null,newvar,call(registerVars,inFunction,inMethod,variables));
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
existsRemainder=true;
break;
case IDENTIFIER:
case THIS:
case EVAL:
GraphTargetItem var;
if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=new EvalActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
}
VariableActionItem gva=null;
GetMemberActionItem gmb=null;
RegisterNumber reg=null;
if (var instanceof VariableActionItem) {
gva=(VariableActionItem)var;
}
 else if (var instanceof GetMemberActionItem) {
gmb=(GetMemberActionItem)var;
}
s=lex();
switch (s.type) {
case ASSIGN:
GraphTargetItem varval=expression(registerVars,inFunction,inMethod,true,variables);
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),varval,false);
variables.add((VariableActionItem)ret);
}
 else if (gmb != null) {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,varval);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
existsRemainder=true;
assocRight=true;
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_XOR:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
GraphTargetItem varval2=expression(registerVars,inFunction,inMethod,true,variables);
switch (s.type) {
case ASSIGN_BITAND:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new BitAndActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new BitAndActionItem(null,gmb,varval2));
}
break;
case ASSIGN_BITOR:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new BitOrActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new BitOrActionItem(null,gmb,varval2));
}
break;
case ASSIGN_DIVIDE:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new DivideActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new DivideActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MINUS:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new SubtractActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new SubtractActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MODULO:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new ModuloActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new ModuloActionItem(null,gmb,varval2));
}
break;
case ASSIGN_MULTIPLY:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new MultiplyActionItem(null,gva,varval2),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new MultiplyActionItem(null,gmb,varval2));
}
break;
case ASSIGN_PLUS:
if (gva != null) {
ret=new VariableActionItem(gva.getVariableName(),new AddActionItem(null,gva,varval2,true),false);
variables.add((VariableActionItem)ret);
}
 else {
ret=new SetMemberActionItem(null,gmb.object,gmb.memberName,new AddActionItem(null,gmb,varval2,true));
}
break;
}
existsRemainder=true;
assocRight=true;
break;
case INCREMENT:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
if (gva == null && gmb == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
lexer.pushback(s);
ret=memberOrCall(var,registerVars,inFunction,inMethod,variables);
existsRemainder=true;
break;
default :
ret=var;
lexer.pushback(s);
existsRemainder=true;
}
break;
default :
GraphTargetItem excmd=expressionCommands(s,registerVars,inFunction,inMethod,-1,variables);
if (excmd != null) {
existsRemainder=true;
ret=excmd;
break;
}
lexer.pushback(s);
}
if (allowRemainder && existsRemainder) {
GraphTargetItem rem=ret;
do {
rem=expressionRemainder(rem,registerVars,inFunction,inMethod,assocRight,variables);
if (rem != null) {
ret=rem;
}
}
 while ((!assocRight) && (rem != null));
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return ret;
}",0.976634364700674
61822,"private GraphTargetItem expressionRemainder(GraphTargetItem expr,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
switch (s.type) {
case DOT:
    lexer.pushback(s);
  ret=memberOrCall(expr,registerVars,inFunction,inMethod,variables);
break;
case TERNAR:
GraphTargetItem terOnTrue=expression(registerVars,inFunction,inMethod,false,variables);
expectedType(SymbolType.COLON);
GraphTargetItem terOnFalse=expression(registerVars,inFunction,inMethod,false,variables);
ret=new TernarOpItem(null,expr,terOnTrue,terOnFalse);
break;
case SHIFT_LEFT:
ret=new LShiftActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case SHIFT_RIGHT:
ret=new RShiftActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case BITAND:
ret=new BitAndActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case BITOR:
ret=new BitOrActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case DIVIDE:
ret=new DivideActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MODULO:
ret=new ModuloActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case EQUALS:
ret=new EqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case STRICT_EQUALS:
ret=new StrictEqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case NOT_EQUAL:
ret=new NeqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case STRICT_NOT_EQUAL:
ret=new StrictNeqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case LOWER_THAN:
ret=new LtActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case LOWER_EQUAL:
ret=new LeActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case GREATER_THAN:
ret=new GtActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case GREATER_EQUAL:
ret=new GeActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case AND:
ret=new AndItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case OR:
ret=new OrItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MINUS:
ret=new SubtractActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MULTIPLY:
ret=new MultiplyActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case PLUS:
ret=new AddActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case XOR:
ret=new BitXorActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case AS:
break;
case INSTANCEOF:
ret=new InstanceOfActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case IS:
break;
default :
lexer.pushback(s);
if (expr instanceof ParenthesisItem) {
if (isType(((ParenthesisItem)expr).value)) {
GraphTargetItem expr2=expression(false,registerVars,inFunction,inMethod,true,variables);
if (expr2 != null) {
ret=new CastOpActionItem(null,((ParenthesisItem)expr).value,expr2);
}
}
}
}
ret=fixPrecedence(ret);
return ret;
}","private GraphTargetItem expressionRemainder(GraphTargetItem expr,HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,boolean allowRemainder,List<VariableActionItem> variables) throws IOException, ParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=lex();
switch (s.type) {
case DOT:
    lexer.pushback(s);
  ret=memberOrCall(expr,registerVars,inFunction,inMethod,variables);
break;
case TERNAR:
GraphTargetItem terOnTrue=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.COLON);
GraphTargetItem terOnFalse=expression(registerVars,inFunction,inMethod,true,variables);
ret=new TernarOpItem(null,expr,terOnTrue,terOnFalse);
break;
case SHIFT_LEFT:
ret=new LShiftActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case SHIFT_RIGHT:
ret=new RShiftActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case BITAND:
ret=new BitAndActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case BITOR:
ret=new BitOrActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case DIVIDE:
ret=new DivideActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MODULO:
ret=new ModuloActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case EQUALS:
ret=new EqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case STRICT_EQUALS:
ret=new StrictEqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case NOT_EQUAL:
ret=new NeqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case STRICT_NOT_EQUAL:
ret=new StrictNeqActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case LOWER_THAN:
ret=new LtActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case LOWER_EQUAL:
ret=new LeActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case GREATER_THAN:
ret=new GtActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case GREATER_EQUAL:
ret=new GeActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case AND:
ret=new AndItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case OR:
ret=new OrItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MINUS:
ret=new SubtractActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case MULTIPLY:
ret=new MultiplyActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case PLUS:
ret=new AddActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables),true);
break;
case XOR:
ret=new BitXorActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case AS:
break;
case INSTANCEOF:
ret=new InstanceOfActionItem(null,expr,expression(registerVars,inFunction,inMethod,false,variables));
break;
case IS:
break;
default :
lexer.pushback(s);
if (expr instanceof ParenthesisItem) {
if (isType(((ParenthesisItem)expr).value)) {
GraphTargetItem expr2=expression(false,registerVars,inFunction,inMethod,true,variables);
if (expr2 != null) {
ret=new CastOpActionItem(null,((ParenthesisItem)expr).value,expr2);
}
}
}
}
ret=fixPrecedence(ret);
return ret;
}",0.9980425055928412
61823,"@Override public boolean needsSemicolon(){
  if (it == null) {
    return super.needsSemicolon();
  }
  return it.needsSemicolon();
}","@Override public boolean needsSemicolon(){
  if (definition) {
    return true;
  }
  return false;
}",0.7521367521367521
61824,"@Override public boolean hasReturnValue(){
  if (it == null) {
    return false;
  }
 else {
    return it.hasReturnValue();
  }
}","@Override public boolean hasReturnValue(){
  if (definition) {
    return false;
  }
  return true;
}",0.8138528138528138
61825,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param level
 * @param pos
 * @param parallel
 * @param skipUnusualTags
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public DefineSpriteTag(SWF swf,byte[] data,int version,int level,long pos,boolean parallel,boolean skipUnusualTags) throws IOException, InterruptedException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version,pos);
  spriteId=sis.readUI16();
  frameCount=sis.readUI16();
  subTags=sis.readTagList(swf,level + 1,parallel,skipUnusualTags,true);
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param level
 * @param pos
 * @param parallel
 * @param skipUnusualTags
 * @throws IOException
 * @throws java.lang.InterruptedException
 */
public DefineSpriteTag(SWF swf,byte[] data,int version,int level,long pos,boolean parallel,boolean skipUnusualTags) throws IOException, InterruptedException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version,pos);
  spriteId=sis.readUI16();
  frameCount=sis.readUI16();
  subTags=sis.readTagList(swf,level + 1,parallel,skipUnusualTags,true,swf.gfx);
}",0.9938931297709924
61826,"private String getName(GraphTargetItem item){
  if (item instanceof DirectValueActionItem) {
    DirectValueActionItem dv=(DirectValueActionItem)item;
    return (String)dv.getResult();
  }
  if (item instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)item;
    return getName(gv.name);
  }
  if (item instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)item;
    return getName(mem.memberName);
  }
  return null;
}","private String getName(GraphTargetItem item){
  if (item instanceof VariableActionItem) {
    return ((VariableActionItem)item).getVariableName();
  }
  if (item instanceof DirectValueActionItem) {
    DirectValueActionItem dv=(DirectValueActionItem)item;
    return (String)dv.getResult();
  }
  if (item instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)item;
    return getName(gv.name);
  }
  if (item instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)item;
    return getName(mem.memberName);
  }
  return null;
}",0.902143522833178
61827,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61828,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61829,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(tryCommands);
  ret.addAll(catchCommands);
  ret.add(finallyCommands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (tryCommands != null) {
    ret.add(tryCommands);
  }
  ret.addAll(catchCommands);
  if (finallyCommands != null) {
    ret.add(finallyCommands);
  }
  return ret;
}",0.7975206611570248
61830,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(functions);
  ret.add(staticFunctions);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (functions != null) {
    ret.add(functions);
  }
  if (staticFunctions != null) {
    ret.add(staticFunctions);
  }
  return ret;
}",0.7714285714285715
61831,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61832,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(actions);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (actions != null) {
    ret.add(actions);
  }
  return ret;
}",0.90282131661442
61833,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(tryCommands);
  ret.addAll(catchCommands);
  ret.add(finallyCommands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (tryCommands != null) {
    ret.add(tryCommands);
  }
  ret.addAll(catchCommands);
  if (finallyCommands != null) {
    ret.add(finallyCommands);
  }
  return ret;
}",0.7975206611570248
61834,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61835,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(firstCommands);
  ret.add(commands);
  ret.add(finalCommands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (firstCommands != null) {
    ret.add(firstCommands);
  }
  if (commands != null) {
    ret.add(commands);
  }
  if (finalCommands != null) {
    ret.add(finalCommands);
  }
  return ret;
}",0.74
61836,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(onTrue);
  ret.add(onFalse);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (onTrue != null) {
    ret.add(onTrue);
  }
  if (onFalse != null) {
    ret.add(onFalse);
  }
  return ret;
}",0.7803617571059431
61837,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.addAll(caseCommands);
  ret.add(defaultCommands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.addAll(caseCommands);
  if (defaultCommands != null) {
    ret.add(defaultCommands);
  }
  return ret;
}",0.7819548872180451
61838,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61839,"@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  ret.add(commands);
  return ret;
}","@Override public List<List<GraphTargetItem>> getSubs(){
  List<List<GraphTargetItem>> ret=new ArrayList<>();
  if (commands != null) {
    ret.add(commands);
  }
  return ret;
}",0.9006211180124224
61840,"@Override public List<GraphSourceItem> toSourceIgnoreReturnValue(SourceGeneratorLocalData localData,SourceGenerator generator){
  List<GraphSourceItem> ret=new ArrayList<>();
  if (object instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)object;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetVariable());
  }
 else   if (object instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)object;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetMember());
  }
 else   if ((object instanceof DirectValueActionItem) && ((DirectValueActionItem)object).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)object).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
    ret.add(new ActionPop());
  }
 else   if (object instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)object;
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSourceIgnoreReturnValue(SourceGeneratorLocalData localData,SourceGenerator generator){
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=object;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetVariable());
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetMember());
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
    ret.add(new ActionPop());
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9340485957715368
61841,"@Override public List<GraphSourceItem> toSourceIgnoreReturnValue(SourceGeneratorLocalData localData,SourceGenerator generator){
  List<GraphSourceItem> ret=new ArrayList<>();
  if (object instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)object;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetVariable());
  }
 else   if (object instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)object;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetMember());
  }
 else   if ((object instanceof DirectValueActionItem) && ((DirectValueActionItem)object).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)object).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
    ret.add(new ActionPop());
  }
 else   if (object instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)object;
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSourceIgnoreReturnValue(SourceGeneratorLocalData localData,SourceGenerator generator){
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=object;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetVariable());
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetMember());
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
    ret.add(new ActionPop());
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9340485957715368
61842,"@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (name instanceof DirectValueActionItem || name instanceof GetVariableActionItem) {
    stripQuotes(name,localData,writer);
    writer.append(""String_Node_Str"");
    return value.toString(writer,localData);
  }
 else {
    writer.append(""String_Node_Str"");
    name.toString(writer,localData);
    writer.append(""String_Node_Str"");
    value.toString(writer,localData);
    return writer.append(""String_Node_Str"");
  }
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (name instanceof DirectValueActionItem || name instanceof VariableActionItem) {
    stripQuotes(name,localData,writer);
    writer.append(""String_Node_Str"");
    return value.toString(writer,localData);
  }
 else {
    writer.append(""String_Node_Str"");
    name.toString(writer,localData);
    writer.append(""String_Node_Str"");
    value.toString(writer,localData);
    return writer.append(""String_Node_Str"");
  }
}",0.9972144846796658
61843,"private boolean isThis(GraphTargetItem item){
  if (item instanceof DirectValueActionItem) {
    DirectValueActionItem di=(DirectValueActionItem)item;
    if (di.value instanceof RegisterNumber) {
      RegisterNumber rn=(RegisterNumber)di.value;
      if (""String_Node_Str"".equals(rn.name)) {
        return true;
      }
    }
  }
  if (item instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)item;
    if (gv.name instanceof DirectValueActionItem) {
      DirectValueActionItem di=(DirectValueActionItem)gv.name;
      if (""String_Node_Str"".equals(di.toStringNoH(null))) {
        return true;
      }
    }
  }
  return false;
}","private boolean isThis(GraphTargetItem item){
  if (item instanceof VariableActionItem) {
    return ""String_Node_Str"".equals(((VariableActionItem)item).getVariableName());
  }
  return false;
}",0.3592120509849362
61844,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  if (value instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)value;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (value instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)value;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((value instanceof DirectValueActionItem) && ((DirectValueActionItem)value).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)value).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (value instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)value;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionDecrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionDecrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionDecrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9631699263398528
61845,"@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  if (value instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)value;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (value instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)value;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((value instanceof DirectValueActionItem) && ((DirectValueActionItem)value).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)value).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (value instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)value;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}","@Override public List<GraphSourceItem> toSource(SourceGeneratorLocalData localData,SourceGenerator generator){
  ActionSourceGenerator asGenerator=(ActionSourceGenerator)generator;
  List<GraphSourceItem> ret=new ArrayList<>();
  GraphTargetItem val=value;
  if (val instanceof VariableActionItem) {
    val=((VariableActionItem)val).getBoxedValue();
  }
  if (val instanceof GetVariableActionItem) {
    GetVariableActionItem gv=(GetVariableActionItem)val;
    ret.addAll(gv.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gv.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetVariable());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if (val instanceof GetMemberActionItem) {
    GetMemberActionItem mem=(GetMemberActionItem)val;
    ret.addAll(mem.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(mem.toSource(localData,generator));
    ret.add(new ActionIncrement());
    int tmpReg=asGenerator.getTempRegister(localData);
    ret.add(new ActionStoreRegister(tmpReg));
    ret.add(new ActionSetMember());
    ret.add(new ActionPush(new RegisterNumber(tmpReg)));
  }
 else   if ((val instanceof DirectValueActionItem) && ((DirectValueActionItem)val).value instanceof RegisterNumber) {
    RegisterNumber rn=(RegisterNumber)((DirectValueActionItem)val).value;
    ret.add(new ActionPush(new RegisterNumber(rn.number)));
    ret.add(new ActionIncrement());
    ret.add(new ActionStoreRegister(rn.number));
  }
 else   if (val instanceof GetPropertyActionItem) {
    GetPropertyActionItem gp=(GetPropertyActionItem)val;
    ret.addAll(gp.toSource(localData,generator));
    ret.addAll(gp.toSource(localData,generator));
    ret.remove(ret.size() - 1);
    ret.addAll(gp.toSource(localData,generator));
    ret.add(new ActionIncrement());
    ret.add(new ActionSetProperty());
  }
  return ret;
}",0.9631699263398528
61846,"private FunctionActionItem function(boolean withBody,String functionName,boolean isMethod,List<VariableActionItem> variables) throws IOException, ParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=null;
  expectedType(SymbolType.PARENT_OPEN);
  s=lex();
  List<String> paramNames=new ArrayList<>();
  while (s.type != SymbolType.PARENT_CLOSE) {
    if (s.type != SymbolType.COMMA) {
      lexer.pushback(s);
    }
    s=lex();
    expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
    paramNames.add(s.value.toString());
    s=lex();
    if (s.type == SymbolType.COLON) {
      type(variables);
      s=lex();
    }
    if (!s.isType(SymbolType.COMMA,SymbolType.PARENT_CLOSE)) {
      expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.PARENT_CLOSE);
    }
  }
  HashMap<String,Integer> registerVars=new HashMap<>();
  registerVars.put(""String_Node_Str"",REGISTER_PARENT);
  registerVars.put(""String_Node_Str"",REGISTER_ROOT);
  registerVars.put(""String_Node_Str"",REGISTER_SUPER);
  registerVars.put(""String_Node_Str"",REGISTER_ARGUMENTS);
  registerVars.put(""String_Node_Str"",REGISTER_THIS);
  registerVars.put(""String_Node_Str"",REGISTER_GLOBAL);
  for (int i=0; i < paramNames.size(); i++) {
    registerVars.put(paramNames.get(i),(7 + i));
  }
  List<GraphTargetItem> body=null;
  List<VariableActionItem> subvariables=new ArrayList<>();
  if (withBody) {
    expectedType(SymbolType.CURLY_OPEN);
    body=commands(registerVars,true,isMethod,0,subvariables);
    expectedType(SymbolType.CURLY_CLOSE);
  }
  return new FunctionActionItem(null,functionName,paramNames,body,constantPool,-1,subvariables);
}","private FunctionActionItem function(boolean withBody,String functionName,boolean isMethod,List<VariableActionItem> variables) throws IOException, ParseException {
  GraphTargetItem ret=null;
  ParsedSymbol s=null;
  expectedType(SymbolType.PARENT_OPEN);
  s=lex();
  List<String> paramNames=new ArrayList<>();
  while (s.type != SymbolType.PARENT_CLOSE) {
    if (s.type != SymbolType.COMMA) {
      lexer.pushback(s);
    }
    s=lex();
    expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
    paramNames.add(s.value.toString());
    s=lex();
    if (s.type == SymbolType.COLON) {
      type(variables);
      s=lex();
    }
    if (!s.isType(SymbolType.COMMA,SymbolType.PARENT_CLOSE)) {
      expected(s,lexer.yyline(),SymbolType.COMMA,SymbolType.PARENT_CLOSE);
    }
  }
  List<GraphTargetItem> body=null;
  List<VariableActionItem> subvariables=new ArrayList<>();
  if (withBody) {
    expectedType(SymbolType.CURLY_OPEN);
    body=commands(new HashMap<String,Integer>(),true,isMethod,0,subvariables);
    expectedType(SymbolType.CURLY_CLOSE);
  }
  return new FunctionActionItem(null,functionName,paramNames,body,constantPool,-1,subvariables);
}",0.8114161849710982
61847,"public SourceGeneratorLocalData(HashMap<String,Integer> registerVars,Boolean inFunction,Boolean inMethod,Integer forInLevel){
  this.registerVars=registerVars;
  this.inFunction=inFunction;
  this.inMethod=inMethod;
  this.forInLevel=forInLevel;
}","public SourceGeneratorLocalData(HashMap<String,Integer> registerVars,Integer inFunction,Boolean inMethod,Integer forInLevel){
  this.registerVars=registerVars;
  this.inFunction=inFunction;
  this.inMethod=inMethod;
  this.forInLevel=forInLevel;
}",0.97165991902834
61848,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  ofs.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  ofs.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9748549323017408
61849,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9750479846449136
61850,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  ofs.toString(writer,localData);
  writer.append(""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  ofs.toString(writer,localData);
  writer.append(""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9803328290468988
61851,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  if (!params.isEmpty()) {
    writer.append(""String_Node_Str"");
    for (int i=0; i < params.size(); i++) {
      if (i > 0) {
        writer.append(""String_Node_Str"");
      }
      GraphTargetItem p=params.get(i);
      if (p instanceof NullAVM2Item) {
        writer.append(""String_Node_Str"");
      }
 else {
        p.toString(writer,localData);
      }
    }
    writer.append(""String_Node_Str"");
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  if (!params.isEmpty()) {
    writer.append(""String_Node_Str"");
    for (int i=0; i < params.size(); i++) {
      if (i > 0) {
        writer.append(""String_Node_Str"");
      }
      GraphTargetItem p=params.get(i);
      if (p instanceof NullAVM2Item) {
        writer.append(""String_Node_Str"");
      }
 else {
        p.toString(writer,localData);
      }
    }
    writer.append(""String_Node_Str"");
  }
  return writer;
}",0.9888027562446168
61852,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(value ? ""String_Node_Str"" : ""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(value ? ""String_Node_Str"" : ""String_Node_Str"");
}",0.9657320872274144
61853,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (function.getPrecedence() > precedence) {
    writer.append(""String_Node_Str"");
    function.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
    function.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (function.getPrecedence() > precedence) {
    writer.append(""String_Node_Str"");
    function.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
    function.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.9887834339948232
61854,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  receiver.toString(writer,localData);
  writer.append(""String_Node_Str"");
  writer.append(methodName);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  receiver.toString(writer,localData);
  writer.append(""String_Node_Str"");
  writer.append(methodName);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.985945945945946
61855,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  formatProperty(writer,receiver,propertyName,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  formatProperty(writer,receiver,propertyName,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.9843937575030012
61856,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  receiver.toString(writer,localData);
  writer.append(""String_Node_Str"");
  writer.append(methodName);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  receiver.toString(writer,localData);
  writer.append(""String_Node_Str"");
  writer.append(methodName);
  writer.append(""String_Node_Str"");
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.985945945945946
61857,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!receiver.toString().equals(""String_Node_Str"")) {
    receiver.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  multiname.toString(writer,localData);
  writer.append(""String_Node_Str"");
  String args=""String_Node_Str"";
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!receiver.toString().equals(""String_Node_Str"")) {
    receiver.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  multiname.toString(writer,localData);
  writer.append(""String_Node_Str"");
  String args=""String_Node_Str"";
  for (int a=0; a < arguments.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    arguments.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.989282769991756
61858,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(className.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(className.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}",0.9706666666666668
61859,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return value.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return value.toString(writer,localData);
}",0.9659442724458204
61860,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (object instanceof NewFunctionAVM2Item) {
    writer.append(""String_Node_Str"");
    return object.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (object instanceof NewFunctionAVM2Item) {
    writer.append(""String_Node_Str"");
    return object.toString(writer,localData);
  }
  writer.append(""String_Node_Str"");
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.9883198562443846
61861,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  int idx=writer.getLength();
  object.toString(writer,localData);
  if (idx < writer.getLength()) {
    writer.append(""String_Node_Str"");
  }
  propertyName.toString(writer,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  int idx=writer.getLength();
  object.toString(writer,localData);
  if (idx < writer.getLength()) {
    writer.append(""String_Node_Str"");
  }
  propertyName.toString(writer,localData);
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.9886064855390008
61862,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!object.toString().equals(""String_Node_Str"")) {
    object.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!object.toString().equals(""String_Node_Str"")) {
    object.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      writer.append(""String_Node_Str"");
    }
    args.get(a).toString(writer,localData);
  }
  return writer.append(""String_Node_Str"");
}",0.9865563598759048
61863,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return value.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return value.toString(writer,localData);
}",0.9659442724458204
61864,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  writer.append(localRegName(localData.localRegNames,regIndex));
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  writer.append(localRegName(localData.localRegNames,regIndex));
  return writer.append(""String_Node_Str"");
}",0.9721518987341772
61865,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9721518987341772
61866,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  return ns.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  return ns.toString(writer,localData);
}",0.9717223650385604
61867,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9721627408993576
61868,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  writer.append(""String_Node_Str"");
  expression.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9727463312368972
61869,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return object.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return object.toString(writer,localData);
}",0.966153846153846
61870,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(propertyName.getNamespace(localData.constantsAvm2).getName(localData.constantsAvm2));
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(propertyName.getNamespace(localData.constantsAvm2).getName(localData.constantsAvm2));
}",0.9722921914357684
61871,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer;
}",0.9483568075117372
61872,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(""String_Node_Str"" + value);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(""String_Node_Str"" + value);
}",0.9608540925266904
61873,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (namespace != null) {
    namespace.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
  }
  if (name != null) {
    writer.append(""String_Node_Str"");
    name.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
    ConstantPool constants=localData.constantsAvm2;
    List<String> fullyQualifiedNames=localData.fullyQualifiedNames;
    writer.append(constants.getMultiname(multinameIndex).getName(constants,fullyQualifiedNames));
  }
  return writer;
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (namespace != null) {
    namespace.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
  }
  if (name != null) {
    writer.append(""String_Node_Str"");
    name.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
 else {
    ConstantPool constants=localData.constantsAvm2;
    List<String> fullyQualifiedNames=localData.fullyQualifiedNames;
    writer.append(constants.getMultiname(multinameIndex).getName(constants,fullyQualifiedNames));
  }
  return writer;
}",0.9896414342629484
61874,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return multiname.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return multiname.toString(writer,localData);
}",0.9727463312368972
61875,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(propertyName.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(propertyName.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}",0.9711286089238844
61876,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return formatProperty(writer,object,propertyName,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  return formatProperty(writer,object,propertyName,localData);
}",0.9696969696969696
61877,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  if (slotName == null) {
    return writer.append(""String_Node_Str"");
  }
  return writer.append(slotName.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  if (slotName == null) {
    return writer.append(""String_Node_Str"");
  }
  return writer.append(slotName.getName(localData.constantsAvm2,localData.fullyQualifiedNames));
}",0.9751434034416826
61878,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!object.toString().equals(""String_Node_Str"")) {
    object.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  return propertyName.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  if (!object.toString().equals(""String_Node_Str"")) {
    object.toString(writer,localData);
    writer.append(""String_Node_Str"");
  }
  writer.append(""String_Node_Str"");
  return propertyName.toString(writer,localData);
}",0.9808541973490428
61879,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  collection.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return object.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  collection.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return object.toString(writer,localData);
}",0.9728601252609604
61880,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return collection.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  object.toString(writer,localData);
  writer.append(""String_Node_Str"");
  return collection.toString(writer,localData);
}",0.9728601252609604
61881,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  writer.append(localRegName(localData.localRegNames,regIndex));
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  writer.append(localRegName(localData.localRegNames,regIndex));
  return writer.append(""String_Node_Str"");
}",0.9721518987341772
61882,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  value.toString(writer,localData);
  return writer.append(""String_Node_Str"");
}",0.9721518987341772
61883,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  formatProperty(writer,object,propertyName,localData);
  writer.append(""String_Node_Str"");
  return value.toString(writer,localData);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  formatProperty(writer,object,propertyName,localData);
  writer.append(""String_Node_Str"");
  return value.toString(writer,localData);
}",0.9743589743589745
61884,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(""String_Node_Str"" + value);
}","@Override public GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData){
  return writer.append(""String_Node_Str"" + value);
}",0.9608540925266904
61885,"private GraphTargetItem command(HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<VariableActionItem> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
switch (s.type) {
case CALL:
    expectedType(SymbolType.PARENT_OPEN);
  ret=new CallActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case LENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new StringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case MBLENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new MBStringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case SET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem name1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem value1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new SetVariableActionItem(null,name1,value1);
break;
case WITH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=(variable(registerVars,inFunction,inMethod,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> wcmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithActionItem(null,wvar,wcmd);
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case TRACE:
expectedType(SymbolType.PARENT_OPEN);
ret=new TraceActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case GETURL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int getuMethod=1;
GraphTargetItem target=null;
if (s.type == SymbolType.COMMA) {
target=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
getuMethod=1;
}
 else if (s.value.equals(""String_Node_Str"")) {
getuMethod=2;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
target=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new GetURL2ActionItem(null,url,target,getuMethod);
break;
case GOTOANDSTOP:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtsFrame,false,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case NEXTFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new NextFrameActionItem(null);
break;
case PLAY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PlayActionItem(null);
break;
case PREVFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PrevFrameActionItem(null);
break;
case TELLTARGET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem tellTarget=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> tellcmds=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new TellTargetActionItem(null,tellTarget,tellcmds);
break;
case STOP:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopActionItem(null);
break;
case STOPALLSOUNDS:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopAllSoundsActionItem(null);
break;
case TOGGLEHIGHQUALITY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new ToggleHighQualityActionItem(null);
break;
case STOPDRAG:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopDragActionItem(null);
break;
case UNLOADMOVIE:
case UNLOADMOVIENUM:
SymbolType unloadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem unTargetOrNum=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
if (unloadType == SymbolType.UNLOADMOVIE) {
ret=new UnLoadMovieActionItem(null,unTargetOrNum);
}
if (unloadType == SymbolType.UNLOADMOVIENUM) {
ret=new UnLoadMovieNumActionItem(null,unTargetOrNum);
}
break;
case PRINT:
case PRINTASBITMAP:
case PRINTASBITMAPNUM:
case PRINTNUM:
SymbolType printType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem printTarget=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem printBBox=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
switch (printType) {
case PRINT:
ret=new PrintActionItem(null,printTarget,printBBox);
break;
case PRINTNUM:
ret=new PrintNumActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAP:
ret=new PrintAsBitmapActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAPNUM:
ret=new PrintAsBitmapNumActionItem(null,printTarget,printBBox);
break;
}
break;
case LOADVARIABLES:
case LOADMOVIE:
case LOADVARIABLESNUM:
case LOADMOVIENUM:
SymbolType loadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url2=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem targetOrNum=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int lvmethod=1;
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
lvmethod=2;
}
 else if (s.value.equals(""String_Node_Str"")) {
lvmethod=1;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
switch (loadType) {
case LOADVARIABLES:
ret=new LoadVariablesActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIE:
ret=new LoadMovieActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADVARIABLESNUM:
ret=new LoadVariablesNumActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIENUM:
ret=new LoadMovieNumActionItem(null,url2,targetOrNum,lvmethod);
break;
}
break;
case GOTOANDPLAY:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtpFrame,true,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case REMOVEMOVIECLIP:
expectedType(SymbolType.PARENT_OPEN);
ret=new RemoveSpriteActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case STARTDRAG:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem dragTarget=(expression(registerVars,inFunction,inMethod,true,variables));
GraphTargetItem lockCenter=null;
GraphTargetItem constrain=null;
GraphTargetItem x1=null;
GraphTargetItem y1=null;
GraphTargetItem x2=null;
GraphTargetItem y2=null;
s=lex();
if (s.type == SymbolType.COMMA) {
lockCenter=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
constrain=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
x1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
x2=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y2=(expression(registerVars,inFunction,inMethod,true,variables));
}
 else {
lexer.pushback(s);
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y1=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
}
}
 else {
lockCenter=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new StartDragActionItem(null,dragTarget,lockCenter,constrain,x1,y1,x2,y2);
break;
case IFFRAMELOADED:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem iflExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> iflComs=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new IfFrameLoadedActionItem(iflExpr,iflComs,null);
break;
case CLASS:
GraphTargetItem classTypeStr=type(variables);
s=lex();
GraphTargetItem extendsTypeStr=null;
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(variables);
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(variables);
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(false,classTypeStr,extendsTypeStr,implementsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
GraphTargetItem interfaceTypeStr=type(variables);
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(variables);
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(true,interfaceTypeStr,null,intExtendsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
ret=(function(true,s.value.toString(),false,variables));
break;
case NEW:
GraphTargetItem type=type(variables);
expectedType(SymbolType.PARENT_OPEN);
if (type instanceof GetMemberActionItem) {
GetMemberActionItem mem=(GetMemberActionItem)type;
ret=new NewMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (type instanceof VariableActionItem) {
VariableActionItem var=(VariableActionItem)type;
ret=new NewObjectActionItem(null,var,call(registerVars,inFunction,inMethod,variables));
}
 else {
ret=new NewObjectActionItem(null,ret,call(registerVars,inFunction,inMethod,variables));
}
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
if (s.type == SymbolType.COLON) {
type(variables);
s=lex();
}
if (s.type == SymbolType.ASSIGN) {
if (!inFunction) {
}
GraphTargetItem varval=(expression(registerVars,inFunction,inMethod,true,variables));
ret=new VariableActionItem(varIdentifier,varval,true);
variables.add((VariableActionItem)ret);
}
 else {
ret=new VariableActionItem(varIdentifier,null,true);
variables.add((VariableActionItem)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,varincdec);
}
 else if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,varincdec);
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case PARENT_OPEN:
case EVAL:
ParsedSymbol varS=s;
boolean isEval=false;
GraphTargetItem var;
if (s.type == SymbolType.PARENT_OPEN) {
var=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=expression(registerVars,inFunction,inMethod,true,variables);
var=new EvalActionItem(null,var);
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
isEval=true;
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
}
s=lex();
switch (s.type) {
case ASSIGN:
ret=var;
ret=Action.gettoset(ret,expression(registerVars,inFunction,inMethod,true,variables),variables);
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_SHIFT_LEFT:
case ASSIGN_SHIFT_RIGHT:
case ASSIGN_USHIFT_RIGHT:
case ASSIGN_XOR:
GraphTargetItem valtoappend=(expression(registerVars,inFunction,inMethod,true,variables));
switch (s.type) {
case ASSIGN_BITAND:
ret=Action.gettoset(var,new BitAndActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_BITOR:
ret=Action.gettoset(var,new BitOrActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_DIVIDE:
ret=Action.gettoset(var,new DivideActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MINUS:
ret=Action.gettoset(var,new SubtractActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MODULO:
ret=Action.gettoset(var,new ModuloActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MULTIPLY:
ret=Action.gettoset(var,new MultiplyActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_PLUS:
ret=Action.gettoset(var,new AddActionItem(null,var,valtoappend,true),variables);
break;
}
break;
case INCREMENT:
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
ret=var;
if (varS.type == SymbolType.SUPER || varS.type == SymbolType.THIS) {
List<GraphTargetItem> args=call(registerVars,inFunction,inMethod,variables);
ret=new CallMethodActionItem(null,ret,new DirectValueActionItem(null,0,new Undefined(),constantPool),args);
}
 else {
lexer.pushback(s);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
}
break;
default :
if (isEval) {
ret=var;
}
 else {
if (mustBeCommand) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
whileBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,null,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
doBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,null,doBody,doExpr);
break;
case FOR:
expectedType(SymbolType.PARENT_OPEN);
s=lex();
boolean forin=false;
GraphTargetItem collection=null;
String objIdent=null;
int innerExprReg=0;
if (s.type == SymbolType.VAR || s.type == SymbolType.IDENTIFIER) {
ParsedSymbol s2=null;
ParsedSymbol ssel=s;
if (s.type == SymbolType.VAR) {
s2=lex();
ssel=s2;
}
if (ssel.type == SymbolType.IDENTIFIER) {
objIdent=ssel.value.toString();
ParsedSymbol s3=lex();
if (s3.type == SymbolType.IN) {
if (inFunction) {
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(objIdent,i);
innerExprReg=i;
break;
}
}
}
collection=expression(registerVars,inFunction,inMethod,true,variables);
forin=true;
}
 else {
lexer.pushback(s3);
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
forFirstCommands.add((command(registerVars,inFunction,inMethod,forinlevel,true,variables)));
forExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
ret=new ForInActionItem(null,null,pushConst(objIdent),collection,forBody);
}
 else {
ret=new ForItem(null,null,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,null,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
ret=new BreakItem(null,0);
break;
case CONTINUE:
ret=new ContinueItem(null,0);
break;
case RETURN:
GraphTargetItem retexpr=expression(true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
retexpr=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
}
ret=new ReturnActionItem(null,retexpr);
break;
case TRY:
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=null;
List<GraphTargetItem> catchExceptions=new ArrayList<>();
if (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING);
catchExceptions.add(pushConst((String)s.value));
expectedType(SymbolType.PARENT_CLOSE);
catchCommands=new ArrayList<>();
List<GraphTargetItem> cc=new ArrayList<>();
cc.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
catchCommands.add(cc);
s=lex();
found=true;
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
ret=new TryActionItem(tryCommands,catchExceptions,catchCommands,finallyCommands);
break;
case THROW:
ret=new ThrowActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return null;
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
if (ret == null && (!mustBeCommand)) {
buf.pushAllBack(lexer);
}
lexer.removeListener(buf);
return ret;
}","private GraphTargetItem command(HashMap<String,Integer> registerVars,boolean inFunction,boolean inMethod,int forinlevel,boolean mustBeCommand,List<VariableActionItem> variables) throws IOException, ParseException {
  LexBufferer buf=new LexBufferer();
  lexer.addListener(buf);
  GraphTargetItem ret=null;
  if (debugMode) {
    System.out.println(""String_Node_Str"");
  }
  ParsedSymbol s=lex();
  if (s.type == SymbolType.EOF) {
    return null;
  }
switch (s.type) {
case CALL:
    expectedType(SymbolType.PARENT_OPEN);
  ret=new CallActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case LENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new StringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case MBLENGTH:
expectedType(SymbolType.PARENT_OPEN);
ret=new MBStringLengthActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case SET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem name1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem value1=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new SetVariableActionItem(null,name1,value1);
break;
case WITH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem wvar=(variable(registerVars,inFunction,inMethod,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> wcmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new WithActionItem(null,wvar,wcmd);
break;
case DELETE:
GraphTargetItem varDel=variable(registerVars,inFunction,inMethod,variables);
if (varDel instanceof GetMemberActionItem) {
GetMemberActionItem gm=(GetMemberActionItem)varDel;
ret=new DeleteActionItem(null,gm.object,gm.memberName);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case TRACE:
expectedType(SymbolType.PARENT_OPEN);
ret=new TraceActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case GETURL:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int getuMethod=1;
GraphTargetItem target=null;
if (s.type == SymbolType.COMMA) {
target=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
getuMethod=1;
}
 else if (s.value.equals(""String_Node_Str"")) {
getuMethod=2;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
target=new DirectValueActionItem(null,0,""String_Node_Str"",new ArrayList<String>());
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new GetURL2ActionItem(null,url,target,getuMethod);
break;
case GOTOANDSTOP:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtsFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtsFrame,false,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case NEXTFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new NextFrameActionItem(null);
break;
case PLAY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PlayActionItem(null);
break;
case PREVFRAME:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new PrevFrameActionItem(null);
break;
case TELLTARGET:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem tellTarget=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> tellcmds=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new TellTargetActionItem(null,tellTarget,tellcmds);
break;
case STOP:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopActionItem(null);
break;
case STOPALLSOUNDS:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopAllSoundsActionItem(null);
break;
case TOGGLEHIGHQUALITY:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new ToggleHighQualityActionItem(null);
break;
case STOPDRAG:
expectedType(SymbolType.PARENT_OPEN);
expectedType(SymbolType.PARENT_CLOSE);
ret=new StopDragActionItem(null);
break;
case UNLOADMOVIE:
case UNLOADMOVIENUM:
SymbolType unloadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem unTargetOrNum=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
if (unloadType == SymbolType.UNLOADMOVIE) {
ret=new UnLoadMovieActionItem(null,unTargetOrNum);
}
if (unloadType == SymbolType.UNLOADMOVIENUM) {
ret=new UnLoadMovieNumActionItem(null,unTargetOrNum);
}
break;
case PRINT:
case PRINTASBITMAP:
case PRINTASBITMAPNUM:
case PRINTNUM:
SymbolType printType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem printTarget=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem printBBox=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
switch (printType) {
case PRINT:
ret=new PrintActionItem(null,printTarget,printBBox);
break;
case PRINTNUM:
ret=new PrintNumActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAP:
ret=new PrintAsBitmapActionItem(null,printTarget,printBBox);
break;
case PRINTASBITMAPNUM:
ret=new PrintAsBitmapNumActionItem(null,printTarget,printBBox);
break;
}
break;
case LOADVARIABLES:
case LOADMOVIE:
case LOADVARIABLESNUM:
case LOADMOVIENUM:
SymbolType loadType=s.type;
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem url2=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.COMMA);
GraphTargetItem targetOrNum=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
expected(s,lexer.yyline(),SymbolType.PARENT_CLOSE,SymbolType.COMMA);
int lvmethod=1;
if (s.type == SymbolType.COMMA) {
s=lex();
expected(s,lexer.yyline(),SymbolType.STRING);
if (s.value.equals(""String_Node_Str"")) {
lvmethod=2;
}
 else if (s.value.equals(""String_Node_Str"")) {
lvmethod=1;
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 else {
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
switch (loadType) {
case LOADVARIABLES:
ret=new LoadVariablesActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIE:
ret=new LoadMovieActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADVARIABLESNUM:
ret=new LoadVariablesNumActionItem(null,url2,targetOrNum,lvmethod);
break;
case LOADMOVIENUM:
ret=new LoadMovieNumActionItem(null,url2,targetOrNum,lvmethod);
break;
}
break;
case GOTOANDPLAY:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
s=lex();
if (s.type == SymbolType.COMMA) {
s=lex();
gtpFrame=expression(registerVars,inFunction,inMethod,true,variables);
}
 else {
lexer.pushback(s);
}
ret=new GotoFrame2ActionItem(null,gtpFrame,true,false,0);
expectedType(SymbolType.PARENT_CLOSE);
break;
case REMOVEMOVIECLIP:
expectedType(SymbolType.PARENT_OPEN);
ret=new RemoveSpriteActionItem(null,(expression(registerVars,inFunction,inMethod,true,variables)));
expectedType(SymbolType.PARENT_CLOSE);
break;
case STARTDRAG:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem dragTarget=(expression(registerVars,inFunction,inMethod,true,variables));
GraphTargetItem lockCenter=null;
GraphTargetItem constrain=null;
GraphTargetItem x1=null;
GraphTargetItem y1=null;
GraphTargetItem x2=null;
GraphTargetItem y2=null;
s=lex();
if (s.type == SymbolType.COMMA) {
lockCenter=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
constrain=new DirectValueActionItem(null,0,Boolean.TRUE,new ArrayList<String>());
x1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y1=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
x2=(expression(registerVars,inFunction,inMethod,true,variables));
s=lex();
if (s.type == SymbolType.COMMA) {
y2=(expression(registerVars,inFunction,inMethod,true,variables));
}
 else {
lexer.pushback(s);
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
x2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y2=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
y1=new DirectValueActionItem(null,0,(Long)0L,new ArrayList<String>());
}
}
 else {
lexer.pushback(s);
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
}
}
 else {
lockCenter=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
constrain=new DirectValueActionItem(null,0,Boolean.FALSE,new ArrayList<String>());
lexer.pushback(s);
}
expectedType(SymbolType.PARENT_CLOSE);
ret=new StartDragActionItem(null,dragTarget,lockCenter,constrain,x1,y1,x2,y2);
break;
case IFFRAMELOADED:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem iflExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
List<GraphTargetItem> iflComs=commands(registerVars,inFunction,inMethod,forinlevel,variables);
expectedType(SymbolType.CURLY_CLOSE);
ret=new IfFrameLoadedActionItem(iflExpr,iflComs,null);
break;
case CLASS:
GraphTargetItem classTypeStr=type(variables);
s=lex();
GraphTargetItem extendsTypeStr=null;
if (s.type == SymbolType.EXTENDS) {
extendsTypeStr=type(variables);
s=lex();
}
List<GraphTargetItem> implementsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.IMPLEMENTS) {
do {
GraphTargetItem implementsTypeStr=type(variables);
implementsTypeStrs.add(implementsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(false,classTypeStr,extendsTypeStr,implementsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INTERFACE:
GraphTargetItem interfaceTypeStr=type(variables);
s=lex();
List<GraphTargetItem> intExtendsTypeStrs=new ArrayList<>();
if (s.type == SymbolType.EXTENDS) {
do {
GraphTargetItem intExtendsTypeStr=type(variables);
intExtendsTypeStrs.add(intExtendsTypeStr);
s=lex();
}
 while (s.type == SymbolType.COMMA);
}
expected(s,lexer.yyline(),SymbolType.CURLY_OPEN);
ret=(traits(true,interfaceTypeStr,null,intExtendsTypeStrs,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case FUNCTION:
s=lexer.lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
ret=(function(true,s.value.toString(),false,variables));
break;
case NEW:
GraphTargetItem type=type(variables);
expectedType(SymbolType.PARENT_OPEN);
if (type instanceof GetMemberActionItem) {
GetMemberActionItem mem=(GetMemberActionItem)type;
ret=new NewMethodActionItem(null,mem.object,mem.memberName,call(registerVars,inFunction,inMethod,variables));
}
 else if (type instanceof VariableActionItem) {
VariableActionItem var=(VariableActionItem)type;
ret=new NewObjectActionItem(null,var,call(registerVars,inFunction,inMethod,variables));
}
 else {
ret=new NewObjectActionItem(null,ret,call(registerVars,inFunction,inMethod,variables));
}
break;
case VAR:
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER);
String varIdentifier=s.value.toString();
s=lex();
if (s.type == SymbolType.COLON) {
type(variables);
s=lex();
}
if (s.type == SymbolType.ASSIGN) {
if (!inFunction) {
}
GraphTargetItem varval=(expression(registerVars,inFunction,inMethod,true,variables));
ret=new VariableActionItem(varIdentifier,varval,true);
variables.add((VariableActionItem)ret);
}
 else {
ret=new VariableActionItem(varIdentifier,null,true);
variables.add((VariableActionItem)ret);
lexer.pushback(s);
}
break;
case CURLY_OPEN:
ret=new BlockItem(null,commands(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.CURLY_CLOSE);
break;
case INCREMENT:
case DECREMENT:
GraphTargetItem varincdec=variable(registerVars,inFunction,inMethod,variables);
if (s.type == SymbolType.INCREMENT) {
ret=new PreIncrementActionItem(null,varincdec);
}
 else if (s.type == SymbolType.DECREMENT) {
ret=new PreDecrementActionItem(null,varincdec);
}
break;
case IDENTIFIER:
case THIS:
case SUPER:
case PARENT_OPEN:
case EVAL:
ParsedSymbol varS=s;
boolean isEval=false;
GraphTargetItem var;
if (s.type == SymbolType.PARENT_OPEN) {
var=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
memberOrCall(var,registerVars,inFunction,inMethod,variables);
}
 else if (s.type == SymbolType.EVAL) {
expectedType(SymbolType.PARENT_OPEN);
var=expression(registerVars,inFunction,inMethod,true,variables);
var=new EvalActionItem(null,var);
expectedType(SymbolType.PARENT_CLOSE);
var=memberOrCall(var,registerVars,inFunction,inMethod,variables);
isEval=true;
}
 else {
lexer.pushback(s);
var=variable(registerVars,inFunction,inMethod,variables);
}
s=lex();
switch (s.type) {
case ASSIGN:
ret=var;
ret=Action.gettoset(ret,expression(registerVars,inFunction,inMethod,true,variables),variables);
break;
case ASSIGN_BITAND:
case ASSIGN_BITOR:
case ASSIGN_DIVIDE:
case ASSIGN_MINUS:
case ASSIGN_MODULO:
case ASSIGN_MULTIPLY:
case ASSIGN_PLUS:
case ASSIGN_SHIFT_LEFT:
case ASSIGN_SHIFT_RIGHT:
case ASSIGN_USHIFT_RIGHT:
case ASSIGN_XOR:
GraphTargetItem valtoappend=(expression(registerVars,inFunction,inMethod,true,variables));
switch (s.type) {
case ASSIGN_BITAND:
ret=Action.gettoset(var,new BitAndActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_BITOR:
ret=Action.gettoset(var,new BitOrActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_DIVIDE:
ret=Action.gettoset(var,new DivideActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MINUS:
ret=Action.gettoset(var,new SubtractActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MODULO:
ret=Action.gettoset(var,new ModuloActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_MULTIPLY:
ret=Action.gettoset(var,new MultiplyActionItem(null,var,valtoappend),variables);
break;
case ASSIGN_PLUS:
ret=Action.gettoset(var,new AddActionItem(null,var,valtoappend,true),variables);
break;
}
break;
case INCREMENT:
ret=new PostIncrementActionItem(null,var);
break;
case DECREMENT:
ret=new PostDecrementActionItem(null,var);
break;
case PARENT_OPEN:
ret=var;
if (varS.type == SymbolType.SUPER || varS.type == SymbolType.THIS && (var instanceof VariableActionItem)) {
List<GraphTargetItem> args=call(registerVars,inFunction,inMethod,variables);
ret=new CallMethodActionItem(null,ret,new DirectValueActionItem(null,0,new Undefined(),constantPool),args);
}
 else {
lexer.pushback(s);
ret=memberOrCall(ret,registerVars,inFunction,inMethod,variables);
}
break;
default :
if (isEval) {
ret=var;
}
 else {
if (mustBeCommand) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
break;
case IF:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem ifExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.PARENT_CLOSE);
GraphTargetItem onTrue=command(registerVars,inFunction,inMethod,forinlevel,true,variables);
List<GraphTargetItem> onTrueList=new ArrayList<>();
onTrueList.add(onTrue);
s=lex();
List<GraphTargetItem> onFalseList=null;
if (s.type == SymbolType.ELSE) {
onFalseList=new ArrayList<>();
onFalseList.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
 else {
lexer.pushback(s);
}
ret=new IfItem(null,ifExpr,onTrueList,onFalseList);
break;
case WHILE:
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> whileExpr=new ArrayList<>();
whileExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> whileBody=new ArrayList<>();
whileBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
ret=new WhileItem(null,null,whileExpr,whileBody);
break;
case DO:
List<GraphTargetItem> doBody=new ArrayList<>();
doBody.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
expectedType(SymbolType.WHILE);
expectedType(SymbolType.PARENT_OPEN);
List<GraphTargetItem> doExpr=new ArrayList<>();
doExpr.add(commaExpression(registerVars,inFunction,inMethod,forinlevel,variables));
expectedType(SymbolType.PARENT_CLOSE);
ret=new DoWhileItem(null,null,doBody,doExpr);
break;
case FOR:
expectedType(SymbolType.PARENT_OPEN);
s=lex();
boolean forin=false;
GraphTargetItem collection=null;
String objIdent=null;
int innerExprReg=0;
if (s.type == SymbolType.VAR || s.type == SymbolType.IDENTIFIER) {
ParsedSymbol s2=null;
ParsedSymbol ssel=s;
if (s.type == SymbolType.VAR) {
s2=lex();
ssel=s2;
}
if (ssel.type == SymbolType.IDENTIFIER) {
objIdent=ssel.value.toString();
ParsedSymbol s3=lex();
if (s3.type == SymbolType.IN) {
if (inFunction) {
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(objIdent,i);
innerExprReg=i;
break;
}
}
}
collection=expression(registerVars,inFunction,inMethod,true,variables);
forin=true;
}
 else {
lexer.pushback(s3);
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
if (s2 != null) {
lexer.pushback(s2);
}
lexer.pushback(s);
}
}
 else {
lexer.pushback(s);
}
List<GraphTargetItem> forFinalCommands=new ArrayList<>();
GraphTargetItem forExpr=null;
List<GraphTargetItem> forFirstCommands=new ArrayList<>();
if (!forin) {
forFirstCommands.add((command(registerVars,inFunction,inMethod,forinlevel,true,variables)));
forExpr=(expression(registerVars,inFunction,inMethod,true,variables));
expectedType(SymbolType.SEMICOLON);
forFinalCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
}
expectedType(SymbolType.PARENT_CLOSE);
List<GraphTargetItem> forBody=new ArrayList<>();
forBody.add(command(registerVars,inFunction,inMethod,forin ? forinlevel + 1 : forinlevel,true,variables));
if (forin) {
ret=new ForInActionItem(null,null,pushConst(objIdent),collection,forBody);
}
 else {
ret=new ForItem(null,null,forFirstCommands,forExpr,forFinalCommands,forBody);
}
break;
case SWITCH:
expectedType(SymbolType.PARENT_OPEN);
GraphTargetItem switchExpr=expression(registerVars,inFunction,inMethod,true,variables);
expectedType(SymbolType.PARENT_CLOSE);
expectedType(SymbolType.CURLY_OPEN);
s=lex();
int exprReg=0;
for (int i=0; i < 256; i++) {
if (!registerVars.containsValue(i)) {
registerVars.put(""String_Node_Str"" + uniqId(),i);
exprReg=i;
break;
}
}
List<List<ActionIf>> caseIfs=new ArrayList<>();
List<List<GraphTargetItem>> caseCmds=new ArrayList<>();
List<GraphTargetItem> caseExprsAll=new ArrayList<>();
List<Integer> valueMapping=new ArrayList<>();
int pos=0;
while (s.type == SymbolType.CASE) {
List<GraphTargetItem> caseExprs=new ArrayList<>();
while (s.type == SymbolType.CASE) {
GraphTargetItem curCaseExpr=expression(registerVars,inFunction,inMethod,true,variables);
caseExprs.add(curCaseExpr);
expectedType(SymbolType.COLON);
s=lex();
caseExprsAll.add(curCaseExpr);
valueMapping.add(pos);
}
pos++;
lexer.pushback(s);
List<GraphTargetItem> caseCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
caseCmds.add(caseCmd);
s=lex();
}
List<GraphTargetItem> defCmd=new ArrayList<>();
if (s.type == SymbolType.DEFAULT) {
expectedType(SymbolType.COLON);
defCmd=commands(registerVars,inFunction,inMethod,forinlevel,variables);
s=lexer.lex();
}
expected(s,lexer.yyline(),SymbolType.CURLY_CLOSE);
ret=new SwitchItem(null,null,switchExpr,caseExprsAll,caseCmds,defCmd,valueMapping);
break;
case BREAK:
ret=new BreakItem(null,0);
break;
case CONTINUE:
ret=new ContinueItem(null,0);
break;
case RETURN:
GraphTargetItem retexpr=expression(true,registerVars,inFunction,inMethod,true,variables);
if (retexpr == null) {
retexpr=new DirectValueActionItem(null,0,new Undefined(),new ArrayList<String>());
}
ret=new ReturnActionItem(null,retexpr);
break;
case TRY:
List<GraphTargetItem> tryCommands=new ArrayList<>();
tryCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
s=lex();
boolean found=false;
List<List<GraphTargetItem>> catchCommands=null;
List<GraphTargetItem> catchExceptions=new ArrayList<>();
if (s.type == SymbolType.CATCH) {
expectedType(SymbolType.PARENT_OPEN);
s=lex();
expected(s,lexer.yyline(),SymbolType.IDENTIFIER,SymbolType.STRING);
catchExceptions.add(pushConst((String)s.value));
expectedType(SymbolType.PARENT_CLOSE);
catchCommands=new ArrayList<>();
List<GraphTargetItem> cc=new ArrayList<>();
cc.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
catchCommands.add(cc);
s=lex();
found=true;
}
List<GraphTargetItem> finallyCommands=null;
if (s.type == SymbolType.FINALLY) {
finallyCommands=new ArrayList<>();
finallyCommands.add(command(registerVars,inFunction,inMethod,forinlevel,true,variables));
found=true;
s=lex();
}
if (!found) {
expected(s,lexer.yyline(),SymbolType.CATCH,SymbolType.FINALLY);
}
lexer.pushback(s);
ret=new TryActionItem(tryCommands,catchExceptions,catchCommands,finallyCommands);
break;
case THROW:
ret=new ThrowActionItem(null,expression(registerVars,inFunction,inMethod,true,variables));
break;
default :
GraphTargetItem valcmd=expressionCommands(s,registerVars,inFunction,inMethod,forinlevel,variables);
if (valcmd != null) {
ret=valcmd;
break;
}
if (s.type != SymbolType.SEMICOLON) {
lexer.pushback(s);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
return null;
}
s=lex();
if ((s != null) && (s.type != SymbolType.SEMICOLON)) {
lexer.pushback(s);
}
if (debugMode) {
System.out.println(""String_Node_Str"");
}
if (ret == null && (!mustBeCommand)) {
buf.pushAllBack(lexer);
}
lexer.removeListener(buf);
return ret;
}",0.99913204103888
61886,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public DefineFont2Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  fontFlagsHasLayout=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsWideOffsets=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int fontNameLen=sis.readUI8();
  fontName=new String(sis.readBytesEx(fontNameLen));
  numGlyphs=sis.readUI16();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  if (numGlyphs > 0) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  glyphShapeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphShapeTable.add(sis.readSHAPE(1));
  }
  codeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
  if (fontFlagsHasLayout) {
    fontAscent=sis.readSI16();
    fontDescent=sis.readSI16();
    fontLeading=sis.readSI16();
    fontAdvanceTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontAdvanceTable.add(sis.readSI16());
    }
    fontBoundsTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontBoundsTable.add(sis.readRECT());
    }
    int kerningCount=sis.readUI16();
    fontKerningTable=new KERNINGRECORD[kerningCount];
    for (int i=0; i < kerningCount; i++) {
      fontKerningTable[i]=sis.readKERNINGRECORD(fontFlagsWideCodes);
    }
  }
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public DefineFont2Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  fontFlagsHasLayout=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsWideOffsets=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int fontNameLen=sis.readUI8();
  if (version >= 6) {
    fontName=new String(sis.readBytesEx(fontNameLen),Utf8Helper.charset);
  }
 else {
    fontName=new String(sis.readBytesEx(fontNameLen));
  }
  numGlyphs=sis.readUI16();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  if (numGlyphs > 0) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  glyphShapeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphShapeTable.add(sis.readSHAPE(1));
  }
  codeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
  if (fontFlagsHasLayout) {
    fontAscent=sis.readSI16();
    fontDescent=sis.readSI16();
    fontLeading=sis.readSI16();
    fontAdvanceTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontAdvanceTable.add(sis.readSI16());
    }
    fontBoundsTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontBoundsTable.add(sis.readRECT());
    }
    int kerningCount=sis.readUI16();
    fontKerningTable=new KERNINGRECORD[kerningCount];
    for (int i=0; i < kerningCount; i++) {
      fontKerningTable[i]=sis.readKERNINGRECORD(fontFlagsWideCodes);
    }
  }
}",0.9713870029097964
61887,"public DefineFont3Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  fontFlagsHasLayout=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsWideOffsets=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int fontNameLen=sis.readUI8();
  fontName=new String(sis.readBytesEx(fontNameLen));
  numGlyphs=sis.readUI16();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  if (numGlyphs > 0) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  glyphShapeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphShapeTable.add(sis.readSHAPE(1));
  }
  codeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
  if (fontFlagsHasLayout) {
    fontAscent=sis.readSI16();
    fontDescent=sis.readSI16();
    fontLeading=sis.readSI16();
    fontAdvanceTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontAdvanceTable.add(sis.readSI16());
    }
    fontBoundsTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontBoundsTable.add(sis.readRECT());
    }
    int kerningCount=sis.readUI16();
    fontKerningTable=new KERNINGRECORD[kerningCount];
    for (int i=0; i < kerningCount; i++) {
      fontKerningTable[i]=sis.readKERNINGRECORD(fontFlagsWideCodes);
    }
  }
}","public DefineFont3Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  fontFlagsHasLayout=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsWideOffsets=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int fontNameLen=sis.readUI8();
  if (version >= 6) {
    fontName=new String(sis.readBytesEx(fontNameLen),Utf8Helper.charset);
  }
 else {
    fontName=new String(sis.readBytesEx(fontNameLen));
  }
  numGlyphs=sis.readUI16();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  if (numGlyphs > 0) {
    if (fontFlagsWideOffsets) {
      sis.readUI32();
    }
 else {
      sis.readUI16();
    }
  }
  glyphShapeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    glyphShapeTable.add(sis.readSHAPE(1));
  }
  codeTable=new ArrayList<>();
  for (int i=0; i < numGlyphs; i++) {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
  if (fontFlagsHasLayout) {
    fontAscent=sis.readSI16();
    fontDescent=sis.readSI16();
    fontLeading=sis.readSI16();
    fontAdvanceTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontAdvanceTable.add(sis.readSI16());
    }
    fontBoundsTable=new ArrayList<>();
    for (int i=0; i < numGlyphs; i++) {
      fontBoundsTable.add(sis.readRECT());
    }
    int kerningCount=sis.readUI16();
    fontKerningTable=new KERNINGRECORD[kerningCount];
    for (int i=0; i < kerningCount; i++) {
      fontKerningTable[i]=sis.readKERNINGRECORD(fontFlagsWideCodes);
    }
  }
}",0.9694458829621958
61888,"/** 
 * Constructor
 * @param data Data bytes
 * @param version SWF version
 * @throws IOException
 */
public DefineFontInfo2Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontID=sis.readUI16();
  int fontNameLen=sis.readUI8();
  fontName=new String(sis.readBytesEx(fontNameLen));
  sis.readUB(2);
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int ctLen=sis.available() / 2;
  codeTable=new ArrayList<>();
  for (int i=0; i < ctLen; i++) {
    codeTable.add(sis.readUI16());
  }
}","/** 
 * Constructor
 * @param data Data bytes
 * @param version SWF version
 * @throws IOException
 */
public DefineFontInfo2Tag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontID=sis.readUI16();
  int fontNameLen=sis.readUI8();
  if (version >= 6) {
    fontName=new String(sis.readBytesEx(fontNameLen),Utf8Helper.charset);
  }
 else {
    fontName=new String(sis.readBytesEx(fontNameLen));
  }
  sis.readUB(2);
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  languageCode=sis.readLANGCODE();
  int ctLen=sis.available() / 2;
  codeTable=new ArrayList<>();
  for (int i=0; i < ctLen; i++) {
    codeTable.add(sis.readUI16());
  }
}",0.9349503858875412
61889,"/** 
 * Constructor
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public DefineFontInfoTag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  int fontNameLen=sis.readUI8();
  fontName=new String(sis.readBytesEx(fontNameLen));
  sis.readUB(2);
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  codeTable=new ArrayList<>();
  do {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
 while (sis.available() > 0);
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public DefineFontInfoTag(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  fontId=sis.readUI16();
  int fontNameLen=sis.readUI8();
  if (version >= 6) {
    fontName=new String(sis.readBytesEx(fontNameLen),Utf8Helper.charset);
  }
 else {
    fontName=new String(sis.readBytesEx(fontNameLen));
  }
  sis.readUB(2);
  fontFlagsSmallText=sis.readUB(1) == 1;
  fontFlagsShiftJIS=sis.readUB(1) == 1;
  fontFlagsANSI=sis.readUB(1) == 1;
  fontFlagsItalic=sis.readUB(1) == 1;
  fontFlagsBold=sis.readUB(1) == 1;
  fontFlagsWideCodes=sis.readUB(1) == 1;
  codeTable=new ArrayList<>();
  do {
    if (fontFlagsWideCodes) {
      codeTable.add(sis.readUI16());
    }
 else {
      codeTable.add(sis.readUI8());
    }
  }
 while (sis.available() > 0);
}",0.9305263157894736
61890,"@Override public void run() throws IOException {
  ImageIO.write(((ImageTag)t).getImage(ttags),((ImageTag)t).getImageFormat().toUpperCase(Locale.ENGLISH),file);
}","@Override public void run() throws IOException {
  ImageIO.write(((ImageTag)t).getImage(ttags).getBufferedImage(),((ImageTag)t).getImageFormat().toUpperCase(Locale.ENGLISH),file);
}",0.9446064139941692
61891,"public static void framesToImage(int containerId,List<BufferedImage> ret,int startFrame,int stopFrame,List<Tag> allTags,List<Tag> controlTags,RECT displayRect,int totalFrameCount,Stack<Integer> visited){
  for (int i=startFrame; i <= stopFrame; i++) {
    String key=""String_Node_Str"" + i + ""String_Node_Str""+ containerId;
    if (frameCache.contains(key)) {
      BufferedImage g=(BufferedImage)frameCache.get(key);
      if (g == null) {
        break;
      }
      ret.add(g);
      startFrame++;
    }
 else {
      break;
    }
  }
  if (startFrame > stopFrame) {
    return;
  }
  if (totalFrameCount == 0) {
    return;
  }
  while (startFrame >= totalFrameCount) {
    startFrame-=totalFrameCount;
  }
  while (stopFrame >= totalFrameCount) {
    stopFrame-=totalFrameCount;
  }
  HashMap<Integer,CharacterTag> characters=new HashMap<>();
  for (  Tag t : allTags) {
    if (t instanceof CharacterTag) {
      CharacterTag ch=(CharacterTag)t;
      characters.put(ch.getCharacterId(),ch);
    }
  }
  HashMap<Integer,Layer> layers=new HashMap<>();
  int maxDepth=0;
  int f=0;
  Color backgroundColor=new Color(0,0,0,0);
  for (  Tag t : controlTags) {
    if (t instanceof SetBackgroundColorTag) {
      SetBackgroundColorTag c=(SetBackgroundColorTag)t;
      backgroundColor=new Color(c.backgroundColor.red,c.backgroundColor.green,c.backgroundColor.blue);
    }
    if (t instanceof PlaceObjectTypeTag) {
      PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
      int depth=po.getDepth();
      if (depth > maxDepth) {
        maxDepth=depth;
      }
      if (!layers.containsKey(depth)) {
        layers.put(depth,new Layer());
      }
      Layer layer=layers.get(depth);
      int characterId=po.getCharacterId();
      if (characterId != -1) {
        layer.characterId=characterId;
      }
      layer.visible=po.isVisible();
      if (po.flagMove()) {
        MATRIX matrix2=po.getMatrix();
        if (matrix2 != null) {
          layer.matrix=matrix2;
        }
        String instanceName=po.getInstanceName();
        if (instanceName != null) {
          layer.instanceName=instanceName;
        }
        CXFORM colorTransForm=po.getColorTransform();
        if (colorTransForm != null) {
          layer.colorTransForm=colorTransForm;
        }
        CXFORMWITHALPHA colorTransFormAlpha=po.getColorTransformWithAlpha();
        if (colorTransFormAlpha != null) {
          layer.colorTransFormAlpha=colorTransFormAlpha;
        }
        if (po.cacheAsBitmap()) {
          layer.cacheAsBitmap=true;
        }
        int blendMode=po.getBlendMode();
        if (blendMode != 0) {
          layer.blendMode=blendMode;
        }
        List<FILTER> filters=po.getFilters();
        if (filters != null) {
          layer.filters=filters;
        }
        int ratio=po.getRatio();
        if (ratio != -1) {
          layer.ratio=ratio;
        }
      }
 else {
        layer.matrix=po.getMatrix();
        layer.instanceName=po.getInstanceName();
        layer.colorTransForm=po.getColorTransform();
        layer.colorTransFormAlpha=po.getColorTransformWithAlpha();
        layer.cacheAsBitmap=po.cacheAsBitmap();
        layer.blendMode=po.getBlendMode();
        layer.filters=po.getFilters();
        layer.ratio=po.getRatio();
      }
    }
    if (t instanceof RemoveTag) {
      RemoveTag rt=(RemoveTag)t;
      layers.remove(rt.getDepth());
    }
    for (    Layer l : layers.values()) {
      l.duration++;
    }
    if (t instanceof ShowFrameTag) {
      if (f > stopFrame) {
        break;
      }
      if ((f >= startFrame) && (f <= stopFrame)) {
        ret.add(frameToImage(containerId,maxDepth,layers,backgroundColor,characters,f,allTags,controlTags,displayRect,visited));
      }
      f++;
    }
  }
}","public static void framesToImage(int containerId,List<SerializableImage> ret,int startFrame,int stopFrame,List<Tag> allTags,List<Tag> controlTags,RECT displayRect,int totalFrameCount,Stack<Integer> visited){
  for (int i=startFrame; i <= stopFrame; i++) {
    String key=""String_Node_Str"" + i + ""String_Node_Str""+ containerId;
    if (frameCache.contains(key)) {
      SerializableImage g=(SerializableImage)frameCache.get(key);
      if (g == null) {
        break;
      }
      ret.add(g);
      startFrame++;
    }
 else {
      break;
    }
  }
  if (startFrame > stopFrame) {
    return;
  }
  if (totalFrameCount == 0) {
    return;
  }
  while (startFrame >= totalFrameCount) {
    startFrame-=totalFrameCount;
  }
  while (stopFrame >= totalFrameCount) {
    stopFrame-=totalFrameCount;
  }
  HashMap<Integer,CharacterTag> characters=new HashMap<>();
  for (  Tag t : allTags) {
    if (t instanceof CharacterTag) {
      CharacterTag ch=(CharacterTag)t;
      characters.put(ch.getCharacterId(),ch);
    }
  }
  HashMap<Integer,Layer> layers=new HashMap<>();
  int maxDepth=0;
  int f=0;
  Color backgroundColor=new Color(0,0,0,0);
  for (  Tag t : controlTags) {
    if (t instanceof SetBackgroundColorTag) {
      SetBackgroundColorTag c=(SetBackgroundColorTag)t;
      backgroundColor=new Color(c.backgroundColor.red,c.backgroundColor.green,c.backgroundColor.blue);
    }
    if (t instanceof PlaceObjectTypeTag) {
      PlaceObjectTypeTag po=(PlaceObjectTypeTag)t;
      int depth=po.getDepth();
      if (depth > maxDepth) {
        maxDepth=depth;
      }
      if (!layers.containsKey(depth)) {
        layers.put(depth,new Layer());
      }
      Layer layer=layers.get(depth);
      int characterId=po.getCharacterId();
      if (characterId != -1) {
        layer.characterId=characterId;
      }
      layer.visible=po.isVisible();
      if (po.flagMove()) {
        MATRIX matrix2=po.getMatrix();
        if (matrix2 != null) {
          layer.matrix=matrix2;
        }
        String instanceName=po.getInstanceName();
        if (instanceName != null) {
          layer.instanceName=instanceName;
        }
        CXFORM colorTransForm=po.getColorTransform();
        if (colorTransForm != null) {
          layer.colorTransForm=colorTransForm;
        }
        CXFORMWITHALPHA colorTransFormAlpha=po.getColorTransformWithAlpha();
        if (colorTransFormAlpha != null) {
          layer.colorTransFormAlpha=colorTransFormAlpha;
        }
        if (po.cacheAsBitmap()) {
          layer.cacheAsBitmap=true;
        }
        int blendMode=po.getBlendMode();
        if (blendMode != 0) {
          layer.blendMode=blendMode;
        }
        List<FILTER> filters=po.getFilters();
        if (filters != null) {
          layer.filters=filters;
        }
        int ratio=po.getRatio();
        if (ratio != -1) {
          layer.ratio=ratio;
        }
      }
 else {
        layer.matrix=po.getMatrix();
        layer.instanceName=po.getInstanceName();
        layer.colorTransForm=po.getColorTransform();
        layer.colorTransFormAlpha=po.getColorTransformWithAlpha();
        layer.cacheAsBitmap=po.cacheAsBitmap();
        layer.blendMode=po.getBlendMode();
        layer.filters=po.getFilters();
        layer.ratio=po.getRatio();
      }
    }
    if (t instanceof RemoveTag) {
      RemoveTag rt=(RemoveTag)t;
      layers.remove(rt.getDepth());
    }
    for (    Layer l : layers.values()) {
      l.duration++;
    }
    if (t instanceof ShowFrameTag) {
      if (f > stopFrame) {
        break;
      }
      if ((f >= startFrame) && (f <= stopFrame)) {
        ret.add(frameToImage(containerId,maxDepth,layers,backgroundColor,characters,f,allTags,controlTags,displayRect,visited));
      }
      f++;
    }
  }
}",0.9920063948840928
61892,"public static BufferedImage frameToImage(int containerId,int frame,List<Tag> allTags,List<Tag> controlTags,RECT displayRect,int totalFrameCount,Stack<Integer> visited){
  List<BufferedImage> ret=new ArrayList<>();
  framesToImage(containerId,ret,frame,frame,allTags,controlTags,displayRect,totalFrameCount,visited);
  if (ret.isEmpty()) {
    return new BufferedImage(1,1,BufferedImage.TYPE_INT_ARGB);
  }
  return ret.get(0);
}","public static SerializableImage frameToImage(int containerId,int frame,List<Tag> allTags,List<Tag> controlTags,RECT displayRect,int totalFrameCount,Stack<Integer> visited){
  List<SerializableImage> ret=new ArrayList<>();
  framesToImage(containerId,ret,frame,frame,allTags,controlTags,displayRect,totalFrameCount,visited);
  if (ret.isEmpty()) {
    return new SerializableImage(1,1,SerializableImage.TYPE_INT_ARGB);
  }
  return ret.get(0);
}",0.908256880733945
61893,"protected void finalizePath(){
  final int maxRepeat=10;
  if (path != null) {
    if (fillPaint != null) {
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        graphics.fill(new java.awt.Rectangle(-16384 * maxRepeat,-16384 * maxRepeat,16384 * 2 * maxRepeat,16384 * 2 * maxRepeat));
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        graphics.fill(new java.awt.Rectangle(-16384 * maxRepeat,-16384 * maxRepeat,16384 * 2 * maxRepeat,16384 * 2 * maxRepeat));
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath();
}","protected void finalizePath(){
  final int maxRepeat=10;
  if (path != null) {
    if (fillPaint != null) {
      if (fillPaint instanceof MultipleGradientPaint) {
        AffineTransform oldAf=graphics.getTransform();
        if (fillPathPaint != null) {
          graphics.setPaint(fillPathPaint);
        }
        graphics.fill(path);
        graphics.setClip(path);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        graphics.fill(new java.awt.Rectangle(-16384 * maxRepeat,-16384 * maxRepeat,16384 * 2 * maxRepeat,16384 * 2 * maxRepeat));
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else       if (fillPaint instanceof TexturePaint) {
        AffineTransform oldAf=graphics.getTransform();
        graphics.setClip(path);
        graphics.setTransform(fillTransform);
        graphics.setPaint(fillPaint);
        graphics.fill(new java.awt.Rectangle(-16384 * maxRepeat,-16384 * maxRepeat,16384 * 2 * maxRepeat,16384 * 2 * maxRepeat));
        graphics.setTransform(oldAf);
        graphics.setClip(null);
      }
 else {
        graphics.setPaint(fillPaint);
        graphics.fill(path);
      }
    }
    if (lineColor != null) {
      graphics.setColor(lineColor);
      graphics.setStroke(lineStroke == null ? defaultStroke : lineStroke);
      graphics.draw(path);
    }
  }
  path=new GeneralPath();
  lineStroke=null;
  lineColor=null;
  fillPaint=null;
}",0.9805722359590252
61894,"@Override public void beginBitmapFill(int bitmapId,Matrix matrix,boolean repeat,boolean smooth){
  finalizePath();
  ImageTag image=null;
  for (  Tag t : swf.tags) {
    if (t instanceof ImageTag) {
      ImageTag i=(ImageTag)t;
      if (i.getCharacterId() == bitmapId) {
        image=i;
        break;
      }
    }
  }
  if (image != null) {
    BufferedImage img=image.getImage(swf.tags);
    if (img != null) {
      fillPaint=new TexturePaint(img,new java.awt.Rectangle(img.getWidth(),img.getHeight()));
      matrix.translateX-=xMin;
      matrix.translateY-=yMin;
      fillTransform=matrixToTransform(matrix);
    }
  }
}","@Override public void beginBitmapFill(int bitmapId,Matrix matrix,boolean repeat,boolean smooth){
  finalizePath();
  ImageTag image=null;
  for (  Tag t : swf.tags) {
    if (t instanceof ImageTag) {
      ImageTag i=(ImageTag)t;
      if (i.getCharacterId() == bitmapId) {
        image=i;
        break;
      }
    }
  }
  if (image != null) {
    SerializableImage img=image.getImage(swf.tags);
    if (img != null) {
      fillPaint=new TexturePaint(img.getBufferedImage(),new java.awt.Rectangle(img.getWidth(),img.getHeight()));
      matrix.translateX-=deltaX;
      matrix.translateY-=deltaY;
      fillTransform=matrix.toTransform();
    }
  }
}",0.80248833592535
61895,"@Override public void curveTo(double controlX,double controlY,double anchorX,double anchorY){
  path.quadTo(controlX - xMin,controlY - yMin,anchorX - xMin,anchorY - yMin);
}","@Override public void curveTo(double controlX,double controlY,double anchorX,double anchorY){
  path.quadTo(controlX - deltaX,controlY - deltaY,anchorX - deltaX,anchorY - deltaY);
}",0.8870056497175142
61896,"@Override public void beginGradientFill(int type,GRADRECORD[] gradientRecords,Matrix matrix,int spreadMethod,int interpolationMethod,float focalPointRatio){
  finalizePath();
switch (type) {
case FILLSTYLE.LINEAR_GRADIENT:
{
      List<Color> colors=new ArrayList<>();
      List<Float> ratios=new ArrayList<>();
      for (int i=0; i < gradientRecords.length; i++) {
        if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
          continue;
        }
        ratios.add(gradientRecords[i].getRatioFloat());
        colors.add(gradientRecords[i].color.toColor());
      }
      float[] ratiosArr=new float[ratios.size()];
      for (int i=0; i < ratios.size(); i++) {
        ratiosArr[i]=ratios.get(i);
      }
      Color[] colorsArr=colors.toArray(new Color[colors.size()]);
      MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
      if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
        cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
      }
 else       if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
        cm=MultipleGradientPaint.CycleMethod.REFLECT;
      }
 else       if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
        cm=MultipleGradientPaint.CycleMethod.REPEAT;
      }
      fillPathPaint=null;
      fillPaint=new LinearGradientPaint(new java.awt.Point(-16384,0),new java.awt.Point(16384,0),ratiosArr,colorsArr,cm);
      fillTransform=matrixToTransform(matrix);
    }
  break;
case FILLSTYLE.RADIAL_GRADIENT:
{
  List<Color> colors=new ArrayList<>();
  List<Float> ratios=new ArrayList<>();
  for (int i=0; i < gradientRecords.length; i++) {
    if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
      continue;
    }
    ratios.add(gradientRecords[i].getRatioFloat());
    colors.add(gradientRecords[i].color.toColor());
  }
  float[] ratiosArr=new float[ratios.size()];
  for (int i=0; i < ratios.size(); i++) {
    ratiosArr[i]=ratios.get(i);
  }
  Color[] colorsArr=colors.toArray(new Color[colors.size()]);
  MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
  if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
    cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
  }
 else   if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
    cm=MultipleGradientPaint.CycleMethod.REFLECT;
  }
 else   if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
    cm=MultipleGradientPaint.CycleMethod.REPEAT;
  }
  Color endColor=gradientRecords[gradientRecords.length - 1].color.toColor();
  fillPathPaint=endColor;
  fillPaint=new RadialGradientPaint(new java.awt.Point(0,0),16384,ratiosArr,colorsArr,cm);
  fillTransform=matrixToTransform(matrix);
}
break;
case FILLSTYLE.FOCAL_RADIAL_GRADIENT:
{
List<Color> colors=new ArrayList<>();
List<Float> ratios=new ArrayList<>();
for (int i=0; i < gradientRecords.length; i++) {
if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
  continue;
}
ratios.add(gradientRecords[i].getRatioFloat());
colors.add(gradientRecords[i].color.toColor());
}
float[] ratiosArr=new float[ratios.size()];
for (int i=0; i < ratios.size(); i++) {
ratiosArr[i]=ratios.get(i);
}
Color[] colorsArr=colors.toArray(new Color[colors.size()]);
MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
}
 else if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
cm=MultipleGradientPaint.CycleMethod.REFLECT;
}
 else if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
cm=MultipleGradientPaint.CycleMethod.REPEAT;
}
Color endColor=gradientRecords[gradientRecords.length - 1].color.toColor();
fillPathPaint=endColor;
fillPaint=new RadialGradientPaint(new java.awt.Point(0,0),16384,new java.awt.Point((int)(focalPointRatio * 16384),0),ratiosArr,colorsArr,cm);
fillTransform=matrixToTransform(matrix);
}
break;
}
}","@Override public void beginGradientFill(int type,GRADRECORD[] gradientRecords,Matrix matrix,int spreadMethod,int interpolationMethod,float focalPointRatio){
  finalizePath();
switch (type) {
case FILLSTYLE.LINEAR_GRADIENT:
{
      List<Color> colors=new ArrayList<>();
      List<Float> ratios=new ArrayList<>();
      for (int i=0; i < gradientRecords.length; i++) {
        if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
          continue;
        }
        ratios.add(gradientRecords[i].getRatioFloat());
        colors.add(gradientRecords[i].color.toColor());
      }
      float[] ratiosArr=new float[ratios.size()];
      for (int i=0; i < ratios.size(); i++) {
        ratiosArr[i]=ratios.get(i);
      }
      Color[] colorsArr=colors.toArray(new Color[colors.size()]);
      MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
      if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
        cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
      }
 else       if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
        cm=MultipleGradientPaint.CycleMethod.REFLECT;
      }
 else       if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
        cm=MultipleGradientPaint.CycleMethod.REPEAT;
      }
      fillPathPaint=null;
      fillPaint=new LinearGradientPaint(new java.awt.Point(-16384,0),new java.awt.Point(16384,0),ratiosArr,colorsArr,cm);
      matrix.translateX-=deltaX;
      matrix.translateY-=deltaY;
      fillTransform=matrix.toTransform();
    }
  break;
case FILLSTYLE.RADIAL_GRADIENT:
{
  List<Color> colors=new ArrayList<>();
  List<Float> ratios=new ArrayList<>();
  for (int i=0; i < gradientRecords.length; i++) {
    if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
      continue;
    }
    ratios.add(gradientRecords[i].getRatioFloat());
    colors.add(gradientRecords[i].color.toColor());
  }
  float[] ratiosArr=new float[ratios.size()];
  for (int i=0; i < ratios.size(); i++) {
    ratiosArr[i]=ratios.get(i);
  }
  Color[] colorsArr=colors.toArray(new Color[colors.size()]);
  MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
  if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
    cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
  }
 else   if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
    cm=MultipleGradientPaint.CycleMethod.REFLECT;
  }
 else   if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
    cm=MultipleGradientPaint.CycleMethod.REPEAT;
  }
  Color endColor=gradientRecords[gradientRecords.length - 1].color.toColor();
  fillPathPaint=endColor;
  fillPaint=new RadialGradientPaint(new java.awt.Point(0,0),16384,ratiosArr,colorsArr,cm);
  matrix.translateX-=deltaX;
  matrix.translateY-=deltaY;
  fillTransform=matrix.toTransform();
}
break;
case FILLSTYLE.FOCAL_RADIAL_GRADIENT:
{
List<Color> colors=new ArrayList<>();
List<Float> ratios=new ArrayList<>();
for (int i=0; i < gradientRecords.length; i++) {
if ((i > 0) && (gradientRecords[i - 1].ratio == gradientRecords[i].ratio)) {
  continue;
}
ratios.add(gradientRecords[i].getRatioFloat());
colors.add(gradientRecords[i].color.toColor());
}
float[] ratiosArr=new float[ratios.size()];
for (int i=0; i < ratios.size(); i++) {
ratiosArr[i]=ratios.get(i);
}
Color[] colorsArr=colors.toArray(new Color[colors.size()]);
MultipleGradientPaint.CycleMethod cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
if (spreadMethod == GRADIENT.SPREAD_PAD_MODE) {
cm=MultipleGradientPaint.CycleMethod.NO_CYCLE;
}
 else if (spreadMethod == GRADIENT.SPREAD_REFLECT_MODE) {
cm=MultipleGradientPaint.CycleMethod.REFLECT;
}
 else if (spreadMethod == GRADIENT.SPREAD_REPEAT_MODE) {
cm=MultipleGradientPaint.CycleMethod.REPEAT;
}
Color endColor=gradientRecords[gradientRecords.length - 1].color.toColor();
fillPathPaint=endColor;
fillPaint=new RadialGradientPaint(new java.awt.Point(0,0),16384,new java.awt.Point((int)(focalPointRatio * 16384),0),ratiosArr,colorsArr,cm);
matrix.translateX-=deltaX;
matrix.translateY-=deltaY;
fillTransform=matrix.toTransform();
}
break;
}
}",0.9735489532405668
61897,"@Override public void lineTo(double x,double y){
  path.lineTo(x - xMin,y - yMin);
}","@Override public void lineTo(double x,double y){
  path.lineTo(x - deltaX,y - deltaY);
}",0.8837209302325582
61898,"@Override public void export(){
  List<SHAPERECORD> records=shape.shapeRecords;
  String key=""String_Node_Str"" + records.hashCode() + ""String_Node_Str""+ (defaultColor == null ? ""String_Node_Str"" : defaultColor.hashCode());
  if (cache.contains(key)) {
    image=(BufferedImage)cache.get(key);
    return;
  }
  RECT bounds=SHAPERECORD.getBounds(records);
  int maxLineWidthTwips=0;
  if (shape instanceof SHAPEWITHSTYLE) {
    SHAPEWITHSTYLE shapeWithStyle=(SHAPEWITHSTYLE)shape;
    for (    LINESTYLE lineStyle : shapeWithStyle.lineStyles.lineStyles) {
      if (lineStyle.width > maxLineWidthTwips) {
        maxLineWidthTwips=lineStyle.width;
      }
    }
  }
  double maxLineWidth=maxLineWidthTwips / unitDivisor / 2;
  xMin=bounds.Xmin / unitDivisor - maxLineWidth;
  yMin=bounds.Ymin / unitDivisor - maxLineWidth;
  image=new BufferedImage((int)(bounds.getWidth() / unitDivisor + 2 + maxLineWidth),(int)(bounds.getHeight() / unitDivisor + 2 + maxLineWidth),BufferedImage.TYPE_INT_ARGB);
  graphics=(Graphics2D)image.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
  graphics.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  defaultStroke=graphics.getStroke();
  super.export();
  if (putToCache) {
    cache.put(key,image);
  }
}","@Override public void export(){
  List<SHAPERECORD> records=shape.shapeRecords;
  String key=""String_Node_Str"" + records.hashCode() + ""String_Node_Str""+ (defaultColor == null ? ""String_Node_Str"" : defaultColor.hashCode());
  if (cache.contains(key)) {
    image=(SerializableImage)cache.get(key);
    deltaX=(double)cacheDeltaX.get(key);
    deltaY=(double)cacheDeltaY.get(key);
    return;
  }
  RECT bounds=SHAPERECORD.getBounds(records);
  int maxLineWidthTwips=0;
  if (shape instanceof SHAPEWITHSTYLE) {
    SHAPEWITHSTYLE shapeWithStyle=(SHAPEWITHSTYLE)shape;
    for (    LINESTYLE lineStyle : shapeWithStyle.lineStyles.lineStyles) {
      if (lineStyle.width > maxLineWidthTwips) {
        maxLineWidthTwips=lineStyle.width;
      }
    }
  }
  double maxLineWidth=maxLineWidthTwips / unitDivisor / 2;
  deltaX=bounds.Xmin / unitDivisor - maxLineWidth;
  deltaY=bounds.Ymin / unitDivisor - maxLineWidth;
  image=new SerializableImage((int)(bounds.getWidth() / unitDivisor + 2 + maxLineWidth),(int)(bounds.getHeight() / unitDivisor + 2 + maxLineWidth),SerializableImage.TYPE_INT_ARGB);
  graphics=(Graphics2D)image.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
  graphics.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  defaultStroke=graphics.getStroke();
  super.export();
  try {
    ImageIO.write(image.getBufferedImage(),""String_Node_Str"",new File(""String_Node_Str"" + imageid++ + ""String_Node_Str""));
  }
 catch (  IOException ex) {
    Logger.getLogger(BitmapExporter.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (putToCache) {
    cache.put(key,image);
    cacheDeltaX.put(key,deltaX);
    cacheDeltaY.put(key,deltaY);
  }
}",0.8420733555622916
61899,"public BufferedImage getImage(){
  return image;
}","public SerializableImage getImage(){
  return image;
}",0.8653846153846154
61900,"@Override public void moveTo(double x,double y){
  path.moveTo(x - xMin,y - yMin);
}","@Override public void moveTo(double x,double y){
  path.moveTo(x - deltaX,y - deltaY);
}",0.8837209302325582
61901,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,List<Tag> tags,String text) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(text));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(String)s.values[0];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(tags,c)) {
if (!missingCharHandler.handle(font,tags,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(tags,nextChar)) {
if (!missingCharHandler.handle(font,tags,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(tags,c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tags,tr.glyphEntries[i].glyphIndex,font.charToGlyph(tags,nextChar));
}
advance=(int)Math.round(20.0 * Math.round((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(20.0 * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),textHeight / 20,c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,List<Tag> tags,String text) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(text));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGBA colorA=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
    if (paramName.equals(""String_Node_Str"")) {
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
      if (m.matches()) {
        colorA=new RGBA(Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16),Integer.parseInt(m.group(4),16),Integer.parseInt(m.group(1),16));
      }
 else {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
switch (paramName) {
case ""String_Node_Str"":
    try {
      fontId=Integer.parseInt(paramValue);
      for (      Tag t : tags) {
        if (t instanceof FontTag) {
          if (((FontTag)t).getFontId() == fontId) {
            font=(FontTag)t;
            fontName=font.getSystemFontName();
            break;
          }
        }
      }
      if (font == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
    }
 catch (    NumberFormatException nfe) {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (colorA != null) {
tr.textColorA=colorA;
tr.styleFlagsHasColor=true;
colorA=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(String)s.values[0];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(tags,c)) {
if (!missingCharHandler.handle(font,tags,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(tags,nextChar)) {
if (!missingCharHandler.handle(font,tags,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(tags,c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tags,tr.glyphEntries[i].glyphIndex,font.charToGlyph(tags,nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(20.0 * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),textHeight / 20,c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textRecords=textRecords;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9983254923849773
61902,"@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,List<Tag> tags,String text) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(text));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(String)s.values[0];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(tags,c)) {
if (!missingCharHandler.handle(font,tags,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(tags,nextChar)) {
if (!missingCharHandler.handle(font,tags,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(tags,c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tags,tr.glyphEntries[i].glyphIndex,font.charToGlyph(tags,nextChar));
}
advance=(int)Math.round(20.0 * Math.round((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(20.0 * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),textHeight / 20,c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}","@Override public boolean setFormattedText(MissingCharacterHandler missingCharHandler,List<Tag> tags,String text) throws ParseException {
  List<TEXTRECORD> oldTextRecords=textRecords;
  try {
    TextLexer lexer=new TextLexer(new StringReader(text));
    ParsedSymbol s=null;
    textRecords=new ArrayList<>();
    RGB color=null;
    int fontId=-1;
    int textHeight=-1;
    FontTag font=null;
    String fontName=null;
    Integer x=null;
    Integer y=null;
    int currentX=0;
    int currentY=0;
    int maxX=Integer.MIN_VALUE;
    int minX=Integer.MAX_VALUE;
    MATRIX textMatrix=new MATRIX();
    textMatrix.hasRotate=false;
    textMatrix.hasScale=false;
    RECT textBounds=new RECT();
    while ((s=lexer.yylex()) != null) {
switch (s.type) {
case PARAMETER:
        String paramName=(String)s.values[0];
      String paramValue=(String)s.values[1];
switch (paramName) {
case ""String_Node_Str"":
      Matcher m=Pattern.compile(""String_Node_Str"").matcher(paramValue);
    if (m.matches()) {
      color=new RGB(Integer.parseInt(m.group(1),16),Integer.parseInt(m.group(2),16),Integer.parseInt(m.group(3),16));
    }
 else {
      throw new ParseException(""String_Node_Str"",lexer.yyline());
    }
  break;
case ""String_Node_Str"":
try {
  fontId=Integer.parseInt(paramValue);
  for (  Tag t : tags) {
    if (t instanceof FontTag) {
      if (((FontTag)t).getFontId() == fontId) {
        font=(FontTag)t;
        fontName=font.getSystemFontName();
        break;
      }
    }
  }
  if (font == null) {
    throw new ParseException(""String_Node_Str"",lexer.yyline());
  }
}
 catch (NumberFormatException nfe) {
  throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textHeight=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
x=Integer.parseInt(paramValue);
currentX=x;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
y=Integer.parseInt(paramValue);
currentY=y;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Xmax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymin=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textBounds.Ymax=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleX=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.scaleY=Integer.parseInt(paramValue);
textMatrix.hasScale=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew0=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.rotateSkew1=Integer.parseInt(paramValue);
textMatrix.hasRotate=true;
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateX=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case ""String_Node_Str"":
try {
textMatrix.translateY=Integer.parseInt(paramValue);
}
 catch (NumberFormatException nfe) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
break;
case TEXT:
if (font == null) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
TEXTRECORD tr=new TEXTRECORD();
textRecords.add(tr);
if (fontId > -1) {
tr.fontId=fontId;
tr.textHeight=textHeight;
fontId=-1;
tr.styleFlagsHasFont=true;
}
if (color != null) {
tr.textColor=color;
tr.styleFlagsHasColor=true;
color=null;
}
if (x != null) {
tr.xOffset=x;
tr.styleFlagsHasXOffset=true;
x=null;
}
if (y != null) {
tr.yOffset=y;
tr.styleFlagsHasYOffset=true;
y=null;
}
String txt=(String)s.values[0];
tr.glyphEntries=new GLYPHENTRY[txt.length()];
for (int i=0; i < txt.length(); i++) {
char c=txt.charAt(i);
Character nextChar=null;
if (i + 1 < txt.length()) {
nextChar=txt.charAt(i + 1);
}
if (!font.containsChar(tags,c)) {
if (!missingCharHandler.handle(font,tags,c)) {
return false;
}
}
if (nextChar != null && !font.containsChar(tags,nextChar)) {
if (!missingCharHandler.handle(font,tags,nextChar)) {
return false;
}
}
tr.glyphEntries[i]=new GLYPHENTRY();
tr.glyphEntries[i].glyphIndex=font.charToGlyph(tags,c);
int advance;
if (font.hasLayout()) {
int kerningAdjustment=0;
if (nextChar != null) {
kerningAdjustment=font.getGlyphKerningAdjustment(tags,tr.glyphEntries[i].glyphIndex,font.charToGlyph(tags,nextChar));
}
advance=(int)Math.round(font.getDivider() * Math.round((double)textHeight * (font.getGlyphAdvance(tr.glyphEntries[i].glyphIndex) + kerningAdjustment) / (font.getDivider() * 1024.0)));
}
 else {
advance=(int)Math.round(20.0 * FontTag.getSystemFontAdvance(fontName,font.getFontStyle(),textHeight / 20,c,nextChar));
}
tr.glyphEntries[i].glyphAdvance=advance;
currentX+=advance;
}
if (currentX > maxX) {
maxX=currentX;
}
if (currentX < minX) {
minX=currentX;
}
break;
}
}
this.textMatrix=textMatrix;
this.textBounds=textBounds;
}
 catch (IOException ex) {
textRecords=oldTextRecords;
return false;
}
catch (ParseException ex) {
textRecords=oldTextRecords;
throw ex;
}
return true;
}",0.9982833319708984
61903,"public List<File> exportSelection(AbortRetryIgnoreHandler handler,String selFile,ExportDialog export) throws IOException {
  final ExportMode exportMode=ExportMode.get(export.getOption(ExportDialog.OPTION_ACTIONSCRIPT));
  final boolean isMp3OrWav=export.getOption(ExportDialog.OPTION_SOUNDS) == 0;
  final boolean isFormatted=export.getOption(ExportDialog.OPTION_TEXTS) == 1;
  List<File> ret=new ArrayList<>();
  List<TreeNode> sel=getAllSelected(tagTree);
  for (  SWF swf : swfs) {
    List<ScriptPack> tlsList=new ArrayList<>();
    List<Tag> images=new ArrayList<>();
    List<Tag> shapes=new ArrayList<>();
    List<Tag> movies=new ArrayList<>();
    List<Tag> sounds=new ArrayList<>();
    List<Tag> texts=new ArrayList<>();
    List<TreeNode> actionNodes=new ArrayList<>();
    List<Tag> binaryData=new ArrayList<>();
    for (    TreeNode d : sel) {
      if (d.getItem().getSwf() != swf) {
        continue;
      }
      if (d instanceof TagNode) {
        TagNode n=(TagNode)d;
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.IMAGE) {
          images.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.SHAPE) {
          shapes.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.AS) {
          actionNodes.add(n);
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.MOVIE) {
          movies.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.SOUND) {
          sounds.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.BINARY_DATA) {
          binaryData.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.TEXT) {
          texts.add((Tag)n.getItem());
        }
      }
      if (d instanceof TreeElement) {
        if (((TreeElement)d).isLeaf()) {
          TreeElement treeElement=(TreeElement)d;
          tlsList.add((ScriptPack)treeElement.getItem());
        }
      }
    }
    ret.addAll(swf.exportImages(handler,selFile + File.separator + ""String_Node_Str"",images));
    ret.addAll(SWF.exportShapes(handler,selFile + File.separator + ""String_Node_Str"",shapes));
    ret.addAll(swf.exportTexts(handler,selFile + File.separator + ""String_Node_Str"",texts,isFormatted));
    ret.addAll(swf.exportMovies(handler,selFile + File.separator + ""String_Node_Str"",movies));
    ret.addAll(swf.exportSounds(handler,selFile + File.separator + ""String_Node_Str"",sounds,isMp3OrWav,isMp3OrWav));
    ret.addAll(SWF.exportBinaryData(handler,selFile + File.separator + ""String_Node_Str"",binaryData));
    List<ABCContainerTag> abcList=swf.abcList;
    if (abcPanel != null) {
      for (int i=0; i < tlsList.size(); i++) {
        ScriptPack tls=tlsList.get(i);
        Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str""+ tlsList.size()+ ""String_Node_Str""+ tls.getPath()+ ""String_Node_Str"");
        ret.add(tls.export(selFile,abcList,exportMode,Configuration.parallelSpeedUp.get()));
      }
    }
 else {
      List<TreeNode> allNodes=new ArrayList<>();
      List<TreeNode> asNodes=getASTagNode(tagTree);
      for (      TreeNode asn : asNodes) {
        allNodes.add(asn);
        TagNode.setExport(allNodes,false);
        TagNode.setExport(actionNodes,true);
        ret.addAll(TagNode.exportNodeAS(handler,allNodes,selFile,exportMode,null));
      }
    }
  }
  return ret;
}","public List<File> exportSelection(AbortRetryIgnoreHandler handler,String selFile,ExportDialog export) throws IOException {
  final ExportMode exportMode=ExportMode.get(export.getOption(ExportDialog.OPTION_ACTIONSCRIPT));
  final boolean isMp3OrWav=export.getOption(ExportDialog.OPTION_SOUNDS) == 0;
  final boolean isFormatted=export.getOption(ExportDialog.OPTION_TEXTS) == 1;
  List<File> ret=new ArrayList<>();
  List<TreeNode> sel=getAllSelected(tagTree);
  for (  SWF swf : swfs) {
    List<ScriptPack> tlsList=new ArrayList<>();
    List<Tag> images=new ArrayList<>();
    List<Tag> shapes=new ArrayList<>();
    List<Tag> movies=new ArrayList<>();
    List<Tag> sounds=new ArrayList<>();
    List<Tag> texts=new ArrayList<>();
    List<TreeNode> actionNodes=new ArrayList<>();
    List<Tag> binaryData=new ArrayList<>();
    for (    TreeNode d : sel) {
      if (d.getItem().getSwf() != swf) {
        continue;
      }
      if (d instanceof ContainerNode) {
        ContainerNode n=(ContainerNode)d;
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.IMAGE) {
          images.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.SHAPE) {
          shapes.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.AS) {
          actionNodes.add(n);
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.MOVIE) {
          movies.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.SOUND) {
          sounds.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.BINARY_DATA) {
          binaryData.add((Tag)n.getItem());
        }
        if (TagTree.getTreeNodeType(n.getItem()) == TreeNodeType.TEXT) {
          texts.add((Tag)n.getItem());
        }
      }
      if (d instanceof TreeElement) {
        if (((TreeElement)d).isLeaf()) {
          TreeElement treeElement=(TreeElement)d;
          tlsList.add((ScriptPack)treeElement.getItem());
        }
      }
    }
    ret.addAll(swf.exportImages(handler,selFile + File.separator + ""String_Node_Str"",images));
    ret.addAll(SWF.exportShapes(handler,selFile + File.separator + ""String_Node_Str"",shapes));
    ret.addAll(swf.exportTexts(handler,selFile + File.separator + ""String_Node_Str"",texts,isFormatted));
    ret.addAll(swf.exportMovies(handler,selFile + File.separator + ""String_Node_Str"",movies));
    ret.addAll(swf.exportSounds(handler,selFile + File.separator + ""String_Node_Str"",sounds,isMp3OrWav,isMp3OrWav));
    ret.addAll(SWF.exportBinaryData(handler,selFile + File.separator + ""String_Node_Str"",binaryData));
    List<ABCContainerTag> abcList=swf.abcList;
    if (abcPanel != null) {
      for (int i=0; i < tlsList.size(); i++) {
        ScriptPack tls=tlsList.get(i);
        Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str""+ tlsList.size()+ ""String_Node_Str""+ tls.getPath()+ ""String_Node_Str"");
        ret.add(tls.export(selFile,abcList,exportMode,Configuration.parallelSpeedUp.get()));
      }
    }
 else {
      List<TreeNode> allNodes=new ArrayList<>();
      List<TreeNode> asNodes=getASTagNode(tagTree);
      for (      TreeNode asn : asNodes) {
        allNodes.add(asn);
        TagNode.setExport(allNodes,false);
        TagNode.setExport(actionNodes,true);
        ret.addAll(TagNode.exportNodeAS(handler,allNodes,selFile,exportMode,null));
      }
    }
  }
  return ret;
}",0.9926052332195676
61904,"/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param mis
 * @param version
 * @param ip
 * @param endIp
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,MemoryInputStream mis,int version,int ip,int endIp,String path) throws IOException, InterruptedException {
  boolean deobfuscate=Configuration.autoDeobfuscate.get();
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(mis,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  Action lastAction=actions.get(actions.size() - 1);
  Action aEnd=new ActionEnd();
  if (!(lastAction instanceof ActionEnd)) {
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
  }
 else {
    endAddress-=getTotalActionLength(aEnd);
  }
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  if (deobfuscate) {
    try {
      actions=deobfuscateActionList(listeners,containerSWFOffset,actions,version,ip,path);
      updateActionLengths(actions,version);
      removeZeroJumps(actions,version);
    }
 catch (    TranslateException ex) {
      Logger.getLogger(ActionListReader.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  return actions;
}","/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param mis
 * @param version
 * @param ip
 * @param endIp
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,MemoryInputStream mis,int version,int ip,int endIp,String path) throws IOException, InterruptedException {
  boolean deobfuscate=Configuration.autoDeobfuscate.get();
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(mis,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  Action lastAction=actions.get(actions.size() - 1);
  Action aEnd=new ActionEnd();
  if (!(lastAction instanceof ActionEnd)) {
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
  }
 else {
    endAddress-=getTotalActionLength(aEnd);
  }
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  if (deobfuscate) {
    try {
      actions=deobfuscateActionList(listeners,containerSWFOffset,actions,version,ip,path);
      updateActionLengths(actions,version);
      removeZeroJumps(actions,version);
    }
 catch (    OutOfMemoryError|StackOverflowError|TranslateException ex) {
      Logger.getLogger(ActionListReader.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  return actions;
}",0.9938671209540034
61905,"public void setScript(ScriptPack scriptLeaf,List<ABCContainerTag> abcList){
  abcPanel.scriptNameLabel.setText(scriptLeaf.getPath().toString());
  int scriptIndex=scriptLeaf.scriptIndex;
  ScriptInfo script=null;
  ABC abc=scriptLeaf.abc;
  if (scriptIndex > -1) {
    script=abc.script_info[scriptIndex];
  }
  if (script == null) {
    highlights=new ArrayList<>();
    specialHighlights=new ArrayList<>();
    traitHighlights=new ArrayList<>();
    methodHighlights=new ArrayList<>();
    this.script=scriptLeaf;
    return;
  }
  setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  this.abc=abc;
  this.abcList=abcList;
  this.script=scriptLeaf;
  CachedDecompilation cd=null;
  try {
    cacheScriptPack(scriptLeaf,abcList);
    cd=getCached(scriptLeaf);
  }
 catch (  InterruptedException ex) {
  }
  if (cd != null) {
    final String hilightedCode=cd.text;
    highlights=cd.getInstructionHighlights();
    specialHighlights=cd.getSpecialHighligths();
    traitHighlights=cd.getTraitHighlights();
    methodHighlights=cd.getMethodHighlights();
    classHighlights=cd.getClassHighlights();
    if (hilightedCode.length() > 1024 * 1024 * 2) {
      setContentType(""String_Node_Str"");
    }
 else {
      setContentType(""String_Node_Str"");
    }
    setText(hilightedCode);
  }
}","public void setScript(ScriptPack scriptLeaf,List<ABCContainerTag> abcList){
  abcPanel.scriptNameLabel.setText(scriptLeaf.getPath().toString());
  int scriptIndex=scriptLeaf.scriptIndex;
  ScriptInfo script=null;
  ABC abc=scriptLeaf.abc;
  if (scriptIndex > -1) {
    script=abc.script_info[scriptIndex];
  }
  if (script == null) {
    highlights=new ArrayList<>();
    specialHighlights=new ArrayList<>();
    traitHighlights=new ArrayList<>();
    methodHighlights=new ArrayList<>();
    this.script=scriptLeaf;
    return;
  }
  setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  this.abc=abc;
  this.abcList=abcList;
  this.script=scriptLeaf;
  CachedDecompilation cd=null;
  try {
    cacheScriptPack(scriptLeaf,abcList);
    cd=getCached(scriptLeaf);
  }
 catch (  InterruptedException ex) {
  }
  if (cd != null) {
    final String hilightedCode=cd.text;
    highlights=cd.getInstructionHighlights();
    specialHighlights=cd.getSpecialHighligths();
    traitHighlights=cd.getTraitHighlights();
    methodHighlights=cd.getMethodHighlights();
    classHighlights=cd.getClassHighlights();
    setContentType(""String_Node_Str"");
    setText(hilightedCode);
  }
}",0.9340702724042638
61906,"@Override public void setText(String t){
  lastLine=-1;
  super.setText(t);
}","@Override public void setText(String t,String contentType){
  lastLine=-1;
  super.setText(t,contentType);
}",0.8324324324324325
61907,"@Override public void setText(String t){
  super.setText(t);
  clearUndos();
}","public void setText(String t,String contentType){
  if (getText() != t) {
    super.setText(null);
    if (t.length() > Configuration.syntaxHighlightLimit.get()) {
      setContentType(""String_Node_Str"");
    }
 else {
      if (!getContentType().equals(contentType)) {
        setContentType(contentType);
      }
    }
    super.setText(t);
    clearUndos();
  }
}",0.081081081081081
61908,"public void setSource(final ASMSource src,final boolean useCache){
  if (setSourceWorker != null) {
    setSourceWorker.cancel(true);
  }
  this.src=src;
  final ASMSource asm=(ASMSource)src;
  CancellableWorker worker=new CancellableWorker(){
    @Override protected Void doInBackground() throws Exception {
      editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      if (Configuration.decompile.get()) {
        decompiledEditor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      }
      DisassemblyListener listener=getDisassemblyListener();
      asm.addDisassemblyListener(listener);
      List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
      lastCode=actions;
      asm.removeDisassemblyListener(listener);
      srcWithHex=null;
      srcNoHex=null;
      srcHexOnly=null;
      setHex(getExportMode());
      if (Configuration.decompile.get()) {
        decompiledEditor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
        if (!useCache) {
          uncache(asm);
        }
        cacheScript(asm,actions);
        CachedScript sc=getCached(asm);
        decompiledHilights=sc.hilights;
        lastDecompiled=sc.text;
        lastASM=asm;
        decompiledEditor.setText(lastDecompiled);
      }
      setEditMode(false);
      setDecompiledEditMode(false);
      return null;
    }
    @Override protected void done(){
      setSourceWorker=null;
      Main.stopWork();
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          try {
            get();
          }
 catch (          CancellationException ex) {
            editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
          }
catch (          Exception ex) {
            decompiledEditor.setText(""String_Node_Str"" + ex);
          }
        }
      }
);
    }
  }
;
  worker.execute();
  setSourceWorker=worker;
  Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"",worker);
}","public void setSource(final ASMSource src,final boolean useCache){
  if (setSourceWorker != null) {
    setSourceWorker.cancel(true);
  }
  this.src=src;
  final ASMSource asm=(ASMSource)src;
  CancellableWorker worker=new CancellableWorker(){
    @Override protected Void doInBackground() throws Exception {
      setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"");
      if (Configuration.decompile.get()) {
        setDecompiledText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      }
      DisassemblyListener listener=getDisassemblyListener();
      asm.addDisassemblyListener(listener);
      List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
      lastCode=actions;
      asm.removeDisassemblyListener(listener);
      srcWithHex=null;
      srcNoHex=null;
      srcHexOnly=null;
      setHex(getExportMode());
      if (Configuration.decompile.get()) {
        setDecompiledText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
        if (!useCache) {
          uncache(asm);
        }
        cacheScript(asm,actions);
        CachedScript sc=getCached(asm);
        decompiledHilights=sc.hilights;
        lastDecompiled=sc.text;
        lastASM=asm;
        setDecompiledText(lastDecompiled);
      }
      setEditMode(false);
      setDecompiledEditMode(false);
      return null;
    }
    @Override protected void done(){
      setSourceWorker=null;
      Main.stopWork();
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          try {
            get();
          }
 catch (          CancellationException ex) {
            setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""),""String_Node_Str"");
          }
catch (          Exception ex) {
            setDecompiledText(""String_Node_Str"" + ex);
          }
        }
      }
);
    }
  }
;
  worker.execute();
  setSourceWorker=worker;
  Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"",worker);
}",0.8907522759942501
61909,"public void setEditMode(boolean val){
  boolean rawEdit=hexOnlyButton.isSelected();
  if (val) {
    if (rawEdit) {
      editor.setContentType(""String_Node_Str"");
      setText(srcHexOnly);
    }
 else {
      editor.setContentType(""String_Node_Str"");
      setText(srcNoHex);
    }
    editor.setEditable(true);
    saveButton.setVisible(true);
    editButton.setVisible(false);
    cancelButton.setVisible(true);
    editor.getCaret().setVisible(true);
    asmLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    setHex(getExportMode());
    editor.setEditable(false);
    saveButton.setVisible(false);
    editButton.setVisible(true);
    cancelButton.setVisible(false);
    editor.getCaret().setVisible(true);
    asmLabel.setIcon(null);
  }
  topButtonsPan.setVisible(!val);
  editMode=val;
  editor.requestFocusInWindow();
}","public void setEditMode(boolean val){
  boolean rawEdit=hexOnlyButton.isSelected();
  if (val) {
    if (rawEdit) {
      setText(srcHexOnly,""String_Node_Str"");
    }
 else {
      setText(srcNoHex,""String_Node_Str"");
    }
    editor.setEditable(true);
    saveButton.setVisible(true);
    editButton.setVisible(false);
    cancelButton.setVisible(true);
    editor.getCaret().setVisible(true);
    asmLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    setHex(getExportMode());
    editor.setEditable(false);
    saveButton.setVisible(false);
    editButton.setVisible(true);
    cancelButton.setVisible(false);
    editor.getCaret().setVisible(true);
    asmLabel.setIcon(null);
  }
  topButtonsPan.setVisible(!val);
  editMode=val;
  editor.requestFocusInWindow();
}",0.9224137931034484
61910,"@Override protected Void doInBackground() throws Exception {
  editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  if (Configuration.decompile.get()) {
    decompiledEditor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  }
  DisassemblyListener listener=getDisassemblyListener();
  asm.addDisassemblyListener(listener);
  List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
  lastCode=actions;
  asm.removeDisassemblyListener(listener);
  srcWithHex=null;
  srcNoHex=null;
  srcHexOnly=null;
  setHex(getExportMode());
  if (Configuration.decompile.get()) {
    decompiledEditor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
    if (!useCache) {
      uncache(asm);
    }
    cacheScript(asm,actions);
    CachedScript sc=getCached(asm);
    decompiledHilights=sc.hilights;
    lastDecompiled=sc.text;
    lastASM=asm;
    decompiledEditor.setText(lastDecompiled);
  }
  setEditMode(false);
  setDecompiledEditMode(false);
  return null;
}","@Override protected Void doInBackground() throws Exception {
  setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"");
  if (Configuration.decompile.get()) {
    setDecompiledText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  }
  DisassemblyListener listener=getDisassemblyListener();
  asm.addDisassemblyListener(listener);
  List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
  lastCode=actions;
  asm.removeDisassemblyListener(listener);
  srcWithHex=null;
  srcNoHex=null;
  srcHexOnly=null;
  setHex(getExportMode());
  if (Configuration.decompile.get()) {
    setDecompiledText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
    if (!useCache) {
      uncache(asm);
    }
    cacheScript(asm,actions);
    CachedScript sc=getCached(asm);
    decompiledHilights=sc.hilights;
    lastDecompiled=sc.text;
    lastASM=asm;
    setDecompiledText(lastDecompiled);
  }
  setEditMode(false);
  setDecompiledEditMode(false);
  return null;
}",0.862708719851577
61911,"public void setHex(ExportMode exportMode){
  if (exportMode != ExportMode.HEX) {
    editor.setContentType(""String_Node_Str"");
    if (exportMode == ExportMode.PCODE) {
      if (srcNoHex == null) {
        srcNoHex=getHilightedText(exportMode);
      }
      setText(srcNoHex);
    }
 else {
      if (srcWithHex == null) {
        srcWithHex=getHilightedText(exportMode);
      }
      setText(srcWithHex);
    }
  }
 else {
    editor.setContentType(""String_Node_Str"");
    if (srcHexOnly == null) {
      HilightedTextWriter writer=new HilightedTextWriter(true);
      Helper.byteArrayToHexWithHeader(writer,src.getActionBytes());
      srcHexOnly=new HilightedText(writer);
    }
    setText(srcHexOnly);
  }
}","public void setHex(ExportMode exportMode){
  if (exportMode != ExportMode.HEX) {
    if (exportMode == ExportMode.PCODE) {
      if (srcNoHex == null) {
        srcNoHex=getHilightedText(exportMode);
      }
      setText(srcNoHex,""String_Node_Str"");
    }
 else {
      if (srcWithHex == null) {
        srcWithHex=getHilightedText(exportMode);
      }
      setText(srcWithHex,""String_Node_Str"");
    }
  }
 else {
    if (srcHexOnly == null) {
      HilightedTextWriter writer=new HilightedTextWriter(true);
      Helper.byteArrayToHexWithHeader(writer,src.getActionBytes());
      srcHexOnly=new HilightedText(writer);
    }
    setText(srcHexOnly,""String_Node_Str"");
  }
}",0.6954022988505747
61912,"@Override protected void done(){
  setSourceWorker=null;
  Main.stopWork();
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      try {
        get();
      }
 catch (      CancellationException ex) {
        editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
      }
catch (      Exception ex) {
        decompiledEditor.setText(""String_Node_Str"" + ex);
      }
    }
  }
);
}","@Override protected void done(){
  setSourceWorker=null;
  Main.stopWork();
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      try {
        get();
      }
 catch (      CancellationException ex) {
        setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""),""String_Node_Str"");
      }
catch (      Exception ex) {
        setDecompiledText(""String_Node_Str"" + ex);
      }
    }
  }
);
}",0.6032110091743119
61913,"private DisassemblyListener getDisassemblyListener(){
  DisassemblyListener listener=new DisassemblyListener(){
    int percent=0;
    String phase=""String_Node_Str"";
    @Override public void progress(    String phase,    long pos,    long total){
      if (total < 1) {
        return;
      }
      int newpercent=(int)(pos * 100 / total);
      if (((newpercent > percent) || (!this.phase.equals(phase))) && newpercent <= 100) {
        percent=newpercent;
        this.phase=phase;
        editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ phase+ ""String_Node_Str""+ percent+ ""String_Node_Str"");
      }
    }
  }
;
  return listener;
}","private DisassemblyListener getDisassemblyListener(){
  DisassemblyListener listener=new DisassemblyListener(){
    int percent=0;
    String phase=""String_Node_Str"";
    @Override public void progress(    String phase,    long pos,    long total){
      if (total < 1) {
        return;
      }
      int newpercent=(int)(pos * 100 / total);
      if (((newpercent > percent) || (!this.phase.equals(phase))) && newpercent <= 100) {
        percent=newpercent;
        this.phase=phase;
        setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ phase+ ""String_Node_Str""+ percent+ ""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
;
  return listener;
}",0.914326853851692
61914,"@Override public void progress(String phase,long pos,long total){
  if (total < 1) {
    return;
  }
  int newpercent=(int)(pos * 100 / total);
  if (((newpercent > percent) || (!this.phase.equals(phase))) && newpercent <= 100) {
    percent=newpercent;
    this.phase=phase;
    editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ phase+ ""String_Node_Str""+ percent+ ""String_Node_Str"");
  }
}","@Override public void progress(String phase,long pos,long total){
  if (total < 1) {
    return;
  }
  int newpercent=(int)(pos * 100 / total);
  if (((newpercent > percent) || (!this.phase.equals(phase))) && newpercent <= 100) {
    percent=newpercent;
    this.phase=phase;
    setEditorText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""+ phase+ ""String_Node_Str""+ percent+ ""String_Node_Str"",""String_Node_Str"");
  }
}",0.688413948256468
61915,"public void setDecompiledEditMode(boolean val){
  if (lastASM == null) {
    return;
  }
  int lastLine=decompiledEditor.getLine();
  int prefLines=lastASM.getPrefixLineCount();
  if (val) {
    String newText=lastASM.removePrefixAndSuffix(lastDecompiled);
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      if (lastLine - prefLines >= 0) {
        decompiledEditor.gotoLine(lastLine - prefLines + 1);
      }
    }
    decompiledEditor.setEditable(true);
    saveDecompiledButton.setVisible(true);
    editDecompiledButton.setVisible(false);
    experimentalLabel.setVisible(false);
    cancelDecompiledButton.setVisible(true);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    String newText=lastDecompiled;
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      decompiledEditor.gotoLine(lastLine + prefLines + 1);
    }
    decompiledEditor.setEditable(false);
    saveDecompiledButton.setVisible(false);
    editDecompiledButton.setVisible(true);
    experimentalLabel.setVisible(true);
    cancelDecompiledButton.setVisible(false);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(null);
  }
  editDecompiledMode=val;
  decompiledEditor.requestFocusInWindow();
}","public void setDecompiledEditMode(boolean val){
  if (lastASM == null) {
    return;
  }
  int lastLine=decompiledEditor.getLine();
  int prefLines=lastASM.getPrefixLineCount();
  if (val) {
    String newText=lastASM.removePrefixAndSuffix(lastDecompiled);
    setDecompiledText(newText);
    if (lastLine > -1) {
      if (lastLine - prefLines >= 0) {
        decompiledEditor.gotoLine(lastLine - prefLines + 1);
      }
    }
    decompiledEditor.setEditable(true);
    saveDecompiledButton.setVisible(true);
    editDecompiledButton.setVisible(false);
    experimentalLabel.setVisible(false);
    cancelDecompiledButton.setVisible(true);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    String newText=lastDecompiled;
    setDecompiledText(newText);
    if (lastLine > -1) {
      decompiledEditor.gotoLine(lastLine + prefLines + 1);
    }
    decompiledEditor.setEditable(false);
    saveDecompiledButton.setVisible(false);
    editDecompiledButton.setVisible(true);
    experimentalLabel.setVisible(true);
    cancelDecompiledButton.setVisible(false);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(null);
  }
  editDecompiledMode=val;
  decompiledEditor.requestFocusInWindow();
}",0.9743788819875776
61916,"public ActionPanel(MainPanel mainPanel){
  DefaultSyntaxKit.initKit();
  this.mainPanel=mainPanel;
  editor=new LineMarkedEditorPane();
  editor.setEditable(false);
  decompiledEditor=new LineMarkedEditorPane();
  decompiledEditor.setEditable(false);
  searchPanel=new JPanel(new FlowLayout());
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(ACTION_SEARCH_PREV);
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(ACTION_SEARCH_NEXT);
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(ACTION_SEARCH_CANCEL);
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  JButton graphButton=new JButton(View.getIcon(""String_Node_Str""));
  graphButton.setActionCommand(ACTION_GRAPH);
  graphButton.addActionListener(this);
  graphButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  graphButton.setMargin(new Insets(3,3,3,3));
  hexButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexButton.setActionCommand(ACTION_HEX);
  hexButton.addActionListener(this);
  hexButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  hexButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexOnlyButton.setActionCommand(ACTION_HEX_ONLY);
  hexOnlyButton.addActionListener(this);
  hexOnlyButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  hexOnlyButton.setMargin(new Insets(3,3,3,3));
  if (!Configuration.showHexOnlyButton.get()) {
    hexOnlyButton.setVisible(false);
  }
  topButtonsPan=new JPanel();
  topButtonsPan.setLayout(new BoxLayout(topButtonsPan,BoxLayout.X_AXIS));
  topButtonsPan.add(graphButton);
  topButtonsPan.add(hexButton);
  topButtonsPan.add(hexOnlyButton);
  JPanel panCode=new JPanel(new BorderLayout());
  panCode.add(new JScrollPane(editor),BorderLayout.CENTER);
  panCode.add(topButtonsPan,BorderLayout.NORTH);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  asmLabel.setHorizontalAlignment(SwingConstants.CENTER);
  panB.add(asmLabel,BorderLayout.NORTH);
  panB.add(panCode,BorderLayout.CENTER);
  JPanel buttonsPan=new JPanel();
  buttonsPan.setLayout(new FlowLayout());
  buttonsPan.add(editButton);
  buttonsPan.add(saveButton);
  buttonsPan.add(cancelButton);
  editButton.setMargin(new Insets(3,3,3,10));
  saveButton.setMargin(new Insets(3,3,3,10));
  cancelButton.setMargin(new Insets(3,3,3,10));
  JPanel decButtonsPan=new JPanel(new FlowLayout());
  decButtonsPan.add(editDecompiledButton);
  decButtonsPan.add(experimentalLabel);
  decButtonsPan.add(saveDecompiledButton);
  decButtonsPan.add(cancelDecompiledButton);
  editDecompiledButton.setMargin(new Insets(3,3,3,10));
  saveDecompiledButton.setMargin(new Insets(3,3,3,10));
  cancelDecompiledButton.setMargin(new Insets(3,3,3,10));
  panB.add(buttonsPan,BorderLayout.SOUTH);
  saveButton.addActionListener(this);
  saveButton.setActionCommand(ACTION_SAVE_ACTION);
  editButton.addActionListener(this);
  editButton.setActionCommand(ACTION_EDIT_ACTION);
  cancelButton.addActionListener(this);
  cancelButton.setActionCommand(ACTION_CANCEL_ACTION);
  saveButton.setVisible(false);
  cancelButton.setVisible(false);
  saveDecompiledButton.addActionListener(this);
  saveDecompiledButton.setActionCommand(ACTION_SAVE_DECOMPILED);
  editDecompiledButton.addActionListener(this);
  editDecompiledButton.setActionCommand(ACTION_EDIT_DECOMPILED);
  cancelDecompiledButton.addActionListener(this);
  cancelDecompiledButton.setActionCommand(ACTION_CANCEL_DECOMPILED);
  saveDecompiledButton.setVisible(false);
  cancelDecompiledButton.setVisible(false);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(new JScrollPane(decompiledEditor),BorderLayout.CENTER);
  decPanel.add(searchPanel,BorderLayout.NORTH);
  searchPanel.setVisible(false);
  JPanel panA=new JPanel();
  panA.setLayout(new BorderLayout());
  panA.add(decPanel,BorderLayout.CENTER);
  panA.add(decLabel,BorderLayout.NORTH);
  panA.add(decButtonsPan,BorderLayout.SOUTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  setLayout(new BorderLayout());
  add(splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panA,panB),BorderLayout.CENTER);
  splitPane.setResizeWeight(0.5);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.guiActionSplitPaneDividerLocation.set((int)pce.getNewValue());
    }
  }
);
  editor.setContentType(""String_Node_Str"");
  editor.setFont(new Font(""String_Node_Str"",Font.PLAIN,editor.getFont().getSize()));
  decompiledEditor.setContentType(""String_Node_Str"");
  decompiledEditor.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledEditor.getFont().getSize()));
  editor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      editor.getCaret().setVisible(true);
      int pos=editor.getCaretPosition();
      Highlighting lastH=null;
      for (      Highlighting h : disassembledHilights) {
        if (pos < h.startPos) {
          break;
        }
        lastH=h;
      }
      String ofs=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
      Highlighting h2=Highlighting.search(decompiledHilights,""String_Node_Str"",ofs);
      if (h2 != null) {
        ignoreCarret=true;
        decompiledEditor.setCaretPosition(h2.startPos);
        decompiledEditor.getCaret().setVisible(true);
        ignoreCarret=false;
      }
    }
  }
);
  decompiledEditor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      decompiledEditor.getCaret().setVisible(true);
      int pos=decompiledEditor.getCaretPosition();
      Highlighting h=Highlighting.search(decompiledHilights,pos);
      if (h != null) {
        Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
        if (h2 != null) {
          ignoreCarret=true;
          if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
            editor.setCaretPosition(h2.startPos);
          }
          editor.getCaret().setVisible(true);
          ignoreCarret=false;
        }
      }
    }
  }
);
}","public ActionPanel(MainPanel mainPanel){
  DefaultSyntaxKit.initKit();
  this.mainPanel=mainPanel;
  editor=new LineMarkedEditorPane();
  editor.setEditable(false);
  decompiledEditor=new LineMarkedEditorPane();
  decompiledEditor.setEditable(false);
  searchPanel=new JPanel(new FlowLayout());
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(ACTION_SEARCH_PREV);
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(ACTION_SEARCH_NEXT);
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(ACTION_SEARCH_CANCEL);
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  JButton graphButton=new JButton(View.getIcon(""String_Node_Str""));
  graphButton.setActionCommand(ACTION_GRAPH);
  graphButton.addActionListener(this);
  graphButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  graphButton.setMargin(new Insets(3,3,3,3));
  hexButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexButton.setActionCommand(ACTION_HEX);
  hexButton.addActionListener(this);
  hexButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  hexButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexOnlyButton.setActionCommand(ACTION_HEX_ONLY);
  hexOnlyButton.addActionListener(this);
  hexOnlyButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  hexOnlyButton.setMargin(new Insets(3,3,3,3));
  if (!Configuration.showHexOnlyButton.get()) {
    hexOnlyButton.setVisible(false);
  }
  topButtonsPan=new JPanel();
  topButtonsPan.setLayout(new BoxLayout(topButtonsPan,BoxLayout.X_AXIS));
  topButtonsPan.add(graphButton);
  topButtonsPan.add(hexButton);
  topButtonsPan.add(hexOnlyButton);
  JPanel panCode=new JPanel(new BorderLayout());
  panCode.add(new JScrollPane(editor),BorderLayout.CENTER);
  panCode.add(topButtonsPan,BorderLayout.NORTH);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  asmLabel.setHorizontalAlignment(SwingConstants.CENTER);
  panB.add(asmLabel,BorderLayout.NORTH);
  panB.add(panCode,BorderLayout.CENTER);
  JPanel buttonsPan=new JPanel();
  buttonsPan.setLayout(new FlowLayout());
  buttonsPan.add(editButton);
  buttonsPan.add(saveButton);
  buttonsPan.add(cancelButton);
  editButton.setMargin(new Insets(3,3,3,10));
  saveButton.setMargin(new Insets(3,3,3,10));
  cancelButton.setMargin(new Insets(3,3,3,10));
  JPanel decButtonsPan=new JPanel(new FlowLayout());
  decButtonsPan.add(editDecompiledButton);
  decButtonsPan.add(experimentalLabel);
  decButtonsPan.add(saveDecompiledButton);
  decButtonsPan.add(cancelDecompiledButton);
  editDecompiledButton.setMargin(new Insets(3,3,3,10));
  saveDecompiledButton.setMargin(new Insets(3,3,3,10));
  cancelDecompiledButton.setMargin(new Insets(3,3,3,10));
  panB.add(buttonsPan,BorderLayout.SOUTH);
  saveButton.addActionListener(this);
  saveButton.setActionCommand(ACTION_SAVE_ACTION);
  editButton.addActionListener(this);
  editButton.setActionCommand(ACTION_EDIT_ACTION);
  cancelButton.addActionListener(this);
  cancelButton.setActionCommand(ACTION_CANCEL_ACTION);
  saveButton.setVisible(false);
  cancelButton.setVisible(false);
  saveDecompiledButton.addActionListener(this);
  saveDecompiledButton.setActionCommand(ACTION_SAVE_DECOMPILED);
  editDecompiledButton.addActionListener(this);
  editDecompiledButton.setActionCommand(ACTION_EDIT_DECOMPILED);
  cancelDecompiledButton.addActionListener(this);
  cancelDecompiledButton.setActionCommand(ACTION_CANCEL_DECOMPILED);
  saveDecompiledButton.setVisible(false);
  cancelDecompiledButton.setVisible(false);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(new JScrollPane(decompiledEditor),BorderLayout.CENTER);
  decPanel.add(searchPanel,BorderLayout.NORTH);
  searchPanel.setVisible(false);
  JPanel panA=new JPanel();
  panA.setLayout(new BorderLayout());
  panA.add(decPanel,BorderLayout.CENTER);
  panA.add(decLabel,BorderLayout.NORTH);
  panA.add(decButtonsPan,BorderLayout.SOUTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  setLayout(new BorderLayout());
  add(splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panA,panB),BorderLayout.CENTER);
  splitPane.setResizeWeight(0.5);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.guiActionSplitPaneDividerLocation.set((int)pce.getNewValue());
    }
  }
);
  editor.setFont(new Font(""String_Node_Str"",Font.PLAIN,editor.getFont().getSize()));
  decompiledEditor.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledEditor.getFont().getSize()));
  editor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      editor.getCaret().setVisible(true);
      int pos=editor.getCaretPosition();
      Highlighting lastH=null;
      for (      Highlighting h : disassembledHilights) {
        if (pos < h.startPos) {
          break;
        }
        lastH=h;
      }
      String ofs=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
      Highlighting h2=Highlighting.search(decompiledHilights,""String_Node_Str"",ofs);
      if (h2 != null) {
        ignoreCarret=true;
        decompiledEditor.setCaretPosition(h2.startPos);
        decompiledEditor.getCaret().setVisible(true);
        ignoreCarret=false;
      }
    }
  }
);
  decompiledEditor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      decompiledEditor.getCaret().setVisible(true);
      int pos=decompiledEditor.getCaretPosition();
      Highlighting h=Highlighting.search(decompiledHilights,pos);
      if (h != null) {
        Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
        if (h2 != null) {
          ignoreCarret=true;
          if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
            editor.setCaretPosition(h2.startPos);
          }
          editor.getCaret().setVisible(true);
          ignoreCarret=false;
        }
      }
    }
  }
);
}",0.9931859268530108
61917,"public void setText(HilightedText text){
  int pos=editor.getCaretPosition();
  Highlighting lastH=null;
  for (  Highlighting h : disassembledHilights) {
    if (pos < h.startPos) {
      break;
    }
    lastH=h;
  }
  String offset=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
  editor.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  disassembledHilights=text.instructionHilights;
  String stripped=text.text;
  editor.setText(stripped);
  Highlighting h=Highlighting.search(disassembledHilights,""String_Node_Str"",offset);
  if (h != null) {
    if (h.startPos <= editor.getText().length()) {
      editor.setCaretPosition(h.startPos);
    }
  }
}","private void setText(HilightedText text,String contentType){
  int pos=editor.getCaretPosition();
  Highlighting lastH=null;
  for (  Highlighting h : disassembledHilights) {
    if (pos < h.startPos) {
      break;
    }
    lastH=h;
  }
  String offset=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
  disassembledHilights=text.instructionHilights;
  String stripped=text.text;
  setEditorText(stripped,contentType);
  Highlighting h=Highlighting.search(disassembledHilights,""String_Node_Str"",offset);
  if (h != null) {
    if (h.startPos <= editor.getText().length()) {
      editor.setCaretPosition(h.startPos);
    }
  }
}",0.4935251798561151
61918,"public MainPanel(MainFrame mainFrame,MainFrameMenu mainMenu,FlashPlayerPanel flashPanel){
  super();
  this.mainFrame=mainFrame;
  this.mainMenu=mainMenu;
  this.flashPanel=flashPanel;
  mainFrame.setTitle(ApplicationInfo.applicationVerName);
  setLayout(new BorderLayout());
  swfs=new ArrayList<>();
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  tagTree=new TagTree((TagTreeModel)null);
  tagTree.addTreeSelectionListener(this);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  createContextMenu();
  statusPanel=new MainFrameStatusPanel(this);
  add(statusPanel,BorderLayout.SOUTH);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  fontPanel=new FontPanel(this);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiPreviewSplitPaneDividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(ACTION_SELECT_COLOR);
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  displayPanel.add(createImagesCard(),CARDIMAGEPANEL);
  displayPanel.add(createBinaryCard(),CARDBINARYPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  welcomePanel=createWelcomePanel();
  add(welcomePanel,BorderLayout.CENTER);
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  CardLayout cl3=new CardLayout();
  contentPanel=new JPanel(cl3);
  contentPanel.add(welcomePanel,WELCOME_PANEL);
  contentPanel.add(splitPane1,SPLIT_PANE1);
  add(contentPanel);
  cl3.show(contentPanel,WELCOME_PANEL);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  updateUi();
  enableDrop(true);
}","public MainPanel(MainFrame mainFrame,MainFrameMenu mainMenu,FlashPlayerPanel flashPanel){
  super();
  this.mainFrame=mainFrame;
  this.mainMenu=mainMenu;
  this.flashPanel=flashPanel;
  mainFrame.setTitle(ApplicationInfo.applicationVerName);
  setLayout(new BorderLayout());
  swfs=new ArrayList<>();
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  tagTree=new TagTree((TagTreeModel)null);
  tagTree.addTreeSelectionListener(this);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  createContextMenu();
  statusPanel=new MainFrameStatusPanel(this);
  add(statusPanel,BorderLayout.SOUTH);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  fontPanel=new FontPanel(this);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited && previewSplitPane.getRightComponent().isVisible()) {
        Configuration.guiPreviewSplitPaneDividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(ACTION_SELECT_COLOR);
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  displayPanel.add(createImagesCard(),CARDIMAGEPANEL);
  displayPanel.add(createBinaryCard(),CARDBINARYPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  welcomePanel=createWelcomePanel();
  add(welcomePanel,BorderLayout.CENTER);
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  CardLayout cl3=new CardLayout();
  contentPanel=new JPanel(cl3);
  contentPanel.add(welcomePanel,WELCOME_PANEL);
  contentPanel.add(splitPane1,SPLIT_PANE1);
  add(contentPanel);
  cl3.show(contentPanel,WELCOME_PANEL);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  updateUi();
  enableDrop(true);
}",0.997712677047594
61919,"/** 
 * Parses the console arguments
 * @return path to the file which should be opened or null
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>(Arrays.asList(arguments));
  AbortRetryIgnoreHandler handler=null;
  String nextParam;
  OUTER:   while (true) {
    nextParam=args.remove();
    if (nextParam != null) {
      nextParam=nextParam.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      parseConfig(args);
    if (args.isEmpty()) {
      Configuration.saveConfig();
      System.out.println(""String_Node_Str"");
      return null;
    }
  break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(args,handler,traceLevel);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParam;
}
 else {
badArguments();
}
return null;
}","/** 
 * Parses the console arguments
 * @return path to the file which should be opened or null
 */
public static String parseArguments(String[] arguments) throws IOException {
  Level traceLevel=Level.WARNING;
  Queue<String> args=new LinkedList<>(Arrays.asList(arguments));
  AbortRetryIgnoreHandler handler=null;
  String nextParam;
  OUTER:   while (true) {
    nextParam=args.remove();
    if (nextParam != null) {
      nextParam=nextParam.toLowerCase();
    }
switch (nextParam) {
case ""String_Node_Str"":
      parseConfig(args);
    if (args.isEmpty()) {
      Configuration.saveConfig();
      System.out.println(""String_Node_Str"");
      return null;
    }
  break;
case ""String_Node_Str"":
handler=parseOnError(args);
break;
case ""String_Node_Str"":
parseTimeout(args);
break;
case ""String_Node_Str"":
parseExportTimeout(args);
break;
case ""String_Node_Str"":
parseExportFileTimeout(args);
break;
case ""String_Node_Str"":
parseAffinity(args);
break;
case ""String_Node_Str"":
parsePriority(args);
break;
case ""String_Node_Str"":
traceLevel=Level.FINE;
break;
case ""String_Node_Str"":
Configuration.debugMode.set(true);
break;
default :
break OUTER;
}
if (args.isEmpty()) {
return null;
}
}
if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(false,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
ContextMenuTools.addToContextMenu(true,true);
System.exit(0);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseProxy(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseExport(args,handler,traceLevel);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseCompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDecompress(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseRenameInvalidIdentifiers(args);
}
 else if (nextParam.equals(""String_Node_Str"")) {
parseDumpSwf(args);
}
 else if (nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"") || nextParam.equals(""String_Node_Str"")) {
printHeader();
printCmdLineUsage();
System.exit(0);
}
 else if (args.isEmpty()) {
return nextParam;
}
 else {
badArguments();
}
return null;
}",0.9976635514018692
61920,"private static boolean addToContextMenu(boolean add,String exeName){
  final String extensions[]=new String[]{""String_Node_Str"",""String_Node_Str""};
  final WinReg.HKEY REG_CLASSES_HKEY=WinReg.HKEY_LOCAL_MACHINE;
  final String REG_CLASSES_PATH=""String_Node_Str"";
  String appDir=getAppDir();
  String verb=""String_Node_Str"";
  String verbName=""String_Node_Str"";
  boolean exists;
  try {
    exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
    if ((!exists) && add) {
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"",""String_Node_Str"",verbName);
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
    }
    for (    String ext : extensions) {
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext)) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext,""String_Node_Str"",""String_Node_Str"");
      }
      String clsName=Advapi32Util.registryGetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext,""String_Node_Str"");
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName)) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName,""String_Node_Str"",""String_Node_Str"");
      }
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str"")) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str"");
      }
      exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
      if ((!exists) && add) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb,""String_Node_Str"",verbName);
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"");
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
      }
      if (exists && (!add)) {
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
      }
      exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      if (exists && (!add)) {
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      }
      if (Advapi32Util.registryValueExists(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"")) {
        String mruList=Advapi32Util.registryGetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"");
        if (mruList != null) {
          exists=false;
          char appChar=0;
          for (int i=0; i < mruList.length(); i++) {
            String app=Advapi32Util.registryGetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + mruList.charAt(i));
            if (app.equals(exeName)) {
              appChar=mruList.charAt(i);
              exists=true;
              break;
            }
          }
          if ((!exists) && add) {
            for (int c='a'; c <= 'z'; c++) {
              if (mruList.indexOf(c) == -1) {
                mruList+=(char)c;
                Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + (char)c,exeName);
                Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"",mruList);
                break;
              }
            }
          }
          if (exists && (!add)) {
            mruList=mruList.replace(""String_Node_Str"" + appChar,""String_Node_Str"");
            Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"",mruList);
            registryDeleteValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + appChar);
          }
        }
      }
      if (Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"")) {
        exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
        if ((!exists) && add) {
          if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"")) {
            Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"");
          }
          if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"")) {
            Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"");
          }
          Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
          Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb,""String_Node_Str"",verbName);
          Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"");
          Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
        }
        if (exists && (!add)) {
          registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"");
          registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
        }
      }
    }
    return true;
  }
 catch (  Exception ex) {
    SHELLEXECUTEINFO sei=new SHELLEXECUTEINFO();
    sei.fMask=0x00000040;
    sei.lpVerb=new WString(""String_Node_Str"");
    sei.lpFile=new WString(appDir + exeName);
    sei.lpParameters=new WString(add ? ""String_Node_Str"" : ""String_Node_Str"");
    sei.nShow=WinUser.SW_NORMAL;
    Shell32.INSTANCE.ShellExecuteEx(sei);
    Kernel32.INSTANCE.WaitForSingleObject(sei.hProcess,1000 * 60 * 60* 24);
  }
  return false;
}","private static boolean addToContextMenu(boolean add,boolean fromCommandLine,String exeName){
  final String extensions[]=new String[]{""String_Node_Str"",""String_Node_Str""};
  final WinReg.HKEY REG_CLASSES_HKEY=WinReg.HKEY_LOCAL_MACHINE;
  final String REG_CLASSES_PATH=""String_Node_Str"";
  String appDir=getAppDir();
  String verb=""String_Node_Str"";
  String verbName=""String_Node_Str"";
  boolean exists;
  try {
    exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
    if ((!exists) && add) {
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"",""String_Node_Str"",verbName);
      Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
      Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
    }
    for (    String ext : extensions) {
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext)) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext,""String_Node_Str"",""String_Node_Str"");
      }
      String clsName=Advapi32Util.registryGetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext,""String_Node_Str"");
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName)) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName,""String_Node_Str"",""String_Node_Str"");
      }
      if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str"")) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str"");
      }
      exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
      if ((!exists) && add) {
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb,""String_Node_Str"",verbName);
        Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"");
        Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
      }
      if (exists && (!add)) {
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + clsName + ""String_Node_Str""+ verb);
      }
      exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      if (exists && (!add)) {
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName+ ""String_Node_Str"");
        registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + exeName);
      }
      if (Advapi32Util.registryValueExists(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"")) {
        String mruList=Advapi32Util.registryGetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"");
        if (mruList != null) {
          exists=false;
          char appChar=0;
          for (int i=0; i < mruList.length(); i++) {
            String app=Advapi32Util.registryGetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + mruList.charAt(i));
            if (app.equals(exeName)) {
              appChar=mruList.charAt(i);
              exists=true;
              break;
            }
          }
          if ((!exists) && add) {
            for (int c='a'; c <= 'z'; c++) {
              if (mruList.indexOf(c) == -1) {
                mruList+=(char)c;
                Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + (char)c,exeName);
                Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"",mruList);
                break;
              }
            }
          }
          if (exists && (!add)) {
            mruList=mruList.replace(""String_Node_Str"" + appChar,""String_Node_Str"");
            Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"",mruList);
            registryDeleteValue(WinReg.HKEY_CURRENT_USER,""String_Node_Str"" + ext + ""String_Node_Str"",""String_Node_Str"" + appChar);
          }
        }
      }
      if (Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"")) {
        exists=Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
        if ((!exists) && add) {
          if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"")) {
            Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"");
          }
          if (!Advapi32Util.registryKeyExists(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"")) {
            Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str"");
          }
          Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
          Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb,""String_Node_Str"",verbName);
          Advapi32Util.registryCreateKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"");
          Advapi32Util.registrySetStringValue(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + appDir + exeName+ ""String_Node_Str"");
        }
        if (exists && (!add)) {
          registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb+ ""String_Node_Str"");
          registryDeleteKey(REG_CLASSES_HKEY,REG_CLASSES_PATH + ""String_Node_Str"" + ext+ ""String_Node_Str""+ verb);
        }
      }
    }
    return true;
  }
 catch (  Exception ex) {
    if (!fromCommandLine) {
      SHELLEXECUTEINFO sei=new SHELLEXECUTEINFO();
      sei.fMask=0x00000040;
      sei.lpVerb=new WString(""String_Node_Str"");
      sei.lpFile=new WString(appDir + exeName);
      sei.lpParameters=new WString(add ? ""String_Node_Str"" : ""String_Node_Str"");
      sei.nShow=WinUser.SW_NORMAL;
      Shell32.INSTANCE.ShellExecuteEx(sei);
      Kernel32.INSTANCE.WaitForSingleObject(sei.hProcess,1000 * 60 * 60* 24);
    }
 else {
      Logger.getLogger(ContextMenuTools.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  return false;
}",0.9887626420277188
61921,"private static void offerAssociation(){
  boolean offered=Configuration.offeredAssociation.get();
  if (!offered) {
    if (Platform.isWindows()) {
      if ((!ContextMenuTools.isAddedToContextMenu()) && View.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
        ContextMenuTools.addToContextMenu(true);
      }
    }
  }
  Configuration.offeredAssociation.set(true);
}","private static void offerAssociation(){
  boolean offered=Configuration.offeredAssociation.get();
  if (!offered) {
    if (Platform.isWindows()) {
      if ((!ContextMenuTools.isAddedToContextMenu()) && View.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
        ContextMenuTools.addToContextMenu(true,false);
      }
    }
  }
  Configuration.offeredAssociation.set(true);
}",0.9936170212765958
61922,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_RELOAD:
    if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
      Main.reloadApp();
    }
  break;
case ACTION_ADVANCED_SETTINGS:
Main.advancedSettings();
break;
case ACTION_LOAD_MEMORY:
Main.loadFromMemory();
break;
case ACTION_LOAD_CACHE:
Main.loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
new SelectLanguageDialog().display();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.panel.disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected());
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.panel.gotoDocumentClass(mainFrame.panel.getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.panel.reload(true);
break;
case ACTION_SEARCH_AS:
mainFrame.panel.searchAs();
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.panel,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.panel.autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_EXIT:
mainFrame.panel.setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
mainFrame.panel.renameOneIdentifier(mainFrame.panel.getCurrentSwf());
break;
case ACTION_ABOUT:
Main.about();
break;
case ACTION_SHOW_PROXY:
Main.showProxy();
break;
case ACTION_SUB_LIMITER:
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ACTION_SAVE:
try {
SWF swf=mainFrame.panel.getCurrentSwf();
Main.saveFile(swf,swf.file);
}
 catch (IOException ex) {
Logger.getLogger(MainFrameClassicMenu.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_SAVE_AS:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf)) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_SAVE_AS_EXE:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf,""String_Node_Str"")) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_OPEN:
Main.openFileDialog();
break;
case ACTION_EXPORT_FLA:
mainFrame.panel.exportFla(mainFrame.panel.getCurrentSwf());
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.export(onlySel);
break;
case ACTION_CHECK_UPDATES:
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ACTION_HELP_US:
String helpUsURL=ApplicationInfo.PROJECT_PAGE + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ACTION_HOMEPAGE:
String homePageURL=ApplicationInfo.PROJECT_PAGE;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
mainFrame.panel.renameIdentifiers(mainFrame.panel.getCurrentSwf());
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
mainFrame.panel.deobfuscate();
break;
case ACTION_REMOVE_NON_SCRIPTS:
mainFrame.panel.removeNonScripts(mainFrame.panel.getCurrentSwf());
break;
case ACTION_REFRESH_DECOMPILED:
mainFrame.panel.refreshDecompiled();
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_RELOAD:
    if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
      Main.reloadApp();
    }
  break;
case ACTION_ADVANCED_SETTINGS:
Main.advancedSettings();
break;
case ACTION_LOAD_MEMORY:
Main.loadFromMemory();
break;
case ACTION_LOAD_CACHE:
Main.loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
new SelectLanguageDialog().display();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.panel.disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected(),false);
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.panel.gotoDocumentClass(mainFrame.panel.getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.panel.reload(true);
break;
case ACTION_SEARCH_AS:
mainFrame.panel.searchAs();
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.panel,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.panel.autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_EXIT:
mainFrame.panel.setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
mainFrame.panel.renameOneIdentifier(mainFrame.panel.getCurrentSwf());
break;
case ACTION_ABOUT:
Main.about();
break;
case ACTION_SHOW_PROXY:
Main.showProxy();
break;
case ACTION_SUB_LIMITER:
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ACTION_SAVE:
try {
SWF swf=mainFrame.panel.getCurrentSwf();
Main.saveFile(swf,swf.file);
}
 catch (IOException ex) {
Logger.getLogger(MainFrameClassicMenu.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_SAVE_AS:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf)) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_SAVE_AS_EXE:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf,""String_Node_Str"")) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_OPEN:
Main.openFileDialog();
break;
case ACTION_EXPORT_FLA:
mainFrame.panel.exportFla(mainFrame.panel.getCurrentSwf());
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.export(onlySel);
break;
case ACTION_CHECK_UPDATES:
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ACTION_HELP_US:
String helpUsURL=ApplicationInfo.PROJECT_PAGE + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ACTION_HOMEPAGE:
String homePageURL=ApplicationInfo.PROJECT_PAGE;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
mainFrame.panel.renameIdentifiers(mainFrame.panel.getCurrentSwf());
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
mainFrame.panel.deobfuscate();
break;
case ACTION_REMOVE_NON_SCRIPTS:
mainFrame.panel.removeNonScripts(mainFrame.panel.getCurrentSwf());
break;
case ACTION_REFRESH_DECOMPILED:
mainFrame.panel.refreshDecompiled();
break;
}
}",0.9995273357491729
61923,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_RELOAD:
    if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
      Main.reloadApp();
    }
  break;
case ACTION_ADVANCED_SETTINGS:
Main.advancedSettings();
break;
case ACTION_LOAD_MEMORY:
Main.loadFromMemory();
break;
case ACTION_LOAD_CACHE:
Main.loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
new SelectLanguageDialog().display();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.panel.disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected());
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.panel.gotoDocumentClass(mainFrame.panel.getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.panel.reload(true);
break;
case ACTION_SEARCH_AS:
mainFrame.panel.searchAs();
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.panel,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.panel.autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_CLEAR_RECENT_FILES:
Configuration.recentFiles.set(null);
break;
case ACTION_EXIT:
mainFrame.panel.setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
mainFrame.panel.renameOneIdentifier(mainFrame.panel.getCurrentSwf());
break;
case ACTION_ABOUT:
Main.about();
break;
case ACTION_SHOW_PROXY:
Main.showProxy();
break;
case ACTION_SUB_LIMITER:
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ACTION_SAVE:
try {
SWF swf=mainFrame.panel.getCurrentSwf();
Main.saveFile(swf,swf.file);
}
 catch (IOException ex) {
Logger.getLogger(MainFrameRibbonMenu.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_SAVE_AS:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf)) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_SAVE_AS_EXE:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf,""String_Node_Str"")) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_OPEN:
Main.openFileDialog();
break;
case ACTION_CLOSE:
Main.closeFile(mainFrame.panel.getCurrentSwf());
break;
case ACTION_CLOSE_ALL:
Main.closeAll();
break;
case ACTION_EXPORT_FLA:
mainFrame.panel.exportFla(mainFrame.panel.getCurrentSwf());
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.export(onlySel);
break;
case ACTION_CHECK_UPDATES:
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ACTION_HELP_US:
String helpUsURL=ApplicationInfo.PROJECT_PAGE + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ACTION_HOMEPAGE:
String homePageURL=ApplicationInfo.PROJECT_PAGE;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
mainFrame.panel.renameIdentifiers(mainFrame.panel.getCurrentSwf());
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
mainFrame.panel.deobfuscate();
break;
case ACTION_REMOVE_NON_SCRIPTS:
mainFrame.panel.removeNonScripts(mainFrame.panel.getCurrentSwf());
break;
case ACTION_REFRESH_DECOMPILED:
mainFrame.panel.refreshDecompiled();
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ACTION_RELOAD:
    if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
      Main.reloadApp();
    }
  break;
case ACTION_ADVANCED_SETTINGS:
Main.advancedSettings();
break;
case ACTION_LOAD_MEMORY:
Main.loadFromMemory();
break;
case ACTION_LOAD_CACHE:
Main.loadFromCache();
break;
case ACTION_GOTO_DOCUMENT_CLASS_ON_STARTUP:
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ACTION_AUTO_RENAME_IDENTIFIERS:
Configuration.autoRenameIdentifiers.set(miAutoRenameIdentifiers.isSelected());
break;
case ACTION_CACHE_ON_DISK:
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ACTION_SET_LANGUAGE:
new SelectLanguageDialog().display();
break;
case ACTION_DISABLE_DECOMPILATION:
Configuration.decompile.set(!miDecompile.isSelected());
mainFrame.panel.disableDecompilationChanged();
break;
case ACTION_ASSOCIATE:
if (miAssociate.isSelected() == ContextMenuTools.isAddedToContextMenu()) {
return;
}
ContextMenuTools.addToContextMenu(miAssociate.isSelected(),false);
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(ContextMenuTools.isAddedToContextMenu());
}
}
,1000);
break;
case ACTION_GOTO_DOCUMENT_CLASS:
mainFrame.panel.gotoDocumentClass(mainFrame.panel.getCurrentSwf());
break;
case ACTION_PARALLEL_SPEED_UP:
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ACTION_INTERNAL_VIEWER_SWITCH:
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
mainFrame.panel.reload(true);
break;
case ACTION_SEARCH_AS:
mainFrame.panel.searchAs();
break;
case ACTION_AUTO_DEOBFUSCATE:
if (View.showConfirmDialog(mainFrame.panel,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
mainFrame.panel.autoDeobfuscateChanged();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ACTION_CLEAR_RECENT_FILES:
Configuration.recentFiles.set(null);
break;
case ACTION_EXIT:
mainFrame.panel.setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ACTION_RENAME_ONE_IDENTIFIER:
mainFrame.panel.renameOneIdentifier(mainFrame.panel.getCurrentSwf());
break;
case ACTION_ABOUT:
Main.about();
break;
case ACTION_SHOW_PROXY:
Main.showProxy();
break;
case ACTION_SUB_LIMITER:
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ACTION_SAVE:
try {
SWF swf=mainFrame.panel.getCurrentSwf();
Main.saveFile(swf,swf.file);
}
 catch (IOException ex) {
Logger.getLogger(MainFrameRibbonMenu.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ACTION_SAVE_AS:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf)) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_SAVE_AS_EXE:
{
SWF swf=mainFrame.panel.getCurrentSwf();
if (Main.saveFileDialog(swf,""String_Node_Str"")) {
mainFrame.setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + swf.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(mainFrame.panel.getCurrentSwf() != null);
}
}
break;
case ACTION_OPEN:
Main.openFileDialog();
break;
case ACTION_CLOSE:
Main.closeFile(mainFrame.panel.getCurrentSwf());
break;
case ACTION_CLOSE_ALL:
Main.closeAll();
break;
case ACTION_EXPORT_FLA:
mainFrame.panel.exportFla(mainFrame.panel.getCurrentSwf());
break;
case ACTION_EXPORT_SEL:
case ACTION_EXPORT:
boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.export(onlySel);
break;
case ACTION_CHECK_UPDATES:
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ACTION_HELP_US:
String helpUsURL=ApplicationInfo.PROJECT_PAGE + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ACTION_HOMEPAGE:
String homePageURL=ApplicationInfo.PROJECT_PAGE;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ACTION_RESTORE_CONTROL_FLOW:
case ACTION_RESTORE_CONTROL_FLOW_ALL:
boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
mainFrame.panel.restoreControlFlow(all);
break;
case ACTION_RENAME_IDENTIFIERS:
mainFrame.panel.renameIdentifiers(mainFrame.panel.getCurrentSwf());
break;
case ACTION_DEOBFUSCATE:
case ACTION_DEOBFUSCATE_ALL:
mainFrame.panel.deobfuscate();
break;
case ACTION_REMOVE_NON_SCRIPTS:
mainFrame.panel.removeNonScripts(mainFrame.panel.getCurrentSwf());
break;
case ACTION_REFRESH_DECOMPILED:
mainFrame.panel.refreshDecompiled();
break;
}
}",0.999541564792176
61924,"@Override protected Object doInBackground() throws Exception {
  for (  SWFSourceInfo sourceInfo : sourceInfos) {
    SWF swf=null;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      swf=parseSWF(sourceInfo);
    }
 catch (    OutOfMemoryError ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
catch (    Exception ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
    final SWF swf1=swf;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          if (mainFrame == null) {
            if (Configuration.useRibbonInterface.get()) {
              mainFrame=new MainFrameRibbon();
            }
 else {
              mainFrame=new MainFrameClassic();
            }
          }
          mainFrame.getPanel().load(swf1);
          if (errorState) {
            mainFrame.getPanel().setErrorState();
          }
        }
      }
);
    }
 catch (    Exception ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  loadingDialog.setVisible(false);
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      if (mainFrame != null) {
        mainFrame.setVisible(true);
      }
      Main.stopWork();
    }
  }
);
  return true;
}","@Override protected Object doInBackground() throws Exception {
  boolean first=true;
  for (  SWFSourceInfo sourceInfo : sourceInfos) {
    SWF swf=null;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      swf=parseSWF(sourceInfo);
    }
 catch (    OutOfMemoryError ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
catch (    Exception ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
      View.showMessageDialog(null,""String_Node_Str"");
    }
    final SWF swf1=swf;
    final boolean first1=first;
    first=false;
    try {
      Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
      View.execInEventDispatch(new Runnable(){
        @Override public void run(){
          if (mainFrame == null) {
            if (Configuration.useRibbonInterface.get()) {
              mainFrame=new MainFrameRibbon();
            }
 else {
              mainFrame=new MainFrameClassic();
            }
          }
          mainFrame.getPanel().load(swf1,first1);
          if (errorState) {
            mainFrame.getPanel().setErrorState();
          }
        }
      }
);
    }
 catch (    Exception ex) {
      Logger.getLogger(Main.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  loadingDialog.setVisible(false);
  View.execInEventDispatch(new Runnable(){
    @Override public void run(){
      if (mainFrame != null) {
        mainFrame.setVisible(true);
      }
      Main.stopWork();
    }
  }
);
  return true;
}",0.975206611570248
61925,"public void restoreControlFlow(final boolean all){
  Main.startWork(translate(""String_Node_Str""));
  if ((!all) || confirmExperimental()) {
    new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        int cnt=0;
        if (all) {
          for (          ABCContainerTag tag : abcPanel.list) {
            tag.getABC().restoreControlFlow();
          }
        }
 else {
          int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
          if (bi != -1) {
            abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,abcPanel.decompiledTextArea.getCurrentTrait(),abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
          }
          abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,abcPanel.decompiledTextArea.getCurrentTrait());
        }
        return true;
      }
      @Override protected void done(){
        Main.stopWork();
        View.showMessageDialog(null,translate(""String_Node_Str""));
        View.execInEventDispatch(new Runnable(){
          @Override public void run(){
            abcPanel.reload();
            updateClassesList();
          }
        }
);
      }
    }
.execute();
  }
}","public void restoreControlFlow(final boolean all){
  Main.startWork(translate(""String_Node_Str""));
  if ((!all) || confirmExperimental()) {
    new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        int cnt=0;
        if (all) {
          for (          ABCContainerTag tag : abcPanel.swf.abcList) {
            tag.getABC().restoreControlFlow();
          }
        }
 else {
          int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
          if (bi != -1) {
            abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,abcPanel.decompiledTextArea.getCurrentTrait(),abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
          }
          abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,abcPanel.decompiledTextArea.getCurrentTrait());
        }
        return true;
      }
      @Override protected void done(){
        Main.stopWork();
        View.showMessageDialog(null,translate(""String_Node_Str""));
        View.execInEventDispatch(new Runnable(){
          @Override public void run(){
            abcPanel.reload();
            updateClassesList();
          }
        }
);
      }
    }
.execute();
  }
}",0.9964071856287424
61926,"public void deobfuscate(){
  if (deobfuscationDialog == null) {
    deobfuscationDialog=new DeobfuscationDialog();
  }
  deobfuscationDialog.setVisible(true);
  if (deobfuscationDialog.ok) {
    Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
    new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        try {
          if (deobfuscationDialog.processAllCheckbox.isSelected()) {
            for (            ABCContainerTag tag : abcPanel.list) {
              if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
                tag.getABC().removeDeadCode();
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
                tag.getABC().removeTraps();
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
                tag.getABC().removeTraps();
                tag.getABC().restoreControlFlow();
              }
            }
          }
 else {
            int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
            Trait t=abcPanel.decompiledTextArea.getCurrentTrait();
            if (bi != -1) {
              if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
                abcPanel.abc.bodies[bi].removeDeadCode(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
                abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
                abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
                abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
              }
            }
            abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,t);
          }
        }
 catch (        Exception ex) {
          Logger.getLogger(MainFramePanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
        }
        return true;
      }
      @Override protected void done(){
        Main.stopWork();
        View.showMessageDialog(null,translate(""String_Node_Str""));
        View.execInEventDispatch(new Runnable(){
          @Override public void run(){
            clearCache();
            abcPanel.reload();
            updateClassesList();
          }
        }
);
      }
    }
.execute();
  }
}","public void deobfuscate(){
  if (deobfuscationDialog == null) {
    deobfuscationDialog=new DeobfuscationDialog();
  }
  deobfuscationDialog.setVisible(true);
  if (deobfuscationDialog.ok) {
    Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
    new CancellableWorker(){
      @Override protected Object doInBackground() throws Exception {
        try {
          if (deobfuscationDialog.processAllCheckbox.isSelected()) {
            for (            ABCContainerTag tag : abcPanel.swf.abcList) {
              if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
                tag.getABC().removeDeadCode();
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
                tag.getABC().removeTraps();
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
                tag.getABC().removeTraps();
                tag.getABC().restoreControlFlow();
              }
            }
          }
 else {
            int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
            Trait t=abcPanel.decompiledTextArea.getCurrentTrait();
            if (bi != -1) {
              if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
                abcPanel.abc.bodies[bi].removeDeadCode(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
                abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
              }
 else               if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
                abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
                abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
              }
            }
            abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,t);
          }
        }
 catch (        Exception ex) {
          Logger.getLogger(MainFramePanel.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
        }
        return true;
      }
      @Override protected void done(){
        Main.stopWork();
        View.showMessageDialog(null,translate(""String_Node_Str""));
        View.execInEventDispatch(new Runnable(){
          @Override public void run(){
            clearCache();
            abcPanel.reload();
            updateClassesList();
          }
        }
);
      }
    }
.execute();
  }
}",0.998598785614199
61927,"@Override public void setVisible(boolean b){
  super.setVisible(b);
  if (b) {
    if (abcPanel != null) {
      abcPanel.initSplits();
    }
    if (actionPanel != null) {
      actionPanel.initSplits();
    }
    final MainFramePanel t=this;
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        splitPane1.setDividerLocation(Configuration.guiSplitPane1DividerLocation.get(getWidth() / 3));
        int confDivLoc=Configuration.guiSplitPane2DividerLocation.get(splitPane2.getHeight() * 3 / 5);
        if (confDivLoc > splitPane2.getHeight() - 10) {
          confDivLoc=splitPane2.getHeight() * 3 / 5;
        }
        splitPane2.setDividerLocation(confDivLoc);
        splitPos=splitPane2.getDividerLocation();
        splitsInited=true;
        if (Configuration.gotoMainClassOnStartup.get()) {
          gotoDocumentClass(getCurrentSwf());
        }
      }
    }
);
  }
}","@Override public void setVisible(boolean b){
  super.setVisible(b);
  if (b) {
    if (abcPanel != null) {
      abcPanel.initSplits();
    }
    if (actionPanel != null) {
      actionPanel.initSplits();
    }
    final MainFramePanel t=this;
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        splitPane1.setDividerLocation(Configuration.guiSplitPane1DividerLocation.get(getWidth() / 3));
        int confDivLoc=Configuration.guiSplitPane2DividerLocation.get(splitPane2.getHeight() * 3 / 5);
        if (confDivLoc > splitPane2.getHeight() - 10) {
          confDivLoc=splitPane2.getHeight() * 3 / 5;
        }
        splitPane2.setDividerLocation(confDivLoc);
        splitPos=splitPane2.getDividerLocation();
        splitsInited=true;
      }
    }
);
  }
}",0.93006993006993
61928,"public void gotoDocumentClass(SWF swf){
  if (swf == null) {
    return;
  }
  String documentClass=null;
  loopdc:   for (  Tag t : swf.tags) {
    if (t instanceof SymbolClassTag) {
      SymbolClassTag sc=(SymbolClassTag)t;
      for (int i=0; i < sc.tagIDs.length; i++) {
        if (sc.tagIDs[i] == 0) {
          documentClass=sc.classNames[i];
          break loopdc;
        }
      }
    }
  }
  if (documentClass != null) {
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPT3PANEL);
    abcPanel.hilightScript(documentClass);
  }
}","public void gotoDocumentClass(SWF swf){
  if (swf == null) {
    return;
  }
  String documentClass=null;
  loopdc:   for (  Tag t : swf.tags) {
    if (t instanceof SymbolClassTag) {
      SymbolClassTag sc=(SymbolClassTag)t;
      for (int i=0; i < sc.tagIDs.length; i++) {
        if (sc.tagIDs[i] == 0) {
          documentClass=sc.classNames[i];
          break loopdc;
        }
      }
    }
  }
  if (documentClass != null) {
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPT3PANEL);
    abcPanel.setSwf(swf);
    abcPanel.hilightScript(documentClass);
  }
}",0.9773123909249564
61929,"public void load(SWF swf){
  List<ContainerItem> objs=new ArrayList<>();
  if (swf != null) {
    objs.addAll(swf.tags);
  }
  ArrayList<ABCContainerTag> abcList=new ArrayList<>();
  getActionScript3(objs,abcList);
  swfs.add(swf);
  swf.abcList=abcList;
  boolean hasAbc=!abcList.isEmpty();
  if (hasAbc) {
    if (abcPanel == null) {
      abcPanel=new ABCPanel(this);
      displayPanel.add(abcPanel,CARDACTIONSCRIPT3PANEL);
      detailPanel.add(abcPanel.tabbedPane,DETAILCARDAS3NAVIGATOR);
    }
    abcPanel.setSwf(abcList,swf);
  }
 else {
    if (actionPanel == null) {
      actionPanel=new ActionPanel(this);
      displayPanel.add(actionPanel,CARDACTIONSCRIPTPANEL);
    }
  }
  tagTree.setModel(new TagTreeModel(mainFrame,swfs));
  expandSwfRoots();
  for (  Tag t : swf.tags) {
    if (t instanceof JPEGTablesTag) {
      swf.jtt=(JPEGTablesTag)t;
    }
  }
  List<ContainerItem> list2=new ArrayList<>();
  list2.addAll(swf.tags);
  swf.characters=new HashMap<>();
  parseCharacters(swf,list2);
  if (Configuration.autoRenameIdentifiers.get()) {
    try {
      swf.deobfuscateIdentifiers(RenameType.TYPENUMBER);
      swf.assignClassesToSymbols();
      clearCache();
      if (abcPanel != null) {
        abcPanel.reload();
      }
      updateClassesList();
    }
 catch (    InterruptedException ex) {
      Logger.getLogger(MainFramePanel.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  showDetail(DETAILCARDEMPTYPANEL);
  showCard(CARDEMPTYPANEL);
  updateUi(swf);
}","public void load(SWF swf,boolean first){
  List<ContainerItem> objs=new ArrayList<>();
  objs.addAll(swf.tags);
  ArrayList<ABCContainerTag> abcList=new ArrayList<>();
  getActionScript3(objs,abcList);
  swfs.add(swf);
  swf.abcList=abcList;
  boolean hasAbc=!abcList.isEmpty();
  if (hasAbc) {
    if (abcPanel == null) {
      abcPanel=new ABCPanel(this);
      displayPanel.add(abcPanel,CARDACTIONSCRIPT3PANEL);
      detailPanel.add(abcPanel.tabbedPane,DETAILCARDAS3NAVIGATOR);
    }
    abcPanel.setSwf(swf);
  }
 else {
    if (actionPanel == null) {
      actionPanel=new ActionPanel(this);
      displayPanel.add(actionPanel,CARDACTIONSCRIPTPANEL);
    }
  }
  tagTree.setModel(new TagTreeModel(mainFrame,swfs));
  expandSwfRoots();
  for (  Tag t : swf.tags) {
    if (t instanceof JPEGTablesTag) {
      swf.jtt=(JPEGTablesTag)t;
    }
  }
  List<ContainerItem> list2=new ArrayList<>();
  list2.addAll(swf.tags);
  swf.characters=new HashMap<>();
  parseCharacters(swf,list2);
  if (Configuration.autoRenameIdentifiers.get()) {
    try {
      swf.deobfuscateIdentifiers(RenameType.TYPENUMBER);
      swf.assignClassesToSymbols();
      clearCache();
      if (abcPanel != null) {
        abcPanel.reload();
      }
      updateClassesList();
    }
 catch (    InterruptedException ex) {
      Logger.getLogger(MainFramePanel.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  showDetail(DETAILCARDEMPTYPANEL);
  showCard(CARDEMPTYPANEL);
  updateUi(swf);
  if (first && Configuration.gotoMainClassOnStartup.get()) {
    gotoDocumentClass(swf);
  }
}",0.9535644211903204
61930,"private List<Object> searchTag(Object obj,Object parent,List<Object> path){
  List<Object> ret=null;
  int cnt=getChildCount(parent);
  for (int i=0; i < cnt; i++) {
    Object n=getChild(parent,i);
    List<Object> newPath=new ArrayList<>();
    newPath.addAll(path);
    newPath.add(n);
    if (n instanceof TreeElement) {
      TreeElement te=(TreeElement)n;
      Object it=te.getItem();
      if (obj == it) {
        return newPath;
      }
    }
    if (n instanceof TagNode) {
      TagNode nd=(TagNode)n;
      if (nd.tag == obj) {
        return newPath;
      }
    }
    ret=searchTag(obj,n,newPath);
    if (ret != null) {
      return ret;
    }
  }
  return ret;
}","private List<TreeNode> searchTag(TreeElementItem obj,TreeNode parent,List<TreeNode> path){
  List<TreeNode> ret=null;
  int cnt=getChildCount(parent);
  for (int i=0; i < cnt; i++) {
    TreeNode n=getChild(parent,i);
    List<TreeNode> newPath=new ArrayList<>();
    newPath.addAll(path);
    newPath.add(n);
    if (n instanceof TreeElement) {
      TreeElement te=(TreeElement)n;
      TreeElementItem it=te.getItem();
      if (obj == it) {
        return newPath;
      }
    }
    if (n instanceof TagNode) {
      TagNode nd=(TagNode)n;
      if (nd.tag == obj) {
        return newPath;
      }
    }
    ret=searchTag(obj,n,newPath);
    if (ret != null) {
      return ret;
    }
  }
  return ret;
}",0.8933717579250721
61931,"public TreePath getTagPath(Object obj){
  List<Object> path=new ArrayList<>();
  path.add(getRoot());
  path=searchTag(obj,getRoot(),path);
  TreePath tp=new TreePath(path.toArray(new Object[path.size()]));
  return tp;
}","public TreePath getTagPath(TreeElementItem obj){
  List<TreeNode> path=new ArrayList<>();
  path.add(getRoot());
  path=searchTag(obj,getRoot(),path);
  TreePath tp=new TreePath(path.toArray(new Object[path.size()]));
  return tp;
}",0.913907284768212
61932,"@SuppressWarnings(""String_Node_Str"") public void setSwf(List<ABCContainerTag> list,SWF swf){
  this.list=list;
  this.swf=swf;
  listIndex=-1;
  switchAbc(0);
  abcComboBox.setModel(new ABCComboBoxModel(list));
  if (list.size() > 0) {
    this.abc=list.get(0).getABC();
  }
  navigator.setABC(list,abc);
}","@SuppressWarnings(""String_Node_Str"") public void setSwf(SWF swf){
  if (this.swf != swf) {
    this.swf=swf;
    listIndex=-1;
    switchAbc(0);
    abcComboBox.setModel(new ABCComboBoxModel(swf.abcList));
    if (swf.abcList.size() > 0) {
      this.abc=swf.abcList.get(0).getABC();
    }
    navigator.setABC(swf.abcList,abc);
  }
}",0.7875
61933,"public boolean search(String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchIgnoreCase=ignoreCase;
    searchRegexp=regexp;
    ClassesListTreeModel clModel=(ClassesListTreeModel)classTree.getModel();
    List<MyEntry<ClassPath,ScriptPack>> allpacks=clModel.getList();
    found=new ArrayList<>();
    final Pattern pat=regexp ? Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0) : Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    int pos=0;
    for (    final MyEntry<ClassPath,ScriptPack> item : allpacks) {
      pos++;
      String workText=AppStrings.translate(""String_Node_Str"");
      String decAdd=""String_Node_Str"";
      if (!decompiledTextArea.isCached(item.value)) {
        decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
      }
      try {
        CancellableWorker worker=new CancellableWorker(){
          @Override public Void doInBackground() throws Exception {
            decompiledTextArea.cacheScriptPack(item.value,list);
            if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
              found.add(item.value);
              foundPath.add(item.key);
            }
            return null;
          }
        }
;
        worker.execute();
        Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ allpacks.size()+ ""String_Node_Str""+ item.key.toString()+ ""String_Node_Str"",worker);
        worker.get();
      }
 catch (      InterruptedException ex) {
        break;
      }
catch (      ExecutionException ex) {
        Logger.getLogger(ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    System.gc();
    Main.stopWork();
    if (found.isEmpty()) {
      searchPanel.setVisible(false);
      return false;
    }
 else {
      foundPos=0;
      decompiledTextArea.setScript(found.get(foundPos),list);
      searchPanel.setVisible(true);
      searchFor=txt;
      updateSearchPos();
      searchForLabel.setText(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",txt) + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}","public boolean search(String txt,boolean ignoreCase,boolean regexp){
  if ((txt != null) && (!txt.isEmpty())) {
    searchIgnoreCase=ignoreCase;
    searchRegexp=regexp;
    ClassesListTreeModel clModel=(ClassesListTreeModel)classTree.getModel();
    List<MyEntry<ClassPath,ScriptPack>> allpacks=clModel.getList();
    found=new ArrayList<>();
    final Pattern pat=regexp ? Pattern.compile(txt,ignoreCase ? Pattern.CASE_INSENSITIVE : 0) : Pattern.compile(Pattern.quote(txt),ignoreCase ? Pattern.CASE_INSENSITIVE : 0);
    int pos=0;
    for (    final MyEntry<ClassPath,ScriptPack> item : allpacks) {
      pos++;
      String workText=AppStrings.translate(""String_Node_Str"");
      String decAdd=""String_Node_Str"";
      if (!decompiledTextArea.isCached(item.value)) {
        decAdd=""String_Node_Str"" + AppStrings.translate(""String_Node_Str"");
      }
      try {
        CancellableWorker worker=new CancellableWorker(){
          @Override public Void doInBackground() throws Exception {
            decompiledTextArea.cacheScriptPack(item.value,swf.abcList);
            if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
              found.add(item.value);
              foundPath.add(item.key);
            }
            return null;
          }
        }
;
        worker.execute();
        Main.startWork(workText + ""String_Node_Str"" + txt+ ""String_Node_Str""+ decAdd+ ""String_Node_Str""+ pos+ ""String_Node_Str""+ allpacks.size()+ ""String_Node_Str""+ item.key.toString()+ ""String_Node_Str"",worker);
        worker.get();
      }
 catch (      InterruptedException ex) {
        break;
      }
catch (      ExecutionException ex) {
        Logger.getLogger(ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    System.gc();
    Main.stopWork();
    if (found.isEmpty()) {
      searchPanel.setVisible(false);
      return false;
    }
 else {
      foundPos=0;
      decompiledTextArea.setScript(found.get(foundPos),swf.abcList);
      searchPanel.setVisible(true);
      searchFor=txt;
      updateSearchPos();
      searchForLabel.setText(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",txt) + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}",0.9959367945823928
61934,"@SuppressWarnings(""String_Node_Str"") public ABCPanel(MainFramePanel mainFramePanel){
  DefaultSyntaxKit.initKit();
  this.mainFramePanel=mainFramePanel;
  setLayout(new BorderLayout());
  decompiledTextArea=new DecompiledEditorPane(this);
  searchPanel=new JPanel(new FlowLayout());
  decompiledScrollPane=new JScrollPane(decompiledTextArea);
  JPanel iconDecPanel=new JPanel();
  iconDecPanel.setLayout(new BoxLayout(iconDecPanel,BoxLayout.Y_AXIS));
  JPanel iconsPanel=new JPanel();
  iconsPanel.setLayout(new BoxLayout(iconsPanel,BoxLayout.X_AXIS));
  JButton newTraitButton=new JButton(View.getIcon(""String_Node_Str""));
  newTraitButton.setMargin(new Insets(5,5,5,5));
  newTraitButton.addActionListener(this);
  newTraitButton.setActionCommand(ACTION_ADD_TRAIT);
  newTraitButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  iconsPanel.add(newTraitButton);
  scriptNameLabel=new JLabel(""String_Node_Str"");
  scriptNameLabel.setAlignmentX(0);
  iconsPanel.setAlignmentX(0);
  decompiledScrollPane.setAlignmentX(0);
  iconDecPanel.add(scriptNameLabel);
  iconDecPanel.add(iconsPanel);
  iconDecPanel.add(decompiledScrollPane);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(searchPanel,BorderLayout.NORTH);
  decPanel.add(iconDecPanel,BorderLayout.CENTER);
  detailPanel=new DetailPanel(this);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  panB.add(decPanel,BorderLayout.CENTER);
  panB.add(decLabel,BorderLayout.NORTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panB,detailPanel);
  splitPane.setResizeWeight(0.5);
  splitPane.setContinuousLayout(true);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.guiAvm2SplitPaneDividerLocation.set((int)pce.getNewValue());
    }
  }
);
  decompiledTextArea.setContentType(""String_Node_Str"");
  decompiledTextArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledTextArea.getFont().getSize()));
  JPanel pan2=new JPanel();
  pan2.setLayout(new BorderLayout());
  pan2.add((abcComboBox=new JComboBox(new ABCComboBoxModel(new ArrayList<ABCContainerTag>()))),BorderLayout.NORTH);
  navigator=new TraitsList(this);
  navPanel=new JPanel(new BorderLayout());
  JPanel navIconsPanel=new JPanel();
  navIconsPanel.setLayout(new BoxLayout(navIconsPanel,BoxLayout.X_AXIS));
  final JToggleButton sortButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  sortButton.setMargin(new Insets(3,3,3,3));
  navIconsPanel.add(sortButton);
  navPanel.add(navIconsPanel,BorderLayout.SOUTH);
  navPanel.add(new JScrollPane(navigator),BorderLayout.CENTER);
  sortButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      navigator.setSorted(sortButton.isSelected());
      navigator.updateUI();
    }
  }
);
  Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  filterField.setActionCommand(ACTION_FILTER_SCRIPT);
  filterField.addActionListener(this);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  JPanel treePanel=new JPanel();
  treePanel.setLayout(new BorderLayout());
  treePanel.add(new JScrollPane(classTree=new ClassesListTree(this)),BorderLayout.CENTER);
  JPanel filterPanel=new JPanel();
  filterPanel.setLayout(new BorderLayout());
  filterPanel.add(filterField,BorderLayout.CENTER);
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(ACTION_SEARCH_PREV);
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(ACTION_SEARCH_NEXT);
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(ACTION_SEARCH_CANCEL);
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  searchPanel.setVisible(false);
  JLabel picLabel=new JLabel(View.getIcon(""String_Node_Str""));
  filterPanel.add(picLabel,BorderLayout.EAST);
  treePanel.add(filterPanel,BorderLayout.NORTH);
  tabbedPane=new JTabbedPane();
  tabbedPane.addTab(AppStrings.translate(""String_Node_Str""),navPanel);
  abcComboBox.addItemListener(this);
  add(splitPane,BorderLayout.CENTER);
  JPanel panConstants=new JPanel();
  panConstants.setLayout(new BorderLayout());
  constantTypeList=new JComboBox(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  constantTable=new JTable();
  if (abc != null) {
    autoResizeColWidth(constantTable,new UIntTableModel(abc));
  }
  constantTable.setAutoCreateRowSorter(true);
  final ABCPanel t=this;
  constantTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        if (constantTypeList.getSelectedIndex() == 7) {
          int rowIndex=constantTable.getSelectedRow();
          if (rowIndex == -1) {
            return;
          }
          int multinameIndex=constantTable.convertRowIndexToModel(rowIndex);
          if (multinameIndex > 0) {
            UsageFrame usageFrame=new UsageFrame(t.list,abc,multinameIndex,t);
            usageFrame.setVisible(true);
          }
        }
      }
    }
  }
);
  constantTypeList.addItemListener(this);
  panConstants.add(constantTypeList,BorderLayout.NORTH);
  panConstants.add(new JScrollPane(constantTable),BorderLayout.CENTER);
  tabbedPane.addTab(AppStrings.translate(""String_Node_Str""),panConstants);
}","@SuppressWarnings(""String_Node_Str"") public ABCPanel(MainFramePanel mainFramePanel){
  DefaultSyntaxKit.initKit();
  this.mainFramePanel=mainFramePanel;
  setLayout(new BorderLayout());
  decompiledTextArea=new DecompiledEditorPane(this);
  searchPanel=new JPanel(new FlowLayout());
  decompiledScrollPane=new JScrollPane(decompiledTextArea);
  JPanel iconDecPanel=new JPanel();
  iconDecPanel.setLayout(new BoxLayout(iconDecPanel,BoxLayout.Y_AXIS));
  JPanel iconsPanel=new JPanel();
  iconsPanel.setLayout(new BoxLayout(iconsPanel,BoxLayout.X_AXIS));
  JButton newTraitButton=new JButton(View.getIcon(""String_Node_Str""));
  newTraitButton.setMargin(new Insets(5,5,5,5));
  newTraitButton.addActionListener(this);
  newTraitButton.setActionCommand(ACTION_ADD_TRAIT);
  newTraitButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
  iconsPanel.add(newTraitButton);
  scriptNameLabel=new JLabel(""String_Node_Str"");
  scriptNameLabel.setAlignmentX(0);
  iconsPanel.setAlignmentX(0);
  decompiledScrollPane.setAlignmentX(0);
  iconDecPanel.add(scriptNameLabel);
  iconDecPanel.add(iconsPanel);
  iconDecPanel.add(decompiledScrollPane);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(searchPanel,BorderLayout.NORTH);
  decPanel.add(iconDecPanel,BorderLayout.CENTER);
  detailPanel=new DetailPanel(this);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  panB.add(decPanel,BorderLayout.CENTER);
  panB.add(decLabel,BorderLayout.NORTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panB,detailPanel);
  splitPane.setResizeWeight(0.5);
  splitPane.setContinuousLayout(true);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.guiAvm2SplitPaneDividerLocation.set((int)pce.getNewValue());
    }
  }
);
  decompiledTextArea.setContentType(""String_Node_Str"");
  decompiledTextArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledTextArea.getFont().getSize()));
  JPanel pan2=new JPanel();
  pan2.setLayout(new BorderLayout());
  pan2.add((abcComboBox=new JComboBox(new ABCComboBoxModel(new ArrayList<ABCContainerTag>()))),BorderLayout.NORTH);
  navigator=new TraitsList(this);
  navPanel=new JPanel(new BorderLayout());
  JPanel navIconsPanel=new JPanel();
  navIconsPanel.setLayout(new BoxLayout(navIconsPanel,BoxLayout.X_AXIS));
  final JToggleButton sortButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  sortButton.setMargin(new Insets(3,3,3,3));
  navIconsPanel.add(sortButton);
  navPanel.add(navIconsPanel,BorderLayout.SOUTH);
  navPanel.add(new JScrollPane(navigator),BorderLayout.CENTER);
  sortButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      navigator.setSorted(sortButton.isSelected());
      navigator.updateUI();
    }
  }
);
  Main.startWork(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str"");
  filterField.setActionCommand(ACTION_FILTER_SCRIPT);
  filterField.addActionListener(this);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  JPanel treePanel=new JPanel();
  treePanel.setLayout(new BorderLayout());
  treePanel.add(new JScrollPane(classTree=new ClassesListTree(this)),BorderLayout.CENTER);
  JPanel filterPanel=new JPanel();
  filterPanel.setLayout(new BorderLayout());
  filterPanel.add(filterField,BorderLayout.CENTER);
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(ACTION_SEARCH_PREV);
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(ACTION_SEARCH_NEXT);
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(ACTION_SEARCH_CANCEL);
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(AppStrings.translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(AppStrings.translate(""String_Node_Str"") + ""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  searchPanel.setVisible(false);
  JLabel picLabel=new JLabel(View.getIcon(""String_Node_Str""));
  filterPanel.add(picLabel,BorderLayout.EAST);
  treePanel.add(filterPanel,BorderLayout.NORTH);
  tabbedPane=new JTabbedPane();
  tabbedPane.addTab(AppStrings.translate(""String_Node_Str""),navPanel);
  abcComboBox.addItemListener(this);
  add(splitPane,BorderLayout.CENTER);
  JPanel panConstants=new JPanel();
  panConstants.setLayout(new BorderLayout());
  constantTypeList=new JComboBox(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  constantTable=new JTable();
  if (abc != null) {
    autoResizeColWidth(constantTable,new UIntTableModel(abc));
  }
  constantTable.setAutoCreateRowSorter(true);
  final ABCPanel t=this;
  constantTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        if (constantTypeList.getSelectedIndex() == 7) {
          int rowIndex=constantTable.getSelectedRow();
          if (rowIndex == -1) {
            return;
          }
          int multinameIndex=constantTable.convertRowIndexToModel(rowIndex);
          if (multinameIndex > 0) {
            UsageFrame usageFrame=new UsageFrame(t.swf.abcList,abc,multinameIndex,t);
            usageFrame.setVisible(true);
          }
        }
      }
    }
  }
);
  constantTypeList.addItemListener(this);
  panConstants.add(constantTypeList,BorderLayout.NORTH);
  panConstants.add(new JScrollPane(constantTable),BorderLayout.CENTER);
  tabbedPane.addTab(AppStrings.translate(""String_Node_Str""),panConstants);
}",0.999321318150969
61935,"public void updateSearchPos(){
  searchPos.setText((foundPos + 1) + ""String_Node_Str"" + found.size());
  ScriptPack pack=found.get(foundPos);
  setAbc(pack.abc);
  decompiledTextArea.setScript(pack,list);
  hilightScript(found.get(foundPos));
  decompiledTextArea.setCaretPosition(0);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      DocumentSearchData dsd=DocumentSearchData.getFromEditor(decompiledTextArea);
      dsd.setPattern(searchFor,searchRegexp,searchIgnoreCase);
      dsd.showQuickFindDialogEx(decompiledTextArea,searchIgnoreCase,searchRegexp);
    }
  }
);
}","public void updateSearchPos(){
  searchPos.setText((foundPos + 1) + ""String_Node_Str"" + found.size());
  ScriptPack pack=found.get(foundPos);
  setAbc(pack.abc);
  decompiledTextArea.setScript(pack,swf.abcList);
  hilightScript(found.get(foundPos));
  decompiledTextArea.setCaretPosition(0);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      DocumentSearchData dsd=DocumentSearchData.getFromEditor(decompiledTextArea);
      dsd.setPattern(searchFor,searchRegexp,searchIgnoreCase);
      dsd.showQuickFindDialogEx(decompiledTextArea,searchIgnoreCase,searchRegexp);
    }
  }
);
}",0.992616899097621
61936,"@Override public Void doInBackground() throws Exception {
  decompiledTextArea.cacheScriptPack(item.value,list);
  if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
    found.add(item.value);
    foundPath.add(item.key);
  }
  return null;
}","@Override public Void doInBackground() throws Exception {
  decompiledTextArea.cacheScriptPack(item.value,swf.abcList);
  if (pat.matcher(decompiledTextArea.getCachedText(item.value)).find()) {
    found.add(item.value);
    foundPath.add(item.key);
  }
  return null;
}",0.9793621013133208
61937,"public void switchAbc(int index){
  listIndex=index;
  classTree.setSwf(swf);
  if (index != -1) {
    this.abc=list.get(index).getABC();
  }
  updateConstList();
}","public void switchAbc(int index){
  listIndex=index;
  classTree.setSwf(swf);
  if (index != -1) {
    this.abc=swf.abcList.get(index).getABC();
  }
  updateConstList();
}",0.9731343283582088
61938,"@SuppressWarnings(""String_Node_Str"") public void clearSwf(){
  this.list=null;
  this.swf=null;
  this.abc=null;
  constantTable.setModel(new DefaultTableModel());
  classTree.clearDoABCTags();
  abcComboBox.setModel(new ABCComboBoxModel(new ArrayList<ABCContainerTag>()));
  navigator.clearABC();
}","@SuppressWarnings(""String_Node_Str"") public void clearSwf(){
  this.swf=null;
  this.abc=null;
  constantTable.setModel(new DefaultTableModel());
  classTree.clearDoABCTags();
  abcComboBox.setModel(new ABCComboBoxModel(new ArrayList<ABCContainerTag>()));
  navigator.clearABC();
}",0.9689655172413794
61939,"@Override public void mouseClicked(MouseEvent e){
  if (e.getClickCount() == 2) {
    if (constantTypeList.getSelectedIndex() == 7) {
      int rowIndex=constantTable.getSelectedRow();
      if (rowIndex == -1) {
        return;
      }
      int multinameIndex=constantTable.convertRowIndexToModel(rowIndex);
      if (multinameIndex > 0) {
        UsageFrame usageFrame=new UsageFrame(t.list,abc,multinameIndex,t);
        usageFrame.setVisible(true);
      }
    }
  }
}","@Override public void mouseClicked(MouseEvent e){
  if (e.getClickCount() == 2) {
    if (constantTypeList.getSelectedIndex() == 7) {
      int rowIndex=constantTable.getSelectedRow();
      if (rowIndex == -1) {
        return;
      }
      int multinameIndex=constantTable.convertRowIndexToModel(rowIndex);
      if (multinameIndex > 0) {
        UsageFrame usageFrame=new UsageFrame(t.swf.abcList,abc,multinameIndex,t);
        usageFrame.setVisible(true);
      }
    }
  }
}",0.9905561385099684
61940,"public void setSwf(SWF swf){
  if (swf != this.swf) {
    this.swf=swf;
    ClassesListTreeModel model=new ClassesListTreeModel(swf);
    this.swf.classTreeModel=model;
    setModel(model);
  }
}","public void setSwf(SWF swf){
  if (swf != this.swf) {
    this.swf=swf;
    if (swf.classTreeModel == null) {
      swf.classTreeModel=new ClassesListTreeModel(swf);
    }
    setModel(swf.classTreeModel);
  }
}",0.5615763546798029
61941,"@Override public void actionPerformed(ActionEvent e){
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    setEditMode(true);
    methodTraitPanel.methodCodePanel.focusEditor();
  }
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    setEditMode(false);
    abcPanel.decompiledTextArea.resetEditing();
  }
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    if (cardMap.get(selectedCard) instanceof TraitDetail) {
      if (((TraitDetail)cardMap.get(selectedCard)).save()) {
        int lasttrait=abcPanel.decompiledTextArea.lastTraitIndex;
        abcPanel.decompiledTextArea.reloadClass();
        abcPanel.decompiledTextArea.gotoTrait(lasttrait);
        View.showMessageDialog(this,AppStrings.translate(""String_Node_Str""));
      }
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    setEditMode(true);
    methodTraitPanel.methodCodePanel.focusEditor();
  }
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    setEditMode(false);
    abcPanel.decompiledTextArea.resetEditing();
  }
  if (e.getActionCommand().equals(""String_Node_Str"")) {
    if (cardMap.get(selectedCard) instanceof TraitDetail) {
      if (((TraitDetail)cardMap.get(selectedCard)).save()) {
        CancellableWorker worker=new CancellableWorker(){
          @Override public Void doInBackground() throws Exception {
            int lasttrait=abcPanel.decompiledTextArea.lastTraitIndex;
            abcPanel.decompiledTextArea.reloadClass();
            abcPanel.decompiledTextArea.gotoTrait(lasttrait);
            return null;
          }
          @Override protected void done(){
            View.showMessageDialog(null,AppStrings.translate(""String_Node_Str""));
          }
        }
;
        worker.execute();
      }
    }
  }
}",0.8454746136865342
61942,"public static boolean reloadSWFs(){
  CancellableWorker.cancelBackgroundThreads();
  mainFrame.closeAll();
  if (Main.sourceInfos.isEmpty()) {
    Cache.clearAll();
    System.gc();
    showModeFrame();
    return true;
  }
 else {
    SWFSourceInfo[] sourceInfosCopy=new SWFSourceInfo[sourceInfos.size()];
    sourceInfos.toArray(sourceInfosCopy);
    sourceInfos.clear();
    openFile(sourceInfosCopy);
    return true;
  }
}","public static boolean reloadSWFs(){
  CancellableWorker.cancelBackgroundThreads();
  if (mainFrame != null) {
    mainFrame.closeAll();
  }
  if (Main.sourceInfos.isEmpty()) {
    Cache.clearAll();
    System.gc();
    showModeFrame();
    return true;
  }
 else {
    SWFSourceInfo[] sourceInfosCopy=new SWFSourceInfo[sourceInfos.size()];
    sourceInfos.toArray(sourceInfosCopy);
    sourceInfos.clear();
    openFile(sourceInfosCopy);
    return true;
  }
}",0.9627959413754228
61943,"public MainFrame(){
  super();
  try {
    flashPanel=new FlashPlayerPanel(this);
  }
 catch (  FlashUnsupportedException fue) {
  }
  boolean externalFlashPlayerUnavailable=flashPanel == null;
  mainRibbon=new MainFrameRibbon(this,getRibbon(),externalFlashPlayerUnavailable);
  int w=Configuration.guiWindowWidth.get();
  int h=Configuration.guiWindowHeight.get();
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  if (w > dim.width) {
    w=dim.width;
  }
  if (h > dim.height) {
    h=dim.height;
  }
  setSize(w,h);
  boolean maximizedHorizontal=Configuration.guiWindowMaximizedHorizontal.get();
  boolean maximizedVertical=Configuration.guiWindowMaximizedVertical.get();
  int state=0;
  if (maximizedHorizontal) {
    state|=JFrame.MAXIMIZED_HORIZ;
  }
  if (maximizedVertical) {
    state|=JFrame.MAXIMIZED_VERT;
  }
  setExtendedState(state);
  View.setWindowIcon(this);
  addWindowStateListener(new WindowStateListener(){
    @Override public void windowStateChanged(    WindowEvent e){
      int state=e.getNewState();
      Configuration.guiWindowMaximizedHorizontal.set((state & JFrame.MAXIMIZED_HORIZ) == JFrame.MAXIMIZED_HORIZ);
      Configuration.guiWindowMaximizedVertical.set((state & JFrame.MAXIMIZED_VERT) == JFrame.MAXIMIZED_VERT);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int state=getExtendedState();
      if ((state & JFrame.MAXIMIZED_HORIZ) == 0) {
        Configuration.guiWindowWidth.set(getWidth());
      }
      if ((state & JFrame.MAXIMIZED_VERT) == 0) {
        Configuration.guiWindowHeight.set(getHeight());
      }
    }
  }
);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      if (Main.proxyFrame != null) {
        if (Main.proxyFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromMemoryFrame != null) {
        if (Main.loadFromMemoryFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromCacheFrame != null) {
        if (Main.loadFromCacheFrame.isVisible()) {
          return;
        }
      }
      Main.exit();
    }
  }
);
  setTitle(ApplicationInfo.applicationVerName);
  swfs=new ArrayList<>();
  java.awt.Container cnt=getContentPane();
  cnt.setLayout(new BorderLayout());
  cnt.add(getRibbon(),BorderLayout.NORTH);
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  tagTree=new JTree((TreeModel)null);
  tagTree.setRootVisible(false);
  tagTree.addTreeSelectionListener(this);
  tagTree.setBackground(Color.white);
  tagTree.setUI(new BasicTreeUI(){
    @Override public void paint(    Graphics g,    JComponent c){
      setHashColor(Color.gray);
      super.paint(g,c);
    }
  }
);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  createContextMenu();
  TreeCellRenderer tcr=new DefaultTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      Object val=value;
      if (val instanceof TagNode) {
        val=((TagNode)val).tag;
      }
      TagType type=getTagType(val);
      if (val instanceof SWFRoot) {
        setIcon(View.getIcon(""String_Node_Str""));
      }
 else       if (type != null) {
        if (type == TagType.FOLDER && expanded) {
          type=TagType.FOLDER_OPEN;
        }
        String tagTypeStr=type.toString().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"");
        setIcon(View.getIcon(tagTypeStr + ""String_Node_Str""));
      }
 else {
      }
      String tos=value.toString();
      int sw=getFontMetrics(getFont()).stringWidth(tos);
      setPreferredSize(new Dimension(18 + sw,getPreferredSize().height));
      setUI(new BasicLabelUI());
      setOpaque(false);
      setBackgroundNonSelectionColor(Color.white);
      return this;
    }
  }
;
  tagTree.setCellRenderer(tcr);
  statusPanel=new MainFrameStatusPanel(this);
  cnt.add(statusPanel,BorderLayout.SOUTH);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  fontPanel=new FontPanel(this);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  textValue.setContentType(""String_Node_Str"");
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.setDividerLocation(300);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(ACTION_SELECT_COLOR);
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  displayPanel.add(createImagesCard(),CARDIMAGEPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.setActionCommand(ABCPanel.ACTION_FILTER_SCRIPT);
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  welcomePanel=createWelcomePanel();
  cnt.add(welcomePanel,BorderLayout.CENTER);
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  View.centerScreen(this);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  updateUi();
  enableDrop(true);
}","public MainFrame(){
  super();
  try {
    flashPanel=new FlashPlayerPanel(this);
  }
 catch (  FlashUnsupportedException fue) {
  }
  boolean externalFlashPlayerUnavailable=flashPanel == null;
  mainRibbon=new MainFrameRibbon(this,getRibbon(),externalFlashPlayerUnavailable);
  int w=Configuration.guiWindowWidth.get();
  int h=Configuration.guiWindowHeight.get();
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  if (w > dim.width) {
    w=dim.width;
  }
  if (h > dim.height) {
    h=dim.height;
  }
  setSize(w,h);
  boolean maximizedHorizontal=Configuration.guiWindowMaximizedHorizontal.get();
  boolean maximizedVertical=Configuration.guiWindowMaximizedVertical.get();
  int state=0;
  if (maximizedHorizontal) {
    state|=JFrame.MAXIMIZED_HORIZ;
  }
  if (maximizedVertical) {
    state|=JFrame.MAXIMIZED_VERT;
  }
  setExtendedState(state);
  View.setWindowIcon(this);
  addWindowStateListener(new WindowStateListener(){
    @Override public void windowStateChanged(    WindowEvent e){
      int state=e.getNewState();
      Configuration.guiWindowMaximizedHorizontal.set((state & JFrame.MAXIMIZED_HORIZ) == JFrame.MAXIMIZED_HORIZ);
      Configuration.guiWindowMaximizedVertical.set((state & JFrame.MAXIMIZED_VERT) == JFrame.MAXIMIZED_VERT);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int state=getExtendedState();
      if ((state & JFrame.MAXIMIZED_HORIZ) == 0) {
        Configuration.guiWindowWidth.set(getWidth());
      }
      if ((state & JFrame.MAXIMIZED_VERT) == 0) {
        Configuration.guiWindowHeight.set(getHeight());
      }
    }
  }
);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      if (Main.proxyFrame != null) {
        if (Main.proxyFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromMemoryFrame != null) {
        if (Main.loadFromMemoryFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromCacheFrame != null) {
        if (Main.loadFromCacheFrame.isVisible()) {
          return;
        }
      }
      Main.exit();
    }
  }
);
  setTitle(ApplicationInfo.applicationVerName);
  swfs=new ArrayList<>();
  java.awt.Container cnt=getContentPane();
  cnt.setLayout(new BorderLayout());
  cnt.add(getRibbon(),BorderLayout.NORTH);
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  tagTree=new JTree((TreeModel)null);
  tagTree.setRootVisible(false);
  tagTree.addTreeSelectionListener(this);
  tagTree.setBackground(Color.white);
  tagTree.setUI(new BasicTreeUI(){
    @Override public void paint(    Graphics g,    JComponent c){
      setHashColor(Color.gray);
      super.paint(g,c);
    }
  }
);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  createContextMenu();
  TreeCellRenderer tcr=new DefaultTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      Object val=value;
      if (val instanceof TagNode) {
        val=((TagNode)val).tag;
      }
      TagType type=getTagType(val);
      if (val instanceof SWFRoot) {
        setIcon(View.getIcon(""String_Node_Str""));
      }
 else       if (type != null) {
        if (type == TagType.FOLDER && expanded) {
          type=TagType.FOLDER_OPEN;
        }
        String tagTypeStr=type.toString().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"");
        setIcon(View.getIcon(tagTypeStr + ""String_Node_Str""));
      }
 else {
      }
      String tos=value.toString();
      int sw=getFontMetrics(getFont()).stringWidth(tos);
      setPreferredSize(new Dimension(18 + sw,getPreferredSize().height));
      setUI(new BasicLabelUI());
      setOpaque(false);
      setBackgroundNonSelectionColor(Color.white);
      return this;
    }
  }
;
  tagTree.setCellRenderer(tcr);
  statusPanel=new MainFrameStatusPanel(this);
  cnt.add(statusPanel,BorderLayout.SOUTH);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(ACTION_SAVE_TEXT);
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(ACTION_EDIT_TEXT);
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(ACTION_CANCEL_TEXT);
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  fontPanel=new FontPanel(this);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  textValue.setContentType(""String_Node_Str"");
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.setDividerLocation(300);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(ACTION_SELECT_COLOR);
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  displayPanel.add(createImagesCard(),CARDIMAGEPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.setActionCommand(ABCPanel.ACTION_FILTER_SCRIPT);
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  welcomePanel=createWelcomePanel();
  cnt.add(welcomePanel,BorderLayout.CENTER);
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  CardLayout cl3=new CardLayout();
  contentPanel=new JPanel(cl3);
  contentPanel.add(welcomePanel,WELCOME_PANEL);
  contentPanel.add(splitPane1,SPLIT_PANE1);
  cnt.add(contentPanel);
  cl3.show(contentPanel,WELCOME_PANEL);
  View.centerScreen(this);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  updateUi();
  enableDrop(true);
}",0.9923166632366056
61944,"public void close(SWF swf){
  swfs.remove(swf);
  if (abcPanel != null && abcPanel.swf == swf) {
    abcPanel.clearSwf();
  }
  actionPanel.clearSource();
  oldValue=null;
  updateUi();
  updateTagTree();
}","public void close(SWF swf){
  swfs.remove(swf);
  if (abcPanel != null && abcPanel.swf == swf) {
    abcPanel.clearSwf();
  }
  if (actionPanel != null) {
    actionPanel.clearSource();
  }
  oldValue=null;
  updateUi();
  updateTagTree();
}",0.9217002237136466
61945,"private void createContextMenu(){
  final JPopupMenu contextPopupMenu=new JPopupMenu();
  final JMenuItem removeMenuItem=new JMenuItem(translate(""String_Node_Str""));
  removeMenuItem.addActionListener(this);
  removeMenuItem.setActionCommand(ACTION_REMOVE_ITEM);
  final JMenuItem exportSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  exportSelectionMenuItem.setActionCommand(MainFrameRibbon.ACTION_EXPORT_SEL);
  exportSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(exportSelectionMenuItem);
  final JMenuItem replaceImageSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  replaceImageSelectionMenuItem.setActionCommand(ACTION_REPLACE_IMAGE);
  replaceImageSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(replaceImageSelectionMenuItem);
  final JMenuItem replaceBinarySelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  replaceBinarySelectionMenuItem.setActionCommand(ACTION_REPLACE_BINARY);
  replaceBinarySelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(replaceBinarySelectionMenuItem);
  final JMenuItem closeSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  closeSelectionMenuItem.setActionCommand(ACTION_CLOSE_SWF);
  closeSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(closeSelectionMenuItem);
  contextPopupMenu.add(removeMenuItem);
  tagTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (SwingUtilities.isRightMouseButton(e)) {
        int row=tagTree.getClosestRowForLocation(e.getX(),e.getY());
        int[] selectionRows=tagTree.getSelectionRows();
        if (!Helper.contains(selectionRows,row)) {
          tagTree.setSelectionRow(row);
        }
        TreePath[] paths=tagTree.getSelectionPaths();
        if (paths == null || paths.length == 0) {
          return;
        }
        boolean allSelectedIsTag=true;
        for (        TreePath treePath : paths) {
          Object tagObj=treePath.getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (!(tag instanceof Tag)) {
              allSelectedIsTag=false;
              break;
            }
          }
        }
        replaceImageSelectionMenuItem.setVisible(false);
        replaceBinarySelectionMenuItem.setVisible(false);
        if (paths.length == 1) {
          Object tagObj=paths[0].getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (tag instanceof ImageTag && ((ImageTag)tag).importSupported()) {
              replaceImageSelectionMenuItem.setVisible(true);
            }
            if (tag instanceof DefineBinaryDataTag) {
              replaceBinarySelectionMenuItem.setVisible(true);
            }
          }
          if (tagObj instanceof SWFRoot) {
            closeSelectionMenuItem.setVisible(true);
          }
        }
        removeMenuItem.setVisible(allSelectedIsTag);
        contextPopupMenu.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
}","private void createContextMenu(){
  final JPopupMenu contextPopupMenu=new JPopupMenu();
  final JMenuItem removeMenuItem=new JMenuItem(translate(""String_Node_Str""));
  removeMenuItem.addActionListener(this);
  removeMenuItem.setActionCommand(ACTION_REMOVE_ITEM);
  final JMenuItem exportSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  exportSelectionMenuItem.setActionCommand(MainFrameRibbon.ACTION_EXPORT_SEL);
  exportSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(exportSelectionMenuItem);
  final JMenuItem replaceImageSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  replaceImageSelectionMenuItem.setActionCommand(ACTION_REPLACE_IMAGE);
  replaceImageSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(replaceImageSelectionMenuItem);
  final JMenuItem replaceBinarySelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  replaceBinarySelectionMenuItem.setActionCommand(ACTION_REPLACE_BINARY);
  replaceBinarySelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(replaceBinarySelectionMenuItem);
  final JMenuItem closeSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  closeSelectionMenuItem.setActionCommand(ACTION_CLOSE_SWF);
  closeSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(closeSelectionMenuItem);
  contextPopupMenu.add(removeMenuItem);
  tagTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (SwingUtilities.isRightMouseButton(e)) {
        int row=tagTree.getClosestRowForLocation(e.getX(),e.getY());
        int[] selectionRows=tagTree.getSelectionRows();
        if (!Helper.contains(selectionRows,row)) {
          tagTree.setSelectionRow(row);
        }
        TreePath[] paths=tagTree.getSelectionPaths();
        if (paths == null || paths.length == 0) {
          return;
        }
        boolean allSelectedIsTag=true;
        for (        TreePath treePath : paths) {
          Object tagObj=treePath.getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (!(tag instanceof Tag)) {
              allSelectedIsTag=false;
              break;
            }
          }
 else {
            allSelectedIsTag=false;
          }
        }
        replaceImageSelectionMenuItem.setVisible(false);
        replaceBinarySelectionMenuItem.setVisible(false);
        if (paths.length == 1) {
          Object tagObj=paths[0].getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (tag instanceof ImageTag && ((ImageTag)tag).importSupported()) {
              replaceImageSelectionMenuItem.setVisible(true);
            }
            if (tag instanceof DefineBinaryDataTag) {
              replaceBinarySelectionMenuItem.setVisible(true);
            }
          }
          if (tagObj instanceof SWFRoot) {
            closeSelectionMenuItem.setVisible(true);
          }
        }
        removeMenuItem.setVisible(allSelectedIsTag);
        contextPopupMenu.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
}",0.9910771191841936
61946,"private void updateUi(){
  if (!isWelcomeScreen) {
    java.awt.Container cnt=getContentPane();
    cnt.remove(splitPane1);
    cnt.add(welcomePanel,BorderLayout.CENTER);
    isWelcomeScreen=true;
  }
  if (swfs.isEmpty()) {
    mainRibbon.updateComponets(null,null);
  }
 else {
    SWF swf=swfs.get(0);
    updateUi(swf);
  }
}","private void updateUi(){
  if (!isWelcomeScreen) {
    CardLayout cl=(CardLayout)(contentPanel.getLayout());
    cl.show(contentPanel,WELCOME_PANEL);
    isWelcomeScreen=true;
  }
  if (swfs.isEmpty()) {
    mainRibbon.updateComponets(null,null);
  }
 else {
    SWF swf=swfs.get(0);
    updateUi(swf);
  }
}",0.7032967032967034
61947,"@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  MethodBody body=abc.findBody(methodIndex);
  writer.append(""String_Node_Str"" + (!functionName.isEmpty() ? ""String_Node_Str"" + functionName : ""String_Node_Str""));
  writer.startMethod(methodIndex);
  writer.appendNoHilight(""String_Node_Str"");
  methodInfo[methodIndex].getParamStr(writer,constants,body,abc,fullyQualifiedNames);
  writer.appendNoHilight(""String_Node_Str"");
  methodInfo[methodIndex].getReturnTypeStr(writer,constants,fullyQualifiedNames);
  writer.endMethod();
  writer.newLine();
  writer.append(""String_Node_Str"").newLine();
  if (body != null) {
    if (writer instanceof NulWriter) {
      body.convert(path + ""String_Node_Str"",ExportMode.SOURCE,isStatic,scriptIndex,classIndex,abc,null,constants,methodInfo,new Stack<GraphTargetItem>(),false,fullyQualifiedNames,null,false);
    }
 else {
      body.toString(path + ""String_Node_Str"",ExportMode.SOURCE,isStatic,scriptIndex,classIndex,abc,null,constants,methodInfo,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,null);
    }
  }
  writer.append(""String_Node_Str"");
  return writer;
}","@Override protected GraphTextWriter appendTo(GraphTextWriter writer,LocalData localData) throws InterruptedException {
  MethodBody body=abc.findBody(methodIndex);
  writer.append(""String_Node_Str"" + (!functionName.isEmpty() ? ""String_Node_Str"" + functionName : ""String_Node_Str""));
  writer.startMethod(methodIndex);
  writer.appendNoHilight(""String_Node_Str"");
  methodInfo[methodIndex].getParamStr(writer,constants,body,abc,fullyQualifiedNames);
  writer.appendNoHilight(""String_Node_Str"");
  methodInfo[methodIndex].getReturnTypeStr(writer,constants,fullyQualifiedNames);
  writer.endMethod();
  writer.newLine();
  writer.append(""String_Node_Str"").newLine();
  if (body != null) {
    if (writer instanceof NulWriter) {
      body.convert(path + ""String_Node_Str"",ExportMode.SOURCE,isStatic,scriptIndex,classIndex,abc,null,constants,methodInfo,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,null,false);
    }
 else {
      body.toString(path + ""String_Node_Str"",ExportMode.SOURCE,isStatic,scriptIndex,classIndex,abc,null,constants,methodInfo,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,null);
    }
  }
  writer.append(""String_Node_Str"");
  return writer;
}",0.9970649895178196
61948,"@Override public Void call() throws InterruptedException {
  MethodBody converted=convertMethodBody(path,isStatic,scriptIndex,classIndex,abc,trait,constants,method_info,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits);
  HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
  convertedItems=converted.code.toGraphTargetItems(path,isStatic,scriptIndex,classIndex,abc,constants,method_info,converted,localRegNames,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits,Graph.SOP_USE_STATIC,new HashMap<Integer,Integer>(),converted.code.visitCode(converted));
  Graph.graphToString(convertedItems,new NulWriter(),LocalData.create(constants,localRegNames,fullyQualifiedNames));
  return null;
}","@Override public Void call() throws InterruptedException {
  MethodBody converted=convertMethodBody(path,isStatic,scriptIndex,classIndex,abc,trait,constants,method_info,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits);
  HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
  convertedItems=converted.code.toGraphTargetItems(path,isStatic,scriptIndex,classIndex,abc,constants,method_info,converted,localRegNames,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits,Graph.SOP_USE_STATIC,new HashMap<Integer,Integer>(),converted.code.visitCode(converted));
  Graph.graphToString(convertedItems,writer,LocalData.create(constants,localRegNames,fullyQualifiedNames));
  return null;
}",0.986703988803359
61949,"public GraphTextWriter toString(final String path,ExportMode exportMode,final boolean isStatic,final int scriptIndex,final int classIndex,final ABC abc,final Trait trait,final ConstantPool constants,final MethodInfo[] method_info,final Stack<GraphTargetItem> scopeStack,final boolean isStaticInitializer,final GraphTextWriter writer,final List<String> fullyQualifiedNames,final Traits initTraits) throws InterruptedException {
  if (exportMode != ExportMode.SOURCE) {
    writer.indent();
    code.toASMSource(constants,trait,method_info[this.method_info],this,exportMode,writer);
    writer.unindent();
  }
 else {
    if (!Configuration.decompile.get()) {
      writer.indent();
      writer.startMethod(this.method_info);
      writer.appendNoHilight(""String_Node_Str"");
      writer.endMethod();
      writer.unindent();
      return writer;
    }
    writer.indent();
    int timeout=Configuration.decompilationTimeoutSingleMethod.get();
    if (convertException == null) {
      HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
      writer.startMethod(this.method_info);
      Graph.graphToString(convertedItems,writer,LocalData.create(constants,localRegNames,fullyQualifiedNames));
      writer.endMethod();
    }
 else     if (convertException instanceof TimeoutException) {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"" + Helper.formatTimeToText(timeout) + ""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
    }
 else {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"" + convertException.getClass().getSimpleName()).newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
    }
    writer.unindent();
  }
  return writer;
}","public GraphTextWriter toString(final String path,ExportMode exportMode,final boolean isStatic,final int scriptIndex,final int classIndex,final ABC abc,final Trait trait,final ConstantPool constants,final MethodInfo[] method_info,final Stack<GraphTargetItem> scopeStack,final boolean isStaticInitializer,final GraphTextWriter writer,final List<String> fullyQualifiedNames,final Traits initTraits) throws InterruptedException {
  if (exportMode != ExportMode.SOURCE) {
    writer.indent();
    code.toASMSource(constants,trait,method_info[this.method_info],this,exportMode,writer);
    writer.unindent();
  }
 else {
    if (!Configuration.decompile.get()) {
      writer.indent();
      writer.startMethod(this.method_info);
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.endMethod();
      writer.unindent();
      return writer;
    }
    writer.indent();
    int timeout=Configuration.decompilationTimeoutSingleMethod.get();
    if (convertException == null) {
      HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
      writer.startMethod(this.method_info);
      Graph.graphToString(convertedItems,writer,LocalData.create(constants,localRegNames,fullyQualifiedNames));
      writer.endMethod();
    }
 else     if (convertException instanceof TimeoutException) {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"" + Helper.formatTimeToText(timeout) + ""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
    }
 else {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"" + convertException.getClass().getSimpleName()).newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
      writer.appendNoHilight(""String_Node_Str"").newLine();
    }
    writer.unindent();
  }
  return writer;
}",0.9978503869303526
61950,"public void convert(final String path,ExportMode exportMode,final boolean isStatic,final int scriptIndex,final int classIndex,final ABC abc,final Trait trait,final ConstantPool constants,final MethodInfo[] method_info,final Stack<GraphTargetItem> scopeStack,final boolean isStaticInitializer,final List<String> fullyQualifiedNames,final Traits initTraits,boolean firstLevel) throws InterruptedException {
  if (debugMode) {
    System.err.println(""String_Node_Str"" + path);
  }
  if (exportMode == ExportMode.SOURCE) {
    int timeout=Configuration.decompilationTimeoutSingleMethod.get();
    try {
      Callable<Void> callable=new Callable<Void>(){
        @Override public Void call() throws InterruptedException {
          MethodBody converted=convertMethodBody(path,isStatic,scriptIndex,classIndex,abc,trait,constants,method_info,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits);
          HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
          convertedItems=converted.code.toGraphTargetItems(path,isStatic,scriptIndex,classIndex,abc,constants,method_info,converted,localRegNames,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits,Graph.SOP_USE_STATIC,new HashMap<Integer,Integer>(),converted.code.visitCode(converted));
          Graph.graphToString(convertedItems,new NulWriter(),LocalData.create(constants,localRegNames,fullyQualifiedNames));
          return null;
        }
      }
;
      if (firstLevel) {
        CancellableWorker.call(callable,timeout,TimeUnit.SECONDS);
      }
 else {
        callable.call();
      }
    }
 catch (    InterruptedException ex) {
      throw ex;
    }
catch (    Exception ex) {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
      convertException=ex;
      if (ex instanceof ExecutionException && ex.getCause() instanceof Exception) {
        convertException=(Exception)ex.getCause();
      }
    }
  }
}","public void convert(final String path,ExportMode exportMode,final boolean isStatic,final int scriptIndex,final int classIndex,final ABC abc,final Trait trait,final ConstantPool constants,final MethodInfo[] method_info,final Stack<GraphTargetItem> scopeStack,final boolean isStaticInitializer,final GraphTextWriter writer,final List<String> fullyQualifiedNames,final Traits initTraits,boolean firstLevel) throws InterruptedException {
  if (debugMode) {
    System.err.println(""String_Node_Str"" + path);
  }
  if (exportMode != ExportMode.SOURCE) {
    code.toASMSource(constants,trait,method_info[this.method_info],this,exportMode,writer);
  }
 else {
    if (!Configuration.decompile.get()) {
      writer.appendNoHilight(""String_Node_Str"").newLine();
      return;
    }
    int timeout=Configuration.decompilationTimeoutSingleMethod.get();
    try {
      Callable<Void> callable=new Callable<Void>(){
        @Override public Void call() throws InterruptedException {
          MethodBody converted=convertMethodBody(path,isStatic,scriptIndex,classIndex,abc,trait,constants,method_info,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits);
          HashMap<Integer,String> localRegNames=getLocalRegNames(abc);
          convertedItems=converted.code.toGraphTargetItems(path,isStatic,scriptIndex,classIndex,abc,constants,method_info,converted,localRegNames,scopeStack,isStaticInitializer,fullyQualifiedNames,initTraits,Graph.SOP_USE_STATIC,new HashMap<Integer,Integer>(),converted.code.visitCode(converted));
          Graph.graphToString(convertedItems,writer,LocalData.create(constants,localRegNames,fullyQualifiedNames));
          return null;
        }
      }
;
      if (firstLevel) {
        CancellableWorker.call(callable,timeout,TimeUnit.SECONDS);
      }
 else {
        callable.call();
      }
    }
 catch (    InterruptedException ex) {
      throw ex;
    }
catch (    Exception ex) {
      Logger.getLogger(MethodBody.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
      convertException=ex;
      if (ex instanceof ExecutionException && ex.getCause() instanceof Exception) {
        convertException=(Exception)ex.getCause();
      }
    }
  }
}",0.933430162188332
61951,"@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  fullyQualifiedNames=new ArrayList<>();
  int bodyIndex=abc.findBodyIndex(abc.class_info[class_info].cinit_index);
  if (bodyIndex != -1) {
    writer.mark();
    abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames)+ ""String_Node_Str"",exportMode,true,scriptIndex,class_info,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),true,fullyQualifiedNames,abc.class_info[class_info].static_traits,true);
    classInitializerIsEmpty=!writer.getMark();
  }
  if (!abc.instance_info[class_info].isInterface()) {
    bodyIndex=abc.findBodyIndex(abc.instance_info[class_info].iinit_index);
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames)+ ""String_Node_Str"",exportMode,false,scriptIndex,class_info,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,fullyQualifiedNames,abc.instance_info[class_info].instance_traits,true);
    }
  }
  abc.class_info[class_info].static_traits.convert(this,path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames),abcTags,abc,true,exportMode,false,scriptIndex,class_info,writer,fullyQualifiedNames,parallel);
  abc.instance_info[class_info].instance_traits.convert(this,path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames),abcTags,abc,false,exportMode,false,scriptIndex,class_info,writer,fullyQualifiedNames,parallel);
}","@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  fullyQualifiedNames=new ArrayList<>();
  int bodyIndex=abc.findBodyIndex(abc.class_info[class_info].cinit_index);
  if (bodyIndex != -1) {
    writer.mark();
    abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames)+ ""String_Node_Str"",exportMode,true,scriptIndex,class_info,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),true,writer,fullyQualifiedNames,abc.class_info[class_info].static_traits,true);
    classInitializerIsEmpty=!writer.getMark();
  }
  if (!abc.instance_info[class_info].isInterface()) {
    bodyIndex=abc.findBodyIndex(abc.instance_info[class_info].iinit_index);
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames)+ ""String_Node_Str"",exportMode,false,scriptIndex,class_info,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,abc.instance_info[class_info].instance_traits,true);
    }
  }
  abc.class_info[class_info].static_traits.convert(this,path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames),abcTags,abc,true,exportMode,false,scriptIndex,class_info,writer,fullyQualifiedNames,parallel);
  abc.instance_info[class_info].instance_traits.convert(this,path + ""String_Node_Str"" + abc.instance_info[class_info].getName(abc.constants).getName(abc.constants,fullyQualifiedNames),abcTags,abc,false,exportMode,false,scriptIndex,class_info,writer,fullyQualifiedNames,parallel);
}",0.9963579604578564
61952,"@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  convertHeader(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  if (!abc.instance_info[classIndex].isInterface()) {
    int bodyIndex=abc.findBodyIndex(method_info);
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.constants.getMultiname(name_index).getName(abc.constants,fullyQualifiedNames),exportMode,isStatic,scriptIndex,classIndex,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,fullyQualifiedNames,null,true);
    }
  }
}","@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  convertHeader(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  if (!abc.instance_info[classIndex].isInterface()) {
    int bodyIndex=abc.findBodyIndex(method_info);
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path + ""String_Node_Str"" + abc.constants.getMultiname(name_index).getName(abc.constants,fullyQualifiedNames),exportMode,isStatic,scriptIndex,classIndex,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,null,true);
    }
  }
}",0.995739500912964
61953,"@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  path=path + ""String_Node_Str"" + getName(abc).getName(abc.constants,fullyQualifiedNames);
  convertHeader(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  int bodyIndex=abc.findBodyIndex(method_info);
  if (!(classIndex != -1 && abc.instance_info[classIndex].isInterface() || bodyIndex == -1)) {
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path,exportMode,isStatic,scriptIndex,classIndex,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,fullyQualifiedNames,null,true);
    }
  }
}","@Override public void convert(Trait parent,String path,List<ABCContainerTag> abcTags,ABC abc,boolean isStatic,ExportMode exportMode,int scriptIndex,int classIndex,NulWriter writer,List<String> fullyQualifiedNames,boolean parallel) throws InterruptedException {
  path=path + ""String_Node_Str"" + getName(abc).getName(abc.constants,fullyQualifiedNames);
  convertHeader(parent,path,abcTags,abc,isStatic,exportMode,scriptIndex,classIndex,writer,fullyQualifiedNames,parallel);
  int bodyIndex=abc.findBodyIndex(method_info);
  if (!(classIndex != -1 && abc.instance_info[classIndex].isInterface() || bodyIndex == -1)) {
    if (bodyIndex != -1) {
      abc.bodies[bodyIndex].convert(path,exportMode,isStatic,scriptIndex,classIndex,abc,this,abc.constants,abc.method_info,new Stack<GraphTargetItem>(),false,writer,fullyQualifiedNames,null,true);
    }
  }
}",0.9958702064896756
61954,"@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,getDivider() * 1024,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < codeTable.size(); i++) {
    if (codeTable.get(i) >= code) {
      if (codeTable.get(i) == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=codeTable.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
    glyphShapeTable.add(pos,shp);
    codeTable.add(pos,(int)character);
  }
 else {
    glyphShapeTable.set(pos,shp);
  }
  if (fontFlagsHasLayout) {
    Font fnt=new Font(fontName,fontStyle,getDivider() * 1024);
    if (!exists) {
      fontBoundsTable.add(pos,shp.getBounds());
      fontAdvanceTable.add(pos,(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
 else {
      fontBoundsTable.set(pos,shp.getBounds());
      fontAdvanceTable.set(pos,(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
  }
  if (!exists) {
    numGlyphs++;
  }
}","@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,getDivider() * 1024,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < codeTable.size(); i++) {
    if (codeTable.get(i) >= code) {
      if (codeTable.get(i) == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=codeTable.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
    glyphShapeTable.add(pos,shp);
    codeTable.add(pos,(int)character);
  }
 else {
    glyphShapeTable.set(pos,shp);
  }
  if (fontFlagsHasLayout) {
    Font fnt=new Font(fontName,fontStyle,1024);
    if (!exists) {
      fontBoundsTable.add(pos,shp.getBounds());
      fontAdvanceTable.add(pos,(int)getDivider() * Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
 else {
      fontBoundsTable.set(pos,shp.getBounds());
      fontAdvanceTable.set(pos,(int)getDivider() * Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
  }
  if (!exists) {
    numGlyphs++;
  }
}",0.9835466179159048
61955,"@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  for (int i=0; i < tags.size(); i++) {
    Tag t=tags.get(i);
    if (t instanceof DefineFontAlignZonesTag) {
      DefineFontAlignZonesTag fa=(DefineFontAlignZonesTag)t;
      if (fa.fontID == fontId) {
        tags.remove(i);
        i--;
      }
    }
  }
  int fontStyle=getFontStyle();
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,getDivider() * 1024,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < codeTable.size(); i++) {
    if (codeTable.get(i) >= code) {
      if (codeTable.get(i) == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=codeTable.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
    glyphShapeTable.add(pos,shp);
    codeTable.add(pos,(int)character);
  }
 else {
    glyphShapeTable.set(pos,shp);
  }
  if (fontFlagsHasLayout) {
    Font fnt=new Font(fontName,fontStyle,getDivider() * 1024);
    if (!exists) {
      fontBoundsTable.add(pos,shp.getBounds());
      fontAdvanceTable.add(pos,(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
 else {
      fontBoundsTable.set(pos,shp.getBounds());
      fontAdvanceTable.set(pos,(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
  }
  if (!exists) {
    numGlyphs++;
  }
}","@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  for (int i=0; i < tags.size(); i++) {
    Tag t=tags.get(i);
    if (t instanceof DefineFontAlignZonesTag) {
      DefineFontAlignZonesTag fa=(DefineFontAlignZonesTag)t;
      if (fa.fontID == fontId) {
        tags.remove(i);
        i--;
      }
    }
  }
  int fontStyle=getFontStyle();
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,getDivider() * 1024,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < codeTable.size(); i++) {
    if (codeTable.get(i) >= code) {
      if (codeTable.get(i) == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=codeTable.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
    glyphShapeTable.add(pos,shp);
    codeTable.add(pos,(int)character);
  }
 else {
    glyphShapeTable.set(pos,shp);
  }
  if (fontFlagsHasLayout) {
    Font fnt=new Font(fontName,fontStyle,1024);
    if (!exists) {
      fontBoundsTable.add(pos,shp.getBounds());
      fontAdvanceTable.add(pos,(int)getDivider() * Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
 else {
      fontBoundsTable.set(pos,shp.getBounds());
      fontAdvanceTable.set(pos,(int)getDivider() * Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX()));
    }
  }
  if (!exists) {
    numGlyphs++;
  }
}",0.9861751152073732
61956,"@SuppressWarnings(""String_Node_Str"") public MainFrame(SWF swf){
  super();
  JRibbon rib=getRibbon();
  JRibbonBand editBand=new JRibbonBand(translate(""String_Node_Str""),null);
  editBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(editBand.getControlPanel()),new IconRibbonBandResizePolicy(editBand.getControlPanel())));
  JCommandButton openCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(openCommandButton,""String_Node_Str"");
  saveCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(saveCommandButton,""String_Node_Str"");
  JCommandButton saveasCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(saveasCommandButton,""String_Node_Str"");
  JCommandButton reloadCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(reloadCommandButton,""String_Node_Str"");
  editBand.addCommandButton(openCommandButton,RibbonElementPriority.TOP);
  editBand.addCommandButton(saveCommandButton,RibbonElementPriority.TOP);
  editBand.addCommandButton(saveasCommandButton,RibbonElementPriority.MEDIUM);
  editBand.addCommandButton(reloadCommandButton,RibbonElementPriority.MEDIUM);
  saveCommandButton.setEnabled(!Main.readOnly);
  JRibbonBand exportBand=new JRibbonBand(translate(""String_Node_Str""),null);
  exportBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(exportBand.getControlPanel()),new IconRibbonBandResizePolicy(exportBand.getControlPanel())));
  JCommandButton exportFlaCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportFlaCommandButton,""String_Node_Str"");
  JCommandButton exportAllCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportAllCommandButton,""String_Node_Str"");
  JCommandButton exportSelectionCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportSelectionCommandButton,""String_Node_Str"");
  exportBand.addCommandButton(exportFlaCommandButton,RibbonElementPriority.TOP);
  exportBand.addCommandButton(exportAllCommandButton,RibbonElementPriority.MEDIUM);
  exportBand.addCommandButton(exportSelectionCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask fileTask=new RibbonTask(translate(""String_Node_Str""),editBand,exportBand);
  JRibbonBand toolsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  toolsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(toolsBand.getControlPanel()),new IconRibbonBandResizePolicy(toolsBand.getControlPanel())));
  JCommandButton searchCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(searchCommandButton,""String_Node_Str"");
  JCommandButton gotoDocumentClassCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(gotoDocumentClassCommandButton,""String_Node_Str"");
  JCommandButton proxyCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(proxyCommandButton,""String_Node_Str"");
  JCommandButton loadMemoryCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(loadMemoryCommandButton,""String_Node_Str"");
  JCommandButton loadCacheCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(loadCacheCommandButton,""String_Node_Str"");
  toolsBand.addCommandButton(searchCommandButton,RibbonElementPriority.TOP);
  toolsBand.addCommandButton(gotoDocumentClassCommandButton,RibbonElementPriority.TOP);
  toolsBand.addCommandButton(proxyCommandButton,RibbonElementPriority.MEDIUM);
  toolsBand.addCommandButton(loadMemoryCommandButton,RibbonElementPriority.MEDIUM);
  toolsBand.addCommandButton(loadCacheCommandButton,RibbonElementPriority.MEDIUM);
  if (!ProcessTools.toolsAvailable()) {
    loadMemoryCommandButton.setEnabled(false);
  }
  JRibbonBand deobfuscationBand=new JRibbonBand(translate(""String_Node_Str""),null);
  deobfuscationBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(deobfuscationBand.getControlPanel()),new IconRibbonBandResizePolicy(deobfuscationBand.getControlPanel())));
  JCommandButton deobfuscationCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(deobfuscationCommandButton,""String_Node_Str"");
  JCommandButton globalrenameCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(globalrenameCommandButton,""String_Node_Str"");
  JCommandButton renameinvalidCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(renameinvalidCommandButton,""String_Node_Str"");
  deobfuscationBand.addCommandButton(deobfuscationCommandButton,RibbonElementPriority.TOP);
  deobfuscationBand.addCommandButton(globalrenameCommandButton,RibbonElementPriority.MEDIUM);
  deobfuscationBand.addCommandButton(renameinvalidCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask toolsTask=new RibbonTask(translate(""String_Node_Str""),toolsBand,deobfuscationBand);
  JRibbonBand settingsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  settingsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(settingsBand.getControlPanel()),new IconRibbonBandResizePolicy(settingsBand.getControlPanel())));
  miAutoDeobfuscation=new JCheckBox(translate(""String_Node_Str""));
  miInternalViewer=new JCheckBox(translate(""String_Node_Str""));
  miParallelSpeedUp=new JCheckBox(translate(""String_Node_Str""));
  miDecompile=new JCheckBox(translate(""String_Node_Str""));
  miAssociate=new JCheckBox(translate(""String_Node_Str""));
  miCacheDisk=new JCheckBox(translate(""String_Node_Str""));
  miGotoMainClassOnStartup=new JCheckBox(translate(""String_Node_Str""));
  settingsBand.addRibbonComponent(new JRibbonComponent(miAutoDeobfuscation));
  settingsBand.addRibbonComponent(new JRibbonComponent(miInternalViewer));
  settingsBand.addRibbonComponent(new JRibbonComponent(miParallelSpeedUp));
  settingsBand.addRibbonComponent(new JRibbonComponent(miDecompile));
  settingsBand.addRibbonComponent(new JRibbonComponent(miAssociate));
  settingsBand.addRibbonComponent(new JRibbonComponent(miCacheDisk));
  settingsBand.addRibbonComponent(new JRibbonComponent(miGotoMainClassOnStartup));
  JRibbonBand languageBand=new JRibbonBand(translate(""String_Node_Str""),null);
  languageBand.setResizePolicies((List)Arrays.asList(new BaseRibbonBandResizePolicy<AbstractBandControlPanel>(languageBand.getControlPanel()){
    @Override public int getPreferredWidth(    int i,    int i1){
      return 105;
    }
    @Override public void install(    int i,    int i1){
    }
  }
,new IconRibbonBandResizePolicy(languageBand.getControlPanel())));
  JCommandButton setLanguageCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(setLanguageCommandButton,""String_Node_Str"");
  languageBand.addCommandButton(setLanguageCommandButton,RibbonElementPriority.TOP);
  JRibbonBand advancedSettingsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  advancedSettingsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(advancedSettingsBand.getControlPanel()),new IconRibbonBandResizePolicy(advancedSettingsBand.getControlPanel())));
  JCommandButton advancedSettingsCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(advancedSettingsCommandButton,""String_Node_Str"");
  advancedSettingsBand.addCommandButton(advancedSettingsCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask settingsTask=new RibbonTask(translate(""String_Node_Str""),settingsBand,languageBand,advancedSettingsBand);
  JRibbonBand helpBand=new JRibbonBand(translate(""String_Node_Str""),null);
  helpBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(helpBand.getControlPanel()),new IconRibbonBandResizePolicy(helpBand.getControlPanel())));
  JCommandButton checkForUpdatesCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(checkForUpdatesCommandButton,""String_Node_Str"");
  JCommandButton helpUsUpdatesCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(helpUsUpdatesCommandButton,""String_Node_Str"");
  JCommandButton homepageCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(homepageCommandButton,""String_Node_Str"");
  JCommandButton aboutCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(aboutCommandButton,""String_Node_Str"");
  helpBand.addCommandButton(aboutCommandButton,RibbonElementPriority.TOP);
  helpBand.addCommandButton(checkForUpdatesCommandButton,RibbonElementPriority.MEDIUM);
  helpBand.addCommandButton(homepageCommandButton,RibbonElementPriority.MEDIUM);
  helpBand.addCommandButton(helpUsUpdatesCommandButton,RibbonElementPriority.TOP);
  RibbonTask helpTask=new RibbonTask(translate(""String_Node_Str""),helpBand);
  rib.addTask(fileTask);
  rib.addTask(toolsTask);
  rib.addTask(settingsTask);
  rib.addTask(helpTask);
  RibbonApplicationMenu mainMenu=new RibbonApplicationMenu();
  RibbonApplicationMenuEntryPrimary exportFlaMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary exportAllMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary exportSelMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary checkUpdatesMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary aboutMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary openFileMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_AND_POPUP_MAIN_ACTION);
  openFileMenu.setRolloverCallback(new RibbonApplicationMenuEntryPrimary.PrimaryRolloverCallback(){
    @Override public void menuEntryActivated(    JPanel targetPanel){
      targetPanel.removeAll();
      JCommandButtonPanel openHistoryPanel=new JCommandButtonPanel(CommandButtonDisplayState.MEDIUM);
      String groupName=translate(""String_Node_Str"");
      openHistoryPanel.addButtonGroup(groupName);
      List<String> recentFiles=Configuration.getRecentFiles();
      int j=0;
      for (int i=recentFiles.size() - 1; i >= 0; i--) {
        String path=recentFiles.get(i);
        RecentFilesButton historyButton=new RecentFilesButton(j + ""String_Node_Str"" + path,null);
        historyButton.fileName=path;
        historyButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent ae){
            RecentFilesButton source=(RecentFilesButton)ae.getSource();
            Main.openFile(source.fileName);
          }
        }
);
        j++;
        historyButton.setHorizontalAlignment(SwingUtilities.LEFT);
        openHistoryPanel.addButtonToLastGroup(historyButton);
      }
      openHistoryPanel.setMaxButtonColumns(1);
      targetPanel.setLayout(new BorderLayout());
      targetPanel.add(openHistoryPanel,BorderLayout.CENTER);
    }
  }
);
  RibbonApplicationMenuEntryFooter exitMenu=new RibbonApplicationMenuEntryFooter(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""));
  mainMenu.addMenuEntry(openFileMenu);
  mainMenu.addMenuSeparator();
  mainMenu.addMenuEntry(exportFlaMenu);
  mainMenu.addMenuEntry(exportAllMenu);
  mainMenu.addMenuEntry(exportSelMenu);
  mainMenu.addMenuSeparator();
  mainMenu.addMenuEntry(checkUpdatesMenu);
  mainMenu.addMenuEntry(aboutMenu);
  mainMenu.addFooterEntry(exitMenu);
  mainMenu.addMenuSeparator();
  rib.setApplicationMenu(mainMenu);
  int w=Configuration.guiWindowWidth.get();
  int h=Configuration.guiWindowHeight.get();
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  if (w > dim.width) {
    w=dim.width;
  }
  if (h > dim.height) {
    h=dim.height;
  }
  setSize(w,h);
  boolean maximizedHorizontal=Configuration.guiWindowMaximizedHorizontal.get();
  boolean maximizedVertical=Configuration.guiWindowMaximizedVertical.get();
  int state=0;
  if (maximizedHorizontal) {
    state|=JFrame.MAXIMIZED_HORIZ;
  }
  if (maximizedVertical) {
    state|=JFrame.MAXIMIZED_VERT;
  }
  setExtendedState(state);
  View.setWindowIcon(this);
  addWindowStateListener(new WindowStateListener(){
    @Override public void windowStateChanged(    WindowEvent e){
      int state=e.getNewState();
      Configuration.guiWindowMaximizedHorizontal.set((state & JFrame.MAXIMIZED_HORIZ) == JFrame.MAXIMIZED_HORIZ);
      Configuration.guiWindowMaximizedVertical.set((state & JFrame.MAXIMIZED_VERT) == JFrame.MAXIMIZED_VERT);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int state=getExtendedState();
      if ((state & JFrame.MAXIMIZED_HORIZ) == 0) {
        Configuration.guiWindowWidth.set(getWidth());
      }
      if ((state & JFrame.MAXIMIZED_VERT) == 0) {
        Configuration.guiWindowHeight.set(getHeight());
      }
    }
  }
);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      if (Main.proxyFrame != null) {
        if (Main.proxyFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromMemoryFrame != null) {
        if (Main.loadFromMemoryFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromCacheFrame != null) {
        if (Main.loadFromCacheFrame.isVisible()) {
          return;
        }
      }
      Main.exit();
    }
  }
);
  setTitle(ApplicationInfo.applicationVerName + ((swf != null && Configuration.displayFileName.get()) ? ""String_Node_Str"" + Main.getFileTitle() : ""String_Node_Str""));
  JMenuBar menuBar=new JMenuBar();
  try {
    flashPanel=new FlashPlayerPanel(this);
  }
 catch (  FlashUnsupportedException fue) {
  }
  JMenu menuFile=new JMenu(translate(""String_Node_Str""));
  JMenuItem miOpen=new JMenuItem(translate(""String_Node_Str""));
  miOpen.setIcon(View.getIcon(""String_Node_Str""));
  miOpen.setActionCommand(""String_Node_Str"");
  miOpen.addActionListener(this);
  JMenuItem miSave=new JMenuItem(translate(""String_Node_Str""));
  miSave.setIcon(View.getIcon(""String_Node_Str""));
  miSave.setActionCommand(""String_Node_Str"");
  miSave.addActionListener(this);
  JMenuItem miSaveAs=new JMenuItem(translate(""String_Node_Str""));
  miSaveAs.setIcon(View.getIcon(""String_Node_Str""));
  miSaveAs.setActionCommand(""String_Node_Str"");
  miSaveAs.addActionListener(this);
  JMenuItem menuExportFla=new JMenuItem(translate(""String_Node_Str""));
  menuExportFla.setActionCommand(""String_Node_Str"");
  menuExportFla.addActionListener(this);
  menuExportFla.setIcon(View.getIcon(""String_Node_Str""));
  JMenuItem menuExportAll=new JMenuItem(translate(""String_Node_Str""));
  menuExportAll.setActionCommand(""String_Node_Str"");
  menuExportAll.addActionListener(this);
  JMenuItem menuExportSel=new JMenuItem(translate(""String_Node_Str""));
  menuExportSel.setActionCommand(""String_Node_Str"");
  menuExportSel.addActionListener(this);
  menuExportAll.setIcon(View.getIcon(""String_Node_Str""));
  menuExportSel.setIcon(View.getIcon(""String_Node_Str""));
  menuFile.add(miOpen);
  menuFile.add(miSave);
  menuFile.add(miSaveAs);
  menuFile.add(menuExportFla);
  menuFile.add(menuExportAll);
  menuFile.add(menuExportSel);
  menuFile.addSeparator();
  JMenuItem miClose=new JMenuItem(translate(""String_Node_Str""));
  miClose.setIcon(View.getIcon(""String_Node_Str""));
  miClose.setActionCommand(""String_Node_Str"");
  miClose.addActionListener(this);
  menuFile.add(miClose);
  menuBar.add(menuFile);
  JMenu menuDeobfuscation=new JMenu(translate(""String_Node_Str""));
  menuDeobfuscation.setIcon(View.getIcon(""String_Node_Str""));
  JMenuItem miDeobfuscation=new JMenuItem(translate(""String_Node_Str""));
  miDeobfuscation.setActionCommand(""String_Node_Str"");
  miDeobfuscation.addActionListener(this);
  miAutoDeobfuscation.setSelected(Configuration.autoDeobfuscate.get());
  miAutoDeobfuscation.addActionListener(this);
  miAutoDeobfuscation.setActionCommand(""String_Node_Str"");
  JMenuItem miRenameOneIdentifier=new JMenuItem(translate(""String_Node_Str""));
  miRenameOneIdentifier.setActionCommand(""String_Node_Str"");
  miRenameOneIdentifier.addActionListener(this);
  JMenuItem miRenameIdentifiers=new JMenuItem(translate(""String_Node_Str""));
  miRenameIdentifiers.setActionCommand(""String_Node_Str"");
  miRenameIdentifiers.addActionListener(this);
  menuDeobfuscation.add(miRenameOneIdentifier);
  menuDeobfuscation.add(miRenameIdentifiers);
  menuDeobfuscation.add(miDeobfuscation);
  JMenu menuTools=new JMenu(translate(""String_Node_Str""));
  JMenuItem miProxy=new JMenuItem(translate(""String_Node_Str""));
  miProxy.setActionCommand(""String_Node_Str"");
  miProxy.setIcon(View.getIcon(""String_Node_Str""));
  miProxy.addActionListener(this);
  JMenuItem miSearchScript=new JMenuItem(translate(""String_Node_Str""));
  miSearchScript.addActionListener(this);
  miSearchScript.setActionCommand(""String_Node_Str"");
  miSearchScript.setIcon(View.getIcon(""String_Node_Str""));
  menuTools.add(miSearchScript);
  boolean externalFlashPlayerUnavailable=flashPanel == null;
  miInternalViewer.setSelected(Configuration.internalFlashViewer.get() || externalFlashPlayerUnavailable);
  if (externalFlashPlayerUnavailable) {
    miInternalViewer.setEnabled(false);
  }
  miInternalViewer.setActionCommand(""String_Node_Str"");
  miInternalViewer.addActionListener(this);
  miParallelSpeedUp.setSelected(Configuration.parallelSpeedUp.get());
  miParallelSpeedUp.setActionCommand(""String_Node_Str"");
  miParallelSpeedUp.addActionListener(this);
  menuTools.add(miProxy);
  menuTools.add(menuDeobfuscation);
  JMenuItem miGotoDocumentClass=new JMenuItem(translate(""String_Node_Str""));
  miGotoDocumentClass.setActionCommand(""String_Node_Str"");
  miGotoDocumentClass.addActionListener(this);
  menuBar.add(menuTools);
  miDecompile.setSelected(!Configuration.decompile.get());
  miDecompile.setActionCommand(""String_Node_Str"");
  miDecompile.addActionListener(this);
  miCacheDisk.setSelected(Configuration.cacheOnDisk.get());
  miCacheDisk.setActionCommand(""String_Node_Str"");
  miCacheDisk.addActionListener(this);
  miGotoMainClassOnStartup.setSelected(Configuration.gotoMainClassOnStartup.get());
  miGotoMainClassOnStartup.setActionCommand(""String_Node_Str"");
  miGotoMainClassOnStartup.addActionListener(this);
  miAssociate.setActionCommand(""String_Node_Str"");
  miAssociate.addActionListener(this);
  miAssociate.setSelected(Main.isAddedToContextMenu());
  JMenuItem miLanguage=new JMenuItem(translate(""String_Node_Str""));
  miLanguage.setActionCommand(""String_Node_Str"");
  miLanguage.addActionListener(this);
  JMenu menuHelp=new JMenu(translate(""String_Node_Str""));
  JMenuItem miAbout=new JMenuItem(translate(""String_Node_Str""));
  miAbout.setIcon(View.getIcon(""String_Node_Str""));
  miAbout.setActionCommand(""String_Node_Str"");
  miAbout.addActionListener(this);
  JMenuItem miCheckUpdates=new JMenuItem(translate(""String_Node_Str""));
  miCheckUpdates.setActionCommand(""String_Node_Str"");
  miCheckUpdates.setIcon(View.getIcon(""String_Node_Str""));
  miCheckUpdates.addActionListener(this);
  JMenuItem miHelpUs=new JMenuItem(translate(""String_Node_Str""));
  miHelpUs.setActionCommand(""String_Node_Str"");
  miHelpUs.setIcon(View.getIcon(""String_Node_Str""));
  miHelpUs.addActionListener(this);
  JMenuItem miHomepage=new JMenuItem(translate(""String_Node_Str""));
  miHomepage.setActionCommand(""String_Node_Str"");
  miHomepage.setIcon(View.getIcon(""String_Node_Str""));
  miHomepage.addActionListener(this);
  menuHelp.add(miCheckUpdates);
  menuHelp.add(miHelpUs);
  menuHelp.add(miHomepage);
  menuHelp.add(miAbout);
  menuBar.add(menuHelp);
  List<ContainerItem> objs=new ArrayList<>();
  if (swf != null) {
    objs.addAll(swf.tags);
  }
  this.swf=swf;
  java.awt.Container cnt=getContentPane();
  cnt.setLayout(new BorderLayout());
  cnt.add(getRibbon(),BorderLayout.NORTH);
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  abcList=new ArrayList<>();
  getActionScript3(objs,abcList);
  if (!abcList.isEmpty()) {
    abcPanel=new ABCPanel(abcList,swf);
    detailPanel.add(abcPanel.tabbedPane,DETAILCARDAS3NAVIGATOR);
    menuTools.add(miGotoDocumentClass);
  }
 else {
    gotoDocumentClassCommandButton.setEnabled(false);
    actionPanel=new ActionPanel();
    deobfuscationCommandButton.setEnabled(false);
  }
  if (swf == null) {
    renameinvalidCommandButton.setEnabled(false);
    globalrenameCommandButton.setEnabled(false);
    saveCommandButton.setEnabled(false);
    saveasCommandButton.setEnabled(false);
    exportAllCommandButton.setEnabled(false);
    exportAllMenu.setEnabled(false);
    exportFlaCommandButton.setEnabled(false);
    exportFlaMenu.setEnabled(false);
    exportSelectionCommandButton.setEnabled(false);
    exportSelMenu.setEnabled(false);
    deobfuscationCommandButton.setEnabled(false);
    searchCommandButton.setEnabled(false);
    reloadCommandButton.setEnabled(false);
  }
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  if (swf == null) {
    tagTree=new JTree((TreeModel)null);
  }
 else {
    tagTree=new JTree(new TagTreeModel(createTagList(objs,null),new SWFRoot((new File(Main.file)).getName())));
  }
  tagTree.addTreeSelectionListener(this);
  tagTree.setBackground(Color.white);
  tagTree.setUI(new BasicTreeUI(){
    @Override public void paint(    Graphics g,    JComponent c){
      setHashColor(Color.gray);
      super.paint(g,c);
    }
  }
);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  final JPopupMenu contextPopupMenu=new JPopupMenu();
  final JMenuItem removeMenuItem=new JMenuItem(translate(""String_Node_Str""));
  removeMenuItem.addActionListener(this);
  removeMenuItem.setActionCommand(""String_Node_Str"");
  JMenuItem exportSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  exportSelectionMenuItem.setActionCommand(""String_Node_Str"");
  exportSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(exportSelectionMenuItem);
  contextPopupMenu.add(removeMenuItem);
  tagTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (SwingUtilities.isRightMouseButton(e)) {
        int row=tagTree.getClosestRowForLocation(e.getX(),e.getY());
        int[] selectionRows=tagTree.getSelectionRows();
        if (!Helper.contains(selectionRows,row)) {
          tagTree.setSelectionRow(row);
        }
        TreePath[] paths=tagTree.getSelectionPaths();
        if (paths == null || paths.length == 0) {
          return;
        }
        boolean allSelectedIsTag=true;
        for (        TreePath treePath : paths) {
          Object tagObj=treePath.getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (!(tag instanceof Tag)) {
              allSelectedIsTag=false;
              break;
            }
          }
        }
        removeMenuItem.setVisible(allSelectedIsTag);
        contextPopupMenu.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
  TreeCellRenderer tcr=new DefaultTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      Object val=value;
      if (val instanceof TagNode) {
        val=((TagNode)val).tag;
      }
      String type=getTagType(val);
      if (row == 0) {
        setIcon(View.getIcon(""String_Node_Str""));
      }
 else       if (type != null) {
        if (type.equals(""String_Node_Str"") && expanded) {
          type=""String_Node_Str"";
        }
        setIcon(View.getIcon(type + ""String_Node_Str""));
      }
 else {
      }
      String tos=value.toString();
      int sw=getFontMetrics(getFont()).stringWidth(tos);
      setPreferredSize(new Dimension(18 + sw,getPreferredSize().height));
      setUI(new BasicLabelUI());
      setOpaque(false);
      setBackgroundNonSelectionColor(Color.white);
      return this;
    }
  }
;
  tagTree.setCellRenderer(tcr);
  JPanel statusLeftPanel=new JPanel();
  statusLeftPanel.setLayout(new BoxLayout(statusLeftPanel,BoxLayout.X_AXIS));
  loadingPanel.setPreferredSize(new Dimension(30,30));
  cancelButton.setText(translate(""String_Node_Str""));
  cancelButton.setPreferredSize(new Dimension(100,30));
  cancelButton.setBorderPainted(false);
  cancelButton.setOpaque(false);
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (cancelButtonPressed != null) {
        cancelButtonPressed.run();
      }
    }
  }
);
  statusLeftPanel.add(loadingPanel);
  statusLeftPanel.add(statusLabel);
  statusLeftPanel.add(cancelButton);
  statusPanel=new JPanel();
  statusPanel.setPreferredSize(new Dimension(1,30));
  statusPanel.setBorder(new BevelBorder(BevelBorder.LOWERED));
  statusPanel.setLayout(new BorderLayout());
  statusPanel.add(statusLeftPanel,BorderLayout.WEST);
  errorNotificationButton=new JButton(""String_Node_Str"");
  errorNotificationButton.setIcon(View.getIcon(""String_Node_Str""));
  errorNotificationButton.setBorderPainted(false);
  errorNotificationButton.setFocusPainted(false);
  errorNotificationButton.setContentAreaFilled(false);
  errorNotificationButton.setMargin(new Insets(2,2,2,2));
  errorNotificationButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  errorNotificationButton.setActionCommand(""String_Node_Str"");
  errorNotificationButton.addActionListener(this);
  errorNotificationButton.setToolTipText(translate(""String_Node_Str""));
  statusPanel.add(errorNotificationButton,BorderLayout.EAST);
  loadingPanel.setVisible(false);
  cancelButton.setVisible(false);
  cnt.add(statusPanel,BorderLayout.SOUTH);
  if (swf != null) {
    for (    Tag t : swf.tags) {
      if (t instanceof JPEGTablesTag) {
        jtt=(JPEGTablesTag)t;
      }
    }
  }
  characters=new HashMap<>();
  List<ContainerItem> list2=new ArrayList<>();
  if (swf != null) {
    list2.addAll(swf.tags);
  }
  parseCharacters(list2);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(""String_Node_Str"");
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(""String_Node_Str"");
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(""String_Node_Str"");
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  final JPanel fontPanel=new JPanel();
  final JPanel fontParams2=new JPanel();
  fontParams2.setLayout(null);
  final Component[][] ctable=new Component[][]{{new JLabel(translate(""String_Node_Str"")),fontNameLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontIsBoldLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontIsItalicLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontAscentLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontDescentLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontLeadingLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontCharactersTextArea=new JTextArea(""String_Node_Str"")}};
  fontCharactersTextArea.setLineWrap(true);
  fontCharactersTextArea.setWrapStyleWord(true);
  fontCharactersTextArea.setOpaque(false);
  fontCharactersTextArea.setEditable(false);
  fontCharactersTextArea.setFont(new JLabel().getFont());
  final int borderLeft=10;
  final int[] maxws=new int[ctable[0].length];
  for (int x=0; x < ctable[0].length; x++) {
    int maxw=0;
    for (int y=0; y < ctable.length; y++) {
      Dimension d=ctable[y][x].getPreferredSize();
      if (d.width > maxw) {
        maxw=d.width;
      }
    }
    maxws[x]=maxw;
  }
  for (int i=0; i < ctable.length; i++) {
    fontParams2.add(ctable[i][0]);
    fontParams2.add(ctable[i][1]);
  }
  fontChangeList=new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      int h=0;
      Insets is=fontPanel.getInsets();
      Insets is2=fontParams2.getInsets();
      for (int i=0; i < ctable.length; i++) {
        Dimension d=ctable[i][0].getPreferredSize();
        Dimension d2=ctable[i][1].getPreferredSize();
        ctable[i][0].setBounds(borderLeft,h,maxws[0],d2.height);
        int w2=fontPanel.getWidth() - 3 * borderLeft - maxws[0] - is.left - is.right - 10;
        ctable[i][1].setBounds(borderLeft + maxws[0] + borderLeft,h,w2,d2.height);
        h+=Math.max(d.height,d2.height);
      }
      fontParams2.setPreferredSize(new Dimension(fontPanel.getWidth() - 20,h));
      fontPanel.revalidate();
    }
    @Override public void componentMoved(    ComponentEvent e){
      componentResized(null);
    }
    @Override public void componentShown(    ComponentEvent e){
      componentResized(null);
    }
    @Override public void componentHidden(    ComponentEvent e){
      componentResized(null);
    }
  }
;
  final JPanel fontParams1=new JPanel();
  fontPanel.addComponentListener(fontChangeList);
  fontChangeList.componentResized(null);
  fontParams1.setLayout(new BoxLayout(fontParams1,BoxLayout.Y_AXIS));
  fontParams1.add(fontParams2);
  JPanel fontAddCharsPanel=new JPanel(new FlowLayout());
  fontAddCharsPanel.add(new JLabel(translate(""String_Node_Str"")));
  fontAddCharactersField=new MyTextField();
  fontAddCharactersField.setPreferredSize(new Dimension(150,fontAddCharactersField.getPreferredSize().height));
  fontAddCharsPanel.add(fontAddCharactersField);
  JButton fontAddCharsButton=new JButton(translate(""String_Node_Str""));
  fontAddCharsButton.setActionCommand(""String_Node_Str"");
  fontAddCharsButton.addActionListener(this);
  fontAddCharsPanel.add(fontAddCharsButton);
  JButton fontEmbedButton=new JButton(translate(""String_Node_Str""));
  fontEmbedButton.setActionCommand(""String_Node_Str"");
  fontEmbedButton.addActionListener(this);
  fontParams1.add(fontAddCharsPanel);
  JPanel fontSelectionPanel=new JPanel(new FlowLayout());
  fontSelectionPanel.add(new JLabel(translate(""String_Node_Str"")));
  fontSelection=new JComboBox<>(FontTag.fontNames.toArray(new String[FontTag.fontNames.size()]));
  fontSelection.setSelectedIndex(0);
  fontSelection.setSelectedItem(""String_Node_Str"");
  fontSelection.setSelectedItem(""String_Node_Str"");
  fontSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      if (oldValue instanceof FontTag) {
        FontTag f=(FontTag)oldValue;
        sourceFontsMap.put(f.getFontId(),(String)fontSelection.getSelectedItem());
      }
    }
  }
);
  fontSelectionPanel.add(fontSelection);
  JPanel fontCharPanel=new JPanel();
  fontCharPanel.setLayout(new ListLayout());
  fontCharPanel.add(fontAddCharsPanel);
  fontCharPanel.add(fontSelectionPanel);
  fontParams1.add(fontCharPanel);
  fontParams1.add(fontEmbedButton);
  fontPanel.setLayout(new BorderLayout());
  fontParams1.add(Box.createVerticalGlue());
  fontPanel.add(new JScrollPane(fontParams1),BorderLayout.CENTER);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent=null;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  textValue.setContentType(""String_Node_Str"");
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.setDividerLocation(300);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(""String_Node_Str"");
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  imagePanel=new ImagePanel();
  JPanel imagesCard=new JPanel(new BorderLayout());
  imagesCard.add(imagePanel,BorderLayout.CENTER);
  imageReplaceButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  imageReplaceButton.setMargin(new Insets(3,3,3,10));
  imageReplaceButton.setActionCommand(""String_Node_Str"");
  imageReplaceButton.addActionListener(this);
  imageButtonsPanel=new JPanel(new FlowLayout());
  imageButtonsPanel.add(imageReplaceButton);
  imagesCard.add(imageButtonsPanel,BorderLayout.SOUTH);
  displayPanel.add(imagesCard,CARDIMAGEPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  if (actionPanel != null) {
    displayPanel.add(actionPanel,CARDACTIONSCRIPTPANEL);
  }
  if (abcPanel != null) {
    displayPanel.add(abcPanel,CARDACTIONSCRIPTPANEL);
  }
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.setActionCommand(""String_Node_Str"");
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  if (swf == null) {
    JPanel welcomePanel=new JPanel();
    welcomePanel.setLayout(new BoxLayout(welcomePanel,BoxLayout.Y_AXIS));
    JLabel welcomeToLabel=new JLabel(translate(""String_Node_Str""));
    welcomeToLabel.setFont(welcomeToLabel.getFont().deriveFont(40));
    welcomeToLabel.setAlignmentX(0.5f);
    JPanel appNamePanel=new JPanel(new FlowLayout());
    JLabel jpLabel=new JLabel(""String_Node_Str"");
    jpLabel.setAlignmentX(0.5f);
    jpLabel.setForeground(new Color(0,0,160));
    jpLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    jpLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(jpLabel);
    JLabel ffLabel=new JLabel(""String_Node_Str"");
    ffLabel.setAlignmentX(0.5f);
    ffLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    ffLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(ffLabel);
    JLabel decLabel=new JLabel(""String_Node_Str"");
    decLabel.setAlignmentX(0.5f);
    decLabel.setForeground(Color.red);
    decLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    decLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(decLabel);
    appNamePanel.setAlignmentX(0.5f);
    welcomePanel.add(Box.createGlue());
    welcomePanel.add(welcomeToLabel);
    welcomePanel.add(appNamePanel);
    JLabel startLabel=new JLabel(translate(""String_Node_Str""));
    startLabel.setAlignmentX(0.5f);
    startLabel.setFont(startLabel.getFont().deriveFont(30));
    welcomePanel.add(startLabel);
    welcomePanel.add(Box.createGlue());
    cnt.add(welcomePanel,BorderLayout.CENTER);
    actionPanel=null;
    abcPanel=null;
  }
 else {
    cnt.add(splitPane1,BorderLayout.CENTER);
  }
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  View.centerScreen(this);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  enableDrop(true);
}","@SuppressWarnings(""String_Node_Str"") public MainFrame(SWF swf){
  super();
  JRibbon rib=getRibbon();
  JRibbonBand editBand=new JRibbonBand(translate(""String_Node_Str""),null);
  editBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(editBand.getControlPanel()),new IconRibbonBandResizePolicy(editBand.getControlPanel())));
  JCommandButton openCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(openCommandButton,""String_Node_Str"");
  saveCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(saveCommandButton,""String_Node_Str"");
  JCommandButton saveasCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(saveasCommandButton,""String_Node_Str"");
  JCommandButton reloadCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(reloadCommandButton,""String_Node_Str"");
  editBand.addCommandButton(openCommandButton,RibbonElementPriority.TOP);
  editBand.addCommandButton(saveCommandButton,RibbonElementPriority.TOP);
  editBand.addCommandButton(saveasCommandButton,RibbonElementPriority.MEDIUM);
  editBand.addCommandButton(reloadCommandButton,RibbonElementPriority.MEDIUM);
  saveCommandButton.setEnabled(!Main.readOnly);
  JRibbonBand exportBand=new JRibbonBand(translate(""String_Node_Str""),null);
  exportBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(exportBand.getControlPanel()),new IconRibbonBandResizePolicy(exportBand.getControlPanel())));
  JCommandButton exportFlaCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportFlaCommandButton,""String_Node_Str"");
  JCommandButton exportAllCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportAllCommandButton,""String_Node_Str"");
  JCommandButton exportSelectionCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(exportSelectionCommandButton,""String_Node_Str"");
  exportBand.addCommandButton(exportFlaCommandButton,RibbonElementPriority.TOP);
  exportBand.addCommandButton(exportAllCommandButton,RibbonElementPriority.MEDIUM);
  exportBand.addCommandButton(exportSelectionCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask fileTask=new RibbonTask(translate(""String_Node_Str""),editBand,exportBand);
  JRibbonBand toolsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  toolsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(toolsBand.getControlPanel()),new IconRibbonBandResizePolicy(toolsBand.getControlPanel())));
  JCommandButton searchCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(searchCommandButton,""String_Node_Str"");
  JCommandButton gotoDocumentClassCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(gotoDocumentClassCommandButton,""String_Node_Str"");
  JCommandButton proxyCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(proxyCommandButton,""String_Node_Str"");
  JCommandButton loadMemoryCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(loadMemoryCommandButton,""String_Node_Str"");
  JCommandButton loadCacheCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(loadCacheCommandButton,""String_Node_Str"");
  toolsBand.addCommandButton(searchCommandButton,RibbonElementPriority.TOP);
  toolsBand.addCommandButton(gotoDocumentClassCommandButton,RibbonElementPriority.TOP);
  toolsBand.addCommandButton(proxyCommandButton,RibbonElementPriority.MEDIUM);
  toolsBand.addCommandButton(loadMemoryCommandButton,RibbonElementPriority.MEDIUM);
  toolsBand.addCommandButton(loadCacheCommandButton,RibbonElementPriority.MEDIUM);
  if (!ProcessTools.toolsAvailable()) {
    loadMemoryCommandButton.setEnabled(false);
  }
  JRibbonBand deobfuscationBand=new JRibbonBand(translate(""String_Node_Str""),null);
  deobfuscationBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(deobfuscationBand.getControlPanel()),new IconRibbonBandResizePolicy(deobfuscationBand.getControlPanel())));
  JCommandButton deobfuscationCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(deobfuscationCommandButton,""String_Node_Str"");
  JCommandButton globalrenameCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(globalrenameCommandButton,""String_Node_Str"");
  JCommandButton renameinvalidCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(renameinvalidCommandButton,""String_Node_Str"");
  deobfuscationBand.addCommandButton(deobfuscationCommandButton,RibbonElementPriority.TOP);
  deobfuscationBand.addCommandButton(globalrenameCommandButton,RibbonElementPriority.MEDIUM);
  deobfuscationBand.addCommandButton(renameinvalidCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask toolsTask=new RibbonTask(translate(""String_Node_Str""),toolsBand,deobfuscationBand);
  JRibbonBand settingsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  settingsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(settingsBand.getControlPanel()),new IconRibbonBandResizePolicy(settingsBand.getControlPanel())));
  miAutoDeobfuscation=new JCheckBox(translate(""String_Node_Str""));
  miInternalViewer=new JCheckBox(translate(""String_Node_Str""));
  miParallelSpeedUp=new JCheckBox(translate(""String_Node_Str""));
  miDecompile=new JCheckBox(translate(""String_Node_Str""));
  miAssociate=new JCheckBox(translate(""String_Node_Str""));
  miCacheDisk=new JCheckBox(translate(""String_Node_Str""));
  miGotoMainClassOnStartup=new JCheckBox(translate(""String_Node_Str""));
  settingsBand.addRibbonComponent(new JRibbonComponent(miAutoDeobfuscation));
  settingsBand.addRibbonComponent(new JRibbonComponent(miInternalViewer));
  settingsBand.addRibbonComponent(new JRibbonComponent(miParallelSpeedUp));
  settingsBand.addRibbonComponent(new JRibbonComponent(miDecompile));
  settingsBand.addRibbonComponent(new JRibbonComponent(miAssociate));
  settingsBand.addRibbonComponent(new JRibbonComponent(miCacheDisk));
  settingsBand.addRibbonComponent(new JRibbonComponent(miGotoMainClassOnStartup));
  JRibbonBand languageBand=new JRibbonBand(translate(""String_Node_Str""),null);
  languageBand.setResizePolicies((List)Arrays.asList(new BaseRibbonBandResizePolicy<AbstractBandControlPanel>(languageBand.getControlPanel()){
    @Override public int getPreferredWidth(    int i,    int i1){
      return 105;
    }
    @Override public void install(    int i,    int i1){
    }
  }
,new IconRibbonBandResizePolicy(languageBand.getControlPanel())));
  JCommandButton setLanguageCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(setLanguageCommandButton,""String_Node_Str"");
  languageBand.addCommandButton(setLanguageCommandButton,RibbonElementPriority.TOP);
  JRibbonBand advancedSettingsBand=new JRibbonBand(translate(""String_Node_Str""),null);
  advancedSettingsBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(advancedSettingsBand.getControlPanel()),new IconRibbonBandResizePolicy(advancedSettingsBand.getControlPanel())));
  JCommandButton advancedSettingsCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(advancedSettingsCommandButton,""String_Node_Str"");
  advancedSettingsBand.addCommandButton(advancedSettingsCommandButton,RibbonElementPriority.MEDIUM);
  RibbonTask settingsTask=new RibbonTask(translate(""String_Node_Str""),settingsBand,languageBand,advancedSettingsBand);
  JRibbonBand helpBand=new JRibbonBand(translate(""String_Node_Str""),null);
  helpBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(helpBand.getControlPanel()),new IconRibbonBandResizePolicy(helpBand.getControlPanel())));
  JCommandButton checkForUpdatesCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(checkForUpdatesCommandButton,""String_Node_Str"");
  JCommandButton helpUsUpdatesCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(helpUsUpdatesCommandButton,""String_Node_Str"");
  JCommandButton homepageCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(homepageCommandButton,""String_Node_Str"");
  JCommandButton aboutCommandButton=new JCommandButton(fixCommandTitle(translate(""String_Node_Str"")),View.getResizableIcon(""String_Node_Str""));
  assignListener(aboutCommandButton,""String_Node_Str"");
  helpBand.addCommandButton(aboutCommandButton,RibbonElementPriority.TOP);
  helpBand.addCommandButton(checkForUpdatesCommandButton,RibbonElementPriority.MEDIUM);
  helpBand.addCommandButton(homepageCommandButton,RibbonElementPriority.MEDIUM);
  helpBand.addCommandButton(helpUsUpdatesCommandButton,RibbonElementPriority.TOP);
  RibbonTask helpTask=new RibbonTask(translate(""String_Node_Str""),helpBand);
  RibbonTask debugTask=null;
  if (Configuration.debugMode.get()) {
    JRibbonBand debugBand=new JRibbonBand(""String_Node_Str"",null);
    debugBand.setResizePolicies((List)Arrays.asList(new CoreRibbonResizePolicies.Mirror(debugBand.getControlPanel()),new IconRibbonBandResizePolicy(debugBand.getControlPanel())));
    JCommandButton removeNonScriptsCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),View.getResizableIcon(""String_Node_Str""));
    assignListener(removeNonScriptsCommandButton,""String_Node_Str"");
    JCommandButton refreshDecompiledCommandButton=new JCommandButton(fixCommandTitle(""String_Node_Str""),View.getResizableIcon(""String_Node_Str""));
    assignListener(refreshDecompiledCommandButton,""String_Node_Str"");
    debugBand.addCommandButton(removeNonScriptsCommandButton,RibbonElementPriority.MEDIUM);
    debugBand.addCommandButton(refreshDecompiledCommandButton,RibbonElementPriority.MEDIUM);
    debugTask=new RibbonTask(""String_Node_Str"",debugBand);
  }
  rib.addTask(fileTask);
  rib.addTask(toolsTask);
  rib.addTask(settingsTask);
  rib.addTask(helpTask);
  if (debugTask != null) {
    rib.addTask(debugTask);
  }
  RibbonApplicationMenu mainMenu=new RibbonApplicationMenu();
  RibbonApplicationMenuEntryPrimary exportFlaMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary exportAllMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary exportSelMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary checkUpdatesMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary aboutMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_ONLY);
  RibbonApplicationMenuEntryPrimary openFileMenu=new RibbonApplicationMenuEntryPrimary(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""),CommandButtonKind.ACTION_AND_POPUP_MAIN_ACTION);
  openFileMenu.setRolloverCallback(new RibbonApplicationMenuEntryPrimary.PrimaryRolloverCallback(){
    @Override public void menuEntryActivated(    JPanel targetPanel){
      targetPanel.removeAll();
      JCommandButtonPanel openHistoryPanel=new JCommandButtonPanel(CommandButtonDisplayState.MEDIUM);
      String groupName=translate(""String_Node_Str"");
      openHistoryPanel.addButtonGroup(groupName);
      List<String> recentFiles=Configuration.getRecentFiles();
      int j=0;
      for (int i=recentFiles.size() - 1; i >= 0; i--) {
        String path=recentFiles.get(i);
        RecentFilesButton historyButton=new RecentFilesButton(j + ""String_Node_Str"" + path,null);
        historyButton.fileName=path;
        historyButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent ae){
            RecentFilesButton source=(RecentFilesButton)ae.getSource();
            Main.openFile(source.fileName);
          }
        }
);
        j++;
        historyButton.setHorizontalAlignment(SwingUtilities.LEFT);
        openHistoryPanel.addButtonToLastGroup(historyButton);
      }
      openHistoryPanel.setMaxButtonColumns(1);
      targetPanel.setLayout(new BorderLayout());
      targetPanel.add(openHistoryPanel,BorderLayout.CENTER);
    }
  }
);
  RibbonApplicationMenuEntryFooter exitMenu=new RibbonApplicationMenuEntryFooter(View.getResizableIcon(""String_Node_Str""),translate(""String_Node_Str""),new ActionRedirector(this,""String_Node_Str""));
  mainMenu.addMenuEntry(openFileMenu);
  mainMenu.addMenuSeparator();
  mainMenu.addMenuEntry(exportFlaMenu);
  mainMenu.addMenuEntry(exportAllMenu);
  mainMenu.addMenuEntry(exportSelMenu);
  mainMenu.addMenuSeparator();
  mainMenu.addMenuEntry(checkUpdatesMenu);
  mainMenu.addMenuEntry(aboutMenu);
  mainMenu.addFooterEntry(exitMenu);
  mainMenu.addMenuSeparator();
  rib.setApplicationMenu(mainMenu);
  int w=Configuration.guiWindowWidth.get();
  int h=Configuration.guiWindowHeight.get();
  Dimension dim=java.awt.Toolkit.getDefaultToolkit().getScreenSize();
  if (w > dim.width) {
    w=dim.width;
  }
  if (h > dim.height) {
    h=dim.height;
  }
  setSize(w,h);
  boolean maximizedHorizontal=Configuration.guiWindowMaximizedHorizontal.get();
  boolean maximizedVertical=Configuration.guiWindowMaximizedVertical.get();
  int state=0;
  if (maximizedHorizontal) {
    state|=JFrame.MAXIMIZED_HORIZ;
  }
  if (maximizedVertical) {
    state|=JFrame.MAXIMIZED_VERT;
  }
  setExtendedState(state);
  View.setWindowIcon(this);
  addWindowStateListener(new WindowStateListener(){
    @Override public void windowStateChanged(    WindowEvent e){
      int state=e.getNewState();
      Configuration.guiWindowMaximizedHorizontal.set((state & JFrame.MAXIMIZED_HORIZ) == JFrame.MAXIMIZED_HORIZ);
      Configuration.guiWindowMaximizedVertical.set((state & JFrame.MAXIMIZED_VERT) == JFrame.MAXIMIZED_VERT);
    }
  }
);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int state=getExtendedState();
      if ((state & JFrame.MAXIMIZED_HORIZ) == 0) {
        Configuration.guiWindowWidth.set(getWidth());
      }
      if ((state & JFrame.MAXIMIZED_VERT) == 0) {
        Configuration.guiWindowHeight.set(getHeight());
      }
    }
  }
);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      if (Main.proxyFrame != null) {
        if (Main.proxyFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromMemoryFrame != null) {
        if (Main.loadFromMemoryFrame.isVisible()) {
          return;
        }
      }
      if (Main.loadFromCacheFrame != null) {
        if (Main.loadFromCacheFrame.isVisible()) {
          return;
        }
      }
      Main.exit();
    }
  }
);
  setTitle(ApplicationInfo.applicationVerName + ((swf != null && Configuration.displayFileName.get()) ? ""String_Node_Str"" + Main.getFileTitle() : ""String_Node_Str""));
  JMenuBar menuBar=new JMenuBar();
  try {
    flashPanel=new FlashPlayerPanel(this);
  }
 catch (  FlashUnsupportedException fue) {
  }
  JMenu menuFile=new JMenu(translate(""String_Node_Str""));
  JMenuItem miOpen=new JMenuItem(translate(""String_Node_Str""));
  miOpen.setIcon(View.getIcon(""String_Node_Str""));
  miOpen.setActionCommand(""String_Node_Str"");
  miOpen.addActionListener(this);
  JMenuItem miSave=new JMenuItem(translate(""String_Node_Str""));
  miSave.setIcon(View.getIcon(""String_Node_Str""));
  miSave.setActionCommand(""String_Node_Str"");
  miSave.addActionListener(this);
  JMenuItem miSaveAs=new JMenuItem(translate(""String_Node_Str""));
  miSaveAs.setIcon(View.getIcon(""String_Node_Str""));
  miSaveAs.setActionCommand(""String_Node_Str"");
  miSaveAs.addActionListener(this);
  JMenuItem menuExportFla=new JMenuItem(translate(""String_Node_Str""));
  menuExportFla.setActionCommand(""String_Node_Str"");
  menuExportFla.addActionListener(this);
  menuExportFla.setIcon(View.getIcon(""String_Node_Str""));
  JMenuItem menuExportAll=new JMenuItem(translate(""String_Node_Str""));
  menuExportAll.setActionCommand(""String_Node_Str"");
  menuExportAll.addActionListener(this);
  JMenuItem menuExportSel=new JMenuItem(translate(""String_Node_Str""));
  menuExportSel.setActionCommand(""String_Node_Str"");
  menuExportSel.addActionListener(this);
  menuExportAll.setIcon(View.getIcon(""String_Node_Str""));
  menuExportSel.setIcon(View.getIcon(""String_Node_Str""));
  menuFile.add(miOpen);
  menuFile.add(miSave);
  menuFile.add(miSaveAs);
  menuFile.add(menuExportFla);
  menuFile.add(menuExportAll);
  menuFile.add(menuExportSel);
  menuFile.addSeparator();
  JMenuItem miClose=new JMenuItem(translate(""String_Node_Str""));
  miClose.setIcon(View.getIcon(""String_Node_Str""));
  miClose.setActionCommand(""String_Node_Str"");
  miClose.addActionListener(this);
  menuFile.add(miClose);
  menuBar.add(menuFile);
  JMenu menuDeobfuscation=new JMenu(translate(""String_Node_Str""));
  menuDeobfuscation.setIcon(View.getIcon(""String_Node_Str""));
  JMenuItem miDeobfuscation=new JMenuItem(translate(""String_Node_Str""));
  miDeobfuscation.setActionCommand(""String_Node_Str"");
  miDeobfuscation.addActionListener(this);
  miAutoDeobfuscation.setSelected(Configuration.autoDeobfuscate.get());
  miAutoDeobfuscation.addActionListener(this);
  miAutoDeobfuscation.setActionCommand(""String_Node_Str"");
  JMenuItem miRenameOneIdentifier=new JMenuItem(translate(""String_Node_Str""));
  miRenameOneIdentifier.setActionCommand(""String_Node_Str"");
  miRenameOneIdentifier.addActionListener(this);
  JMenuItem miRenameIdentifiers=new JMenuItem(translate(""String_Node_Str""));
  miRenameIdentifiers.setActionCommand(""String_Node_Str"");
  miRenameIdentifiers.addActionListener(this);
  menuDeobfuscation.add(miRenameOneIdentifier);
  menuDeobfuscation.add(miRenameIdentifiers);
  menuDeobfuscation.add(miDeobfuscation);
  JMenu menuTools=new JMenu(translate(""String_Node_Str""));
  JMenuItem miProxy=new JMenuItem(translate(""String_Node_Str""));
  miProxy.setActionCommand(""String_Node_Str"");
  miProxy.setIcon(View.getIcon(""String_Node_Str""));
  miProxy.addActionListener(this);
  JMenuItem miSearchScript=new JMenuItem(translate(""String_Node_Str""));
  miSearchScript.addActionListener(this);
  miSearchScript.setActionCommand(""String_Node_Str"");
  miSearchScript.setIcon(View.getIcon(""String_Node_Str""));
  menuTools.add(miSearchScript);
  boolean externalFlashPlayerUnavailable=flashPanel == null;
  miInternalViewer.setSelected(Configuration.internalFlashViewer.get() || externalFlashPlayerUnavailable);
  if (externalFlashPlayerUnavailable) {
    miInternalViewer.setEnabled(false);
  }
  miInternalViewer.setActionCommand(""String_Node_Str"");
  miInternalViewer.addActionListener(this);
  miParallelSpeedUp.setSelected(Configuration.parallelSpeedUp.get());
  miParallelSpeedUp.setActionCommand(""String_Node_Str"");
  miParallelSpeedUp.addActionListener(this);
  menuTools.add(miProxy);
  menuTools.add(menuDeobfuscation);
  JMenuItem miGotoDocumentClass=new JMenuItem(translate(""String_Node_Str""));
  miGotoDocumentClass.setActionCommand(""String_Node_Str"");
  miGotoDocumentClass.addActionListener(this);
  menuBar.add(menuTools);
  miDecompile.setSelected(!Configuration.decompile.get());
  miDecompile.setActionCommand(""String_Node_Str"");
  miDecompile.addActionListener(this);
  miCacheDisk.setSelected(Configuration.cacheOnDisk.get());
  miCacheDisk.setActionCommand(""String_Node_Str"");
  miCacheDisk.addActionListener(this);
  miGotoMainClassOnStartup.setSelected(Configuration.gotoMainClassOnStartup.get());
  miGotoMainClassOnStartup.setActionCommand(""String_Node_Str"");
  miGotoMainClassOnStartup.addActionListener(this);
  miAssociate.setActionCommand(""String_Node_Str"");
  miAssociate.addActionListener(this);
  miAssociate.setSelected(Main.isAddedToContextMenu());
  JMenuItem miLanguage=new JMenuItem(translate(""String_Node_Str""));
  miLanguage.setActionCommand(""String_Node_Str"");
  miLanguage.addActionListener(this);
  JMenu menuHelp=new JMenu(translate(""String_Node_Str""));
  JMenuItem miAbout=new JMenuItem(translate(""String_Node_Str""));
  miAbout.setIcon(View.getIcon(""String_Node_Str""));
  miAbout.setActionCommand(""String_Node_Str"");
  miAbout.addActionListener(this);
  JMenuItem miCheckUpdates=new JMenuItem(translate(""String_Node_Str""));
  miCheckUpdates.setActionCommand(""String_Node_Str"");
  miCheckUpdates.setIcon(View.getIcon(""String_Node_Str""));
  miCheckUpdates.addActionListener(this);
  JMenuItem miHelpUs=new JMenuItem(translate(""String_Node_Str""));
  miHelpUs.setActionCommand(""String_Node_Str"");
  miHelpUs.setIcon(View.getIcon(""String_Node_Str""));
  miHelpUs.addActionListener(this);
  JMenuItem miHomepage=new JMenuItem(translate(""String_Node_Str""));
  miHomepage.setActionCommand(""String_Node_Str"");
  miHomepage.setIcon(View.getIcon(""String_Node_Str""));
  miHomepage.addActionListener(this);
  menuHelp.add(miCheckUpdates);
  menuHelp.add(miHelpUs);
  menuHelp.add(miHomepage);
  menuHelp.add(miAbout);
  menuBar.add(menuHelp);
  List<ContainerItem> objs=new ArrayList<>();
  if (swf != null) {
    objs.addAll(swf.tags);
  }
  this.swf=swf;
  java.awt.Container cnt=getContentPane();
  cnt.setLayout(new BorderLayout());
  cnt.add(getRibbon(),BorderLayout.NORTH);
  detailPanel=new JPanel();
  detailPanel.setLayout(new CardLayout());
  JPanel whitePanel=new JPanel();
  whitePanel.setBackground(Color.white);
  detailPanel.add(whitePanel,DETAILCARDEMPTYPANEL);
  CardLayout cl2=(CardLayout)(detailPanel.getLayout());
  cl2.show(detailPanel,DETAILCARDEMPTYPANEL);
  abcList=new ArrayList<>();
  getActionScript3(objs,abcList);
  if (!abcList.isEmpty()) {
    abcPanel=new ABCPanel(abcList,swf);
    detailPanel.add(abcPanel.tabbedPane,DETAILCARDAS3NAVIGATOR);
    menuTools.add(miGotoDocumentClass);
  }
 else {
    gotoDocumentClassCommandButton.setEnabled(false);
    actionPanel=new ActionPanel();
    deobfuscationCommandButton.setEnabled(false);
  }
  if (swf == null) {
    renameinvalidCommandButton.setEnabled(false);
    globalrenameCommandButton.setEnabled(false);
    saveCommandButton.setEnabled(false);
    saveasCommandButton.setEnabled(false);
    exportAllCommandButton.setEnabled(false);
    exportAllMenu.setEnabled(false);
    exportFlaCommandButton.setEnabled(false);
    exportFlaMenu.setEnabled(false);
    exportSelectionCommandButton.setEnabled(false);
    exportSelMenu.setEnabled(false);
    deobfuscationCommandButton.setEnabled(false);
    searchCommandButton.setEnabled(false);
    reloadCommandButton.setEnabled(false);
  }
  UIManager.getDefaults().put(""String_Node_Str"",BasicTreeUI.class.getName());
  if (swf == null) {
    tagTree=new JTree((TreeModel)null);
  }
 else {
    tagTree=new JTree(new TagTreeModel(createTagList(objs,null),new SWFRoot((new File(Main.file)).getName())));
  }
  tagTree.addTreeSelectionListener(this);
  tagTree.setBackground(Color.white);
  tagTree.setUI(new BasicTreeUI(){
    @Override public void paint(    Graphics g,    JComponent c){
      setHashColor(Color.gray);
      super.paint(g,c);
    }
  }
);
  DragSource dragSource=DragSource.getDefaultDragSource();
  dragSource.createDefaultDragGestureRecognizer(tagTree,DnDConstants.ACTION_COPY_OR_MOVE,new DragGestureListener(){
    @Override public void dragGestureRecognized(    DragGestureEvent dge){
      dge.startDrag(DragSource.DefaultCopyDrop,new Transferable(){
        @Override public DataFlavor[] getTransferDataFlavors(){
          return new DataFlavor[]{DataFlavor.javaFileListFlavor};
        }
        @Override public boolean isDataFlavorSupported(        DataFlavor flavor){
          return flavor.equals(DataFlavor.javaFileListFlavor);
        }
        @Override public Object getTransferData(        DataFlavor flavor) throws UnsupportedFlavorException, IOException {
          if (flavor.equals(DataFlavor.javaFileListFlavor)) {
            List<File> files=new ArrayList<>();
            String tempDir=System.getProperty(""String_Node_Str"");
            if (!tempDir.endsWith(File.separator)) {
              tempDir+=File.separator;
            }
            Random rnd=new Random();
            tempDir+=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ System.currentTimeMillis()+ ""String_Node_Str""+ rnd.nextInt(1000);
            File fTempDir=new File(tempDir);
            if (!fTempDir.exists()) {
              if (!fTempDir.mkdirs()) {
                if (!fTempDir.exists()) {
                  throw new IOException(""String_Node_Str"" + fTempDir);
                }
              }
            }
            final ExportDialog export=new ExportDialog();
            try {
              File ftemp=new File(tempDir);
              files=exportSelection(errorHandler,tempDir,export);
              files.clear();
              File[] fs=ftemp.listFiles();
              files.addAll(Arrays.asList(fs));
              Main.stopWork();
            }
 catch (            IOException ex) {
              return null;
            }
            for (            File f : files) {
              f.deleteOnExit();
            }
            new File(tempDir).deleteOnExit();
            return files;
          }
          return null;
        }
      }
,new DragSourceListener(){
        @Override public void dragEnter(        DragSourceDragEvent dsde){
          enableDrop(false);
        }
        @Override public void dragOver(        DragSourceDragEvent dsde){
        }
        @Override public void dropActionChanged(        DragSourceDragEvent dsde){
        }
        @Override public void dragExit(        DragSourceEvent dse){
        }
        @Override public void dragDropEnd(        DragSourceDropEvent dsde){
          enableDrop(true);
        }
      }
);
    }
  }
);
  final JPopupMenu contextPopupMenu=new JPopupMenu();
  final JMenuItem removeMenuItem=new JMenuItem(translate(""String_Node_Str""));
  removeMenuItem.addActionListener(this);
  removeMenuItem.setActionCommand(""String_Node_Str"");
  JMenuItem exportSelectionMenuItem=new JMenuItem(translate(""String_Node_Str""));
  exportSelectionMenuItem.setActionCommand(""String_Node_Str"");
  exportSelectionMenuItem.addActionListener(this);
  contextPopupMenu.add(exportSelectionMenuItem);
  contextPopupMenu.add(removeMenuItem);
  tagTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (SwingUtilities.isRightMouseButton(e)) {
        int row=tagTree.getClosestRowForLocation(e.getX(),e.getY());
        int[] selectionRows=tagTree.getSelectionRows();
        if (!Helper.contains(selectionRows,row)) {
          tagTree.setSelectionRow(row);
        }
        TreePath[] paths=tagTree.getSelectionPaths();
        if (paths == null || paths.length == 0) {
          return;
        }
        boolean allSelectedIsTag=true;
        for (        TreePath treePath : paths) {
          Object tagObj=treePath.getLastPathComponent();
          if (tagObj instanceof TagNode) {
            Object tag=((TagNode)tagObj).tag;
            if (!(tag instanceof Tag)) {
              allSelectedIsTag=false;
              break;
            }
          }
        }
        removeMenuItem.setVisible(allSelectedIsTag);
        contextPopupMenu.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
  TreeCellRenderer tcr=new DefaultTreeCellRenderer(){
    @Override public Component getTreeCellRendererComponent(    JTree tree,    Object value,    boolean sel,    boolean expanded,    boolean leaf,    int row,    boolean hasFocus){
      super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
      Object val=value;
      if (val instanceof TagNode) {
        val=((TagNode)val).tag;
      }
      String type=getTagType(val);
      if (row == 0) {
        setIcon(View.getIcon(""String_Node_Str""));
      }
 else       if (type != null) {
        if (type.equals(""String_Node_Str"") && expanded) {
          type=""String_Node_Str"";
        }
        setIcon(View.getIcon(type + ""String_Node_Str""));
      }
 else {
      }
      String tos=value.toString();
      int sw=getFontMetrics(getFont()).stringWidth(tos);
      setPreferredSize(new Dimension(18 + sw,getPreferredSize().height));
      setUI(new BasicLabelUI());
      setOpaque(false);
      setBackgroundNonSelectionColor(Color.white);
      return this;
    }
  }
;
  tagTree.setCellRenderer(tcr);
  JPanel statusLeftPanel=new JPanel();
  statusLeftPanel.setLayout(new BoxLayout(statusLeftPanel,BoxLayout.X_AXIS));
  loadingPanel.setPreferredSize(new Dimension(30,30));
  cancelButton.setText(translate(""String_Node_Str""));
  cancelButton.setPreferredSize(new Dimension(100,30));
  cancelButton.setBorderPainted(false);
  cancelButton.setOpaque(false);
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (cancelButtonPressed != null) {
        cancelButtonPressed.run();
      }
    }
  }
);
  statusLeftPanel.add(loadingPanel);
  statusLeftPanel.add(statusLabel);
  statusLeftPanel.add(cancelButton);
  statusPanel=new JPanel();
  statusPanel.setPreferredSize(new Dimension(1,30));
  statusPanel.setBorder(new BevelBorder(BevelBorder.LOWERED));
  statusPanel.setLayout(new BorderLayout());
  statusPanel.add(statusLeftPanel,BorderLayout.WEST);
  errorNotificationButton=new JButton(""String_Node_Str"");
  errorNotificationButton.setIcon(View.getIcon(""String_Node_Str""));
  errorNotificationButton.setBorderPainted(false);
  errorNotificationButton.setFocusPainted(false);
  errorNotificationButton.setContentAreaFilled(false);
  errorNotificationButton.setMargin(new Insets(2,2,2,2));
  errorNotificationButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  errorNotificationButton.setActionCommand(""String_Node_Str"");
  errorNotificationButton.addActionListener(this);
  errorNotificationButton.setToolTipText(translate(""String_Node_Str""));
  statusPanel.add(errorNotificationButton,BorderLayout.EAST);
  loadingPanel.setVisible(false);
  cancelButton.setVisible(false);
  cnt.add(statusPanel,BorderLayout.SOUTH);
  if (swf != null) {
    for (    Tag t : swf.tags) {
      if (t instanceof JPEGTablesTag) {
        jtt=(JPEGTablesTag)t;
      }
    }
  }
  characters=new HashMap<>();
  List<ContainerItem> list2=new ArrayList<>();
  if (swf != null) {
    list2.addAll(swf.tags);
  }
  parseCharacters(list2);
  JPanel textTopPanel=new JPanel(new BorderLayout());
  textValue=new LineMarkedEditorPane();
  textTopPanel.add(new JScrollPane(textValue),BorderLayout.CENTER);
  textValue.setEditable(false);
  JPanel textButtonsPanel=new JPanel();
  textButtonsPanel.setLayout(new FlowLayout());
  textSaveButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textSaveButton.setMargin(new Insets(3,3,3,10));
  textSaveButton.setActionCommand(""String_Node_Str"");
  textSaveButton.addActionListener(this);
  textEditButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textEditButton.setMargin(new Insets(3,3,3,10));
  textEditButton.setActionCommand(""String_Node_Str"");
  textEditButton.addActionListener(this);
  textCancelButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  textCancelButton.setMargin(new Insets(3,3,3,10));
  textCancelButton.setActionCommand(""String_Node_Str"");
  textCancelButton.addActionListener(this);
  textButtonsPanel.add(textEditButton);
  textButtonsPanel.add(textSaveButton);
  textButtonsPanel.add(textCancelButton);
  textSaveButton.setVisible(false);
  textCancelButton.setVisible(false);
  textTopPanel.add(textButtonsPanel,BorderLayout.SOUTH);
  displayWithPreview=new JPanel(new CardLayout());
  displayWithPreview.add(textTopPanel,CARDTEXTPANEL);
  final JPanel fontPanel=new JPanel();
  final JPanel fontParams2=new JPanel();
  fontParams2.setLayout(null);
  final Component[][] ctable=new Component[][]{{new JLabel(translate(""String_Node_Str"")),fontNameLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontIsBoldLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontIsItalicLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontAscentLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontDescentLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontLeadingLabel=new JLabel(translate(""String_Node_Str""))},{new JLabel(translate(""String_Node_Str"")),fontCharactersTextArea=new JTextArea(""String_Node_Str"")}};
  fontCharactersTextArea.setLineWrap(true);
  fontCharactersTextArea.setWrapStyleWord(true);
  fontCharactersTextArea.setOpaque(false);
  fontCharactersTextArea.setEditable(false);
  fontCharactersTextArea.setFont(new JLabel().getFont());
  final int borderLeft=10;
  final int[] maxws=new int[ctable[0].length];
  for (int x=0; x < ctable[0].length; x++) {
    int maxw=0;
    for (int y=0; y < ctable.length; y++) {
      Dimension d=ctable[y][x].getPreferredSize();
      if (d.width > maxw) {
        maxw=d.width;
      }
    }
    maxws[x]=maxw;
  }
  for (int i=0; i < ctable.length; i++) {
    fontParams2.add(ctable[i][0]);
    fontParams2.add(ctable[i][1]);
  }
  fontChangeList=new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      int h=0;
      Insets is=fontPanel.getInsets();
      Insets is2=fontParams2.getInsets();
      for (int i=0; i < ctable.length; i++) {
        Dimension d=ctable[i][0].getPreferredSize();
        Dimension d2=ctable[i][1].getPreferredSize();
        ctable[i][0].setBounds(borderLeft,h,maxws[0],d2.height);
        int w2=fontPanel.getWidth() - 3 * borderLeft - maxws[0] - is.left - is.right - 10;
        ctable[i][1].setBounds(borderLeft + maxws[0] + borderLeft,h,w2,d2.height);
        h+=Math.max(d.height,d2.height);
      }
      fontParams2.setPreferredSize(new Dimension(fontPanel.getWidth() - 20,h));
      fontPanel.revalidate();
    }
    @Override public void componentMoved(    ComponentEvent e){
      componentResized(null);
    }
    @Override public void componentShown(    ComponentEvent e){
      componentResized(null);
    }
    @Override public void componentHidden(    ComponentEvent e){
      componentResized(null);
    }
  }
;
  final JPanel fontParams1=new JPanel();
  fontPanel.addComponentListener(fontChangeList);
  fontChangeList.componentResized(null);
  fontParams1.setLayout(new BoxLayout(fontParams1,BoxLayout.Y_AXIS));
  fontParams1.add(fontParams2);
  JPanel fontAddCharsPanel=new JPanel(new FlowLayout());
  fontAddCharsPanel.add(new JLabel(translate(""String_Node_Str"")));
  fontAddCharactersField=new MyTextField();
  fontAddCharactersField.setPreferredSize(new Dimension(150,fontAddCharactersField.getPreferredSize().height));
  fontAddCharsPanel.add(fontAddCharactersField);
  JButton fontAddCharsButton=new JButton(translate(""String_Node_Str""));
  fontAddCharsButton.setActionCommand(""String_Node_Str"");
  fontAddCharsButton.addActionListener(this);
  fontAddCharsPanel.add(fontAddCharsButton);
  JButton fontEmbedButton=new JButton(translate(""String_Node_Str""));
  fontEmbedButton.setActionCommand(""String_Node_Str"");
  fontEmbedButton.addActionListener(this);
  fontParams1.add(fontAddCharsPanel);
  JPanel fontSelectionPanel=new JPanel(new FlowLayout());
  fontSelectionPanel.add(new JLabel(translate(""String_Node_Str"")));
  fontSelection=new JComboBox<>(FontTag.fontNames.toArray(new String[FontTag.fontNames.size()]));
  fontSelection.setSelectedIndex(0);
  fontSelection.setSelectedItem(""String_Node_Str"");
  fontSelection.setSelectedItem(""String_Node_Str"");
  fontSelection.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      if (oldValue instanceof FontTag) {
        FontTag f=(FontTag)oldValue;
        sourceFontsMap.put(f.getFontId(),(String)fontSelection.getSelectedItem());
      }
    }
  }
);
  fontSelectionPanel.add(fontSelection);
  JPanel fontCharPanel=new JPanel();
  fontCharPanel.setLayout(new ListLayout());
  fontCharPanel.add(fontAddCharsPanel);
  fontCharPanel.add(fontSelectionPanel);
  fontParams1.add(fontCharPanel);
  fontParams1.add(fontEmbedButton);
  fontPanel.setLayout(new BorderLayout());
  fontParams1.add(Box.createVerticalGlue());
  fontPanel.add(new JScrollPane(fontParams1),BorderLayout.CENTER);
  displayWithPreview.add(fontPanel,CARDFONTPANEL);
  Component leftComponent=null;
  displayPanel=new JPanel(new CardLayout());
  if (flashPanel != null) {
    JPanel flashPlayPanel=new JPanel(new BorderLayout());
    flashPlayPanel.add(flashPanel,BorderLayout.CENTER);
    flashPlayPanel.add(flashControls=new PlayerControls(flashPanel),BorderLayout.SOUTH);
    leftComponent=flashPlayPanel;
  }
 else {
    JPanel swtPanel=new JPanel(new BorderLayout());
    swtPanel.add(new JLabel(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"",JLabel.CENTER),BorderLayout.CENTER);
    swtPanel.setBackground(View.DEFAULT_BACKGROUND_COLOR);
    leftComponent=swtPanel;
  }
  textValue.setContentType(""String_Node_Str"");
  previewSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
  previewSplitPane.setDividerLocation(300);
  JPanel pan=new JPanel(new BorderLayout());
  JLabel prevLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevLabel.setHorizontalAlignment(SwingConstants.CENTER);
  JLabel paramsLabel=new HeaderLabel(translate(""String_Node_Str""));
  paramsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  pan.add(prevLabel,BorderLayout.NORTH);
  viewerCards=new JPanel();
  viewerCards.setLayout(new CardLayout());
  internelViewerPanel=new ImagePanel();
  JPanel ivPanel=new JPanel(new BorderLayout());
  ivPanel.add(new HeaderLabel(translate(""String_Node_Str"")),BorderLayout.NORTH);
  ivPanel.add(internelViewerPanel,BorderLayout.CENTER);
  viewerCards.add(ivPanel,INTERNAL_VIEWER_CARD);
  ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
  if (flashPanel != null) {
    JPanel bottomPanel=new JPanel(new BorderLayout());
    JPanel buttonsPanel=new JPanel(new FlowLayout());
    JButton selectColorButton=new JButton(View.getIcon(""String_Node_Str""));
    selectColorButton.addActionListener(this);
    selectColorButton.setActionCommand(""String_Node_Str"");
    selectColorButton.setToolTipText(AppStrings.translate(""String_Node_Str""));
    buttonsPanel.add(selectColorButton);
    bottomPanel.add(buttonsPanel,BorderLayout.EAST);
    pan.add(bottomPanel,BorderLayout.SOUTH);
  }
  pan.add(leftComponent,BorderLayout.CENTER);
  viewerCards.add(pan,FLASH_VIEWER_CARD);
  previewSplitPane.setLeftComponent(viewerCards);
  parametersPanel=new JPanel(new BorderLayout());
  parametersPanel.add(paramsLabel,BorderLayout.NORTH);
  parametersPanel.add(displayWithPreview,BorderLayout.CENTER);
  previewSplitPane.setRightComponent(parametersPanel);
  parametersPanel.setVisible(false);
  displayPanel.add(previewSplitPane,CARDFLASHPANEL);
  imagePanel=new ImagePanel();
  JPanel imagesCard=new JPanel(new BorderLayout());
  imagesCard.add(imagePanel,BorderLayout.CENTER);
  imageReplaceButton=new JButton(translate(""String_Node_Str""),View.getIcon(""String_Node_Str""));
  imageReplaceButton.setMargin(new Insets(3,3,3,10));
  imageReplaceButton.setActionCommand(""String_Node_Str"");
  imageReplaceButton.addActionListener(this);
  imageButtonsPanel=new JPanel(new FlowLayout());
  imageButtonsPanel.add(imageReplaceButton);
  imagesCard.add(imageButtonsPanel,BorderLayout.SOUTH);
  displayPanel.add(imagesCard,CARDIMAGEPANEL);
  JPanel shapesCard=new JPanel(new BorderLayout());
  JPanel previewPanel=new JPanel(new BorderLayout());
  previewImagePanel=new ImagePanel();
  JPanel previewCnt=new JPanel(new BorderLayout());
  previewCnt.add(previewImagePanel,BorderLayout.CENTER);
  previewCnt.add(new PlayerControls(previewImagePanel),BorderLayout.SOUTH);
  previewPanel.add(previewCnt,BorderLayout.CENTER);
  JLabel prevIntLabel=new HeaderLabel(translate(""String_Node_Str""));
  prevIntLabel.setHorizontalAlignment(SwingConstants.CENTER);
  previewPanel.add(prevIntLabel,BorderLayout.NORTH);
  shapesCard.add(previewPanel,BorderLayout.CENTER);
  displayPanel.add(shapesCard,CARDDRAWPREVIEWPANEL);
  swfPreviewPanel=new SWFPreviwPanel();
  displayPanel.add(swfPreviewPanel,CARDSWFPREVIEWPANEL);
  displayPanel.add(new JPanel(),CARDEMPTYPANEL);
  if (actionPanel != null) {
    displayPanel.add(actionPanel,CARDACTIONSCRIPTPANEL);
  }
  if (abcPanel != null) {
    displayPanel.add(abcPanel,CARDACTIONSCRIPTPANEL);
  }
  CardLayout cl=(CardLayout)(displayPanel.getLayout());
  cl.show(displayPanel,CARDEMPTYPANEL);
  searchPanel=new JPanel();
  searchPanel.setLayout(new BorderLayout());
  searchPanel.add(filterField,BorderLayout.CENTER);
  searchPanel.add(new JLabel(View.getIcon(""String_Node_Str"")),BorderLayout.WEST);
  JLabel closeSearchButton=new JLabel(View.getIcon(""String_Node_Str""));
  closeSearchButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      filterField.setText(""String_Node_Str"");
      doFilter();
      searchPanel.setVisible(false);
    }
  }
);
  searchPanel.add(closeSearchButton,BorderLayout.EAST);
  JPanel pan1=new JPanel(new BorderLayout());
  pan1.add(new JScrollPane(tagTree),BorderLayout.CENTER);
  pan1.add(searchPanel,BorderLayout.SOUTH);
  filterField.setActionCommand(""String_Node_Str"");
  filterField.addActionListener(this);
  searchPanel.setVisible(false);
  filterField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      warn();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      warn();
    }
    public void warn(){
      doFilter();
    }
  }
);
  splitPane2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,pan1,detailPanel);
  splitPane1=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,splitPane2,displayPanel);
  if (swf == null) {
    JPanel welcomePanel=new JPanel();
    welcomePanel.setLayout(new BoxLayout(welcomePanel,BoxLayout.Y_AXIS));
    JLabel welcomeToLabel=new JLabel(translate(""String_Node_Str""));
    welcomeToLabel.setFont(welcomeToLabel.getFont().deriveFont(40));
    welcomeToLabel.setAlignmentX(0.5f);
    JPanel appNamePanel=new JPanel(new FlowLayout());
    JLabel jpLabel=new JLabel(""String_Node_Str"");
    jpLabel.setAlignmentX(0.5f);
    jpLabel.setForeground(new Color(0,0,160));
    jpLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    jpLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(jpLabel);
    JLabel ffLabel=new JLabel(""String_Node_Str"");
    ffLabel.setAlignmentX(0.5f);
    ffLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    ffLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(ffLabel);
    JLabel decLabel=new JLabel(""String_Node_Str"");
    decLabel.setAlignmentX(0.5f);
    decLabel.setForeground(Color.red);
    decLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,50));
    decLabel.setHorizontalAlignment(SwingConstants.CENTER);
    appNamePanel.add(decLabel);
    appNamePanel.setAlignmentX(0.5f);
    welcomePanel.add(Box.createGlue());
    welcomePanel.add(welcomeToLabel);
    welcomePanel.add(appNamePanel);
    JLabel startLabel=new JLabel(translate(""String_Node_Str""));
    startLabel.setAlignmentX(0.5f);
    startLabel.setFont(startLabel.getFont().deriveFont(30));
    welcomePanel.add(startLabel);
    welcomePanel.add(Box.createGlue());
    cnt.add(welcomePanel,BorderLayout.CENTER);
    actionPanel=null;
    abcPanel=null;
  }
 else {
    cnt.add(splitPane1,BorderLayout.CENTER);
  }
  splitPane1.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (splitsInited) {
        Configuration.guiSplitPane1DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  splitPane2.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      if (detailPanel.isVisible()) {
        Configuration.guiSplitPane2DividerLocation.set((int)pce.getNewValue());
      }
    }
  }
);
  View.centerScreen(this);
  tagTree.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      if ((e.getKeyCode() == 'F') && (e.isControlDown())) {
        searchPanel.setVisible(true);
        filterField.requestFocusInWindow();
      }
    }
  }
);
  detailPanel.setVisible(false);
  enableDrop(true);
}",0.9871833994507172
61957,"@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ""String_Node_Str"":
    if (oldValue instanceof FontTag) {
      FontEmbedDialog fed=new FontEmbedDialog(fontSelection.getSelectedItem().toString(),fontAddCharactersField.getText(),((FontTag)oldValue).getFontStyle());
      if (fed.display()) {
        Set<Integer> selChars=fed.getSelectedChars();
        if (!selChars.isEmpty()) {
          String selFont=fed.getSelectedFont();
          fontSelection.setSelectedItem(selFont);
          fontAddChars((FontTag)oldValue,selChars,selFont);
          fontAddCharactersField.setText(""String_Node_Str"");
          reload(true);
        }
      }
    }
  break;
case ""String_Node_Str"":
Color newColor=JColorChooser.showDialog(null,AppStrings.translate(""String_Node_Str""),View.swfBackgroundColor);
if (newColor != null) {
View.swfBackgroundColor=newColor;
reload(true);
}
break;
case ""String_Node_Str"":
if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
Main.reloadSWF();
}
break;
case ""String_Node_Str"":
Main.advancedSettings();
break;
case ""String_Node_Str"":
Main.loadFromMemory();
break;
case ""String_Node_Str"":
Main.loadFromCache();
break;
case ""String_Node_Str"":
Main.displayErrorFrame();
break;
case ""String_Node_Str"":
String newchars=fontAddCharactersField.getText();
if (oldValue instanceof FontTag) {
Set<Integer> selChars=new TreeSet<>();
for (int c=0; c < newchars.length(); c++) {
selChars.add(newchars.codePointAt(c));
}
fontAddChars((FontTag)oldValue,selChars,fontSelection.getSelectedItem().toString());
fontAddCharactersField.setText(""String_Node_Str"");
reload(true);
}
break;
case ""String_Node_Str"":
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ""String_Node_Str"":
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ""String_Node_Str"":
new SelectLanguageDialog().display();
break;
case ""String_Node_Str"":
Configuration.decompile.set(!miDecompile.isSelected());
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
reload(true);
doFilter();
break;
case ""String_Node_Str"":
if (miAssociate.isSelected() == Main.isAddedToContextMenu()) {
return;
}
Main.addToContextMenu(miAssociate.isSelected());
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(Main.isAddedToContextMenu());
}
}
,1000);
break;
case ""String_Node_Str"":
gotoDocumentClass();
break;
case ""String_Node_Str"":
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ""String_Node_Str"":
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
reload(true);
break;
case ""String_Node_Str"":
if (searchDialog == null) {
searchDialog=new SearchDialog();
}
searchDialog.setVisible(true);
if (searchDialog.result) {
final String txt=searchDialog.searchField.getText();
if (!txt.isEmpty()) {
if (abcPanel != null) {
(new Thread(){
@Override public void run(){
if (abcPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
View.execInEventDispatch(new Runnable(){
@Override public void run(){
showDetail(DETAILCARDAS3NAVIGATOR);
showCard(CARDACTIONSCRIPTPANEL);
}
}
);
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
}
).start();
}
 else {
(new Thread(){
@Override public void run(){
if (actionPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
View.execInEventDispatch(new Runnable(){
@Override public void run(){
showCard(CARDACTIONSCRIPTPANEL);
}
}
);
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
}
).start();
}
}
}
break;
case ""String_Node_Str"":
Object tagObj=tagTree.getLastSelectedPathComponent();
if (tagObj == null) {
return;
}
if (tagObj instanceof TagNode) {
tagObj=((TagNode)tagObj).tag;
}
if (tagObj instanceof ImageTag) {
ImageTag it=(ImageTag)tagObj;
if (it.importSupported()) {
JFileChooser fc=new JFileChooser();
fc.setCurrentDirectory(new File(Configuration.lastOpenDir.get()));
fc.setFileFilter(new FileFilter(){
@Override public boolean accept(File f){
return (f.getName().toLowerCase().endsWith(""String_Node_Str"")) || (f.getName().toLowerCase().endsWith(""String_Node_Str"")) || (f.getName().toLowerCase().endsWith(""String_Node_Str""))|| (f.getName().toLowerCase().endsWith(""String_Node_Str""))|| (f.isDirectory());
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
);
JFrame f=new JFrame();
View.setWindowIcon(f);
int returnVal=fc.showOpenDialog(f);
if (returnVal == JFileChooser.APPROVE_OPTION) {
Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
File selfile=Helper.fixDialogFile(fc.getSelectedFile());
byte[] data=Helper.readFile(selfile.getAbsolutePath());
try {
it.setImage(data);
swf.clearImageCache();
}
 catch (IOException ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
reload(true);
}
}
}
break;
case ""String_Node_Str"":
List<Object> sel=getSelected(tagTree);
List<Tag> tagsToRemove=new ArrayList<>();
for (Object o : sel) {
Object tag=o;
if (o instanceof TagNode) {
tag=((TagNode)o).tag;
}
if (tag instanceof Tag) {
tagsToRemove.add((Tag)tag);
}
}
if (tagsToRemove.size() == 1) {
Tag tag=tagsToRemove.get(0);
if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",tag.toString()),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
swf.removeTag(tag);
showCard(CARDEMPTYPANEL);
refreshTree();
}
}
 else if (tagsToRemove.size() > 1) {
if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(tagsToRemove.size())),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
for (Tag tag : tagsToRemove) {
swf.removeTag(tag);
}
showCard(CARDEMPTYPANEL);
refreshTree();
}
}
break;
case ""String_Node_Str"":
setEditText(true);
break;
case ""String_Node_Str"":
setEditText(false);
break;
case ""String_Node_Str"":
if (oldValue instanceof TextTag) {
try {
if (((TextTag)oldValue).setFormattedText(new MissingCharacterHandler(){
@Override public boolean handle(FontTag font,List<Tag> tags,char character){
String fontName=sourceFontsMap.get(font.getFontId());
if (fontName == null) {
fontName=font.getFontName(tags);
}
fontName=FontTag.findInstalledFontName(fontName);
Font f=new Font(fontName,font.getFontStyle(),18);
if (!f.canDisplay(character)) {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + character),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
return false;
}
font.addCharacter(tags,character,fontName);
return true;
}
}
,swf.tags,textValue.getText(),fontSelection.getSelectedItem().toString())) {
setEditText(false);
}
}
 catch (ParseException ex) {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
}
break;
case ""String_Node_Str"":
if (View.showConfirmDialog(this,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
reload(true);
doFilter();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ""String_Node_Str"":
setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ""String_Node_Str"":
if (swf.fileAttributes.actionScript3) {
final int multiName=abcPanel.decompiledTextArea.getMultinameUnderCursor();
if (multiName > 0) {
(new Thread(){
@Override public void run(){
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
renameMultiname(multiName);
Main.stopWork();
}
}
).start();
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
 else {
final String identifier=actionPanel.getStringUnderCursor();
if (identifier != null) {
(new Thread(){
@Override public void run(){
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
try {
renameIdentifier(identifier);
}
 catch (InterruptedException ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,null,ex);
}
Main.stopWork();
}
}
).start();
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
break;
case ""String_Node_Str"":
Main.about();
break;
case ""String_Node_Str"":
Main.showProxy();
break;
case ""String_Node_Str"":
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ""String_Node_Str"":
try {
Main.saveFile(Main.file);
}
 catch (IOException ex) {
Logger.getLogger(com.jpexs.decompiler.flash.gui.abc.ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ""String_Node_Str"":
if (Main.saveFileDialog()) {
setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + Main.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(!Main.readOnly);
}
break;
case ""String_Node_Str"":
Main.openFileDialog();
break;
case ""String_Node_Str"":
JFileChooser fc=new JFileChooser();
String selDir=Configuration.lastOpenDir.get();
fc.setCurrentDirectory(new File(selDir));
if (!selDir.endsWith(File.separator)) {
selDir+=File.separator;
}
String fileName=(new File(Main.file).getName());
fileName=fileName.substring(0,fileName.length() - 4) + ""String_Node_Str"";
fc.setSelectedFile(new File(selDir + fileName));
FileFilter fla=new FileFilter(){
@Override public boolean accept(File f){
return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
;
FileFilter xfl=new FileFilter(){
@Override public boolean accept(File f){
return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
;
fc.setFileFilter(fla);
fc.addChoosableFileFilter(xfl);
fc.setAcceptAllFileFilterUsed(false);
JFrame f=new JFrame();
View.setWindowIcon(f);
int returnVal=fc.showSaveDialog(f);
if (returnVal == JFileChooser.APPROVE_OPTION) {
Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
File sf=Helper.fixDialogFile(fc.getSelectedFile());
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
final boolean compressed=fc.getFileFilter() == fla;
if (!compressed) {
if (sf.getName().endsWith(""String_Node_Str"")) {
sf=new File(sf.getAbsolutePath().substring(0,sf.getAbsolutePath().length() - 4) + ""String_Node_Str"");
}
}
final File selfile=sf;
(new Thread(){
@Override public void run(){
Helper.freeMem();
try {
if (compressed) {
swf.exportFla(errorHandler,selfile.getAbsolutePath(),new File(Main.file).getName(),ApplicationInfo.applicationName,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get());
}
 else {
swf.exportXfl(errorHandler,selfile.getAbsolutePath(),new File(Main.file).getName(),ApplicationInfo.applicationName,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get());
}
}
 catch (IOException ex) {
View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage(),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
Helper.freeMem();
Main.stopWork();
}
}
).start();
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
final ExportDialog export=new ExportDialog();
export.setVisible(true);
if (!export.cancelled) {
JFileChooser chooser=new JFileChooser();
chooser.setCurrentDirectory(new File(Configuration.lastExportDir.get()));
chooser.setDialogTitle(translate(""String_Node_Str""));
chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
chooser.setAcceptAllFileFilterUsed(false);
if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
final long timeBefore=System.currentTimeMillis();
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
final String selFile=Helper.fixDialogFile(chooser.getSelectedFile()).getAbsolutePath();
Configuration.lastExportDir.set(Helper.fixDialogFile(chooser.getSelectedFile()).getAbsolutePath());
final ExportMode exportMode=ExportMode.get(export.getOption(ExportDialog.OPTION_ACTIONSCRIPT));
final boolean isMp3OrWav=export.getOption(ExportDialog.OPTION_SOUNDS) == 0;
final boolean isFormatted=export.getOption(ExportDialog.OPTION_TEXTS) == 1;
final boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
(new Thread(){
@Override public void run(){
try {
if (onlySel) {
exportSelection(errorHandler,selFile,export);
}
 else {
swf.exportImages(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportShapes(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportTexts(errorHandler,selFile + File.separator + ""String_Node_Str"",isFormatted);
swf.exportMovies(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportSounds(errorHandler,selFile + File.separator + ""String_Node_Str"",isMp3OrWav,isMp3OrWav);
swf.exportBinaryData(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportActionScript(errorHandler,selFile,exportMode,Configuration.parallelSpeedUp.get());
}
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage());
}
Main.stopWork();
long timeAfter=System.currentTimeMillis();
long timeMs=timeAfter - timeBefore;
setStatus(translate(""String_Node_Str"").replace(""String_Node_Str"",Helper.formatTimeSec(timeMs)));
}
}
).start();
}
}
break;
case ""String_Node_Str"":
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ""String_Node_Str"":
String helpUsURL=ApplicationInfo.projectPage + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ""String_Node_Str"":
String homePageURL=ApplicationInfo.projectPage;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
Main.startWork(translate(""String_Node_Str""));
final boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
if ((!all) || confirmExperimental()) {
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
int cnt=0;
if (all) {
for (ABCContainerTag tag : abcPanel.list) {
tag.getABC().restoreControlFlow();
}
}
 else {
int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
if (bi != -1) {
abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,abcPanel.decompiledTextArea.getCurrentTrait(),abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,abcPanel.decompiledTextArea.getCurrentTrait());
}
Main.stopWork();
View.showMessageDialog(null,""String_Node_Str"");
abcPanel.reload();
doFilter();
return true;
}
}
.execute();
}
break;
case ""String_Node_Str"":
if (confirmExperimental()) {
final RenameType renameType=new RenameDialog().display();
if (renameType != null) {
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
try {
int cnt=0;
cnt=swf.deobfuscateIdentifiers(renameType);
Main.stopWork();
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + cnt));
swf.assignClassesToSymbols();
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
doFilter();
reload(true);
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
return true;
}
}
.execute();
}
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
if (deobfuscationDialog == null) {
deobfuscationDialog=new DeobfuscationDialog();
}
deobfuscationDialog.setVisible(true);
if (deobfuscationDialog.ok) {
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
try {
if (deobfuscationDialog.processAllCheckbox.isSelected()) {
for (ABCContainerTag tag : abcPanel.list) {
if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
tag.getABC().removeDeadCode();
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
tag.getABC().removeTraps();
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
tag.getABC().removeTraps();
tag.getABC().restoreControlFlow();
}
}
}
 else {
int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
Trait t=abcPanel.decompiledTextArea.getCurrentTrait();
if (bi != -1) {
if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
abcPanel.abc.bodies[bi].removeDeadCode(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
}
abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,t);
}
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
Main.stopWork();
View.showMessageDialog(null,translate(""String_Node_Str""));
clearCache();
abcPanel.reload();
doFilter();
return true;
}
}
.execute();
}
break;
}
}","@Override public void actionPerformed(ActionEvent e){
switch (e.getActionCommand()) {
case ""String_Node_Str"":
    if (oldValue instanceof FontTag) {
      FontEmbedDialog fed=new FontEmbedDialog(fontSelection.getSelectedItem().toString(),fontAddCharactersField.getText(),((FontTag)oldValue).getFontStyle());
      if (fed.display()) {
        Set<Integer> selChars=fed.getSelectedChars();
        if (!selChars.isEmpty()) {
          String selFont=fed.getSelectedFont();
          fontSelection.setSelectedItem(selFont);
          fontAddChars((FontTag)oldValue,selChars,selFont);
          fontAddCharactersField.setText(""String_Node_Str"");
          reload(true);
        }
      }
    }
  break;
case ""String_Node_Str"":
Color newColor=JColorChooser.showDialog(null,AppStrings.translate(""String_Node_Str""),View.swfBackgroundColor);
if (newColor != null) {
View.swfBackgroundColor=newColor;
reload(true);
}
break;
case ""String_Node_Str"":
if (View.showConfirmDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
Main.reloadSWF();
}
break;
case ""String_Node_Str"":
Main.advancedSettings();
break;
case ""String_Node_Str"":
Main.loadFromMemory();
break;
case ""String_Node_Str"":
Main.loadFromCache();
break;
case ""String_Node_Str"":
Main.displayErrorFrame();
break;
case ""String_Node_Str"":
String newchars=fontAddCharactersField.getText();
if (oldValue instanceof FontTag) {
Set<Integer> selChars=new TreeSet<>();
for (int c=0; c < newchars.length(); c++) {
selChars.add(newchars.codePointAt(c));
}
fontAddChars((FontTag)oldValue,selChars,fontSelection.getSelectedItem().toString());
fontAddCharactersField.setText(""String_Node_Str"");
reload(true);
}
break;
case ""String_Node_Str"":
Configuration.gotoMainClassOnStartup.set(miGotoMainClassOnStartup.isSelected());
break;
case ""String_Node_Str"":
Configuration.cacheOnDisk.set(miCacheDisk.isSelected());
if (miCacheDisk.isSelected()) {
Cache.setStorageType(Cache.STORAGE_FILES);
}
 else {
Cache.setStorageType(Cache.STORAGE_MEMORY);
}
break;
case ""String_Node_Str"":
new SelectLanguageDialog().display();
break;
case ""String_Node_Str"":
Configuration.decompile.set(!miDecompile.isSelected());
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
reload(true);
doFilter();
break;
case ""String_Node_Str"":
if (miAssociate.isSelected() == Main.isAddedToContextMenu()) {
return;
}
Main.addToContextMenu(miAssociate.isSelected());
new Timer().schedule(new TimerTask(){
@Override public void run(){
miAssociate.setSelected(Main.isAddedToContextMenu());
}
}
,1000);
break;
case ""String_Node_Str"":
gotoDocumentClass();
break;
case ""String_Node_Str"":
String confStr=translate(""String_Node_Str"") + ""String_Node_Str"";
if (miParallelSpeedUp.isSelected()) {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
 else {
confStr+=""String_Node_Str"" + translate(""String_Node_Str"");
}
if (View.showConfirmDialog(null,confStr,translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.parallelSpeedUp.set((Boolean)miParallelSpeedUp.isSelected());
}
 else {
miParallelSpeedUp.setSelected(!miParallelSpeedUp.isSelected());
}
break;
case ""String_Node_Str"":
Configuration.internalFlashViewer.set(miInternalViewer.isSelected());
reload(true);
break;
case ""String_Node_Str"":
if (searchDialog == null) {
searchDialog=new SearchDialog();
}
searchDialog.setVisible(true);
if (searchDialog.result) {
final String txt=searchDialog.searchField.getText();
if (!txt.isEmpty()) {
if (abcPanel != null) {
(new Thread(){
@Override public void run(){
if (abcPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
View.execInEventDispatch(new Runnable(){
@Override public void run(){
showDetail(DETAILCARDAS3NAVIGATOR);
showCard(CARDACTIONSCRIPTPANEL);
}
}
);
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
}
).start();
}
 else {
(new Thread(){
@Override public void run(){
if (actionPanel.search(txt,searchDialog.ignoreCaseCheckBox.isSelected(),searchDialog.regexpCheckBox.isSelected())) {
View.execInEventDispatch(new Runnable(){
@Override public void run(){
showCard(CARDACTIONSCRIPTPANEL);
}
}
);
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",txt),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
}
).start();
}
}
}
break;
case ""String_Node_Str"":
Object tagObj=tagTree.getLastSelectedPathComponent();
if (tagObj == null) {
return;
}
if (tagObj instanceof TagNode) {
tagObj=((TagNode)tagObj).tag;
}
if (tagObj instanceof ImageTag) {
ImageTag it=(ImageTag)tagObj;
if (it.importSupported()) {
JFileChooser fc=new JFileChooser();
fc.setCurrentDirectory(new File(Configuration.lastOpenDir.get()));
fc.setFileFilter(new FileFilter(){
@Override public boolean accept(File f){
return (f.getName().toLowerCase().endsWith(""String_Node_Str"")) || (f.getName().toLowerCase().endsWith(""String_Node_Str"")) || (f.getName().toLowerCase().endsWith(""String_Node_Str""))|| (f.getName().toLowerCase().endsWith(""String_Node_Str""))|| (f.isDirectory());
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
);
JFrame f=new JFrame();
View.setWindowIcon(f);
int returnVal=fc.showOpenDialog(f);
if (returnVal == JFileChooser.APPROVE_OPTION) {
Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
File selfile=Helper.fixDialogFile(fc.getSelectedFile());
byte[] data=Helper.readFile(selfile.getAbsolutePath());
try {
it.setImage(data);
swf.clearImageCache();
}
 catch (IOException ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
reload(true);
}
}
}
break;
case ""String_Node_Str"":
List<Object> sel=getSelected(tagTree);
List<Tag> tagsToRemove=new ArrayList<>();
for (Object o : sel) {
Object tag=o;
if (o instanceof TagNode) {
tag=((TagNode)o).tag;
}
if (tag instanceof Tag) {
tagsToRemove.add((Tag)tag);
}
}
if (tagsToRemove.size() == 1) {
Tag tag=tagsToRemove.get(0);
if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",tag.toString()),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
swf.removeTag(tag);
showCard(CARDEMPTYPANEL);
refreshTree();
}
}
 else if (tagsToRemove.size() > 1) {
if (View.showConfirmDialog(this,translate(""String_Node_Str"").replace(""String_Node_Str"",Integer.toString(tagsToRemove.size())),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
for (Tag tag : tagsToRemove) {
swf.removeTag(tag);
}
showCard(CARDEMPTYPANEL);
refreshTree();
}
}
break;
case ""String_Node_Str"":
setEditText(true);
break;
case ""String_Node_Str"":
setEditText(false);
break;
case ""String_Node_Str"":
if (oldValue instanceof TextTag) {
try {
if (((TextTag)oldValue).setFormattedText(new MissingCharacterHandler(){
@Override public boolean handle(FontTag font,List<Tag> tags,char character){
String fontName=sourceFontsMap.get(font.getFontId());
if (fontName == null) {
fontName=font.getFontName(tags);
}
fontName=FontTag.findInstalledFontName(fontName);
Font f=new Font(fontName,font.getFontStyle(),18);
if (!f.canDisplay(character)) {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + character),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
return false;
}
font.addCharacter(tags,character,fontName);
return true;
}
}
,swf.tags,textValue.getText(),fontSelection.getSelectedItem().toString())) {
setEditText(false);
}
}
 catch (ParseException ex) {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",ex.text).replace(""String_Node_Str"",""String_Node_Str"" + ex.line),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
}
break;
case ""String_Node_Str"":
if (View.showConfirmDialog(this,translate(""String_Node_Str"") + ""String_Node_Str"" + (miAutoDeobfuscation.isSelected() ? translate(""String_Node_Str"") : translate(""String_Node_Str"")),translate(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
Configuration.autoDeobfuscate.set(miAutoDeobfuscation.isSelected());
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
reload(true);
doFilter();
}
 else {
miAutoDeobfuscation.setSelected(!miAutoDeobfuscation.isSelected());
}
break;
case ""String_Node_Str"":
setVisible(false);
if (Main.proxyFrame != null) {
if (Main.proxyFrame.isVisible()) {
return;
}
}
Main.exit();
break;
}
if (Main.isWorking()) {
return;
}
switch (e.getActionCommand()) {
case ""String_Node_Str"":
if (swf.fileAttributes.actionScript3) {
final int multiName=abcPanel.decompiledTextArea.getMultinameUnderCursor();
if (multiName > 0) {
(new Thread(){
@Override public void run(){
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
renameMultiname(multiName);
Main.stopWork();
}
}
).start();
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
 else {
final String identifier=actionPanel.getStringUnderCursor();
if (identifier != null) {
(new Thread(){
@Override public void run(){
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
try {
renameIdentifier(identifier);
}
 catch (InterruptedException ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,null,ex);
}
Main.stopWork();
}
}
).start();
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
}
break;
case ""String_Node_Str"":
Main.about();
break;
case ""String_Node_Str"":
Main.showProxy();
break;
case ""String_Node_Str"":
if (e.getSource() instanceof JCheckBoxMenuItem) {
Main.setSubLimiter(((JCheckBoxMenuItem)e.getSource()).getState());
}
break;
case ""String_Node_Str"":
try {
Main.saveFile(Main.file);
}
 catch (IOException ex) {
Logger.getLogger(com.jpexs.decompiler.flash.gui.abc.ABCPanel.class.getName()).log(Level.SEVERE,null,ex);
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
break;
case ""String_Node_Str"":
if (Main.saveFileDialog()) {
setTitle(ApplicationInfo.applicationVerName + (Configuration.displayFileName.get() ? ""String_Node_Str"" + Main.getFileTitle() : ""String_Node_Str""));
saveCommandButton.setEnabled(!Main.readOnly);
}
break;
case ""String_Node_Str"":
Main.openFileDialog();
break;
case ""String_Node_Str"":
JFileChooser fc=new JFileChooser();
String selDir=Configuration.lastOpenDir.get();
fc.setCurrentDirectory(new File(selDir));
if (!selDir.endsWith(File.separator)) {
selDir+=File.separator;
}
String fileName=(new File(Main.file).getName());
fileName=fileName.substring(0,fileName.length() - 4) + ""String_Node_Str"";
fc.setSelectedFile(new File(selDir + fileName));
FileFilter fla=new FileFilter(){
@Override public boolean accept(File f){
return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
;
FileFilter xfl=new FileFilter(){
@Override public boolean accept(File f){
return f.isDirectory() || (f.getName().toLowerCase().endsWith(""String_Node_Str""));
}
@Override public String getDescription(){
return translate(""String_Node_Str"");
}
}
;
fc.setFileFilter(fla);
fc.addChoosableFileFilter(xfl);
fc.setAcceptAllFileFilterUsed(false);
JFrame f=new JFrame();
View.setWindowIcon(f);
int returnVal=fc.showSaveDialog(f);
if (returnVal == JFileChooser.APPROVE_OPTION) {
Configuration.lastOpenDir.set(Helper.fixDialogFile(fc.getSelectedFile()).getParentFile().getAbsolutePath());
File sf=Helper.fixDialogFile(fc.getSelectedFile());
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
final boolean compressed=fc.getFileFilter() == fla;
if (!compressed) {
if (sf.getName().endsWith(""String_Node_Str"")) {
sf=new File(sf.getAbsolutePath().substring(0,sf.getAbsolutePath().length() - 4) + ""String_Node_Str"");
}
}
final File selfile=sf;
(new Thread(){
@Override public void run(){
Helper.freeMem();
try {
if (compressed) {
swf.exportFla(errorHandler,selfile.getAbsolutePath(),new File(Main.file).getName(),ApplicationInfo.applicationName,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get());
}
 else {
swf.exportXfl(errorHandler,selfile.getAbsolutePath(),new File(Main.file).getName(),ApplicationInfo.applicationName,ApplicationInfo.applicationVerName,ApplicationInfo.version,Configuration.parallelSpeedUp.get());
}
}
 catch (IOException ex) {
View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage(),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
}
Helper.freeMem();
Main.stopWork();
}
}
).start();
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
final ExportDialog export=new ExportDialog();
export.setVisible(true);
if (!export.cancelled) {
JFileChooser chooser=new JFileChooser();
chooser.setCurrentDirectory(new File(Configuration.lastExportDir.get()));
chooser.setDialogTitle(translate(""String_Node_Str""));
chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
chooser.setAcceptAllFileFilterUsed(false);
if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
final long timeBefore=System.currentTimeMillis();
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
final String selFile=Helper.fixDialogFile(chooser.getSelectedFile()).getAbsolutePath();
Configuration.lastExportDir.set(Helper.fixDialogFile(chooser.getSelectedFile()).getAbsolutePath());
final ExportMode exportMode=ExportMode.get(export.getOption(ExportDialog.OPTION_ACTIONSCRIPT));
final boolean isMp3OrWav=export.getOption(ExportDialog.OPTION_SOUNDS) == 0;
final boolean isFormatted=export.getOption(ExportDialog.OPTION_TEXTS) == 1;
final boolean onlySel=e.getActionCommand().endsWith(""String_Node_Str"");
(new Thread(){
@Override public void run(){
try {
if (onlySel) {
exportSelection(errorHandler,selFile,export);
}
 else {
swf.exportImages(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportShapes(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportTexts(errorHandler,selFile + File.separator + ""String_Node_Str"",isFormatted);
swf.exportMovies(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportSounds(errorHandler,selFile + File.separator + ""String_Node_Str"",isMp3OrWav,isMp3OrWav);
swf.exportBinaryData(errorHandler,selFile + File.separator + ""String_Node_Str"");
swf.exportActionScript(errorHandler,selFile,exportMode,Configuration.parallelSpeedUp.get());
}
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
View.showMessageDialog(null,translate(""String_Node_Str"") + ""String_Node_Str"" + ex.getClass().getName()+ ""String_Node_Str""+ ex.getLocalizedMessage());
}
Main.stopWork();
long timeAfter=System.currentTimeMillis();
long timeMs=timeAfter - timeBefore;
setStatus(translate(""String_Node_Str"").replace(""String_Node_Str"",Helper.formatTimeSec(timeMs)));
}
}
).start();
}
}
break;
case ""String_Node_Str"":
if (!Main.checkForUpdates()) {
View.showMessageDialog(null,translate(""String_Node_Str""),translate(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
}
break;
case ""String_Node_Str"":
String helpUsURL=ApplicationInfo.projectPage + ""String_Node_Str"";
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(helpUsURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",helpUsURL));
}
break;
case ""String_Node_Str"":
String homePageURL=ApplicationInfo.projectPage;
if (java.awt.Desktop.isDesktopSupported()) {
java.awt.Desktop desktop=java.awt.Desktop.getDesktop();
try {
java.net.URI uri=new java.net.URI(homePageURL);
desktop.browse(uri);
}
 catch (URISyntaxException|IOException ex) {
}
}
 else {
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",homePageURL));
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
Main.startWork(translate(""String_Node_Str""));
final boolean all=e.getActionCommand().endsWith(""String_Node_Str"");
if ((!all) || confirmExperimental()) {
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
int cnt=0;
if (all) {
for (ABCContainerTag tag : abcPanel.list) {
tag.getABC().restoreControlFlow();
}
}
 else {
int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
if (bi != -1) {
abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,abcPanel.decompiledTextArea.getCurrentTrait(),abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,abcPanel.decompiledTextArea.getCurrentTrait());
}
Main.stopWork();
View.showMessageDialog(null,""String_Node_Str"");
abcPanel.reload();
doFilter();
return true;
}
}
.execute();
}
break;
case ""String_Node_Str"":
if (confirmExperimental()) {
final RenameType renameType=new RenameDialog().display();
if (renameType != null) {
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
try {
int cnt=0;
cnt=swf.deobfuscateIdentifiers(renameType);
Main.stopWork();
View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + cnt));
swf.assignClassesToSymbols();
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
doFilter();
reload(true);
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
return true;
}
}
.execute();
}
}
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
if (deobfuscationDialog == null) {
deobfuscationDialog=new DeobfuscationDialog();
}
deobfuscationDialog.setVisible(true);
if (deobfuscationDialog.ok) {
Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
new SwingWorker(){
@Override protected Object doInBackground() throws Exception {
try {
if (deobfuscationDialog.processAllCheckbox.isSelected()) {
for (ABCContainerTag tag : abcPanel.list) {
if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
tag.getABC().removeDeadCode();
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
tag.getABC().removeTraps();
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
tag.getABC().removeTraps();
tag.getABC().restoreControlFlow();
}
}
}
 else {
int bi=abcPanel.detailPanel.methodTraitPanel.methodCodePanel.getBodyIndex();
Trait t=abcPanel.decompiledTextArea.getCurrentTrait();
if (bi != -1) {
if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_DEAD_CODE) {
abcPanel.abc.bodies[bi].removeDeadCode(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_REMOVE_TRAPS) {
abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
}
 else if (deobfuscationDialog.codeProcessingLevel.getValue() == DeobfuscationDialog.LEVEL_RESTORE_CONTROL_FLOW) {
abcPanel.abc.bodies[bi].removeTraps(abcPanel.abc.constants,abcPanel.abc,t,abcPanel.decompiledTextArea.getScriptLeaf().scriptIndex,abcPanel.decompiledTextArea.getClassIndex(),abcPanel.decompiledTextArea.getIsStatic(),""String_Node_Str"");
abcPanel.abc.bodies[bi].restoreControlFlow(abcPanel.abc.constants,t,abcPanel.abc.method_info[abcPanel.abc.bodies[bi].method_info]);
}
}
abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setBodyIndex(bi,abcPanel.abc,t);
}
}
 catch (Exception ex) {
Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
}
Main.stopWork();
View.showMessageDialog(null,translate(""String_Node_Str""));
clearCache();
abcPanel.reload();
doFilter();
return true;
}
}
.execute();
}
break;
case ""String_Node_Str"":
List<Tag> tags=new ArrayList<>(swf.tags);
for (Tag tag : tags) {
System.out.println(tag.getClass());
if (!(tag instanceof ABCContainerTag || tag instanceof ASMSource)) {
swf.removeTag(tag);
}
}
showCard(CARDEMPTYPANEL);
refreshTree();
break;
case ""String_Node_Str"":
clearCache();
if (abcPanel != null) {
abcPanel.reload();
}
reload(true);
doFilter();
break;
}
}",0.9908049297130752
61958,"public String getModifiers(List<ABCContainerTag> abcTags,ABC abc,boolean isStatic){
  String ret=""String_Node_Str"";
  if ((kindFlags & ATTR_Override) > 0) {
    ret+=""String_Node_Str"";
  }
  Multiname m=getName(abc);
  if (m != null) {
    String nsname=""String_Node_Str"";
{
      for (      ABCContainerTag abcTag : abcTags) {
        nsname=abcTag.getABC().nsValueToName(abc.constants.constant_namespace[m.namespace_index].getName(abc.constants));
        if (nsname.equals(""String_Node_Str"")) {
          break;
        }
        if (nsname.contains(""String_Node_Str"")) {
          nsname=nsname.substring(nsname.lastIndexOf('.') + 1);
        }
        if (!nsname.isEmpty()) {
          break;
        }
      }
    }
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname.contains(""String_Node_Str"")) {
      nsname=""String_Node_Str"";
    }
    if ((!nsname.isEmpty()) && (!nsname.equals(""String_Node_Str""))) {
    }
 else {
      if (ns != null) {
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          nsname=ns.getName(abc.constants);
        }
      }
    }
    if ((!nsname.contains(""String_Node_Str"")) && (!nsname.isEmpty())) {
      ret+=""String_Node_Str"" + nsname;
    }
    if (ns != null) {
      ret+=""String_Node_Str"" + ns.getPrefix(abc);
    }
  }
  if (isStatic) {
    ret+=""String_Node_Str"";
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      ret+=""String_Node_Str"";
    }
  }
  return ret.trim();
}","public String getModifiers(List<ABCContainerTag> abcTags,ABC abc,boolean isStatic){
  String ret=""String_Node_Str"";
  if ((kindFlags & ATTR_Override) > 0) {
    ret+=""String_Node_Str"";
  }
  Multiname m=getName(abc);
  if (m != null) {
    String nsname=""String_Node_Str"";
{
      for (      ABCContainerTag abcTag : abcTags) {
        if (m.namespace_index == -1) {
          break;
        }
        nsname=abcTag.getABC().nsValueToName(abc.constants.constant_namespace[m.namespace_index].getName(abc.constants));
        if (nsname.equals(""String_Node_Str"")) {
          break;
        }
        if (nsname.contains(""String_Node_Str"")) {
          nsname=nsname.substring(nsname.lastIndexOf('.') + 1);
        }
        if (!nsname.isEmpty()) {
          break;
        }
      }
    }
    Namespace ns=m.getNamespace(abc.constants);
    if (nsname.contains(""String_Node_Str"")) {
      nsname=""String_Node_Str"";
    }
    if ((!nsname.isEmpty()) && (!nsname.equals(""String_Node_Str""))) {
    }
 else {
      if (ns != null) {
        if (ns.kind == Namespace.KIND_NAMESPACE) {
          nsname=ns.getName(abc.constants);
        }
      }
    }
    if ((!nsname.contains(""String_Node_Str"")) && (!nsname.isEmpty())) {
      ret+=""String_Node_Str"" + nsname;
    }
    if (ns != null) {
      ret+=""String_Node_Str"" + ns.getPrefix(abc);
    }
  }
  if (isStatic) {
    ret+=""String_Node_Str"";
  }
  if ((kindFlags & ATTR_Final) > 0) {
    if (!isStatic) {
      ret+=""String_Node_Str"";
    }
  }
  return ret.trim();
}",0.9777777777777776
61959,"public ConfigurationItem(String name,T defaultValue,T value){
  hasValue=true;
  this.defaultValue=defaultValue;
  this.value=value;
}","public ConfigurationItem(String name,T defaultValue,T value){
  this.name=name;
  hasValue=true;
  this.defaultValue=defaultValue;
  this.value=value;
}",0.9370629370629372
61960,"private static void setConfigurations(String cfgStr){
  String[] cfgs;
  if (cfgStr.contains(""String_Node_Str"")) {
    cfgs=cfgStr.split(""String_Node_Str"");
  }
 else {
    cfgs=new String[]{cfgStr};
  }
  for (  String c : cfgs) {
    String[] cp;
    if (c.contains(""String_Node_Str"")) {
      cp=c.split(""String_Node_Str"");
    }
 else {
      cp=new String[]{c,""String_Node_Str""};
    }
    String key=cp[0];
    String value=cp[1];
    if (key.toLowerCase().equals(""String_Node_Str"".toLowerCase())) {
      key=""String_Node_Str"";
    }
    for (    ConfigurationItem<Boolean> item : commandlineConfigBoolean) {
      if (key.toLowerCase().equals(item.getName().toLowerCase())) {
        Boolean bValue=parseBooleanConfigValue(value);
        if (bValue != null) {
          System.out.println(""String_Node_Str"" + item + ""String_Node_Str""+ bValue);
          item.set(bValue);
        }
      }
    }
  }
}","private static void setConfigurations(String cfgStr){
  String[] cfgs;
  if (cfgStr.contains(""String_Node_Str"")) {
    cfgs=cfgStr.split(""String_Node_Str"");
  }
 else {
    cfgs=new String[]{cfgStr};
  }
  for (  String c : cfgs) {
    String[] cp;
    if (c.contains(""String_Node_Str"")) {
      cp=c.split(""String_Node_Str"");
    }
 else {
      cp=new String[]{c,""String_Node_Str""};
    }
    String key=cp[0];
    String value=cp[1];
    if (key.toLowerCase().equals(""String_Node_Str"".toLowerCase())) {
      key=""String_Node_Str"";
    }
    for (    ConfigurationItem<Boolean> item : commandlineConfigBoolean) {
      if (key.toLowerCase().equals(item.getName().toLowerCase())) {
        Boolean bValue=parseBooleanConfigValue(value);
        if (bValue != null) {
          System.out.println(""String_Node_Str"" + item.getName() + ""String_Node_Str""+ bValue);
          item.set(bValue);
        }
      }
    }
  }
}",0.994535519125683
61961,"public void reload(boolean forceReload){
  Object tagObj=tagTree.getLastSelectedPathComponent();
  if (tagObj == null) {
    return;
  }
  if (tagObj instanceof TagNode) {
    tagObj=((TagNode)tagObj).tag;
  }
  if (tagObj instanceof TreeElement) {
    tagObj=((TreeElement)tagObj).getItem();
  }
  if (!forceReload && (tagObj == oldValue)) {
    return;
  }
  if (flashPanel != null) {
    flashPanel.specialPlayback=false;
  }
  swfPreviewPanel.stop();
  stopFlashPlayer();
  oldValue=tagObj;
  if (tagObj instanceof ScriptPack) {
    final ScriptPack scriptLeaf=(ScriptPack)tagObj;
    if (!Main.isWorking()) {
      Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"",new Runnable(){
        @Override public void run(){
          if (setSourceTask != null) {
            setSourceTask.cancel(true);
          }
          abcPanel.decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
        }
      }
);
      FutureTask<Void> task=Helper.callAsync(new Callable<Void>(){
        @Override public Void call() throws Exception {
          int classIndex=-1;
          for (          Trait t : scriptLeaf.abc.script_info[scriptLeaf.scriptIndex].traits.traits) {
            if (t instanceof TraitClass) {
              classIndex=((TraitClass)t).class_info;
              break;
            }
          }
          abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setCode(""String_Node_Str"");
          abcPanel.navigator.setABC(abcList,scriptLeaf.abc);
          abcPanel.navigator.setClassIndex(classIndex,scriptLeaf.scriptIndex);
          abcPanel.setAbc(scriptLeaf.abc);
          abcPanel.decompiledTextArea.setScript(scriptLeaf,abcList);
          abcPanel.decompiledTextArea.setClassIndex(classIndex);
          abcPanel.decompiledTextArea.setNoTrait();
          return null;
        }
      }
,new Callback<AsyncResult<Void>>(){
        @Override public void call(        AsyncResult<Void> arg1){
          setSourceTask=null;
          Main.stopWork();
        }
      }
);
      setSourceTask=task;
    }
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPTPANEL);
    return;
  }
 else {
    showDetail(DETAILCARDEMPTYPANEL);
  }
  if ((tagObj instanceof SWFRoot)) {
    if (miInternalViewer.isSelected()) {
      showCard(CARDSWFPREVIEWPANEL);
      swfPreviewPanel.load(swf);
      swfPreviewPanel.play();
    }
 else {
      showCard(CARDFLASHPANEL);
      parametersPanel.setVisible(false);
      if (flashPanel != null) {
        Color backgroundColor=View.DEFAULT_BACKGROUND_COLOR;
        for (        Tag t : swf.tags) {
          if (t instanceof SetBackgroundColorTag) {
            backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
            break;
          }
        }
        if (flashPanel instanceof FlashPlayerPanel) {
          if (tempFile != null) {
            tempFile.delete();
          }
          try {
            tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
            tempFile.deleteOnExit();
            swf.saveTo(new FileOutputStream(tempFile));
            flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,swf.frameRate);
          }
 catch (          IOException iex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",iex);
          }
        }
      }
    }
  }
 else   if (tagObj instanceof DefineBinaryDataTag) {
    showCard(CARDEMPTYPANEL);
  }
 else   if (tagObj instanceof ASMSource) {
    showCard(CARDACTIONSCRIPTPANEL);
    actionPanel.setSource((ASMSource)tagObj,!forceReload);
  }
 else   if (tagObj instanceof ImageTag) {
    imageButtonsPanel.setVisible(((ImageTag)tagObj).importSupported());
    showCard(CARDIMAGEPANEL);
    imagePanel.setImage(((ImageTag)tagObj).getImage(swf.tags));
  }
 else   if ((tagObj instanceof DrawableTag) && (!(tagObj instanceof TextTag)) && (!(tagObj instanceof FontTag))&& (miInternalViewer.isSelected())) {
    showCard(CARDDRAWPREVIEWPANEL);
    previewImagePanel.setDrawable((DrawableTag)tagObj,swf,characters,50);
  }
 else   if ((tagObj instanceof FontTag) && (miInternalViewer.isSelected())) {
    showCard(CARDFLASHPANEL);
    previewImagePanel.setDrawable((DrawableTag)tagObj,swf,characters,50);
    showFontTag((FontTag)tagObj);
  }
 else   if (tagObj instanceof FrameNode && ((FrameNode)tagObj).isDisplayed() && (miInternalViewer.isSelected())) {
    showCard(CARDDRAWPREVIEWPANEL);
    FrameNode fn=(FrameNode)tagObj;
    List<Tag> controlTags=swf.tags;
    int containerId=0;
    RECT rect=swf.displayRect;
    int totalFrameCount=swf.frameCount;
    if (fn.getParent() instanceof DefineSpriteTag) {
      controlTags=((DefineSpriteTag)fn.getParent()).subTags;
      containerId=((DefineSpriteTag)fn.getParent()).spriteId;
      rect=((DefineSpriteTag)fn.getParent()).getRect(characters,new Stack<Integer>());
      totalFrameCount=((DefineSpriteTag)fn.getParent()).frameCount;
    }
    previewImagePanel.setImage(SWF.frameToImage(containerId,((FrameNode)tagObj).getFrame() - 1,swf.tags,controlTags,rect,totalFrameCount,new Stack<Integer>()));
  }
 else   if (((tagObj instanceof FrameNode) && ((FrameNode)tagObj).isDisplayed()) || ((tagObj instanceof CharacterTag) || (tagObj instanceof FontTag)) && (tagObj instanceof Tag)) {
    ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
    try {
      if (tempFile != null) {
        tempFile.delete();
      }
      tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
      tempFile.deleteOnExit();
      Color backgroundColor=View.swfBackgroundColor;
      if (tagObj instanceof FontTag) {
        backgroundColor=View.DEFAULT_BACKGROUND_COLOR;
      }
      int frameCount=1;
      int frameRate=swf.frameRate;
      HashMap<Integer,VideoFrameTag> videoFrames=new HashMap<>();
      DefineVideoStreamTag vs=null;
      if (tagObj instanceof DefineVideoStreamTag) {
        vs=(DefineVideoStreamTag)tagObj;
        swf.populateVideoFrames(vs.getCharacterId(),swf.tags,videoFrames);
        frameCount=videoFrames.size();
      }
      List<SoundStreamBlockTag> soundFrames=new ArrayList<>();
      if (tagObj instanceof SoundStreamHeadTypeTag) {
        SWF.populateSoundStreamBlocks(swf.tags,(Tag)tagObj,soundFrames);
        frameCount=soundFrames.size();
      }
      if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
        frameCount=100;
        frameRate=50;
      }
      if (tagObj instanceof DefineSoundTag) {
        frameCount=1;
      }
      try (FileOutputStream fos=new FileOutputStream(tempFile)){
        SWFOutputStream sos=new SWFOutputStream(fos,10);
        sos.write(""String_Node_Str"".getBytes());
        sos.write(swf.version);
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        SWFOutputStream sos2=new SWFOutputStream(baos,10);
        int width=swf.displayRect.Xmax - swf.displayRect.Xmin;
        int height=swf.displayRect.Ymax - swf.displayRect.Ymin;
        sos2.writeRECT(swf.displayRect);
        sos2.writeUI8(0);
        sos2.writeUI8(frameRate);
        sos2.writeUI16(frameCount);
        if (tagObj instanceof FrameNode) {
          FrameNode fn=(FrameNode)tagObj;
          if (fn.getParent() == null) {
            for (            Tag t : swf.tags) {
              if (t instanceof SetBackgroundColorTag) {
                backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
                break;
              }
            }
          }
        }
        sos2.writeTag(new SetBackgroundColorTag(null,new RGB(backgroundColor)));
        if (tagObj instanceof FrameNode) {
          FrameNode fn=(FrameNode)tagObj;
          Object parent=fn.getParent();
          List<ContainerItem> subs=new ArrayList<>();
          if (parent == null) {
            subs.addAll(swf.tags);
          }
 else {
            if (parent instanceof Container) {
              subs=((Container)parent).getSubItems();
            }
          }
          List<Integer> doneCharacters=new ArrayList<>();
          int frameCnt=1;
          for (          Object o : subs) {
            if (o instanceof ShowFrameTag) {
              frameCnt++;
              continue;
            }
            if (frameCnt > fn.getFrame()) {
              break;
            }
            Tag t=(Tag)o;
            Set<Integer> needed=t.getDeepNeededCharacters(characters,new ArrayList<Integer>());
            for (            int n : needed) {
              if (!doneCharacters.contains(n)) {
                sos2.writeTag(classicTag(characters.get(n)));
                doneCharacters.add(n);
              }
            }
            if (t instanceof CharacterTag) {
              doneCharacters.add(((CharacterTag)t).getCharacterId());
            }
            sos2.writeTag(classicTag(t));
            if (parent != null) {
              if (t instanceof PlaceObjectTypeTag) {
                PlaceObjectTypeTag pot=(PlaceObjectTypeTag)t;
                int chid=pot.getCharacterId();
                int depth=pot.getDepth();
                MATRIX mat=pot.getMatrix();
                if (mat == null) {
                  mat=new MATRIX();
                }
                mat=(MATRIX)Helper.deepCopy(mat);
                if (parent instanceof BoundedTag) {
                  RECT r=((BoundedTag)parent).getRect(characters,new Stack<Integer>());
                  mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
                  mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
                }
 else {
                  mat.translateX+=width / 2;
                  mat.translateY+=height / 2;
                }
                sos2.writeTag(new PlaceObject2Tag(null,false,false,false,false,false,true,false,true,depth,chid,mat,null,0,null,0,null));
              }
            }
          }
          sos2.writeTag(new ShowFrameTag(null));
        }
 else {
          if (tagObj instanceof DefineBitsTag) {
            if (jtt != null) {
              sos2.writeTag(jtt);
            }
          }
 else           if (tagObj instanceof AloneTag) {
          }
 else {
            Set<Integer> needed=((Tag)tagObj).getDeepNeededCharacters(characters,new ArrayList<Integer>());
            for (            int n : needed) {
              sos2.writeTag(classicTag(characters.get(n)));
            }
          }
          sos2.writeTag(classicTag((Tag)tagObj));
          int chtId=0;
          if (tagObj instanceof CharacterTag) {
            chtId=((CharacterTag)tagObj).getCharacterId();
          }
          MATRIX mat=new MATRIX();
          mat.hasRotate=false;
          mat.hasScale=false;
          mat.translateX=0;
          mat.translateY=0;
          if (tagObj instanceof BoundedTag) {
            RECT r=((BoundedTag)tagObj).getRect(characters,new Stack<Integer>());
            mat.translateX=-r.Xmin;
            mat.translateY=-r.Ymin;
            mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
            mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
          }
 else {
            mat.translateX=width / 4;
            mat.translateY=height / 4;
          }
          if (tagObj instanceof FontTag) {
            int countGlyphs=((FontTag)tagObj).getGlyphShapeTable().size();
            int fontId=((FontTag)tagObj).getFontId();
            int sloupcu=(int)Math.ceil(Math.sqrt(countGlyphs));
            int radku=(int)Math.ceil(((float)countGlyphs) / ((float)sloupcu));
            int x=0;
            int y=1;
            for (int f=0; f < countGlyphs; f++) {
              if (x >= sloupcu) {
                x=0;
                y++;
              }
              List<TEXTRECORD> rec=new ArrayList<>();
              TEXTRECORD tr=new TEXTRECORD();
              int textHeight=height / radku;
              tr.fontId=fontId;
              tr.styleFlagsHasFont=true;
              tr.textHeight=textHeight;
              tr.glyphEntries=new GLYPHENTRY[1];
              tr.styleFlagsHasColor=true;
              tr.textColor=new RGB(0,0,0);
              tr.glyphEntries[0]=new GLYPHENTRY();
              tr.glyphEntries[0].glyphAdvance=0;
              tr.glyphEntries[0].glyphIndex=f;
              rec.add(tr);
              mat.translateX=x * width / sloupcu;
              mat.translateY=y * height / radku;
              sos2.writeTag(new DefineTextTag(null,999 + f,new RECT(0,width,0,height),new MATRIX(),rec));
              sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1 + f,999 + f,mat,null,0,null,0,null));
              x++;
            }
            sos2.writeTag(new ShowFrameTag(null));
          }
 else           if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            sos2.writeTag(new ShowFrameTag(null));
            int numFrames=100;
            for (int ratio=0; ratio < 65536; ratio+=65536 / numFrames) {
              sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,false,true,1,chtId,mat,null,ratio,null,0,null));
              sos2.writeTag(new ShowFrameTag(null));
            }
          }
 else           if (tagObj instanceof SoundStreamHeadTypeTag) {
            for (            SoundStreamBlockTag blk : soundFrames) {
              sos2.writeTag(blk);
              sos2.writeTag(new ShowFrameTag(null));
            }
          }
 else           if (tagObj instanceof DefineSoundTag) {
            ExportAssetsTag ea=new ExportAssetsTag();
            DefineSoundTag ds=(DefineSoundTag)tagObj;
            ea.tags.add(ds.soundId);
            ea.names.add(""String_Node_Str"");
            sos2.writeTag(ea);
            List<Action> actions;
            DoActionTag doa;
            doa=new DoActionTag(null,new byte[]{},SWF.DEFAULT_VERSION,0);
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            sos2.writeTag(new ShowFrameTag(null));
            if (flashPanel != null) {
              flashPanel.specialPlayback=true;
            }
          }
 else           if (tagObj instanceof DefineVideoStreamTag) {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,false,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            List<VideoFrameTag> frs=new ArrayList<>(videoFrames.values());
            Collections.sort(frs,new Comparator<VideoFrameTag>(){
              @Override public int compare(              VideoFrameTag o1,              VideoFrameTag o2){
                return o1.frameNum - o2.frameNum;
              }
            }
);
            boolean first=true;
            int ratio=0;
            for (            VideoFrameTag f : frs) {
              if (!first) {
                ratio++;
                sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,false,false,true,1,0,null,null,ratio,null,0,null));
              }
              sos2.writeTag(f);
              sos2.writeTag(new ShowFrameTag(null));
              first=false;
            }
          }
 else {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            sos2.writeTag(new ShowFrameTag(null));
          }
        }
        sos2.writeTag(new EndTag(null));
        byte[] data=baos.toByteArray();
        sos.writeUI32(sos.getPos() + data.length + 4);
        sos.write(data);
        fos.flush();
      }
       showCard(CARDFLASHPANEL);
      if (flashPanel != null) {
        if (flashPanel instanceof FlashPlayerPanel) {
          flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,frameRate);
        }
      }
    }
 catch (    IOException|com.jpexs.decompiler.flash.action.parser.ParseException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (tagObj instanceof TextTag) {
      parametersPanel.setVisible(true);
      previewSplitPane.setDividerLocation(previewSplitPane.getWidth() / 2);
      showDetailWithPreview(CARDTEXTPANEL);
      textValue.setText(((TextTag)tagObj).getFormattedText(swf.tags));
    }
 else     if (tagObj instanceof FontTag) {
      showFontTag((FontTag)tagObj);
    }
 else {
      parametersPanel.setVisible(false);
    }
  }
 else {
    showCard(CARDEMPTYPANEL);
  }
}","public void reload(boolean forceReload){
  Object tagObj=tagTree.getLastSelectedPathComponent();
  if (tagObj == null) {
    return;
  }
  if (tagObj instanceof TagNode) {
    tagObj=((TagNode)tagObj).tag;
  }
  if (tagObj instanceof TreeElement) {
    tagObj=((TreeElement)tagObj).getItem();
  }
  if (!forceReload && (tagObj == oldValue)) {
    return;
  }
  if (flashPanel != null) {
    flashPanel.specialPlayback=false;
  }
  swfPreviewPanel.stop();
  stopFlashPlayer();
  oldValue=tagObj;
  if (tagObj instanceof ScriptPack) {
    final ScriptPack scriptLeaf=(ScriptPack)tagObj;
    if (!Main.isWorking()) {
      Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"",new Runnable(){
        @Override public void run(){
          if (setSourceTask != null) {
            setSourceTask.cancel(true);
          }
          abcPanel.decompiledTextArea.setText(""String_Node_Str"" + AppStrings.translate(""String_Node_Str""));
        }
      }
);
      FutureTask<Void> task=Helper.callAsync(new Callable<Void>(){
        @Override public Void call() throws Exception {
          int classIndex=-1;
          for (          Trait t : scriptLeaf.abc.script_info[scriptLeaf.scriptIndex].traits.traits) {
            if (t instanceof TraitClass) {
              classIndex=((TraitClass)t).class_info;
              break;
            }
          }
          abcPanel.detailPanel.methodTraitPanel.methodCodePanel.setCode(""String_Node_Str"");
          abcPanel.navigator.setABC(abcList,scriptLeaf.abc);
          abcPanel.navigator.setClassIndex(classIndex,scriptLeaf.scriptIndex);
          abcPanel.setAbc(scriptLeaf.abc);
          abcPanel.decompiledTextArea.setScript(scriptLeaf,abcList);
          abcPanel.decompiledTextArea.setClassIndex(classIndex);
          abcPanel.decompiledTextArea.setNoTrait();
          return null;
        }
      }
,new Callback<AsyncResult<Void>>(){
        @Override public void call(        AsyncResult<Void> result){
          setSourceTask=null;
          if (result.error != null) {
            abcPanel.decompiledTextArea.setText(""String_Node_Str"" + result.error);
          }
          Main.stopWork();
        }
      }
);
      setSourceTask=task;
    }
    showDetail(DETAILCARDAS3NAVIGATOR);
    showCard(CARDACTIONSCRIPTPANEL);
    return;
  }
 else {
    showDetail(DETAILCARDEMPTYPANEL);
  }
  if ((tagObj instanceof SWFRoot)) {
    if (miInternalViewer.isSelected()) {
      showCard(CARDSWFPREVIEWPANEL);
      swfPreviewPanel.load(swf);
      swfPreviewPanel.play();
    }
 else {
      showCard(CARDFLASHPANEL);
      parametersPanel.setVisible(false);
      if (flashPanel != null) {
        Color backgroundColor=View.DEFAULT_BACKGROUND_COLOR;
        for (        Tag t : swf.tags) {
          if (t instanceof SetBackgroundColorTag) {
            backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
            break;
          }
        }
        if (flashPanel instanceof FlashPlayerPanel) {
          if (tempFile != null) {
            tempFile.delete();
          }
          try {
            tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
            tempFile.deleteOnExit();
            swf.saveTo(new FileOutputStream(tempFile));
            flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,swf.frameRate);
          }
 catch (          IOException iex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,""String_Node_Str"",iex);
          }
        }
      }
    }
  }
 else   if (tagObj instanceof DefineBinaryDataTag) {
    showCard(CARDEMPTYPANEL);
  }
 else   if (tagObj instanceof ASMSource) {
    showCard(CARDACTIONSCRIPTPANEL);
    actionPanel.setSource((ASMSource)tagObj,!forceReload);
  }
 else   if (tagObj instanceof ImageTag) {
    imageButtonsPanel.setVisible(((ImageTag)tagObj).importSupported());
    showCard(CARDIMAGEPANEL);
    imagePanel.setImage(((ImageTag)tagObj).getImage(swf.tags));
  }
 else   if ((tagObj instanceof DrawableTag) && (!(tagObj instanceof TextTag)) && (!(tagObj instanceof FontTag))&& (miInternalViewer.isSelected())) {
    showCard(CARDDRAWPREVIEWPANEL);
    previewImagePanel.setDrawable((DrawableTag)tagObj,swf,characters,50);
  }
 else   if ((tagObj instanceof FontTag) && (miInternalViewer.isSelected())) {
    showCard(CARDFLASHPANEL);
    previewImagePanel.setDrawable((DrawableTag)tagObj,swf,characters,50);
    showFontTag((FontTag)tagObj);
  }
 else   if (tagObj instanceof FrameNode && ((FrameNode)tagObj).isDisplayed() && (miInternalViewer.isSelected())) {
    showCard(CARDDRAWPREVIEWPANEL);
    FrameNode fn=(FrameNode)tagObj;
    List<Tag> controlTags=swf.tags;
    int containerId=0;
    RECT rect=swf.displayRect;
    int totalFrameCount=swf.frameCount;
    if (fn.getParent() instanceof DefineSpriteTag) {
      controlTags=((DefineSpriteTag)fn.getParent()).subTags;
      containerId=((DefineSpriteTag)fn.getParent()).spriteId;
      rect=((DefineSpriteTag)fn.getParent()).getRect(characters,new Stack<Integer>());
      totalFrameCount=((DefineSpriteTag)fn.getParent()).frameCount;
    }
    previewImagePanel.setImage(SWF.frameToImage(containerId,((FrameNode)tagObj).getFrame() - 1,swf.tags,controlTags,rect,totalFrameCount,new Stack<Integer>()));
  }
 else   if (((tagObj instanceof FrameNode) && ((FrameNode)tagObj).isDisplayed()) || ((tagObj instanceof CharacterTag) || (tagObj instanceof FontTag)) && (tagObj instanceof Tag)) {
    ((CardLayout)viewerCards.getLayout()).show(viewerCards,FLASH_VIEWER_CARD);
    try {
      if (tempFile != null) {
        tempFile.delete();
      }
      tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
      tempFile.deleteOnExit();
      Color backgroundColor=View.swfBackgroundColor;
      if (tagObj instanceof FontTag) {
        backgroundColor=View.DEFAULT_BACKGROUND_COLOR;
      }
      int frameCount=1;
      int frameRate=swf.frameRate;
      HashMap<Integer,VideoFrameTag> videoFrames=new HashMap<>();
      DefineVideoStreamTag vs=null;
      if (tagObj instanceof DefineVideoStreamTag) {
        vs=(DefineVideoStreamTag)tagObj;
        swf.populateVideoFrames(vs.getCharacterId(),swf.tags,videoFrames);
        frameCount=videoFrames.size();
      }
      List<SoundStreamBlockTag> soundFrames=new ArrayList<>();
      if (tagObj instanceof SoundStreamHeadTypeTag) {
        SWF.populateSoundStreamBlocks(swf.tags,(Tag)tagObj,soundFrames);
        frameCount=soundFrames.size();
      }
      if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
        frameCount=100;
        frameRate=50;
      }
      if (tagObj instanceof DefineSoundTag) {
        frameCount=1;
      }
      try (FileOutputStream fos=new FileOutputStream(tempFile)){
        SWFOutputStream sos=new SWFOutputStream(fos,10);
        sos.write(""String_Node_Str"".getBytes());
        sos.write(swf.version);
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        SWFOutputStream sos2=new SWFOutputStream(baos,10);
        int width=swf.displayRect.Xmax - swf.displayRect.Xmin;
        int height=swf.displayRect.Ymax - swf.displayRect.Ymin;
        sos2.writeRECT(swf.displayRect);
        sos2.writeUI8(0);
        sos2.writeUI8(frameRate);
        sos2.writeUI16(frameCount);
        if (tagObj instanceof FrameNode) {
          FrameNode fn=(FrameNode)tagObj;
          if (fn.getParent() == null) {
            for (            Tag t : swf.tags) {
              if (t instanceof SetBackgroundColorTag) {
                backgroundColor=((SetBackgroundColorTag)t).backgroundColor.toColor();
                break;
              }
            }
          }
        }
        sos2.writeTag(new SetBackgroundColorTag(null,new RGB(backgroundColor)));
        if (tagObj instanceof FrameNode) {
          FrameNode fn=(FrameNode)tagObj;
          Object parent=fn.getParent();
          List<ContainerItem> subs=new ArrayList<>();
          if (parent == null) {
            subs.addAll(swf.tags);
          }
 else {
            if (parent instanceof Container) {
              subs=((Container)parent).getSubItems();
            }
          }
          List<Integer> doneCharacters=new ArrayList<>();
          int frameCnt=1;
          for (          Object o : subs) {
            if (o instanceof ShowFrameTag) {
              frameCnt++;
              continue;
            }
            if (frameCnt > fn.getFrame()) {
              break;
            }
            Tag t=(Tag)o;
            Set<Integer> needed=t.getDeepNeededCharacters(characters,new ArrayList<Integer>());
            for (            int n : needed) {
              if (!doneCharacters.contains(n)) {
                sos2.writeTag(classicTag(characters.get(n)));
                doneCharacters.add(n);
              }
            }
            if (t instanceof CharacterTag) {
              doneCharacters.add(((CharacterTag)t).getCharacterId());
            }
            sos2.writeTag(classicTag(t));
            if (parent != null) {
              if (t instanceof PlaceObjectTypeTag) {
                PlaceObjectTypeTag pot=(PlaceObjectTypeTag)t;
                int chid=pot.getCharacterId();
                int depth=pot.getDepth();
                MATRIX mat=pot.getMatrix();
                if (mat == null) {
                  mat=new MATRIX();
                }
                mat=(MATRIX)Helper.deepCopy(mat);
                if (parent instanceof BoundedTag) {
                  RECT r=((BoundedTag)parent).getRect(characters,new Stack<Integer>());
                  mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
                  mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
                }
 else {
                  mat.translateX+=width / 2;
                  mat.translateY+=height / 2;
                }
                sos2.writeTag(new PlaceObject2Tag(null,false,false,false,false,false,true,false,true,depth,chid,mat,null,0,null,0,null));
              }
            }
          }
          sos2.writeTag(new ShowFrameTag(null));
        }
 else {
          if (tagObj instanceof DefineBitsTag) {
            if (jtt != null) {
              sos2.writeTag(jtt);
            }
          }
 else           if (tagObj instanceof AloneTag) {
          }
 else {
            Set<Integer> needed=((Tag)tagObj).getDeepNeededCharacters(characters,new ArrayList<Integer>());
            for (            int n : needed) {
              sos2.writeTag(classicTag(characters.get(n)));
            }
          }
          sos2.writeTag(classicTag((Tag)tagObj));
          int chtId=0;
          if (tagObj instanceof CharacterTag) {
            chtId=((CharacterTag)tagObj).getCharacterId();
          }
          MATRIX mat=new MATRIX();
          mat.hasRotate=false;
          mat.hasScale=false;
          mat.translateX=0;
          mat.translateY=0;
          if (tagObj instanceof BoundedTag) {
            RECT r=((BoundedTag)tagObj).getRect(characters,new Stack<Integer>());
            mat.translateX=-r.Xmin;
            mat.translateY=-r.Ymin;
            mat.translateX=mat.translateX + width / 2 - r.getWidth() / 2;
            mat.translateY=mat.translateY + height / 2 - r.getHeight() / 2;
          }
 else {
            mat.translateX=width / 4;
            mat.translateY=height / 4;
          }
          if (tagObj instanceof FontTag) {
            int countGlyphs=((FontTag)tagObj).getGlyphShapeTable().size();
            int fontId=((FontTag)tagObj).getFontId();
            int sloupcu=(int)Math.ceil(Math.sqrt(countGlyphs));
            int radku=(int)Math.ceil(((float)countGlyphs) / ((float)sloupcu));
            int x=0;
            int y=1;
            for (int f=0; f < countGlyphs; f++) {
              if (x >= sloupcu) {
                x=0;
                y++;
              }
              List<TEXTRECORD> rec=new ArrayList<>();
              TEXTRECORD tr=new TEXTRECORD();
              int textHeight=height / radku;
              tr.fontId=fontId;
              tr.styleFlagsHasFont=true;
              tr.textHeight=textHeight;
              tr.glyphEntries=new GLYPHENTRY[1];
              tr.styleFlagsHasColor=true;
              tr.textColor=new RGB(0,0,0);
              tr.glyphEntries[0]=new GLYPHENTRY();
              tr.glyphEntries[0].glyphAdvance=0;
              tr.glyphEntries[0].glyphIndex=f;
              rec.add(tr);
              mat.translateX=x * width / sloupcu;
              mat.translateY=y * height / radku;
              sos2.writeTag(new DefineTextTag(null,999 + f,new RECT(0,width,0,height),new MATRIX(),rec));
              sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1 + f,999 + f,mat,null,0,null,0,null));
              x++;
            }
            sos2.writeTag(new ShowFrameTag(null));
          }
 else           if ((tagObj instanceof DefineMorphShapeTag) || (tagObj instanceof DefineMorphShape2Tag)) {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            sos2.writeTag(new ShowFrameTag(null));
            int numFrames=100;
            for (int ratio=0; ratio < 65536; ratio+=65536 / numFrames) {
              sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,false,true,1,chtId,mat,null,ratio,null,0,null));
              sos2.writeTag(new ShowFrameTag(null));
            }
          }
 else           if (tagObj instanceof SoundStreamHeadTypeTag) {
            for (            SoundStreamBlockTag blk : soundFrames) {
              sos2.writeTag(blk);
              sos2.writeTag(new ShowFrameTag(null));
            }
          }
 else           if (tagObj instanceof DefineSoundTag) {
            ExportAssetsTag ea=new ExportAssetsTag();
            DefineSoundTag ds=(DefineSoundTag)tagObj;
            ea.tags.add(ds.soundId);
            ea.names.add(""String_Node_Str"");
            sos2.writeTag(ea);
            List<Action> actions;
            DoActionTag doa;
            doa=new DoActionTag(null,new byte[]{},SWF.DEFAULT_VERSION,0);
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            actions=ASMParser.parse(0,0,false,""String_Node_Str"" + ""String_Node_Str"",SWF.DEFAULT_VERSION,false);
            doa.setActions(actions,SWF.DEFAULT_VERSION);
            sos2.writeTag(doa);
            sos2.writeTag(new ShowFrameTag(null));
            sos2.writeTag(new ShowFrameTag(null));
            if (flashPanel != null) {
              flashPanel.specialPlayback=true;
            }
          }
 else           if (tagObj instanceof DefineVideoStreamTag) {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,false,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            List<VideoFrameTag> frs=new ArrayList<>(videoFrames.values());
            Collections.sort(frs,new Comparator<VideoFrameTag>(){
              @Override public int compare(              VideoFrameTag o1,              VideoFrameTag o2){
                return o1.frameNum - o2.frameNum;
              }
            }
);
            boolean first=true;
            int ratio=0;
            for (            VideoFrameTag f : frs) {
              if (!first) {
                ratio++;
                sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,false,false,true,1,0,null,null,ratio,null,0,null));
              }
              sos2.writeTag(f);
              sos2.writeTag(new ShowFrameTag(null));
              first=false;
            }
          }
 else {
            sos2.writeTag(new PlaceObject2Tag(null,false,false,false,true,false,true,true,false,1,chtId,mat,null,0,null,0,null));
            sos2.writeTag(new ShowFrameTag(null));
          }
        }
        sos2.writeTag(new EndTag(null));
        byte[] data=baos.toByteArray();
        sos.writeUI32(sos.getPos() + data.length + 4);
        sos.write(data);
        fos.flush();
      }
       showCard(CARDFLASHPANEL);
      if (flashPanel != null) {
        if (flashPanel instanceof FlashPlayerPanel) {
          flashPanel.displaySWF(tempFile.getAbsolutePath(),backgroundColor,frameRate);
        }
      }
    }
 catch (    IOException|com.jpexs.decompiler.flash.action.parser.ParseException ex) {
      Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (tagObj instanceof TextTag) {
      parametersPanel.setVisible(true);
      previewSplitPane.setDividerLocation(previewSplitPane.getWidth() / 2);
      showDetailWithPreview(CARDTEXTPANEL);
      textValue.setText(((TextTag)tagObj).getFormattedText(swf.tags));
    }
 else     if (tagObj instanceof FontTag) {
      showFontTag((FontTag)tagObj);
    }
 else {
      parametersPanel.setVisible(false);
    }
  }
 else {
    showCard(CARDEMPTYPANEL);
  }
}",0.996191845756438
61962,"@Override public void call(AsyncResult<Void> arg1){
  setSourceTask=null;
  Main.stopWork();
}","@Override public void call(AsyncResult<Void> result){
  setSourceTask=null;
  if (result.error != null) {
    abcPanel.decompiledTextArea.setText(""String_Node_Str"" + result.error);
  }
  Main.stopWork();
}",0.6020066889632107
61963,"@Override public HilightedTextWriter toString(HilightedTextWriter writer,ConstantPool constants,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames){
  hilight(""String_Node_Str"",writer);
  int idx=writer.getLength();
  object.toString(writer,constants,localRegNames,fullyQualifiedNames);
  if (idx > writer.getLength()) {
    hilight(""String_Node_Str"",writer);
  }
  propertyName.toString(writer,constants,localRegNames,fullyQualifiedNames);
  hilight(""String_Node_Str"",writer);
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      hilight(""String_Node_Str"",writer);
    }
    args.get(a).toString(writer,constants,localRegNames,fullyQualifiedNames);
  }
  return hilight(""String_Node_Str"",writer);
}","@Override public HilightedTextWriter toString(HilightedTextWriter writer,ConstantPool constants,HashMap<Integer,String> localRegNames,List<String> fullyQualifiedNames){
  hilight(""String_Node_Str"",writer);
  int idx=writer.getLength();
  object.toString(writer,constants,localRegNames,fullyQualifiedNames);
  if (idx < writer.getLength()) {
    hilight(""String_Node_Str"",writer);
  }
  propertyName.toString(writer,constants,localRegNames,fullyQualifiedNames);
  hilight(""String_Node_Str"",writer);
  for (int a=0; a < args.size(); a++) {
    if (a > 0) {
      hilight(""String_Node_Str"",writer);
    }
    args.get(a).toString(writer,constants,localRegNames,fullyQualifiedNames);
  }
  return hilight(""String_Node_Str"",writer);
}",0.9986282578875172
61964,"@Override public HilightedTextWriter toString(HilightedTextWriter writer,List<Object> localData){
  GraphTargetItem expr=expression;
  List<GraphTargetItem> ifBranch=onTrue;
  List<GraphTargetItem> elseBranch=onFalse;
  if (onTrue.isEmpty()) {
    if (onFalse.isEmpty()) {
      if (expr instanceof NotItem) {
        expr=((NotItem)expr).getOriginal();
      }
    }
 else {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      ifBranch=onFalse;
      elseBranch=onTrue;
    }
  }
  hilight(""String_Node_Str"",writer);
  expr.toString(writer,localData);
  hilight(""String_Node_Str"",writer).appendNewLine();
  hilight(""String_Node_Str"",writer).appendNewLine();
  hilight(Graph.INDENTOPEN,writer).appendNewLine();
  for (  GraphTargetItem ti : ifBranch) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).appendNewLine();
    }
  }
  hilight(Graph.INDENTCLOSE + ""String_Node_Str"",writer);
  hilight(""String_Node_Str"",writer);
  if (elseBranch.size() > 0) {
    hilight(""String_Node_Str"",writer);
    hilight(""String_Node_Str"" + Graph.INDENTOPEN + ""String_Node_Str"",writer);
    for (    GraphTargetItem ti : elseBranch) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData);
        hilight(""String_Node_Str"",writer);
      }
    }
    hilight(Graph.INDENTCLOSE + ""String_Node_Str"",writer);
  }
  return writer;
}","@Override public HilightedTextWriter toString(HilightedTextWriter writer,List<Object> localData){
  GraphTargetItem expr=expression;
  List<GraphTargetItem> ifBranch=onTrue;
  List<GraphTargetItem> elseBranch=onFalse;
  if (onTrue.isEmpty()) {
    if (onFalse.isEmpty()) {
      if (expr instanceof NotItem) {
        expr=((NotItem)expr).getOriginal();
      }
    }
 else {
      if (expr instanceof LogicalOpItem) {
        expr=((LogicalOpItem)expr).invert();
      }
 else {
        expr=new NotItem(null,expr);
      }
      ifBranch=onFalse;
      elseBranch=onTrue;
    }
  }
  hilight(""String_Node_Str"",writer);
  expr.toString(writer,localData);
  hilight(""String_Node_Str"",writer).appendNewLine();
  hilight(""String_Node_Str"",writer).appendNewLine();
  hilight(Graph.INDENTOPEN,writer).appendNewLine();
  for (  GraphTargetItem ti : ifBranch) {
    if (!ti.isEmpty()) {
      ti.toStringSemicoloned(writer,localData).appendNewLine();
    }
  }
  hilight(Graph.INDENTCLOSE,writer).appendNewLine();
  hilight(""String_Node_Str"",writer);
  if (elseBranch.size() > 0) {
    writer.appendNewLine();
    hilight(""String_Node_Str"",writer).appendNewLine();
    hilight(""String_Node_Str"",writer).appendNewLine();
    hilight(Graph.INDENTOPEN,writer).appendNewLine();
    for (    GraphTargetItem ti : elseBranch) {
      if (!ti.isEmpty()) {
        ti.toStringSemicoloned(writer,localData).appendNewLine();
      }
    }
    hilight(Graph.INDENTCLOSE,writer).appendNewLine();
    hilight(""String_Node_Str"",writer);
  }
  return writer;
}",0.754918306102034
61965,"public static List<File> exportNodeAS(List<Tag> allTags,AbortRetryIgnoreHandler handler,List<TagNode> nodeList,String outdir,ExportMode exportMode,AtomicInteger index,int count,EventListener ev) throws IOException {
  File dir=new File(outdir);
  List<File> ret=new ArrayList<>();
  if (!outdir.endsWith(File.separator)) {
    outdir=outdir + File.separator;
  }
  List<String> existingNames=new ArrayList<>();
  for (  TagNode node : nodeList) {
    String name=""String_Node_Str"";
    if (node.tag instanceof Exportable) {
      name=((Exportable)node.tag).getExportFileName(allTags);
    }
 else {
      name=Helper.makeFileName(node.tag.toString());
    }
    int i=1;
    String baseName=name;
    while (existingNames.contains(name)) {
      i++;
      name=baseName + ""String_Node_Str"" + i;
    }
    existingNames.add(name);
    if (node.subItems.isEmpty()) {
      if ((node.tag instanceof ASMSource) && (node.export)) {
        if (!dir.exists()) {
          if (!dir.mkdirs()) {
            if (!dir.exists()) {
              continue;
            }
          }
        }
        boolean retry;
        do {
          retry=false;
          try {
            long startTime=System.currentTimeMillis();
            String f=outdir + name + ""String_Node_Str"";
            File file=new File(f);
            String res;
            ASMSource asm=((ASMSource)node.tag);
            if (exportMode == ExportMode.HEX) {
              HilightedTextWriter writer=new HilightedTextWriter(false,asm.getActionSourceIndent());
              asm.getActionBytesAsHex(writer);
              res=asm.getActionSourcePrefix() + writer.toString() + asm.getActionSourceSuffix();
            }
 else             if (exportMode != ExportMode.SOURCE) {
              HilightedTextWriter writer=new HilightedTextWriter(false,asm.getActionSourceIndent());
              asm.getASMSource(SWF.DEFAULT_VERSION,exportMode,writer,null);
              String str=writer.toString();
              res=asm.getActionSourcePrefix() + str + asm.getActionSourceSuffix();
            }
 else {
              List<Action> as=asm.getActions(SWF.DEFAULT_VERSION);
              Action.setActionsAddresses(as,0,SWF.DEFAULT_VERSION);
              res=asm.getActionSourcePrefix() + Action.actionsToSource(as,SWF.DEFAULT_VERSION,""String_Node_Str"",false,asm.getActionSourceIndent()) + asm.getActionSourceSuffix();
            }
            try (FileOutputStream fos=new FileOutputStream(f)){
              fos.write(res.getBytes(""String_Node_Str""));
            }
             long stopTime=System.currentTimeMillis();
            if (ev != null) {
              long time=stopTime - startTime;
              ev.handleEvent(""String_Node_Str"",""String_Node_Str"" + index.getAndIncrement() + ""String_Node_Str""+ count+ ""String_Node_Str""+ f+ ""String_Node_Str""+ Helper.formatTimeSec(time));
            }
            ret.add(file);
          }
 catch (          Exception|OutOfMemoryError|StackOverflowError ex) {
            Logger.getLogger(TagNode.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
            if (handler != null) {
              int action=handler.getNewInstance().handle(ex);
switch (action) {
case AbortRetryIgnoreHandler.ABORT:
                throw ex;
case AbortRetryIgnoreHandler.RETRY:
              retry=true;
            break;
case AbortRetryIgnoreHandler.IGNORE:
          retry=false;
        break;
    }
  }
}
}
 while (retry);
}
}
 else {
ret.addAll(exportNodeAS(allTags,handler,node.subItems,outdir + name,exportMode,index,count,ev));
}
}
return ret;
}","public static List<File> exportNodeAS(List<Tag> allTags,AbortRetryIgnoreHandler handler,List<TagNode> nodeList,String outdir,ExportMode exportMode,AtomicInteger index,int count,EventListener ev) throws IOException {
  File dir=new File(outdir);
  List<File> ret=new ArrayList<>();
  if (!outdir.endsWith(File.separator)) {
    outdir=outdir + File.separator;
  }
  List<String> existingNames=new ArrayList<>();
  for (  TagNode node : nodeList) {
    String name=""String_Node_Str"";
    if (node.tag instanceof Exportable) {
      name=((Exportable)node.tag).getExportFileName(allTags);
    }
 else {
      name=Helper.makeFileName(node.tag.toString());
    }
    int i=1;
    String baseName=name;
    while (existingNames.contains(name)) {
      i++;
      name=baseName + ""String_Node_Str"" + i;
    }
    existingNames.add(name);
    if (node.subItems.isEmpty()) {
      if ((node.tag instanceof ASMSource) && (node.export)) {
        if (!dir.exists()) {
          if (!dir.mkdirs()) {
            if (!dir.exists()) {
              continue;
            }
          }
        }
        boolean retry;
        do {
          retry=false;
          try {
            long startTime=System.currentTimeMillis();
            String f=outdir + name + ""String_Node_Str"";
            File file=new File(f);
            String res;
            ASMSource asm=((ASMSource)node.tag);
            if (exportMode == ExportMode.HEX) {
              HilightedTextWriter writer=new HilightedTextWriter(false);
              asm.getActionSourcePrefix(writer);
              asm.getActionBytesAsHex(writer);
              asm.getActionSourceSuffix(writer);
              res=writer.toString();
            }
 else             if (exportMode != ExportMode.SOURCE) {
              HilightedTextWriter writer=new HilightedTextWriter(false);
              asm.getActionSourcePrefix(writer);
              asm.getASMSource(SWF.DEFAULT_VERSION,exportMode,writer,null);
              asm.getActionSourceSuffix(writer);
              res=writer.toString();
            }
 else {
              List<Action> as=asm.getActions(SWF.DEFAULT_VERSION);
              Action.setActionsAddresses(as,0,SWF.DEFAULT_VERSION);
              HilightedTextWriter writer=new HilightedTextWriter(false);
              asm.getActionSourcePrefix(writer);
              Action.actionsToSource(as,SWF.DEFAULT_VERSION,""String_Node_Str"",writer);
              asm.getActionSourceSuffix(writer);
              res=writer.toString();
            }
            try (FileOutputStream fos=new FileOutputStream(f)){
              fos.write(res.getBytes(""String_Node_Str""));
            }
             long stopTime=System.currentTimeMillis();
            if (ev != null) {
              long time=stopTime - startTime;
              ev.handleEvent(""String_Node_Str"",""String_Node_Str"" + index.getAndIncrement() + ""String_Node_Str""+ count+ ""String_Node_Str""+ f+ ""String_Node_Str""+ Helper.formatTimeSec(time));
            }
            ret.add(file);
          }
 catch (          Exception|OutOfMemoryError|StackOverflowError ex) {
            Logger.getLogger(TagNode.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
            if (handler != null) {
              int action=handler.getNewInstance().handle(ex);
switch (action) {
case AbortRetryIgnoreHandler.ABORT:
                throw ex;
case AbortRetryIgnoreHandler.RETRY:
              retry=true;
            break;
case AbortRetryIgnoreHandler.IGNORE:
          retry=false;
        break;
    }
  }
}
}
 while (retry);
}
}
 else {
ret.addAll(exportNodeAS(allTags,handler,node.subItems,outdir + name,exportMode,index,count,ev));
}
}
return ret;
}",0.9242067341000416
61966,"/** 
 * Converts list of actions to ActionScript source code
 * @param actions List of actions
 * @param version SWF version
 * @param path
 * @return String with Source code
 */
public static HilightedText actionsToSource(final List<Action> actions,final int version,final String path,boolean highlight,int indent){
  List<GraphTargetItem> tree=null;
  Throwable convertException=null;
  int timeout=Configuration.getConfig(""String_Node_Str"",60);
  try {
    tree=Helper.timedCall(new Callable<List<GraphTargetItem>>(){
      @Override public List<GraphTargetItem> call() throws Exception {
        int staticOperation=Graph.SOP_USE_STATIC;
        List<GraphTargetItem> tree=actionsToTree(new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),actions,version,staticOperation,path);
        Graph.graphToString(tree,new NulWriter(),new LocalData());
        return tree;
      }
    }
,timeout,TimeUnit.SECONDS);
  }
 catch (  InterruptedException|TimeoutException|ExecutionException|OutOfMemoryError|StackOverflowError ex) {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
    convertException=ex;
    if (ex instanceof ExecutionException && ex.getCause() instanceof Exception) {
      convertException=(Exception)ex.getCause();
    }
  }
  HilightedTextWriter writer=new HilightedTextWriter(highlight,indent);
  if (convertException == null) {
    Graph.graphToString(tree,writer,new LocalData());
  }
 else   if (convertException instanceof TimeoutException) {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"" + Helper.formatTimeToText(timeout) + ""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
  }
 else {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"" + convertException.getClass().getSimpleName()).newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
  }
  return new HilightedText(writer);
}","/** 
 * Converts list of actions to ActionScript source code
 * @param actions List of actions
 * @param version SWF version
 * @param path
 * @return String with Source code
 */
public static void actionsToSource(final List<Action> actions,final int version,final String path,HilightedTextWriter writer){
  List<GraphTargetItem> tree=null;
  Throwable convertException=null;
  int timeout=Configuration.getConfig(""String_Node_Str"",60);
  try {
    tree=Helper.timedCall(new Callable<List<GraphTargetItem>>(){
      @Override public List<GraphTargetItem> call() throws Exception {
        int staticOperation=Graph.SOP_USE_STATIC;
        List<GraphTargetItem> tree=actionsToTree(new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>(),actions,version,staticOperation,path);
        Graph.graphToString(tree,new NulWriter(),new LocalData());
        return tree;
      }
    }
,timeout,TimeUnit.SECONDS);
  }
 catch (  InterruptedException|TimeoutException|ExecutionException|OutOfMemoryError|StackOverflowError ex) {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
    convertException=ex;
    if (ex instanceof ExecutionException && ex.getCause() instanceof Exception) {
      convertException=(Exception)ex.getCause();
    }
  }
  if (convertException == null) {
    Graph.graphToString(tree,writer,new LocalData());
  }
 else   if (convertException instanceof TimeoutException) {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"" + Helper.formatTimeToText(timeout) + ""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
  }
 else {
    Logger.getLogger(Action.class.getName()).log(Level.SEVERE,""String_Node_Str"",convertException);
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"" + convertException.getClass().getSimpleName()).newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
    writer.appendNoHilight(""String_Node_Str"").newLine();
  }
}",0.9638164544168184
61967,"public void setSource(final ASMSource src,final boolean useCache){
  this.src=src;
  Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
  final ASMSource asm=(ASMSource)src;
  (new Thread(){
    @Override public void run(){
      editor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
      if (Configuration.getConfig(""String_Node_Str"",true)) {
        decompiledEditor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
      }
      DisassemblyListener listener=getDisassemblyListener();
      asm.addDisassemblyListener(listener);
      List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
      lastCode=actions;
      asm.removeDisassemblyListener(listener);
      srcWithHex=null;
      srcNoHex=null;
      srcHexOnly=null;
      setHex(getExportMode());
      if (Configuration.getConfig(""String_Node_Str"",true)) {
        decompiledEditor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
        String stripped=""String_Node_Str"";
        if (!useCache) {
          uncache(asm);
        }
        cacheScript(asm,actions);
        CachedScript sc=getCached(asm);
        decompiledHilights=sc.hilights;
        lastDecompiled=sc.text;
        lastASM=asm;
        stripped=lastDecompiled;
        decompiledEditor.setText(asm.getActionSourcePrefix() + Helper.indentRows(asm.getActionSourceIndent(),lastDecompiled,HilightedTextWriter.INDENT_STRING) + asm.getActionSourceSuffix());
      }
      setEditMode(false);
      setDecompiledEditMode(false);
      Main.stopWork();
    }
  }
).start();
}","public void setSource(final ASMSource src,final boolean useCache){
  this.src=src;
  Main.startWork(translate(""String_Node_Str"") + ""String_Node_Str"");
  final ASMSource asm=(ASMSource)src;
  (new Thread(){
    @Override public void run(){
      editor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
      if (Configuration.getConfig(""String_Node_Str"",true)) {
        decompiledEditor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
      }
      DisassemblyListener listener=getDisassemblyListener();
      asm.addDisassemblyListener(listener);
      List<Action> actions=asm.getActions(SWF.DEFAULT_VERSION);
      lastCode=actions;
      asm.removeDisassemblyListener(listener);
      srcWithHex=null;
      srcNoHex=null;
      srcHexOnly=null;
      setHex(getExportMode());
      if (Configuration.getConfig(""String_Node_Str"",true)) {
        decompiledEditor.setText(""String_Node_Str"" + translate(""String_Node_Str"") + ""String_Node_Str"");
        if (!useCache) {
          uncache(asm);
        }
        cacheScript(asm,actions);
        CachedScript sc=getCached(asm);
        decompiledHilights=sc.hilights;
        lastDecompiled=sc.text;
        lastASM=asm;
        decompiledEditor.setText(lastDecompiled);
      }
      setEditMode(false);
      setDecompiledEditMode(false);
      Main.stopWork();
    }
  }
).start();
}",0.9034185197477596
61968,"@Override public void caretUpdate(CaretEvent e){
  if (ignoreCarret) {
    return;
  }
  if (editMode || editDecompiledMode) {
    return;
  }
  decompiledEditor.getCaret().setVisible(true);
  int pos=decompiledEditor.getCaretPosition();
  System.out.println(""String_Node_Str"" + pos);
  Highlighting h=Highlighting.search(decompiledHilights,pos);
  if (h != null) {
    Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
    if (h2 != null) {
      ignoreCarret=true;
      if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
        editor.setCaretPosition(h2.startPos);
      }
      editor.getCaret().setVisible(true);
      ignoreCarret=false;
    }
  }
}","@Override public void caretUpdate(CaretEvent e){
  if (ignoreCarret) {
    return;
  }
  if (editMode || editDecompiledMode) {
    return;
  }
  decompiledEditor.getCaret().setVisible(true);
  int pos=decompiledEditor.getCaretPosition();
  Highlighting h=Highlighting.search(decompiledHilights,pos);
  if (h != null) {
    Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
    if (h2 != null) {
      ignoreCarret=true;
      if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
        editor.setCaretPosition(h2.startPos);
      }
      editor.getCaret().setVisible(true);
      ignoreCarret=false;
    }
  }
}",0.967109867039888
61969,"public void setDecompiledEditMode(boolean val){
  if (lastASM == null) {
    return;
  }
  String pref=lastASM.getActionSourcePrefix();
  int lastPos=decompiledEditor.getCaretPosition();
  int lastLine=decompiledEditor.getLine();
  int prefLines=Helper.getLineCount(pref);
  if (val) {
    String newText=lastDecompiled;
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      int newpos=lastPos - pref.length();
      if (lastLine - prefLines >= 0) {
        decompiledEditor.gotoLine(lastLine - prefLines + 1);
      }
    }
    decompiledEditor.setEditable(true);
    saveDecompiledButton.setVisible(true);
    editDecompiledButton.setVisible(false);
    experimentalLabel.setVisible(false);
    cancelDecompiledButton.setVisible(true);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    String newText=pref + Helper.indentRows(lastASM.getActionSourceIndent(),lastDecompiled,HilightedTextWriter.INDENT_STRING) + lastASM.getActionSourceSuffix();
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      decompiledEditor.gotoLine(lastLine + prefLines + 1);
    }
    decompiledEditor.setEditable(false);
    saveDecompiledButton.setVisible(false);
    editDecompiledButton.setVisible(true);
    experimentalLabel.setVisible(true);
    cancelDecompiledButton.setVisible(false);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(null);
  }
  editDecompiledMode=val;
  decompiledEditor.requestFocusInWindow();
}","public void setDecompiledEditMode(boolean val){
  if (lastASM == null) {
    return;
  }
  int lastLine=decompiledEditor.getLine();
  int prefLines=lastASM.getPrefixLineCount();
  if (val) {
    String newText=lastASM.removePrefixAndSuffix(lastDecompiled);
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      if (lastLine - prefLines >= 0) {
        decompiledEditor.gotoLine(lastLine - prefLines + 1);
      }
    }
    decompiledEditor.setEditable(true);
    saveDecompiledButton.setVisible(true);
    editDecompiledButton.setVisible(false);
    experimentalLabel.setVisible(false);
    cancelDecompiledButton.setVisible(true);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(View.getIcon(""String_Node_Str""));
  }
 else {
    String newText=lastDecompiled;
    decompiledEditor.setText(newText);
    if (lastLine > -1) {
      decompiledEditor.gotoLine(lastLine + prefLines + 1);
    }
    decompiledEditor.setEditable(false);
    saveDecompiledButton.setVisible(false);
    editDecompiledButton.setVisible(true);
    experimentalLabel.setVisible(true);
    cancelDecompiledButton.setVisible(false);
    decompiledEditor.getCaret().setVisible(true);
    decLabel.setIcon(null);
  }
  editDecompiledMode=val;
  decompiledEditor.requestFocusInWindow();
}",0.8504606661941885
61970,"private void cacheScript(ASMSource src,List<Action> actions){
  if (!cache.contains(src)) {
    if (actions == null) {
      actions=src.getActions(SWF.DEFAULT_VERSION);
    }
    HilightedText text=Action.actionsToSource(actions,SWF.DEFAULT_VERSION,src.toString(),true,0);
    List<Highlighting> hilights=text.instructionHilights;
    String srcNoHex=text.text;
    cache.put(src,new CachedScript(srcNoHex,hilights));
  }
}","private void cacheScript(ASMSource src,List<Action> actions){
  if (!cache.contains(src)) {
    if (actions == null) {
      actions=src.getActions(SWF.DEFAULT_VERSION);
    }
    HilightedTextWriter writer=new HilightedTextWriter(true);
    src.getActionSourcePrefix(writer);
    Action.actionsToSource(actions,SWF.DEFAULT_VERSION,src.toString(),writer);
    src.getActionSourceSuffix(writer);
    List<Highlighting> hilights=writer.instructionHilights;
    String srcNoHex=writer.toString();
    cache.put(src,new CachedScript(srcNoHex,hilights));
  }
}",0.8212461695607763
61971,"public ActionPanel(){
  DefaultSyntaxKit.initKit();
  editor=new LineMarkedEditorPane();
  editor.setEditable(false);
  decompiledEditor=new LineMarkedEditorPane();
  decompiledEditor.setEditable(false);
  searchPanel=new JPanel(new FlowLayout());
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(""String_Node_Str"");
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(""String_Node_Str"");
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(""String_Node_Str"");
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  JButton graphButton=new JButton(View.getIcon(""String_Node_Str""));
  graphButton.setActionCommand(""String_Node_Str"");
  graphButton.addActionListener(this);
  graphButton.setToolTipText(translate(""String_Node_Str""));
  graphButton.setMargin(new Insets(3,3,3,3));
  hexButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexButton.setActionCommand(""String_Node_Str"");
  hexButton.addActionListener(this);
  hexButton.setToolTipText(translate(""String_Node_Str""));
  hexButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexOnlyButton.setActionCommand(""String_Node_Str"");
  hexOnlyButton.addActionListener(this);
  hexOnlyButton.setToolTipText(translate(""String_Node_Str""));
  hexOnlyButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton.setVisible(false);
  topButtonsPan=new JPanel();
  topButtonsPan.setLayout(new BoxLayout(topButtonsPan,BoxLayout.X_AXIS));
  topButtonsPan.add(graphButton);
  topButtonsPan.add(hexButton);
  topButtonsPan.add(hexOnlyButton);
  JPanel panCode=new JPanel(new BorderLayout());
  panCode.add(new JScrollPane(editor),BorderLayout.CENTER);
  panCode.add(topButtonsPan,BorderLayout.NORTH);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  asmLabel.setHorizontalAlignment(SwingConstants.CENTER);
  panB.add(asmLabel,BorderLayout.NORTH);
  panB.add(panCode,BorderLayout.CENTER);
  JPanel buttonsPan=new JPanel();
  buttonsPan.setLayout(new FlowLayout());
  buttonsPan.add(editButton);
  buttonsPan.add(saveButton);
  buttonsPan.add(cancelButton);
  editButton.setMargin(new Insets(3,3,3,10));
  saveButton.setMargin(new Insets(3,3,3,10));
  cancelButton.setMargin(new Insets(3,3,3,10));
  JPanel decButtonsPan=new JPanel(new FlowLayout());
  decButtonsPan.add(editDecompiledButton);
  decButtonsPan.add(experimentalLabel);
  decButtonsPan.add(saveDecompiledButton);
  decButtonsPan.add(cancelDecompiledButton);
  editDecompiledButton.setMargin(new Insets(3,3,3,10));
  saveDecompiledButton.setMargin(new Insets(3,3,3,10));
  cancelDecompiledButton.setMargin(new Insets(3,3,3,10));
  panB.add(buttonsPan,BorderLayout.SOUTH);
  saveButton.addActionListener(this);
  saveButton.setActionCommand(""String_Node_Str"");
  editButton.addActionListener(this);
  editButton.setActionCommand(""String_Node_Str"");
  cancelButton.addActionListener(this);
  cancelButton.setActionCommand(""String_Node_Str"");
  saveButton.setVisible(false);
  cancelButton.setVisible(false);
  saveDecompiledButton.addActionListener(this);
  saveDecompiledButton.setActionCommand(""String_Node_Str"");
  editDecompiledButton.addActionListener(this);
  editDecompiledButton.setActionCommand(""String_Node_Str"");
  cancelDecompiledButton.addActionListener(this);
  cancelDecompiledButton.setActionCommand(""String_Node_Str"");
  saveDecompiledButton.setVisible(false);
  cancelDecompiledButton.setVisible(false);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(new JScrollPane(decompiledEditor),BorderLayout.CENTER);
  decPanel.add(searchPanel,BorderLayout.NORTH);
  searchPanel.setVisible(false);
  JPanel panA=new JPanel();
  panA.setLayout(new BorderLayout());
  panA.add(decPanel,BorderLayout.CENTER);
  panA.add(decLabel,BorderLayout.NORTH);
  panA.add(decButtonsPan,BorderLayout.SOUTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  setLayout(new BorderLayout());
  add(splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panA,panB),BorderLayout.CENTER);
  splitPane.setResizeWeight(0.5);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.setConfig(""String_Node_Str"",pce.getNewValue());
    }
  }
);
  editor.setContentType(""String_Node_Str"");
  editor.setFont(new Font(""String_Node_Str"",Font.PLAIN,editor.getFont().getSize()));
  decompiledEditor.setContentType(""String_Node_Str"");
  decompiledEditor.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledEditor.getFont().getSize()));
  editor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      editor.getCaret().setVisible(true);
      int pos=editor.getCaretPosition();
      Highlighting lastH=null;
      for (      Highlighting h : disassembledHilights) {
        if (pos < h.startPos) {
          break;
        }
        lastH=h;
      }
      String ofs=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
      Highlighting h2=Highlighting.search(decompiledHilights,""String_Node_Str"",ofs);
      if (h2 != null) {
        ignoreCarret=true;
        decompiledEditor.setCaretPosition(h2.startPos);
        decompiledEditor.getCaret().setVisible(true);
        ignoreCarret=false;
      }
    }
  }
);
  decompiledEditor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      decompiledEditor.getCaret().setVisible(true);
      int pos=decompiledEditor.getCaretPosition();
      System.out.println(""String_Node_Str"" + pos);
      Highlighting h=Highlighting.search(decompiledHilights,pos);
      if (h != null) {
        Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
        if (h2 != null) {
          ignoreCarret=true;
          if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
            editor.setCaretPosition(h2.startPos);
          }
          editor.getCaret().setVisible(true);
          ignoreCarret=false;
        }
      }
    }
  }
);
}","public ActionPanel(){
  DefaultSyntaxKit.initKit();
  editor=new LineMarkedEditorPane();
  editor.setEditable(false);
  decompiledEditor=new LineMarkedEditorPane();
  decompiledEditor.setEditable(false);
  searchPanel=new JPanel(new FlowLayout());
  JButton prevSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  prevSearchButton.setMargin(new Insets(3,3,3,3));
  prevSearchButton.addActionListener(this);
  prevSearchButton.setActionCommand(""String_Node_Str"");
  JButton nextSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  nextSearchButton.setMargin(new Insets(3,3,3,3));
  nextSearchButton.addActionListener(this);
  nextSearchButton.setActionCommand(""String_Node_Str"");
  JButton cancelSearchButton=new JButton(View.getIcon(""String_Node_Str""));
  cancelSearchButton.setMargin(new Insets(3,3,3,3));
  cancelSearchButton.addActionListener(this);
  cancelSearchButton.setActionCommand(""String_Node_Str"");
  searchPos=new JLabel(""String_Node_Str"");
  searchForLabel=new JLabel(translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  searchPanel.add(searchForLabel);
  searchPanel.add(prevSearchButton);
  searchPanel.add(new JLabel(""String_Node_Str""));
  searchPanel.add(searchPos);
  searchPanel.add(nextSearchButton);
  searchPanel.add(cancelSearchButton);
  JButton graphButton=new JButton(View.getIcon(""String_Node_Str""));
  graphButton.setActionCommand(""String_Node_Str"");
  graphButton.addActionListener(this);
  graphButton.setToolTipText(translate(""String_Node_Str""));
  graphButton.setMargin(new Insets(3,3,3,3));
  hexButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexButton.setActionCommand(""String_Node_Str"");
  hexButton.addActionListener(this);
  hexButton.setToolTipText(translate(""String_Node_Str""));
  hexButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton=new JToggleButton(View.getIcon(""String_Node_Str""));
  hexOnlyButton.setActionCommand(""String_Node_Str"");
  hexOnlyButton.addActionListener(this);
  hexOnlyButton.setToolTipText(translate(""String_Node_Str""));
  hexOnlyButton.setMargin(new Insets(3,3,3,3));
  hexOnlyButton.setVisible(false);
  topButtonsPan=new JPanel();
  topButtonsPan.setLayout(new BoxLayout(topButtonsPan,BoxLayout.X_AXIS));
  topButtonsPan.add(graphButton);
  topButtonsPan.add(hexButton);
  topButtonsPan.add(hexOnlyButton);
  JPanel panCode=new JPanel(new BorderLayout());
  panCode.add(new JScrollPane(editor),BorderLayout.CENTER);
  panCode.add(topButtonsPan,BorderLayout.NORTH);
  JPanel panB=new JPanel();
  panB.setLayout(new BorderLayout());
  asmLabel.setHorizontalAlignment(SwingConstants.CENTER);
  panB.add(asmLabel,BorderLayout.NORTH);
  panB.add(panCode,BorderLayout.CENTER);
  JPanel buttonsPan=new JPanel();
  buttonsPan.setLayout(new FlowLayout());
  buttonsPan.add(editButton);
  buttonsPan.add(saveButton);
  buttonsPan.add(cancelButton);
  editButton.setMargin(new Insets(3,3,3,10));
  saveButton.setMargin(new Insets(3,3,3,10));
  cancelButton.setMargin(new Insets(3,3,3,10));
  JPanel decButtonsPan=new JPanel(new FlowLayout());
  decButtonsPan.add(editDecompiledButton);
  decButtonsPan.add(experimentalLabel);
  decButtonsPan.add(saveDecompiledButton);
  decButtonsPan.add(cancelDecompiledButton);
  editDecompiledButton.setMargin(new Insets(3,3,3,10));
  saveDecompiledButton.setMargin(new Insets(3,3,3,10));
  cancelDecompiledButton.setMargin(new Insets(3,3,3,10));
  panB.add(buttonsPan,BorderLayout.SOUTH);
  saveButton.addActionListener(this);
  saveButton.setActionCommand(""String_Node_Str"");
  editButton.addActionListener(this);
  editButton.setActionCommand(""String_Node_Str"");
  cancelButton.addActionListener(this);
  cancelButton.setActionCommand(""String_Node_Str"");
  saveButton.setVisible(false);
  cancelButton.setVisible(false);
  saveDecompiledButton.addActionListener(this);
  saveDecompiledButton.setActionCommand(""String_Node_Str"");
  editDecompiledButton.addActionListener(this);
  editDecompiledButton.setActionCommand(""String_Node_Str"");
  cancelDecompiledButton.addActionListener(this);
  cancelDecompiledButton.setActionCommand(""String_Node_Str"");
  saveDecompiledButton.setVisible(false);
  cancelDecompiledButton.setVisible(false);
  JPanel decPanel=new JPanel(new BorderLayout());
  decPanel.add(new JScrollPane(decompiledEditor),BorderLayout.CENTER);
  decPanel.add(searchPanel,BorderLayout.NORTH);
  searchPanel.setVisible(false);
  JPanel panA=new JPanel();
  panA.setLayout(new BorderLayout());
  panA.add(decPanel,BorderLayout.CENTER);
  panA.add(decLabel,BorderLayout.NORTH);
  panA.add(decButtonsPan,BorderLayout.SOUTH);
  decLabel.setHorizontalAlignment(SwingConstants.CENTER);
  setLayout(new BorderLayout());
  add(splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,panA,panB),BorderLayout.CENTER);
  splitPane.setResizeWeight(0.5);
  splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent pce){
      Configuration.setConfig(""String_Node_Str"",pce.getNewValue());
    }
  }
);
  editor.setContentType(""String_Node_Str"");
  editor.setFont(new Font(""String_Node_Str"",Font.PLAIN,editor.getFont().getSize()));
  decompiledEditor.setContentType(""String_Node_Str"");
  decompiledEditor.setFont(new Font(""String_Node_Str"",Font.PLAIN,decompiledEditor.getFont().getSize()));
  editor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      editor.getCaret().setVisible(true);
      int pos=editor.getCaretPosition();
      Highlighting lastH=null;
      for (      Highlighting h : disassembledHilights) {
        if (pos < h.startPos) {
          break;
        }
        lastH=h;
      }
      String ofs=lastH == null ? ""String_Node_Str"" : lastH.getPropertyString(""String_Node_Str"");
      Highlighting h2=Highlighting.search(decompiledHilights,""String_Node_Str"",ofs);
      if (h2 != null) {
        ignoreCarret=true;
        decompiledEditor.setCaretPosition(h2.startPos);
        decompiledEditor.getCaret().setVisible(true);
        ignoreCarret=false;
      }
    }
  }
);
  decompiledEditor.addCaretListener(new CaretListener(){
    @Override public void caretUpdate(    CaretEvent e){
      if (ignoreCarret) {
        return;
      }
      if (editMode || editDecompiledMode) {
        return;
      }
      decompiledEditor.getCaret().setVisible(true);
      int pos=decompiledEditor.getCaretPosition();
      Highlighting h=Highlighting.search(decompiledHilights,pos);
      if (h != null) {
        Highlighting h2=Highlighting.search(disassembledHilights,""String_Node_Str"",h.getPropertyString(""String_Node_Str""));
        if (h2 != null) {
          ignoreCarret=true;
          if (h2.startPos > 0 && h2.startPos < editor.getText().length()) {
            editor.setCaretPosition(h2.startPos);
          }
          editor.getCaret().setVisible(true);
          ignoreCarret=false;
        }
      }
    }
  }
);
}",0.996404652802256
61972,"@Override public HilightedTextWriter newLine(){
  appendToSb(""String_Node_Str"");
  newLine=true;
  newLineCount++;
  return this;
}","@Override public HilightedTextWriter newLine(){
  appendToSb(NEW_LINE);
  newLine=true;
  newLineCount++;
  return this;
}",0.91699604743083
61973,"@Override public String getActionSourceSuffix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61974,"@Override public String getActionSourcePrefix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61975,"@Override public String getActionSourceSuffix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61976,"@Override public String getActionSourcePrefix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61977,"@Override public String getActionSourceSuffix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61978,"@Override public String getActionSourcePrefix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer){
  return writer;
}",0.7045454545454546
61979,public String getActionSourceSuffix();,public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer);,0.6542056074766355
61980,public String getActionSourcePrefix();,public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer);,0.6542056074766355
61981,"@Override public String getActionSourceSuffix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer){
  writer.unindent();
  return writer.appendNoHilight(""String_Node_Str"").newLine();
}",0.6198347107438017
61982,"@Override public String getActionSourcePrefix(){
  return getHeader(false) + ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer){
  writer.appendNoHilight(getHeader(false));
  writer.appendNoHilight(""String_Node_Str"").newLine();
  return writer.indent();
}",0.5148514851485149
61983,"@Override public String getActionSourceSuffix(){
  return ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourceSuffix(GraphTextWriter writer){
  writer.unindent();
  return writer.appendNoHilight(""String_Node_Str"").newLine();
}",0.6198347107438017
61984,"@Override public String getActionSourcePrefix(){
  return eventFlags.getHeader(keyCode,false) + ""String_Node_Str"";
}","@Override public GraphTextWriter getActionSourcePrefix(GraphTextWriter writer){
  writer.appendNoHilight(eventFlags.getHeader(keyCode,false));
  writer.appendNoHilight(""String_Node_Str"").newLine();
  return writer.indent();
}",0.5865102639296188
61985,"private static String convertActionScript(ASMSource as){
  HilightedText decompiledAS=Action.actionsToSource(as.getActions(SWF.DEFAULT_VERSION),SWF.DEFAULT_VERSION,as.toString(),false,as.getActionSourceIndent());
  return as.getActionSourcePrefix() + decompiledAS.text + as.getActionSourceSuffix();
}","private static String convertActionScript(ASMSource as){
  HilightedTextWriter writer=new HilightedTextWriter(false);
  as.getActionSourcePrefix(writer);
  Action.actionsToSource(as.getActions(SWF.DEFAULT_VERSION),SWF.DEFAULT_VERSION,as.toString(),writer);
  as.getActionSourceSuffix(writer);
  return writer.toString();
}",0.6302250803858521
61986,"/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param address
 * @param ip
 * @param rri
 * @param version
 * @param containerSWFOffset
 * @param endip
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,ReReadableInputStream rri,int version,int ip,int endIp,String path) throws IOException {
  boolean deobfuscate=Configuration.getConfig(""String_Node_Str"",true);
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(rri,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,rri,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  Action lastAction=actions.get(actions.size() - 1);
  if (!(lastAction instanceof ActionEnd)) {
    Action aEnd=new ActionEnd();
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
    endAddress+=getTotalActionLength(aEnd);
  }
  if (deobfuscate) {
    return deobfuscateActionList(listeners,containerSWFOffset,actions,version,0,path);
  }
  return actions;
}","/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param rri
 * @param version
 * @param ip
 * @param endIp
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> readActionList(List<DisassemblyListener> listeners,long containerSWFOffset,ReReadableInputStream rri,int version,int ip,int endIp,String path) throws IOException {
  boolean deobfuscate=Configuration.getConfig(""String_Node_Str"",true);
  ConstantPool cpool=new ConstantPool();
  SWFInputStream sis=new SWFInputStream(rri,version);
  List<Action> actionMap=new ArrayList<>();
  List<Long> nextOffsets=new ArrayList<>();
  Action entryAction=readActionListAtPos(listeners,containerSWFOffset,cpool,sis,rri,actionMap,nextOffsets,ip,ip,endIp,version,path,false,new ArrayList<Long>());
  Map<Action,List<Action>> containerLastActions=new HashMap<>();
  getContainerLastActions(actionMap,containerLastActions);
  List<Action> actions=new ArrayList<>();
  int index=getNextNotNullIndex(actionMap,0);
  if (index != -1 && entryAction != actionMap.get(index)) {
    ActionJump jump=new ActionJump(0);
    int size=getTotalActionLength(jump);
    jump.setJumpOffset((int)(entryAction.getAddress() - size));
    actions.add(jump);
  }
  index=getNextNotNullIndex(actionMap,index);
  while (index > -1) {
    Action action=actionMap.get(index);
    long nextOffset=nextOffsets.get(index);
    int nextIndex=getNextNotNullIndex(actionMap,index + 1);
    actions.add(action);
    if (nextIndex != -1 && nextOffset != nextIndex) {
      if (!action.isExit() && !(action instanceof ActionJump)) {
        ActionJump jump=new ActionJump(0);
        jump.setAddress(action.getAddress(),version);
        int size=getTotalActionLength(jump);
        jump.setJumpOffset((int)(nextOffset - action.getAddress() - size));
        actions.add(jump);
      }
    }
    index=nextIndex;
  }
  Map<Action,Action> jumps=new HashMap<>();
  getJumps(actions,jumps);
  long endAddress=updateAddresses(actions,ip,version);
  updateJumps(actions,jumps,containerLastActions,endAddress,version);
  updateActionStores(actions,jumps);
  updateContainerSizes(actions,containerLastActions);
  updateActionLengths(actions,version);
  Action lastAction=actions.get(actions.size() - 1);
  if (!(lastAction instanceof ActionEnd)) {
    Action aEnd=new ActionEnd();
    aEnd.setAddress(endAddress,version);
    actions.add(aEnd);
    endAddress+=getTotalActionLength(aEnd);
  }
  if (deobfuscate) {
    return deobfuscateActionList(listeners,containerSWFOffset,actions,version,0,path);
  }
  return actions;
}",0.9783824077525158
61987,"/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param address
 * @param ip
 * @param rri
 * @param version
 * @param containerSWFOffset
 * @param endip
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> deobfuscateActionList(List<DisassemblyListener> listeners,long containerSWFOffset,List<Action> actions,int version,int ip,String path) throws IOException {
  byte[] data=Action.actionsToBytes(actions,true,version);
  ReReadableInputStream rri=new ReReadableInputStream(new ByteArrayInputStream(data));
  int endIp=data.length;
  List<Action> retdups=new ArrayList<>();
  for (int i=0; i <= endIp; i++) {
    Action a=new ActionNop();
    a.setAddress(i,version);
    retdups.add(a);
  }
  ConstantPool cpool=new ConstantPool();
  Stack<GraphTargetItem> stack=new Stack<>();
  List<Object> localData=Helper.toList(new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>());
  SWFInputStream sis=new SWFInputStream(rri,version);
  deobfustaceActionListAtPosRecursive(listeners,new ArrayList<GraphTargetItem>(),new HashMap<Long,List<GraphSourceItemContainer>>(),containerSWFOffset,localData,stack,cpool,sis,rri,ip,retdups,ip,endIp,path,new HashMap<Integer,Integer>(),false,new HashMap<Integer,HashMap<String,GraphTargetItem>>(),version);
  if (!retdups.isEmpty()) {
    for (int i=0; i < ip; i++) {
      retdups.remove(0);
    }
  }
  List<Action> ret=new ArrayList<>();
  Action last=null;
  for (  Action a : retdups) {
    if (a != last) {
      ret.add(a);
    }
    last=a;
  }
  for (int i=0; i < retdups.size(); i++) {
    Action a=retdups.get(i);
    if (a instanceof ActionEnd) {
      if (i < retdups.size() - 1) {
        ActionJump jmp=new ActionJump(0);
        jmp.setJumpOffset(retdups.size() - i - jmp.getBytes(version).length);
        a.replaceWith=jmp;
      }
    }
  }
  if (Configuration.getConfig(""String_Node_Str"",true)) {
    ret=Action.removeNops(0,ret,version,0,path);
  }
  List<Action> reta=new ArrayList<>();
  for (  Object o : ret) {
    if (o instanceof Action) {
      reta.add((Action)o);
    }
  }
  return reta;
}","/** 
 * Reads list of actions from the stream. Reading ends with ActionEndFlag(=0) or end of the stream.
 * @param listeners
 * @param containerSWFOffset
 * @param actions
 * @param version
 * @param ip
 * @param path
 * @return List of actions
 * @throws IOException
 */
public static List<Action> deobfuscateActionList(List<DisassemblyListener> listeners,long containerSWFOffset,List<Action> actions,int version,int ip,String path) throws IOException {
  byte[] data=Action.actionsToBytes(actions,true,version);
  ReReadableInputStream rri=new ReReadableInputStream(new ByteArrayInputStream(data));
  int endIp=data.length;
  List<Action> retdups=new ArrayList<>();
  for (int i=0; i <= endIp; i++) {
    Action a=new ActionNop();
    a.setAddress(i,version);
    retdups.add(a);
  }
  ConstantPool cpool=new ConstantPool();
  Stack<GraphTargetItem> stack=new Stack<>();
  List<Object> localData=Helper.toList(new HashMap<Integer,String>(),new HashMap<String,GraphTargetItem>(),new HashMap<String,GraphTargetItem>());
  SWFInputStream sis=new SWFInputStream(rri,version);
  deobfustaceActionListAtPosRecursive(listeners,new ArrayList<GraphTargetItem>(),new HashMap<Long,List<GraphSourceItemContainer>>(),containerSWFOffset,localData,stack,cpool,sis,rri,ip,retdups,ip,endIp,path,new HashMap<Integer,Integer>(),false,new HashMap<Integer,HashMap<String,GraphTargetItem>>(),version);
  if (!retdups.isEmpty()) {
    for (int i=0; i < ip; i++) {
      retdups.remove(0);
    }
  }
  List<Action> ret=new ArrayList<>();
  Action last=null;
  for (  Action a : retdups) {
    if (a != last) {
      ret.add(a);
    }
    last=a;
  }
  for (int i=0; i < retdups.size(); i++) {
    Action a=retdups.get(i);
    if (a instanceof ActionEnd) {
      if (i < retdups.size() - 1) {
        ActionJump jmp=new ActionJump(0);
        jmp.setJumpOffset(retdups.size() - i - jmp.getBytes(version).length);
        a.replaceWith=jmp;
      }
    }
  }
  if (Configuration.getConfig(""String_Node_Str"",true)) {
    ret=Action.removeNops(0,ret,version,0,path);
  }
  List<Action> reta=new ArrayList<>();
  for (  Object o : ret) {
    if (o instanceof Action) {
      reta.add((Action)o);
    }
  }
  return reta;
}",0.9769230769230768
61988,"/** 
 * Highlights specified text as class by adding special tags
 * @param text Text to highlight
 * @param offset Offset of trait
 * @return Highlighted text
 */
public static String hilighClass(String text,long index){
  return hilight(text,""String_Node_Str"" + index);
}","/** 
 * Highlights specified text as class by adding special tags
 * @param text Text to highlight
 * @param index Class index
 * @return Highlighted text
 */
public static String hilighClass(String text,long index){
  return hilight(text,""String_Node_Str"" + index);
}",0.9279112754158964
61989,"/** 
 * Highlights specified text as trait by adding special tags
 * @param text Text to highlight
 * @param offset Offset of trait
 * @return Highlighted text
 */
public static String hilighTrait(String text,long index){
  return hilight(text,""String_Node_Str"" + index);
}","/** 
 * Highlights specified text as trait by adding special tags
 * @param text Text to highlight
 * @param index Trait index
 * @return Highlighted text
 */
public static String hilighTrait(String text,long index){
  return hilight(text,""String_Node_Str"" + index);
}",0.9279112754158964
61990,"public int addMethodBody(MethodBody body){
  bodies=Arrays.copyOf(bodies,bodies.length + 1);
  bodies[bodies.length - 1]=body;
  bodyIdxFromMethodIdx=Arrays.copyOf(bodyIdxFromMethodIdx,bodyIdxFromMethodIdx.length + 1);
  bodyIdxFromMethodIdx[bodyIdxFromMethodIdx.length - 1]=body.method_info;
  return bodies.length - 1;
}","public int addMethodBody(MethodBody body){
  bodies=Arrays.copyOf(bodies,bodies.length + 1);
  bodies[bodies.length - 1]=body;
  if (body.method_info >= bodyIdxFromMethodIdx.length) {
    int newlen=body.method_info + 1;
    int oldlen=bodyIdxFromMethodIdx.length;
    bodyIdxFromMethodIdx=Arrays.copyOf(bodyIdxFromMethodIdx,newlen);
    for (int i=oldlen; i < newlen; i++) {
      bodyIdxFromMethodIdx[i]=-1;
    }
    bodyIdxFromMethodIdx[body.method_info]=bodies.length - 1;
  }
  return bodies.length - 1;
}",0.5498199279711885
61991,"public String getParams(ConstantPool constants,List<String> fullyQualifiedNames){
  StringBuilder s=new StringBuilder();
  for (int i=0; i < definition.operands.length; i++) {
switch (definition.operands[i]) {
case AVM2Code.DAT_MULTINAME_INDEX:
      if (operands[i] == 0) {
        s.append(""String_Node_Str"");
      }
 else {
        s.append(""String_Node_Str"");
        s.append(constants.constant_multiname[operands[i]].toString(constants,fullyQualifiedNames));
      }
    break;
case AVM2Code.DAT_STRING_INDEX:
  s.append(""String_Node_Str"");
s.append(Helper.escapeString(constants.constant_string[operands[i]]));
s.append(""String_Node_Str"");
break;
case AVM2Code.DAT_INT_INDEX:
s.append(""String_Node_Str"");
s.append(constants.constant_int[operands[i]]);
break;
case AVM2Code.DAT_UINT_INDEX:
s.append(""String_Node_Str"");
s.append(constants.constant_uint[operands[i]]);
break;
case AVM2Code.DAT_DOUBLE_INDEX:
s.append(""String_Node_Str"");
s.append(constants.constant_double[operands[i]]);
break;
case AVM2Code.DAT_OFFSET:
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[i] + getBytes().length));
break;
case AVM2Code.DAT_CASE_BASEOFFSET:
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[i]));
break;
case AVM2Code.OPT_CASE_OFFSETS:
s.append(""String_Node_Str"");
s.append(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[j]));
}
break;
default :
s.append(""String_Node_Str"");
s.append(operands[i]);
}
}
return s.toString();
}","public String getParams(ConstantPool constants,List<String> fullyQualifiedNames){
  StringBuilder s=new StringBuilder();
  for (int i=0; i < definition.operands.length; i++) {
switch (definition.operands[i]) {
case AVM2Code.DAT_MULTINAME_INDEX:
      if (operands[i] == 0) {
        s.append(""String_Node_Str"");
      }
 else {
        s.append(""String_Node_Str"");
        s.append(constants.constant_multiname[operands[i]].toString(constants,fullyQualifiedNames));
      }
    break;
case AVM2Code.DAT_STRING_INDEX:
  if (operands[i] == 0) {
    s.append(""String_Node_Str"");
  }
 else {
    s.append(""String_Node_Str"");
    s.append(Helper.escapeString(constants.constant_string[operands[i]]));
    s.append(""String_Node_Str"");
  }
break;
case AVM2Code.DAT_INT_INDEX:
if (operands[i] == 0) {
s.append(""String_Node_Str"");
}
 else {
s.append(""String_Node_Str"");
s.append(constants.constant_int[operands[i]]);
}
break;
case AVM2Code.DAT_UINT_INDEX:
if (operands[i] == 0) {
s.append(""String_Node_Str"");
}
 else {
s.append(""String_Node_Str"");
s.append(constants.constant_uint[operands[i]]);
}
break;
case AVM2Code.DAT_DOUBLE_INDEX:
if (operands[i] == 0) {
s.append(""String_Node_Str"");
}
 else {
s.append(""String_Node_Str"");
s.append(constants.constant_double[operands[i]]);
}
break;
case AVM2Code.DAT_OFFSET:
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[i] + getBytes().length));
break;
case AVM2Code.DAT_CASE_BASEOFFSET:
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[i]));
break;
case AVM2Code.OPT_CASE_OFFSETS:
s.append(""String_Node_Str"");
s.append(operands[i]);
for (int j=i + 1; j < operands.length; j++) {
s.append(""String_Node_Str"");
s.append(""String_Node_Str"");
s.append(Helper.formatAddress(offset + operands[j]));
}
break;
default :
s.append(""String_Node_Str"");
s.append(operands[i]);
}
}
return s.toString();
}",0.8486366165831942
61992,"public static AVM2Code parse(InputStream is,ConstantPool constants,Trait trait,MissingSymbolHandler missingHandler,MethodBody body,MethodInfo info) throws IOException, ParseException {
  AVM2Code code=new AVM2Code();
  List<OffsetItem> offsetItems=new ArrayList<>();
  List<LabelItem> labelItems=new ArrayList<>();
  List<ABCException> exceptions=new ArrayList<>();
  List<Integer> exceptionIndices=new ArrayList<>();
  int offset=0;
  Flasm3Lexer lexer=new Flasm3Lexer(new InputStreamReader(is,""String_Node_Str""));
  ParsedSymbol symb;
  AVM2Instruction lastIns=null;
  List<String> exceptionsFrom=new ArrayList<>();
  List<String> exceptionsTo=new ArrayList<>();
  List<String> exceptionsTargets=new ArrayList<>();
  info.flags=0;
  info.name_index=0;
  List<Integer> paramTypes=new ArrayList<>();
  List<Integer> paramNames=new ArrayList<>();
  List<ValueKind> optional=new ArrayList<>();
  do {
    symb=lexer.lex();
    if (Arrays.asList(ParsedSymbol.TYPE_KEYWORD_BODY,ParsedSymbol.TYPE_KEYWORD_CODE,ParsedSymbol.TYPE_KEYWORD_METHOD).contains(symb.type)) {
      continue;
    }
    if (symb.type == ParsedSymbol.TYPE_KEYWORD_TRAIT) {
      if (trait == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
      symb=lexer.lex();
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_METHOD:
case ParsedSymbol.TYPE_KEYWORD_GETTER:
case ParsedSymbol.TYPE_KEYWORD_SETTER:
        if (!(trait instanceof TraitMethodGetterSetter)) {
          throw new ParseException(""String_Node_Str"",lexer.yyline());
        }
      TraitMethodGetterSetter tm=(TraitMethodGetterSetter)trait;
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_METHOD:
      tm.kindType=Trait.TRAIT_METHOD;
    break;
case ParsedSymbol.TYPE_KEYWORD_GETTER:
  tm.kindType=Trait.TRAIT_GETTER;
break;
case ParsedSymbol.TYPE_KEYWORD_SETTER:
tm.kindType=Trait.TRAIT_SETTER;
break;
}
tm.name_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_KEYWORD_DISPID,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
tm.disp_id=(int)(long)(Long)symb.value;
break;
case ParsedSymbol.TYPE_KEYWORD_FUNCTION:
if (!(trait instanceof TraitFunction)) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_NAME) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
info.name_index=constants.getStringId((String)symb.value,true);
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_PARAM) {
paramTypes.add(parseMultiName(constants,lexer));
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_PARAMNAME) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
paramNames.add(constants.getStringId((String)symb.value,true));
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_OPTIONAL) {
optional.add(parseValue(constants,lexer));
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_MAXSTACK) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_stack=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_LOCALCOUNT) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_regs=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_INITSCOPEDEPTH) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.init_scope_depth=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_MAXSCOPEDEPTH) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_scope_depth=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_RETURNS) {
info.ret_type=parseMultiName(constants,lexer);
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_FLAG) {
symb=lexer.lex();
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_EXPLICIT:
info.setFlagExplicit();
break;
case ParsedSymbol.TYPE_KEYWORD_HAS_OPTIONAL:
info.setFlagHas_optional();
break;
case ParsedSymbol.TYPE_KEYWORD_HAS_PARAM_NAMES:
info.setFlagHas_paramnames();
break;
case ParsedSymbol.TYPE_KEYWORD_IGNORE_REST:
info.setFlagIgnore_Rest();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_ACTIVATION:
info.setFlagNeed_activation();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_ARGUMENTS:
info.setFlagNeed_Arguments();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_REST:
info.setFlagNeed_rest();
break;
case ParsedSymbol.TYPE_KEYWORD_SET_DXNS:
info.setFlagSetsdxns();
break;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_TRY) {
expected(ParsedSymbol.TYPE_KEYWORD_FROM,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsFrom.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TO,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsTo.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TARGET,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsTargets.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TYPE,""String_Node_Str"",lexer);
ABCException ex=new ABCException();
ex.type_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_KEYWORD_NAME,""String_Node_Str"",lexer);
ex.name_index=parseMultiName(constants,lexer);
exceptions.add(ex);
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_START) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).start=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_END) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).end=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_TARGET) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).target=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EOF) {
break;
}
if (symb.type == ParsedSymbol.TYPE_COMMENT) {
if (lastIns != null) {
lastIns.comment=(String)symb.value;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_INSTRUCTION_NAME) {
if (((String)symb.value).toLowerCase(Locale.ENGLISH).equals(""String_Node_Str"")) {
ParsedSymbol exIndex=lexer.lex();
if (exIndex.type != ParsedSymbol.TYPE_INTEGER) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ParsedSymbol exName=lexer.lex();
if (exName.type != ParsedSymbol.TYPE_MULTINAME) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ParsedSymbol exType=lexer.lex();
if (exType.type != ParsedSymbol.TYPE_MULTINAME) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ABCException ex=new ABCException();
ex.name_index=checkMultinameIndex(constants,(int)(long)(Long)exName.value,lexer.yyline());
ex.type_index=checkMultinameIndex(constants,(int)(long)(Long)exType.value,lexer.yyline());
exceptions.add(ex);
exceptionIndices.add((int)(long)(Long)exIndex.value);
continue;
}
boolean insFound=false;
for (InstructionDefinition def : AVM2Code.instructionSet) {
if (def.instructionName.equals((String)symb.value)) {
insFound=true;
List<Integer> operandsList=new ArrayList<>();
for (int i=0; i < def.operands.length; i++) {
ParsedSymbol parsedOperand=lexer.lex();
switch (def.operands[i]) {
case AVM2Code.DAT_MULTINAME_INDEX:
lexer.pushback(parsedOperand);
operandsList.add(parseMultiName(constants,lexer));
break;
case AVM2Code.DAT_STRING_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_STRING) {
int sid=constants.getStringId((String)parsedOperand.value);
if (sid == 0) {
if ((missingHandler != null) && (missingHandler.missingString((String)parsedOperand.value))) {
sid=constants.addString((String)parsedOperand.value);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(sid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_INT_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
long intVal=(Long)parsedOperand.value;
int iid=constants.getIntId(intVal);
if (iid == 0) {
if ((missingHandler != null) && (missingHandler.missingInt(intVal))) {
iid=constants.addInt(intVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(iid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_UINT_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
long intVal=(Long)parsedOperand.value;
int iid=constants.getUIntId(intVal);
if (iid == 0) {
if ((missingHandler != null) && (missingHandler.missingUInt(intVal))) {
iid=constants.addUInt(intVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(iid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_DOUBLE_INDEX:
if ((parsedOperand.type == ParsedSymbol.TYPE_INTEGER) || (parsedOperand.type == ParsedSymbol.TYPE_FLOAT)) {
double doubleVal=0;
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
doubleVal=(Long)parsedOperand.value;
}
if (parsedOperand.type == ParsedSymbol.TYPE_FLOAT) {
doubleVal=(Double)parsedOperand.value;
}
int did=constants.getDoubleId(doubleVal);
if (did == 0) {
if ((missingHandler != null) && (missingHandler.missingDouble(doubleVal))) {
did=constants.addDouble(doubleVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(did);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_OFFSET:
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new OffsetItem((String)parsedOperand.value,code.code.size(),i));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_CASE_BASEOFFSET:
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new CaseOffsetItem((String)parsedOperand.value,code.code.size(),i));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.OPT_CASE_OFFSETS:
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
int patCount=(int)(long)(Long)parsedOperand.value;
operandsList.add(patCount);
for (int c=0; c <= patCount; c++) {
parsedOperand=lexer.lex();
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new CaseOffsetItem((String)parsedOperand.value,code.code.size(),i + (c + 1)));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
default :
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
operandsList.add((int)(long)(Long)parsedOperand.value);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
int[] operands=new int[operandsList.size()];
for (int i=0; i < operandsList.size(); i++) {
operands[i]=operandsList.get(i);
}
lastIns=new AVM2Instruction(offset,def,operands,new byte[0]);
code.code.add(lastIns);
offset+=lastIns.getBytes().length;
break;
}
}
if (symb.value.toString().toLowerCase().equals(""String_Node_Str"")) {
lastIns=new AVM2Instruction(offset,new DeobfuscatePopIns(),new int[0],new byte[0]);
code.code.add(lastIns);
offset+=lastIns.getBytes().length;
insFound=true;
}
if (!insFound) {
throw new ParseException(""String_Node_Str"" + (String)symb.value,lexer.yyline());
}
}
 else if (symb.type == ParsedSymbol.TYPE_LABEL) {
labelItems.add(new LabelItem((String)symb.value,offset));
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 while (symb.type != ParsedSymbol.TYPE_EOF);
code.compact();
for (LabelItem li : labelItems) {
int ind;
ind=exceptionsFrom.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).start=li.offset;
}
ind=exceptionsTo.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).end=li.offset;
}
ind=exceptionsTargets.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).target=li.offset;
}
}
for (OffsetItem oi : offsetItems) {
for (LabelItem li : labelItems) {
if (oi.label.equals(li.label)) {
AVM2Instruction ins=code.code.get((int)oi.insPosition);
int relOffset;
if (oi instanceof CaseOffsetItem) {
relOffset=li.offset - (int)ins.offset;
}
 else {
relOffset=li.offset - ((int)ins.offset + ins.getBytes().length);
}
ins.operands[oi.insOperandIndex]=relOffset;
}
}
}
body.exceptions=new ABCException[exceptions.size()];
for (int e=0; e < exceptions.size(); e++) {
body.exceptions[e]=exceptions.get(e);
}
info.param_types=new int[paramTypes.size()];
for (int i=0; i < paramTypes.size(); i++) {
info.param_types[i]=paramTypes.get(i);
}
if (info.flagHas_paramnames()) {
info.paramNames=new int[paramNames.size()];
for (int i=0; i < paramNames.size(); i++) {
info.paramNames[i]=paramNames.get(i);
}
}
if (info.flagHas_optional()) {
info.optional=new ValueKind[optional.size()];
for (int i=0; i < optional.size(); i++) {
info.optional[i]=optional.get(i);
}
}
return code;
}","public static AVM2Code parse(InputStream is,ConstantPool constants,Trait trait,MissingSymbolHandler missingHandler,MethodBody body,MethodInfo info) throws IOException, ParseException {
  AVM2Code code=new AVM2Code();
  List<OffsetItem> offsetItems=new ArrayList<>();
  List<LabelItem> labelItems=new ArrayList<>();
  List<ABCException> exceptions=new ArrayList<>();
  List<Integer> exceptionIndices=new ArrayList<>();
  int offset=0;
  Flasm3Lexer lexer=new Flasm3Lexer(new InputStreamReader(is,""String_Node_Str""));
  ParsedSymbol symb;
  AVM2Instruction lastIns=null;
  List<String> exceptionsFrom=new ArrayList<>();
  List<String> exceptionsTo=new ArrayList<>();
  List<String> exceptionsTargets=new ArrayList<>();
  info.flags=0;
  info.name_index=0;
  List<Integer> paramTypes=new ArrayList<>();
  List<Integer> paramNames=new ArrayList<>();
  List<ValueKind> optional=new ArrayList<>();
  do {
    symb=lexer.lex();
    if (Arrays.asList(ParsedSymbol.TYPE_KEYWORD_BODY,ParsedSymbol.TYPE_KEYWORD_CODE,ParsedSymbol.TYPE_KEYWORD_METHOD).contains(symb.type)) {
      continue;
    }
    if (symb.type == ParsedSymbol.TYPE_KEYWORD_TRAIT) {
      if (trait == null) {
        throw new ParseException(""String_Node_Str"",lexer.yyline());
      }
      symb=lexer.lex();
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_METHOD:
case ParsedSymbol.TYPE_KEYWORD_GETTER:
case ParsedSymbol.TYPE_KEYWORD_SETTER:
        if (!(trait instanceof TraitMethodGetterSetter)) {
          throw new ParseException(""String_Node_Str"",lexer.yyline());
        }
      TraitMethodGetterSetter tm=(TraitMethodGetterSetter)trait;
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_METHOD:
      tm.kindType=Trait.TRAIT_METHOD;
    break;
case ParsedSymbol.TYPE_KEYWORD_GETTER:
  tm.kindType=Trait.TRAIT_GETTER;
break;
case ParsedSymbol.TYPE_KEYWORD_SETTER:
tm.kindType=Trait.TRAIT_SETTER;
break;
}
tm.name_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_KEYWORD_DISPID,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
tm.disp_id=(int)(long)(Long)symb.value;
break;
case ParsedSymbol.TYPE_KEYWORD_FUNCTION:
if (!(trait instanceof TraitFunction)) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_NAME) {
symb=lexer.lex();
if (symb.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
info.name_index=0;
}
 else {
expected(symb,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
info.name_index=constants.getStringId((String)symb.value,true);
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_PARAM) {
paramTypes.add(parseMultiName(constants,lexer));
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_PARAMNAME) {
symb=lexer.lex();
if (symb.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
paramNames.add(0);
}
 else {
expected(symb,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
paramNames.add(constants.getStringId((String)symb.value,true));
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_OPTIONAL) {
optional.add(parseValue(constants,lexer));
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_MAXSTACK) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_stack=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_LOCALCOUNT) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_regs=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_INITSCOPEDEPTH) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.init_scope_depth=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_MAXSCOPEDEPTH) {
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
body.max_scope_depth=(int)(long)(Long)symb.value;
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_RETURNS) {
info.ret_type=parseMultiName(constants,lexer);
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_FLAG) {
symb=lexer.lex();
switch (symb.type) {
case ParsedSymbol.TYPE_KEYWORD_EXPLICIT:
info.setFlagExplicit();
break;
case ParsedSymbol.TYPE_KEYWORD_HAS_OPTIONAL:
info.setFlagHas_optional();
break;
case ParsedSymbol.TYPE_KEYWORD_HAS_PARAM_NAMES:
info.setFlagHas_paramnames();
break;
case ParsedSymbol.TYPE_KEYWORD_IGNORE_REST:
info.setFlagIgnore_Rest();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_ACTIVATION:
info.setFlagNeed_activation();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_ARGUMENTS:
info.setFlagNeed_Arguments();
break;
case ParsedSymbol.TYPE_KEYWORD_NEED_REST:
info.setFlagNeed_rest();
break;
case ParsedSymbol.TYPE_KEYWORD_SET_DXNS:
info.setFlagSetsdxns();
break;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_KEYWORD_TRY) {
expected(ParsedSymbol.TYPE_KEYWORD_FROM,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsFrom.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TO,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsTo.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TARGET,""String_Node_Str"",lexer);
symb=lexer.lex();
expected(symb,ParsedSymbol.TYPE_IDENTIFIER,""String_Node_Str"");
exceptionsTargets.add((String)symb.value);
expected(ParsedSymbol.TYPE_KEYWORD_TYPE,""String_Node_Str"",lexer);
ABCException ex=new ABCException();
ex.type_index=parseMultiName(constants,lexer);
expected(ParsedSymbol.TYPE_KEYWORD_NAME,""String_Node_Str"",lexer);
ex.name_index=parseMultiName(constants,lexer);
exceptions.add(ex);
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_START) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).start=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_END) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).end=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EXCEPTION_TARGET) {
int exIndex=(Integer)symb.value;
int listIndex=exceptionIndices.indexOf(exIndex);
if (listIndex == -1) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
exceptions.get(listIndex).target=offset;
continue;
}
if (symb.type == ParsedSymbol.TYPE_EOF) {
break;
}
if (symb.type == ParsedSymbol.TYPE_COMMENT) {
if (lastIns != null) {
lastIns.comment=(String)symb.value;
}
continue;
}
if (symb.type == ParsedSymbol.TYPE_INSTRUCTION_NAME) {
if (((String)symb.value).toLowerCase(Locale.ENGLISH).equals(""String_Node_Str"")) {
ParsedSymbol exIndex=lexer.lex();
if (exIndex.type != ParsedSymbol.TYPE_INTEGER) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ParsedSymbol exName=lexer.lex();
if (exName.type != ParsedSymbol.TYPE_MULTINAME) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ParsedSymbol exType=lexer.lex();
if (exType.type != ParsedSymbol.TYPE_MULTINAME) {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
ABCException ex=new ABCException();
ex.name_index=checkMultinameIndex(constants,(int)(long)(Long)exName.value,lexer.yyline());
ex.type_index=checkMultinameIndex(constants,(int)(long)(Long)exType.value,lexer.yyline());
exceptions.add(ex);
exceptionIndices.add((int)(long)(Long)exIndex.value);
continue;
}
boolean insFound=false;
for (InstructionDefinition def : AVM2Code.instructionSet) {
if (def.instructionName.equals((String)symb.value)) {
insFound=true;
List<Integer> operandsList=new ArrayList<>();
for (int i=0; i < def.operands.length; i++) {
ParsedSymbol parsedOperand=lexer.lex();
switch (def.operands[i]) {
case AVM2Code.DAT_MULTINAME_INDEX:
lexer.pushback(parsedOperand);
operandsList.add(parseMultiName(constants,lexer));
break;
case AVM2Code.DAT_STRING_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
operandsList.add(0);
}
 else {
if (parsedOperand.type == ParsedSymbol.TYPE_STRING) {
int sid=constants.getStringId((String)parsedOperand.value);
if (sid == 0) {
if ((missingHandler != null) && (missingHandler.missingString((String)parsedOperand.value))) {
sid=constants.addString((String)parsedOperand.value);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(sid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
break;
case AVM2Code.DAT_INT_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
operandsList.add(0);
}
 else {
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
long intVal=(Long)parsedOperand.value;
int iid=constants.getIntId(intVal);
if (iid == 0) {
if ((missingHandler != null) && (missingHandler.missingInt(intVal))) {
iid=constants.addInt(intVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(iid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
break;
case AVM2Code.DAT_UINT_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
operandsList.add(0);
}
 else {
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
long intVal=(Long)parsedOperand.value;
int iid=constants.getUIntId(intVal);
if (iid == 0) {
if ((missingHandler != null) && (missingHandler.missingUInt(intVal))) {
iid=constants.addUInt(intVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(iid);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
break;
case AVM2Code.DAT_DOUBLE_INDEX:
if (parsedOperand.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
operandsList.add(0);
}
 else {
if ((parsedOperand.type == ParsedSymbol.TYPE_INTEGER) || (parsedOperand.type == ParsedSymbol.TYPE_FLOAT)) {
double doubleVal=0;
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
doubleVal=(Long)parsedOperand.value;
}
if (parsedOperand.type == ParsedSymbol.TYPE_FLOAT) {
doubleVal=(Double)parsedOperand.value;
}
int did=constants.getDoubleId(doubleVal);
if (did == 0) {
if ((missingHandler != null) && (missingHandler.missingDouble(doubleVal))) {
did=constants.addDouble(doubleVal);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
operandsList.add(did);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
break;
case AVM2Code.DAT_OFFSET:
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new OffsetItem((String)parsedOperand.value,code.code.size(),i));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.DAT_CASE_BASEOFFSET:
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new CaseOffsetItem((String)parsedOperand.value,code.code.size(),i));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
case AVM2Code.OPT_CASE_OFFSETS:
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
int patCount=(int)(long)(Long)parsedOperand.value;
operandsList.add(patCount);
for (int c=0; c <= patCount; c++) {
parsedOperand=lexer.lex();
if (parsedOperand.type == ParsedSymbol.TYPE_IDENTIFIER) {
offsetItems.add(new CaseOffsetItem((String)parsedOperand.value,code.code.size(),i + (c + 1)));
operandsList.add(0);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
break;
default :
if (parsedOperand.type == ParsedSymbol.TYPE_INTEGER) {
operandsList.add((int)(long)(Long)parsedOperand.value);
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
}
int[] operands=new int[operandsList.size()];
for (int i=0; i < operandsList.size(); i++) {
operands[i]=operandsList.get(i);
}
lastIns=new AVM2Instruction(offset,def,operands,new byte[0]);
code.code.add(lastIns);
offset+=lastIns.getBytes().length;
break;
}
}
if (symb.value.toString().toLowerCase().equals(""String_Node_Str"")) {
lastIns=new AVM2Instruction(offset,new DeobfuscatePopIns(),new int[0],new byte[0]);
code.code.add(lastIns);
offset+=lastIns.getBytes().length;
insFound=true;
}
if (!insFound) {
throw new ParseException(""String_Node_Str"" + (String)symb.value,lexer.yyline());
}
}
 else if (symb.type == ParsedSymbol.TYPE_LABEL) {
labelItems.add(new LabelItem((String)symb.value,offset));
}
 else {
throw new ParseException(""String_Node_Str"",lexer.yyline());
}
}
 while (symb.type != ParsedSymbol.TYPE_EOF);
code.compact();
for (LabelItem li : labelItems) {
int ind;
ind=exceptionsFrom.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).start=li.offset;
}
ind=exceptionsTo.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).end=li.offset;
}
ind=exceptionsTargets.indexOf(li.label);
if (ind > -1) {
exceptions.get(ind).target=li.offset;
}
}
for (OffsetItem oi : offsetItems) {
for (LabelItem li : labelItems) {
if (oi.label.equals(li.label)) {
AVM2Instruction ins=code.code.get((int)oi.insPosition);
int relOffset;
if (oi instanceof CaseOffsetItem) {
relOffset=li.offset - (int)ins.offset;
}
 else {
relOffset=li.offset - ((int)ins.offset + ins.getBytes().length);
}
ins.operands[oi.insOperandIndex]=relOffset;
}
}
}
body.exceptions=new ABCException[exceptions.size()];
for (int e=0; e < exceptions.size(); e++) {
body.exceptions[e]=exceptions.get(e);
}
info.param_types=new int[paramTypes.size()];
for (int i=0; i < paramTypes.size(); i++) {
info.param_types[i]=paramTypes.get(i);
}
if (info.flagHas_paramnames()) {
info.paramNames=new int[paramNames.size()];
for (int i=0; i < paramNames.size(); i++) {
info.paramNames[i]=paramNames.get(i);
}
}
if (info.flagHas_optional()) {
info.optional=new ValueKind[optional.size()];
for (int i=0; i < optional.size(); i++) {
info.optional[i]=optional.get(i);
}
}
return code;
}",0.9802067946824224
61993,"public static ValueKind parseValue(ConstantPool constants,Flasm3Lexer lexer) throws IOException, ParseException {
  ParsedSymbol type=lexer.lex();
  ParsedSymbol value;
  int value_index=0;
  int value_kind=0;
switch (type.type) {
case ParsedSymbol.TYPE_KEYWORD_INTEGER:
    value_kind=ValueKind.CONSTANT_Int;
  expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
expected(value,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
value_index=constants.getIntId((Long)value.value,true);
break;
case ParsedSymbol.TYPE_KEYWORD_UINTEGER:
value_kind=ValueKind.CONSTANT_UInt;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
expected(value,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
value_index=constants.getUIntId((Long)value.value,true);
break;
case ParsedSymbol.TYPE_KEYWORD_DOUBLE:
value_kind=ValueKind.CONSTANT_Double;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
expected(value,ParsedSymbol.TYPE_FLOAT,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
value_index=constants.getDoubleId((Double)value.value,true);
break;
case ParsedSymbol.TYPE_KEYWORD_UTF8:
value_kind=ValueKind.CONSTANT_Utf8;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
expected(value,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
value_index=constants.getStringId((String)value.value,true);
break;
case ParsedSymbol.TYPE_KEYWORD_TRUE:
value_kind=ValueKind.CONSTANT_True;
break;
case ParsedSymbol.TYPE_KEYWORD_FALSE:
value_kind=ValueKind.CONSTANT_False;
break;
case ParsedSymbol.TYPE_KEYWORD_NULL:
value_kind=ValueKind.CONSTANT_Null;
break;
case ParsedSymbol.TYPE_KEYWORD_NAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_PACKAGEINTERNALNS:
case ParsedSymbol.TYPE_KEYWORD_PROTECTEDNAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_EXPLICITNAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_STATICPROTECTEDNS:
case ParsedSymbol.TYPE_KEYWORD_PRIVATENAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_PACKAGENAMESPACE:
switch (type.type) {
case ParsedSymbol.TYPE_KEYWORD_NAMESPACE:
value_kind=ValueKind.CONSTANT_Namespace;
break;
case ParsedSymbol.TYPE_KEYWORD_PACKAGEINTERNALNS:
value_kind=ValueKind.CONSTANT_PackageInternalNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PROTECTEDNAMESPACE:
value_kind=ValueKind.CONSTANT_ProtectedNamespace;
break;
case ParsedSymbol.TYPE_KEYWORD_EXPLICITNAMESPACE:
value_kind=ValueKind.CONSTANT_ExplicitNamespace;
break;
case ParsedSymbol.TYPE_KEYWORD_STATICPROTECTEDNS:
value_kind=ValueKind.CONSTANT_StaticProtectedNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PRIVATENAMESPACE:
value_kind=ValueKind.CONSTANT_PrivateNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PACKAGENAMESPACE:
value_kind=ValueKind.CONSTANT_PackageNamespace;
break;
}
lexer.pushback(type);
value_index=parseNamespace(constants,lexer);
break;
}
return new ValueKind(value_index,value_kind);
}","public static ValueKind parseValue(ConstantPool constants,Flasm3Lexer lexer) throws IOException, ParseException {
  ParsedSymbol type=lexer.lex();
  ParsedSymbol value;
  int value_index=0;
  int value_kind=0;
switch (type.type) {
case ParsedSymbol.TYPE_KEYWORD_INTEGER:
    value_kind=ValueKind.CONSTANT_Int;
  expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
if (value.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
value_index=0;
}
 else {
expected(value,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
value_index=constants.getIntId((Long)value.value,true);
}
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_UINTEGER:
value_kind=ValueKind.CONSTANT_UInt;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
if (value.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
value_index=0;
}
 else {
expected(value,ParsedSymbol.TYPE_INTEGER,""String_Node_Str"");
value_index=constants.getUIntId((Long)value.value,true);
}
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_DOUBLE:
value_kind=ValueKind.CONSTANT_Double;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
if (value.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
value_index=0;
}
 else {
expected(value,ParsedSymbol.TYPE_FLOAT,""String_Node_Str"");
value_index=constants.getDoubleId((Double)value.value,true);
}
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
break;
case ParsedSymbol.TYPE_KEYWORD_UTF8:
value_kind=ValueKind.CONSTANT_Utf8;
expected(ParsedSymbol.TYPE_PARENT_OPEN,""String_Node_Str"",lexer);
value=lexer.lex();
if (value.type == ParsedSymbol.TYPE_KEYWORD_NULL) {
value_index=0;
}
 else {
expected(value,ParsedSymbol.TYPE_STRING,""String_Node_Str"");
expected(ParsedSymbol.TYPE_PARENT_CLOSE,""String_Node_Str"",lexer);
value_index=constants.getStringId((String)value.value,true);
}
break;
case ParsedSymbol.TYPE_KEYWORD_TRUE:
value_kind=ValueKind.CONSTANT_True;
break;
case ParsedSymbol.TYPE_KEYWORD_FALSE:
value_kind=ValueKind.CONSTANT_False;
break;
case ParsedSymbol.TYPE_KEYWORD_NULL:
value_kind=ValueKind.CONSTANT_Null;
break;
case ParsedSymbol.TYPE_KEYWORD_NAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_PACKAGEINTERNALNS:
case ParsedSymbol.TYPE_KEYWORD_PROTECTEDNAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_EXPLICITNAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_STATICPROTECTEDNS:
case ParsedSymbol.TYPE_KEYWORD_PRIVATENAMESPACE:
case ParsedSymbol.TYPE_KEYWORD_PACKAGENAMESPACE:
switch (type.type) {
case ParsedSymbol.TYPE_KEYWORD_NAMESPACE:
value_kind=ValueKind.CONSTANT_Namespace;
break;
case ParsedSymbol.TYPE_KEYWORD_PACKAGEINTERNALNS:
value_kind=ValueKind.CONSTANT_PackageInternalNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PROTECTEDNAMESPACE:
value_kind=ValueKind.CONSTANT_ProtectedNamespace;
break;
case ParsedSymbol.TYPE_KEYWORD_EXPLICITNAMESPACE:
value_kind=ValueKind.CONSTANT_ExplicitNamespace;
break;
case ParsedSymbol.TYPE_KEYWORD_STATICPROTECTEDNS:
value_kind=ValueKind.CONSTANT_StaticProtectedNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PRIVATENAMESPACE:
value_kind=ValueKind.CONSTANT_PrivateNs;
break;
case ParsedSymbol.TYPE_KEYWORD_PACKAGENAMESPACE:
value_kind=ValueKind.CONSTANT_PackageNamespace;
break;
}
lexer.pushback(type);
value_index=parseNamespace(constants,lexer);
break;
}
return new ValueKind(value_index,value_kind);
}",0.8903603326147213
61994,"@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,20 * font.nominalSize,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode >= code) {
      if (font.glyphInfo.get(i).glyphCode == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
  }
  Font fnt=new Font(fontName,fontStyle,20 * font.nominalSize);
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  if (!exists) {
    font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
    shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  }
 else {
    font.glyphInfo.set(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.set(pos,new GlyphType(shp.shapeRecords));
    shapeCache.set(pos,font.glyphs.get(pos).toSHAPE());
  }
  imageCache.remove(""String_Node_Str"" + fontId);
}","@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,20 * font.nominalSize,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode >= code) {
      if (font.glyphInfo.get(i).glyphCode == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
  }
  Font fnt=new Font(fontName,fontStyle,font.nominalSize);
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  if (!exists) {
    font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
    shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  }
 else {
    font.glyphInfo.set(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.set(pos,new GlyphType(shp.shapeRecords));
    shapeCache.set(pos,font.glyphs.get(pos).toSHAPE());
  }
  imageCache.remove(""String_Node_Str"" + fontId);
}",0.9981195938322678
61995,"private void fontAddChars(FontTag ft,Set<Integer> selChars,String selFont){
  FontTag f=(FontTag)oldValue;
  String oldchars=f.getCharacters(swf.tags);
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) == -1) {
      Font font=new Font(selFont,f.getFontStyle(),1024);
      if (!font.canDisplay(c)) {
        View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
    }
  }
  String[] yesno=new String[]{translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str"")};
  boolean yestoall=false;
  boolean notoall=false;
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) > -1) {
      int opt;
      if (!(yestoall || notoall)) {
        opt=View.showOptionDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,yesno,translate(""String_Node_Str""));
        if (opt == 2) {
          yestoall=true;
        }
        if (opt == 3) {
          notoall=true;
        }
      }
 else       if (yestoall) {
        opt=0;
      }
 else       if (notoall) {
        opt=1;
      }
 else {
        opt=1;
      }
      if (opt == 1) {
        continue;
      }
    }
    f.addCharacter(swf.tags,c,fontSelection.getSelectedItem().toString());
    oldchars+=c;
  }
}","private void fontAddChars(FontTag ft,Set<Integer> selChars,String selFont){
  FontTag f=(FontTag)oldValue;
  String oldchars=f.getCharacters(swf.tags);
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) == -1) {
      Font font=new Font(selFont,f.getFontStyle(),1024);
      if (!font.canDisplay(c)) {
        View.showMessageDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
    }
  }
  String[] yesno=new String[]{translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str""),translate(""String_Node_Str"")};
  boolean yestoall=false;
  boolean notoall=false;
  for (  int ic : selChars) {
    char c=(char)ic;
    if (oldchars.indexOf((int)c) > -1) {
      int opt;
      if (!(yestoall || notoall)) {
        opt=View.showOptionDialog(null,translate(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"" + c),translate(""String_Node_Str""),JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,yesno,translate(""String_Node_Str""));
        if (opt == 2) {
          yestoall=true;
        }
        if (opt == 3) {
          notoall=true;
        }
      }
      if (yestoall) {
        opt=0;
      }
 else       if (notoall) {
        opt=1;
      }
 else {
        opt=1;
      }
      if (opt == 1) {
        continue;
      }
    }
    f.addCharacter(swf.tags,c,fontSelection.getSelectedItem().toString());
    oldchars+=c;
  }
}",0.998037933289732
61996,"@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,20 * font.nominalSize,character);
  int code=(int)character;
  int pos=-1;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode > code) {
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  FontTag.shiftGlyphIndices(fontId,pos,tags);
  Font fnt=new Font(fontName,fontStyle,20 * font.nominalSize);
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
  font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
  shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  imageCache.remove(""String_Node_Str"" + fontId);
}","@Override public void addCharacter(List<Tag> tags,char character,String fontName){
  int fontStyle=getFontStyle();
  FontType font=fonts.get(0);
  SHAPE shp=SHAPERECORD.systemFontCharacterToSHAPE(fontName,fontStyle,20 * font.nominalSize,character);
  int code=(int)character;
  int pos=-1;
  boolean exists=false;
  for (int i=0; i < font.glyphInfo.size(); i++) {
    if (font.glyphInfo.get(i).glyphCode >= code) {
      if (font.glyphInfo.get(i).glyphCode == code) {
        exists=true;
      }
      pos=i;
      break;
    }
  }
  if (pos == -1) {
    pos=font.glyphInfo.size();
  }
  if (!exists) {
    FontTag.shiftGlyphIndices(fontId,pos,tags);
  }
  Font fnt=new Font(fontName,fontStyle,20 * font.nominalSize);
  int advance=(int)Math.round(fnt.createGlyphVector((new JPanel()).getFontMetrics(fnt).getFontRenderContext(),""String_Node_Str"" + character).getGlyphMetrics(0).getAdvanceX());
  if (!exists) {
    font.glyphInfo.add(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.add(pos,new GlyphType(shp.shapeRecords));
    shapeCache.add(pos,font.glyphs.get(pos).toSHAPE());
  }
 else {
    font.glyphInfo.set(pos,new GlyphInfoType(code,advance,0));
    font.glyphs.set(pos,new GlyphType(shp.shapeRecords));
    shapeCache.set(pos,font.glyphs.get(pos).toSHAPE());
  }
  imageCache.remove(""String_Node_Str"" + fontId);
}",0.8507333908541846
61997,"public static byte[] getTagHeader(Tag tag,byte[] data,int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    SWFOutputStream sos=new SWFOutputStream(baos,version);
    int tagLength=data.length;
    int tagID=tag.getId();
    int tagIDLength=(tagID << 6);
    if ((tagLength < 0x3f) && (!tag.forceWriteAsLong)) {
      tagIDLength+=tagLength;
      sos.writeUI16(tagIDLength);
    }
 else {
      tagIDLength+=0x3f;
      sos.writeUI16(tagIDLength);
      sos.writeSI32(tagLength);
    }
  }
 catch (  IOException iex) {
  }
  return baos.toByteArray();
}","public static byte[] getTagHeader(Tag tag,byte[] data,int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    SWFOutputStream sos=new SWFOutputStream(baos,version);
    int tagLength=data.length;
    int tagID=tag.getId();
    int tagIDLength=(tagID << 6);
    if ((tagLength <= 62) && (!tag.forceWriteAsLong)) {
      tagIDLength+=tagLength;
      sos.writeUI16(tagIDLength);
    }
 else {
      tagIDLength+=0x3f;
      sos.writeUI16(tagIDLength);
      sos.writeSI32(tagLength);
    }
  }
 catch (  IOException iex) {
  }
  return baos.toByteArray();
}",0.7712082262210797
61998,"/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public GFxDefineExternalImage2(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  characterId=sis.readUI32();
  bitmapFormat=sis.readUI16();
  targetWidth=sis.readUI16();
  targetHeight=sis.readUI16();
  int fileNameLen=sis.readUI8();
  fileName=new String(sis.readBytes(fileNameLen));
}","/** 
 * Constructor
 * @param swf
 * @param data Data bytes
 * @param version SWF version
 * @param pos
 * @throws IOException
 */
public GFxDefineExternalImage2(SWF swf,byte[] data,int version,long pos) throws IOException {
  super(swf,ID,""String_Node_Str"",data,pos);
  SWFInputStream sis=new SWFInputStream(new ByteArrayInputStream(data),version);
  characterId=sis.readUI32();
  bitmapFormat=sis.readUI16();
  targetWidth=sis.readUI16();
  targetHeight=sis.readUI16();
  int fileNameLen=sis.readUI8();
  fileName=new String(sis.readBytes(fileNameLen));
  if (sis.available() > 0) {
    extraData=sis.readBytes(sis.available());
  }
}",0.9337803855825648
61999,"/** 
 * Gets data bytes
 * @param version SWF version
 * @return Bytes of data
 */
@Override public byte[] getData(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,version);
  try {
    sos.writeUI32(characterId);
    sos.writeUI16(bitmapFormat);
    sos.writeUI16(targetWidth);
    sos.writeUI16(targetHeight);
    byte fileNameBytes[]=fileName.getBytes();
    sos.writeUI8(fileNameBytes.length);
    sos.write(fileNameBytes);
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @param version SWF version
 * @return Bytes of data
 */
@Override public byte[] getData(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,version);
  try {
    sos.writeUI32(characterId);
    sos.writeUI16(bitmapFormat);
    sos.writeUI16(targetWidth);
    sos.writeUI16(targetHeight);
    byte fileNameBytes[]=fileName.getBytes();
    sos.writeUI8(fileNameBytes.length);
    sos.write(fileNameBytes);
    if (extraData != null) {
      sos.write(extraData);
    }
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.948905109489051
62000,"/** 
 * Gets data bytes
 * @param version SWF version
 * @return Bytes of data
 */
@Override public byte[] getData(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,version);
  try {
    sos.writeUI16(version);
    if (version >= 0x10a) {
      sos.writeUI32(flags);
    }
    sos.writeUI16(bitmapFormat);
    sos.writeUI8(prefix.length);
    sos.write(prefix);
    byte swfNameBytes[]=swfName.getBytes();
    sos.writeUI8(swfNameBytes.length);
    sos.write(swfNameBytes);
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}","/** 
 * Gets data bytes
 * @param version SWF version
 * @return Bytes of data
 */
@Override public byte[] getData(int version){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  OutputStream os=baos;
  SWFOutputStream sos=new SWFOutputStream(os,version);
  try {
    sos.writeUI16(this.version);
    if (this.version >= 0x10a) {
      sos.writeUI32(flags);
    }
    sos.writeUI16(bitmapFormat);
    sos.writeUI8(prefix.length);
    sos.write(prefix);
    byte swfNameBytes[]=swfName.getBytes();
    sos.writeUI8(swfNameBytes.length);
    sos.write(swfNameBytes);
    if (codeOffsets != null) {
      sos.writeUI16(codeOffsets.size());
      for (      long l : codeOffsets) {
        sos.writeUI32(l);
      }
    }
  }
 catch (  IOException e) {
  }
  return baos.toByteArray();
}",0.8854532677442024
